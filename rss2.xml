<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Tue, 14 May 2024 04:19:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[TypeScript] typeof, instanceof, literal로 타입 보호하기</title>
      <link>http://hgko1207.github.io/2024/05/13/typescript-23/</link>
      <guid>http://hgko1207.github.io/2024/05/13/typescript-23/</guid>
      <pubDate>Mon, 13 May 2024 04:24:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;타입을 보호하는 기술을 익혀 코드의 견고성을 강화하는 여정을 시작하겠습니다. typeof, instanceof, literal을 사용하면 정
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-22.png" alt=""></p><p>타입을 보호하는 기술을 익혀 코드의 견고성을 강화하는 여정을 시작하겠습니다. typeof, instanceof, literal을 사용하면 정확한 타입을 적용하고 타입스크립트 프로젝트 초기에 잠재적인 오류를 잡아낼 수 있는 힘을 얻을 수 있습니다. 이러한 기술을 자세히 살펴보면서 의도하지 않은 동작으로부터 코드를 강화하고 더 높은 수준의 유형 안전을 달성하는 방법을 알아보세요.</p><h2 id="typeof"><code>typeof</code></h2><p><code>typeof</code> 연산자를 사용하면 값이나 변수의 유형을 확인할 수 있습니다. 타입 가드에서 타입을 좁히기 위해 자주 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params">message: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> message === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 이 블록 내에서 TypeScript는 'message'가 'string' 유형임을 알고 있습니다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(message.toUpperCase());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 이 블록 안에서, 타입스크립트는 'message'의 타입이 'number'라는 것을 알고 있습니다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(message.toFixed(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof"><code>instanceof</code></h2><p><code>instanceof</code> 연산자는 객체가 특정 클래스 또는 생성자 함수의 인스턴스인지 여부를 확인합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Woof!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat &#123;</span><br><span class="line">  meow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Meow!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">petSound</span>(<span class="params">animal: Dog | Cat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="comment">// 이 블록 안에서, 타입스크립트는 'animal'이 'Dog' 타입임을 알고 있습니다.</span></span><br><span class="line">    animal.bark();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 이 블록 안에서, 타입스크립트는 'animal'이 'Cat' 타입임을 알고 있습니다.</span></span><br><span class="line">    animal.meow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Literal-Types">Literal Types</h2><p>TypeScript의 Literal 타입을 사용하면 변수의 정확한 값을 지정할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStatus</span>(<span class="params">status: 'success' | 'error' | 'pending'</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'status'는 리터럴 타입 'success', 'error' 또는 'pending'으로 좁혀집니다.</span></span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'success'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Operation succeeded!'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'error'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'An error occurred.'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pending'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Operation is pending.'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서 <code>status</code> 매개변수는 지정된 리터럴 값 중 하나만 가질 수 있습니다.</p><h2 id="마무리">마무리</h2><p>이러한 기술을 사용하면 TypeScript가 조건부 블록 내에서 보다 구체적인 유형을 이해하고 적용하여 코드의 유형 안전성을 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/13/typescript-23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Indexed Access Types 및 Mapped Types</title>
      <link>http://hgko1207.github.io/2024/05/09/typescript-22/</link>
      <guid>http://hgko1207.github.io/2024/05/09/typescript-22/</guid>
      <pubDate>Thu, 09 May 2024 04:16:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 TypeScript의 타입 시스템을 크게 향상시키는 두 가지 강력한 기능을 살펴보는 여정을 시작합니다.&lt;/p&gt;
&lt;h2 id
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-22.png" alt="" /></p><p>이번 글에서는 TypeScript의 타입 시스템을 크게 향상시키는 두 가지 강력한 기능을 살펴보는 여정을 시작합니다.</p><h2 id="indexed-access-types"><a class="markdownIt-Anchor" href="#indexed-access-types"></a> Indexed Access Types</h2><p>조회 타입이라고도 하는 인덱싱된 액세스 타입을 사용하면 키를 기반으로 객체에서 프로퍼티 타입을 조회할 수 있습니다. 이 구문은 대괄호 안에 키 타입이 들어 있는 대괄호를 사용합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  city: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AgeType = Person[<span class="string">'age'</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Person['age']</code>는 <code>Person</code> 타입에서 ‘age’ 속성의 타입을 검색합니다.</p><h2 id="mapped-types"><a class="markdownIt-Anchor" href="#mapped-types"></a> Mapped Types</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">  option1: <span class="built_in">boolean</span>;</span><br><span class="line">  option2: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NullableFlags = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof Flags]: <span class="built_in">boolean</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result: &#123; option1: boolean | null, option2: boolean | null &#125;</span></span><br></pre></td></tr></table></figure><p>여기서 <code>NullableFlags</code>는 <code>Flags</code>의 각 프로퍼티를 <code>null</code>을 허용하도록 변환합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/09/typescript-22/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 엄격한 타입 검사, 고급 컴파일러 옵션</title>
      <link>http://hgko1207.github.io/2024/05/09/typescript-21/</link>
      <guid>http://hgko1207.github.io/2024/05/09/typescript-21/</guid>
      <pubDate>Wed, 08 May 2024 15:41:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;타입스크립트의 강점은 표현력이 풍부한 구문뿐만 아니라 강력한 타입 검사 및 컴파일 옵션에도 있습니다. 이번 글에서는 엄격한 타입 검사 및
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-21.png" alt="" /></p><p>타입스크립트의 강점은 표현력이 풍부한 구문뿐만 아니라 강력한 타입 검사 및 컴파일 옵션에도 있습니다. 이번 글에서는 엄격한 타입 검사 및 고급 컴파일러 옵션에 대해 집중적으로 살펴봅니다. 이러한 기능은 코드 품질을 높이고, 잠재적인 오류를 조기에 발견하며, 컴파일 프로세스를 미세 조정하는 데 도움이 됩니다. 타입 안전성을 보장하고 TypeScript 워크플로를 최적화하는 미묘한 차이를 알아보는 여정에 함께하세요.</p><h2 id="엄격한-타입-검사strict-type-checking"><a class="markdownIt-Anchor" href="#엄격한-타입-검사strict-type-checking"></a> 엄격한 타입 검사(Strict Type Checking)</h2><p>엄격한 타입 검사를 사용하려면 컴파일 시 일반적인 프로그래밍 오류를 포착하는 데 도움이 되는 여러 가지 TypeScript 컴파일러 옵션을 사용 설정해야 합니다. 엄격한 타입 검사를 사용하려면 몇 가지 하위 옵션이 포함된 <code>--strict</code> 플래그를 사용하면 됩니다.</p><ul><li><code>--strictNullChecks</code>: 변수의 타입에서 명시적으로 허용하지 않는 한 변수가 null 또는 정의되지 않은 상태로 할당되지 않도록 합니다.</li><li><code>--strictFunctionTypes</code>: 함수 매개변수 타입과 반환 타입을 보다 엄격하게 검사합니다.</li><li><code>--strictPropertyInitialization</code>: 모든 클래스 프로퍼티가 생성자에서 초기화되도록 합니다.</li><li><code>--strictBindCallApply</code>: 함수의 바인드, 호출 및 적용 메서드를 더 엄격하게 검사합니다.</li></ul><p>이러한 옵션을 활성화하려면 다음 컴파일러 명령을 사용하면 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --strict tsfile.ts</span><br></pre></td></tr></table></figure><p>또는 <code>tsconfig.json</code>에서 설정할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictFunctionTypes"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictPropertyInitialization"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictBindCallApply"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="고급-컴파일러-옵션advanced-compiler-option"><a class="markdownIt-Anchor" href="#고급-컴파일러-옵션advanced-compiler-option"></a> 고급 컴파일러 옵션(Advanced Compiler Option)</h2><p>엄격한 타입 검사 외에도 TypeScript는 컴파일러의 동작을 미세 조정할 수 있는 다양한 고급 컴파일러 옵션을 제공합니다. 주목할 만한 옵션은 다음과 같습니다.</p><ul><li><code>--target</code>: 생성된 JavaScript 코드의 ECMAScript 대상 버전을 지정합니다(예: “es5”, “es6”).</li><li><code>--module</code>: 생성된 JavaScript 코드에서 사용할 모듈 시스템을 지정합니다(예: “commonjs”, “amd”, “es6”).</li><li><code>--esModuleInterop</code>: CommonJS 모듈과의 호환성을 활성화하고 기본 내보내기가 없는 모듈에서 기본 가져오기를 허용합니다.</li><li><code>--declaration</code>: 해당 <code>.d.ts</code> 선언 파일을 생성합니다.</li><li><code>--sourceMap</code>: 더 나은 디버깅 지원을 위해 소스 맵 파일을 생성합니다.</li><li><code>--noEmitOnError</code>: 컴파일 오류가 있는 경우 TypeScript가 JavaScript 파일을 내보내지 않도록 합니다.</li></ul><p>이러한 옵션은 <code>tsconfig.json</code> 파일에서 구성할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"noEmitOnError"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 옵션을 사용하면 TypeScript가 코드를 트랜스파일하는 방식을 제어하여 호환성을 보장하고 선언 파일을 생성하며 디버깅 프로세스를 지원할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/09/typescript-21/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2024년을 위한 WPF 개발 모범 사례</title>
      <link>http://hgko1207.github.io/2024/05/07/wpf-1/</link>
      <guid>http://hgko1207.github.io/2024/05/07/wpf-1/</guid>
      <pubDate>Tue, 07 May 2024 05:57:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;소프트웨어 개발은 매우 역동적이며 프로그램 내에서 효율성을 유지하면서 자신의 스타일을 적응하고 개선하는 데 개방적인 사람들에게 유리합니다.&lt;/p&gt;
&lt;p&gt;.NET 개발자에게 &lt;strong&gt;Windows Presentation Foundation&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>소프트웨어 개발은 매우 역동적이며 프로그램 내에서 효율성을 유지하면서 자신의 스타일을 적응하고 개선하는 데 개방적인 사람들에게 유리합니다.</p><p>.NET 개발자에게 <strong>Windows Presentation Foundation</strong>(WPF)은 여전히 강력한 데스크톱 애플리케이션을 빌드하는 데 가장 적합한 도구 중 하나입니다. 2024년에 점점 더 가까워지는 지금, 이 기회에 WPF를 더 효과적으로 사용할 수 있는 가장 중요한 모범 사례 몇 가지를 살펴보세요!</p><h2 id="최신-상태로-유지하여-net-발전-수용하기"><a class="markdownIt-Anchor" href="#최신-상태로-유지하여-net-발전-수용하기"></a> 최신 상태로 유지하여 .NET 발전 수용하기</h2><p>.NET 프레임워크에 도입된 최신 기능과 향상된 기능을 활용하여 기술의 최전선에 서세요. .NET은 매년 더 나은 성능, 보안 및 언어 기능을 제공하기 위해 계속 발전하고 있습니다. 최신 .NET 버전을 구현하여 이러한 개선 사항의 이점을 활용하면 WPF 프로젝트에 큰 도움이 될 것입니다.</p><h2 id="비동기-프로그래밍을-사용한-반응형-ui"><a class="markdownIt-Anchor" href="#비동기-프로그래밍을-사용한-반응형-ui"></a> 비동기 프로그래밍을 사용한 반응형 UI</h2><p>UI는 사용자 경험을 소개하는 가장 중요한 요소이며, 첫인상을 결정짓는 중요한 요소입니다. 비동기 프로그래밍 패턴과 동적 보기를 채택하여 WPF 애플리케이션의 유동성과 반응성을 유지하세요. 비차단 작업에 <code>async</code>/<code>await</code>를 사용하면 UI가 멈추는 것을 방지하고 전반적인 사용자 경험을 향상시킬 수 있습니다.</p><h2 id="유지보수성을-위한-mvvm-아키텍처"><a class="markdownIt-Anchor" href="#유지보수성을-위한-mvvm-아키텍처"></a> 유지보수성을 위한 MVVM 아키텍처</h2><p><strong>Model-View-View-Model</strong>(MVVM) 아키텍처 패턴은 여전히 WPF 개발에서 큰 부분을 차지합니다. MVVM을 토폴로지에 도입하여 문제를 분리하고, 테스트 가능성을 높이고, 유지 관리를 간소화하세요. Visual Studio와 같은 도구는 처음부터 MVVM 구조를 스캐폴딩할 수 있도록 지원하므로 팀과 프로젝트의 모범 사례에 따라 쉽게 구현할 수 있습니다.</p><h2 id="선언적-ui를-위한-xaml-활용"><a class="markdownIt-Anchor" href="#선언적-ui를-위한-xaml-활용"></a> 선언적 UI를 위한 XAML 활용</h2><p><strong>XAML</strong>(eXtensible Application Markup Language)은 WPF에서 선언적 UI를 만들기 위한 강력한 도구입니다. XAML을 사용하여 애플리케이션의 사용자 인터페이스를 정의하면 UI의 가독성과 유지 관리성을 크게 향상시킬 수 있습니다. 이 접근 방식은 팀과 이해관계자 간의 커뮤니케이션을 강화하여 궁극적으로 훨씬 더 효율적인 워크플로우를 제공합니다.</p><h2 id="데이터-바인딩-기법-최적화"><a class="markdownIt-Anchor" href="#데이터-바인딩-기법-최적화"></a> 데이터 바인딩 기법 최적화</h2><p>데이터를 효율적으로 바인딩하는 것은 WPF 인프라에 매우 중요합니다. 애플리케이션의 요구 사항에 따라 적절한 데이터 바인딩 모드(<code>OneTime</code>, <code>OneWay</code>, <code>TwoWay</code>)를 선택하세요. 또한 데이터 유효성 검사 및 <code>INotifyPropertyChanged</code>와 같은 기능을 활용하여 실시간 업데이트를 보장하고 데이터 무결성을 유지할 수 있습니다. 많은 경우 복잡한 C# 컨버터를 작성하지 않아도 되는 WPF BindingExpressions 라이브러리를 사용하면 MVVM 애플리케이션에서 데이터 바인딩을 더욱 쉽게 수행할 수 있습니다.</p><h2 id="종속성-주입-수용"><a class="markdownIt-Anchor" href="#종속성-주입-수용"></a> 종속성 주입 수용</h2><p>종속성 주입(DI)은 모듈화되고 유지 관리 가능한 코드를 장려하는 모범 사례입니다. Microsoft.Extensions.DependencyInjection과 같은 DI 프레임워크를 사용하여 WPF 애플리케이션의 종속성을 관리하세요. 이렇게 하면 테스트 가능성, 유연성 및 전반적인 코드 품질이 향상됩니다.</p><h2 id="필요한-사용자를-위한-접근성-우선-순위-지정"><a class="markdownIt-Anchor" href="#필요한-사용자를-위한-접근성-우선-순위-지정"></a> 필요한 사용자를 위한 접근성 우선 순위 지정</h2><p>포용적 디자인은 다양한 사용자 요구를 충족하는 애플리케이션을 만드는 데 있어 기본입니다. 장애가 있거나 특별한 요청이 필요한 사용자가 WPF 애플리케이션에 액세스할 수 있는지 확인해야 합니다. WPF의 기본 제공 접근성 기능을 사용하고 접근성 표준을 준수하여 더 많은 사용자가 애플리케이션을 사용할 수 있도록 하세요.</p><h2 id="스타일-및-템플릿으로-프로그레시브-ui-구현"><a class="markdownIt-Anchor" href="#스타일-및-템플릿으로-프로그레시브-ui-구현"></a> 스타일 및 템플릿으로 프로그레시브 UI 구현</h2><p>미리 빌드된 스타일과 템플릿을 사용하여 시각적으로 매력적이고 일관된 사용자 인터페이스를 제작하세요. 애플리케이션 전반에 걸쳐 일관된 디자인 언어를 만들어 사용자의 인지도와 전반적인 만족도를 향상시키세요. WPF의 스타일 지정 기능을 사용하면 프로젝트에 필요한 보다 현대적이고 직관적인 UI를 구현할 수 있습니다.</p><h2 id="라이브-비주얼-트리로-디버깅-향상"><a class="markdownIt-Anchor" href="#라이브-비주얼-트리로-디버깅-향상"></a> 라이브 비주얼 트리로 디버깅 향상</h2><p>디버깅은 개발 프로세스에서 매우 중요한 부분입니다. Visual Studio의 라이브 비주얼 트리와 같은 유용한 도구를 활용하여 실행 중인 WPF 애플리케이션의 시각적 구조를 자세히 조사할 수 있습니다. 이 기능은 UI 계층 구조에 대한 실시간 인사이트를 제공하여 문제를 빠르게 식별하고 해결하는 데 도움이 됩니다.</p><h2 id="보안-의식-유지"><a class="markdownIt-Anchor" href="#보안-의식-유지"></a> 보안 의식 유지</h2><p>소프트웨어 개발에서 보안은 타협할 수 없는 부분입니다. WPF 애플리케이션 보안을 위한 업계 모범 사례를 따르세요. 중요한 정보를 암호화하고, 사용자 입력의 유효성을 검사하고, .NET 프레임워크의 최신 보안 업데이트에 대한 정보를 지속적으로 확인하세요. 빠르고 유연한 내부 및 외부 보고를 통해 규제 기관과 보조를 맞추세요.</p><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>.NET 개발자는 2024년에 주목할 만한 WPF 개발에 더욱 도전하게 될 것입니다. 이러한 모범 사례를 채택하면 보다 효율적이고 유지 관리가 쉬우며 사용자 친화적인 애플리케이션을 개발할 수 있을 것입니다. 최신 기술을 최신 상태로 유지하고 이러한 지침을 워크플로에 통합하면 끊임없이 진화하는 세상에서 WPF 개발 기술을 마스터하는 데 도움이 될 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/07/wpf-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Google에서 1위를 차지하기 위한 10가지 ChatGPT 프롬프트</title>
      <link>http://hgko1207.github.io/2024/05/03/chatgpt-24/</link>
      <guid>http://hgko1207.github.io/2024/05/03/chatgpt-24/</guid>
      <pubDate>Fri, 03 May 2024 04:49:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/thumbnail/chatgpt.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 SEO를 위한 뛰어난 도구입니다.&lt;/p&gt;
&lt;p&gt;이 글를 따라 10가지 ChatGPT 프롬프트를 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/thumbnail/chatgpt.png" alt="" /></p><p><strong>ChatGPT</strong>는 SEO를 위한 뛰어난 도구입니다.</p><p>이 글를 따라 10가지 ChatGPT 프롬프트를 통해 SEO를 마스터하여 Google에서 검색 순위 1위를 달성하는 방법을 알아보세요. 지금 바로 매력적인 콘텐츠를 만들어 검색 엔진에 최적화하세요.</p><h2 id="프롬프트-1-google-키워드-플래너를-사용한-키워드-조사-및-분석"><a class="markdownIt-Anchor" href="#프롬프트-1-google-키워드-플래너를-사용한-키워드-조사-및-분석"></a> 프롬프트 1 - Google 키워드 플래너를 사용한 키워드 조사 및 분석</h2><p>Google 키워드 플래너를 사용하여 키워드 조사 및 분석을 수행하여 키워드 난이도가 낮고 관련성이 높은 키워드를 식별하세요. 키워드 데이터가 검색 의도와 순위에 맞게 콘텐츠를 최적화하는 데 어떻게 사용되는지 설명하세요.</p><p><strong>입력:</strong> 키워드 조사 및 분석을 위한 타겟 고객과 업계를 지정하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-2-작가-및-콘텐츠-제작자를-위한-seo-전략"><a class="markdownIt-Anchor" href="#프롬프트-2-작가-및-콘텐츠-제작자를-위한-seo-전략"></a> 프롬프트 2 - 작가 및 콘텐츠 제작자를 위한 SEO 전략</h2><p>블로그 가시성과 청중 참여를 높이기 위해 특별히 작가와 콘텐츠 제작자를 위한 SEO 전략을 개발하세요. 블로거의 SEO 성공을 위한 콘텐츠 계획, 키워드 타겟팅, 홍보 전략에 대해 토론하세요.</p><p><strong>입력:</strong> 블로그 주제 또는 틈새 시장, 타겟 고객 인구 통계 및 콘텐츠 홍보 채널을 지정하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-3-기술적-seo-감사-및-최적화"><a class="markdownIt-Anchor" href="#프롬프트-3-기술적-seo-감사-및-최적화"></a> 프롬프트 3 — 기술적 SEO 감사 및 최적화</h2><p>기술적 SEO 감사를 실시하여 검색 엔진 크롤링 및 색인 생성에 영향을 미치는 [웹사이트] 문제를 파악하고 수정하세요. 사이트 속도 개선, 모바일 친화성, 표준화 등 기술적 SEO 최적화와 관련된 단계를 자세히 설명하세요.</p><p><strong>입력:</strong> 웹사이트의 기술 인프라와 기존의 SEO 문제를 설명하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-4-콘텐츠-갭-분석"><a class="markdownIt-Anchor" href="#프롬프트-4-콘텐츠-갭-분석"></a> 프롬프트 4 - 콘텐츠 갭 분석</h2><p>콘텐츠 격차 분석을 수행하여 SEO에 최적화된 새로운 콘텐츠를 만들 수 있는 기회를 파악하세요. 콘텐츠 격차를 파악하고 관련성 높은 고품질 콘텐츠로 채우는 방법에 대해 토론하세요.</p><p><strong>입력:</strong> 콘텐츠 갭 분석을 위한 콘텐츠 주제 또는 주제와 타겟 키워드를 지정하세요. 이 답변을 제공한 후에는 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-5-백링크를-위한-링크-구축-전략"><a class="markdownIt-Anchor" href="#프롬프트-5-백링크를-위한-링크-구축-전략"></a> 프롬프트 5 - 백링크를 위한 링크 구축 전략</h2><p>권위 있는 웹사이트와 업계 인플루언서로부터 양질의 백링크를 확보하는 데 중점을 둔 링크 구축 전략을 수립하세요. 효과적인 링크 구축 캠페인을 위한 홍보 전략, 콘텐츠 협업 기회, 링크 확보 모범 사례에 대해 논의하세요.</p><p><strong>입력:</strong> 링크 구축 캠페인의 타겟 도메인과 선호하는 아웃리치 방법을 정의하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-6-필러-페이지-모델을-사용한-seo-전략-개발"><a class="markdownIt-Anchor" href="#프롬프트-6-필러-페이지-모델을-사용한-seo-전략-개발"></a> 프롬프트 6 - 필러 페이지 모델을 사용한 SEO 전략 개발</h2><p>기둥 페이지 모델을 활용하여 종합적인 SEO 전략을 개발하세요. 최적의 검색 엔진 가시성을 위해 기둥 콘텐츠와 클러스터 주제를 어떻게 구성하는지 설명하세요.</p><p><strong>입력:</strong> 기둥 페이지 모델을 기반으로 SEO 전략 개발을 위한 업계 또는 틈새 시장을 정의하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-7-모바일-seo-최적화-전략"><a class="markdownIt-Anchor" href="#프롬프트-7-모바일-seo-최적화-전략"></a> 프롬프트 7 - 모바일 SEO 최적화 전략</h2><p>모바일 장치에서 사용자 경험과 검색 엔진 가시성을 향상시키기 위한 모바일 SEO 최적화 전략을 개발하세요. 모바일 SEO를 위한 반응형 디자인 원칙, 모바일 친화적인 콘텐츠 형식, 페이지 속도 최적화에 대해 설명하세요.</p><p><strong>입력:</strong> 웹사이트의 현재 모바일 최적화 상태와 개선이 필요한 부분에 대해 자세히 설명하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-8-동영상-seo-최적화-전략"><a class="markdownIt-Anchor" href="#프롬프트-8-동영상-seo-최적화-전략"></a> 프롬프트 8 - 동영상 SEO 최적화 전략</h2><p>동영상 검색 결과에서 가시성과 순위를 높이기 위해 동영상 SEO 최적화 기술을 구현하세요. 동영상 SEO 성공을 위한 동영상 메타데이터 최적화, 썸네일 최적화, 동영상 참여도 측정지표에 대해 논의하세요.</p><p><strong>입력:</strong> SEO 최적화를 위한 동영상 콘텐츠 전략, 타겟 키워드 및 선호하는 동영상 플랫폼에 대한 세부 정보를 제공하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-9-의도-기반-검색을-위한-시맨틱-seo-최적화"><a class="markdownIt-Anchor" href="#프롬프트-9-의도-기반-검색을-위한-시맨틱-seo-최적화"></a> 프롬프트 9 - 의도 기반 검색을 위한 시맨틱 SEO 최적화</h2><p>사용자의 검색 의도 및 시맨틱 검색 알고리즘에 맞게 시맨틱 SEO를 위해 콘텐츠를 최적화하세요. 시맨틱 SEO를 위한 엔티티 기반 최적화, 시맨틱 마크업 및 문맥 관련 콘텐츠의 중요성에 대해 토론하세요.</p><p><strong>입력:</strong> 타겟 고객의 검색 의도와 선호하는 시맨틱 검색 쿼리를 파악하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="프롬프트-10-지리적-가시성을-위한-로컬-seo-최적화"><a class="markdownIt-Anchor" href="#프롬프트-10-지리적-가시성을-위한-로컬-seo-최적화"></a> 프롬프트 10 - 지리적 가시성을 위한 로컬 SEO 최적화</h2><p>지리적 가시성을 개선하고 지역 고객을 유치하기 위해 지역 SEO에 최적화하세요. 지역 검색 순위를 위한 Google 마이 비즈니스, 지역 인용 및 지역 타겟팅 콘텐츠의 중요성에 대해 설명하세요.</p><p><strong>입력:</strong> 지역 SEO 최적화를 위해 타겟 지역 고객과 비즈니스 위치에 대한 세부 정보를 제공하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 10가지 SEO ChatGPT 프롬프트가 일상적인 SEO 작업을 100배 더 효율적으로 완료하는 데 도움이 되길 바랍니다. 이러한 SEO 프롬프트는 디지털 마케터로서의 일상적인 작업을 혁신적으로 개선하여 생산성을 높이고 수많은 시간을 절약할 수 있는 SEO 전문가로 만들어 줄 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/03/chatgpt-24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Namespace, Generic and Custom Module</title>
      <link>http://hgko1207.github.io/2024/05/03/typescript-20/</link>
      <guid>http://hgko1207.github.io/2024/05/03/typescript-20/</guid>
      <pubDate>Fri, 03 May 2024 04:35:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;오늘은 네임스페이스(Namespace), 제네릭(Generic), 사용자 정의 모듈(Custom Module)의 시너지 효과에 대해 알아
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-20.png" alt="" /></p><p>오늘은 네임스페이스(Namespace), 제네릭(Generic), 사용자 정의 모듈(Custom Module)의 시너지 효과에 대해 알아보겠습니다. 이 강력한 도구는 TypeScript 프로젝트에 구조, 유연성 및 모듈성을 제공합니다. 이 시리즈를 살펴보면서 이러한 기능을 결합하여 코드베이스를 효과적으로 구성, 확장 및 확장할 수 있는 방법을 확인하실 수 있습니다.</p><h2 id="namespace"><a class="markdownIt-Anchor" href="#namespace"></a> Namespace</h2><p>TypeScript의 네임스페이스는 로직을 명명된 범위로 캡슐화하여 코드를 구성하는 방법을 제공합니다. 네임스페이스는 이름 충돌을 방지하고 대규모 애플리케이션을 구조화하는 데 유용합니다. 네임스페이스는 네임스페이스 키워드를 사용하여 선언합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Geometry &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 거리 로직 계산</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(point2.x - point1.x, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(point2.y - point1.y, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Geometry.Point = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p2: Geometry.Point = &#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> distance = Geometry.distance(p1, p2);</span><br><span class="line"><span class="built_in">console</span>.log(distance);</span><br></pre></td></tr></table></figure><p>이 예에서 <code>Geometry</code>는 <code>Point</code> 인터페이스와 <code>distance</code> 함수를 포함하는 네임스페이스입니다.</p><h2 id="제네릭"><a class="markdownIt-Anchor" href="#제네릭"></a> 제네릭</h2><p>앞서 언급했듯이 타입스크립트의 제네릭을 사용하면 다양한 데이터 유형에서 작동할 수 있는 함수와 클래스를 작성할 수 있습니다. 제네릭은 유연성과 유형 안전성을 제공합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello, TypeScript!'</span>);</span><br><span class="line"><span class="comment">// 결과는 문자열 타입입니다.</span></span><br></pre></td></tr></table></figure><h2 id="사용자-정의-모듈"><a class="markdownIt-Anchor" href="#사용자-정의-모듈"></a> 사용자 정의 모듈</h2><p>사용자 정의 모듈은 코드를 별도의 파일로 구성하고 각 파일에 모듈을 포함하는 것을 말합니다. 모듈은 모듈식 유지 관리가 가능한 코드베이스를 만드는 데 도움이 됩니다.</p><p>두 개의 파일이 있다고 가정해 보겠습니다.</p><p><code>math.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add, subtract &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> difference = subtract(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// Output: 8</span></span><br><span class="line"><span class="built_in">console</span>.log(difference); <span class="comment">// Output: 2</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>math.ts</code>는 덧셈과 뺄셈 함수가 포함된 모듈입니다. <code>app.ts</code> 파일은 이러한 함수를 가져와 사용합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 개념을 결합하면 체계적이고 유연한 타입스크립트 애플리케이션을 구축할 수 있습니다. 네임스페이스는 파일 내에서 코드를 구조화하는 데 도움이 되고, 제네릭은 유연성을 제공하며, 모듈은 여러 파일에 걸쳐 조직화를 가능하게 합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/03/typescript-20/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Generic, Type Guard, Signature 및 Overload</title>
      <link>http://hgko1207.github.io/2024/05/02/typescript-19/</link>
      <guid>http://hgko1207.github.io/2024/05/02/typescript-19/</guid>
      <pubDate>Thu, 02 May 2024 01:47:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 제네릭(Generic), 타입 가드(Type Guard), 서명(Signature) 및 오버로드(Overload)의 영역을 살
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-19.png" alt=""></p><p>이번 글에서는 제네릭(Generic), 타입 가드(Type Guard), 서명(Signature) 및 오버로드(Overload)의 영역을 살펴봅니다. 이러한 개념은 유연하고 재사용 가능하며 타입이 안전한 코드를 만들기 위한 기본 구성 요소입니다. 이 시리즈를 진행하면서 이러한 기능이 어떻게 강력하고 유지 관리가 쉬운 TypeScript 애플리케이션을 만드는 데 중추적인 역할을 하는지 알아볼 수 있습니다.</p><h2 id="제네릭">제네릭</h2><p>TypeScript의 제네릭을 사용하면 타입을 매개변수로 전달할 수 있어 재사용 가능한 type-safe 함수 및 클래스를 만들 수 있습니다. 이를 통해 다양한 데이터 타입에서 작동할 수 있는 함수나 클래스를 작성할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello, TypeScript!'</span>);</span><br><span class="line"><span class="comment">// result is of type string</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>identity</code> 함수는 T 타입에 대해 제네릭이므로 모든 타입에서 작동할 수 있습니다.</p><h2 id="타입-가드">타입 가드</h2><p>타입 가드는 특정 코드 블록 내에서 변수의 타입을 좁히는 방법입니다. 런타임 검사를 기반으로 타입별 연산을 수행하기 위해 유니온(union) 타입과 함께 자주 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">value</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'string'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span> = <span class="string">'Hello, TypeScript!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isString(x)) &#123;</span><br><span class="line">  <span class="comment">// 이 블록 내에서, 타입스크립트는 x가 문자열이라는 것을 알고 있습니다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(x.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isString</code> 함수는 조건부 블록 내에서 타입스크립트가 <code>x</code>의 타입을 이해하는 데 도움이 되는 타입 가드입니다.</p><h2 id="Signature">Signature</h2><p>TypeScript에서 함수 서명은 매개변수의 타입과 함수의 반환 타입을 설명합니다. 여기에는 매개변수 이름, 타입 및 반환 타입이 포함됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MathOperation = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add: MathOperation = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> subtract: MathOperation = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br></pre></td></tr></table></figure><p>여기서 <code>MathOperation</code>은 두 개의 숫자를 취하고 숫자를 반환하는 함수를 나타내는 타입입니다. <code>add</code>와 <code>subtract</code> 모두 이 서명을 준수하는 함수입니다.</p><h2 id="Overload">Overload</h2><p>함수 오버로드를 사용하면 단일 함수에 대해 여러 타입 서명을 제공할 수 있습니다. 이는 인수의 타입이나 수에 따라 함수가 다르게 동작할 때 특히 유용합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;person&#125;</span>! You are <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;person&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서 <code>greet</code> 함수에는 서로 다른 매개변수 타입을 지정하는 두 개의 오버로드가 있습니다. 실제 구현은 이러한 오버로드를 따르고 그에 따라 다양한 경우를 처리합니다.</p><h2 id="결론">결론</h2><p>이러한 개념은 TypeScript에서 유연하고 유형이 안전한 코드를 작성하기 위한 강력한 도구 세트를 제공합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/05/02/typescript-19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 고급 타입, 매핑된 타입, keyof/typeof</title>
      <link>http://hgko1207.github.io/2024/04/30/typescript-18/</link>
      <guid>http://hgko1207.github.io/2024/04/30/typescript-18/</guid>
      <pubDate>Tue, 30 Apr 2024 02:41:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이 글에서는 고급 타입, 매핑된 타입, 강력한 keyof/typeof 연산자를 살펴봅니다. TypeScript의 표현형 타이핑 시스템의 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-18.png" alt="" /></p><p>이 글에서는 고급 타입, 매핑된 타입, 강력한 keyof/typeof 연산자를 살펴봅니다. TypeScript의 표현형 타이핑 시스템의 중추라고 할 수 있는 이러한 기능을 사용하면 정교하고 정확한 타입 정의를 생성하여 코드를 새로운 차원으로 끌어올릴 수 있습니다.</p><h2 id="고급-타입"><a class="markdownIt-Anchor" href="#고급-타입"></a> 고급 타입</h2><p>TypeScript에서 &quot;advanced types&quot;은 일반적으로 더 복잡한 타입 정의를 만들 수 있는 기능과 구성을 의미합니다. 고급 타입의 몇 가지 예로는 Union 타입, Intersection 타입, Conditional 타입, Mapped 타입 등이 있습니다.</p><h3 id="union-type"><a class="markdownIt-Anchor" href="#union-type"></a> Union Type</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyUnion = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>Union 타입은 여러 타입 중 하나가 될 수 있는 값을 설명합니다. 세로 막대(<code>|</code>)를 사용하여 각 타입을 구분하므로 <code>string | number</code>는 <code>string</code> 또는 <code>number</code>가 될 수 있는 값의 타입입니다.</p><h3 id="intersection-type"><a class="markdownIt-Anchor" href="#intersection-type"></a> Intersection Type</h3><p>교차(Intersection) 타입은 여러 타입을 하나로 결합합니다. 이를 통해 기존 타입을 합쳐서 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있으므로 MyIntersection은 <code>prop1</code>과 <code>prop2</code>를 포함하는 객체를 기대하는 타입입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyIntersection = &#123; prop1: <span class="built_in">string</span> &#125; &amp; &#123; prop2: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="conditional-type"><a class="markdownIt-Anchor" href="#conditional-type"></a> Conditional Type</h3><p>이 타입은 제네릭 매개변수를 받아 <code>T</code>가 <code>string</code>을 확장하는지 확인합니다. <code>T</code>가 <code>string</code>을 확장하면 타입은 <code>&quot;string type&quot;</code>으로 평가되고, 그렇지 않으면 <code>&quot;non-string type&quot;</code>으로 평가됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyConditional&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'string type'</span> : <span class="string">'non-string type'</span>;</span><br></pre></td></tr></table></figure><h3 id="mapped-type"><a class="markdownIt-Anchor" href="#mapped-type"></a> Mapped Type</h3><p>Mapped 타입을 사용하면 기존 타입의 속성을 변환하여 새로운 타입을 만들 수 있습니다. 일반적인 구문은 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: SomeTransformation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionalProps&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 <code>OptionalProps</code>는 (<code>?</code>) 프로퍼티를 사용하여 <code>T</code>의 모든 프로퍼티를 옵션으로 만듭니다.</p><h2 id="keyof"><a class="markdownIt-Anchor" href="#keyof"></a> <code>keyof</code></h2><p><code>keyof</code>는 객체 타입의 모든 키의 합집합 타입을 생성하는 타입스크립트 연산자입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyKeys = keyof &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// MyKeys is "name" | "age"</span></span><br></pre></td></tr></table></figure><h2 id="typeof"><a class="markdownIt-Anchor" href="#typeof"></a> <code>typeof</code></h2><p><code>typeof</code>는 값, 변수 또는 표현식의 타입을 반환하는 연산자입니다. 종종 <code>keyof</code>와 함께 사용하여 타입의 키를 가져오는 데 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; name: <span class="string">'John'</span>, age: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonKeys = keyof <span class="keyword">typeof</span> person;</span><br><span class="line"><span class="comment">// PersonKeys is "name" | "age"</span></span><br></pre></td></tr></table></figure><p>이러한 개념은 종종 타입스크립트에서 강력하고 표현력이 풍부한 타입 정의를 만드는 데 함께 사용됩니다. 이를 통해 데이터를 모델링하고 코드에서 타입 안전을 강화할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/30/typescript-18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알아야 할 13가지 HTML 속성</title>
      <link>http://hgko1207.github.io/2024/04/29/web-8/</link>
      <guid>http://hgko1207.github.io/2024/04/29/web-8/</guid>
      <pubDate>Mon, 29 Apr 2024 01:56:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;에서 속성은 HTML 요소에 대한 추가 정보를 제공하는 데 사용됩니다. 이 글에서는 웹사이트의 시각적 매력을 향상시킬
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-8.png" alt=""></p><p><strong>HTML</strong>에서 속성은 HTML 요소에 대한 추가 정보를 제공하는 데 사용됩니다. 이 글에서는 웹사이트의 시각적 매력을 향상시킬 수 있는 13가지 HTML 속성에 대해 알아봅니다.</p><h2 id="Accept">Accept</h2><p><code>accept</code> 속성을 <code>&lt;input&gt;</code> 요소(파일 유형에만 해당)와 함께 사용하여 서버가 허용할 수 있는 파일 유형을 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">".jpg, .jpeg, .png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Alt">Alt</h2><p><code>alt</code> 속성을 <code>&lt;img&gt;</code> 요소와 함께 사용하여 웹 페이지에 이미지를 표시할 수 없는 경우 대체 텍스트를 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"nature.png"</span> <span class="attr">alt</span>=<span class="string">"A beautiful sunset"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Autocomplete">Autocomplete</h2><p><code>autocomplete</code> 속성을 <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code> 및 <code>&lt;textarea&gt;</code> 요소와 함께 사용하여 브라우저의 자동 완성 기능을 제어할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Contenteditable">Contenteditable</h2><p><code>Contenteditable</code> 속성을 사용하여 요소의 콘텐츠가 편집 가능한지 여부를 지정할 수 있습니다. 이를 통해 사용자는 요소 내의 콘텐츠를 수정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span>You can edit this content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다.</p><h2 id="Download">Download</h2><p><code>download</code> 속성을 <code>&lt;a&gt;</code> 요소와 함께 사용하여 사용자가 링크를 클릭할 때 링크된 리소스를 탐색하는 대신 다운로드하도록 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">download</span>=<span class="string">"document.pdf"</span>&gt;</span>Download PDF<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Hidden">Hidden</h2><p><code>hidden</code> 속성을 사용하여 웹 페이지에서 요소를 숨길 수 있습니다. 이 속성은 JavaScript 또는 CSS를 통해 표시 여부를 제어할 때 유용합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span>This is hidden content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다.</p><h2 id="Loading">Loading</h2><p><code>&lt;img&gt;</code> 요소와 함께 <code>loading</code> 속성을 사용하여 브라우저에서 이미지를 로드하는 방법을 제어할 수 있습니다. 세 가지 값이 있습니다. “eager”, “lazy”, &quot;auto&quot;의 세 가지 값이 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.png"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Multiple">Multiple</h2><p><code>&lt;input&gt;</code> 및 <code>&lt;select&gt;</code> 요소와 함께 <code>multiple</code> 속성을 사용하여 사용자가 한 번에 여러 값을 선택/입력할 수 있도록 할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"typescript"</span>&gt;</span>TypeScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"rust"</span>&gt;</span>Rust<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Poster">Poster</h2><p><code>&lt;video&gt;</code> 요소와 함께 <code>poster</code> 속성을 사용하여 사용자가 비디오를 재생할 때까지 이미지를 표시할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"image.png"</span> <span class="attr">width</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Readonly">Readonly</h2><p><code>&lt;input&gt;</code> 요소와 함께 <code>readonly</code> 속성을 사용하여 해당 요소가 편집할 수 없는 읽기 전용임을 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"This is readonly."</span> <span class="attr">readonly</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Srcset">Srcset</h2><p><code>&lt;img&gt;</code> 및 <code>&lt;source&gt;</code>(<code>&lt;picture&gt;</code>) 요소와 함께 <code>srcset</code> 속성을 사용하여 이미지 소스 목록을 제공할 수 있습니다. 이렇게 하면 브라우저에서 화면 크기에 따라 다른 이미지를 선택할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">srcset</span>=<span class="string">"image.jpg, image-2x.jpg, image-3x.jpg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spellcheck">Spellcheck</h2><p><code>&lt;input&gt;</code> 요소(비밀번호 아님), 콘텐츠 편집 가능 요소, <code>&lt;textarea&gt;</code> 요소와 함께 <code>spellcheck</code> 속성을 사용하여 브라우저에서 맞춤법 검사를 사용하거나 사용하지 않도록 설정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Title">Title</h2><p><code>title</code> 속성을 사용하여 요소에 대한 추가 정보를 제공할 수 있습니다. 이 정보는 일반적으로 사용자가 요소 위로 마우스를 가져가면 표시됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">title</span>=<span class="string">"Click to download"</span>&gt;</span>Download File<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/29/web-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Meta AI: 페이스북, 인스타그램 등에서의 다목적 AI 비서</title>
      <link>http://hgko1207.github.io/2024/04/22/ai-24/</link>
      <guid>http://hgko1207.github.io/2024/04/22/ai-24/</guid>
      <pubDate>Mon, 22 Apr 2024 04:56:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;메타 플랫폼스(Meta Platforms, 구 Facebook)의 아이디어로 탄생한 Meta AI는 소셜 미디어 세계를 강타했습니다. 대규모 Llama 3 언어 모델을 기반으로 하는 이 무료 가상 비서는 메타 생태계(Facebook, Instag
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>메타 플랫폼스(Meta Platforms, 구 Facebook)의 아이디어로 탄생한 Meta AI는 소셜 미디어 세계를 강타했습니다. 대규모 Llama 3 언어 모델을 기반으로 하는 이 무료 가상 비서는 메타 생태계(Facebook, Instagram, WhatsApp, Messenger) 내에서 정보 및 창의적인 작업을 위한 원스톱 쇼핑을 목표로 합니다.</p><p><img src="/images/header/ai-24.png" alt="" /></p><h2 id="기능"><a class="markdownIt-Anchor" href="#기능"></a> 기능</h2><p>Meta AI가 제공하는 기능은 다음과 같습니다.</p><ul><li><strong>다방면의 어시스턴트:</strong> 친구들과 함께 여행을 조사하는 데 도움이 필요하신가요? 사진 캡션이 마음에 걸리나요? Meta AI는 다양한 작업을 지원할 수 있습니다. 질문에 답하고, 창의적인 글쓰기 프롬프트를 제안하며, 설명을 바탕으로 고유한 이미지를 생성할 수도 있습니다.</li><li><strong>원활한 통합:</strong> 별도의 앱을 다운로드할 필요가 없습니다. Meta AI는 Facebook Messenger, Instagram 채팅, WhatsApp 그룹에 바로 내장되어 있습니다. &quot;@Meta AI&quot;와 요청을 입력하기만 하면 AI 어시스턴트가 바로 작동합니다.</li><li><strong>진화하는 이미지 생성:</strong> Meta AI는 인상적인 이미지 생성 기능을 자랑합니다. &quot;imagine&quot;라는 프롬프트에 원하는 이미지를 설명하기만 하면 됩니다. Meta AI는 사실적인 풍경부터 기발한 생물까지 모든 것을 만들 수 있습니다. 또한, 이제 이미지에 애니메이션을 적용하여 GIF로 변환할 수 있어 창의력을 완전히 새로운 차원으로 끌어올릴 수 있습니다.</li></ul><h2 id="경쟁사와-비교"><a class="markdownIt-Anchor" href="#경쟁사와-비교"></a> 경쟁사와 비교</h2><p>그렇다면 Meta AI는 ChatGPT와 저(Gemini)와 같은 경쟁사와 비교했을 때 어떤 점이 다를까요?</p><ul><li><strong>접근성:</strong> Meta AI의 가장 큰 장점은 Meta의 방대한 사용자 기반과의 통합에 있습니다. 이미 Facebook, WhatsApp 또는 Instagram을 사용 중이라면 추가 계정 없이도 Meta AI에 즉시 액세스할 수 있습니다.</li><li><strong>소셜 상호작용에 초점:</strong> Meta AI는 소셜 미디어 경험을 향상시키기 위해 특별히 설계된 것 같습니다. 그룹 활동 계획부터 채팅을 위한 재미있는 콘텐츠 생성까지, 소셜 서클 내에서 AI 동반자를 원하는 사용자들에게 적합합니다.</li></ul><h2 id="고려사항"><a class="markdownIt-Anchor" href="#고려사항"></a> 고려사항</h2><p>하지만 몇 가지 고려해야 할 사항이 있습니다.</p><ul><li><strong>제한된 가용성:</strong> 현재 Meta AI는 영어와 일부 국가에서만 사용할 수 있습니다.</li><li><strong>개인정보 보호 문제:</strong> AI 비서를 소셜 미디어 플랫폼에 직접 통합하면 일부 사용자에게는 개인정보 보호에 대한 우려가 제기될 수 있습니다. Meta는 개인 메시지와 통화가 암호화된 상태로 유지되도록 보장하지만, Meta AI가 사용자 데이터를 사용하는 방식은 여전히 논의의 여지가 있습니다.</li><li><strong>개발 중:</strong> 다른 새로운 AI 기술과 마찬가지로 Meta AI도 아직 개발 중입니다. 인상적이긴 하지만 때때로 요청을 잘못 해석하거나 무의미한 응답을 생성할 수 있습니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Meta AI는 AI 비서가 온라인 상호작용의 필수적인 부분이 되는 소셜 미디어의 미래를 엿볼 수 있는 기술입니다. 소셜 서클 내에서 재미있고 편리한 AI 동반자를 찾고 있는 메타 사용자라면 Meta AI를 꼭 사용해 볼 가치가 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/22/ai-24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Set/Get, Protected, Private/Public/Static Members</title>
      <link>http://hgko1207.github.io/2024/04/19/typescript-17/</link>
      <guid>http://hgko1207.github.io/2024/04/19/typescript-17/</guid>
      <pubDate>Fri, 19 Apr 2024 01:34:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 set/get, protected, private/public, static 멤버의 복잡한 기능에 대해 살펴보겠습니다. 이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-17.png" alt="" /></p><p>이번 글에서는 set/get, protected, private/public, static 멤버의 복잡한 기능에 대해 살펴보겠습니다. 이러한 기능은 타입스크립트 클래스 내에서 접근과 가시성을 제어하는 데 중요한 역할을 합니다. 멤버 가시성 및 접근 제어의 미묘한 차이를 살펴보고 강력하고 캡슐화된 코드 구조를 만드는 데 필요한 도구를 함께 살펴보세요.</p><h2 id="1-public-private-and-protected-members"><a class="markdownIt-Anchor" href="#1-public-private-and-protected-members"></a> 1. Public, Private, and Protected Members</h2><ul><li><strong>Public:</strong> <code>public</code>으로 표시된 멤버는 클래스 외부에서 액세스할 수 있습니다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">  <span class="keyword">public</span> model: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">model: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car(<span class="string">'Kia'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myCar.model); <span class="comment">// 접근 가능</span></span><br></pre></td></tr></table></figure><ul><li><strong>Private:</strong> <code>private</code>로 표시된 멤버는 클래스 내에서만 접근할 수 있습니다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">  <span class="keyword">private</span> model: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">model: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getModel(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model; <span class="comment">// 클래스 내에서 접근 가능</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car(<span class="string">'Toyota'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(myCar.model); // Error: 속성 'model'은 비공개이며 'Car' 클래스 내에서만 액세스할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCar.getModel()); <span class="comment">// 메서드를 통해 접근할 수 있습니다.</span></span><br></pre></td></tr></table></figure><ul><li><strong>Protected:</strong> <code>protected</code>으로 표시된 멤버는 클래스와 그 하위 클래스(파생 클래스) 내에서 액세스할 수 있습니다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Vehicle &#123;</span><br><span class="line">  <span class="keyword">protected</span> wheels: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">wheels: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wheels = wheels;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">extends</span> Vehicle &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">wheels: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(wheels);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getWheels(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.wheels; <span class="comment">// 파생 클래스에서 접근 가능</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(myCar.wheels); // Error: 'wheels' 속성은 보호되어 있으며 'Vehicle' 클래스와 그 하위 클래스 내에서만 접근할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCar.getWheels()); <span class="comment">// 메서드를 통해 액세스할 수 있습니다.</span></span><br></pre></td></tr></table></figure><h2 id="2-getter-and-setter"><a class="markdownIt-Anchor" href="#2-getter-and-setter"></a> 2. Getter and Setter</h2><ul><li><strong>Getter:</strong> private 속성의 값을 검색하는 데 사용됩니다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line">  <span class="keyword">private</span> _radius: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> radius(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCircle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCircle.radius); <span class="comment">// getter를 통해 접근 가능</span></span><br></pre></td></tr></table></figure><ul><li><strong>Setter:</strong> private 프로퍼티의 값을 업데이트하는 데 사용됩니다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line">  <span class="keyword">private</span> _radius: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> radius(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> radius(newRadius: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newRadius &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._radius = newRadius;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCircle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCircle.radius); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">myCircle.radius = <span class="number">7</span>; <span class="comment">// setter를 통해 설정합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCircle.radius); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">myCircle.radius = <span class="number">-3</span>; <span class="comment">// setter에 의해 무시됨</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCircle.radius); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="3-static-members"><a class="markdownIt-Anchor" href="#3-static-members"></a> 3. Static Members</h2><p>정적 멤버는 클래스의 인스턴스가 아닌 클래스 자체에 속합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MathOperations &#123;</span><br><span class="line">  <span class="keyword">static</span> PI: <span class="built_in">number</span> = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> calculateCircumference(radius: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.PI * radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MathOperations.PI); <span class="comment">// 정적 속성 접근하기</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MathOperations.calculateCircumference(<span class="number">5</span>)); <span class="comment">// 정적 메서드 호출하기</span></span><br></pre></td></tr></table></figure><p>정적 멤버는 인스턴스를 생성하지 않고 클래스에서 직접 액세스할 수 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 기능은 클래스의 내부 상태에 대한 액세스를 캡슐화하고 제어할 수 있는 방법을 제공하여 코드 구성과 유지보수성을 향상시킵니다. 각 멤버에 대해 원하는 캡슐화 수준과 가시성에 따라 적절한 접근 제어자를 선택하세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/19/typescript-17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] OOP 관행, 클래스 및 상속</title>
      <link>http://hgko1207.github.io/2024/04/19/typescript-16/</link>
      <guid>http://hgko1207.github.io/2024/04/19/typescript-16/</guid>
      <pubDate>Fri, 19 Apr 2024 01:25:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 클래스와 상속을 중심으로 객체 지향 프로그래밍(OOP) 사례를 살펴봅니다. 이러한 개념을 통해 실제 엔티티를 구조화되고 유
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-16.png" alt="" /></p><p>이번 글에서는 클래스와 상속을 중심으로 객체 지향 프로그래밍(OOP) 사례를 살펴봅니다. 이러한 개념을 통해 실제 엔티티를 구조화되고 유지 관리 가능한 방식으로 모델링할 수 있습니다. 모듈식 재사용 가능한 코드 작성에 대한 인사이트를 제공하는 TypeScript에서 OOP의 심층적인 내용을 살펴보세요.</p><h2 id="1-클래스"><a class="markdownIt-Anchor" href="#1-클래스"></a> 1. 클래스</h2><p>클래스는 프로퍼티와 메서드가 있는 객체를 만들기 위한 청사진입니다. 코드에서 실제 엔티티를 모델링하는 방법을 제공합니다.</p><p><strong>기본 클래스 예제:</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="comment">// 속성</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메서드</span></span><br><span class="line">  makeSound(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Some generic sound'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal 클래스의 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> myAnimal = <span class="keyword">new</span> Animal(<span class="string">'Leo'</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myAnimal.name); <span class="comment">// Output: Leo</span></span><br><span class="line"></span><br><span class="line">myAnimal.makeSound(); <span class="comment">// Output: Some generic sound</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Animal</code>은 속성(<code>name</code>과 <code>age</code>), 이러한 속성을 초기화하는 생성자, 메서드(<code>makeSound</code>)를 가진 클래스입니다.</p><h2 id="2-상속"><a class="markdownIt-Anchor" href="#2-상속"></a> 2. 상속</h2><p>상속을 사용하면 클래스가 다른 클래스로부터 프로퍼티와 메서드를 상속하여 코드 재사용을 촉진하고 계층적 관계를 만들 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="comment">// 추가 속성</span></span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, breed: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 기본 클래스(Animal)의 생성자 호출하기</span></span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 파생 클래스 속성 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// makeSound 메서드 재정의</span></span><br><span class="line">  makeSound(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Woof! Woof!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dog 전용 추가 메서드</span></span><br><span class="line">  fetch(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Fetching the ball!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 클래스의 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> Dog(<span class="string">'Buddy'</span>, <span class="number">3</span>, <span class="string">'Labrador'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myDog.name); <span class="comment">// Output: Buddy</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.breed); <span class="comment">// Output: Labrador</span></span><br><span class="line"></span><br><span class="line">myDog.makeSound(); <span class="comment">// Output: Woof! Woof!</span></span><br><span class="line">myDog.fetch(); <span class="comment">// Output: Fetching the ball!</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Dog</code>는 <code>Animal</code>의 서브클래스입니다. <code>Animal</code>의 프로퍼티와 메서드를 상속받으며 자체 프로퍼티와 메서드를 가질 수도 있습니다. <code>super</code> 키워드는 기본 클래스의 생성자를 호출하는 데 사용됩니다.</p><h2 id="3-접근-제어자"><a class="markdownIt-Anchor" href="#3-접근-제어자"></a> 3. 접근 제어자</h2><p>접근 제어자(Access Modifier)는 클래스 멤버(프로퍼티 및 메서드)의 표시 여부를 제어합니다. 타입스크립트는 <code>public</code>, <code>private</code>, <code>protected</code> 접근 제어자를 지원합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDetails(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(john.getDetails()); <span class="comment">// Output: John, 30 years old.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(john.age); // Error: Property 'age' is private and only accessible within class 'Person'.</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>age</code>은 <code>private</code>로 표시되어 <code>Person</code> 클래스 내에서만 액세스할 수 있습니다.</p><h2 id="4-추상-클래스"><a class="markdownIt-Anchor" href="#4-추상-클래스"></a> 4. 추상 클래스</h2><p>추상 클래스는 인스턴스화할 수 없는 클래스이며 다른 클래스의 베이스 클래스로 사용되는 경우가 많습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Shape &#123;</span><br><span class="line">  <span class="keyword">abstract</span> calculateArea(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Circle <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  calculateArea(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCircle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myCircle.calculateArea()); <span class="comment">// Output: 78.53981633974483</span></span><br></pre></td></tr></table></figure><p>여기서 <code>Shape</code>는 <code>calculateArea()</code> 추상 메서드를 가진 추상 클래스입니다. <code>Circle</code> 클래스는 <code>Shape</code>를 확장하고 <code>calculateArea()</code>에 대한 구현을 제공합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>타입스크립트에서 클래스와 상속을 사용하는 이러한 OOP 관행을 사용하면 모듈화되고 재사용 가능하며 체계적으로 정리된 코드를 만들 수 있습니다. 이를 통해 실제 엔티티와 관계를 반영하는 방식으로 복잡한 시스템을 모델링할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/19/typescript-16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Any, Void, Never, Null, Strict Null Checks</title>
      <link>http://hgko1207.github.io/2024/04/18/typescript-15/</link>
      <guid>http://hgko1207.github.io/2024/04/18/typescript-15/</guid>
      <pubDate>Thu, 18 Apr 2024 05:14:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 타입스크립트 타입의 동적 환경을 탐색하고, &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;n
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-15.png" alt="" /></p><p>이번 글에서는 타입스크립트 타입의 동적 환경을 탐색하고, <code>any</code>, <code>void</code>, <code>never</code>, <code>null</code>, 그리고 엄격한 null 체크의 중요성에 대해 살펴봅니다. 이러한 타입을 이해하는 것은 타입 안전을 유지하고 일반적인 프로그래밍 오류를 방지하는 데 필수적입니다. TypeScript의 타입 역학에 대해 알아보세요.</p><h2 id="1-any-type"><a class="markdownIt-Anchor" href="#1-any-type"></a> 1. Any Type</h2><p><code>any</code> 타입은 모든 타입의 값을 나타내는 데 사용됩니다. 기본적으로 특정 변수나 표현식에 대한 타입 검사를 사용하지 않습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myVariable: <span class="built_in">any</span> = <span class="string">'Hello, TypeScript!'</span>;</span><br><span class="line"></span><br><span class="line">myVariable = <span class="number">42</span>; <span class="comment">// No type error</span></span><br></pre></td></tr></table></figure><p><code>any</code>를 사용하면 편리할 수 있지만 TypeScript의 정적 타입 검사의 이점을 희생합니다.</p><h2 id="2-void-type"><a class="markdownIt-Anchor" href="#2-void-type"></a> 2. Void Type</h2><p><code>void</code> 타입은 값을 반환하지 않는 함수에 사용됩니다. 함수에 부작용이 있지만 의미 있는 결과를 생성하지 않는 함수를 나타낼 때 자주 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-never-type"><a class="markdownIt-Anchor" href="#3-never-type"></a> 3. Never Type</h2><p><code>never</code> 타입은 절대 발생하지 않는 값을 나타냅니다. 예외를 던지거나 무한 루프에 들어가는 함수의 반환 타입으로 자주 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// do something indefinitely</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-null-type"><a class="markdownIt-Anchor" href="#4-null-type"></a> 4. Null Type</h2><p>타입스크립트에서 <code>null</code>과 <code>undefined</code>는 기본적으로 모든 타입의 일부입니다. 그러나 엄격 null 검사를 활성화하면 <code>null</code>과 <code>undefined</code>은 모든 타입과 해당 타입에만 할당할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myString: <span class="built_in">string</span> = <span class="literal">null</span>; <span class="comment">// Error with strict null checks enabled</span></span><br></pre></td></tr></table></figure><h2 id="5-strict-null-checks"><a class="markdownIt-Anchor" href="#5-strict-null-checks"></a> 5. Strict Null Checks</h2><p>기본적으로 TypeScript에는 변수가 <code>null</code>이거나 <code>undefined</code> 경우 이를 명시적으로 표시하여 타입 안전성을 향상시키는 &quot;strict null checks&quot;라는 기능이 있습니다. 이를 통해 null 및 undefined 값과 관련된 많은 일반적인 프로그래밍 오류를 방지할 수 있습니다.</p><p>TypeScript 프로젝트에서 엄격한 null 검사를 사용하려면 <code>tsconfig.json</code> 파일에서 <code>&quot;strictNullChecks&quot;</code> 옵션을 <code>true</code>로 설정하면 됩니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strict null checks를 활성화하면 변수가 <code>null</code>이거나 <code>undefined</code> 경우를 명시적으로 지정해야 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myString: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// OK with strict null checks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNumber: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>; <span class="comment">// OK with strict null checks</span></span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>TypeScript의 이러한 기능을 사용하면 보다 안전하고 예측 가능한 코드를 작성하여 런타임 오류 발생 가능성을 줄이고 애플리케이션의 유지 관리성을 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/18/typescript-15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Typing Functions and Signatures</title>
      <link>http://hgko1207.github.io/2024/04/18/typescript-14/</link>
      <guid>http://hgko1207.github.io/2024/04/18/typescript-14/</guid>
      <pubDate>Thu, 18 Apr 2024 04:56:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 코드의 기능과 타입 안전을 보장하는 함수와 서명 입력에 중점을 둡니다. 함수 매개변수와 반환 타입에 주석을 다는 방법을 이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-14.png" alt="" /></p><p>이번 글에서는 코드의 기능과 타입 안전을 보장하는 함수와 서명 입력에 중점을 둡니다. 함수 매개변수와 반환 타입에 주석을 다는 방법을 이해하는 것은 효과적인 타입스크립트 개발을 위해 매우 중요합니다. 코드베이스에 명확성과 자신감을 부여하는 함수 입력의 미묘한 차이를 살펴보세요.</p><h2 id="1-function-parameter-and-return-type-annotations"><a class="markdownIt-Anchor" href="#1-function-parameter-and-return-type-annotations"></a> 1. Function Parameter and Return Type Annotations</h2><p>타입 어노테이션을 사용하여 함수 매개변수 타입과 반환(Return) 타입을 명시적으로 지정할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result: <span class="built_in">number</span> = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>add</code> 함수는 <code>number</code> 타입의 매개변수 두 개를 받아 <code>number</code> 타입의 값을 반환합니다.</p><h2 id="2-optional-and-default-parameters"><a class="markdownIt-Anchor" href="#2-optional-and-default-parameters"></a> 2. Optional and Default Parameters</h2><p>매개변수 이름 뒤에 <code>?</code>을 추가하여 선택적 매개변수로 만들 수 있으며, <code>=</code> 구문을 사용하여 기본값을 제공할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span>, greeting?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (greeting) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greet(<span class="string">'John'</span>)); <span class="comment">// Output: Hello, John!</span></span><br><span class="line"><span class="built_in">console</span>.log(greet(<span class="string">'John'</span>, <span class="string">'Hi'</span>)); <span class="comment">// Output: Hi, John!</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>greet</code> 함수에는 선택적 매개변수(<code>greeting</code>)가 있으며, 이 매개변수가 제공되면 인사말에 사용됩니다.</p><h2 id="3-function-types-and-variable-assignment"><a class="markdownIt-Anchor" href="#3-function-types-and-variable-assignment"></a> 3. Function Types and Variable Assignment</h2><p>함수에 대한 타입을 정의하고 변수에 할당할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function type definition</span></span><br><span class="line"><span class="keyword">type</span> MathOperation = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function assigned to a variable with the defined type</span></span><br><span class="line"><span class="keyword">const</span> multiply: MathOperation = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> multiplicationResult: <span class="built_in">number</span> = multiply(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiplicationResult); <span class="comment">// Output: 24</span></span><br></pre></td></tr></table></figure><p>여기서 <code>MathOperation</code>은 <code>number</code> 타입의 매개변수 두 개를 받아 <code>number</code>를 반환하는 함수를 나타내는 타입입니다.</p><h2 id="4-function-overloads"><a class="markdownIt-Anchor" href="#4-function-overloads"></a> 4. Function Overloads</h2><p>함수 오버로드를 사용하여 함수에 대해 여러 타입 서명을 제공할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function overloads</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stringResult: <span class="built_in">string</span> = combine(<span class="string">'Hello, '</span>, <span class="string">'world!'</span>);</span><br><span class="line"><span class="keyword">let</span> numberResult: <span class="built_in">number</span> = combine(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringResult); <span class="comment">// Output: Hello, world!</span></span><br><span class="line"><span class="built_in">console</span>.log(numberResult); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>combine</code> 함수에는 여러 타입 서명이 있어 두 개의 문자열 또는 두 개의 숫자를 받아들일 수 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>함수와 매개변수를 올바르게 입력하면 코드 명확성을 높이고, 더 나은 도구 지원을 가능하게 하며, 개발 중에 잠재적인 오류를 포착할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/18/typescript-14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Union, Literal, Tagged Types</title>
      <link>http://hgko1207.github.io/2024/04/17/typescript-13/</link>
      <guid>http://hgko1207.github.io/2024/04/17/typescript-13/</guid>
      <pubDate>Wed, 17 Apr 2024 05:11:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 타입 정의의 정확성과 표현력을 높여주는 Union 타입, Literal 타입, Tagged 타입에 대해 살펴봅니다. 이러한
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-13.png" alt="" /></p><p>이번 글에서는 타입 정의의 정확성과 표현력을 높여주는 Union 타입, Literal 타입, Tagged 타입에 대해 살펴봅니다. 이러한 기능을 이해하면 더욱 강력하고 미묘한 타입 시스템을 만들 수 있습니다. TypeScript의 고급 유형 기능의 세계를 탐색하는 이 여정에 함께하세요.</p><h2 id="1-union-types"><a class="markdownIt-Anchor" href="#1-union-types"></a> 1. Union Types</h2><p>Union 타입은 변수가 두 가지 이상의 타입을 가질 수 있게 해줍니다. 연산자를 사용하여 유형을 결합할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayResult</span>(<span class="params">result: Result</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayResult(<span class="number">42</span>); <span class="comment">// Output: 42</span></span><br><span class="line">displayResult(<span class="string">'hello'</span>); <span class="comment">// Output: hello</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Result</code>는 숫자나 문자열일 수 있습니다.</p><h2 id="2-literal-types"><a class="markdownIt-Anchor" href="#2-literal-types"></a> 2. Literal Types</h2><p>Literal 타입을 사용하면 변수가 가질 수 있는 정확한 값을 지정할 수 있습니다. 문자열 리터럴, 숫자 리터럴, 부울 리터럴 등과 함께 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction = <span class="string">'up'</span> | <span class="string">'down'</span> | <span class="string">'left'</span> | <span class="string">'right'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">direction: Direction</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Moving <span class="subst">$&#123;direction&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(<span class="string">'up'</span>); <span class="comment">// Output: Moving up</span></span><br><span class="line">move(<span class="string">'right'</span>); <span class="comment">// Output: Moving right</span></span><br></pre></td></tr></table></figure><p>여기서 <code>Direction</code>은 특정 문자열 “up”, “down”, “left” 또는 &quot;right&quot;를 나타내는 리터럴 타입입니다.</p><h2 id="3-tagged-union-types"><a class="markdownIt-Anchor" href="#3-tagged-union-types"></a> 3. Tagged Union Types</h2><p>Tagged Union 타입은 값이 여러 타입 중 하나일 수 있고 공통 속성(태그)으로 구분하려는 시나리오를 모델링하는 데 자주 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">'square'</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">'circle'</span>;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Circle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">shape: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.kind === <span class="string">'square'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> shape.size * shape.size;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius * shape.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mySquare: Square = &#123; kind: <span class="string">'square'</span>, size: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> myCircle: Circle = &#123; kind: <span class="string">'circle'</span>, radius: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(area(mySquare)); <span class="comment">// Output: 16</span></span><br><span class="line"><span class="built_in">console</span>.log(area(myCircle)); <span class="comment">// Output: 28.274333882308138</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Shape</code>는 두 가지 가능한 모양을 가진 Tagged 유니온 유형입니다: <code>Square</code>과 <code>Circle</code>입니다. <code>kind</code> 속성은 두 도형을 구분하는 태그 역할을 합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 기능은 표현력이 풍부하고 정확한 유형 정의를 생성할 수 있는 강력한 도구를 제공하여 코드에서 특정 패턴을 캡처하고 적용할 수 있게 해줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/17/typescript-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 개발자의 생산성을 높여주는 10가지 VS Code 확장 프로그램</title>
      <link>http://hgko1207.github.io/2024/04/16/info-13/</link>
      <guid>http://hgko1207.github.io/2024/04/16/info-13/</guid>
      <pubDate>Tue, 16 Apr 2024 01:58:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VS Code&lt;/strong&gt;는 유연성, 속도, 광범위한 확장 기능 라이브러리로 인해 웹 개발자들 사이에서 매우 인기 있는 코드 편집
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-13.png" alt="" /></p><p><strong>VS Code</strong>는 유연성, 속도, 광범위한 확장 기능 라이브러리로 인해 웹 개발자들 사이에서 매우 인기 있는 코드 편집기입니다. 이 블로그에서는 웹 개발자의 생산성을 높여주는 10가지 VS Code 확장 프로그램을 소개합니다.</p><h2 id="live-preview"><a class="markdownIt-Anchor" href="#live-preview"></a> Live Preview</h2><p><strong>Live Preview</strong> 확장 프로그램을 사용하면 VS Code 내부의 작은 브라우저에서 웹 사이트를 볼 수 있습니다. 따라서 웹사이트의 변경 사항을 확인하기 위해 코드 편집기에서 나갈 필요가 없습니다.</p><p>HTML, CSS 또는 JavaScript 파일을 변경하면 자동으로 업데이트됩니다. 따라서 매번 페이지를 새로고침할 필요가 없습니다.</p><p><img src="/images/header/info-13_1.png" alt="" /></p><h2 id="eslint"><a class="markdownIt-Anchor" href="#eslint"></a> ESLint</h2><p><strong>ESLint</strong> 확장 프로그램은 자바스크립트 개발자의 필수품입니다. 코드를 검사하여 세미콜론을 잊어버리거나 정의되지 않은 변수를 사용하는 등의 실수가 있는지 알려주고 더 나은 코드를 작성하도록 안내합니다.</p><p><img src="/images/header/info-13_2.png" alt="" /></p><h2 id="prettier"><a class="markdownIt-Anchor" href="#prettier"></a> Prettier</h2><p><strong>Prettier</strong> 확장 프로그램은 저장할 때마다 원하는 스타일 가이드에 맞게 코드 서식을 자동으로 지정해주는 코드 서식 지정기입니다. 따라서 코드가 항상 깔끔하고 깔끔하게 보입니다.</p><p><img src="/images/header/info-13_3.png" alt="" /></p><h2 id="path-intellisense"><a class="markdownIt-Anchor" href="#path-intellisense"></a> Path Intellisense</h2><p><strong>Path Intellisense</strong> 확장 프로그램은 파일 경로에 대한 자동 완성 제안을 제공합니다. 오류 발생 가능성을 줄이고 긴 경로를 수동으로 입력하는 수고를 덜어줍니다.</p><p><img src="/images/header/info-13_4.png" alt="" /></p><h2 id="peacock"><a class="markdownIt-Anchor" href="#peacock"></a> Peacock</h2><p><strong>Peacock</strong>은 다양한 VS Code 작업 영역에 대해 서로 다른 색상을 선택할 수 있는 독특한 확장 프로그램입니다. 여러 프로젝트를 동시에 작업할 때 유용합니다. 각 프로젝트 작업 영역에 다른 색상을 지정하여 쉽게 구분할 수 있습니다</p><p><img src="/images/header/info-13_5.png" alt="" /></p><h2 id="vscode-icons"><a class="markdownIt-Anchor" href="#vscode-icons"></a> VSCode-icons</h2><p><strong>VSCode-icons</strong> 확장 프로그램은 폴더와 파일에 아이콘을 추가합니다. 시각적으로 더 매력적이고 직관적으로 보이도록 만들어 줍니다.</p><p><img src="/images/header/info-13_6.png" alt="" /></p><h2 id="tabnine"><a class="markdownIt-Anchor" href="#tabnine"></a> Tabnine</h2><p><strong>Tabnine</strong>은 AI 기반 코드 완성 확장 프로그램입니다. 입력 패턴을 확인하고 전체 줄 또는 코드 블록을 제안하여 코딩 프로세스 속도를 높일 수 있도록 도와줍니다.</p><p><img src="/images/header/info-13_7.png" alt="" /></p><h2 id="code-runner"><a class="markdownIt-Anchor" href="#code-runner"></a> Code Runner</h2><p><strong>Code Runner</strong> 확장 프로그램을 사용하면 에디터 내에서 코드 스니펫을 실행할 수 있습니다. 여러 언어와 프레임워크를 지원합니다.</p><p><img src="/images/header/info-13_8.png" alt="" /></p><h2 id="es7-reactreduxreact-native-snippets"><a class="markdownIt-Anchor" href="#es7-reactreduxreact-native-snippets"></a> ES7+ React/Redux/React-Native Snippets</h2><p><strong>ES7+ React/Redux/React-Native Snippets</strong>은 상용구 코드에 빠르고 쉽게 액세스할 수 있는 기능을 제공합니다. React, Redux 또는 React Native로 작업하는 경우 이러한 스니펫을 사용하면 시간을 절약하고 개발 워크플로우 속도를 높일 수 있습니다.</p><p><img src="/images/header/info-13_9.png" alt="" /></p><h2 id="postman"><a class="markdownIt-Anchor" href="#postman"></a> Postman</h2><p><strong>Postman</strong> 확장 프로그램은 API 관련 프로젝트를 진행하는 웹 개발자에게 꼭 필요한 도구입니다. 코드 편집기에서 바로 API를 쉽게 다루고 테스트할 수 있습니다. 앞뒤로 전환할 필요가 없습니다.</p><p><img src="/images/header/info-13_10.png" alt="" /></p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>VS Code 확장 프로그램을 사용해 보면 작업 속도가 빨라지고, 작업이 더 원활해지며, 코드가 깔끔하게 유지됩니다. 직접 사용해 보시고 개발 프로세스의 차이를 경험해 보세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/16/info-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS 미디어 쿼리(Media Query): 반응형 웹사이트를 위한 초보자 가이드</title>
      <link>http://hgko1207.github.io/2024/04/09/web-7/</link>
      <guid>http://hgko1207.github.io/2024/04/09/web-7/</guid>
      <pubDate>Tue, 09 Apr 2024 13:18:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;끊임없이 변화하는 웹 개발 세계에서 휴대폰, 태블릿, 노트북 등 모든 기기에서 멋지게 보이고 원활하게 작동하는 웹사이트를 만드는 것은 매우 중요합니다.
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-7.png" alt="" /></p><p>끊임없이 변화하는 웹 개발 세계에서 휴대폰, 태블릿, 노트북 등 모든 기기에서 멋지게 보이고 원활하게 작동하는 웹사이트를 만드는 것은 매우 중요합니다. 이 글에서는 반응형 웹사이트를 만들기 위한 <strong>CSS 미디어 쿼리</strong>에 대해 알아봅니다.</p><h2 id="css-미디어-쿼리란-무엇인가요"><a class="markdownIt-Anchor" href="#css-미디어-쿼리란-무엇인가요"></a> CSS 미디어 쿼리란 무엇인가요?</h2><p>CSS 미디어 쿼리는 화면 너비, 높이, 디바이스 방향, 해상도 등에 따라 디바이스마다 다른 스타일을 적용하는 데 사용됩니다. 미디어 쿼리를 사용하면 사용자의 기기에 완벽하게 반응하는 웹 디자인을 만들고 사용자 경험을 향상시킬 수 있습니다.</p><h2 id="미디어-쿼리의-기본-구문"><a class="markdownIt-Anchor" href="#미디어-쿼리의-기본-구문"></a> 미디어 쿼리의 기본 구문</h2><p>미디어 쿼리의 기본 구문은 다음과 같습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-expression) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@media</code></strong>: 미디어 쿼리의 시작을 나타내는 데 사용됩니다.</p><p><strong><code>media-type</code></strong>: 브라우저에 이 코드가 어떤 종류의 미디어인지 알려줍니다. 여기에는 다음과 같은 값을 사용할 수 있습니다.</p><ul><li><strong>all</strong> — 모든 미디어 타입 디바이스용.</li><li><strong>print</strong> — 프린터용.</li><li><strong>screen</strong> — 데스크톱 화면, 랩톱, 태블릿, 휴대폰 등.</li><li><strong>speech</strong> — 페이지를 소리 내어 읽는 스크린 리더용입니다.</li></ul><p><strong><code>media-expression</code></strong>: CSS를 적용하기 위해 전달해야 하는 규칙입니다.</p><p>예를 들어 표현식에서 화면 너비를 600px로 지정하면 화면 크기가 이 너비와 일치할 때만 관련 CSS 스타일이 적용되고, 그렇지 않으면 비활성 상태로 유지됩니다.</p><p><strong><code>{ /* CSS styles go here */ }</code></strong>: 여기에는 지정된 <code>media-type</code>과 <code>media-expression</code>에 적용하려는 CSS 스타일이 작성됩니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>media-type</code>은 화면이고 <code>media-expression</code>은 <code>max-width: 600px</code>이므로 화면 너비가 600px 이하일 때 본문의 배경색이 변경됩니다(여기서는 최대 너비가 600px이므로).</p><p>제공된 미디어 표현식을 중단점이라고도 합니다. 따라서 여기서는 600px가 중단점입니다. 이제 <code>media-expression</code>에 어떤 값을 지정할 수 있는지 생각해 보셨을 것입니다.</p><p><code>media-expression</code>에 가장 일반적으로 사용되는 값을 알려드리겠습니다.</p><p>width and height of the device<br />orientation (for example, tablet/mobile phone is in landscape or portrait mode)<br />resolution<br />ranged syntax</p><ul><li>디바이스의 너비와 높이</li><li>방향(예: 태블릿/휴대폰이 가로 또는 세로 모드인 경우)</li><li>해상도</li><li>범위 구문</li></ul><p>위의 각 값을 이해하기 위해 몇 가지 예를 살펴보겠습니다.</p><h2 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h2><h2 id="디바이스의-너비와-높이"><a class="markdownIt-Anchor" href="#디바이스의-너비와-높이"></a> 디바이스의 너비와 높이</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">675px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 화면 크기가 675px 이하인 경우 배경색과 본문 색상이 변경됩니다.</p><h2 id="디바이스-방향"><a class="markdownIt-Anchor" href="#디바이스-방향"></a> 디바이스 방향</h2><p>가로 또는 세로로 방향을 지정할 수 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Styles for landscape orientation */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="해상도"><a class="markdownIt-Anchor" href="#해상도"></a> 해상도</h2><p>해상도에 따라 디바이스를 타깃팅할 수도 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Styles for high-resolution displays */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-resolution:</span> <span class="number">300dpi</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="범위-구문"><a class="markdownIt-Anchor" href="#범위-구문"></a> 범위 구문</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">758px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 화면 크기가 375px에서 758px 사이인 경우 배경색과 본문 색상이 변경됩니다.</p><p>미디어 쿼리를 사용하면 디바이스마다 다른 CSS 스타일을 설정할 수 있습니다.</p><h2 id="일반적인-중단점"><a class="markdownIt-Anchor" href="#일반적인-중단점"></a> 일반적인 중단점</h2><p>이제 미디어 쿼리에 대해 배우고 나면 &quot;화면의 중단점(breakpoint)을 어떻게 알 수 있나요?&quot;라는 질문이 생길 수 있습니다.🤔</p><p>다음은 디바이스에 일반적으로 사용되는 몇 가지 중단점입니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 초대형 화면 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1920px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 데스크톱 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1919px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 노트북/대형 태블릿 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1199px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 소형 태블릿 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">991px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 초소형 디바이스 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">481px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">767px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 모바일 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="comment">/* CSS styles go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>표준 중단점은 명시적으로 정의되어 있지 않지만 일반적으로 사용되는 이러한 중단점을 사용하여 웹사이트를 반응형으로 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/09/web-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS 개발자가 알아야 할 시간 절약형 웹사이트 11가지</title>
      <link>http://hgko1207.github.io/2024/04/09/web-design-7/</link>
      <guid>http://hgko1207.github.io/2024/04/09/web-design-7/</guid>
      <pubDate>Tue, 09 Apr 2024 12:37:28 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-design-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이 글에서는 시간을 많이 절약하고 CSS 개발 경험을 향상시킬 수 있는 15개의 웹사이트를 소개합니다.&lt;/p&gt;
&lt;h2 id=&quot;css-but
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-design-7.png" alt="" /></p><p>이 글에서는 시간을 많이 절약하고 CSS 개발 경험을 향상시킬 수 있는 15개의 웹사이트를 소개합니다.</p><h2 id="css-buttons"><a class="markdownIt-Anchor" href="#css-buttons"></a> CSS Buttons</h2><p><u><a href="https://cssbuttons.app/" target="_blank" rel="noopener"><strong>CSS Buttons</strong></a></u>을 사용하면 버튼 디자인 과정을 간소화할 수 있습니다. 이 웹사이트는 작업을 더 빠르게 완료할 수 있도록 해당 CSS 코드와 함께 사용자 정의 가능한 버튼 스타일의 훌륭한 컬렉션을 제공합니다.</p><p><img src="/images/header/web-design-7_1.png" alt="" /></p><h2 id="neumorphism-io"><a class="markdownIt-Anchor" href="#neumorphism-io"></a> Neumorphism .io</h2><p><u><a href="https://neumorphism.io/#e0e0e0" target="_blank" rel="noopener"><strong>Neumorphism or soft UI</strong></a></u>를 사용하여 뉴모픽 요소를 생성하고 해당 CSS 코드를 가져와 요소에 물리적 객체의 모양을 부여할 수 있습니다.</p><p><img src="/images/header/web-design-7_2.png" alt="" /></p><h2 id="css-strips-generator"><a class="markdownIt-Anchor" href="#css-strips-generator"></a> CSS Strips Generator</h2><p><u><a href="https://stripesgenerator.com/" target="_blank" rel="noopener"><strong>CSS Strips Generator</strong></a></u>는 스트라이프 배경을 만들고 디자인을 향상시키는 데 사용할 수 있습니다.</p><p><img src="/images/header/web-design-7_3.png" alt="" /></p><h2 id="google-fonts"><a class="markdownIt-Anchor" href="#google-fonts"></a> Google Fonts</h2><p>다양한 무료 및 오픈 소스 글꼴 컬렉션에 <u><a href="https://fonts.google.com/" target="_blank" rel="noopener"><strong>Google Fonts</strong></a></u>을 사용하여 웹사이트의 타이포그래피를 향상시킬 수 있습니다. Google Fonts을 사용하여 프로젝트에 글꼴을 쉽게 통합할 수 있습니다.</p><p><img src="/images/header/web-design-7_4.png" alt="" /></p><h2 id="get-waves"><a class="markdownIt-Anchor" href="#get-waves"></a> Get Waves</h2><p><u><a href="https://getwaves.io/" target="_blank" rel="noopener"><strong>Get Waves</strong></a></u>를 사용하면 눈길을 사로잡는 SVG 물결 패턴을 만들어 웹사이트에 역동적인 느낌을 더할 수 있습니다.</p><p><img src="/images/header/web-design-7_5.png" alt="" /></p><h2 id="can-i-use"><a class="markdownIt-Anchor" href="#can-i-use"></a> Can I Use</h2><p>CSS를 작성할 때는 브라우저 호환성을 파악하는 것이 중요합니다. <u><a href="https://caniuse.com/" target="_blank" rel="noopener"><strong>Can I Use</strong></a></u>을 사용하여 최신 브라우저 지원 표를 확인할 수 있습니다.</p><p><img src="/images/header/web-design-7_6.png" alt="" /></p><h2 id="colorspace"><a class="markdownIt-Anchor" href="#colorspace"></a> ColorSpace</h2><p>웹사이트를 시각적으로 매력적으로 만들려면 올바른 색상 팔레트를 선택하는 것이 중요합니다. 색상을 입력하기만 하면 <u><a href="https://mycolor.space/" target="_blank" rel="noopener"><strong>ColorSpace</strong></a></u>을 사용하여 프로젝트에 딱 맞는 색상을 선택할 수 있습니다.</p><p><img src="/images/header/web-design-7_7.png" alt="" /></p><h2 id="css-grid-generator"><a class="markdownIt-Anchor" href="#css-grid-generator"></a> CSS Grid Generator</h2><p><u><a href="https://cssgrid-generator.netlify.app/" target="_blank" rel="noopener"><strong>CSS Grid Generator</strong></a></u>는 복잡한 그리드 레이아웃을 만들고 해당 CSS 코드를 생성하는 데 유용한 도구입니다.</p><p><img src="/images/header/web-design-7_8.png" alt="" /></p><h2 id="css-gradient-generator"><a class="markdownIt-Anchor" href="#css-gradient-generator"></a> CSS Gradient Generator</h2><p><u><a href="https://cssgradient.io/" target="_blank" rel="noopener"><strong>CSS Gradient Generator</strong></a></u>는 복잡한 CSS 그라디언트를 쉽게 만들 수 있습니다. 또한 해당 CSS 코드도 제공합니다.</p><p><img src="/images/header/web-design-7_9.png" alt="" /></p><h2 id="animatecss"><a class="markdownIt-Anchor" href="#animatecss"></a> Animate.css</h2><p>프로젝트에 쉽게 통합할 수 있는 바로 사용할 수 있는 다양한 애니메이션 모음을 위해 <u><a href="https://animate.style/" target="_blank" rel="noopener"><strong>Animate.css</strong></a></u>를 사용할 수 있습니다.</p><p><img src="/images/header/web-design-7_10.png" alt="" /></p><h2 id="css-validator"><a class="markdownIt-Anchor" href="#css-validator"></a> CSS Validator</h2><p><u><a href="https://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener"><strong>CSS Validator</strong></a></u>는 CSS 코드가 웹의 규칙을 따르는지 확인하는 데 사용할 수 있습니다. W3C의 CSS Validator는 스타일시트를 살펴보고 코드 작성 방식에서 실수를 찾아내어 CSS 표준을 충족하는지 확인합니다.</p><p><img src="/images/header/web-design-7_11.png" alt="" /></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/09/web-design-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Type, Enum, Interface 타입 만들기</title>
      <link>http://hgko1207.github.io/2024/04/09/typescript-12/</link>
      <guid>http://hgko1207.github.io/2024/04/09/typescript-12/</guid>
      <pubDate>Tue, 09 Apr 2024 05:43:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/typescript-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 사용자 정의 타입, Enum 및 Interface를 만드는 데 초점을 맞춥니다. 이러한 강력한 구조를 사용하면 표현력이 풍
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/typescript-12.png" alt="" /></p><p>이번 글에서는 사용자 정의 타입, Enum 및 Interface를 만드는 데 초점을 맞춥니다. 이러한 강력한 구조를 사용하면 표현력이 풍부하고 잘 정의된 코드 구조를 만들 수 있습니다.</p><p>타입을 만들고, 명명된 상수에 Enum을 활용하고, 명확한 Interface를 디자인하여 TypeScript 프로젝트의 협업과 유지 관리성을 향상시키는 방법을 살펴보세요.</p><h2 id="1-type-만들기"><a class="markdownIt-Anchor" href="#1-type-만들기"></a> 1. Type 만들기</h2><p><code>type</code>을 사용하면 기존 타입에 대한 사용자 정의 이름을 정의하거나 타입의 조합을 만들 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status = <span class="string">'success'</span> | <span class="string">'error'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processStatus</span>(<span class="params">status: Status</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Processing status: <span class="subst">$&#123;status&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStatus: Status = <span class="string">'success'</span>;</span><br><span class="line"></span><br><span class="line">processStatus(myStatus);</span><br><span class="line"><span class="comment">// Output: Processing status: success</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Status</code>는 “success” 또는 &quot;error&quot;를 나타내는 사용자 정의 타입입니다.</p><h2 id="2-enum"><a class="markdownIt-Anchor" href="#2-enum"></a> 2. Enum</h2><p><code>enum</code>은 숫자 값 집합에 보다 친숙한 이름을 부여하는 방법입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'UP'</span>,</span><br><span class="line">  Down = <span class="string">'DOWN'</span>,</span><br><span class="line">  Left = <span class="string">'LEFT'</span>,</span><br><span class="line">  Right = <span class="string">'RIGHT'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerDirection: Direction = Direction.Up;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Player is moving <span class="subst">$&#123;playerDirection&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Output: Player is moving UP</span></span><br></pre></td></tr></table></figure><p>여기서 <code>Direction</code>은 각 멤버에 문자열 값이 할당된 Enum 입니다.</p><h2 id="3-interface"><a class="markdownIt-Anchor" href="#3-interface"></a> 3. Interface</h2><p><code>interface</code>는 객체 형상에 대한 컨트랙트를 정의하여 객체가 준수해야 하는 구조를 지정할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sayHello: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john: Person = &#123;</span><br><span class="line">  firstName: <span class="string">'John'</span>,</span><br><span class="line">  lastName: <span class="string">'Doe'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, I'm <span class="subst">$&#123;john.firstName&#125;</span> <span class="subst">$&#123;john.lastName&#125;</span>.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">john.sayHello(); <span class="comment">// Output: Hello, I'm John Doe.</span></span><br></pre></td></tr></table></figure><p>이 예제에서 <code>Person</code>은 <code>firstName</code>, <code>lastName</code>, <code>age</code> 및 <code>sayHello</code> 메서드가 있는 객체의 구조를 정의하는 인터페이스입니다.</p><h2 id="type-enum-및-interface-결합하기"><a class="markdownIt-Anchor" href="#type-enum-및-interface-결합하기"></a> Type, Enum 및 Interface 결합하기</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car = &#123;</span><br><span class="line">  make: <span class="built_in">string</span>;</span><br><span class="line">  model: <span class="built_in">string</span>;</span><br><span class="line">  year: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FuelType &#123;</span><br><span class="line">  Gasoline = <span class="string">'Gasoline'</span>,</span><br><span class="line">  Electric = <span class="string">'Electric'</span>,</span><br><span class="line">  Hybrid = <span class="string">'Hybrid'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ElectricCar <span class="keyword">extends</span> Car &#123;</span><br><span class="line">  batteryCapacity: <span class="built_in">number</span>;</span><br><span class="line">  fuelType: FuelType.Electric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myElectricCar: ElectricCar = &#123;</span><br><span class="line">  make: <span class="string">'Tesla'</span>,</span><br><span class="line">  model: <span class="string">'Model 3'</span>,</span><br><span class="line">  year: <span class="number">2022</span>,</span><br><span class="line">  batteryCapacity: <span class="number">75</span>,</span><br><span class="line">  fuelType: FuelType.Electric,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>여기에는 <code>Car</code> 타입, <code>FuelType</code> Enum, 그리고 <code>Car</code> 타입을 확장하는 <code>ElectricCar</code> 인터페이스가 있습니다. <code>myElectricCar</code>는 <code>ElectricCar</code> 인터페이스에 부합하는 객체입니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 개념을 사용하면 명확한 구조를 적용하고 유형과 값에 의미 있는 이름을 제공함으로써 보다 강력하고 유지 관리가 쉬운 코드를 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/09/typescript-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알아야 할 13가지 HTML 속성</title>
      <link>http://hgko1207.github.io/2024/04/02/web-design-6/</link>
      <guid>http://hgko1207.github.io/2024/04/02/web-design-6/</guid>
      <pubDate>Tue, 02 Apr 2024 05:08:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-design-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;accept-속성&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#accept-속성&quot;&gt;&lt;/a&gt; Accept 속성
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-design-6.png" alt="" /></p><h2 id="accept-속성"><a class="markdownIt-Anchor" href="#accept-속성"></a> Accept 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">".jpg, .jpeg, .png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="alt-속성"><a class="markdownIt-Anchor" href="#alt-속성"></a> Alt 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"nature.png"</span> <span class="attr">alt</span>=<span class="string">"A beautiful sunset"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="autocomplete-속성"><a class="markdownIt-Anchor" href="#autocomplete-속성"></a> Autocomplete 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="contenteditable-속성"><a class="markdownIt-Anchor" href="#contenteditable-속성"></a> Contenteditable 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span>You can edit this content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="download-속성"><a class="markdownIt-Anchor" href="#download-속성"></a> Download 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">download</span>=<span class="string">"document.pdf"</span>&gt;</span>Download PDF<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="hidden-속성"><a class="markdownIt-Anchor" href="#hidden-속성"></a> Hidden 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span>This is hidden content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="loading-속성"><a class="markdownIt-Anchor" href="#loading-속성"></a> Loading 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.png"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="multiple-속성"><a class="markdownIt-Anchor" href="#multiple-속성"></a> Multiple 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"typescript"</span>&gt;</span>TypeScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"rust"</span>&gt;</span>Rust<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="poster-속성"><a class="markdownIt-Anchor" href="#poster-속성"></a> Poster 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"image.png"</span> <span class="attr">width</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="readonly-속성"><a class="markdownIt-Anchor" href="#readonly-속성"></a> Readonly 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"This is readonly."</span> <span class="attr">readonly</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="srcset-속성"><a class="markdownIt-Anchor" href="#srcset-속성"></a> Srcset 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">srcset</span>=<span class="string">"image.jpg, image-2x.jpg, image-3x.jpg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spellcheck-속성"><a class="markdownIt-Anchor" href="#spellcheck-속성"></a> Spellcheck 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="title-속성"><a class="markdownIt-Anchor" href="#title-속성"></a> Title 속성</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">title</span>=<span class="string">"Click to download"</span>&gt;</span>Download File<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/04/02/web-design-6/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
