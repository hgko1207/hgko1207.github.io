<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Mon, 10 Mar 2025 04:26:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2025년, C# 개발자가 반드시 알아야 할 10가지</title>
      <link>http://hgko1207.github.io/2025/03/10/csharp-18/</link>
      <guid>http://hgko1207.github.io/2025/03/10/csharp-18/</guid>
      <pubDate>Mon, 10 Mar 2025 03:45:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;백엔드 개발이든, 클라이언트 사이드 로직을 다루는 풀스택 개발이든, 클라우드 네이티브 환경에서 서비스 배포를 담당하는 엔지니어든, 2025년에는 여러분의 개발 흐름에서 주목해야 할 변화들이 있습니다.&lt;/p&gt;
&lt;p&gt;다음은 2025년에 반드시 알아야
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>백엔드 개발이든, 클라이언트 사이드 로직을 다루는 풀스택 개발이든, 클라우드 네이티브 환경에서 서비스 배포를 담당하는 엔지니어든, 2025년에는 여러분의 개발 흐름에서 주목해야 할 변화들이 있습니다.</p><p>다음은 2025년에 반드시 알아야 할 <strong>C#의 10가지 핵심 사항</strong>입니다.</p><h2 id="1-패턴-매칭pattern-matching의-또-다른-진화"><a class="markdownIt-Anchor" href="#1-패턴-매칭pattern-matching의-또-다른-진화"></a> 1. 패턴 매칭(Pattern Matching)의 또 다른 진화</h2><p>C# 12와 13이 패턴 매칭을 한 단계 발전시켰다고 생각했다면, C# 14는 또 다른 차원을 열어줍니다.</p><p>패턴 매칭이 더욱 <strong>표현력 있고 직관적인 방식</strong>으로 개선되어 가독성과 유지보수성이 향상되었습니다. 예전에는 <code>switch-case</code> 문이 난무하는 코드를 패턴 매칭으로 변환하면서 엄청난 변화를 경험했는데, 이제는 <strong>마치 자연어로 로직을 작성하는 듯한 느낌</strong>이 듭니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = someObject <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; Type: <span class="string">"Admin"</span>, Status: <span class="string">"Active"</span> &#125; =&gt; <span class="string">"Grant full access"</span>,</span><br><span class="line">    &#123; Type: <span class="string">"User"</span>, Status: <span class="string">"Suspended"</span> &#125; =&gt; <span class="string">"Access denied"</span>,</span><br><span class="line">    _ =&gt; <span class="string">"Partial access"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-net-9의-성능-향상"><a class="markdownIt-Anchor" href="#2-net-9의-성능-향상"></a> 2. .NET 9의 성능 향상</h2><p>.NET은 항상 <strong>성능 최적화</strong>를 중시해왔고, .NET 9에서는 더욱 향상된 <strong>JIT 최적화, 메모리 할당 전략 개선, AOT(미리 컴파일) 지원 강화</strong>를 제공합니다.</p><p>특히 <strong>마이크로서비스 및 대규모 트래픽을 처리하는 애플리케이션</strong>에서 실행 속도와 시작 시간이 크게 개선됩니다.</p><p>✅ <strong>업그레이드 사례</strong><br />.NET 6에서 .NET 9로 마이그레이션 후 <strong>메모리 사용량이 20% 감소</strong>하는 것을 확인했습니다.<br />특히 <strong>최적화된 가비지 컬렉터(Optimized GC)</strong> 덕분에 이러한 성능 개선이 가능했습니다.</p><h2 id="3-불변-컬렉션immutable-collections-기본-제공"><a class="markdownIt-Anchor" href="#3-불변-컬렉션immutable-collections-기본-제공"></a> 3. 불변 컬렉션(Immutable Collections) 기본 제공</h2><p>기존에는 <code>System.Collections.Immutable</code> 같은 외부 라이브러리를 사용해야 했던 <strong>불변 컬렉션(Immutable Collections)</strong> 이 C# 14에서 기본 제공됩니다.</p><p>이 기능은 함수형 프로그래밍 패러다임과 잘 맞으며, 특히 멀티스레드 환경에서 데이터 무결성을 보장하는 데 유용합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> ImmutableList&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span> &#125;;</span><br><span class="line">names.Add(<span class="string">"David"</span>); <span class="comment">// 컴파일 오류 - 불변(Immutable) 컬렉션</span></span><br></pre></td></tr></table></figure><h2 id="4-레코드records-확장"><a class="markdownIt-Anchor" href="#4-레코드records-확장"></a> 4. 레코드(Records) 확장</h2><p>C# 9에서 도입된 <strong>레코드(Records)</strong> 는 데이터 중심 객체를 다룰 때 매우 유용했습니다.<br />이제 C# 14에서는 <strong>깊은 복사(Deep Copy)</strong> 기능이 <strong>포함된 가변 레코드(Mutable Records)</strong> 를 지원합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">record <span class="title">Employee</span>(<span class="params"><span class="keyword">string</span> Name, <span class="keyword">string</span> Role</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e1 = <span class="keyword">new</span> Employee(<span class="string">"John"</span>, <span class="string">"Developer"</span>);</span><br><span class="line"><span class="keyword">var</span> e2 = e1 with &#123; Role = <span class="string">"Tech Lead"</span> &#125;; <span class="comment">// 깊은 복사 후 일부 속성 수정</span></span><br></pre></td></tr></table></figure><p>✅ <strong>이 기능은 CQRS 패턴 및 이벤트 기반 아키텍처에서 데이터 변환을 간소화하는 데 유용합니다.</strong></p><h2 id="5-task-streams를-활용한-간편한-병렬-처리"><a class="markdownIt-Anchor" href="#5-task-streams를-활용한-간편한-병렬-처리"></a> 5. Task Streams를 활용한 간편한 병렬 처리</h2><p>C#에서 비동기 프로그래밍이 지속적으로 발전하고 있으며, .NET 9에서는 <strong>Task Streams</strong> 가 도입되었습니다.</p><p>기존에는 <code>IAsyncEnumerable</code>과 수동 <code>CancellationToken</code>을 사용해야 했지만, 이제는 <strong>더 간결한 API</strong> 를 통해 <strong>비동기 데이터 흐름을 쉽게 관리</strong>할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> data <span class="keyword">in</span> myStream)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-통합된-구성-시스템unified-configuration-system"><a class="markdownIt-Anchor" href="#6-통합된-구성-시스템unified-configuration-system"></a> 6. 통합된 구성 시스템(Unified Configuration System)</h2><p>기존 .NET 프로젝트에서 <code>appsettings.json</code>, <strong>환경 변수(Environment Variables), 사용자 비밀(User Secrets)</strong> 등을 각각 관리하는 것은 번거로웠습니다.</p><p>.NET 9에서는 <strong>모든 설정을 하나의 통합된 방식으로 관리</strong>할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = Configuration.Load(<span class="string">"myappsettings.json"</span>);</span><br><span class="line">Console.WriteLine(config[<span class="string">"AppName"</span>]);</span><br></pre></td></tr></table></figure><p>✅ <strong>환경별 중복 설정을 줄이고, 유지보수가 더욱 쉬워집니다.</strong></p><h2 id="7-향상된-json-처리-기능"><a class="markdownIt-Anchor" href="#7-향상된-json-처리-기능"></a> 7. 향상된 JSON 처리 기능</h2><p><code>System.Text.Json</code> 은 매년 개선되고 있으며, .NET 9에서는 <strong>속성 자동 매핑, 다형성 타입 직렬화, 더 빠른 역직렬화</strong> 기능이 추가되었습니다.</p><p>이제는 <code>NewtonSoft.Json</code>을 사용할 필요 없이, 내장 JSON 기능만으로도 충분한 성능을 제공합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123; \"Name\": \"Alice\", \"Age\": 30 &#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> person = JsonSerializer.Deserialize&lt;Person&gt;(json);</span><br><span class="line">Console.WriteLine(person.Name);</span><br></pre></td></tr></table></figure><h2 id="8-향상된-의존성-주입dependency-injection-di"><a class="markdownIt-Anchor" href="#8-향상된-의존성-주입dependency-injection-di"></a> 8. 향상된 의존성 주입(Dependency Injection, DI)</h2><p>.NET 9에서는 DI 프레임워크가 <strong>더 간결하고 효율적으로 개선</strong>되었습니다.</p><p>✅ <strong>새로운 기능</strong></p><ul><li>생성자가 없는(Constructor-less) 의존성 주입 지원</li><li>일시적(Transient) 객체의 자동 폐기 지원</li><li>대규모 애플리케이션에서 <strong>더 빠른 DI 성능 제공</strong></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IMyService, MyService&gt;();</span><br><span class="line">services.UseAutoInjection();</span><br></pre></td></tr></table></figure><p>✅ <strong>불필요한 DI 설정을 줄이고, 유지보수성을 높일 수 있습니다.</strong></p><h2 id="9-확장된-minimal-api-및-grpc-최적화"><a class="markdownIt-Anchor" href="#9-확장된-minimal-api-및-grpc-최적화"></a> 9. 확장된 Minimal API 및 gRPC 최적화</h2><p>Minimal API는 .NET 6에서 처음 도입된 이후로 계속 발전해 왔습니다.<br />.NET 9에서는 <strong>경로 그룹(Route Groups) 및 내장 검증(Validation Decorators)</strong> 기능이 추가되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.MapGet(<span class="string">"/hello/&#123;name&#125;"</span>, (<span class="keyword">string</span> name) =&gt; <span class="string">$"Hello, <span class="subst">&#123;name&#125;</span>!"</span>)</span><br><span class="line">   .WithValidation();</span><br></pre></td></tr></table></figure><p>또한 <strong>gRPC가 기본적으로 메시지 압축과 양방향 스트리밍 최적화를 지원</strong>하여,<br /><strong>실시간 통신이 더욱 빠르고 효율적으로 개선</strong>되었습니다.</p><h2 id="10-net-클라우드-네이티브-기능-확장"><a class="markdownIt-Anchor" href="#10-net-클라우드-네이티브-기능-확장"></a> 10. .NET 클라우드 네이티브 기능 확장</h2><p>마이크로소프트는 <strong>클라우드 네이티브 개발</strong>을 더욱 강화하고 있으며, .NET 9에서는 다음과 같은 기능이 추가되었습니다.</p><ul><li>✅ <strong>자동 텔레메트리(Telemetry)</strong></li><li>✅ <strong>내장 분산 추적(Distributed Tracing)</strong></li><li>✅ <strong>Kubernetes 환경에서의 최적화</strong></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line">builder.Services.AddTelemetry();</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>C# 14와 .NET 9은 단순한 기능 개선을 넘어서 <strong>소프트웨어 개발 방식을 근본적으로 변화시키고 있습니다.</strong></p><p>✅ 더 빠르고<br />✅ 더 직관적이며<br />✅ 더 효율적으로</p><p>변화하는 C#의 새로운 기능을 학습하고 활용하여 더 나은 개발자로 성장하세요! 🚀🔥</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/03/10/csharp-18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>시니어 .NET 개발자가 전하는 17가지 핵심 팁</title>
      <link>http://hgko1207.github.io/2025/03/10/csharp-17/</link>
      <guid>http://hgko1207.github.io/2025/03/10/csharp-17/</guid>
      <pubDate>Mon, 10 Mar 2025 03:15:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;초보자든, 몇 년의 경험을 쌓은 개발자든 상관없이, 이 글은 &lt;strong&gt;실제 개발 경험에서 얻은 교훈과 실수, 그리고 깨달음&lt;/strong&gt;을 바탕으로 작성되었습니다.&lt;/p&gt;
&lt;p&gt;이제부터 .NET 개발자로서 반드시 알아야 할 최고의 팁과 트
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>초보자든, 몇 년의 경험을 쌓은 개발자든 상관없이, 이 글은 <strong>실제 개발 경험에서 얻은 교훈과 실수, 그리고 깨달음</strong>을 바탕으로 작성되었습니다.</p><p>이제부터 .NET 개발자로서 반드시 알아야 할 최고의 팁과 트릭을 공유하겠습니다.</p><h2 id="1-비동기-프로그래밍async-programming을-마스터하라"><a class="markdownIt-Anchor" href="#1-비동기-프로그래밍async-programming을-마스터하라"></a> 1. 비동기 프로그래밍(Async Programming)을 마스터하라</h2><p>.NET을 처음 접했을 때는 모든 API를 동기적으로 작성했습니다. 하지만 트래픽이 증가하자 서비스가 쉽게 무너졌습니다. 이후 <strong>비동기 프로그래밍(async/await)</strong> 으로 전환하면서 성능과 확장성이 크게 개선되었습니다.</p><p>📌 핵심 포인트</p><ul><li><code>Task.Run</code>을 신중하게 사용하라.</li><li><code>async void</code>는 피하라.</li><li>라이브러리 코드에서는 <code>ConfigureAwait(false)</code>를 활용하라.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchDataAsync</span>(<span class="params">HttpClient client</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"https://api.example.com/data"</span>);</span><br><span class="line">    response.EnsureSuccessStatusCode();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-의존성-주입dependency-injection은-필수다"><a class="markdownIt-Anchor" href="#2-의존성-주입dependency-injection은-필수다"></a> 2. 의존성 주입(Dependency Injection)은 필수다</h2><p>과거에 <strong>하드코딩된 의존성(dependencies)</strong> 을 가진 .NET 프로젝트를 유지보수하면서 엄청난 어려움을 겪었습니다. <strong>의존성 주입(DI)</strong> 을 도입한 후 코드가 훨씬 <strong>모듈화되고 테스트하기 쉬워졌습니다.</strong></p><p>📌 핵심 포인트</p><ul><li>DI를 사용하면 유지보수성이 향상된다.</li><li>.NET의 내장 DI 컨테이너를 적극 활용하라.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDataService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">GetData</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataService</span> : <span class="title">IDataService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetData</span>(<span class="params"></span>)</span> =&gt; <span class="string">"Hello, Dependency Injection!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DI 컨테이너에 등록</span></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line">builder.Services.AddScoped&lt;IDataService, DataService&gt;();</span><br></pre></td></tr></table></figure><h2 id="3-레코드records와-불변immutable-타입을-활용하라"><a class="markdownIt-Anchor" href="#3-레코드records와-불변immutable-타입을-활용하라"></a> 3. 레코드(Records)와 불변(Immutable) 타입을 활용하라</h2><p>C# 9에서 <strong>records</strong> 가 도입된 후 불필요한 보일러플레이트 클래스를 줄일 수 있었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> Name, <span class="keyword">int</span> Age</span>)</span>;</span><br></pre></td></tr></table></figure><p>✅ <code>record</code> 타입을 사용하면 자동으로 불변성(immutability)과 값 비교 기능이 제공됩니다.</p><h2 id="4-패턴-매칭pattern-matching을-적극-활용하라"><a class="markdownIt-Anchor" href="#4-패턴-매칭pattern-matching을-적극-활용하라"></a> 4. 패턴 매칭(Pattern Matching)을 적극 활용하라</h2><p>불필요한 <code>if-else</code> 블록을 대체하면 코드가 훨씬 간결해집니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetMessage</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span> =&gt; obj <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> number =&gt; <span class="string">$"Number: <span class="subst">&#123;number&#125;</span>"</span>,</span><br><span class="line">    <span class="keyword">string</span> text =&gt; <span class="string">$"Text: <span class="subst">&#123;text&#125;</span>"</span>,</span><br><span class="line">    _ =&gt; <span class="string">"Unknown type"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-리플렉션reflection-남용을-피하라"><a class="markdownIt-Anchor" href="#5-리플렉션reflection-남용을-피하라"></a> 5. 리플렉션(Reflection) 남용을 피하라</h2><p>리플렉션은 강력하지만 성능 비용이 큽니다. 초기에는 리플렉션을 남용했지만, 결국 제네릭(Generic)과 인터페이스(Interface)로 대체하는 것이 훨씬 효율적이었습니다.</p><p>🚨 잘못된 예시</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> method = <span class="keyword">typeof</span>(MyClass).GetMethod(<span class="string">"MyMethod"</span>);</span><br><span class="line">method.Invoke(instance, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>✅ 제네릭을 활용한 해결책</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T CreateInstance&lt;T&gt;() <span class="keyword">where</span> T : <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-linq-쿼리-최적화"><a class="markdownIt-Anchor" href="#6-linq-쿼리-최적화"></a> 6. LINQ 쿼리 최적화</h2><p>LINQ는 강력하지만, 잘못 사용하면 성능 문제가 발생할 수 있습니다.<br />✅ <code>ToList()</code>는 정말 필요할 때만 사용하라!</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = myCollection.Where(x =&gt; x.IsActive).Select(x =&gt; x.Name).ToList();</span><br></pre></td></tr></table></figure><h2 id="7-문자열-연결보다-문자열-보간string-interpolation-을-사용하라"><a class="markdownIt-Anchor" href="#7-문자열-연결보다-문자열-보간string-interpolation-을-사용하라"></a> 7. 문자열 연결보다 문자열 보간(String Interpolation) 을 사용하라</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 비효율적인 코드</span></span><br><span class="line"><span class="keyword">string</span> message = <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 가독성이 좋은 코드</span></span><br><span class="line"><span class="keyword">string</span> message = <span class="string">$"Hello <span class="subst">&#123;name&#125;</span>!"</span>;</span><br></pre></td></tr></table></figure><h2 id="8-예외exception-처리-신중하게-하기"><a class="markdownIt-Anchor" href="#8-예외exception-처리-신중하게-하기"></a> 8. 예외(Exception) 처리 신중하게 하기</h2><p>모든 예외를 <code>catch (Exception)</code>로 잡는 것은 위험하다. 구체적인 예외를 명시적으로 처리하라!</p><p>🚨 잘못된 예시</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; <span class="comment">/* 코드 */</span> &#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception) &#123; <span class="comment">/* 아무것도 안함 */</span> &#125;</span><br></pre></td></tr></table></figure><p>✅ 올바른 예시</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; <span class="comment">/* 코드 */</span> &#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123; Log(ex.Message); &#125;</span><br></pre></td></tr></table></figure><h2 id="9-조기-최적화premature-optimization는-독이다"><a class="markdownIt-Anchor" href="#9-조기-최적화premature-optimization는-독이다"></a> 9. 조기 최적화(Premature Optimization)는 독이다</h2><p>초기에는 성능을 과도하게 최적화하려 했지만, <strong>실제 문제를 프로파일링(profiling)한 후 최적화하는 것이 더 효과적</strong>이었다.</p><h2 id="10-spant와-memoryt-활용"><a class="markdownIt-Anchor" href="#10-spant와-memoryt-활용"></a> 10. <code>Span&lt;T&gt;</code>와 <code>Memory&lt;T&gt;</code> 활용</h2><p>.NET Core부터 <code>Span&lt;T&gt;</code>와 <code>Memory&lt;T&gt;</code>를 활용하면 대용량 데이터 처리가 훨씬 빨라집니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">stackalloc</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="11-로깅logging-활용-그러나-신중하게"><a class="markdownIt-Anchor" href="#11-로깅logging-활용-그러나-신중하게"></a> 11. 로깅(logging) 활용, 그러나 신중하게</h2><p>로그를 적게 남기면 디버깅이 어려워지고, 너무 많이 남기면 성능이 저하됩니다.<br /><strong>Serilog</strong> 또는 <strong>NLog</strong> 같은 구조적 로깅 라이브러리를 활용하세요.</p><h2 id="12-보안security은-절대-타협하지-마라"><a class="markdownIt-Anchor" href="#12-보안security은-절대-타협하지-마라"></a> 12. 보안(Security)은 절대 타협하지 마라</h2><p><strong>IOptions<T></strong> 를 활용하여 민감한 설정 값을 코드에서 직접 하드코딩하는 것을 피하세요.</p><h2 id="13-net-성능-프로파일링-도구-활용"><a class="markdownIt-Anchor" href="#13-net-성능-프로파일링-도구-활용"></a> 13. .NET 성능 프로파일링 도구 활용</h2><p><strong>dotTrace</strong>, <strong>BenchmarkDotNet</strong> 같은 도구를 사용해 실제 코드 성능을 분석하세요.</p><h2 id="14-단위-테스트unit-testing는-필수"><a class="markdownIt-Anchor" href="#14-단위-테스트unit-testing는-필수"></a> 14. 단위 테스트(Unit Testing)는 필수</h2><p>테스트 없이 배포했다가 서비스가 터지는 경험을 한 후, 단위 테스트의 중요성을 깨달았습니다.<br /><code>xUnit</code> 또는 <code>NUnit</code>을 활용하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add_ShouldReturnSum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Assert.Equal(<span class="number">5</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-source-generator-활용"><a class="markdownIt-Anchor" href="#15-source-generator-활용"></a> 15. Source Generator 활용</h2><p>C# 10부터 <strong>Source Generator</strong> 를 사용하여 컴파일 타임에 자동 코드 생성을 활용할 수 있습니다.</p><h2 id="16-net-6에서-minimal-api-활용"><a class="markdownIt-Anchor" href="#16-net-6에서-minimal-api-활용"></a> 16. .NET 6+에서 Minimal API 활용</h2><p>Minimal API는 불필요한 코드 없이 API를 빠르게 개발할 수 있도록 도와줍니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = WebApplication.Create();</span><br><span class="line">app.MapGet(<span class="string">"/hello"</span>, () =&gt; <span class="string">"Hello World"</span>);</span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><h2 id="17-끊임없이-배우고-공유하라"><a class="markdownIt-Anchor" href="#17-끊임없이-배우고-공유하라"></a> 17. 끊임없이 배우고, 공유하라</h2><p>최고의 개발자는 계속 배우고, 지식을 공유하는 사람입니다. 🚀<br />블로그, 오픈 소스 기여, 코드 리뷰를 통해 성장하세요!</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>시니어 .NET 개발자가 된다는 것은 단순히 코드만 작성하는 것이 아닙니다.<br /><strong>가독성 높은 코드, 유지보수 가능한 아키텍처, 성능을 고려한 설계, 그리고 보안을 철저히 지키는 것</strong>이 중요합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/03/10/csharp-17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ChatGPT를 활용하여 10배 빠르게 코딩하는 방법</title>
      <link>http://hgko1207.github.io/2025/03/04/chatgpt-35/</link>
      <guid>http://hgko1207.github.io/2025/03/04/chatgpt-35/</guid>
      <pubDate>Tue, 04 Mar 2025 06:33:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;많은 개발자들이 ChatGPT를 활용하고 있지만, 단순한 코드 생성에 그치는 경우가 많습니다. 하지만 상위 1% 개발자들은 ChatGPT를 단순
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-4.png" alt="" /></p><p>많은 개발자들이 ChatGPT를 활용하고 있지만, 단순한 코드 생성에 그치는 경우가 많습니다. 하지만 상위 1% 개발자들은 ChatGPT를 단순한 코드 생성기가 아니라 개발 파트너로 활용하여 복잡한 시스템을 빠르게 구축하고 있습니다.</p><p>다음은 ChatGPT를 사용하여 생산성을 극대화하는 방법입니다.</p><h2 id="1-명확한-문제-정의가-우선이다"><a class="markdownIt-Anchor" href="#1-명확한-문제-정의가-우선이다"></a> 1. 명확한 문제 정의가 우선이다</h2><p>단순히 “<strong>이 버그를 어떻게 고치죠?</strong>” 라고 묻는 것은 비효율적입니다. 대신, 다음 요소를 포함하여 구체적으로 설명하세요.</p><ul><li>✅ <strong>문제의 맥락 제공:</strong> 어떤 기능에서 문제가 발생하는지 설명</li><li>✅ <strong>목표 명확히 하기:</strong> 디버깅, 최적화, 리팩토링 중 어떤 것이 필요한지 구체화</li><li>✅ <strong>샘플 코드 포함:</strong> 문제가 발생한 코드 조각 제공</li><li>✅ <strong>사용하는 프레임워크 및 라이브러리 명시:</strong> Flask, Django, React 등의 기술 스택을 포함</li></ul><p>🔴 나쁜 예시:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">파이썬 코드 좀 도와줄 수 있어?</span><br></pre></td></tr></table></figure><p>🟢 좋은 예시:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flask API를 개발 중인데, PostgreSQL과 연결할 때 SQLAlchemy에서 500 에러가 발생합니다.</span><br><span class="line">오류 메시지는 [에러 코드] 이고, 관련된 코드는 [코드] 입니다.</span><br><span class="line">원인이 무엇이고, 어떻게 해결할 수 있을까요?</span><br></pre></td></tr></table></figure><h2 id="2-질문-대신-명령형-요청을-사용하라"><a class="markdownIt-Anchor" href="#2-질문-대신-명령형-요청을-사용하라"></a> 2. 질문 대신 명령형 요청을 사용하라</h2><p>ChatGPT에게 단순한 질문을 하기보다는 명확한 지시를 내리면 더욱 빠르고 유용한 답변을 얻을 수 있습니다.</p><p>❌ 비효율적인 질문</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">파이썬에서 데코레이터를 어떻게 사용하나요?</span><br></pre></td></tr></table></figure><p>✅ 효율적인 명령형 요청</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">함수의 실행 시간을 측정하는 데코레이터를 작성해줘.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python에서 static method와 class method의 차이를 예제와 함께 설명해줘.</span><br></pre></td></tr></table></figure><h2 id="3-빌드-업build-upon-기법을-활용하라"><a class="markdownIt-Anchor" href="#3-빌드-업build-upon-기법을-활용하라"></a> 3. &quot;빌드 업(Build Upon) 기법&quot;을 활용하라</h2><p>한 번에 완벽한 코드를 얻으려 하지 말고, 단계별로 발전시키세요.</p><p>1️⃣ <strong>기본 구조 생성</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeScript와 Express로 REST API의 기본 구조를 생성해줘.</span><br></pre></td></tr></table></figure><p>2️⃣ <strong>기능 추가</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JWT 인증을 추가하고, 리프레시 토큰과 비밀번호 재설정 기능을 포함해줘.</span><br></pre></td></tr></table></figure><p>3️⃣ <strong>최적화</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이제 Zod를 사용하여 요청 유효성 검사 및 Rate Limiting을 추가해줘.</span><br></pre></td></tr></table></figure><p>이런 방식으로 접근하면 반복적인 수정 없이 <strong>빠르고 안정적인 코드</strong>를 작성할 수 있습니다.</p><h2 id="4-chatgpt를-개인-기술-리드tech-lead처럼-활용하라"><a class="markdownIt-Anchor" href="#4-chatgpt를-개인-기술-리드tech-lead처럼-활용하라"></a> 4. ChatGPT를 개인 기술 리드(Tech Lead)처럼 활용하라</h2><p>단순한 코드 스니펫 요청이 아니라, 시스템 설계 수준에서 논의하는 것이 중요합니다.</p><p>🟢 효율적인 요청 예시</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">시니어 소프트웨어 아키텍트처럼 행동해줘.</span><br><span class="line">[프로젝트 개요]를 기반으로 다음 요소들을 논의하자.</span><br><span class="line"></span><br><span class="line">1. 시스템 요구사항과 제약 조건</span><br><span class="line">2. 핵심 아키텍처 결정 사항</span><br><span class="line">3. 데이터 모델 및 관계 설정</span><br><span class="line">4. API 설계</span><br><span class="line">5. 보안 고려 사항</span><br><span class="line"></span><br><span class="line">내가 설정한 가정들을 검토하고, 더 나은 대안을 제시해줘.</span><br></pre></td></tr></table></figure><p>이 요청 하나만으로도, 수많은 리팩토링을 방지할 수 있는 고급 설계를 ChatGPT와 함께 고민할 수 있습니다.</p><h2 id="5-점진적-구현-방식-incremental-implementation"><a class="markdownIt-Anchor" href="#5-점진적-구현-방식-incremental-implementation"></a> 5. 점진적 구현 방식 (Incremental Implementation)</h2><p>한 번에 전체 코드베이스를 입력하지 말고, <strong>단계별로 진행하는 것이 효과적</strong>입니다.</p><p>1️⃣ <strong>설계 공유</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">이전에 논의한 내용을 바탕으로 [특정 컴포넌트]를 구현하려고 합니다.</span><br><span class="line">현재 계획은 다음과 같습니다.</span><br><span class="line">[설계 개요]</span><br><span class="line"></span><br><span class="line">이 접근법에서 놓치고 있는 엣지 케이스가 있을까요? 대규모 트래픽에서 문제가 될 요소는 무엇인가요?</span><br></pre></td></tr></table></figure><p>2️⃣ <strong>구현 방법 논의</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[특정 기능]을 구현할 때 최적의 방식은 무엇인가요?</span><br><span class="line">성능, 유지보수성, 테스트 전략을 고려하여 코드를 작성해줘.</span><br></pre></td></tr></table></figure><p>3️⃣ <strong>코드 리뷰 및 최적화</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이 코드의 성능, 보안, 디자인 패턴 개선점, 예외 처리를 점검해줘.</span><br></pre></td></tr></table></figure><p>이렇게 진행하면, <strong>더 나은 설계를 기반으로 코드 품질을 향상</strong>시킬 수 있습니다.</p><h2 id="6-문서-탐색을-chatgpt에게-맡겨라"><a class="markdownIt-Anchor" href="#6-문서-탐색을-chatgpt에게-맡겨라"></a> 6. 문서 탐색을 ChatGPT에게 맡겨라</h2><p>문서를 일일이 찾아보는 대신, ChatGPT가 문서를 요약해 주도록 활용하면 시간을 절약할 수 있습니다.</p><p>🟢 효율적인 요청 예시</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">너는 [프레임워크&#x2F;언어] 전문가야.</span><br><span class="line">[기능]을 구현하려고 하는데, 관련 API와 클래스,</span><br><span class="line">자주 발생하는 실수 및 최적화 방법을 코드 예제와 함께 설명해줘.</span><br></pre></td></tr></table></figure><p>이렇게 요청하면 <strong>가장 중요한 개념만 압축하여 학습</strong>할 수 있습니다.</p><h2 id="일반적인-반박에-대한-반론"><a class="markdownIt-Anchor" href="#일반적인-반박에-대한-반론"></a> 🔥 일반적인 반박에 대한 반론</h2><h3 id="ai가-생성한-코드는-믿을-수-없어"><a class="markdownIt-Anchor" href="#ai가-생성한-코드는-믿을-수-없어"></a> 💭 “AI가 생성한 코드는 믿을 수 없어!”</h3><p>그래서 코드 리뷰를 요청하는 겁니다. AI가 완벽하진 않지만, 올바른 질문을 던지면 <strong>품질 검토까지 가능</strong>합니다.</p><h3 id="ai가-대신하면-내가-성장하지-못하는-거-아닌가"><a class="markdownIt-Anchor" href="#ai가-대신하면-내가-성장하지-못하는-거-아닌가"></a> 💭 “AI가 대신하면 내가 성장하지 못하는 거 아닌가?”</h3><p>오히려 반대입니다. ChatGPT는 단순한 답변이 아니라 <strong>설계 의도, 패턴, 대체 방법까지 설명</strong>해 주기 때문에 더욱 깊이 있는 학습이 가능합니다.</p><h3 id="ai를-활용하는-건-부정직한-거-아닌가"><a class="markdownIt-Anchor" href="#ai를-활용하는-건-부정직한-거-아닌가"></a> 💭 “AI를 활용하는 건 부정직한 거 아닌가?”</h3><p>시니어 개발자에게 멘토링을 받는 것이 부정직한가요?<br />AI를 활용하는 것은 <strong>더 빠르고 효율적으로 성장하는 방법</strong>입니다.</p><h2 id="앞으로-개발자들이-갈라질-두-가지-길"><a class="markdownIt-Anchor" href="#앞으로-개발자들이-갈라질-두-가지-길"></a> 🚀 앞으로 개발자들이 갈라질 두 가지 길</h2><p>AI를 활용하는 개발자와 그렇지 않은 개발자의 생산성 차이는 점점 더 벌어지고 있습니다.</p><ul><li>✅ AI와 협업하며 <strong>10배 빠르게 성장하는 개발자</strong></li><li>❌ 여전히 Stack Overflow를 복사-붙여넣기 하며 <strong>정체된 개발자</strong></li></ul><p><strong>💡 당신의 코딩 속도를 10배 높일 준비가 되었나요?</strong><br />이제 ChatGPT를 단순한 코드 도구가 아니라, 당신만의 AI 개발 파트너로 활용해보세요! 🚀</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/03/04/chatgpt-35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker 전문가들이 99%까지 이미지 크기를 줄이는 숨겨진 기술</title>
      <link>http://hgko1207.github.io/2025/02/04/docker-3/</link>
      <guid>http://hgko1207.github.io/2025/02/04/docker-3/</guid>
      <pubDate>Tue, 04 Feb 2025 06:41:53 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Docker 이미지는 디스크 공간을 차지하고 배포 속도를 늦추는 문제를 유발할 수 있습니다. 하지만 최상위 DevOps 팀들은 이미 &lt;strong&gt;이미지 크기를 최대 99%까지 줄이는 기술&lt;/strong&gt;을 활용하고 있습니다. 이번 글에서는 이러
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Docker 이미지는 디스크 공간을 차지하고 배포 속도를 늦추는 문제를 유발할 수 있습니다. 하지만 최상위 DevOps 팀들은 이미 <strong>이미지 크기를 최대 99%까지 줄이는 기술</strong>을 활용하고 있습니다. 이번 글에서는 이러한 숨겨진 최적화 기법을 공개합니다.</p><h2 id="🚀-과도한-Docker-이미지가-초래하는-숨은-비용">🚀 과도한 Docker 이미지가 초래하는 숨은 비용</h2><p>Docker 이미지가 너무 크면 단순한 불편을 넘어 다음과 같은 비용을 발생시킵니다.</p><ul><li>✅ <strong>시간 낭비:</strong> 빌드 및 배포 속도가 느려짐</li><li>✅ <strong>비용 증가:</strong> 저장 공간과 네트워크 대역폭 사용 증가</li><li>✅ <strong>성능 저하:</strong> 애플리케이션 응답 속도 감소</li></ul><h2 id="📉-1-2GB-→-8MB로-최적화-실제-사례">📉 1.2GB → 8MB로 최적화: 실제 사례</h2><p>이러한 기술의 힘을 보여주기 위해 실제 사례를 살펴보겠습니다. 초기 Docker 이미지 크기가 1.2GB인 기존 Python 기반 머신 러닝 애플리케이션을 가져와서 8MB로 최적화했습니다. 그 방법은 다음과 같습니다.</p><ul><li><strong>멀티 스테이지 빌드(Multi-Stage Builds)</strong></li><li><strong>레이어 최적화(Layer Optimizations)</strong></li><li><strong>최소 베이스 이미지(Scratch, Alpine 등) 활용</strong></li><li><strong>Distroless 이미지 및 고급 최적화 기법</strong></li><li><strong>보안 모범 사례 적용</strong></li></ul><h2 id="기본-Dockerfile-비효율적인-설정">기본 Dockerfile: 비효율적인 설정</h2><p>일반적인 Dockerfile은 다음과 같을 것입니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"main.py"</span>]</span></span><br></pre></td></tr></table></figure><p>이 Dockerfile은 정상적으로 작동하지만, 다음과 같은 이유로 거대한 이미지 크기를 초래합니다.</p><ul><li><strong>전체 Python 이미지를 사용</strong></li><li><strong>불필요한 빌드 도구 및 종속성 포함</strong></li><li><strong>비효율적인 레이어 캐싱</strong></li><li><strong>불필요한 파일이 포함될 가능성</strong></li></ul><p>이제 최적화 기술을 활용하여 이 문제를 해결해 보겠습니다.</p><h2 id="1️⃣-멀티-스테이지-빌드-Multi-Stage-Builds">1️⃣ 멀티 스테이지 빌드(Multi-Stage Builds)</h2><p>멀티 스테이지 빌드는 빌드 단계에서 필요한 패키지와 런타임 단계에서 필요한 패키지를 분리하여 최종 Docker 이미지의 크기를 크게 줄일 수 있습니다.</p><p><strong>✅ 최소한의 베이스 이미지 사용</strong></p><ul><li>전체 Python 버전 대신 Slim 또는 Alpine 버전을 선택하여 사용 사례에 맞게 최적화합니다.</li></ul><h3 id="기존-단일-스테이지-Dockerfile">기존 단일 스테이지 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 공식 Python 런타임을 부모 이미지로 사용</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필수 빌드 종속성 설치</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 작업 디렉토리 설정</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 의존성 파일 복사 및 설치</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 애플리케이션 코드 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 모델 컴파일 (필요한 경우)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python compile_model.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 스크립트 실행</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"inference.py"</span>]</span></span><br></pre></td></tr></table></figure><p>이 이미지의 최종 크기는 <strong>약 1.2GB</strong>입니다.<br>이는 빌드 도구와 개발 라이브러리를 포함하고 있기 때문입니다.</p><h3 id="멀티-스테이지-Dockerfile-적용">멀티 스테이지 Dockerfile 적용</h3><p><strong>🎯 단계 1: 빌드 스테이지</strong></p><ul><li>작업 디렉토리 설정</li><li>필수 빌드 도구 설치</li><li>Python 의존성 설치</li><li>애플리케이션 코드 복사</li><li>PyInstaller를 사용하여 독립 실행 파일 생성</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 빌드 스테이지</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필수 빌드 종속성 설치</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 작업 디렉토리 설정</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 의존성 파일 복사 및 설치</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 애플리케이션 코드 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 모델 컴파일 (필요한 경우)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python compile_model.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PyInstaller 설치</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install pyinstaller</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 독립 실행 파일 생성</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pyinstaller --onefile inference.py</span></span><br></pre></td></tr></table></figure><p><strong>🎯 단계 2: 프로덕션 스테이지</strong></p><ul><li><code>scratch</code> 이미지를 사용하여 완전히 비어있는 환경에서 시작</li><li>빌드 스테이지에서 필요한 파일만 복사</li><li>컴파일된 실행 파일을 엔트리포인트로 설정</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 프로덕션 스테이지</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 작업 디렉토리 설정</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 빌드 스테이지에서 필요한 파일만 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/dist/inference /app/inference</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/model /app/model</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 추론 실행 파일 실행</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/app/inference"</span>]</span></span><br></pre></td></tr></table></figure><p>✅ <strong>빌드 결과:</strong> 85MB 크기의 Docker 이미지 생성 (90% 이상 감소)</p><h2 id="2️⃣-레이어-최적화-Layer-Optimization-불필요한-용량-줄이기">2️⃣ 레이어 최적화(Layer Optimization): 불필요한 용량 줄이기</h2><p>Dockerfile에서 <code>RUN</code>, <code>COPY</code>, <code>ADD</code> 명령어는 각각 새로운 레이어를 생성합니다.<br>즉, 불필요한 레이어를 최소화하면 이미지 크기를 더욱 줄일 수 있습니다.</p><h3 id="🚨-비효율적인-예제">🚨 비효율적인 예제</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y python3-pip python3-dev</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install numpy pandas</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get clean</span></span><br></pre></td></tr></table></figure><p>🔴 각 RUN 명령어가 별도 레이어를 생성하여 이미지 크기가 커집니다.</p><h3 id="✅-최적화된-예제">✅ 최적화된 예제</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y python3-pip python3-dev &amp;&amp; \</span></span><br><span class="line"><span class="bash">    pip install numpy pandas &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><p>✅ 하나의 RUN 명령어에서 여러 작업을 수행하면 불필요한 레이어 생성을 방지할 수 있습니다.</p><h2 id="3️⃣-최소-베이스-이미지-사용-Scratch-Alpine-등">3️⃣ 최소 베이스 이미지 사용 (Scratch, Alpine 등)</h2><p>가장 강력하면서도 도전적인 방법은 <strong>Scratch 이미지</strong>를 사용하는 것입니다.</p><p><strong>✅ Scratch 이미지란?</strong></p><ul><li>운영체제가 포함되지 않은 완전한 빈 이미지</li><li>의존성 없음 (필요한 파일을 직접 추가해야 함)</li><li>가장 작은 이미지 크기 유지</li></ul><p><strong>💡 Scratch 이미지가 유용한 경우:</strong></p><ul><li><p><strong>사용자 정의 베이스 이미지 생성:</strong> 독자적인 리눅스 배포판을 만든 경우, Ubuntu 같은 베이스 이미지 없이 Scratch 이미지 위에서 실행 가능</p></li><li><p><strong>독립 실행형 애플리케이션 배포:</strong> Python 기반 머신러닝 모델 서버를 PyInstaller로 컴파일 후, Scratch 이미지에 추가</p></li></ul><p><strong>📌 예제 Dockerfile (Scratch 이미지 사용)</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> myapp /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/myapp"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="4️⃣-Distroless-이미지-사용">4️⃣ Distroless 이미지 사용</h2><p>Distroless 이미지는 <strong>Scratch 이미지와 전체 운영체제 이미지의 중간 형태</strong>입니다.<br>Google에서 제공하며, 필수 구성 요소만 포함하여 불필요한 부분을 제거한 최적의 솔루션입니다.</p><p><strong>📌 Distroless 이미지의 특징:</strong></p><ul><li>✅ 전체 운영체제 이미지보다 더 작음</li><li>✅ 보안성이 강화됨 (불필요한 패키지 제거)</li><li>✅ SSL 인증서 및 타임존 데이터 포함</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> gcr.io/distroless/python3-debian10</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/dist/main /app/main</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/model /app/model</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/config.yml /app/config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/app/main"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="5️⃣-Docker-BuildKit-활성화">5️⃣ Docker BuildKit 활성화</h2><p>Docker BuildKit을 활성화하면 <strong>더 빠르고 안전한 빌드</strong>가 가능합니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_BUILDKIT=<span class="number">1</span> docker build -t myapp .</span><br></pre></td></tr></table></figure><h2 id="6️⃣-불필요한-파일-제거">6️⃣ 불필요한 파일 제거</h2><ul><li>❌ 애플리케이션 데이터를 Docker 이미지 내부에 보관하지 마세요.</li><li>✅ 외부 스토리지 (예: AWS S3, MySQL) 또는 Docker 볼륨을 활용하세요.</li></ul><p>📌 <code>.dockerignore</code> 파일 활용:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 대용량 데이터셋 제외</span></span><br><span class="line">data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 가상 환경 제외</span></span><br><span class="line">venv/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 캐시 및 로그 및 임시 파일 제외</span></span><br><span class="line">__pycache__/</span><br><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">*.pyc</span><br><span class="line">*.pyo</span><br><span class="line">.pytest_cache</span><br><span class="line">.git</span><br><span class="line">.gitignore</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모델 학습 체크포인트 및 텐서보드 로그</span></span><br><span class="line">checkpoints/</span><br><span class="line">runs/</span><br></pre></td></tr></table></figure><h2 id="7️⃣-이미지-분석-도구-활용">7️⃣ 이미지 분석 도구 활용</h2><p>Dive 및 Docker Slim 같은 도구를 활용하여 Docker 이미지 내부를 분석하고 불필요한 파일을 제거하세요.</p><p><strong>📌 Dive 사용법:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dive my-docker-image</span><br></pre></td></tr></table></figure><p><strong>📌 Docker Slim 사용법:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-slim build my-docker-image</span><br></pre></td></tr></table></figure><h2 id="8️⃣-보안-강화를-위한-모범-사례">8️⃣ 보안 강화를 위한 모범 사례</h2><ul><li>✅ 신뢰할 수 있는 공식 베이스 이미지 사용</li><li>✅ 루트 사용자를 피하고 일반 사용자로 컨테이너 실행</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> adduser --disabled-password --gecos <span class="string">""</span> appuser</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br></pre></td></tr></table></figure><ul><li>✅ 네트워크 노출 최소화</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 127.0.0.1:8080:8080 myimage</span><br></pre></td></tr></table></figure><ul><li>✅ 보안 취약점 스캔 (Trivy 활용)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker scan my-image:tag</span><br></pre></td></tr></table></figure><h2 id="최적화-결과">최적화 결과</h2><table><thead><tr><th>항목</th><th>최적화 전</th><th>최적화 후</th></tr></thead><tbody><tr><td><strong>이미지 크기</strong></td><td>1.2GB</td><td>8MB (99.33% 감소)</td></tr><tr><td><strong>배포 시간</strong></td><td>10초</td><td>1.5초 (85% 감소)</td></tr><tr><td><strong>클라우드 비용</strong></td><td>100%</td><td>40% 절감</td></tr></tbody></table><h2 id="결론">결론</h2><ul><li>멀티 스테이지 빌드와 Distroless 이미지를 활용하여 Docker 이미지를 최적화하세요.</li><li>최소한의 패키지만 포함한 Slim 또는 Scratch 이미지를 사용하세요.</li><li>레이어를 최소화하고 불필요한 파일을 제거하여 성능과 보안을 강화하세요.</li></ul><p>이제 <strong>여러분도 Docker 이미지를 99% 더 작게 만들 수 있습니다! 🚀</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/02/04/docker-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>.NET 성능 저하 안티 패턴 10가지와 해결 방법</title>
      <link>http://hgko1207.github.io/2025/02/04/csharp-16/</link>
      <guid>http://hgko1207.github.io/2025/02/04/csharp-16/</guid>
      <pubDate>Tue, 04 Feb 2025 06:08:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;애플리케이션의 성능 병목 현상은 효율성, 확장성, 사용자 경험을 저하시킬 수 있습니다. 많은 .NET 개발자들은 무의식적으로 성능을 저하시킬 수 있는 안티 패턴을 따르게 됩니다. 이번 글에서는 대표적인 .NET 성능 저하 안티 패턴 10가지를 살
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>애플리케이션의 성능 병목 현상은 효율성, 확장성, 사용자 경험을 저하시킬 수 있습니다. 많은 .NET 개발자들은 무의식적으로 성능을 저하시킬 수 있는 안티 패턴을 따르게 됩니다. 이번 글에서는 대표적인 .NET 성능 저하 안티 패턴 10가지를 살펴보고, 그것이 왜 문제인지, 그리고 최적화된 해결 방법을 제시하겠습니다.</p><h2 id="1-과도한-객체-할당-및-가비지-컬렉션-GC-부하">1. 과도한 객체 할당 및 가비지 컬렉션(GC) 부하</h2><p><strong>문제점:</strong></p><ul><li>짧은 수명의 객체를 너무 많이 생성하면 빈번한 GC 실행을 유발하여 애플리케이션 성능을 저하시킵니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>재사용 가능한 객체를 위한 <strong>객체 풀링(Object Pooling)</strong> 사용</li><li>작은 크기의 불변 객체는 <strong>클래스 대신 구조체(Struct)</strong> 사용</li><li><strong>Span 및 Memory</strong> 사용하여 할당 줄이기</li><li>필요할 경우 <strong>GC 설정(GCSettings.LargeObjectHeapCompactionMode)</strong> 튜닝</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화: MemoryPool을 사용하여 메모리 재사용</span></span><br><span class="line"><span class="keyword">var</span> pool = MemoryPool&lt;<span class="keyword">byte</span>&gt;.Shared;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> owner = pool.Rent(<span class="number">1024</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> memory = owner.Memory;</span><br><span class="line">    <span class="comment">// 메모리 처리 로직</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-비동기-코드-차단-Sync-Over-Async">2. 비동기 코드 차단 (Sync Over Async)</h2><p><strong>문제점:</strong></p><ul><li>비동기 메서드에서 <code>.Result</code> 또는 <code>.GetAwaiter().GetResult()</code>를 호출하면 스레드가 차단되어 데드락이 발생할 수 있습니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>항상 <strong>async/await</strong> 사용</li><li>동기 코드와 비동기 코드를 섞어 사용하지 않기</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetDataAsync().Result; <span class="comment">// 스레드 차단 발생</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> FetchDataFromServiceAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-비효율적인-데이터베이스-쿼리">3. 비효율적인 데이터베이스 쿼리</h2><p><strong>문제점:</strong></p><ul><li>ORM (예: Entity Framework)에서 N+1 문제 발생</li><li>적절한 인덱스 미사용</li><li>불필요한 데이터 조회</li></ul><p><strong>해결 방법:</strong></p><ul><li>Lazy Loading 대신 Eager Loading 사용 (필요한 데이터를 한 번에 가져오기)</li><li>페이징 및 인덱싱 최적화</li><li>EF Core 로깅을 활용하여 쿼리 프로파일링</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">var</span> orders = context.Orders.ToList();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> order <span class="keyword">in</span> orders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> customer = context.Customers.Find(order.CustomerId); <span class="comment">// N+1 문제 발생</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">var</span> ordersWithCustomers = context.Orders.Include(o =&gt; o.Customer).ToList();</span><br></pre></td></tr></table></figure><h2 id="4-과도한-Reflection-사용">4. 과도한 Reflection 사용</h2><p><strong>문제점:</strong></p><ul><li>Reflection은 메타데이터를 검사해야 하므로 성능 비용이 큽니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>컴파일된 표현식(Compiled Expressions) 또는 소스 생성기(Source Generators) 사용</li><li>Reflection 결과 캐싱</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(MyClass);</span><br><span class="line"><span class="keyword">var</span> property = type.GetProperty(<span class="string">"MyProperty"</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = property.GetValue(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">var</span> propertyDelegate = (Func&lt;MyClass, <span class="keyword">object</span>&gt;)Delegate.CreateDelegate(</span><br><span class="line">    <span class="keyword">typeof</span>(Func&lt;MyClass, <span class="keyword">object</span>&gt;), <span class="literal">null</span>, type.GetProperty(<span class="string">"MyProperty"</span>).GetMethod);</span><br><span class="line"><span class="keyword">var</span> valueOptimized = propertyDelegate(instance);</span><br></pre></td></tr></table></figure><h2 id="5-루프에서-문자열-연결-사용">5. 루프에서 문자열 연결 사용</h2><p><strong>문제점:</strong></p><ul><li>문자열은 불변 객체이므로, 반복적으로 문자열을 연결하면 새로운 객체가 계속 생성됩니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>StringBuilder 사용</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    result += i.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sb.Append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">string</span> optimizedResult = sb.ToString();</span><br></pre></td></tr></table></figure><h2 id="6-캐싱을-활용하지-않음">6. 캐싱을 활용하지 않음</h2><p><strong>문제점:</strong></p><ul><li>같은 비용이 큰 연산을 반복 실행하면 불필요한 자원이 낭비됩니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>MemoryCache, Redis 또는 Lazy 사용</li><li>출력 캐싱(Output Caching) 적용</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> MemoryCache _cache = <span class="keyword">new</span> MemoryCache(<span class="keyword">new</span> MemoryCacheOptions());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetExpensiveData</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cache.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">string</span> cachedData))</span><br><span class="line">    &#123;</span><br><span class="line">        cachedData = ComputeExpensiveData();</span><br><span class="line">        _cache.Set(key, cachedData, TimeSpan.FromMinutes(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-비동기-데이터베이스-호출-미사용">7. 비동기 데이터베이스 호출 미사용</h2><p><strong>문제점:</strong></p><ul><li>동기적인 데이터베이스 쿼리는 스레드를 차단하고 확장성을 저하시킵니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>EF Core의 ToListAsync() 등의 비동기 메서드 사용</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">var</span> users = context.Users.ToList(); <span class="comment">// 스레드 차단 발생</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">var</span> users = <span class="keyword">await</span> context.Users.ToListAsync();</span><br></pre></td></tr></table></figure><h2 id="8-성능이-중요한-경로에서-과도한-로깅">8. 성능이 중요한 경로에서 과도한 로깅</h2><p><strong>문제점:</strong></p><ul><li>과도한 로깅은 실행 속도를 저하시킵니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>조건부 로깅 사용</li><li>핫 패스(Hot Path)에서는 로그 레벨을 줄이기</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line">_logger.LogInformation(<span class="string">"Processing item: &#123;Id&#125;"</span>, item.Id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">if</span> (_logger.IsEnabled(LogLevel.Debug))</span><br><span class="line">&#123;</span><br><span class="line">    _logger.LogDebug(<span class="string">"Processing item: &#123;Id&#125;"</span>, item.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-LINQ-비효율적-사용">9. LINQ 비효율적 사용</h2><p><strong>문제점:</strong></p><ul><li>필터링 전에 .ToList()를 호출하면 불필요한 메모리 사용이 발생합니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>지연 실행(Deferred Execution) 활용</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안티 패턴</span></span><br><span class="line"><span class="keyword">var</span> filteredUsers = context.Users.ToList().Where(u =&gt; u.IsActive);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화</span></span><br><span class="line"><span class="keyword">var</span> filteredUsers = context.Users.Where(u =&gt; u.IsActive).ToList();</span><br></pre></td></tr></table></figure><h2 id="10-대량-데이터-처리-시-비동기-스트림-미사용">10. 대량 데이터 처리 시 비동기 스트림 미사용</h2><p><strong>문제점:</strong></p><ul><li>대량 데이터를 한 번에 로드하면 메모리 사용량이 증가합니다.</li></ul><p><strong>해결 방법:</strong></p><ul><li>IAsyncEnumerable을 사용하여 스트리밍 방식으로 데이터 처리</li></ul><p><strong>예제 코드:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;User&gt; <span class="title">GetUsersAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> context.Users.AsAsyncEnumerable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="핵심-요약">핵심 요약</h2><p>✅ <strong>GC 부하를 줄이기 위해 과도한 객체 할당을 방지</strong><br>✅ <strong>비동기 프로그래밍을 적극 활용하여 응답성 향상</strong><br>✅ <strong>불필요한 데이터 조회를 최소화하도록 쿼리 최적화</strong><br>✅ <strong>캐싱을 활용하여 중복 연산 방지</strong><br>✅ <strong>성능이 중요한 경로에서 불필요한 로깅 최소화</strong></p><p>이러한 안티 패턴을 개선하면 .NET 애플리케이션의 성능, 확장성, 안정성을 크게 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/02/04/csharp-16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩에 필요한 11개의 놀라운 GitHub 저장소</title>
      <link>http://hgko1207.github.io/2025/01/17/github-1/</link>
      <guid>http://hgko1207.github.io/2025/01/17/github-1/</guid>
      <pubDate>Fri, 17 Jan 2025 14:04:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;코딩을 배우는 것은 비교적 쉬운 일입니다. 그러나 더 나은 코드를 작성하는 기술을 마스터하는 것은 훨씬 더 어렵습니다. GitHub는 개발자들에게 보물창고와 같은 존재로, 여기서 &amp;quot;&lt;strong&gt;gold&lt;/strong&gt;&amp;quot;는 다른
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>코딩을 배우는 것은 비교적 쉬운 일입니다. 그러나 더 나은 코드를 작성하는 기술을 마스터하는 것은 훨씬 더 어렵습니다. GitHub는 개발자들에게 보물창고와 같은 존재로, 여기서 &quot;<strong>gold</strong>&quot;는 다른 사람들이 공유한 잘 작성된 코드입니다. GitHub를 탐험함으로써 더 깨끗한 코드를 작성하는 방법을 배우고, 고품질 코드가 무엇인지 이해하며, 더 숙련된 개발자가 되기 위한 필수 단계를 배울 수 있습니다.</p><h2 id="1-notwaldorf-emoji-translate">1. <a href="https://github.com/notwaldorf/emoji-translate" target="_blank" rel="noopener">notwaldorf/emoji-translate</a></h2><p>누가 평범한 텍스트가 필요하다고 했나요? 이제 완전히 이모지로 소통할 수 있습니다!</p><p>이 저장소는 Python 패키지 <code>moji-translate</code>에 속하며, 텍스트를 이모지가 가득한 메시지로 변환합니다.</p><p>공통 단어와 구문을 해당 이모지로 매핑하는 사전 기반 접근 방식을 활용하여 텍스트 메시지를 시각적으로 재미있게 만듭니다. 이는 일상적인 텍스트를 소셜 미디어, 메시징 앱, 또는 창의적인 마케팅 캠페인에 적합한 유쾌하고 이모지가 풍부한 콘텐츠로 변환할 수 있습니다.</p><h2 id="2-tycrek-degoogle">2. <a href="https://github.com/tycrek/degoogle" target="_blank" rel="noopener">tycrek/degoogle</a></h2><p>이 프로젝트는 현재 아카이브 상태이며, 사용자가 Google 서비스 의존도를 줄일 수 있도록 개인 정보 보호 중심의 대안을 포괄적으로 제공하는 것을 목표로 합니다. 그리고 검색 엔진, 이메일 서비스, 클라우드 스토리지 등 다양한 카테고리에서 엄선된 대안을 제안합니다.</p><p>이 레포지토리는 사용자 개인 정보 보호와 데이터 보안을 우선시하는 도구를 추천합니다. 2024년 8월 26일 아카이브 상태로 전환되었지만, 참고와 연구 목적으로 여전히 내용을 공개하고 있습니다. 커뮤니티는 아카이브 전까지 업데이트와 문제 논의를 통해 기여했습니다.</p><h2 id="3-you-dont-need-You-Dont-Need-JavaScript">3. <a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript" target="_blank" rel="noopener">you-dont-need/You-Dont-Need-JavaScript</a></h2><p>이 레포지토리는 JavaScript에 의존하지 않고도 인터랙티브한 웹 환경을 만드는 기술을 소개합니다.</p><p>HTML과 CSS를 활용하여 일반적으로 JavaScript로 구현되는 아코디언, 모달, 툴팁과 같은 기능을 구현하는 방법에 초점을 맞추고 있습니다. 이러한 접근 방식은 외부 종속성을 줄여 간결성을 유지하고 성능을 최적화하는 데 기여합니다.</p><h2 id="4-tg-bomze-Face-Depixelizer">4. <a href="https://github.com/tg-bomze/Face-Depixelizer" target="_blank" rel="noopener">tg-bomze/Face-Depixelizer</a></h2><p>이 레포지토리는 <strong>PULSE</strong>(Photo Upsampling via Latent Space Exploration) 기술을 기반으로 한 <strong>StyleGAN</strong>이라는 생성 모델을 활용합니다.</p><p>저해상도 이미지를 고해상도로 변환하여 시각적으로 현실적인 결과를 제공합니다.<br>디픽셀화 과정은 생성 모델의 <strong>잠재 공간</strong>(latent space)을 탐색하여 이미지 품질을 향상시키며, 올바른 스케일을 유지하여 보다 선명한 시각적 결과를 얻도록 돕습니다.</p><h2 id="5-kdeldycke-awesome-falsehood">5. <a href="https://github.com/kdeldycke/awesome-falsehood" target="_blank" rel="noopener">kdeldycke/awesome-falsehood</a></h2><p>프로그래머들이 믿는 잘못된 상식(falsehoods)을 모아 놓은 정리된 리스트입니다. Falsehood이란 처음에는 사실이라고 믿었지만, 실제로는 잘못된 것으로 증명된 개념을 의미합니다.</p><p>예를 들어,<br>“유효한 이메일 주소에는 정확히 하나의 @ 문자가 포함되어야 한다.”<br>이 규칙을 바탕으로 이메일 필드 검증 로직을 구현하려고 한다면, 맞을까요?</p><p><strong>아닙니다!</strong><br>실제로 이메일 주소에는 여러 개의 @ 문자가 포함될 수도 있습니다. 따라서, 검증 로직도 이를 고려해야 합니다.<br>이처럼 처음에는 사실처럼 보이지만 잘못된 개념들을 정리한 레포지토리입니다.</p><h2 id="6-minimaxir-big-list-of-naughty-strings">6. <a href="https://github.com/minimaxir/big-list-of-naughty-strings" target="_blank" rel="noopener">minimaxir/big-list-of-naughty-strings</a></h2><p>이 레포지토리는 소프트웨어 시스템에서 사용자 입력으로 사용될 때 문제가 될 수 있는 문자열들을 모아놓은 목록입니다.</p><p>이러한 <strong>“naughty” 문자열</strong>은 예상치 못한 동작을 유발하거나, 애플리케이션 충돌 및 보안 취약점을 초래할 수 있습니다.<br>주로 <strong>QA(품질 보증) 테스트</strong>에 활용되며, 개발자가 애플리케이션이 엣지 케이스를 효과적으로 처리할 수 있도록 돕습니다.</p><p>이 목록에는 <strong>보이지 않는 유니코드 문자</strong> 또는 <strong>일반적인 입력 검증 시스템을 깨트리는 문자들</strong>과 같은 다양한 문제성 문자열이 포함되어 있습니다.</p><h2 id="7-EbookFoundation-free-programming-books">7. <a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">EbookFoundation/free-programming-books</a></h2><p>이 레포지토리는 GitHub에서 발견할 수 있는 또 하나의 보물과도 같은 자료입니다.</p><p><strong>EbookFoundation</strong>에서 제공하는 이 레포지토리에는 <strong>무료 프로그래밍 서적 목록</strong>이 포함되어 있습니다.<br>20개 이상의 언어로 제공되는 무료 책 링크를 찾을 수 있으며, 1,000권 이상의 책이 100개 이상의 프로그래밍 언어와 수많은 개념을 다루고 있습니다.</p><h2 id="8-public-apis-public-apis">8. <a href="https://github.com/public-apis/public-apis" target="_blank" rel="noopener">public-apis/public-apis</a></h2><p>소프트웨어 및 웹 개발에서 활용할 수 있는 <strong>무료 API 목록</strong>을 모아놓은 레포지토리입니다.</p><h2 id="9-jwasham-coding-interview-university">9. <a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">jwasham/coding-interview-university</a></h2><p>면접을 앞두고 계신가요? 준비할 면접 질문을 찾고 계신가요?<br>이 레포지토리는 <strong>코딩 면접 준비를 위한 다양한 질문들</strong>을 제공합니다.</p><p>Python 개발자 면접이든, JavaScript 개발자 면접이든, 전문적으로 설계된 면접 질문을 다수 찾아볼 수 있습니다.<br>또한, <strong>자료구조와 동적 프로그래밍</strong> 관련 질문도 광범위하게 다루고 있으며, <strong>시간 및 공간 복잡도</strong>와 최적화 방법에 대한 질문도 포함되어 있습니다.</p><h2 id="10-tauri-apps-tauri">10. <a href="https://github.com/tauri-apps/tauri" target="_blank" rel="noopener">tauri-apps/tauri</a></h2><p><strong>Tauri</strong>는 HTML, CSS, JavaScript와 같은 최신 웹 기술을 사용하여 <strong>안전하고, 가볍고, 고성능의 데스크톱 애플리케이션을 개발할 수 있도록 설계된 오픈소스 프레임워크</strong>입니다.</p><p>기존 프레임워크가 전체 브라우저 엔진을 번들로 포함하는 것과 달리, <strong>Tauri는 시스템의 네이티브 웹 렌더러를 사용하여 애플리케이션 크기와 메모리 사용량을 줄입니다.</strong><br>또한 <strong>React, Vue.js, Svelte</strong>와 같은 프런트엔드 프레임워크를 지원하며, 이를 통해 Windows, macOS, Linux에서 실행되는 크로스플랫폼 애플리케이션을 개발할 수 있습니다.</p><p>Tauri는 <strong>보안성을 최우선으로 고려</strong>하여, 애플리케이션의 공격 표면을 최소화하고 <strong>파일 관리, 알림과 같은 시스템 수준의 작업을 위한 안전한 API 바인딩을 제공합니다.</strong><br>Rust 기반 백엔드를 사용하여 <strong>속도와 안정성을 보장</strong>하며, 성능과 최신 웹 개발 기술 간의 균형을 찾는 개발자들에게 이상적인 솔루션입니다.</p><h2 id="11-CopilotKit">11. <a href="https://github.com/CopilotKit/CopilotKit" target="_blank" rel="noopener">CopilotKit</a></h2><p><strong>CopilotKit</strong>은 애플리케이션 내에서 AI 비서 및 에이전트를 깊이 통합하여 구축할 수 있도록 설계된 오픈소스 프레임워크입니다.</p><p>이 프레임워크는 스프레드시트 데이터 분석, 금융 관리, 여행 계획, 학술 연구 등 다양한 활용 사례를 지원하며, 대화형 자연어 인터페이스를 통해 사용자가 AI를 보다 직관적으로 활용할 수 있도록 돕습니다.</p><p>개발자는 CopilotKit의 라이브러리를 활용하여 프런트엔드 UI 컴포넌트, 실시간 상태 관리, 구조화된 자동완성 기능 등을 갖춘 맞춤형 AI 도구를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/17/github-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ChatGPT가 만들어줄 수 있는 7가지 제품</title>
      <link>http://hgko1207.github.io/2025/01/09/chatgpt-34/</link>
      <guid>http://hgko1207.github.io/2025/01/09/chatgpt-34/</guid>
      <pubDate>Thu, 09 Jan 2025 06:11:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 이제 많은 사람들의 마음을 사로잡은 도구가 되었습니다. 하지만 단순히 대화를 나누는 데 그치지 않고, 창작자들의 완벽한 조력자 역할도 수행할 수 있습니다! 흥미로운 콘텐츠부터 유용한 도구, 창의적인 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>ChatGPT</strong>는 이제 많은 사람들의 마음을 사로잡은 도구가 되었습니다. 하지만 단순히 대화를 나누는 데 그치지 않고, 창작자들의 완벽한 조력자 역할도 수행할 수 있습니다! 흥미로운 콘텐츠부터 유용한 도구, 창의적인 영감까지 필요한 모든 것을 생산해내며 생산성을 크게 향상시킬 수 있습니다.</p><p>오늘은 ChatGPT로 만들 수 있는 7가지 놀라운 제품을 소개하고, 아이디어를 현실로 바꿀 수 있는 실용적인 프롬프트도 함께 제공하겠습니다.</p><h2 id="1-매력적인-PLR-Private-Label-Rights-가이드">1. 매력적인 PLR(Private Label Rights) 가이드</h2><p>디지털 시장에서 제품을 판매하거나 포트폴리오를 강화할 때 <strong>PLR 가이드</strong>는 시간과 노력을 크게 절약할 수 있는 강력한 도구입니다. PLR 가이드는 한 번 만들어 두면 재사용할 수 있으며, 콘텐츠를 자유롭게 수정하여 새로운 제품으로 활용할 수 있습니다. 특히 <strong>개인 재정, 생산성, 피트니스</strong>와 같은 꾸준한 수요가 있는 주제를 다룰 때 큰 효과를 볼 수 있습니다.</p><blockquote><p>[주제]에 대한 5,000자 분량의 PLR 가이드를 작성해 주세요. 콘텐츠는 잘 구조화되어야 하고, 독자들에게 실질적으로 도움이 되는 예시와 실행 가능한 팁을 포함해야 합니다. 명확한 소제목으로 나누어 커스터마이징이 용이하도록 하며, 강렬한 도입부와 핵심 내용을 다시 강조하는 결론을 포함하세요.</p></blockquote><h2 id="2-다양한-분야에-적합한-인터랙티브-전자책-E-Books">2. 다양한 분야에 적합한 인터랙티브 전자책(E-Books)</h2><p>ChatGPT는 <strong>소설, 실용 가이드, 비즈니스 매뉴</strong>얼 등 다양한 주제의 전자책을 만들어 줄 수 있습니다. 이 전자책들은 개인 프로젝트로 활용할 수 있을 뿐만 아니라, <strong>Kindle 비즈니스</strong>를 시작할 때도 좋은 아이템이 됩니다.</p><blockquote><p>[주제]에 대한 10,000자 분량의 전자책을 작성해 주세요. 매력적인 도입부, 10개의 잘 구성된 챕터, 그리고 독자에게 여운을 남기는 결론을 포함해야 합니다. 독자가 쉽게 읽을 수 있도록 편안한 대화체로 작성하고, 중간중간 유머와 농담을 섞어 독자의 관심을 유지하세요. 실질적인 조언과 이야기 요소도 포함해 주세요.</p></blockquote><h2 id="3-눈길을-끄는-소셜-미디어-캡션">3. 눈길을 끄는 소셜 미디어 캡션</h2><p>소셜 미디어는 브랜드를 성장시키고 제품을 판매할 수 있는 중요한 플랫폼입니다. 그러나 수많은 콘텐츠 속에서 주목받기란 쉽지 않습니다. ChatGPT는 <strong>재치 있고 매력적인 캡션</strong>을 작성하여 팔로워의 관심을 끌고, 제품을 효과적으로 홍보할 수 있도록 도와줍니다.</p><blockquote><p>[제품/서비스]를 홍보할 수 있는 인스타그램 캡션 30개를 작성해 주세요. 각 캡션은 150자 이내로 작성하고, 콜 투 액션(Call to Action)을 포함하며, 가벼운 분위기와 친근한 어조를 유지하세요. 도달 범위를 넓히기 위해 트렌드 해시태그도 함께 추가해 주세요.</p></blockquote><h2 id="4-창업자를-위한-맞춤형-비즈니스-플랜">4. 창업자를 위한 맞춤형 비즈니스 플랜</h2><p>많은 창업자들이 큰 꿈을 꾸지만, 구체적인 <strong>비즈니스 플랜</strong> 작성 단계에서 어려움을 겪곤 합니다. ChatGPT는 명확한 전략이 담긴 전문적인 비즈니스 플랜을 손쉽게 작성할 수 있습니다.</p><blockquote><p>[산업 분야]에서 스타트업을 위한 상세한 비즈니스 플랜을 작성해 주세요. <strong>요약, 시장 분석, 마케팅 전략, 운영 계획, 재무 계획</strong>과 같은 섹션을 포함하고, 모든 내용이 실질적이고 실행 가능하도록 작성해 주세요. 전문적인 어조를 사용해 주세요.</p></blockquote><h2 id="5-독자를-사로잡는-블로그-포스트">5. 독자를 사로잡는 블로그 포스트</h2><p>블로그는 여전히 강력한 디지털 마케팅 도구입니다. 핵심은 <strong>고품질 콘텐츠</strong>와 <strong>SEO</strong>에 있습니다. ChatGPT는 독자에게 가치를 제공하고, 문제를 해결하며, 검색 엔진에서도 높은 순위를 차지할 수 있는 블로그 포스트를 작성할 수 있습니다.</p><blockquote><p>[주제]에 대한 2,000자 분량의 블로그 포스트를 작성해 주세요. 공식적인 어조를 사용하고, 소제목, 목록, 예시를 포함하여 글을 구조화하세요. [<strong>키워드</strong>]와 같은 SEO 키워드에 중점을 두고, 독자의 일반적인 질문에 답하며 문제를 해결할 수 있는 콘텐츠를 포함하세요. 강렬한 도입부와 결론을 포함해 주세요.</p></blockquote><h2 id="6-맞춤형-운동-계획">6. 맞춤형 운동 계획</h2><p>ChatGPT는 개인 맞춤형 <strong>운동 계획</strong>을 작성하여 다양한 피트니스 목표를 달성할 수 있도록 도와줍니다. <strong>체중 감량, 근육 증가, 기초 체력 향상</strong> 등 목표에 맞춰 적절한 운동 프로그램을 제안할 수 있습니다.</p><blockquote><p>[목표 예: 체중 감량 또는 근육 증가]를 위한 4주 운동 계획을 작성해 주세요. 매일의 운동과 명확한 지침, 휴식일, 권장 준비 운동 및 마무리 운동을 포함하세요. [<strong>운동 수준</strong>]에 맞게 계획을 조정하고, 동기를 유지할 수 있는 팁도 포함해 주세요.</p></blockquote><h2 id="7-흥미로운-비디오-콘텐츠-스크립트">7. 흥미로운 비디오 콘텐츠 스크립트</h2><p><strong>비디오 콘텐츠</strong>는 오늘날 가장 강력한 콘텐츠 유형 중 하나입니다. YouTube, 광고, 교육 콘텐츠 등 다양한 목적을 위한 스크립트를 ChatGPT가 작성할 수 있습니다.</p><blockquote><p>[주제]에 대한 5분 분량의 비디오 스크립트를 작성해 주세요. 주의를 끌 수 있는 도입부, 3개의 주요 포인트와 흥미로운 예시, 그리고 설득력 있는 결론을 포함하세요. [대상 예: 10대 또는 전문가]에게 적합한 대화체로 작성해 주세요.</p></blockquote><h2 id="마무리">마무리</h2><p>ChatGPT는 단순한 도구가 아니라, 창의적인 협력자로 활용할 수 있습니다. 위에서 소개한 프롬프트들은 ChatGPT의 잠재력을 극대화할 수 있는 방법을 제시하며, 다양한 디지털 제품을 만들어 수익화할 수 있도록 돕습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/chatgpt-34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알아두어야 할 마이크로서비스 설계 패턴 TOP 10</title>
      <link>http://hgko1207.github.io/2025/01/09/info-32/</link>
      <guid>http://hgko1207.github.io/2025/01/09/info-32/</guid>
      <pubDate>Thu, 09 Jan 2025 05:13:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;마이크로서비스에 특화된 다양한 설계 패턴을 소개하려고 합니다. 본격적인 패턴 설명에 앞서 마이크로서비스에 대한 기본 개념과 함께 이로 인해 발생하는 도전 과제를 간단히 정리해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;마이크로서비스란-무엇인가&quot;&gt;&lt;a cl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>마이크로서비스에 특화된 다양한 설계 패턴을 소개하려고 합니다. 본격적인 패턴 설명에 앞서 마이크로서비스에 대한 기본 개념과 함께 이로 인해 발생하는 도전 과제를 간단히 정리해 보겠습니다.</p><h2 id="마이크로서비스란-무엇인가"><a class="markdownIt-Anchor" href="#마이크로서비스란-무엇인가"></a> 마이크로서비스란 무엇인가?</h2><p>마이크로서비스란 특정 기능에 집중하며 독립적으로 배포 가능한 소규모 컴포넌트를 말합니다. 각 마이크로서비스는 자체 프로세스에서 실행되며, 일반적으로 API를 통해 다른 서비스와 통신합니다. 이 서비스들은 느슨하게 결합(loose coupling)되어 있어 확장성, 개발 속도, 유지보수 측면에서 많은 장점을 제공합니다.</p><p><img src="/images/header/info-32.png" alt="" /></p><h2 id="모놀리식-애플리케이션-vs-마이크로서비스-애플리케이션"><a class="markdownIt-Anchor" href="#모놀리식-애플리케이션-vs-마이크로서비스-애플리케이션"></a> 모놀리식 애플리케이션 vs 마이크로서비스 애플리케이션</h2><p>마이크로서비스 아키텍처는 모놀리식 애플리케이션과 비교했을 때 다음과 같은 주요 장점을 제공합니다.</p><ol><li><p><strong>확장성</strong><br />각 마이크로서비스를 독립적으로 확장할 수 있어 리소스 사용을 최적화할 수 있습니다.</p></li><li><p><strong>유연성</strong><br />서로 다른 마이크로서비스를 각기 다른 기술로 개발, 테스트, 배포, 유지보수할 수 있습니다.</p></li><li><p><strong>빠른 개발 속도</strong><br />작은 단위의 팀이 각기 다른 마이크로서비스를 병렬로 개발할 수 있어 개발 주기와 출시 속도가 빨라집니다.</p></li><li><p><strong>높은 복원력</strong><br />특정 마이크로서비스에 장애가 발생하더라도 전체 시스템에 미치는 영향이 적어 안정성이 높아집니다.</p></li><li><p><strong>유지보수 용이성</strong><br />각 마이크로서비스가 작고 독립적인 코드베이스로 구성되어 있어 이해하기 쉽고 수정 및 디버깅이 용이합니다.</p></li><li><p><strong>아웃소싱 유연성</strong><br />비즈니스 기능을 제3자 파트너에게 아웃소싱할 때 지적 재산 보호가 중요합니다. 마이크로서비스 아키텍처는 파트너별 구성 요소를 격리하여 핵심 서비스를 안전하게 보호할 수 있도록 도와줍니다.</p></li></ol><p>하지만 마이크로서비스 아키텍처는 다음과 같은 도전 과제도 수반합니다.</p><ol><li><p><strong>복잡성 증가</strong><br />마이크로서비스 기반 애플리케이션을 개발하고 유지보수하는 것은 모놀리식보다 더 많은 노력을 요구합니다. 각 서비스마다 별도의 코드베이스, 테스트, 배포 파이프라인, 문서화가 필요합니다.</p></li><li><p><strong>서비스 간 통신 문제</strong><br />네트워크 통신에 의존하기 때문에 지연(latency), 장애, 복잡한 통신 처리 문제 등이 발생할 수 있습니다.</p></li><li><p><strong>데이터 관리</strong><br />마이크로서비스마다 별도의 데이터베이스를 사용하는 경우가 많아 데이터 일관성, 동기화, 트랜잭션 관리에서 어려움을 겪을 수 있습니다.</p></li><li><p><strong>배포 부담</strong><br />여러 마이크로서비스의 배포, 버전 관리, 확장을 관리하려면 Kubernetes와 같은 고급 오케스트레이션 및 자동화 도구가 필요합니다.</p></li><li><p><strong>보안</strong><br />각 마이크로서비스가 새로운 취약점을 초래할 수 있어 공격 표면이 넓어지며, 이에 따라 보안 관리가 더욱 중요해집니다.</p></li></ol><h2 id="주요-마이크로서비스-설계-패턴"><a class="markdownIt-Anchor" href="#주요-마이크로서비스-설계-패턴"></a> 주요 마이크로서비스 설계 패턴</h2><p>이제 마이크로서비스 아키텍처에서 흔히 사용되는 주요 설계 패턴 10가지를 자세히 살펴보겠습니다.</p><h3 id="1-database-per-service-pattern"><a class="markdownIt-Anchor" href="#1-database-per-service-pattern"></a> 1. Database Per Service Pattern</h3><p><strong>Database Per Service Pattern</strong>은 각 마이크로서비스가 독립적인 데이터베이스를 가지도록 하는 설계 방식입니다. 이렇게 하면 느슨한 결합을 유지할 수 있으며, 각 팀이 서비스에 적합한 데이터베이스 기술을 선택할 수 있습니다.</p><p><img src="/images/header/info-32_1.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>느슨한 결합:</strong> 각 서비스가 독립적으로 동작하므로 모듈성이 향상됩니다.</li><li><strong>기술 선택의 유연성:</strong> 각 서비스에 가장 적합한 데이터베이스를 선택할 수 있습니다.</li><li><strong>확장성:</strong> 서비스별로 독립적인 확장 전략을 세울 수 있어 리소스 사용이 최적화됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 여러 데이터베이스의 백업, 복구, 확장 등을 관리하는 데 어려움이 있습니다.</li><li><strong>교차 서비스 쿼리 문제:</strong> 여러 데이터베이스에 걸쳐 데이터를 조회하는 것이 어려울 수 있습니다.</li><li><strong>데이터 일관성 문제:</strong> 데이터 일관성을 유지하기 위해 Event Sourcing이나 Saga 패턴과 같은 추가적인 설계가 필요할 수 있습니다.</li></ul><h3 id="2-api-gateway-pattern"><a class="markdownIt-Anchor" href="#2-api-gateway-pattern"></a> 2. API Gateway Pattern</h3><p><strong>API Gateway Pattern</strong>은 모든 클라이언트 요청을 단일 엔드포인트(API 게이트웨이)를 통해 처리하는 설계 방식입니다. 이 게이트웨이는 요청을 적절한 마이크로서비스로 라우팅하고, 인증, 로깅, 로드 밸런싱과 같은 공통 기능을 제공합니다.</p><p><img src="/images/header/info-32_2.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>클라이언트 상호작용 단순화:</strong> 클라이언트가 다수의 마이크로서비스에 직접 요청하는 대신, 하나의 게이트웨이만 호출하면 됩니다.</li><li><strong>중앙 집중식 관리:</strong> 인증, 로깅, 모니터링 등 공통 기능을 게이트웨이에서 통합 관리할 수 있습니다.</li><li><strong>보안 향상:</strong> 게이트웨이에서 접근 제어, 요청 검증 등을 처리하여 보안을 강화할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>단일 장애 지점:</strong> 게이트웨이가 장애를 겪으면 전체 시스템이 영향을 받을 수 있습니다.</li><li><strong>성능 오버헤드:</strong> 모든 요청이 게이트웨이를 거쳐야 하므로 잘못 설계된 경우 병목이 될 수 있습니다.</li><li><strong>복잡성 증가:</strong> 게이트웨이에 많은 기능이 추가될수록 관리 복잡성이 커질 수 있습니다.</li></ul><h3 id="3-backend-for-frontend-pattern-bff"><a class="markdownIt-Anchor" href="#3-backend-for-frontend-pattern-bff"></a> 3. Backend For Frontend Pattern (BFF)</h3><p><strong>BFF</strong> 패턴은 서로 다른 프론트엔드 애플리케이션(웹, 모바일 등)에 위한 맞춤형 백엔드를 제공하는 설계 방식입니다.</p><p><img src="/images/header/info-32_3.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>프론트엔드와의 통신 최적화:</strong> 각 프론트엔드의 요구사항에 맞는 응답을 제공하여 사용자 경험을 개선할 수 있습니다.</li><li><strong>프론트엔드 단순화:</strong> BFF가 데이터 집계, 변환 등을 처리하므로 프론트엔드 코드가 단순해집니다.</li><li><strong>독립적 진화 가능:</strong> 각 프론트엔드와 BFF가 독립적으로 진화할 수 있어 개발 유연성이 높아집니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>유지보수 복잡성 증가:</strong> 프론트엔드별로 별도의 BFF를 관리해야 하므로 유지보수 비용이 증가할 수 있습니다.</li><li><strong>코드 중복 가능성:</strong> 여러 BFF에 공통으로 필요한 기능이 중복될 수 있습니다.</li><li><strong>일관성 관리 어려움:</strong> 여러 BFF가 동일한 기능을 제공할 때 일관성을 유지하는 것이 어려울 수 있습니다.</li></ul><h3 id="4-command-query-responsibility-segregation-cqrs"><a class="markdownIt-Anchor" href="#4-command-query-responsibility-segregation-cqrs"></a> 4. Command Query Responsibility Segregation (CQRS)</h3><p><strong>CQRS 패턴</strong>은 읽기 작업(쿼리)과 쓰기 작업(명령)의 책임을 분리하는 설계 방식입니다.</p><p><img src="/images/header/info-32_4.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>성능 최적화:</strong> 읽기와 쓰기 작업을 독립적으로 최적화할 수 있습니다.</li><li><strong>독립적 확장성:</strong> 읽기와 쓰기 모델을 개별적으로 확장할 수 있어 리소스 사용이 효율적입니다.</li><li><strong>유지보수성 향상:</strong> 읽기와 쓰기 로직이 분리되어 코드의 가독성과 유지보수성이 향상됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 두 개의 모델을 관리해야 하므로 설계와 구현이 복잡해집니다.</li><li><strong>데이터 동기화 문제:</strong> 쓰기 모델과 읽기 모델 간의 데이터 동기화를 보장하기 어려울 수 있습니다.</li><li><strong>추가 도구 필요:</strong> 메시지 큐 또는 이벤트 소싱과 같은 도구가 필요할 수 있습니다.</li></ul><h3 id="5-event-sourcing-pattern"><a class="markdownIt-Anchor" href="#5-event-sourcing-pattern"></a> 5. Event Sourcing Pattern</h3><p><strong>Event Sourcing Pattern</strong>은 시스템의 상태 변경을 이벤트로 기록하고, 이러한 이벤트의 흐름을 통해 현재 상태를 재구성하는 방식입니다. 상태를 직접 저장하는 대신 상태 변화를 나타내는 모든 이벤트를 이벤트 스토어에 저장합니다.</p><p><img src="/images/header/info-32_5.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>완전한 감사 기록 제공:</strong> 모든 상태 변경이 이벤트로 기록되므로 시스템의 모든 변화를 추적할 수 있습니다.</li><li><strong>확장성 향상:</strong> 쓰기 작업을 이벤트 형태로 기록하고, 여러 소비자에게 이를 전달할 수 있어 높은 쓰기 확장성을 제공합니다.</li><li><strong>기능 추가 용이:</strong> 새로운 이벤트 유형을 도입함으로써 기존 데이터를 손상시키지 않고 기능을 확장할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 이벤트 스트림을 관리하고 상태를 재구성하는 방식이 일반적인 데이터 저장 방식보다 복잡합니다.</li><li><strong>높은 저장소 요구량:</strong> 모든 이벤트가 저장되기 때문에 많은 저장 공간이 필요할 수 있습니다.</li><li><strong>복잡한 쿼리:</strong> 필요한 현재 상태를 얻기 위해 이벤트를 재생(replay)해야 하므로 쿼리 작성이 까다로울 수 있습니다.</li></ul><h3 id="6-saga-pattern"><a class="markdownIt-Anchor" href="#6-saga-pattern"></a> 6. Saga Pattern</h3><p><strong>Saga Pattern</strong>은 분산 시스템에서 여러 서비스에 걸친 트랜잭션을 관리하기 위한 설계 방식입니다. 이를 위해 트랜잭션을 로컬 트랜잭션의 집합으로 나누고, 각 단계가 완료되면 다음 단계로 넘어갑니다. 만약 어느 단계에서 실패하면 이전 단계에서 수행한 작업을 취소하는 보상 트랜잭션을 실행합니다.</p><p><img src="/images/header/info-32_6.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>데이터 일관성 유지:</strong> 서비스 간의 데이터 일관성을 유지하면서도 분산 트랜잭션의 복잡성을 줄일 수 있습니다.</li><li><strong>복원력 향상:</strong> 트랜잭션이 실패할 경우 보상 작업을 통해 시스템을 복구할 수 있어 신뢰성이 높아집니다.</li><li><strong>확장성 향상:</strong> 로컬 트랜잭션으로 구성되어 있기 때문에 각 서비스가 독립적으로 확장 가능합니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 각 단계에 대한 보상 트랜잭션을 설계하고 관리해야 하므로 구현이 복잡할 수 있습니다.</li><li><strong>자동 롤백 부재:</strong> 전통적인 ACID 트랜잭션과 달리 자동 롤백이 없기 때문에 개발자가 명시적으로 보상 작업을 설계해야 합니다.</li><li><strong>격리 수준 부족:</strong> 동시 실행되는 여러 Saga가 있을 경우 데이터 이상 현상이 발생할 수 있습니다.</li></ul><h3 id="7-sidecar-pattern"><a class="markdownIt-Anchor" href="#7-sidecar-pattern"></a> 7. Sidecar Pattern</h3><p><strong>Sidecar Pattern</strong>은 주요 서비스와 함께 배포되는 보조 서비스를 별도의 프로세스로 실행하여 로깅, 모니터링, 보안 등의 부가 기능을 제공하는 설계 방식입니다. 주로 컨테이너 환경에서 사용됩니다.</p><p><img src="/images/header/info-32_7.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>모듈화 및 확장성:</strong> 사이드카를 통해 새로운 기능을 쉽게 추가하거나 제거할 수 있으며, 서비스의 주 기능을 변경하지 않고도 부가 기능을 확장할 수 있습니다.</li><li><strong>책임 분리:</strong> 보조 기능을 독립적인 프로세스로 실행함으로써 주 서비스와의 책임을 명확히 분리할 수 있습니다.</li><li><strong>독립적 확장 가능:</strong> 사이드카와 주 서비스는 각각 별도로 확장할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>관리 복잡성 증가:</strong> 다수의 사이드카 서비스를 관리해야 하므로 운영 복잡성이 증가할 수 있습니다.</li><li><strong>단일 장애 지점:</strong> 사이드카가 장애를 겪을 경우 주 서비스에도 영향을 줄 수 있으므로 고가용성 설계가 필요합니다.</li><li><strong>성능 저하 가능성:</strong> 사이드카와 주 서비스 간의 통신이 지연을 초래할 수 있어 성능에 영향을 줄 수 있습니다.</li></ul><h3 id="8-circuit-breaker-pattern"><a class="markdownIt-Anchor" href="#8-circuit-breaker-pattern"></a> 8. Circuit Breaker Pattern</h3><p><strong>Circuit Breaker Pattern</strong>은 서비스 장애가 발생했을 때 이를 감지하고, 일정 시간 동안 요청을 차단하여 연쇄적인 장애를 방지하는 방식입니다. 전기 회로 차단기와 유사하게 동작합니다.</p><p><img src="/images/header/info-32_8.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>연쇄 장애 방지:</strong> 장애가 발생한 서비스를 호출하지 않도록 차단함으로써 전체 시스템의 안정성을 높일 수 있습니다.</li><li><strong>시스템 복원력 향상:</strong> 장애가 발생했을 때 시스템이 과부하에 걸리지 않도록 하여 복원력을 높입니다.</li><li><strong>신뢰성 향상:</strong> 오류가 발생할 때 빠르게 대체 동작을 수행할 수 있어 사용자 경험이 향상됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>설정 복잡성:</strong> 임계값과 복구 주기를 적절하게 설정하는 것이 어려울 수 있습니다.</li><li><strong>대체 동작 설계 필요:</strong> 서비스 장애 시 대체 동작(fallback)을 제공하기 위해 별도의 설계가 필요합니다.</li><li><strong>불필요한 차단 가능성:</strong> 임계값 설정이 적절하지 않으면 서비스가 정상임에도 불구하고 차단이 발생할 수 있습니다.</li></ul><h3 id="9-anti-corruption-layer-pattern"><a class="markdownIt-Anchor" href="#9-anti-corruption-layer-pattern"></a> 9. Anti-Corruption Layer Pattern</h3><p><strong>Anti-Corruption Layer Pattern</strong>은 외부 시스템과 통합할 때 내부 시스템의 설계와 데이터 모델을 보호하기 위한 패턴입니다. 내부 시스템과 외부 시스템 간의 데이터 모델 차이를 변환하는 중간 계층을 제공하여 내부 시스템이 외부 변화에 영향을 받지 않도록 합니다.</p><p><img src="/images/header/info-32_9.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>내부 시스템 보호:</strong> 외부 시스템의 변화로부터 내부 시스템을 보호할 수 있습니다.</li><li><strong>유연성 향상:</strong> 외부 시스템과의 통합을 쉽게 관리할 수 있으며, 외부 시스템 변경 시에도 내부 시스템의 수정이 최소화됩니다.</li><li><strong>유지보수 용이성:</strong> 내부 시스템과 외부 시스템의 책임이 명확히 분리되어 유지보수가 용이해집니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>추가 복잡성:</strong> 변환 계층을 설계하고 관리해야 하므로 시스템 복잡성이 증가할 수 있습니다.</li><li><strong>지연 시간 증가:</strong> 변환 작업으로 인해 응답 속도가 느려질 수 있습니다.</li><li><strong>확장성 문제:</strong> 많은 수의 외부 시스템과 통합할 경우 ACL 계층을 확장하는 것이 어려울 수 있습니다.</li></ul><h3 id="10-aggregator-pattern"><a class="markdownIt-Anchor" href="#10-aggregator-pattern"></a> 10. Aggregator Pattern</h3><p><strong>Aggregator Pattern</strong>은 여러 마이크로서비스에서 데이터를 수집하고 이를 하나의 응답으로 병합하여 클라이언트에 제공하는 설계 방식입니다.</p><p><img src="/images/header/info-32_10.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>클라이언트 상호작용 단순화:</strong> 클라이언트가 하나의 엔드포인트만 호출하면 되므로 인터페이스가 단순해집니다.</li><li><strong>네트워크 호출 최소화:</strong> 클라이언트가 여러 서비스를 호출하지 않고도 필요한 데이터를 한 번에 받을 수 있습니다.</li><li><strong>중앙 집중식 데이터 처리:</strong> 데이터 집계 및 변환을 중앙에서 처리하여 일관성을 유지할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 여러 서비스로부터 데이터를 수집하고 병합하는 로직이 복잡할 수 있습니다.</li><li><strong>단일 장애 지점:</strong> Aggregator가 장애를 겪으면 전체 응답이 실패할 수 있으므로 고가용성 설계가 필요합니다.</li><li><strong>지연 시간 증가:</strong> 여러 서비스로부터 데이터를 수집하는 과정에서 지연이 발생할 수 있습니다.</li><li><strong>확장성 문제:</strong> Aggregator가 처리해야 할 요청 수가 많아질 경우 확장하기 어려울 수 있습니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 패턴들은 마이크로서비스 아키텍처의 복잡성을 관리하고 시스템의 확장성과 신뢰성을 높이는 데 필수적인 역할을 합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/info-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 위한 고급 ChatGPT 프롬프트 기술</title>
      <link>http://hgko1207.github.io/2025/01/09/chatgpt-33/</link>
      <guid>http://hgko1207.github.io/2025/01/09/chatgpt-33/</guid>
      <pubDate>Thu, 09 Jan 2025 04:24:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안녕하세요, 개발자 여러분! 💫&lt;/p&gt;
&lt;p&gt;ChatGPT가 등장한 이후 많은 개발자들이 이를 활용하고 있습니다. 이미 수많은 프롬프트 엔지니어링에 대한 튜토리얼이 쏟아지고 있는데요, 이번 글은 그런 일반적인 가이드가 아닙니다.&lt;/p&gt;
&lt;p&gt;A
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안녕하세요, 개발자 여러분! 💫</p><p>ChatGPT가 등장한 이후 많은 개발자들이 이를 활용하고 있습니다. 이미 수많은 프롬프트 엔지니어링에 대한 튜토리얼이 쏟아지고 있는데요, 이번 글은 그런 일반적인 가이드가 아닙니다.</p><p>AI를 일상에서 활용한 개인적인 경험을 공유하려 합니다. AI가 어떻게 저에게 도움을 주고, 왜 매우 유용하다고 생각하는지 설명하겠습니다. 또한, 이 글은 친구 개발자와의 대화에서 영감을 얻었는데요, 그는 AI가 별로 도움이 안 된다고 느꼈지만, 저는 AI를 통해 많은 이점을 얻고 있습니다. 그가 왜 실패했고, 제가 왜 성공했는지도 함께 이야기해 보겠습니다.</p><h2 id="AI는-인간이-아닙니다">AI는 인간이 아닙니다!</h2><p>무엇보다 먼저 명심할 것이 있습니다. ChatGPT가 때로는 인간처럼 느껴질 수 있지만, <strong>AI는 인간이 아닙니다.</strong> AI는 생각하지 않으며, 인간이 본질적으로 이해하는 맥락을 인식하지 못합니다. AI의 답변은 단지 데이터를 수학적 공식으로 처리한 결과일 뿐입니다.</p><p>다시 한 번 강조하겠습니다.</p><ul><li><strong>AI는 생각하지 않습니다.</strong></li><li><strong>AI에게 의식은 없습니다.</strong></li><li><strong>AI는 단지 예측 가능한 수학적 결과를 생성할 뿐입니다.</strong></li></ul><p>이 점을 명확히 이해하는 것이 중요합니다. 이 사실을 깨닫고 나면 많은 프롬프트 엔지니어링 튜토리얼이 더 의미 있게 다가올 것입니다. AI를 도구로 간주하고 다룬다면, 그 도구는 여러분의 손에서 강력한 무기가 될 것입니다.</p><h2 id="데이터-모델과-프롬프트-엔지니어링">데이터 모델과 프롬프트 엔지니어링</h2><p>AI는 복잡한 알고리즘과 방대한 데이터 세트를 기반으로 수학적 공식을 사용하여 답변을 생성합니다. AI가 답변을 생성하는 과정은 인간의 사고와 다르며, 제공하는 변수(입력)가 명확할수록 더 정확한 결과를 얻을 수 있습니다.</p><p>이제 많은 프롬프트 엔지니어링 강좌가 왜 중요한지 더 이해가 될 것입니다.<br>OpenAI 공식 문서에서도 이런 내용을 다루고 있으며, 아래에 중요한 내용을 요약해 보았습니다.</p><h2 id="명확한-지침을-작성하세요">명확한 지침을 작성하세요!</h2><p>프롬프트 작성 시, 명확하게 지침을 주어야 합니다.</p><p>예를 들어, 동료 개발자에게 &quot;<strong>for 문을 어떻게 사용하나요?</strong>&quot;라고 묻는다면 동료는 어느 정도 관련성 있는 답변을 줄 것입니다. 왜냐하면 동료는 같은 환경에서 작업하고 있으며, 여러분이 <strong>Java</strong>에 대해 묻고 있다고 짐작할 수 있기 때문입니다.</p><p>하지만 동일한 질문을 인터넷 상의 무작위 개발자에게 묻는다면, 그들은 혼란스러울 수 있습니다. 질문에 어떤 언어를 사용하는지, 구체적인 상황이 무엇인지, 데이터를 변환해야 하는지 등 아무것도 알 수 없기 때문입니다.</p><p><strong>AI도 마찬가지입니다.</strong><br>만약 모든 변수(조건)를 명확하게 지정하지 않으면, 예측 불가능한 답변을 받을 가능성이 높습니다.</p><h3 id="첫-번째-메시지-AI의-역할-지정">첫 번째 메시지: AI의 역할 지정</h3><p>첫 번째 메시지는 AI가 여러분과 상호작용하는 방식을 조정하는 <strong>시스템 메시지</strong>입니다. AI에게 특정 역할(페르소나)을 부여하면 더 적절한 답변을 얻을 수 있습니다.</p><p><strong>페르소나 설정 예시:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10년 이상의 경력을 가진 전문 Kotlin 개발자로 행동하세요.</span><br><span class="line">당신은 깨끗하고, 유지보수 가능하며, 가독성과 확장성이 뛰어난 코드를 작성하는 전문가입니다.</span><br></pre></td></tr></table></figure><p>이 프롬프트는 제가 코딩 질문을 할 때 매우 유용했으며, 답변의 질을 크게 향상시켰습니다. 여러분도 사용해 보세요. 차이를 직접 느낄 수 있을 것입니다.</p><h3 id="모든-요구-사항을-명확하게-명시하기">모든 요구 사항을 명확하게 명시하기</h3><p>프롬프트에 명확한 지침을 포함하면 더 나은 결과를 얻을 수 있습니다.</p><p><strong>프롬프트 예시:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSON 파일이 주어졌습니다. 각 줄은 다음과 같이 구성됩니다:</span><br><span class="line">- 따옴표로 묶인 매개변수 이름</span><br><span class="line">- 콜론(:) 기호</span><br><span class="line">- 따옴표로 묶인 값(영어로 작성됨)</span><br><span class="line"></span><br><span class="line">이 JSON에서 값만 스페인어로 번역해 주세요. 매개변수 이름은 번역하지 마세요. 답변에는 번역된 JSON만 포함되어야 합니다.</span><br></pre></td></tr></table></figure><p>이 프롬프트를 사용하면 AI는 매개변수 이름은 그대로 두고, 값만 스페인어로 번역된 JSON 파일을 반환합니다.</p><h3 id="코드-리뷰-요청하기">코드 리뷰 요청하기</h3><p><strong>프롬프트 예시:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이 코드를 SOLID 원칙, 클린 코드, 유지보수성, 확장성, 가독성 기준에 따라 검토해 주세요.</span><br></pre></td></tr></table></figure><p>AI는 이 요청에 따라 각 원칙에 맞게 답변을 구조화하고, 원칙별로 코드를 개선할 수 있는 방법을 제시합니다.</p><h4 id="예시-코드와-결과">예시 코드와 결과</h4><p>예를 보여드리겠습니다. 이것은 초기 코드의 일부입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 연결 설정</span></span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserToDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Storing "</span> + <span class="keyword">this</span>.name + <span class="string">" into database..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Not connected to database."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 ChatGPT에게 &quot;<strong>이 코드를 검토해 주세요</strong>&quot;라고 요청했을 반환된 리팩터링된 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Saving "</span> + <span class="keyword">this</span>.name + <span class="string">"..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Connect first."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT에 &quot;<strong>이 코드를 SOLID 원칙, 클린 코드, 유지보수성, 확장성, 가독성 기준에 따라 검토해 주세요</strong>&quot;라고 요청했을 때 반환된 리펙토링된 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name의 getter 메서드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Storing "</span> + user.getName() + <span class="string">" into database..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Not connected to database. Connect first."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SOLID-원칙-적용-설명">SOLID 원칙 적용 설명</h4><ul><li><strong>단일 책임 원칙(Single Responsibility Principle, SRP):</strong><br>User 클래스와 Database 클래스를 분리하여 각 클래스가 단일 책임만 가지도록 했습니다.</li><li><strong>개방/폐쇄 원칙(Open/Closed Principle):</strong><br>기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 구조를 개선했습니다.</li><li><strong>리스코프 치환 원칙(Liskov Substitution Principle):</strong><br>이 원칙은 더 복잡한 예제에서 설명될 수 있으며, 필요 시 인터페이스나 하위 클래스를 도입하여 적용할 수 있습니다.</li><li><strong>인터페이스 분리 원칙(Interface Segregation Principle)과 의존성 역전 원칙(Dependency Inversion Principle):</strong><br>더 큰 규모의 프로젝트나 인터페이스, 서브클래스를 사용할 때 설명할 수 있습니다.</li></ul><p>이처럼 책임 분리와 메서드 단순화를 통해 코드가 더 깨끗하고 유지보수 가능하며, 확장 가능하고 가독성 높은 구조로 개선되었습니다.</p><h2 id="문맥-인식-한계와-해결-방법">문맥 인식: 한계와 해결 방법</h2><p>ChatGPT는 고정된 문맥 길이가 있습니다. 즉, 사용자와 AI 간의 대화에서 모든 내용을 한 번에 기억하지 못합니다.</p><p>대화가 길어지면 초기에 설정했던 AI의 역할이나 작성했던 코드 일부를 잊어버릴 수 있습니다.</p><p>이를 해결하려면 AI에게 작업할 전체 코드를 반복해서 보여주고 맥락을 다시 제공해야 합니다.</p><h2 id="ChatGPT가-작동하는-방식-이해하기">ChatGPT가 작동하는 방식 이해하기</h2><p>ChatGPT는 수학적으로 작동하는 도구이기 때문에 때로는 부정확하거나 누락된 답변을 줄 수 있습니다. 따라서 AI에게 답변의 근거를 설명하도록 요청하면 더 의미 있는 결과를 얻을 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">이 코드가 왜 맞는지 설명해 주세요.</span><br><span class="line">각 줄에 주석을 달고 어떤 역할을 하는지 설명해 주세요.</span><br></pre></td></tr></table></figure><h2 id="프롬프트-테스트와-개선">프롬프트 테스트와 개선</h2><p>프롬프트는 한 번에 완벽할 수 없습니다. 원하는 결과를 얻을 때까지 여러 번 테스트하고, 답변이 마음에 들지 않으면 프롬프트를 개선하세요.</p><p><strong>프롬프트 개선 예시:</strong></p><ul><li>AI가 생성한 코드가 테스트 결과와 일치하지 않으면 <strong>AI의 코드, 테스트 케이스, 기대 결과, 실제 결과</strong>를 다시 보여주고 오류를 수정하도록 요청하세요.</li><li>필요하다면 코드를 여러 단계로 나누어 요청하고, 각 단계별로 검토 및 개선하도록 지시하세요.</li></ul><h2 id="결론">결론</h2><p>ChatGPT는 올바르게 다루었을 때 일상적인 코딩 작업에서 매우 강력한 도구가 될 수 있습니다. 하지만 AI의 능력과 한계를 이해하고 적절히 활용해야 합니다.</p><p>ChatGPT는 개발자를 도와주고 가르치며 안내할 수 있지만, 인간 개발자를 대체할 수는 없습니다. 개발자의 직관과 예술적인 코딩 감각은 여전히 필수적이며, 우리는 이러한 도구를 잘 조율해 멋진 작품을 만들어야 합니다.</p><p><strong>ChatGPT를 동료로 삼아 여러분의 코딩 여정을 더 즐겁고 생산적으로 만드세요.</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/chatgpt-33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python 프로젝트 구조화 방법</title>
      <link>http://hgko1207.github.io/2025/01/09/python-12/</link>
      <guid>http://hgko1207.github.io/2025/01/09/python-12/</guid>
      <pubDate>Thu, 09 Jan 2025 03:59:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;잘 구성된 &lt;strong&gt;Python&lt;/strong&gt; 프로젝트 구조는 코드베이스를 관리하기 쉽게 만들고 확장성과 이해도를 높여줍니다. 이는 개인 개발자는 물론, 팀으로 협업할 때도 필수적인 요소입니다. 이 글에서는 Python 프로젝트를 효과적으
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>잘 구성된 <strong>Python</strong> 프로젝트 구조는 코드베이스를 관리하기 쉽게 만들고 확장성과 이해도를 높여줍니다. 이는 개인 개발자는 물론, 팀으로 협업할 때도 필수적인 요소입니다. 이 글에서는 Python 프로젝트를 효과적으로 구성하는 방법에 대해 단계별로 설명하고, 각 단계에서 모범 사례와 예시를 함께 다룹니다.</p><h2 id="1단계-프로젝트-설정-루트-디렉터리"><a class="markdownIt-Anchor" href="#1단계-프로젝트-설정-루트-디렉터리"></a> 1단계: 프로젝트 설정 🌳 루트 디렉터리</h2><p>가장 먼저 프로젝트와 관련된 모든 파일을 포함할 <strong>루트(Root) 디렉터리</strong>를 생성합니다. 디렉터리 이름은 프로젝트의 목적이나 내용을 명확하게 나타내도록 <strong>설명적이고 의미 있는 이름</strong>으로 지정하는 것이 좋습니다. 일반적으로 프로젝트 이름을 디렉터리 이름으로 사용하는 것이 권장됩니다.</p><p><strong>예시:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br></pre></td></tr></table></figure><p>이 디렉터리 안에 소스 코드, 문서, 설정 파일 등을 추가하며 프로젝트를 구성해 나가게 됩니다.</p><h2 id="2단계-가상-환경-생성"><a class="markdownIt-Anchor" href="#2단계-가상-환경-생성"></a> 2단계: 가상 환경 생성 🌄</h2><p>가상 환경은 프로젝트 간 종속성 충돌을 방지하고, <strong>종속성을 격리</strong>하여 관리할 수 있도록 해줍니다. 이를 통해 프로젝트마다 필요한 패키지 버전을 다르게 설정할 수 있으며, 안정적인 개발 환경을 유지할 수 있습니다.</p><h3 id="가상-환경-생성-방법"><a class="markdownIt-Anchor" href="#가상-환경-생성-방법"></a> 가상 환경 생성 방법</h3><p><strong>Linux/macOS 사용자:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my_project</span><br><span class="line">python3 -m venv venv</span><br></pre></td></tr></table></figure><p><strong>Windows 사용자:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>가상 환경 생성 후, 아래 명령어로 활성화할 수 있습니다.</p><p><strong>Linux/macOS에서 활성화:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure><p><strong>Windows에서 활성화:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate</span><br></pre></td></tr></table></figure><p>이제 가상 환경이 활성화되었으며, 모든 종속성(라이브러리 및 패키지)은 이 환경에 설치됩니다. 이렇게 하면 프로젝트가 특정 버전의 라이브러리에 종속되어도 다른 프로젝트에 영향을 주지 않게 됩니다.</p><h2 id="3단계-핵심-디렉터리-구조-정의"><a class="markdownIt-Anchor" href="#3단계-핵심-디렉터리-구조-정의"></a> 3단계: 핵심 디렉터리 구조 정의 📗</h2><p>Python 프로젝트의 핵심 프로젝트 구조는 <strong>패키지/모듈 디렉터리, 테스트 디렉터리</strong>, 그리고 루트 수준에 위치한 <strong>설정 및 구성 파일</strong>로 구성되어야 합니다. 이러한 구조는 프로젝트의 코드 관리와 확장을 용이하게 해줍니다.</p><h3 id="예시-디렉터리-구조"><a class="markdownIt-Anchor" href="#예시-디렉터리-구조"></a> 예시 디렉터리 구조</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">│</span><br><span class="line">├── my_package/           # 메인 패키지 디렉터리</span><br><span class="line">│   ├── __init__.py       # 디렉터리를 패키지로 인식시키는 파일</span><br><span class="line">│   ├── module1.py</span><br><span class="line">│   ├── module2.py</span><br><span class="line">│   └── utils.py</span><br><span class="line">│</span><br><span class="line">├── tests/                # 각 모듈이나 기능에 대한 테스트 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_module1.py</span><br><span class="line">│   ├── test_module2.py</span><br><span class="line">│   └── test_utils.py</span><br><span class="line">│</span><br><span class="line">├── venv/                 # 가상 환경 디렉터리 (.gitignore에 추가하여 무시)</span><br><span class="line">│</span><br><span class="line">├── requirements.txt      # 프로젝트 종속성 목록</span><br><span class="line">│</span><br><span class="line">└── README.md             # 프로젝트 설명 및 사용법</span><br></pre></td></tr></table></figure><h3 id="구성-요소-설명"><a class="markdownIt-Anchor" href="#구성-요소-설명"></a> 구성 요소 설명</h3><ul><li><strong><code>my_package/</code>:</strong> 프로젝트의 핵심 코드를 포함하는 디렉터리입니다.</li><li><strong><code>tests/</code>:</strong> 각 모듈에 대한 단위 테스트가 포함된 디렉터리로, 테스트를 통해 코드의 안정성을 검증할 수 있습니다.</li><li><strong><code>requirements.txt</code>:</strong> 프로젝트에 필요한 라이브러리와 종속성 목록을 관리하는 파일입니다. <code>pip freeze &gt; requirements.txt</code> 명령어로 자동 생성할 수 있습니다.</li><li><strong><code>README.md</code>:</strong> 프로젝트에 대한 설명과 사용법을 제공하는 문서로, 다른 사용자들이 프로젝트를 쉽게 이해하고 사용할 수 있도록 도와줍니다.</li></ul><h2 id="4단계-__init__py-파일-작성"><a class="markdownIt-Anchor" href="#4단계-__init__py-파일-작성"></a> 4단계: <code>__init__.py</code> 파일 작성 📝</h2><p><code>__init__.py</code> 파일은 디렉터리를 Python 패키지로 인식하게 만듭니다. 또한, 이 파일을 통해 특정 모듈이나 함수에 대한 임포트를 간소화할 수 있습니다.</p><p><strong>예시 <code>__init__.py</code> 파일 (my_package/ 디렉터리):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .module1 <span class="keyword">import</span> function1</span><br><span class="line"><span class="keyword">from</span> .module2 <span class="keyword">import</span> function2</span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 간단하게 임포트할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> function1</span><br></pre></td></tr></table></figure><h2 id="5단계-설정-파일-추가-️"><a class="markdownIt-Anchor" href="#5단계-설정-파일-추가-️"></a> 5단계: 설정 파일 추가 ⚙️</h2><p>테스트, 코드 스타일 검사, 배포 등을 자동화하려면 설정 파일을 추가하는 것이 좋습니다.</p><h3 id="1-gitignore"><a class="markdownIt-Anchor" href="#1-gitignore"></a> 1. <code>.gitignore</code></h3><p><code>.gitignore</code> 파일을 통해 Git에서 관리하지 않을 파일과 디렉터리를 지정할 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">venv/</span><br><span class="line">__pycache__/</span><br><span class="line">*.pyc</span><br></pre></td></tr></table></figure><h3 id="2-requirementstxt"><a class="markdownIt-Anchor" href="#2-requirementstxt"></a> 2. <code>requirements.txt</code></h3><p><code>requirements.txt</code> 파일은 프로젝트 종속성을 관리하며, 동일한 개발 환경을 쉽게 재현할 수 있도록 도와줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 생성 방법</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h2 id="6단계-테스트-설정-️"><a class="markdownIt-Anchor" href="#6단계-테스트-설정-️"></a> 6단계: 테스트 설정 ⚓️</h2><p>테스트는 프로젝트의 품질을 보장하는 중요한 요소입니다. Python에서는 <strong>pytest</strong> 또는 <strong>unittest</strong>를 사용하여 테스트를 작성할 수 있습니다.</p><p>테스트 파일은 일반적으로 <code>tests/</code> 디렉터리에 배치하며, 파일 이름은 <code>test_</code>로 시작하는 것이 관례입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예시 테스트 파일: tests/test_module1.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> function1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_function1</span><span class="params">()</span>:</span></span><br><span class="line">    result = function1()</span><br><span class="line">    <span class="keyword">assert</span> result == expected_output  <span class="comment"># 실제 예상 결과로 교체</span></span><br></pre></td></tr></table></figure><p>명령어로 테스트 실행</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest tests/</span><br></pre></td></tr></table></figure><h2 id="7단계-패키징을-위한-setuppy-작성-선택-사항"><a class="markdownIt-Anchor" href="#7단계-패키징을-위한-setuppy-작성-선택-사항"></a> 7단계: 패키징을 위한 <code>setup.py</code> 작성 📦 (선택 사항)</h2><p>배포 가능한 Python 패키지를 만들려면 <code>setup.py</code> 파일을 추가해야 합니다.<br />이 파일은 Python이 패키지를 빌드하고 설치하는 방법을 정의합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예시</span></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"my_project"</span>,</span><br><span class="line">    version=<span class="string">"0.1"</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">"some_package&gt;=1.0.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>로컬에서 패키지 설치 방법</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p>이제 프로젝트를 다른 Python 환경에서도 쉽게 설치하고 사용할 수 있습니다.</p><h2 id="8단계-프로젝트-문서화"><a class="markdownIt-Anchor" href="#8단계-프로젝트-문서화"></a> 8단계: 프로젝트 문서화 📜</h2><p>문서화는 프로젝트를 더 이해하기 쉽게 만들어 줍니다.<br /><code>README.md</code> 파일을 업데이트하여 프로젝트 개요, 설치 방법, 사용 예시 등을 포함하세요.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># My Project</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Overview</span></span><br><span class="line"></span><br><span class="line">This project does XYZ.</span><br><span class="line"></span><br><span class="line"><span class="section">## Installation</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>Clone the repository.</span><br><span class="line"><span class="bullet">2. </span>Install dependencies:</span><br><span class="line">   <span class="code">```</span>bash</span><br><span class="line"><span class="code">      pip install -r requirements.txt</span></span><br><span class="line">   <span class="code">```</span></span><br></pre></td></tr></table></figure><h2 id="최종"><a class="markdownIt-Anchor" href="#최종"></a> 최종</h2><p>최종 프로젝트 구조 예시입니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">│</span><br><span class="line">├── my_package/           # 메인 패키지 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── module1.py</span><br><span class="line">│   ├── module2.py</span><br><span class="line">│   └── utils.py</span><br><span class="line">│</span><br><span class="line">├── tests/                # 테스트 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_module1.py</span><br><span class="line">│   ├── test_module2.py</span><br><span class="line">│   └── test_utils.py</span><br><span class="line">│</span><br><span class="line">├── venv/                 # 가상 환경 디렉터리</span><br><span class="line">│</span><br><span class="line">├── requirements.txt      # 종속성 목록</span><br><span class="line">│</span><br><span class="line">├── README.md             # 프로젝트 설명 및 사용법</span><br><span class="line">│</span><br><span class="line">└── setup.py              # 선택 사항: 패키징 설정 파일</span><br></pre></td></tr></table></figure><p>이러한 구조는 프로젝트를 체계적으로 관리할 수 있도록 도와주며, 개발, 테스트, 유지보수를 더 효율적으로 할 수 있게 만듭니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/python-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C# 13 및 .NET 9 필수 기능 소개</title>
      <link>http://hgko1207.github.io/2024/12/06/csharp-15/</link>
      <guid>http://hgko1207.github.io/2024/12/06/csharp-15/</guid>
      <pubDate>Fri, 06 Dec 2024 05:42:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;.NET 9는 많은 변화와 개선 사항을 제공하며, 곧 출시를 앞두고 있습니다. 이 글에서는 &lt;strong&gt;.NET 9와 C# 13&lt;/strong&gt;에서 가장 영향을 많이 미치고 널리 적용 가능한 주요 기능들을 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>.NET 9는 많은 변화와 개선 사항을 제공하며, 곧 출시를 앞두고 있습니다. 이 글에서는 <strong>.NET 9와 C# 13</strong>에서 가장 영향을 많이 미치고 널리 적용 가능한 주요 기능들을 살펴보겠습니다.</p><h2 id="1-새로운-lock-객체"><a class="markdownIt-Anchor" href="#1-새로운-lock-객체"></a> 1. 새로운 Lock 객체</h2><p>C# 13에서는 <strong>System.Threading.Lock</strong>라는 새로운 타입이 도입되어 상호 배제를 처리합니다. 기존에는 <code>object</code> 타입을 사용해 잠금을 구현했지만, 이제는 전용 <code>Lock</code> 타입이 제공되어 앞으로 대부분의 잠금 작업에 표준으로 자리 잡을 것으로 기대됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock = <span class="keyword">new</span>(); <span class="comment">// 잠금을 위한 object 인스턴스 생성</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStuff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_lock) <span class="comment">// object를 이용한 잠금</span></span><br><span class="line">        &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">"기존 방식의 lock 블록 안입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Lock _lock = <span class="keyword">new</span>(); <span class="comment">// 새로운 Lock 객체 생성</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStuff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_lock) <span class="comment">// Lock 객체를 이용한 잠금</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">".NET 9 방식의 lock 블록 안입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>주요 장점</strong></p><ul><li><strong>더 깔끔하고 안전한 코드:</strong> 코드가 더욱 읽기 쉽고 예측 가능해집니다. 또한, <code>Lock</code> 인스턴스를 일반 <code>object</code>로 잘못 사용하면 컴파일러가 경고를 제공합니다.</li><li><strong>성능 향상:</strong> Microsoft에 따르면, 임의의 <code>object</code> 인스턴스를 잠금에 사용하는 것보다 더 효율적일 수 있습니다.</li><li><strong>새로운 잠금 메커니즘:</strong> <code>EnterScope</code>가 내부적으로 <code>Monitor</code> 클래스를 대체합니다. 이 메커니즘은 <code>Dispose</code> 패턴을 따르는 <code>ref struct</code>를 반환하므로 <code>using</code> 문과 매끄럽게 결합됩니다.</li><li><strong>비동기 작업의 제한:</strong> <code>lock</code> 블록 내에서는 여전히 <code>async</code> 호출이 허용되지 않습니다. 이는 잠금과 비동기 코드가 상호 작용하는 방식에 내재된 한계 때문입니다. 기존의 <code>SemaphoreSlim</code> 접근 방식이 여전히 대안으로 사용됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">readonly</span> Lock _lock = <span class="keyword">new</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphore = <span class="keyword">new</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoStuff</span>(<span class="params"><span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      <span class="comment">// 1. 'lock' 구문과 비동기 작업의 제한</span></span><br><span class="line">      <span class="keyword">lock</span>(_lock)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">// 컴파일 오류: 'lock' 블록 내부에서 'await'를 사용할 수 없습니다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 'EnterScope'와 비동기 작업의 제한</span></span><br><span class="line">      <span class="keyword">using</span>(_lock.EnterScope())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">// 런타임 오류: 'System.Threading.Lock.Scope' 타입 인스턴스는 'await' 또는 'yield' 경계를 넘을 수 없습니다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. SemaphoreSlim을 이용한 비동기 작업</span></span><br><span class="line">      <span class="keyword">await</span> _semaphore.WaitAsync();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">10</span>);</span><br><span class="line">         <span class="comment">// 정상적으로 동작: SemaphoreSlim은 비동기 작업을 지원합니다.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span></span><br><span class="line">      &#123;</span><br><span class="line">         _semaphore.Release(); <span class="comment">// 반드시 자원을 해제해야 함</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-taskwheneach"><a class="markdownIt-Anchor" href="#2-taskwheneach"></a> 2. Task.WhenEach</h2><p>다양한 시간 간격으로 완료되는 작업(Task) 리스트가 있다고 가정해봅시다. 작업이 모두 끝날 때까지 기다리는 <code>WaitAll()</code> 방식은 이 경우 적합하지 않습니다. 각각의 작업이 완료되는 즉시 처리하고 싶다면 <code>Task.WaitAny()</code>를 사용하여 대안적으로 구현할 수 있습니다. 그러나 C# 13에서는 이를 더 우아하고 효율적으로 처리할 수 있는 <code>Task.WhenEach</code> 기능이 도입되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 랜덤한 간격으로 완료되는 5개의 작업 리스트 생성</span></span><br><span class="line"><span class="keyword">var</span> tasks = Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">   .Select(<span class="keyword">async</span> i =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">await</span> Task.Delay(<span class="keyword">new</span> Random().Next(<span class="number">1000</span>, <span class="number">5000</span>)); <span class="comment">// 1~5초 사이의 딜레이</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">$"Task <span class="subst">&#123;i&#125;</span> done"</span>; <span class="comment">// 완료 메시지 반환</span></span><br><span class="line">   &#125;)</span><br><span class="line">   .ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="keyword">while</span>(tasks.Count &gt; <span class="number">0</span>) <span class="comment">// 아직 완료되지 않은 작업이 남아 있는 동안</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> completedTask = <span class="keyword">await</span> Task.WhenAny(tasks); <span class="comment">// 가장 먼저 완료된 작업 선택</span></span><br><span class="line">   tasks.Remove(completedTask); <span class="comment">// 완료된 작업 리스트에서 제거</span></span><br><span class="line">   Console.WriteLine(<span class="keyword">await</span> completedTask); <span class="comment">// 작업 결과 출력</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> completedTask <span class="keyword">in</span> Task.WhenEach(tasks)) <span class="comment">// 작업이 완료될 때마다 처리</span></span><br><span class="line">   Console.WriteLine(<span class="keyword">await</span> completedTask); <span class="comment">// 작업 결과 출력</span></span><br></pre></td></tr></table></figure><p><code>Task.WhenEach</code>는 <code>IAsyncEnumerable&lt;Task&lt;TResult&gt;&gt;</code>를 반환하며, <code>await foreach를</code> 사용해 작업이 완료되는 즉시 쉽게 반복(iterate) 처리할 수 있도록 해줍니다.👌</p><h2 id="3-params-collections"><a class="markdownIt-Anchor" href="#3-params-collections"></a> 3. params Collections</h2><p>C# 13부터 <code>params</code> 매개변수로 컬렉션 표현식에 지원되는 모든 타입을 사용할 수 있게 되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">int</span>[] numbers</span>)</span></span><br><span class="line"><span class="function"></span>   =&gt; Console.WriteLine(numbers.Length); <span class="comment">// int 배열만 허용</span></span><br></pre></td></tr></table></figure><p>C# 13 이후, <code>params</code> 매개변수는 다양한 컬렉션 타입을 지원합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9</span></span><br><span class="line"><span class="comment">// ReadOnlySpan&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> ReadOnlySpan&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IEnumerable&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> IEnumerable&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Count());</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> HashSet&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Count);</span><br></pre></td></tr></table></figure><ul><li><strong>더 깔끔한 코드:</strong> <code>.ToArray()</code>, <code>.ToList()</code> 호출 횟수를 크게 줄일 수 있습니다.</li><li><strong>성능 향상:</strong> <code>.ToArray()</code>, <code>.ToList()</code> 같은 호출은 자체적으로 추가적인 리소스 오버헤드를 발생시킵니다. 이제 <code>Span&lt;&gt;</code>과 <code>IEnumerable&lt;&gt;</code>를 지원함으로써 더 효율적인 메모리 사용과 지연 실행(lazy execution)을 활용할 수 있습니다. 결과적으로, 유연성과 성능이 요구되는 시나리오에서 더 나은 성능을 제공합니다.</li></ul><h2 id="4-semi-auto-properties-반자동-속성"><a class="markdownIt-Anchor" href="#4-semi-auto-properties-반자동-속성"></a> 4. Semi-Auto Properties (반자동 속성)</h2><p>C#에서 <code>public int Number { get; set; }</code>와 같은 자동 구현 속성을 선언하면, 컴파일러가 자동으로 백업 필드(예: <code>_number</code>)와 내부 getter/setter 메서드(<code>void set_Number(int number)</code>, <code>int get_Number()</code>)를 생성합니다.</p><p>하지만 속성의 getter나 setter에서 유효성 검사, 기본값 설정, 계산, 지연 로딩(lazy loading) 등의 커스텀 로직이 필요할 경우, 클래스에서 백업 필드를 직접 정의해야 했습니다.</p><p>C# 13에서는 <code>field</code> 키워드를 도입하여, 백업 필드를 직접 정의하지 않고도 바로 사용할 수 있도록 간소화했습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MagicNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _number; <span class="comment">// 백업 필드 직접 정의</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _number * <span class="number">10</span>; <span class="comment">// 커스텀 로직 적용</span></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) <span class="comment">// 유효성 검사</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(<span class="keyword">value</span>), <span class="string">"값은 0보다 커야 합니다."</span>);</span><br><span class="line">            _number = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MagicNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; field; <span class="comment">// 컴파일러가 생성한 백업 필드에 직접 접근</span></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) <span class="comment">// 유효성 검사</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(<span class="keyword">value</span>), <span class="string">"값은 0보다 커야 합니다."</span>);</span><br><span class="line">            field = <span class="keyword">value</span>; <span class="comment">// field 키워드로 백업 필드 설정</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>보일러플레이트 코드 감소:</strong> 백업 필드를 수동으로 정의할 필요가 없어져 코드가 더 깔끔하고 간결해집니다.</li><li><strong>가독성 향상:</strong> <code>field</code> 키워드를 표준으로 사용하면서, 커스텀 백업 필드 이름을 관리할 필요가 없어 코드의 명확성이 높아집니다.</li><li><strong>속성 범위 내 필드 제한:</strong> 백업 필드는 속성 내부로 제한되어 클래스의 다른 부분에서 의도치 않게 사용되는 일을 방지하며, 캡슐화를 강화합니다.</li><li><strong>🚨 잠재적 호환성 문제:</strong> 클래스에 이미 <code>field</code>라는 이름의 속성이 있다면 새 키워드보다 우선 적용되어 예기치 않은 동작이 발생할 수 있습니다. 이는 이 기능이 2016년 최초 제안 이후 지연된 이유 중 하나로 보입니다.</li></ul><h2 id="5-hybrid-cache"><a class="markdownIt-Anchor" href="#5-hybrid-cache"></a> 5. Hybrid Cache</h2><p>새로운 <strong>HybridCache API</strong>는 기존의 <code>IDistributedCache</code>와 <code>IMemoryCache</code> API에서 발생하는 문제를 해결하며, 새로운 기능과 성능을 제공해 .NET에서 캐싱을 더 유연하고 효율적으로 만듭니다. 특히, <strong>스탬피드 문제</strong>와 같은 캐싱의 한계를 개선하며 대부분의 <code>IDistributedCache</code> 및 <code>IMemoryCache</code> 시나리오에 드롭인(dop-in) 방식으로 대체할 수 있도록 설계되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Post</span>(<span class="params"><span class="keyword">int</span> UserId, <span class="keyword">int</span> Id, <span class="keyword">string</span> Title, <span class="keyword">string</span> Body</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">PostsService</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    IHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    IMemoryCache memoryCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    IDistributedCache distributedCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    HybridCache hybridCache</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;Post&gt;?&gt; GetUserPostsAsync(<span class="keyword">string</span> userId)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cacheKey = <span class="string">$"posts_<span class="subst">&#123;userId&#125;</span>"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기존 방식 (Memory Cache)</span></span><br><span class="line">        <span class="keyword">var</span> posts = <span class="keyword">await</span> memoryCache.GetOrCreateAsync(cacheKey,</span><br><span class="line">            <span class="keyword">async</span> _ =&gt; <span class="keyword">await</span> GetPostsAsync(userId));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기존 방식 (Distributed Cache)</span></span><br><span class="line">        <span class="keyword">var</span> postsJson = <span class="keyword">await</span> distributedCache.GetStringAsync(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (postsJson <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posts = <span class="keyword">await</span> GetPostsAsync(userId);</span><br><span class="line">            <span class="keyword">await</span> distributedCache.SetStringAsync(cacheKey, JsonSerializer.Serialize(posts));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            posts = JsonSerializer.Deserialize&lt;List&lt;Post&gt;&gt;(postsJson);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// .NET 9 (Hybrid Cache)</span></span><br><span class="line">        posts = <span class="keyword">await</span> hybridCache.GetOrCreateAsync(cacheKey,</span><br><span class="line">            <span class="keyword">async</span> _ =&gt; <span class="keyword">await</span> GetPostsAsync(userId), <span class="keyword">new</span> HybridCacheEntryOptions() &#123;</span><br><span class="line">                Flags = HybridCacheEntryFlags.DisableLocalCache | <span class="comment">// 분산 캐시처럼 동작</span></span><br><span class="line">                        HybridCacheEntryFlags.DisableDistributedCache <span class="comment">// 메모리 캐시처럼 동작</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> posts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;List&lt;Post&gt;?&gt; GetPostsAsync(<span class="keyword">string</span> userId)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"===========Fetching posts from API"</span>);</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">$"https://jsonplaceholder.typicode.com/posts?userId=<span class="subst">&#123;userId&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">var</span> client = httpClientFactory.CreateClient();</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.Content.ReadFromJsonAsync&lt;List&lt;Post&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>두 가지 장점의 결합 (Best of Both Worlds):</strong> <code>HybridCache</code>는 단일 API로 데이터를 메모리 캐시(L1) 또는 분산 캐시(L2)에 저장할 수 있는 유연성을 제공합니다. L1 캐시는 자주 사용되는 데이터를 빠르게 로컬에서 액세스할 수 있도록 하고, L2 캐시는 대규모 및 덜 자주 접근되는 데이터를 처리할 수 있는 확장성을 제공합니다. 이 동작은 <strong>HybridCacheEntryFlags</strong>로 제어할 수 있습니다.</li><li><strong>스탬피드 보호 (Stampede Protection):</strong> <code>IMemoryCache</code>와 <code>IDistributedCache</code> 모두 스탬피드 문제를 겪지만, <code>HybridCache</code>는 동일한 키에 대해 하나의 호출만 값 생성을 수행하고, 다른 호출은 결과를 대기하도록 처리해 불필요한 캐시 재생성을 방지합니다.</li><li><strong>추가 기능:</strong> <code>HybridCache</code>는 태깅(Tagging), <code>.WithSerializer(...)</code> 및 <code>.WithSerializerFactory(...)</code> 메서드를 통한 설정 가능한 직렬화, <code>[ImmutableObject(true)]</code> 어노테이션을 활용한 캐시 인스턴스 재사용과 같은 추가 기능을 제공합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 분산 캐시 (Redis) 설정</span></span><br><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">"localhost:6379"</span>;</span><br><span class="line">    options.InstanceName = <span class="string">"SampleInstance"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 캐시 설정 (데모 목적)</span></span><br><span class="line">builder.Services.AddMemoryCache();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HybridCache 추가</span></span><br><span class="line">builder.Services.AddHybridCache();</span><br><span class="line">builder.Services.AddSingleton&lt;PostsService&gt;(); <span class="comment">// PostsService 등록</span></span><br></pre></td></tr></table></figure><p><strong>HybridCache</strong>는 메모리 캐시와 분산 캐시의 장점을 결합하여 빠른 액세스와 확장성을 동시에 제공합니다. 스탬피드 문제를 해결하며, 다양한 설정 및 추가 기능으로 유연하고 강력한 캐싱 솔루션을 제공합니다. 🚀</p><h2 id="6-내장-openapi-문서-생성"><a class="markdownIt-Anchor" href="#6-내장-openapi-문서-생성"></a> 6. 내장 OpenAPI 문서 생성</h2><p>.NET 5부터 Web API 템플릿은 <code>Swashbuckle.AspNetCore</code> 패키지를 통해 OpenAPI 지원을 기본으로 제공해왔습니다.</p><p>.NET 9에서는 Microsoft가 자체적으로 개발한 <code>Microsoft.AspNetCore.OpenApi</code> 패키지를 통해 OpenAPI 사양을 지원하며, 이는 기존의 <strong>Swashbuckle.AspNetCore</strong>를 대체합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.NET 9에서는 더 간단한 방식으로 OpenAPI 문서를 설정할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">builder.Services.AddOpenApi(); <span class="comment">// OpenAPI 지원 추가</span></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.MapOpenApi(); <span class="comment">// OpenAPI 엔드포인트 매핑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 실행한 후 <strong>/openapi/v1.json</strong>으로 이동하면 생성된 OpenAPI 문서를 확인할 수 있습니다.</p><ul><li><p><strong>Swagger UI:</strong> 문법이 더 짧아지고 처음 보기에 더 &quot;네이티브&quot;하게 보이지만, 기본적으로는 상호작용 가능한 API 문서(Swagger UI)는 제공되지 않고 OpenAPI 문서만 생성됩니다. 😢 Swagger UI 같은 상호작용 가능한 API 문서가 필요하다면 Scalar와 같은 서드파티 도구를 통합해야 합니다. 자세한 가이드는 Scalar .NET API Reference Integration에서 확인할 수 있습니다.</p></li><li><p><strong>Build-Time Generation:</strong> <code>Microsoft.Extensions.ApiDescription.Server</code> 패키지를 사용해 빌드 시점에 OpenAPI 문서를 생성할 수도 있습니다.</p></li></ul><h2 id="7-searchvalues-개선-사항"><a class="markdownIt-Anchor" href="#7-searchvalues-개선-사항"></a> 7. SearchValues 개선 사항</h2><p><strong>SearchValues</strong>는 .NET 8에서 도입된 불변(immutable) 및 읽기 전용 값 집합으로, 기존의 <strong>ICollection.Contains</strong>보다 훨씬 더 효율적인 검색을 제공합니다. 처음에는 문자(char)나 바이트(byte) 집합만 지원했지만, .NET 9에서는 문자열(string)도 지원하도록 확장되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Exploring new capabilities of SearchValues!"</span>.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> vowelSearch = SearchValues.Create([ <span class="string">'n'</span>, <span class="string">'e'</span>, <span class="string">'w'</span> ]); <span class="comment">// 문자 집합 검색</span></span><br><span class="line">Console.WriteLine(text.ContainsAny(vowelSearch));</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">var</span> keywordSearch = SearchValues.Create([<span class="string">"new"</span>, <span class="string">"of"</span>], StringComparison.OrdinalIgnoreCase); <span class="comment">// 문자열 검색</span></span><br><span class="line">Console.WriteLine(text.ContainsAny(keywordSearch));</span><br></pre></td></tr></table></figure><p>.NET 9에서는 <code>StringComparison</code> 매개변수를 사용해 비교 방식을 지정할 수 있습니다.</p><p>이제 문자열도 지원하며, 대소문자 무시 등의 비교 옵션을 지정할 수 있는 기능이 추가되었습니다. 앞으로 이 기능은 문서 파싱, 입력 필터링, 스팸 감지, 데이터 편집, 검색 등 광범위한 텍스트 처리 애플리케이션에서 필수적인 도구가 될 것입니다. 🚀</p><h2 id="8-새로운-linq-메서드"><a class="markdownIt-Anchor" href="#8-새로운-linq-메서드"></a> 8. 새로운 LINQ 메서드</h2><p>.NET 9에서는 <code>CountBy</code>, <code>AggregateBy</code>, <code>Index</code>라는 세 가지 새로운 LINQ 메서드가 추가되었습니다. 이 메서드들은 일반적인 데이터 조작 작업에서 성능과 간결성을 향상시키도록 설계되었습니다. 아래는 각 메서드의 예시와 설명입니다.</p><h3 id="countby"><a class="markdownIt-Anchor" href="#countby"></a> <code>CountBy</code></h3><p>특정 키로 그룹화하고 각 그룹의 항목 수를 계산합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> firstName, <span class="keyword">string</span> lastName)[] people =</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John"</span>, <span class="meta-string">"Doe"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Jane"</span>, <span class="meta-string">"Peterson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John"</span>, <span class="meta-string">"Smith"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary"</span>, <span class="meta-string">"Johnson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Nick"</span>, <span class="meta-string">"Carson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary"</span>, <span class="meta-string">"Morgan"</span>)</span></span><br><span class="line"><span class="meta"></span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> firstNameCounts = people</span><br><span class="line">   .GroupBy(p =&gt; p.firstName)</span><br><span class="line">   .ToDictionary(<span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Key, <span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Count())</span><br><span class="line">   .AsEnumerable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">firstNameCounts = people</span><br><span class="line">   .CountBy(p =&gt; p.firstName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> entry <span class="keyword">in</span> firstNameCounts)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(<span class="string">$"First Name <span class="subst">&#123;entry.Key&#125;</span> appears <span class="subst">&#123;entry.Value&#125;</span> times"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">First Name John appears 2 times</span></span><br><span class="line"><span class="comment">First Name Jane appears 1 times</span></span><br><span class="line"><span class="comment">First Name Mary appears 2 times</span></span><br><span class="line"><span class="comment">First Name Nick appears 1 times</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="aggregateby"><a class="markdownIt-Anchor" href="#aggregateby"></a> <code>AggregateBy</code></h3><p>그룹화된 데이터에서 값들을 집계합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> name, <span class="keyword">string</span> department, <span class="keyword">int</span> vacationDaysLeft)[] employees =</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John Doe"</span>, <span class="meta-string">"IT"</span>, 12),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Jane Peterson"</span>, <span class="meta-string">"Marketing"</span>, 18),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John Smith"</span>, <span class="meta-string">"IT"</span>, 28),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary Johnson"</span>, <span class="meta-string">"HR"</span>, 17),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Nick Carson"</span>, <span class="meta-string">"Marketing"</span>, 5),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary Morgan"</span>, <span class="meta-string">"HR"</span>, 9)</span></span><br><span class="line"><span class="meta"></span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> departmentVacationDaysLeft = employees</span><br><span class="line">   .GroupBy(emp =&gt; emp.department)</span><br><span class="line">   .ToDictionary(<span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Key, <span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Sum(emp =&gt; emp.vacationDaysLeft))</span><br><span class="line">   .AsEnumerable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">departmentVacationDaysLeft = employees</span><br><span class="line">   .AggregateBy(emp =&gt; emp.department, <span class="number">0</span>, (acc, emp) =&gt; acc + emp.vacationDaysLeft);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> departmentVacationDaysLeft)</span><br><span class="line">   Console.WriteLine(<span class="string">$"Department <span class="subst">&#123;entry.Key&#125;</span> has a total of <span class="subst">&#123;entry.Value&#125;</span> vacation days left."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">Department IT has a total of 40 vacation days left.</span></span><br><span class="line"><span class="comment">Department Marketing has a total of 23 vacation days left.</span></span><br><span class="line"><span class="comment">Department HR has a total of 26 vacation days left.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="index"><a class="markdownIt-Anchor" href="#index"></a> <code>Index</code></h3><p>컬렉션의 각 항목에 인덱스를 매핑합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> managers = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"John Doe"</span>,</span><br><span class="line">   <span class="string">"Jane Peterson"</span>,</span><br><span class="line">   <span class="string">"John Smith"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (index, manager) <span class="keyword">in</span> managers.Select((m, i) =&gt; (i, m)))</span><br><span class="line">   Console.WriteLine(<span class="string">$"Manager <span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;manager&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (index, manager) <span class="keyword">in</span> managers.Index())</span><br><span class="line">   Console.WriteLine(<span class="string">$"Manager <span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;manager&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">Manager 0: John Doe</span></span><br><span class="line"><span class="comment">Manager 1: Jane Peterson</span></span><br><span class="line"><span class="comment">Manager 2: John Smith</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>가장 좋은 함수는 <code>Index()</code>입니다. foreach에서 인덱스가 없는 점은 항상 골칫거리였고, 종종 더 복잡한 우회 방법을 사용하게 만들었기 때문입니다.</p><h2 id="9-내장-uuid-v7-생성"><a class="markdownIt-Anchor" href="#9-내장-uuid-v7-생성"></a> 9. 내장 UUID v7 생성</h2><p>.NET 초기부터 <code>Guid.NewGuid()</code>를 사용해 UUID를 생성해왔습니다. 이 방식은 <strong>UUID v4</strong>를 생성합니다. 그러나 UUID 사양은 지속적으로 발전해 현재의 안정된 버전은 <strong>UUID v7</strong>입니다.</p><p><strong>UUID v7</strong>의 주요 특징 중 하나는 UUID에 포함된 <strong>타임스탬프</strong>(timestamp)입니다. 구조는 다음과 같습니다:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------------+----------------------+</span><br><span class="line">| <span class="number">48</span>-<span class="built_in">bit</span> timestamp | <span class="number">12</span>-<span class="built_in">bit</span> <span class="built_in">random</span> |    <span class="number">62</span>-<span class="built_in">bit</span> <span class="built_in">random</span>     |</span><br><span class="line">+------------------+---------------+----------------------+</span><br></pre></td></tr></table></figure><p>이 타임스탬프 덕분에 UUID를 생성 시간에 따라 정렬할 수 있습니다. 이는 데이터베이스에서 더욱 적합하며, 분산 환경에서 더 나은 고유성을 보장합니다.</p><p>이제 .NET에서는 외부 라이브러리(예: <code>UUIDNext</code>)를 사용하지 않고도 UUID v7을 생성할 수 있습니다. 새로운 <code>Guid.CreateVersion7()</code> 메서드가 이를 지원하며, 특정 타임스탬프를 받아 UUID를 생성할 수도 있습니다. 이는 테스트 목적이나 정렬된 시퀀스에 특정 위치에 항목을 삽입할 때 유용합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> guid = Guid.NewGuid(); <span class="comment">// v4 UUID</span></span><br><span class="line">guid = Guid.CreateVersion7(); <span class="comment">// v7 UUID 생성</span></span><br><span class="line">guid = Guid.CreateVersion7(TimeProvider.System.GetUtcNow()); <span class="comment">// 타임스탬프가 포함된 v7 UUID 생성</span></span><br></pre></td></tr></table></figure><ul><li><code>Guid.CreateVersion7()</code>는 내부적으로 <code>NewGuid()</code>를 사용하며, 48비트 타임스탬프를 추가하고 UUID v7 표준에 맞게 올바른 버전 및 변형 비트를 설정합니다.</li><li>이로 인해 <code>NewGuid()</code>보다 약간 느릴 수 있지만, 수백만 개의 UUID를 생성해야 하는 경우가 아니라면 성능 차이는 거의 느껴지지 않습니다.</li></ul><h2 id="10-기타-기능"><a class="markdownIt-Anchor" href="#10-기타-기능"></a> 10. 기타 기능</h2><p>아래는 흥미로운 변경 사항들의 목록으로, 특정한 사용 사례에 적합하며 널리 채택되기보다는 특정 상황에서 유용하게 사용될 수 있는 기능들입니다.</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13#implicit-index-access" target="_blank" rel="noopener">암시적 인덱스 접근(Implicit index access)</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/csharp.md#partial-properties" target="_blank" rel="noopener">부분 속성(Partial properties)</a></li><li><a href="https://github.com/dotnet/core/blob/main/release-notes/9.0/preview/preview6/libraries.md#allows-ref-struct-used-in-many-places-throughout-the-libraries" target="_blank" rel="noopener">ref struct 허용</a></li><li><a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/libraries#base64url" target="_blank" rel="noopener">Base64Url 지원</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#collection-lookups-with-spans" target="_blank" rel="noopener">Span을 사용한 컬렉션 조회</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#regexenumeratesplits" target="_blank" rel="noopener">Regex.EnumerateSplits</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#systemtextjson" target="_blank" rel="noopener">System.Text.Json의 새로운 기능</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#ordereddictionarytkey-tvalue" target="_blank" rel="noopener"><code>OrderedDictionary&lt;TKey, TValue&gt;</code></a></li><li><a href="https://github.com/dotnet/core/blob/d6826c747b07bb4f050e2692bc309b8acd6ec1ec/release-notes/9.0/preview/preview6/libraries.md#readonlysett" target="_blank" rel="noopener"><code>ReadOnlySet&lt;T&gt;</code></a></li><li><a href="https://github.com/dotnet/core/blob/main/release-notes/9.0/preview/preview4/libraries.md#new-tensort-type" target="_blank" rel="noopener">New <code>Tensor&lt;T&gt;</code> 타입</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/12/06/csharp-15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>일상 작업을 자동화하는 10가지 Python 스크립트</title>
      <link>http://hgko1207.github.io/2024/12/05/python-11/</link>
      <guid>http://hgko1207.github.io/2024/12/05/python-11/</guid>
      <pubDate>Thu, 05 Dec 2024 14:39:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Python의 진정한 힘은 바로 자동화에 있습니다.&lt;/strong&gt; 일상 작업에 이 힘을 활용하지 않으시겠습니까?&lt;/p&gt;
&lt;p&gt;다음의 10가지 Python 스크립트는 초보자부터 숙련된 개발자까지 반복적인 작업을 자동화하고, 시간을 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Python의 진정한 힘은 바로 자동화에 있습니다.</strong> 일상 작업에 이 힘을 활용하지 않으시겠습니까?</p><p>다음의 10가지 Python 스크립트는 초보자부터 숙련된 개발자까지 반복적인 작업을 자동화하고, 시간을 절약하며, 효율성을 높이는 데 도움을 줄 것입니다.</p><p>전문가 수준이 아니더라도 지금 바로 시작할 수 있습니다!</p><h2 id="1-이미지-최적화-도구-photoshop이-필요-없어요"><a class="markdownIt-Anchor" href="#1-이미지-최적화-도구-photoshop이-필요-없어요"></a> 1. 이미지 최적화 도구: Photoshop이 필요 없어요!</h2><p>웹사이트나 소셜 미디어에 이미지를 최적화해야 할 때 Photoshop을 열기 귀찮으셨죠? 이제는 간단한 Python 스크립트로 해결할 수 있습니다. <strong>Pillow</strong> 라이브러리를 사용해 이미지 크기 조정, 회전, 필터 적용 등 다양한 작업을 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter, ImageOps, ImageEnhance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이미지 로드</span></span><br><span class="line">im = Image.open(<span class="string">"Image1.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이미지 작업 예제</span></span><br><span class="line">im = im.crop((<span class="number">34</span>, <span class="number">23</span>, <span class="number">100</span>, <span class="number">100</span>))  <span class="comment"># 자르기</span></span><br><span class="line">im = im.resize((<span class="number">50</span>, <span class="number">50</span>))          <span class="comment"># 크기 조정</span></span><br><span class="line">im = im.transpose(Image.FLIP_LEFT_RIGHT)  <span class="comment"># 좌우 반전</span></span><br><span class="line">im = im.rotate(<span class="number">360</span>)               <span class="comment"># 회전</span></span><br><span class="line">im.save(<span class="string">"Image1.jpg"</span>, optimize=<span class="literal">True</span>, quality=<span class="number">90</span>)  <span class="comment"># 압축 저장</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 필터 및 효과 적용</span></span><br><span class="line">im = im.filter(ImageFilter.BLUR)          <span class="comment"># 블러 효과</span></span><br><span class="line">im = im.filter(ImageFilter.SHARPEN)       <span class="comment"># 선명도 효과</span></span><br><span class="line">im = ImageOps.grayscale(im)               <span class="comment"># 흑백 변환</span></span><br><span class="line">im = ImageOps.invert(im)                  <span class="comment"># 색상 반전</span></span><br><span class="line">im.save(<span class="string">"Image1_optimized.jpg"</span>)</span><br></pre></td></tr></table></figure><h2 id="2-비디오-최적화-전문가급-비디오-만들기"><a class="markdownIt-Anchor" href="#2-비디오-최적화-전문가급-비디오-만들기"></a> 2. 비디오 최적화: 전문가급 비디오 만들기</h2><p>요즘 시대에서 비디오 편집은 단지 유튜버만의 영역이 아닙니다. <strong>MoviePy</strong>를 통해 자르기, 속도 조절, 효과 추가 등 기본적인 기능뿐만 아니라 멋진 효과까지 손쉽게 추가할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moviepy.editor <span class="keyword">as</span> pyedit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 로드</span></span><br><span class="line">video = pyedit.VideoFileClip(<span class="string">"vid.mp4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 자르기</span></span><br><span class="line">vid1 = video.subclip(<span class="number">0</span>, <span class="number">10</span>)  <span class="comment"># 0초부터 10초까지</span></span><br><span class="line">vid2 = video.subclip(<span class="number">20</span>, <span class="number">40</span>)  <span class="comment"># 20초부터 40초까지</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])  <span class="comment"># 두 클립 합치기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 속도 증가</span></span><br><span class="line">final_vid = final_vid.speedx(<span class="number">2</span>)  <span class="comment"># 2배 속도</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 오디오 추가</span></span><br><span class="line">aud = pyedit.AudioFileClip(<span class="string">"bg.mp3"</span>)  <span class="comment"># 오디오 파일 로드</span></span><br><span class="line">final_vid = final_vid.set_audio(aud)  <span class="comment"># 비디오에 오디오 설정</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 뒤집기 (역재생)</span></span><br><span class="line">final_vid = final_vid.fx(pyedit.vfx.time_mirror)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 두 비디오 병합</span></span><br><span class="line">vid1 = pyedit.VideoFileClip(<span class="string">"vid1.mp4"</span>)</span><br><span class="line">vid2 = pyedit.VideoFileClip(<span class="string">"vid2.mp4"</span>)</span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오에 시각 효과(VFX) 추가</span></span><br><span class="line">vid1 = final_vid.fx(pyedit.vfx.mirror_x)  <span class="comment"># 좌우 반전 효과</span></span><br><span class="line">vid2 = final_vid.fx(pyedit.vfx.invert_colors)  <span class="comment"># 색상 반전 효과</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오에 이미지 추가</span></span><br><span class="line">img1 = pyedit.ImageClip(<span class="string">"img1.jpg"</span>)  <span class="comment"># 이미지 1</span></span><br><span class="line">img2 = pyedit.ImageClip(<span class="string">"img2.jpg"</span>)  <span class="comment"># 이미지 2</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([img1, img2])  <span class="comment"># 이미지와 비디오 합치기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 최종 비디오 저장</span></span><br><span class="line">final_vid.write_videofile(<span class="string">"final.mp4"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-이메일-스케줄러-이메일-잊지-마세요"><a class="markdownIt-Anchor" href="#3-이메일-스케줄러-이메일-잊지-마세요"></a> 3. 이메일 스케줄러: 이메일 잊지 마세요!</h2><p><strong>smtplib</strong>과 <strong>schedule</strong>을 사용하여 이메일을 자동으로 예약하고 발송할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">()</span>:</span></span><br><span class="line">    sender_email = <span class="string">"your_email@gmail.com"</span></span><br><span class="line">    receiver_email = <span class="string">"recipient_email@gmail.com"</span></span><br><span class="line">    password = <span class="string">"your_email_password"</span></span><br><span class="line"></span><br><span class="line">    subject = <span class="string">"자동 이메일"</span></span><br><span class="line">    body = <span class="string">"이것은 Python으로 전송된 자동 이메일입니다."</span></span><br><span class="line"></span><br><span class="line">    message = <span class="string">f"Subject: <span class="subst">&#123;subject&#125;</span>\n\n<span class="subst">&#123;body&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> smtplib.SMTP_SSL(<span class="string">"smtp.gmail.com"</span>, <span class="number">465</span>) <span class="keyword">as</span> server:</span><br><span class="line">        server.login(sender_email, password)</span><br><span class="line">        server.sendmail(sender_email, receiver_email, message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 매일 오전 8시에 이메일을 보내도록 예약</span></span><br><span class="line">schedule.every().day.at(<span class="string">"08:00"</span>).do(send_email)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="4-소셜-미디어-자동-게시-도구"><a class="markdownIt-Anchor" href="#4-소셜-미디어-자동-게시-도구"></a> 4. 소셜 미디어 자동 게시 도구</h2><p><strong>Tweepy</strong> 라이브러리를 사용해 Twitter와 같은 플랫폼에 자동으로 게시물을 올릴 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_to_twitter</span><span class="params">()</span>:</span></span><br><span class="line">    api_key = <span class="string">"YOUR_API_KEY"</span></span><br><span class="line">    api_secret = <span class="string">"YOUR_API_SECRET"</span></span><br><span class="line">    access_token = <span class="string">"YOUR_ACCESS_TOKEN"</span></span><br><span class="line">    access_token_secret = <span class="string">"YOUR_ACCESS_TOKEN_SECRET"</span></span><br><span class="line"></span><br><span class="line">    auth = tweepy.OAuthHandler(api_key, api_secret)</span><br><span class="line">    auth.set_access_token(access_token, access_token_secret)</span><br><span class="line">    api = tweepy.API(auth)</span><br><span class="line"></span><br><span class="line">    tweet = <span class="string">"이것은 Python으로 자동 게시된 트윗입니다!"</span></span><br><span class="line">    api.update_status(tweet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6시간마다 게시되도록 예약합니다.</span></span><br><span class="line">schedule.every(<span class="number">6</span>).hours.do(post_to_twitter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="5-pdf를-이미지로-변환"><a class="markdownIt-Anchor" href="#5-pdf를-이미지로-변환"></a> 5. PDF를 이미지로 변환</h2><p><strong>PyMuPDF</strong>를 사용하여 PDF 페이지를 고화질 이미지로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pdf_to_images</span><span class="params">(pdf_file)</span>:</span></span><br><span class="line">    doc = fitz.open(pdf_file)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> doc:</span><br><span class="line">        pix = page.get_pixmap()</span><br><span class="line">        output = <span class="string">f"page<span class="subst">&#123;page.number&#125;</span>.png"</span></span><br><span class="line">        pix.writePNG(output)</span><br><span class="line"></span><br><span class="line">pdf_to_images(<span class="string">"test.pdf"</span>)</span><br></pre></td></tr></table></figure><h2 id="6-api-데이터-가져오기"><a class="markdownIt-Anchor" href="#6-api-데이터-가져오기"></a> 6. API 데이터 가져오기</h2><p><strong>urllib3</strong>를 사용하여 API 데이터를 자동으로 가져오며, 날씨 정보, 주가, GitHub 저장소 정보 등 어떤 데이터든 처리할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line"><span class="comment"># GET 요청으로 API 데이터 가져오기</span></span><br><span class="line">url = <span class="string">"https://api.github.com/users/psf/repos"</span>  <span class="comment"># GitHub 저장소 API URL</span></span><br><span class="line">http = urllib3.PoolManager()  <span class="comment"># HTTP 연결 풀 생성</span></span><br><span class="line">response = http.request(<span class="string">'GET'</span>, url)  <span class="comment"># GET 요청 전송</span></span><br><span class="line">print(<span class="string">"Status Code:"</span>, response.status)  <span class="comment"># 상태 코드 출력</span></span><br><span class="line">print(<span class="string">"Response Data:"</span>, response.data)  <span class="comment"># 응답 데이터 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 요청으로 API 데이터 전송</span></span><br><span class="line">url = <span class="string">"https://httpbin.org/post"</span>  <span class="comment"># POST 테스트 API URL</span></span><br><span class="line">http = urllib3.PoolManager()  <span class="comment"># HTTP 연결 풀 생성</span></span><br><span class="line">response = http.request(<span class="string">'POST'</span>, url, fields=&#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;)  <span class="comment"># POST 요청 전송</span></span><br><span class="line">print(<span class="string">"Status Code:"</span>, response.status)  <span class="comment"># 상태 코드 출력</span></span><br></pre></td></tr></table></figure><h2 id="7-배터리-알림-배터리-상태를-항상-주시하세요"><a class="markdownIt-Anchor" href="#7-배터리-알림-배터리-상태를-항상-주시하세요"></a> 7. 배터리 알림: 배터리 상태를 항상 주시하세요</h2><p><strong>plyer</strong>와 <strong>psutil</strong>을 사용해 배터리 상태를 모니터링하고 충전이 필요할 때 알림을 보냅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plyer <span class="keyword">import</span> notification</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    battery = psutil.sensors_battery()</span><br><span class="line">    life = battery.percent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> life &lt; <span class="number">50</span>:</span><br><span class="line">        notification.notify(</span><br><span class="line">            title=<span class="string">"Battery Low"</span>,</span><br><span class="line">            message=<span class="string">"Please connect to a power source"</span>,</span><br><span class="line">            timeout=<span class="number">10</span></span><br><span class="line">        )</span><br><span class="line">    sleep(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><h2 id="8-웹-스크래핑"><a class="markdownIt-Anchor" href="#8-웹-스크래핑"></a> 8. 웹 스크래핑</h2><p><strong>BeautifulSoup</strong>와 <strong>requests</strong>를 사용해 웹사이트에서 데이터를 자동으로 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://example.com"</span>  <span class="comment"># 스크래핑할 URL</span></span><br><span class="line">response = requests.get(url)  <span class="comment"># GET 요청</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">"html.parser"</span>)  <span class="comment"># HTML 파싱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 웹사이트에서 특정 데이터 추출</span></span><br><span class="line">data = soup.find(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>: <span class="string">"content"</span>&#125;).get_text()  <span class="comment"># "content" 클래스 데이터 추출</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h2 id="9-pytest-자동화된-테스트로-오류-없는-코드-유지"><a class="markdownIt-Anchor" href="#9-pytest-자동화된-테스트로-오류-없는-코드-유지"></a> 9. Pytest: 자동화된 테스트로 오류 없는 코드 유지</h2><p><strong>Pytest</strong>를 사용해 Python 코드가 올바르게 작동하는지 자동으로 테스트할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트할 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트 케이스</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_addition</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">-1</span>, <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">10</span>, <span class="number">5</span>) == <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main()</span><br></pre></td></tr></table></figure><h2 id="10-파일-백업-및-동기화"><a class="markdownIt-Anchor" href="#10-파일-백업-및-동기화"></a> 10. 파일 백업 및 동기화</h2><p>파일을 자동으로 백업하고 동기화하여 데이터를 안전하게 관리할 수 있습니다. 이 스크립트는 두 폴더 간 파일 백업 및 동기화를 수행합니다. 한 폴더에서 문서를 수정하면 다른 폴더도 자동으로 업데이트됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backup_and_sync</span><span class="params">(source_folder, backup_folder)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(source_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            source_path = os.path.join(root, file)</span><br><span class="line">            backup_path = os.path.join(backup_folder, root.replace(source_folder, <span class="string">""</span>), file)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 백업 폴더에 디렉토리가 없으면 생성</span></span><br><span class="line">            os.makedirs(os.path.dirname(backup_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 백업 폴더로 파일 복사</span></span><br><span class="line">            shutil.copy2(source_path, backup_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 백업 폴더에 남아있는 불필요한 파일 삭제</span></span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(backup_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            backup_path = os.path.join(root, file)</span><br><span class="line">            source_path = os.path.join(source_folder, root.replace(backup_folder, <span class="string">""</span>), file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(source_path):</span><br><span class="line">                os.remove(backup_path)</span><br><span class="line"></span><br><span class="line">source_folder = <span class="string">"path/to/source/folder"</span>  <span class="comment"># 원본 폴더 경로</span></span><br><span class="line">backup_folder = <span class="string">"path/to/backup/folder"</span>  <span class="comment"># 백업 폴더 경로</span></span><br><span class="line"></span><br><span class="line">backup_and_sync(source_folder, backup_folder)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/12/05/python-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 Lombok을 활용한 효율적인 Java 개발 가이드 🌟</title>
      <link>http://hgko1207.github.io/2024/11/25/spring-9/</link>
      <guid>http://hgko1207.github.io/2024/11/25/spring-9/</guid>
      <pubDate>Mon, 25 Nov 2024 05:38:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Project Lombok&lt;/strong&gt;은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Project Lombok</strong>은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보일러플레이트 코드를 자동으로 생성해줍니다.</p><h2 id="lombok을-사용하는-이유"><a class="markdownIt-Anchor" href="#lombok을-사용하는-이유"></a> Lombok을 사용하는 이유</h2><ul><li><strong>코드 간소화:</strong> <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, getters, setters 등의 일반적인 메서드를 자동으로 생성합니다.</li><li><strong>가독성 향상:</strong> 불필요한 코드가 줄어들어 코드의 의도가 더 명확하게 드러납니다.</li><li><strong>개발 시간 단축:</strong> 작성해야 할 코드가 줄어들어 비즈니스 로직에 집중할 수 있습니다.</li><li><strong>리팩토링 용이성:</strong> 필드 이름을 변경하더라도 getter/setter를 따로 수정할 필요가 없습니다.</li></ul><h2 id="lombok의-주요-기능"><a class="markdownIt-Anchor" href="#lombok의-주요-기능"></a> Lombok의 주요 기능</h2><p>Lombok은 수많은 주석을 제공합니다. 다음은 몇 가지 주요 기능을 살펴보겠습니다.</p><h2 id="data"><a class="markdownIt-Anchor" href="#data"></a> @Data</h2><p>모든 필드에 대한 getter를 생성하고, <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> 메서드와 생성자를 자동으로 만듭니다. 또한, final 필드에 대해 setter도 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">               <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-nonnull"><a class="markdownIt-Anchor" href="#2-nonnull"></a> 2. @NonNull</h2><p>메서드 또는 생성자의 매개변수에 대해 null 체크를 자동으로 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(@NonNull String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-cleanup"><a class="markdownIt-Anchor" href="#3-cleanup"></a> 3. @Cleanup</h2><p>특정 리소스를 자동으로 정리하여 리소스 누수를 방지합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="comment">// 스트림 작업</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-sneakythrows"><a class="markdownIt-Anchor" href="#4-sneakythrows"></a> 4. @SneakyThrows</h2><p>메서드 선언에 <code>throws</code>를 명시하지 않고도 체크 예외를 던질 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Files.readAllBytes(Paths.get(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-builder"><a class="markdownIt-Anchor" href="#5-builder"></a> 5. @Builder</h2><p>객체 생성을 위한 빌더 패턴을 자동으로 구현합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">email</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(name, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-value"><a class="markdownIt-Anchor" href="#6-value"></a> 6. @Value</h2><p><code>@Data</code>의 불변(immutable) 버전으로, 모든 필드를 private 및 final로 설정하며 setter를 생성하지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-생성자-어노테이션"><a class="markdownIt-Anchor" href="#7-생성자-어노테이션"></a> 7. 생성자 어노테이션</h2><p>Lombok은 생성자를 자동으로 생성하는 여러 어노테이션을 제공합니다.</p><h3 id="noargsconstructor"><a class="markdownIt-Anchor" href="#noargsconstructor"></a> @NoArgsConstructor</h3><p>인수 없는 생성자를 생성합니다. 프레임워크(JPA 등)에서 필요한 경우 유용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requiredargsconstructor"><a class="markdownIt-Anchor" href="#requiredargsconstructor"></a> @RequiredArgsConstructor</h3><p><code>final</code> 필드 및 <code>@NonNull</code> 필드에 대해 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@NonNull String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allargsconstructor"><a class="markdownIt-Anchor" href="#allargsconstructor"></a> @AllArgsConstructor</h3><p>모든 필드에 대한 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intellij-및-eclipse에서-lombok-설정"><a class="markdownIt-Anchor" href="#intellij-및-eclipse에서-lombok-설정"></a> IntelliJ 및 Eclipse에서 Lombok 설정</h2><h3 id="intellij-idea"><a class="markdownIt-Anchor" href="#intellij-idea"></a> IntelliJ IDEA</h3><ul><li><strong>플러그인 설치:</strong> 마켓플레이스에서 Lombok 플러그인을 설치합니다.</li><li><strong>어노테이션 프로세싱 활성화:</strong><br />Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors에서 활성화.</li></ul><h3 id="eclipse"><a class="markdownIt-Anchor" href="#eclipse"></a> Eclipse</h3><ul><li><strong>Lombok JAR 다운로드 및 실행:</strong> Eclipse 설치 경로에 Lombok을 통합합니다.</li><li><strong>재시작 및 설정 확인:</strong> 프로젝트 속성에서 어노테이션 프로세싱 활성화.</li></ul><h2 id="maven-및-gradle-통합"><a class="markdownIt-Anchor" href="#maven-및-gradle-통합"></a> Maven 및 Gradle 통합</h2><ul><li><strong>Maven 설정</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Gradle 설정</strong></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Lombok은 특히 Spring Boot 생태계에서 자바 개발자에게 필수적인 도구로 자리 잡았습니다. 보일러플레이트 코드를 줄이고 유지보수를 간소화하며, 코드 생산성을 크게 향상시킵니다.</p><p><strong>Lombok을 제대로 이해하고 활용하면, Spring Boot 애플리케이션 개발의 효율성이 크게 향상될 것입니다.</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/spring-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모든 개발자가 알아야 할 20가지 Git 명령어</title>
      <link>http://hgko1207.github.io/2024/11/25/git-4/</link>
      <guid>http://hgko1207.github.io/2024/11/25/git-4/</guid>
      <pubDate>Mon, 25 Nov 2024 04:55:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/git-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 &lt;code&gt;push&lt;/code&gt;, &lt;code
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/git-4.png" alt="" /></p><p><strong>Git</strong>은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 <code>push</code>, <code>pull</code>, <code>commit</code> 정도만 활용합니다. 그러나 Git은 우리가 상상하지 못한 다양한 기능을 제공하며, 이를 활용하면 생산성과 효율성을 대폭 향상시킬 수 있습니다.</p><p>이 글에서는 <strong>Git의 유용한 명령어 20가지</strong>를 소개하며, 이를 통해 더욱 효율적이고 자신감 있게 버전 관리를 할 수 있도록 도와드립니다.</p><h2 id="1-인터랙티브-추가"><a class="markdownIt-Anchor" href="#1-인터랙티브-추가"></a> 1. 인터랙티브 추가</h2><ul><li><strong>설명:</strong> 파일 전체가 아닌 특정 부분만 스테이징할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 내의 특정 변경 사항만 선택적으로 커밋할 수 있어, 작은 단위의 커밋을 만들 때 유용합니다.</li><li><strong>팁:</strong> 한 파일에서 여러 작업을 진행한 경우, 각 작업을 개별 커밋으로 나누는 데 사용하세요.</li></ul><h2 id="2-마지막-커밋-되돌리기"><a class="markdownIt-Anchor" href="#2-마지막-커밋-되돌리기"></a> 2. 마지막 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 마지막 커밋을 취소하되, 작업 디렉토리의 변경 사항은 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 커밋을 수정하거나 다시 커밋할 수 있는 “타임머신” 같은 기능입니다.</li><li><strong>팁:</strong> <code>--soft</code>는 변경 사항을 유지하고, <code>--hard</code>는 변경 사항까지 모두 되돌립니다.</li></ul><h2 id="3-브랜치의-업스트림-상태-확인하기"><a class="markdownIt-Anchor" href="#3-브랜치의-업스트림-상태-확인하기"></a> 3. 브랜치의 업스트림 상태 확인하기</h2><ul><li><strong>설명:</strong> 원격의 모든 업데이트를 가져오고, 삭제된 원격 브랜치의 참조를 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all --prune</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 로컬 환경을 최신 상태로 유지하며, 불필요한 브랜치를 정리합니다.</li><li><strong>팁:</strong> 대규모 팀에서 작업할 때 브랜치 목록을 깔끔하게 유지하세요.</li></ul><h2 id="4-빠른-커밋-수정"><a class="markdownIt-Anchor" href="#4-빠른-커밋-수정"></a> 4. 빠른 커밋 수정</h2><ul><li><strong>설명:</strong> 마지막 커밋을 수정하거나 커밋 메시지를 변경합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> Git 로그를 깔끔하게 유지하며 작은 실수를 빠르게 수정할 수 있습니다.</li><li><strong>팁:</strong> 여러 번의 커밋 없이 작은 실수를 수정하세요.</li></ul><h2 id="5-작업-임시-저장"><a class="markdownIt-Anchor" href="#5-작업-임시-저장"></a> 5. 작업 임시 저장</h2><ul><li><strong>설명:</strong> 현재 변경 사항을 커밋하지 않고 임시로 저장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 현재 작업을 보류하고 다른 브랜치로 전환할 수 있습니다.</li><li><strong>팁:</strong> <code>git stash save &quot;설명&quot;</code>으로 임시 저장 항목에 설명을 추가하면 더 쉽게 찾을 수 있습니다.</li></ul><h2 id="6-임시-저장-복원"><a class="markdownIt-Anchor" href="#6-임시-저장-복원"></a> 6. 임시 저장 복원</h2><ul><li><strong>설명:</strong> 임시 저장된 작업을 복원합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 저장한 작업을 다시 가져오며, 목록에서 자동으로 삭제됩니다.</li><li><strong>팁:</strong> <code>git stash apply</code>를 사용하면 삭제 없이 적용할 수 있습니다.</li></ul><h2 id="7-특정-커밋-가져오기"><a class="markdownIt-Anchor" href="#7-특정-커밋-가져오기"></a> 7. 특정 커밋 가져오기</h2><ul><li><strong>설명:</strong> 특정 커밋만 현재 브랜치에 적용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 브랜치 전체를 병합하지 않고 필요한 기능이나 버그 수정을 가져올 수 있습니다.</li><li><strong>팁:</strong> 버그 수정이나 특정 기능만 백포트(backport)할 때 유용합니다.</li></ul><h2 id="8-로컬-브랜치-정리"><a class="markdownIt-Anchor" href="#8-로컬-브랜치-정리"></a> 8. 로컬 브랜치 정리</h2><ul><li><strong>설명:</strong> 사용하지 않는 브랜치를 삭제합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 오래된 브랜치를 정리해 작업 공간을 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 병합되지 않은 브랜치를 삭제하려면 <code>-D</code> 플래그를 사용하세요.</li></ul><h2 id="9-파일-히스토리-보기"><a class="markdownIt-Anchor" href="#9-파일-히스토리-보기"></a> 9. 파일 히스토리 보기</h2><ul><li><strong>설명:</strong> 특정 파일에 영향을 준 모든 커밋을 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 변경 이력을 추적해 변경 이유를 이해할 수 있습니다.</li><li><strong>팁:</strong> <code>--stat</code> 옵션을 추가하면 더 자세한 변경 내용을 볼 수 있습니다.</li></ul><h2 id="10-라인별-코드-작성자-확인"><a class="markdownIt-Anchor" href="#10-라인별-코드-작성자-확인"></a> 10. 라인별 코드 작성자 확인</h2><ul><li><strong>설명:</strong> 특정 파일의 각 줄을 누가 작성했는지 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 디버깅 시 특정 코드 작성자를 추적하는 데 유용합니다.</li><li><strong>팁:</strong> <code>git log</code>와 함께 사용해 더 자세한 히스토리를 확인하세요.</li></ul><h2 id="11-버그-소스-찾기"><a class="markdownIt-Anchor" href="#11-버그-소스-찾기"></a> 11. 버그 소스 찾기</h2><ul><li><strong>설명:</strong> 이진 검색을 통해 버그가 도입된 커밋을 찾습니다.</li><li><strong>장점:</strong> 대규모 프로젝트에서 버그가 발생한 커밋을 빠르게 찾습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good &lt;older-commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="12-병합-중단"><a class="markdownIt-Anchor" href="#12-병합-중단"></a> 12. 병합 중단</h2><ul><li><strong>설명:</strong> 병합 중 문제가 발생하면 병합을 중단하고 이전 상태로 되돌립니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 병합 중단 후 새로운 시작점을 제공합니다.</li><li><strong>팁:</strong> 병합 전에 작업 디렉토리를 깨끗하게 유지하세요.</li></ul><h2 id="13-커밋-메시지-검색"><a class="markdownIt-Anchor" href="#13-커밋-메시지-검색"></a> 13. 커밋 메시지 검색</h2><ul><li><strong>설명:</strong> 커밋 메시지를 검색합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=<span class="string">"검색어"</span></span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 메시지 키워드로 커밋을 빠르게 찾습니다.</li><li><strong>팁:</strong> <code>--author</code>를 추가해 특정 작성자의 커밋을 검색하세요.</li></ul><h2 id="14-태그-추가"><a class="markdownIt-Anchor" href="#14-태그-추가"></a> 14. 태그 추가</h2><ul><li><strong>설명:</strong> Git 히스토리에서 특정 지점을 태그로 표시합니다.</li><li><strong>장점:</strong> 특정 버전을 표시해 쉽게 참조할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">"Version 1.0 release"</span></span><br></pre></td></tr></table></figure><h2 id="15-작업-공간-정리"><a class="markdownIt-Anchor" href="#15-작업-공간-정리"></a> 15. 작업 공간 정리</h2><ul><li><strong>설명:</strong> 추적되지 않은 파일과 디렉터리를 제거합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 작업 디렉토리를 정리하고 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 삭제된 파일이 필요 없는지 확인하세요.</li></ul><h2 id="16-git-작업-기록-보기"><a class="markdownIt-Anchor" href="#16-git-작업-기록-보기"></a> 16. Git 작업 기록 보기</h2><ul><li><strong>설명:</strong> 모든 Git 작업 기록을 확인합니다.</li><li><strong>장점:</strong> 손실된 커밋이나 작업을 복구할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="17-커밋-합치기"><a class="markdownIt-Anchor" href="#17-커밋-합치기"></a> 17. 커밋 합치기</h2><ul><li><strong>설명:</strong> 여러 커밋을 하나로 합쳐 Git 로그를 깔끔하게 만듭니다.</li><li><strong>장점:</strong> 커밋 기록을 깔끔하고 전문적으로 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~&lt;number-of-commits&gt;</span><br></pre></td></tr></table></figure><h2 id="18-커밋-되돌리기"><a class="markdownIt-Anchor" href="#18-커밋-되돌리기"></a> 18. 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 특정 커밋을 되돌리되, 전체 히스토리는 유지합니다.</li><li><strong>장점:</strong> 히스토리를 변경하지 않고 실수를 수정할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="19-브랜치-그래프-보기"><a class="markdownIt-Anchor" href="#19-브랜치-그래프-보기"></a> 19. 브랜치 그래프 보기</h2><ul><li><strong>설명:</strong> 프로젝트의 브랜치와 병합 기록을 그래프로 표시합니다.</li><li><strong>장점:</strong> 브랜치 구조를 한눈에 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all</span><br></pre></td></tr></table></figure><h2 id="20-자동-완성-사용"><a class="markdownIt-Anchor" href="#20-자동-완성-사용"></a> 20. 자동 완성 사용</h2><ul><li><strong>설명:</strong> Git 명령어 입력 시 탭을 눌러 자동 완성을 활성화합니다.</li><li><strong>장점:</strong> 생산성을 높이고 타이핑 오류를 줄입니다.</li></ul><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 20가지 Git 명령어 트릭은 생산성을 높이고 팀 내 Git 관리 능력을 향상시키는 필수 도구입니다. 이를 익히고 활용하면 동료들에게 &quot;Git 마스터&quot;로 인정받을 것입니다. 🚀</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/git-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(2)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-3/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-3/</guid>
      <pubDate>Mon, 25 Nov 2024 04:37:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;16-docker-image-prune&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#16-docker-image-prune&quot;&gt;&lt;/a&gt; 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.</p><h2 id="16-docker-image-prune"><a class="markdownIt-Anchor" href="#16-docker-image-prune"></a> 16. <code>docker image prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 이미지를 삭제합니다.</li><li><strong>장점:</strong> 개발 환경을 깔끔하게 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="17-docker-volume-prune"><a class="markdownIt-Anchor" href="#17-docker-volume-prune"></a> 17. <code>docker volume prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 볼륨을 삭제합니다.</li><li><strong>장점:</strong> 불필요한 스토리지 사용을 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><h2 id="18-docker-events"><a class="markdownIt-Anchor" href="#18-docker-events"></a> 18. <code>docker events</code></h2><ul><li><strong>설명:</strong> Docker 서버의 실시간 이벤트를 스트리밍합니다.</li><li><strong>장점:</strong> 컨테이너 수명 주기 이벤트를 추적합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events</span><br></pre></td></tr></table></figure><h2 id="19-docker-inspect-format"><a class="markdownIt-Anchor" href="#19-docker-inspect-format"></a> 19. <code>docker inspect --format</code></h2><ul><li><strong>설명:</strong> <code>docker inspect</code> 출력에서 특정 정보를 추출합니다.</li><li><strong>장점:</strong> 자동화 스크립트에서 필요한 데이터만 효율적으로 가져옵니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123; .Config.Env &#125;&#125;'</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="20-docker-build-no-cache"><a class="markdownIt-Anchor" href="#20-docker-build-no-cache"></a> 20. <code>docker build --no-cache</code></h2><ul><li><strong>설명:</strong> 캐시를 사용하지 않고 이미지를 빌드합니다.</li><li><strong>장점:</strong> 깨끗한 빌드를 보장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="21-docker-run-d"><a class="markdownIt-Anchor" href="#21-docker-run-d"></a> 21. <code>docker run -d</code></h2><ul><li><strong>설명:</strong> 컨테이너를 백그라운드에서 실행합니다.</li><li><strong>장점:</strong> 터미널을 자유롭게 사용하면서 여러 컨테이너를 관리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="22-docker-image-inspect"><a class="markdownIt-Anchor" href="#22-docker-image-inspect"></a> 22. <code>docker image inspect</code></h2><ul><li><strong>설명:</strong> 이미지의 세부 정보를 제공합니다.</li><li><strong>장점:</strong> 디버깅 및 이미지 최적화에 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="23-docker-save-docker-load"><a class="markdownIt-Anchor" href="#23-docker-save-docker-load"></a> 23. <code>docker save / docker load</code></h2><ul><li><strong>설명:</strong> 이미지를 tar 파일로 저장하거나 로드합니다.</li><li><strong>장점:</strong> 인터넷 없이 이미지를 전송할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;image_name&gt;.tar &lt;image_name&gt;</span><br><span class="line">docker load -i &lt;image_name&gt;.tar</span><br></pre></td></tr></table></figure><h2 id="24-docker-exec-it"><a class="markdownIt-Anchor" href="#24-docker-exec-it"></a> 24. <code>docker exec -it</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너에서 대화형 bash 셸을 엽니다.</li><li><strong>장점:</strong> 컨테이너 내부에서 디버깅과 테스트를 빠르게 수행할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name&gt; bash</span><br></pre></td></tr></table></figure><h2 id="25-docker-ps-q-docker-stop-docker-ps-q"><a class="markdownIt-Anchor" href="#25-docker-ps-q-docker-stop-docker-ps-q"></a> 25. docker ps -q / docker stop $(docker ps -q)</h2><ul><li><strong>설명:</strong> 실행 중인 모든 컨테이너를 빠르게 중지합니다.</li><li><strong>장점:</strong> 개발 환경을 한 번에 정리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 25가지 Docker 명령어는 일상적인 워크플로를 개선하고 컨테이너 환경을 보다 효율적으로 관리할 수 있도록 도와줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(1)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-2/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-2/</guid>
      <pubDate>Mon, 25 Nov 2024 04:10:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Docker</strong>는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.</p><p>이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은 <strong>Docker 명령어</strong>를 활용해 워크플로를 최적화하고, 성능을 개선하며, 확장 가능한 애플리케이션을 구축하는 능력입니다.</p><p>이 글에서는 Docker 명령어 25가지를 소개하며, 이를 통해 개발 및 배포 프로세스를 완벽하게 제어하고 일상적인 작업을 개선하는 방법을 알려드립니다.</p><h2 id="1-docker-update"><a class="markdownIt-Anchor" href="#1-docker-update"></a> 1. <code>docker update</code></h2><ul><li><strong>설명:</strong> 컨테이너를 재시작하지 않고 리소스 제한을 업데이트합니다.</li><li><strong>장점:</strong> 중단 없이 리소스를 조정해 컨테이너 성능 저하를 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --cpus 2 --memory 1g &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> 트래픽이 많은 시간대에 리소스를 늘렸다가, 이후 다시 축소하여 자원을 절약하세요.</li></ul><h2 id="2-docker-stats"><a class="markdownIt-Anchor" href="#2-docker-stats"></a> 2. <code>docker stats</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너의 실시간 리소스 사용량을 표시합니다.</li><li><strong>장점:</strong> CPU, 메모리, 네트워크 사용량을 실시간으로 모니터링할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> --all 옵션으로 백그라운드 컨테이너까지 모니터링하세요.</li></ul><h2 id="3-docker-diff"><a class="markdownIt-Anchor" href="#3-docker-diff"></a> 3. <code>docker diff</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템에서 변경된 내용을 보여줍니다.</li><li><strong>장점:</strong> 배포 후 변경된 파일을 빠르게 확인하고 문제를 해결합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="4-docker-commit"><a class="markdownIt-Anchor" href="#4-docker-commit"></a> 4. <code>docker commit</code></h2><ul><li><strong>설명:</strong> 컨테이너의 현재 상태를 기반으로 새로운 이미지를 생성합니다.</li><li><strong>장점:</strong> 변경된 상태를 저장해 디버깅이나 테스트 환경에 활용할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;container_name&gt; &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="5-docker-cp"><a class="markdownIt-Anchor" href="#5-docker-cp"></a> 5. <code>docker cp</code></h2><ul><li><strong>설명:</strong> 컨테이너와 호스트 간 파일을 복사합니다.</li><li><strong>장점:</strong> 컨테이너를 중단하지 않고 로그나 설정 파일에 접근할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;container_name&gt;:/path/to/file /host/path</span><br></pre></td></tr></table></figure><h2 id="6-docker-build-squash"><a class="markdownIt-Anchor" href="#6-docker-build-squash"></a> 6. <code>docker build --squash</code></h2><ul><li><strong>설명:</strong> 빌드 중 레이어를 하나로 압축하여 이미지 크기를 줄입니다.</li><li><strong>장점:</strong> 이미지 크기를 줄여 로드 시간을 단축하고 저장 공간을 절약합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="7-docker-system-df"><a class="markdownIt-Anchor" href="#7-docker-system-df"></a> 7. <code>docker system df</code></h2><ul><li><strong>설명:</strong> Docker 디스크 사용량 요약 정보를 제공합니다.</li><li><strong>장점:</strong> 디스크 공간을 많이 차지하는 요소를 빠르게 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="8-docker-network-inspect"><a class="markdownIt-Anchor" href="#8-docker-network-inspect"></a> 8. <code>docker network inspect</code></h2><ul><li><strong>설명:</strong> Docker 네트워크의 상세 정보를 확인합니다.</li><li><strong>장점:</strong> 컨테이너 간 네트워킹 문제를 디버깅하는 데 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;network_name&gt;</span><br></pre></td></tr></table></figure><h2 id="9-docker-exec-u"><a class="markdownIt-Anchor" href="#9-docker-exec-u"></a> 9. <code>docker exec -u</code></h2><ul><li><strong>설명:</strong> 특정 사용자를 지정해 컨테이너에서 명령을 실행합니다.</li><li><strong>장점:</strong> 다양한 사용자 환경을 테스트할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u &lt;user&gt; &lt;container_name&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="10-docker-run-rm"><a class="markdownIt-Anchor" href="#10-docker-run-rm"></a> 10. <code>docker run --rm</code></h2><ul><li><strong>설명:</strong> 컨테이너 종료 후 자동으로 삭제합니다.</li><li><strong>장점:</strong> 임시 작업 후 불필요한 컨테이너를 자동으로 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="11-docker-compose-config"><a class="markdownIt-Anchor" href="#11-docker-compose-config"></a> 11. <code>docker-compose config</code></h2><ul><li><strong>설명:</strong> <code>docker-compose.yml</code> 파일을 검증하고 구성을 표시합니다.</li><li><strong>장점:</strong> 구성 파일의 구문 오류를 사전에 감지할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose config</span><br></pre></td></tr></table></figure><h2 id="12-docker-rm-v"><a class="markdownIt-Anchor" href="#12-docker-rm-v"></a> 12. <code>docker rm -v</code></h2><ul><li><strong>설명:</strong> 컨테이너와 관련된 익명의 볼륨을 함께 삭제합니다.</li><li><strong>장점:</strong> 고아 볼륨을 방지해 디스크 공간을 효율적으로 사용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="13-docker-export-docker-import"><a class="markdownIt-Anchor" href="#13-docker-export-docker-import"></a> 13. <code>docker export / docker import</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템을 tar 파일로 내보내거나 새 이미지로 가져옵니다.</li><li><strong>장점:</strong> 특정 상태를 다른 환경으로 쉽게 전환할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> &lt;container_name&gt; &gt; container.tar</span><br><span class="line">docker import container.tar &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="14-docker-history"><a class="markdownIt-Anchor" href="#14-docker-history"></a> 14. <code>docker history</code></h2><ul><li><strong>설명:</strong> 이미지의 각 레이어 변경 이력을 보여줍니다.</li><li><strong>장점:</strong> 큰 이미지를 디버깅하거나 최적화할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="15-docker-logs-since"><a class="markdownIt-Anchor" href="#15-docker-logs-since"></a> 15. <code>docker logs --since</code></h2><ul><li><strong>설명:</strong> 특정 시간 이후의 로그를 검색합니다.</li><li><strong>장점:</strong> 최근 업데이트 이후의 문제를 빠르게 찾을 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since <span class="string">"10m"</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p>내용이 많아, 다음 글에서 추가로 설명드리겠습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법</title>
      <link>http://hgko1207.github.io/2024/11/21/spring-8/</link>
      <guid>http://hgko1207.github.io/2024/11/21/spring-8/</guid>
      <pubDate>Thu, 21 Nov 2024 03:12:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 있을 것입니다.</p><h2 id="api-응답-구조가-왜-중요할까"><a class="markdownIt-Anchor" href="#api-응답-구조가-왜-중요할까"></a> API 응답 구조가 왜 중요할까?</h2><p>먼저, 잘 구조화된 API 응답이 왜 중요한지 살펴봅시다. 일관된 응답 구조는 다음과 같은 장점을 제공합니다:</p><ul><li><strong>클라이언트 측 에러 처리 개선:</strong> 프론트엔드 팀에서 크게 감사할 것입니다.</li><li><strong>가독성과 유지보수성 향상:</strong> 미래의 당신이나 팀이 명확함에 감동할 것입니다.</li><li><strong>디버깅과 로깅 간소화:</strong> 문제를 빠르고 효율적으로 파악할 수 있습니다.</li></ul><h2 id="좋은-api-응답의-조건"><a class="markdownIt-Anchor" href="#좋은-api-응답의-조건"></a> 좋은 API 응답의 조건</h2><p>잘 구조화된 API 응답은 다음과 같은 특징을 가져야 합니다:</p><ul><li><strong>일관성:</strong> 다양한 엔드포인트에서 동일한 형식 유지</li><li><strong>정보 제공:</strong> 관련 데이터, 메시지, 상태 코드 및 에러 코드를 포함</li><li><strong>단순함:</strong> 쉽게 파싱하고 이해할 수 있는 형식</li></ul><h2 id="이상적인-응답-구조-만들기"><a class="markdownIt-Anchor" href="#이상적인-응답-구조-만들기"></a> 이상적인 응답 구조 만들기</h2><h3 id="1-표준-응답-형식-정의"><a class="markdownIt-Anchor" href="#1-표준-응답-형식-정의"></a> 1. 표준 응답 형식 정의</h3><p>모든 API가 따를 표준 응답 형식을 먼저 정의합니다. 다음은 간단하면서도 효과적인 형식입니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"요청이 성공적으로 처리되었습니다."</span>,</span><br><span class="line">  "data": &#123; ... &#125;,</span><br><span class="line">  "errors": null,</span><br><span class="line">  "errorCode": 0,</span><br><span class="line">  "timestamp": 1633017600000,</span><br><span class="line">  "path": "/api/example"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 필드의 역할</p><ul><li><code>success</code>: (<code>boolean</code>) 요청이 성공했는지 여부를 나타냅니다.</li><li><code>message</code>: (<code>String</code>) 요청 처리 결과에 대한 사람이 읽을 수 있는 메시지를 제공합니다.</li><li><code>data</code>: (<code>T</code>) 클라이언트가 요청한 실제 데이터를 포함합니다.</li><li><code>errors</code>: (<code>List&lt;String&gt;</code>) 요청이 실패한 경우 발생한 에러 메시지 목록입니다.</li><li><code>errorCode</code>: (<code>int</code>) 비즈니스 로직 관련 에러 유형을 나타내는 코드입니다.</li><li><code>timestamp</code>: (<code>long</code>) 응답이 생성된 시간을 나타냅니다.</li><li><code>path</code>: (<code>String</code>) 호출된 API 엔드포인트를 나타냅니다.</li></ul><h3 id="2-응답-유틸리티-메서드-생성"><a class="markdownIt-Anchor" href="#2-응답-유틸리티-메서드-생성"></a> 2. 응답 유틸리티 메서드 생성</h3><p>코드 중복을 피하기 위해 응답을 생성하는 유틸리티 메서드를 만들어봅니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String message, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(data);</span><br><span class="line">        response.setErrors(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrorCode(<span class="number">0</span>);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(List&lt;String&gt; errors, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrors(errors);</span><br><span class="line">        response.setErrorCode(errorCode);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(String error, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error(Arrays.asList(error), message, errorCode, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-전역-예외-처리-구현"><a class="markdownIt-Anchor" href="#3-전역-예외-처리-구현"></a> 3. 전역 예외 처리 구현</h3><p>전역적으로 예외를 처리하면 처리되지 않은 에러도 표준 응답 형식으로 반환할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = Arrays.asList(ex.getMessage());</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(errors, <span class="string">"An error occurred"</span>, <span class="number">1000</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ResourceNotFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleResourceNotFoundException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ResourceNotFoundException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getMessage(), <span class="string">"Resource not found"</span>, <span class="number">1001</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ValidationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleValidationException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ValidationException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getErrors(), <span class="string">"Validation failed"</span>, <span class="number">1002</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-컨트롤러에서-응답-형식-사용"><a class="markdownIt-Anchor" href="#4-컨트롤러에서-응답-형식-사용"></a> 4. 컨트롤러에서 응답 형식 사용</h3><p>표준화된 응답 형식을 컨트롤러에서도 활용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/products"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; getProductById(<span class="meta">@PathVariable</span> Long id, HttpServletRequest request) &#123;</span><br><span class="line">        Product product = productService.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (product == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ResourceNotFoundException(<span class="string">"Product not found with id "</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(product, <span class="string">"Product fetched successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; createProduct(<span class="meta">@RequestBody</span> Product product, HttpServletRequest request) &#123;</span><br><span class="line">        Product createdProduct = productService.save(product);</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(createdProduct, <span class="string">"Product created successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="에러-코드의-예시"><a class="markdownIt-Anchor" href="#에러-코드의-예시"></a> 에러 코드의 예시</h2><p>아래는 전자상거래 애플리케이션에서 사용할 수 있는 에러 코드의 예입니다.</p><table><thead><tr><th>에러 코드</th><th>설명</th></tr></thead><tbody><tr><td>2000</td><td>재고 없음</td></tr><tr><td>2001</td><td>결제 수단 거부</td></tr><tr><td>2002</td><td>유효하지 않은 쿠폰 코드</td></tr><tr><td>2003</td><td>주문 취소 기간 초과</td></tr><tr><td>2004</td><td>계정 일시 정지</td></tr><tr><td>2005</td><td>동일 상품에 대한 중복 주문</td></tr></tbody></table><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법을 알아보았습니다. 위 단계를 구현하면 API가 더 깔끔하고 유지보수가 쉬워질 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/21/spring-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>시니어 개발자들이 절대 놓치지 않는 10가지 코딩 습관</title>
      <link>http://hgko1207.github.io/2024/11/19/info-31/</link>
      <guid>http://hgko1207.github.io/2024/11/19/info-31/</guid>
      <pubDate>Tue, 19 Nov 2024 05:46:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다루기 쉽게 유지하는 방법을 살펴봅시다.</p><h2 id="1-코드를-미래의-나를-위해-작성하라"><a class="markdownIt-Anchor" href="#1-코드를-미래의-나를-위해-작성하라"></a> 1. 코드를 미래의 나를 위해 작성하라</h2><p>새벽 3시에 디버깅해야 하는 상황을 상상해 보세요. x, y, temp 같은 이름을 사용하는 변수와 복잡하게 중첩된 함수들이 난잡하게 얽혀 있다면 고통스럽겠죠. 코드를 작성할 때는 미래의 자신이 코드를 리뷰한다고 생각하고 작성하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = x * y;</span><br><span class="line">  <span class="keyword">return</span> temp + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalPrice</span>(<span class="params">itemPrice, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalCost = itemPrice * quantity;</span><br><span class="line">  <span class="keyword">return</span> totalCost + <span class="number">5</span>; <span class="comment">// 배송비 포함</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>좋은 코드에서는 <code>itemPrice</code>, <code>quantity</code>, <code>totalCost</code> 같은 이름이 함수의 목적을 즉시 알 수 있게 해줍니다. 코드를 다시 살펴보지 않아도 이해할 수 있죠.</p><p>코드는 유지보수를 염두에 두고 작성해야 합니다. 구조, 의미 있는 이름, 논리적 흐름에 신경 써서 단순함을 추구하세요.</p><h2 id="2-이름-짓기는-중요하다"><a class="markdownIt-Anchor" href="#2-이름-짓기는-중요하다"></a> 2. 이름 짓기는 중요하다</h2><p>시니어 개발자는 변수, 함수, 클래스의 이름을 짓는 일이 중요하다는 것을 압니다. 모호한 이름은 혼란을 야기합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = fetchData();</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = fetchUserData();</span><br></pre></td></tr></table></figure><p>좋은 이름은 코드를 읽는 사람이 추가적인 맥락을 찾을 필요가 없게 만듭니다.</p><h2 id="3-중복을-피하라dry-그러나-과유불급은-피하라"><a class="markdownIt-Anchor" href="#3-중복을-피하라dry-그러나-과유불급은-피하라"></a> 3. 중복을 피하라(DRY), 그러나 과유불급은 피하라</h2><p>코드 중복은 시간 낭비를 초래합니다. DRY(Don’t Repeat Yourself) 원칙을 따르되, 지나친 추상화는 피하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tax = price * <span class="number">0.13</span>;</span><br><span class="line">  <span class="keyword">return</span> price + tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TAX_RATE = <span class="number">0.13</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * TAX_RATE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price + calculateTax(price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-무엇을-설명하는-대신-왜를-설명하라"><a class="markdownIt-Anchor" href="#4-무엇을-설명하는-대신-왜를-설명하라"></a> 4. '무엇’을 설명하는 대신 '왜’를 설명하라</h2><p>불필요한 주석은 코드 읽기를 방해합니다. 대신 복잡한 알고리즘의 이유나 가정 같은 맥락을 설명하세요.</p><p><strong>좋은 주석</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대규모 배열의 빠른 조회를 위해 이진 탐색 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">arr, target</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="5-단일-책임-원칙을-지켜라"><a class="markdownIt-Anchor" href="#5-단일-책임-원칙을-지켜라"></a> 5. 단일 책임 원칙을 지켜라</h2><p>함수는 하나의 작업만 수행해야 합니다. 이 원칙을 따르면 테스트가 쉬워지고, 코드가 더 읽기 쉽고 모듈화됩니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndProcessAndSaveUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"><a class="markdownIt-Anchor" href="#6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"></a> 6. 버전 관리는 필수다 (의미 있는 커밋 메시지와 함께)</h2><p>시니어 개발자는 의미 없는 커밋 메시지를 작성하지 않습니다.</p><p><strong>나쁜 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"버그 수정"</span></span><br></pre></td></tr></table></figure><p><strong>좋은 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"검증이 누락되어 사용자 세부 정보가 저장되지 않는 문제 해결"</span></span><br></pre></td></tr></table></figure><h2 id="7-에러를-우아하게-처리하라"><a class="markdownIt-Anchor" href="#7-에러를-우아하게-처리하라"></a> 7. 에러를 우아하게 처리하라</h2><p>애플리케이션이 충돌하며 “뭔가 잘못되었습니다” 같은 에러 메시지를 띄운다면, 이는 사용자 경험을 망칩니다. 의미 있는 에러 메시지와 로그를 제공하세요.</p><p><strong>나쁜 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  logError(error);</span><br><span class="line">  showErrorNotification(<span class="string">'문제가 발생했습니다. 나중에 다시 시도해주세요.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-테스트를-작성하라"><a class="markdownIt-Anchor" href="#8-테스트를-작성하라"></a> 8. 테스트를 작성하라</h2><p>테스트는 코드가 제대로 작동하는지 확인하는 중요한 도구입니다.</p><p><strong>테스트 없는 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> price = calculateTotal(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong>테스트 작성</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'calculateTotal'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should return the correct total'</span>, () =&gt; &#123;</span><br><span class="line">    expect(calculateTotal(<span class="number">100</span>)).toBe(<span class="number">115</span>); <span class="comment">// 15% 세금 포함</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-종속성-관리를-신중히-하라"><a class="markdownIt-Anchor" href="#9-종속성-관리를-신중히-하라"></a> 9. 종속성 관리를 신중히 하라</h2><p>불필요한 라이브러리 의존성은 프로젝트를 복잡하게 만들고, 보안 문제를 초래하며, 유지보수를 어렵게 합니다.</p><p><strong>나쁜 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure><p><strong>좋은 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash.debounce</span><br></pre></td></tr></table></figure><h2 id="10-정기적으로-과감하게-리팩터링하라"><a class="markdownIt-Anchor" href="#10-정기적으로-과감하게-리팩터링하라"></a> 10. 정기적으로 과감하게 리팩터링하라</h2><p>코드는 정원을 가꾸는 것과 같습니다. 정기적으로 구조를 개선하고 읽기 쉽게 최적화해야 합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; orderList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (orderList[i].status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// process the order</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterPendingOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> orderList.filter(<span class="function">(<span class="params">order</span>) =&gt;</span> order.status === <span class="string">'pending'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pendingOrders = filterPendingOrders(orderList);</span><br><span class="line">  pendingOrders.forEach(<span class="function">(<span class="params">order</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// process the order</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>위 10가지 실천법은 시니어 개발자의 작업 방식을 반영한 기본적인 습관들입니다. 이를 점진적으로 적용하면 더 깨끗하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 당신의 코드가 미래의 자신과 동료 개발자들에게 편리함을 제공하게 될 것입니다. 😉</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/info-31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>필수로 알아야할 13가지 SQL 문법</title>
      <link>http://hgko1207.github.io/2024/11/19/sql-1/</link>
      <guid>http://hgko1207.github.io/2024/11/19/sql-1/</guid>
      <pubDate>Tue, 19 Nov 2024 05:15:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Structured Query Language&lt;/strong&gt;(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Structured Query Language</strong>(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리 사용됩니다.</p><p>SQL은 데이터를 필터링, 정렬, 그룹화, 집계하는 등 다양한 데이터 조작 작업을 수행할 수 있는 강력한 도구입니다. 이 글에서는 데이터 과학 작업의 90%를 수행할 수 있는 13가지 필수 SQL 문법에 대해 다룹니다. 이러한 문법은 이해하기 쉽고 구현하기 쉬우며, SQL 작업의 기초를 다지는 데에 도움을 줍니다.</p><h2 id="1-select"><a class="markdownIt-Anchor" href="#1-select"></a> 1. SELECT</h2><p><code>SELECT</code> 문은 데이터베이스에서 하나 이상의 테이블에서 데이터를 조회하는 데 사용됩니다. <code>WHERE</code>, <code>ORDER BY</code>, <code>GROUP BY</code>와 같은 다양한 함수와 함께 사용하여 데이터를 필터링, 정렬, 그룹화하는 데 익숙해져야 합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>column1</code>, <code>column2</code>, <code>column3</code>는 조회하려는 열의 이름이며, <code>table_name</code>은 데이터를 포함한 테이블의 이름입니다. <code>WHERE</code> 절은 선택 사항이지만, 쿼리가 데이터를 조회하기 위해 충족해야 하는 조건을 지정하는 데 사용됩니다.</p><h3 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h3><p>고객 테이블에서 18세 이상인 모든 고객을 조회</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> age &gt;= <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h2 id="2-join"><a class="markdownIt-Anchor" href="#2-join"></a> 2. JOIN</h2><p><code>JOIN</code> 문은 데이터베이스의 두 개 이상의 테이블에서 데이터를 결합할 때 사용됩니다. 필요한 경우 적합한 JOIN 유형(예: <code>INNER</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>FULL OUTER</code>)을 지정해야 합니다.</p><h3 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> INNER JOIN</h3><p><code>INNER JOIN</code>은 두 테이블의 열에서 일치하는 행만 반환합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orders.order_id, customers.customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id = customers.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블과 <code>customers</code> 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 두 테이블의 <code>customer_id</code> 열에서 일치하는 데이터가 있는 경우에만 <code>order_id</code>와 <code>customer_name</code> 열이 포함됩니다.</p><h3 id="left-join"><a class="markdownIt-Anchor" href="#left-join"></a> LEFT JOIN</h3><p><code>LEFT JOIN</code>은 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 행을 반환합니다. 오른쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되고, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="right-join"><a class="markdownIt-Anchor" href="#right-join"></a> RIGHT JOIN</h3><p><code>RIGHT JOIN</code>은 오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 행을 반환합니다. 왼쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고, <code>customers</code> 테이블은 왼쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되고, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="outer-join"><a class="markdownIt-Anchor" href="#outer-join"></a> OUTER JOIN</h3><p><code>OUTER JOIN</code>은 두 테이블 중 하나 또는 두 테이블의 모든 행을 반환하며, 일치하지 않는 행도 포함합니다. <code>LEFT OUTER JOIN</code>과 <code>RIGHT OUTER JOIN</code> 두 가지 유형이 있습니다.</p><h4 id="left-outer-join-예제"><a class="markdownIt-Anchor" href="#left-outer-join-예제"></a> LEFT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되며, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h4 id="right-outer-join-예제"><a class="markdownIt-Anchor" href="#right-outer-join-예제"></a> RIGHT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고 <code>customers</code> 테이블은 왼쪽 테이블입니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되며, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><p><strong>참고:</strong> 일부 데이터베이스는 <code>RIGHT OUTER JOIN</code>을 지원하지 않을 수 있습니다. 이 경우, <code>LEFT OUTER JOIN</code>을 사용하고 테이블의 순서를 바꾸어 동일한 결과를 얻을 수 있습니다.</p><h2 id="3-where"><a class="markdownIt-Anchor" href="#3-where"></a> 3. WHERE</h2><p><code>WHERE</code> 문은 지정된 조건에 따라 데이터를 필터링하는 데 사용됩니다. 특정 기준을 충족하는 데이터만 조회하려면 <code>WHERE</code> 문을 능숙하게 사용하는 것이 중요합니다.</p><p>아래는 테이블에서 데이터를 필터링하기 위해 <code>WHERE</code> 문을 사용하는 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, department, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department = <span class="string">'Sales'</span> <span class="keyword">AND</span> salary &gt; <span class="number">50000</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “Sales” 부서에서 근무하며 급여가 $50,000 이상인 모든 직원의 이름, 부서, 급여를 결과로 반환합니다.</p><h2 id="4-group-by"><a class="markdownIt-Anchor" href="#4-group-by"></a> 4. GROUP BY</h2><p><code>GROUP BY</code> 문은 하나 이상의 열을 기준으로 데이터를 그룹화하며, <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>와 같은 집계 함수를 사용하여 그룹화된 데이터의 요약 정보를 계산할 수 있습니다. GROUP BY를 활용하여 카테고리별로 데이터를 분석하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="keyword">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 부서와 각 부서의 평균 급여를 반환합니다. 각 부서의 평균 급여는 해당 부서 직원들의 모든 급여 합계를 직원 수로 나눈 값으로 계산됩니다. <code>GROUP BY</code> 절은 부서별로 직원을 그룹화하는 데 사용되며, <code>AVG</code> 함수는 각 부서의 평균 급여를 계산하는 데 사용됩니다.</p><table><thead><tr><th>Department</th><th>Avg Salary</th></tr></thead><tbody><tr><td>Sales</td><td>65,000</td></tr><tr><td>Marketing</td><td>55,000</td></tr><tr><td>Engineering</td><td>80,000</td></tr></tbody></table><p>위 예제에서, <strong>Sales</strong> 부서는 평균 급여가 $65,000, <strong>Marketing</strong> 부서는 $55,000, <strong>Engineering</strong> 부서는 $80,000임을 확인할 수 있습니다.</p><h2 id="5-having"><a class="markdownIt-Anchor" href="#5-having"></a> 5. HAVING</h2><p><code>HAVING</code> 문은 <code>GROUP BY</code>로 그룹화된 데이터를 특정 조건에 따라 필터링하는 데 사용됩니다. 그룹화된 데이터를 추가로 필터링하는 방법을 숙달하는 것이 중요합니다.</p><p>아래는 <code>HAVING</code> 절을 사용하는 SQL 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantity) &gt;= <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 고객과 그들이 주문한 총 제품 수량을 반환하지만, 총 수량이 50단위 이상인 고객만 결과에 포함됩니다. <code>GROUP BY</code> 절은 고객별로 주문을 그룹화하는 데 사용되고, <code>SUM</code> 함수는 각 고객이 주문한 제품의 총 수량을 계산하는 데 사용됩니다. 마지막으로 <code>HAVING</code> 절은 결과를 필터링하여 조건을 만족하는 데이터만 반환합니다.</p><h2 id="6-윈도우-함수-window-function"><a class="markdownIt-Anchor" href="#6-윈도우-함수-window-function"></a> 6. 윈도우 함수 (Window Function)</h2><p>SQL에서 윈도우 함수는 현재 행과 관련된 행 집합에 대해 계산을 수행하는 데 사용됩니다. 이러한 함수는 지정된 조건이나 파티션에 기반한 테이블의 일부 행(윈도우)에 적용됩니다. 아래는 SQL에서 윈도우 함수를 사용하는 몇 가지 예제입니다.</p><h3 id="1-row_number"><a class="markdownIt-Anchor" href="#1-row_number"></a> 1. <code>ROW_NUMBER()</code></h3><p><code>ROW_NUMBER()</code> 함수는 각 파티션 내에서 각 행에 고유한 순차 번호를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>row_num</code>이라는 추가 열을 포함하며, 이 열은 <code>column1</code>의 순서에 따라 각 행에 순차적으로 번호를 부여합니다.</p><h3 id="2-sum"><a class="markdownIt-Anchor" href="#2-sum"></a> 2. <code>SUM()</code></h3><p><code>SUM()</code> 함수는 각 파티션 내에서 특정 열의 합계를 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_sum</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_sum</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 합계를 계산합니다.</p><h3 id="3-rank"><a class="markdownIt-Anchor" href="#3-rank"></a> 3. <code>RANK()</code></h3><p><code>RANK()</code> 함수는 특정 열의 값에 따라 각 파티션 내에서 각 행에 순위를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column3 <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>rank_num</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column3</code> 값을 기준으로 내림차순 정렬된 순위를 나타냅니다.</p><h3 id="4-avg"><a class="markdownIt-Anchor" href="#4-avg"></a> 4. <code>AVG()</code></h3><p><code>AVG()</code> 함수는 각 파티션 내에서 특정 열의 평균을 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">AVG</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_avg</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_avg</code>라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 평균을 계산합니다.</p><h3 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h3><p>윈도우 함수의 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다. 사용하려는 DBMS의 문서를 참고하여 정확한 문법을 확인하는 것이 좋습니다.</p><h2 id="7-union"><a class="markdownIt-Anchor" href="#7-union"></a> 7. UNION</h2><p>SQL에서 <code>UNION</code> 연산자는 두 개 이상의 <code>SELECT</code> 문의 결과를 하나의 결과 집합으로 결합하는 데 사용됩니다. 각 <code>SELECT</code> 문은 동일한 열 개수와 호환 가능한 데이터 유형을 가져야 합니다. 결과 집합에서는 중복된 행이 자동으로 제거됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 뉴욕에 거주하는 모든 사람(고객과 직원 포함)의 목록을 반환합니다. 첫 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 고객을 조회하며, 두 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 직원을 조회합니다. <code>UNION</code> 연산자는 이 두 <code>SELECT</code> 문의 결과를 결합하고 중복된 행을 제거합니다.</p><h2 id="8-create"><a class="markdownIt-Anchor" href="#8-create"></a> 8. CREATE</h2><p><code>CREATE</code> 문은 새로운 데이터베이스 테이블, 뷰 또는 기타 데이터베이스 객체를 생성하는 데 사용됩니다. 새로운 테이블, 뷰, 기타 객체를 생성하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 쿼리는 &quot;customers&quot;라는 이름의 새 테이블을 생성하며, 네 개의 열(“id”, “name”, “email”, “phone”)을 포함합니다.</p><ul><li><strong>id:</strong> 정수형으로 설정되며, 테이블의 기본 키로 지정됩니다.</li><li><strong>name:</strong> 최대 50자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>email:</strong> 최대 100자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>phone:</strong> 최대 20자까지 저장할 수 있는 문자열로 설정됩니다.</li></ul><h2 id="9-insert"><a class="markdownIt-Anchor" href="#9-insert"></a> 9. INSERT</h2><p><code>INSERT</code> 문은 데이터베이스 테이블에 새 데이터를 삽입하는 데 사용됩니다. 테이블에 데이터를 추가하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, <span class="keyword">name</span>, major, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1234</span>, <span class="string">'John Doe'</span>, <span class="string">'Computer Science'</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음 값으로 새 행을 “students” 테이블에 삽입합니다:</p><ul><li><strong>id:</strong> 1234</li><li><strong>name:</strong> John Doe</li><li><strong>major:</strong> Computer Science</li><li><strong>gpa:</strong> 3.5</li></ul><p><code>INSERT</code> 문은 데이터를 삽입하려는 테이블의 이름을 지정하고, 삽입할 열 목록을 작성한 뒤, <code>VALUES</code> 키워드를 사용해 해당 열에 삽입할 값을 순서대로 지정합니다.</p><h2 id="10-update"><a class="markdownIt-Anchor" href="#10-update"></a> 10. UPDATE</h2><p><code>UPDATE</code> 문은 데이터베이스 테이블의 기존 데이터를 수정하는 데 사용됩니다. 테이블의 하나 이상의 열 값을 업데이트하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> major = <span class="string">'Mathematics'</span>, gpa = <span class="number">3.7</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음과 같은 작업을 수행합니다:</p><ul><li><strong>major</strong> 열의 값을 'Mathematics’로 업데이트</li><li><strong>gpa</strong> 열의 값을 3.7로 업데이트</li><li><strong>WHERE</strong> 절을 사용하여 ID가 1234인 행만 업데이트</li></ul><p><code>UPDATE</code> 문은 업데이트하려는 테이블의 이름을 지정한 후, <code>SET</code> 키워드를 사용하여 업데이트할 열과 새 값을 나열합니다. 특정 행만 업데이트하려면 <code>WHERE</code> 절을 사용하여 조건을 지정해야 합니다.</p><h2 id="11-delete"><a class="markdownIt-Anchor" href="#11-delete"></a> 11. DELETE</h2><p><code>DELETE</code> 문은 데이터베이스 테이블에서 하나 이상의 행을 삭제하는 데 사용됩니다. 테이블에서 데이터를 제거하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “students” 테이블에서 ID가 1234인 행을 제거합니다.</p><ul><li><code>DELETE FROM</code>은 데이터를 삭제하려는 테이블의 이름을 지정합니다.</li><li><code>WHERE</code> 절은 삭제할 행을 지정하는 조건을 나타냅니다. 이 경우, ID가 1234인 행을 삭제하도록 설정했습니다.</li></ul><h2 id="12-drop"><a class="markdownIt-Anchor" href="#12-drop"></a> 12. DROP</h2><p><code>DROP</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체를 삭제하는 데 사용됩니다. 불필요한 테이블이나 기타 객체를 데이터베이스에서 제거하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-drop-table"><a class="markdownIt-Anchor" href="#1-drop-table"></a> 1. DROP TABLE</h3><p>기존 테이블과 해당 테이블의 모든 데이터 및 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="2-drop-index"><a class="markdownIt-Anchor" href="#2-drop-index"></a> 2. DROP INDEX</h3><p>테이블에서 기존 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="3-drop-view"><a class="markdownIt-Anchor" href="#3-drop-view"></a> 3. DROP VIEW</h3><p>기존의 뷰(View)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure><h3 id="4-drop-procedure"><a class="markdownIt-Anchor" href="#4-drop-procedure"></a> 4. DROP PROCEDURE</h3><p>기존의 저장 프로시저(Stored Procedure)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br></pre></td></tr></table></figure><h3 id="주의-사항"><a class="markdownIt-Anchor" href="#주의-사항"></a> 주의 사항</h3><ul><li><code>DROP</code> 문은 지정된 객체와 관련된 모든 데이터 및 인덱스를 <strong>영구적으로 삭제</strong>합니다.</li><li>삭제된 데이터나 객체는 복구할 수 없으므로, 삭제 작업을 실행하기 전에 데이터를 반드시 백업해야 합니다.</li><li>사용하는 데이터베이스 관리 시스템(DBMS)에 따라 <code>DROP</code> 문의 정확한 문법이 다를 수 있으므로, 사용하는 DBMS의 문서를 참조하는 것이 좋습니다.</li></ul><h2 id="13-alter"><a class="markdownIt-Anchor" href="#13-alter"></a> 13. ALTER</h2><p><code>ALTER</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체의 구조를 수정하는 데 사용됩니다. 열 추가 및 삭제, 데이터 유형 변경, 제약 조건 설정 등 다양한 작업을 수행하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-alter-table"><a class="markdownIt-Anchor" href="#1-alter-table"></a> 1. ALTER TABLE</h3><p>기존 테이블의 구조를 수정합니다. 열을 추가하거나 삭제하고, 데이터 유형을 변경하거나 제약 조건을 설정하는 데 사용됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">MODIFY</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">DROP</span> column_name,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name constraint_definition,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></table></figure><p>테이블에 새로운 열 추가</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">ADD</span> phone_number <span class="built_in">VARCHAR</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>기존 열 삭제</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> phone_number;</span><br></pre></td></tr></table></figure><h3 id="2-alter-index"><a class="markdownIt-Anchor" href="#2-alter-index"></a> 2. ALTER INDEX</h3><p>기존 인덱스의 구조를 수정합니다. 열을 추가하거나 제거하고, 인덱스 유형을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ADD</span> column_name,</span><br><span class="line"><span class="keyword">DROP</span> column_name;</span><br></pre></td></tr></table></figure><h3 id="3-alter-view"><a class="markdownIt-Anchor" href="#3-alter-view"></a> 3. ALTER VIEW</h3><p>기존 뷰(View)의 정의를 수정합니다. 생성 시 사용된 <code>SELECT</code> 문을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">AS</span> select_statement;</span><br></pre></td></tr></table></figure><h3 id="참고-2"><a class="markdownIt-Anchor" href="#참고-2"></a> 참고</h3><ul><li><code>ALTER</code> 문의 정확한 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다.</li><li>구조를 수정하는 작업은 데이터 무결성에 영향을 미칠 수 있으므로, 변경 전에 데이터베이스 구조와 데이터에 미치는 영향을 철저히 검토해야 합니다.</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/sql-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 컴포넌트 작성, 전문가처럼!</title>
      <link>http://hgko1207.github.io/2024/11/12/react-19/</link>
      <guid>http://hgko1207.github.io/2024/11/12/react-19/</guid>
      <pubDate>Tue, 12 Nov 2024 06:08:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/react-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/react-19.png" alt="" /></p><p><strong>React</strong>에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포넌트를 만드는 예술입니다. 오늘은 React 컴포넌트를 전문가처럼 작성하는 방법을 알아보며, 가독성, 재사용성, 효율성에 중점을 두고 설명해드리겠습니다.</p><h2 id="1-기본-list-컴포넌트-만들기"><a class="markdownIt-Anchor" href="#1-기본-list-컴포넌트-만들기"></a> 1. 기본 List 컴포넌트 만들기</h2><p>먼저, 간단한 <code>List</code> 컴포넌트부터 시작해 보겠습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/List.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> List;</span><br></pre></td></tr></table></figure><p>이 컴포넌트는 배열 형태의 <code>data</code>를 받아 이를 목록 형태로 렌더링합니다.</p><h2 id="2-hoc로-컴포넌트-확장하기"><a class="markdownIt-Anchor" href="#2-hoc로-컴포넌트-확장하기"></a> 2. HOC로 컴포넌트 확장하기</h2><p>고차 컴포넌트(Higher-Order Components, HOC)는 컴포넌트의 구조를 변경하지 않고 기능을 확장할 수 있는 강력한 패턴입니다. HOC는 다른 컴포넌트를 감싸 추가적인 기능을 제공하도록 설계되었습니다.</p><p>예를 들어, <code>withLoading</code> HOC를 사용해 로딩 상태를 표시하는 방법은 다음과 같습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withLoading.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithLoading</span>(<span class="params">&#123; isLoading, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLoading;</span><br></pre></td></tr></table></figure><p>이 HOC는 <code>isLoading</code> prop을 확인하여, <code>isLoading</code>이 <code>true</code>일 때는 “Loading…” 메시지를, 그렇지 않을 때는 감싼 컴포넌트를 렌더링합니다. 이를 통해 데이터 로딩 중에도 사용자 경험을 자연스럽게 유지할 수 있습니다.</p><p>비슷하게, <code>withErrorHandling</code> HOC를 사용해 에러 상태를 관리할 수도 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withErrorHandling.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withErrorHandling</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithErrorHandling</span>(<span class="params">&#123; error, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withErrorHandling;</span><br></pre></td></tr></table></figure><p>에러가 발생하면 <code>withErrorHandling</code>은 에러 메시지를 표시하고, 그렇지 않으면 컴포넌트를 일반적으로 렌더링합니다. 이 HOC는 데이터 가져오기(fetch) 오류 또는 컴포넌트 수명 주기 내에서 발생하는 문제를 처리하는 데 유용합니다.</p><p>이제 <code>withLoading</code>과 <code>withErrorHandling</code>을 결합해 로딩과 에러 상태를 모두 처리할 수 있는 컴포넌트를 만들 수 있습니다. 이 접근법은 코드 재사용과 관심사 분리를 촉진하여, 컴포넌트의 유지 보수를 더 용이하게 하고 이해하기 쉽게 만듭니다.</p><h2 id="3-hooks로-데이터-가져오기"><a class="markdownIt-Anchor" href="#3-hooks로-데이터-가져오기"></a> 3. Hooks로 데이터 가져오기</h2><p>React의 hooks는 클래스 없이도 상태나 기타 React 기능을 사용할 수 있게 합니다. <code>useFetch</code>는 API에서 데이터를 가져오는 커스텀 훅입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hooks/useFetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useFetch = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setLoading(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">        <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Network response was not ok'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">        setData(json);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setError(error);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클린업 함수</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 필요 시 클린업 로직 작성</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useFetch;</span><br></pre></td></tr></table></figure><p>이 훅은 로딩 상태, 데이터 저장, 에러 처리를 담당하여, 컴포넌트에서 데이터를 쉽게 가져와 표시할 수 있도록 합니다.</p><h2 id="4-앱-구성하기"><a class="markdownIt-Anchor" href="#4-앱-구성하기"></a> 4. 앱 구성하기</h2><p>마지막으로, 모든 요소를 <code>App</code> 컴포넌트에 통합합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLoading <span class="keyword">from</span> <span class="string">'./hocs/withLoading'</span>;</span><br><span class="line"><span class="keyword">import</span> withErrorHandling <span class="keyword">from</span> <span class="string">'./hocs/withErrorHandling'</span>;</span><br><span class="line"><span class="keyword">import</span> useFetch <span class="keyword">from</span> <span class="string">'./hooks/useFetch'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./components/List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ListWithLoading = withLoading(List);</span><br><span class="line"><span class="keyword">const</span> ListWithErrorHandling = withErrorHandling(ListWithLoading);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, error &#125; = useFetch(<span class="string">'https://api.example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;List Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ListWithErrorHandling data=&#123;data&#125; isLoading=&#123;isLoading&#125; error=&#123;error&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>useFetch</code> 훅을 사용하여 데이터를 로드하고, <code>List</code> 컴포넌트에 전달합니다. 이 <code>List</code> 컴포넌트는 <code>withLoading</code>과 <code>withErrorHandling</code> HOC로 확장되어 로딩과 에러 상태를 처리합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>프로처럼 컴포넌트를 작성하는 것은 전체적인 그림을 보는 것에서 시작됩니다. 가독성, 유지보수성, 재사용성이 높은 컴포넌트를 만드는 것이 핵심입니다. HOC와 hooks 같은 패턴을 사용하면, 시간이 지나도 견고하고 효율적인 코드베이스를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/12/react-19/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
