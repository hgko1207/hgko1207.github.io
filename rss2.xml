<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Thu, 09 Jan 2025 05:57:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>알아두어야 할 마이크로서비스 설계 패턴 TOP 10</title>
      <link>http://hgko1207.github.io/2025/01/09/info-32/</link>
      <guid>http://hgko1207.github.io/2025/01/09/info-32/</guid>
      <pubDate>Thu, 09 Jan 2025 05:13:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;마이크로서비스에 특화된 다양한 설계 패턴을 소개하려고 합니다. 본격적인 패턴 설명에 앞서 마이크로서비스에 대한 기본 개념과 함께 이로 인해 발생하는 도전 과제를 간단히 정리해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;마이크로서비스란-무엇인가&quot;&gt;&lt;a cl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>마이크로서비스에 특화된 다양한 설계 패턴을 소개하려고 합니다. 본격적인 패턴 설명에 앞서 마이크로서비스에 대한 기본 개념과 함께 이로 인해 발생하는 도전 과제를 간단히 정리해 보겠습니다.</p><h2 id="마이크로서비스란-무엇인가"><a class="markdownIt-Anchor" href="#마이크로서비스란-무엇인가"></a> 마이크로서비스란 무엇인가?</h2><p>마이크로서비스란 특정 기능에 집중하며 독립적으로 배포 가능한 소규모 컴포넌트를 말합니다. 각 마이크로서비스는 자체 프로세스에서 실행되며, 일반적으로 API를 통해 다른 서비스와 통신합니다. 이 서비스들은 느슨하게 결합(loose coupling)되어 있어 확장성, 개발 속도, 유지보수 측면에서 많은 장점을 제공합니다.</p><p><img src="/images/header/info-32.png" alt="" /></p><h2 id="모놀리식-애플리케이션-vs-마이크로서비스-애플리케이션"><a class="markdownIt-Anchor" href="#모놀리식-애플리케이션-vs-마이크로서비스-애플리케이션"></a> 모놀리식 애플리케이션 vs 마이크로서비스 애플리케이션</h2><p>마이크로서비스 아키텍처는 모놀리식 애플리케이션과 비교했을 때 다음과 같은 주요 장점을 제공합니다.</p><ol><li><p><strong>확장성</strong><br />각 마이크로서비스를 독립적으로 확장할 수 있어 리소스 사용을 최적화할 수 있습니다.</p></li><li><p><strong>유연성</strong><br />서로 다른 마이크로서비스를 각기 다른 기술로 개발, 테스트, 배포, 유지보수할 수 있습니다.</p></li><li><p><strong>빠른 개발 속도</strong><br />작은 단위의 팀이 각기 다른 마이크로서비스를 병렬로 개발할 수 있어 개발 주기와 출시 속도가 빨라집니다.</p></li><li><p><strong>높은 복원력</strong><br />특정 마이크로서비스에 장애가 발생하더라도 전체 시스템에 미치는 영향이 적어 안정성이 높아집니다.</p></li><li><p><strong>유지보수 용이성</strong><br />각 마이크로서비스가 작고 독립적인 코드베이스로 구성되어 있어 이해하기 쉽고 수정 및 디버깅이 용이합니다.</p></li><li><p><strong>아웃소싱 유연성</strong><br />비즈니스 기능을 제3자 파트너에게 아웃소싱할 때 지적 재산 보호가 중요합니다. 마이크로서비스 아키텍처는 파트너별 구성 요소를 격리하여 핵심 서비스를 안전하게 보호할 수 있도록 도와줍니다.</p></li></ol><p>하지만 마이크로서비스 아키텍처는 다음과 같은 도전 과제도 수반합니다.</p><ol><li><p><strong>복잡성 증가</strong><br />마이크로서비스 기반 애플리케이션을 개발하고 유지보수하는 것은 모놀리식보다 더 많은 노력을 요구합니다. 각 서비스마다 별도의 코드베이스, 테스트, 배포 파이프라인, 문서화가 필요합니다.</p></li><li><p><strong>서비스 간 통신 문제</strong><br />네트워크 통신에 의존하기 때문에 지연(latency), 장애, 복잡한 통신 처리 문제 등이 발생할 수 있습니다.</p></li><li><p><strong>데이터 관리</strong><br />마이크로서비스마다 별도의 데이터베이스를 사용하는 경우가 많아 데이터 일관성, 동기화, 트랜잭션 관리에서 어려움을 겪을 수 있습니다.</p></li><li><p><strong>배포 부담</strong><br />여러 마이크로서비스의 배포, 버전 관리, 확장을 관리하려면 Kubernetes와 같은 고급 오케스트레이션 및 자동화 도구가 필요합니다.</p></li><li><p><strong>보안</strong><br />각 마이크로서비스가 새로운 취약점을 초래할 수 있어 공격 표면이 넓어지며, 이에 따라 보안 관리가 더욱 중요해집니다.</p></li></ol><h2 id="주요-마이크로서비스-설계-패턴"><a class="markdownIt-Anchor" href="#주요-마이크로서비스-설계-패턴"></a> 주요 마이크로서비스 설계 패턴</h2><p>이제 마이크로서비스 아키텍처에서 흔히 사용되는 주요 설계 패턴 10가지를 자세히 살펴보겠습니다.</p><h3 id="1-database-per-service-pattern"><a class="markdownIt-Anchor" href="#1-database-per-service-pattern"></a> 1. Database Per Service Pattern</h3><p><strong>Database Per Service Pattern</strong>은 각 마이크로서비스가 독립적인 데이터베이스를 가지도록 하는 설계 방식입니다. 이렇게 하면 느슨한 결합을 유지할 수 있으며, 각 팀이 서비스에 적합한 데이터베이스 기술을 선택할 수 있습니다.</p><p><img src="/images/header/info-32_1.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>느슨한 결합:</strong> 각 서비스가 독립적으로 동작하므로 모듈성이 향상됩니다.</li><li><strong>기술 선택의 유연성:</strong> 각 서비스에 가장 적합한 데이터베이스를 선택할 수 있습니다.</li><li><strong>확장성:</strong> 서비스별로 독립적인 확장 전략을 세울 수 있어 리소스 사용이 최적화됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 여러 데이터베이스의 백업, 복구, 확장 등을 관리하는 데 어려움이 있습니다.</li><li><strong>교차 서비스 쿼리 문제:</strong> 여러 데이터베이스에 걸쳐 데이터를 조회하는 것이 어려울 수 있습니다.</li><li><strong>데이터 일관성 문제:</strong> 데이터 일관성을 유지하기 위해 Event Sourcing이나 Saga 패턴과 같은 추가적인 설계가 필요할 수 있습니다.</li></ul><h3 id="2-api-gateway-pattern"><a class="markdownIt-Anchor" href="#2-api-gateway-pattern"></a> 2. API Gateway Pattern</h3><p><strong>API Gateway Pattern</strong>은 모든 클라이언트 요청을 단일 엔드포인트(API 게이트웨이)를 통해 처리하는 설계 방식입니다. 이 게이트웨이는 요청을 적절한 마이크로서비스로 라우팅하고, 인증, 로깅, 로드 밸런싱과 같은 공통 기능을 제공합니다.</p><p><img src="/images/header/info-32_2.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>클라이언트 상호작용 단순화:</strong> 클라이언트가 다수의 마이크로서비스에 직접 요청하는 대신, 하나의 게이트웨이만 호출하면 됩니다.</li><li><strong>중앙 집중식 관리:</strong> 인증, 로깅, 모니터링 등 공통 기능을 게이트웨이에서 통합 관리할 수 있습니다.</li><li><strong>보안 향상:</strong> 게이트웨이에서 접근 제어, 요청 검증 등을 처리하여 보안을 강화할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>단일 장애 지점:</strong> 게이트웨이가 장애를 겪으면 전체 시스템이 영향을 받을 수 있습니다.</li><li><strong>성능 오버헤드:</strong> 모든 요청이 게이트웨이를 거쳐야 하므로 잘못 설계된 경우 병목이 될 수 있습니다.</li><li><strong>복잡성 증가:</strong> 게이트웨이에 많은 기능이 추가될수록 관리 복잡성이 커질 수 있습니다.</li></ul><h3 id="3-backend-for-frontend-pattern-bff"><a class="markdownIt-Anchor" href="#3-backend-for-frontend-pattern-bff"></a> 3. Backend For Frontend Pattern (BFF)</h3><p><strong>BFF</strong> 패턴은 서로 다른 프론트엔드 애플리케이션(웹, 모바일 등)에 위한 맞춤형 백엔드를 제공하는 설계 방식입니다.</p><p><img src="/images/header/info-32_3.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>프론트엔드와의 통신 최적화:</strong> 각 프론트엔드의 요구사항에 맞는 응답을 제공하여 사용자 경험을 개선할 수 있습니다.</li><li><strong>프론트엔드 단순화:</strong> BFF가 데이터 집계, 변환 등을 처리하므로 프론트엔드 코드가 단순해집니다.</li><li><strong>독립적 진화 가능:</strong> 각 프론트엔드와 BFF가 독립적으로 진화할 수 있어 개발 유연성이 높아집니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>유지보수 복잡성 증가:</strong> 프론트엔드별로 별도의 BFF를 관리해야 하므로 유지보수 비용이 증가할 수 있습니다.</li><li><strong>코드 중복 가능성:</strong> 여러 BFF에 공통으로 필요한 기능이 중복될 수 있습니다.</li><li><strong>일관성 관리 어려움:</strong> 여러 BFF가 동일한 기능을 제공할 때 일관성을 유지하는 것이 어려울 수 있습니다.</li></ul><h3 id="4-command-query-responsibility-segregation-cqrs"><a class="markdownIt-Anchor" href="#4-command-query-responsibility-segregation-cqrs"></a> 4. Command Query Responsibility Segregation (CQRS)</h3><p><strong>CQRS 패턴</strong>은 읽기 작업(쿼리)과 쓰기 작업(명령)의 책임을 분리하는 설계 방식입니다.</p><p><img src="/images/header/info-32_4.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>성능 최적화:</strong> 읽기와 쓰기 작업을 독립적으로 최적화할 수 있습니다.</li><li><strong>독립적 확장성:</strong> 읽기와 쓰기 모델을 개별적으로 확장할 수 있어 리소스 사용이 효율적입니다.</li><li><strong>유지보수성 향상:</strong> 읽기와 쓰기 로직이 분리되어 코드의 가독성과 유지보수성이 향상됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 두 개의 모델을 관리해야 하므로 설계와 구현이 복잡해집니다.</li><li><strong>데이터 동기화 문제:</strong> 쓰기 모델과 읽기 모델 간의 데이터 동기화를 보장하기 어려울 수 있습니다.</li><li><strong>추가 도구 필요:</strong> 메시지 큐 또는 이벤트 소싱과 같은 도구가 필요할 수 있습니다.</li></ul><h3 id="5-event-sourcing-pattern"><a class="markdownIt-Anchor" href="#5-event-sourcing-pattern"></a> 5. Event Sourcing Pattern</h3><p><strong>Event Sourcing Pattern</strong>은 시스템의 상태 변경을 이벤트로 기록하고, 이러한 이벤트의 흐름을 통해 현재 상태를 재구성하는 방식입니다. 상태를 직접 저장하는 대신 상태 변화를 나타내는 모든 이벤트를 이벤트 스토어에 저장합니다.</p><p><img src="/images/header/info-32_5.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>완전한 감사 기록 제공:</strong> 모든 상태 변경이 이벤트로 기록되므로 시스템의 모든 변화를 추적할 수 있습니다.</li><li><strong>확장성 향상:</strong> 쓰기 작업을 이벤트 형태로 기록하고, 여러 소비자에게 이를 전달할 수 있어 높은 쓰기 확장성을 제공합니다.</li><li><strong>기능 추가 용이:</strong> 새로운 이벤트 유형을 도입함으로써 기존 데이터를 손상시키지 않고 기능을 확장할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 이벤트 스트림을 관리하고 상태를 재구성하는 방식이 일반적인 데이터 저장 방식보다 복잡합니다.</li><li><strong>높은 저장소 요구량:</strong> 모든 이벤트가 저장되기 때문에 많은 저장 공간이 필요할 수 있습니다.</li><li><strong>복잡한 쿼리:</strong> 필요한 현재 상태를 얻기 위해 이벤트를 재생(replay)해야 하므로 쿼리 작성이 까다로울 수 있습니다.</li></ul><h3 id="6-saga-pattern"><a class="markdownIt-Anchor" href="#6-saga-pattern"></a> 6. Saga Pattern</h3><p><strong>Saga Pattern</strong>은 분산 시스템에서 여러 서비스에 걸친 트랜잭션을 관리하기 위한 설계 방식입니다. 이를 위해 트랜잭션을 로컬 트랜잭션의 집합으로 나누고, 각 단계가 완료되면 다음 단계로 넘어갑니다. 만약 어느 단계에서 실패하면 이전 단계에서 수행한 작업을 취소하는 보상 트랜잭션을 실행합니다.</p><p><img src="/images/header/info-32_6.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>데이터 일관성 유지:</strong> 서비스 간의 데이터 일관성을 유지하면서도 분산 트랜잭션의 복잡성을 줄일 수 있습니다.</li><li><strong>복원력 향상:</strong> 트랜잭션이 실패할 경우 보상 작업을 통해 시스템을 복구할 수 있어 신뢰성이 높아집니다.</li><li><strong>확장성 향상:</strong> 로컬 트랜잭션으로 구성되어 있기 때문에 각 서비스가 독립적으로 확장 가능합니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 각 단계에 대한 보상 트랜잭션을 설계하고 관리해야 하므로 구현이 복잡할 수 있습니다.</li><li><strong>자동 롤백 부재:</strong> 전통적인 ACID 트랜잭션과 달리 자동 롤백이 없기 때문에 개발자가 명시적으로 보상 작업을 설계해야 합니다.</li><li><strong>격리 수준 부족:</strong> 동시 실행되는 여러 Saga가 있을 경우 데이터 이상 현상이 발생할 수 있습니다.</li></ul><h3 id="7-sidecar-pattern"><a class="markdownIt-Anchor" href="#7-sidecar-pattern"></a> 7. Sidecar Pattern</h3><p><strong>Sidecar Pattern</strong>은 주요 서비스와 함께 배포되는 보조 서비스를 별도의 프로세스로 실행하여 로깅, 모니터링, 보안 등의 부가 기능을 제공하는 설계 방식입니다. 주로 컨테이너 환경에서 사용됩니다.</p><p><img src="/images/header/info-32_7.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>모듈화 및 확장성:</strong> 사이드카를 통해 새로운 기능을 쉽게 추가하거나 제거할 수 있으며, 서비스의 주 기능을 변경하지 않고도 부가 기능을 확장할 수 있습니다.</li><li><strong>책임 분리:</strong> 보조 기능을 독립적인 프로세스로 실행함으로써 주 서비스와의 책임을 명확히 분리할 수 있습니다.</li><li><strong>독립적 확장 가능:</strong> 사이드카와 주 서비스는 각각 별도로 확장할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>관리 복잡성 증가:</strong> 다수의 사이드카 서비스를 관리해야 하므로 운영 복잡성이 증가할 수 있습니다.</li><li><strong>단일 장애 지점:</strong> 사이드카가 장애를 겪을 경우 주 서비스에도 영향을 줄 수 있으므로 고가용성 설계가 필요합니다.</li><li><strong>성능 저하 가능성:</strong> 사이드카와 주 서비스 간의 통신이 지연을 초래할 수 있어 성능에 영향을 줄 수 있습니다.</li></ul><h3 id="8-circuit-breaker-pattern"><a class="markdownIt-Anchor" href="#8-circuit-breaker-pattern"></a> 8. Circuit Breaker Pattern</h3><p><strong>Circuit Breaker Pattern</strong>은 서비스 장애가 발생했을 때 이를 감지하고, 일정 시간 동안 요청을 차단하여 연쇄적인 장애를 방지하는 방식입니다. 전기 회로 차단기와 유사하게 동작합니다.</p><p><img src="/images/header/info-32_8.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>연쇄 장애 방지:</strong> 장애가 발생한 서비스를 호출하지 않도록 차단함으로써 전체 시스템의 안정성을 높일 수 있습니다.</li><li><strong>시스템 복원력 향상:</strong> 장애가 발생했을 때 시스템이 과부하에 걸리지 않도록 하여 복원력을 높입니다.</li><li><strong>신뢰성 향상:</strong> 오류가 발생할 때 빠르게 대체 동작을 수행할 수 있어 사용자 경험이 향상됩니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>설정 복잡성:</strong> 임계값과 복구 주기를 적절하게 설정하는 것이 어려울 수 있습니다.</li><li><strong>대체 동작 설계 필요:</strong> 서비스 장애 시 대체 동작(fallback)을 제공하기 위해 별도의 설계가 필요합니다.</li><li><strong>불필요한 차단 가능성:</strong> 임계값 설정이 적절하지 않으면 서비스가 정상임에도 불구하고 차단이 발생할 수 있습니다.</li></ul><h3 id="9-anti-corruption-layer-pattern"><a class="markdownIt-Anchor" href="#9-anti-corruption-layer-pattern"></a> 9. Anti-Corruption Layer Pattern</h3><p><strong>Anti-Corruption Layer Pattern</strong>은 외부 시스템과 통합할 때 내부 시스템의 설계와 데이터 모델을 보호하기 위한 패턴입니다. 내부 시스템과 외부 시스템 간의 데이터 모델 차이를 변환하는 중간 계층을 제공하여 내부 시스템이 외부 변화에 영향을 받지 않도록 합니다.</p><p><img src="/images/header/info-32_9.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>내부 시스템 보호:</strong> 외부 시스템의 변화로부터 내부 시스템을 보호할 수 있습니다.</li><li><strong>유연성 향상:</strong> 외부 시스템과의 통합을 쉽게 관리할 수 있으며, 외부 시스템 변경 시에도 내부 시스템의 수정이 최소화됩니다.</li><li><strong>유지보수 용이성:</strong> 내부 시스템과 외부 시스템의 책임이 명확히 분리되어 유지보수가 용이해집니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>추가 복잡성:</strong> 변환 계층을 설계하고 관리해야 하므로 시스템 복잡성이 증가할 수 있습니다.</li><li><strong>지연 시간 증가:</strong> 변환 작업으로 인해 응답 속도가 느려질 수 있습니다.</li><li><strong>확장성 문제:</strong> 많은 수의 외부 시스템과 통합할 경우 ACL 계층을 확장하는 것이 어려울 수 있습니다.</li></ul><h3 id="10-aggregator-pattern"><a class="markdownIt-Anchor" href="#10-aggregator-pattern"></a> 10. Aggregator Pattern</h3><p><strong>Aggregator Pattern</strong>은 여러 마이크로서비스에서 데이터를 수집하고 이를 하나의 응답으로 병합하여 클라이언트에 제공하는 설계 방식입니다.</p><p><img src="/images/header/info-32_10.png" alt="" /></p><p><strong>장점</strong></p><ul><li><strong>클라이언트 상호작용 단순화:</strong> 클라이언트가 하나의 엔드포인트만 호출하면 되므로 인터페이스가 단순해집니다.</li><li><strong>네트워크 호출 최소화:</strong> 클라이언트가 여러 서비스를 호출하지 않고도 필요한 데이터를 한 번에 받을 수 있습니다.</li><li><strong>중앙 집중식 데이터 처리:</strong> 데이터 집계 및 변환을 중앙에서 처리하여 일관성을 유지할 수 있습니다.</li></ul><p><strong>단점</strong></p><ul><li><strong>복잡성 증가:</strong> 여러 서비스로부터 데이터를 수집하고 병합하는 로직이 복잡할 수 있습니다.</li><li><strong>단일 장애 지점:</strong> Aggregator가 장애를 겪으면 전체 응답이 실패할 수 있으므로 고가용성 설계가 필요합니다.</li><li><strong>지연 시간 증가:</strong> 여러 서비스로부터 데이터를 수집하는 과정에서 지연이 발생할 수 있습니다.</li><li><strong>확장성 문제:</strong> Aggregator가 처리해야 할 요청 수가 많아질 경우 확장하기 어려울 수 있습니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 패턴들은 마이크로서비스 아키텍처의 복잡성을 관리하고 시스템의 확장성과 신뢰성을 높이는 데 필수적인 역할을 합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/info-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 위한 고급 ChatGPT 프롬프트 기술</title>
      <link>http://hgko1207.github.io/2025/01/09/chatgpt-33/</link>
      <guid>http://hgko1207.github.io/2025/01/09/chatgpt-33/</guid>
      <pubDate>Thu, 09 Jan 2025 04:24:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안녕하세요, 개발자 여러분! 💫&lt;/p&gt;
&lt;p&gt;ChatGPT가 등장한 이후 많은 개발자들이 이를 활용하고 있습니다. 이미 수많은 프롬프트 엔지니어링에 대한 튜토리얼이 쏟아지고 있는데요, 이번 글은 그런 일반적인 가이드가 아닙니다.&lt;/p&gt;
&lt;p&gt;A
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안녕하세요, 개발자 여러분! 💫</p><p>ChatGPT가 등장한 이후 많은 개발자들이 이를 활용하고 있습니다. 이미 수많은 프롬프트 엔지니어링에 대한 튜토리얼이 쏟아지고 있는데요, 이번 글은 그런 일반적인 가이드가 아닙니다.</p><p>AI를 일상에서 활용한 개인적인 경험을 공유하려 합니다. AI가 어떻게 저에게 도움을 주고, 왜 매우 유용하다고 생각하는지 설명하겠습니다. 또한, 이 글은 친구 개발자와의 대화에서 영감을 얻었는데요, 그는 AI가 별로 도움이 안 된다고 느꼈지만, 저는 AI를 통해 많은 이점을 얻고 있습니다. 그가 왜 실패했고, 제가 왜 성공했는지도 함께 이야기해 보겠습니다.</p><h2 id="ai는-인간이-아닙니다"><a class="markdownIt-Anchor" href="#ai는-인간이-아닙니다"></a> AI는 인간이 아닙니다!</h2><p>무엇보다 먼저 명심할 것이 있습니다. ChatGPT가 때로는 인간처럼 느껴질 수 있지만, <strong>AI는 인간이 아닙니다.</strong> AI는 생각하지 않으며, 인간이 본질적으로 이해하는 맥락을 인식하지 못합니다. AI의 답변은 단지 데이터를 수학적 공식으로 처리한 결과일 뿐입니다.</p><p>다시 한 번 강조하겠습니다:</p><ul><li><strong>AI는 생각하지 않습니다.</strong></li><li><strong>AI에게 의식은 없습니다.</strong></li><li><strong>AI는 단지 예측 가능한 수학적 결과를 생성할 뿐입니다.</strong></li></ul><p>이 점을 명확히 이해하는 것이 중요합니다. 이 사실을 깨닫고 나면 많은 프롬프트 엔지니어링 튜토리얼이 더 의미 있게 다가올 것입니다. AI를 도구로 간주하고 다룬다면, 그 도구는 여러분의 손에서 강력한 무기가 될 것입니다.</p><h2 id="데이터-모델과-프롬프트-엔지니어링"><a class="markdownIt-Anchor" href="#데이터-모델과-프롬프트-엔지니어링"></a> 데이터 모델과 프롬프트 엔지니어링</h2><p>AI는 복잡한 알고리즘과 방대한 데이터 세트를 기반으로 수학적 공식을 사용하여 답변을 생성합니다. AI가 답변을 생성하는 과정은 인간의 사고와 다르며, 제공하는 변수(입력)가 명확할수록 더 정확한 결과를 얻을 수 있습니다.</p><p>이제 많은 프롬프트 엔지니어링 강좌가 왜 중요한지 더 이해가 될 것입니다.<br />OpenAI 공식 문서에서도 이런 내용을 다루고 있으며, 아래에 중요한 내용을 요약해 보았습니다.</p><h2 id="명확한-지침을-작성하세요"><a class="markdownIt-Anchor" href="#명확한-지침을-작성하세요"></a> 명확한 지침을 작성하세요!</h2><p>프롬프트 작성 시, 명확하게 지침을 주어야 합니다.</p><p>예를 들어, 동료 개발자에게 &quot;<strong>for 문을 어떻게 사용하나요?</strong>&quot;라고 묻는다면 동료는 어느 정도 관련성 있는 답변을 줄 것입니다. 왜냐하면 동료는 같은 환경에서 작업하고 있으며, 여러분이 <strong>Java</strong>에 대해 묻고 있다고 짐작할 수 있기 때문입니다.</p><p>하지만 동일한 질문을 인터넷 상의 무작위 개발자에게 묻는다면, 그들은 혼란스러울 수 있습니다. 질문에 어떤 언어를 사용하는지, 구체적인 상황이 무엇인지, 데이터를 변환해야 하는지 등 아무것도 알 수 없기 때문입니다.</p><p><strong>AI도 마찬가지입니다.</strong><br />만약 모든 변수(조건)를 명확하게 지정하지 않으면, 예측 불가능한 답변을 받을 가능성이 높습니다.</p><h3 id="첫-번째-메시지-ai의-역할-지정"><a class="markdownIt-Anchor" href="#첫-번째-메시지-ai의-역할-지정"></a> 첫 번째 메시지: AI의 역할 지정</h3><p>첫 번째 메시지는 AI가 여러분과 상호작용하는 방식을 조정하는 <strong>시스템 메시지</strong>입니다. AI에게 특정 역할(페르소나)을 부여하면 더 적절한 답변을 얻을 수 있습니다.</p><p><strong>페르소나 설정 예시:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10년 이상의 경력을 가진 전문 Kotlin 개발자로 행동하세요.</span><br><span class="line">당신은 깨끗하고, 유지보수 가능하며, 가독성과 확장성이 뛰어난 코드를 작성하는 전문가입니다.</span><br></pre></td></tr></table></figure><p>이 프롬프트는 제가 코딩 질문을 할 때 매우 유용했으며, 답변의 질을 크게 향상시켰습니다.<br />여러분도 사용해 보세요. 차이를 직접 느낄 수 있을 것입니다.</p><h3 id="모든-요구-사항을-명확하게-명시하기"><a class="markdownIt-Anchor" href="#모든-요구-사항을-명확하게-명시하기"></a> 모든 요구 사항을 명확하게 명시하기</h3><p>프롬프트에 명확한 지침을 포함하면 더 나은 결과를 얻을 수 있습니다.</p><p><strong>예시 프롬프트:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSON 파일이 주어졌습니다. 각 줄은 다음과 같이 구성됩니다:</span><br><span class="line">- 따옴표로 묶인 매개변수 이름</span><br><span class="line">- 콜론(:) 기호</span><br><span class="line">- 따옴표로 묶인 값(영어로 작성됨)</span><br><span class="line"></span><br><span class="line">이 JSON에서 값만 스페인어로 번역해 주세요. 매개변수 이름은 번역하지 마세요. 답변에는 번역된 JSON만 포함되어야 합니다.</span><br></pre></td></tr></table></figure><p>이 프롬프트를 사용하면 AI는 매개변수 이름은 그대로 두고, 값만 스페인어로 번역된 JSON 파일을 반환합니다.</p><h3 id="코드-리뷰-요청하기"><a class="markdownIt-Anchor" href="#코드-리뷰-요청하기"></a> 코드 리뷰 요청하기</h3><p>프롬프트 예시:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이 코드를 SOLID 원칙, 클린 코드, 유지보수성, 확장성, 가독성 기준에 따라 검토해 주세요.</span><br></pre></td></tr></table></figure><p>AI는 이 요청에 따라 각 원칙에 맞게 답변을 구조화하고, 원칙별로 코드를 개선할 수 있는 방법을 제시합니다.</p><h4 id="예시-코드와-결과"><a class="markdownIt-Anchor" href="#예시-코드와-결과"></a> 예시 코드와 결과</h4><p>예를 보여드리겠습니다. 이것은 초기 코드의 일부입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 연결 설정</span></span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserToDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Storing "</span> + <span class="keyword">this</span>.name + <span class="string">" into database..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Not connected to database."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 ChatGPT에게 &quot;<strong>이 코드를 검토해 주세요</strong>&quot;라고 요청했을 반환된 리팩터링된 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Saving "</span> + <span class="keyword">this</span>.name + <span class="string">"..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Connect first."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT에 &quot;<strong>이 코드를 SOLID 원칙, 클린 코드, 유지보수성, 확장성, 가독성 기준에 따라 검토해 주세요</strong>&quot;라고 요청했을 때 반환된 리펙토링된 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name의 getter 메서드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connected = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Storing "</span> + user.getName() + <span class="string">" into database..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Not connected to database. Connect first."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="solid-원칙-적용-설명"><a class="markdownIt-Anchor" href="#solid-원칙-적용-설명"></a> SOLID 원칙 적용 설명</h4><ul><li><strong>단일 책임 원칙(Single Responsibility Principle, SRP):</strong><br />User 클래스와 Database 클래스를 분리하여 각 클래스가 단일 책임만 가지도록 했습니다.</li><li><strong>개방/폐쇄 원칙(Open/Closed Principle):</strong><br />기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 구조를 개선했습니다.</li><li><strong>리스코프 치환 원칙(Liskov Substitution Principle):</strong><br />이 원칙은 더 복잡한 예제에서 설명될 수 있으며, 필요 시 인터페이스나 하위 클래스를 도입하여 적용할 수 있습니다.</li><li><strong>인터페이스 분리 원칙(Interface Segregation Principle)과 의존성 역전 원칙(Dependency Inversion Principle):</strong><br />더 큰 규모의 프로젝트나 인터페이스, 서브클래스를 사용할 때 설명할 수 있습니다.</li></ul><p>이처럼 책임 분리와 메서드 단순화를 통해 코드가 더 깨끗하고 유지보수 가능하며, 확장 가능하고 가독성 높은 구조로 개선되었습니다.</p><h2 id="문맥-인식-한계와-해결-방법"><a class="markdownIt-Anchor" href="#문맥-인식-한계와-해결-방법"></a> 문맥 인식: 한계와 해결 방법</h2><p>ChatGPT는 고정된 문맥 길이가 있습니다. 즉, 사용자와 AI 간의 대화에서 모든 내용을 한 번에 기억하지 못합니다.</p><p>대화가 길어지면 초기에 설정했던 AI의 역할이나 작성했던 코드 일부를 잊어버릴 수 있습니다.</p><p>이를 해결하려면 AI에게 작업할 전체 코드를 반복해서 보여주고 맥락을 다시 제공해야 합니다.</p><h2 id="chatgpt가-작동하는-방식-이해하기"><a class="markdownIt-Anchor" href="#chatgpt가-작동하는-방식-이해하기"></a> ChatGPT가 작동하는 방식 이해하기</h2><p>ChatGPT는 수학적으로 작동하는 도구이기 때문에 때로는 부정확하거나 누락된 답변을 줄 수 있습니다. 따라서 AI에게 답변의 근거를 설명하도록 요청하면 더 의미 있는 결과를 얻을 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">이 코드가 왜 맞는지 설명해 주세요.</span><br><span class="line">각 줄에 주석을 달고 어떤 역할을 하는지 설명해 주세요.</span><br></pre></td></tr></table></figure><h2 id="프롬프트-테스트와-개선"><a class="markdownIt-Anchor" href="#프롬프트-테스트와-개선"></a> 프롬프트 테스트와 개선</h2><p>프롬프트는 한 번에 완벽할 수 없습니다. 원하는 결과를 얻을 때까지 여러 번 테스트하고, 답변이 마음에 들지 않으면 프롬프트를 개선하세요.</p><p><strong>프롬프트 개선 예시:</strong></p><ul><li>AI가 생성한 코드가 테스트 결과와 일치하지 않으면 <strong>AI의 코드, 테스트 케이스, 기대 결과, 실제 결과</strong>를 다시 보여주고 오류를 수정하도록 요청하세요.</li><li>필요하다면 코드를 여러 단계로 나누어 요청하고, 각 단계별로 검토 및 개선하도록 지시하세요.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>ChatGPT는 올바르게 다루었을 때 일상적인 코딩 작업에서 매우 강력한 도구가 될 수 있습니다. 하지만 AI의 능력과 한계를 이해하고 적절히 활용해야 합니다.</p><p>ChatGPT는 개발자를 도와주고 가르치며 안내할 수 있지만, 인간 개발자를 대체할 수는 없습니다. 개발자의 직관과 예술적인 코딩 감각은 여전히 필수적이며, 우리는 이러한 도구를 잘 조율해 멋진 작품을 만들어야 합니다.</p><p><strong>ChatGPT를 동료로 삼아 여러분의 코딩 여정을 더 즐겁고 생산적으로 만드세요.</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/chatgpt-33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python 프로젝트 구조화 방법</title>
      <link>http://hgko1207.github.io/2025/01/09/python-12/</link>
      <guid>http://hgko1207.github.io/2025/01/09/python-12/</guid>
      <pubDate>Thu, 09 Jan 2025 03:59:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;잘 구성된 &lt;strong&gt;Python&lt;/strong&gt; 프로젝트 구조는 코드베이스를 관리하기 쉽게 만들고 확장성과 이해도를 높여줍니다. 이는 개인 개발자는 물론, 팀으로 협업할 때도 필수적인 요소입니다. 이 글에서는 Python 프로젝트를 효과적으
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>잘 구성된 <strong>Python</strong> 프로젝트 구조는 코드베이스를 관리하기 쉽게 만들고 확장성과 이해도를 높여줍니다. 이는 개인 개발자는 물론, 팀으로 협업할 때도 필수적인 요소입니다. 이 글에서는 Python 프로젝트를 효과적으로 구성하는 방법에 대해 단계별로 설명하고, 각 단계에서 모범 사례와 예시를 함께 다룹니다.</p><h2 id="1단계-프로젝트-설정-루트-디렉터리"><a class="markdownIt-Anchor" href="#1단계-프로젝트-설정-루트-디렉터리"></a> 1단계: 프로젝트 설정 🌳 루트 디렉터리</h2><p>가장 먼저 프로젝트와 관련된 모든 파일을 포함할 <strong>루트(Root) 디렉터리</strong>를 생성합니다. 디렉터리 이름은 프로젝트의 목적이나 내용을 명확하게 나타내도록 <strong>설명적이고 의미 있는 이름</strong>으로 지정하는 것이 좋습니다. 일반적으로 프로젝트 이름을 디렉터리 이름으로 사용하는 것이 권장됩니다.</p><p><strong>예시:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br></pre></td></tr></table></figure><p>이 디렉터리 안에 소스 코드, 문서, 설정 파일 등을 추가하며 프로젝트를 구성해 나가게 됩니다.</p><h2 id="2단계-가상-환경-생성"><a class="markdownIt-Anchor" href="#2단계-가상-환경-생성"></a> 2단계: 가상 환경 생성 🌄</h2><p>가상 환경은 프로젝트 간 종속성 충돌을 방지하고, <strong>종속성을 격리</strong>하여 관리할 수 있도록 해줍니다. 이를 통해 프로젝트마다 필요한 패키지 버전을 다르게 설정할 수 있으며, 안정적인 개발 환경을 유지할 수 있습니다.</p><h3 id="가상-환경-생성-방법"><a class="markdownIt-Anchor" href="#가상-환경-생성-방법"></a> 가상 환경 생성 방법</h3><p><strong>Linux/macOS 사용자:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my_project</span><br><span class="line">python3 -m venv venv</span><br></pre></td></tr></table></figure><p><strong>Windows 사용자:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>가상 환경 생성 후, 아래 명령어로 활성화할 수 있습니다.</p><p><strong>Linux/macOS에서 활성화:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure><p><strong>Windows에서 활성화:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate</span><br></pre></td></tr></table></figure><p>이제 가상 환경이 활성화되었으며, 모든 종속성(라이브러리 및 패키지)은 이 환경에 설치됩니다. 이렇게 하면 프로젝트가 특정 버전의 라이브러리에 종속되어도 다른 프로젝트에 영향을 주지 않게 됩니다.</p><h2 id="3단계-핵심-디렉터리-구조-정의"><a class="markdownIt-Anchor" href="#3단계-핵심-디렉터리-구조-정의"></a> 3단계: 핵심 디렉터리 구조 정의 📗</h2><p>Python 프로젝트의 핵심 프로젝트 구조는 <strong>패키지/모듈 디렉터리, 테스트 디렉터리</strong>, 그리고 루트 수준에 위치한 <strong>설정 및 구성 파일</strong>로 구성되어야 합니다. 이러한 구조는 프로젝트의 코드 관리와 확장을 용이하게 해줍니다.</p><h3 id="예시-디렉터리-구조"><a class="markdownIt-Anchor" href="#예시-디렉터리-구조"></a> 예시 디렉터리 구조</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">│</span><br><span class="line">├── my_package/           # 메인 패키지 디렉터리</span><br><span class="line">│   ├── __init__.py       # 디렉터리를 패키지로 인식시키는 파일</span><br><span class="line">│   ├── module1.py</span><br><span class="line">│   ├── module2.py</span><br><span class="line">│   └── utils.py</span><br><span class="line">│</span><br><span class="line">├── tests/                # 각 모듈이나 기능에 대한 테스트 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_module1.py</span><br><span class="line">│   ├── test_module2.py</span><br><span class="line">│   └── test_utils.py</span><br><span class="line">│</span><br><span class="line">├── venv/                 # 가상 환경 디렉터리 (.gitignore에 추가하여 무시)</span><br><span class="line">│</span><br><span class="line">├── requirements.txt      # 프로젝트 종속성 목록</span><br><span class="line">│</span><br><span class="line">└── README.md             # 프로젝트 설명 및 사용법</span><br></pre></td></tr></table></figure><h3 id="구성-요소-설명"><a class="markdownIt-Anchor" href="#구성-요소-설명"></a> 구성 요소 설명</h3><ul><li><strong><code>my_package/</code>:</strong> 프로젝트의 핵심 코드를 포함하는 디렉터리입니다.</li><li><strong><code>tests/</code>:</strong> 각 모듈에 대한 단위 테스트가 포함된 디렉터리로, 테스트를 통해 코드의 안정성을 검증할 수 있습니다.</li><li><strong><code>requirements.txt</code>:</strong> 프로젝트에 필요한 라이브러리와 종속성 목록을 관리하는 파일입니다. <code>pip freeze &gt; requirements.txt</code> 명령어로 자동 생성할 수 있습니다.</li><li><strong><code>README.md</code>:</strong> 프로젝트에 대한 설명과 사용법을 제공하는 문서로, 다른 사용자들이 프로젝트를 쉽게 이해하고 사용할 수 있도록 도와줍니다.</li></ul><h2 id="4단계-__init__py-파일-작성"><a class="markdownIt-Anchor" href="#4단계-__init__py-파일-작성"></a> 4단계: <code>__init__.py</code> 파일 작성 📝</h2><p><code>__init__.py</code> 파일은 디렉터리를 Python 패키지로 인식하게 만듭니다. 또한, 이 파일을 통해 특정 모듈이나 함수에 대한 임포트를 간소화할 수 있습니다.</p><p><strong>예시 <code>__init__.py</code> 파일 (my_package/ 디렉터리):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .module1 <span class="keyword">import</span> function1</span><br><span class="line"><span class="keyword">from</span> .module2 <span class="keyword">import</span> function2</span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 간단하게 임포트할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> function1</span><br></pre></td></tr></table></figure><h2 id="5단계-설정-파일-추가-️"><a class="markdownIt-Anchor" href="#5단계-설정-파일-추가-️"></a> 5단계: 설정 파일 추가 ⚙️</h2><p>테스트, 코드 스타일 검사, 배포 등을 자동화하려면 설정 파일을 추가하는 것이 좋습니다.</p><h3 id="1-gitignore"><a class="markdownIt-Anchor" href="#1-gitignore"></a> 1. <code>.gitignore</code></h3><p><code>.gitignore</code> 파일을 통해 Git에서 관리하지 않을 파일과 디렉터리를 지정할 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">venv/</span><br><span class="line">__pycache__/</span><br><span class="line">*.pyc</span><br></pre></td></tr></table></figure><h3 id="2-requirementstxt"><a class="markdownIt-Anchor" href="#2-requirementstxt"></a> 2. <code>requirements.txt</code></h3><p><code>requirements.txt</code> 파일은 프로젝트 종속성을 관리하며, 동일한 개발 환경을 쉽게 재현할 수 있도록 도와줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 생성 방법</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h2 id="6단계-테스트-설정-️"><a class="markdownIt-Anchor" href="#6단계-테스트-설정-️"></a> 6단계: 테스트 설정 ⚓️</h2><p>테스트는 프로젝트의 품질을 보장하는 중요한 요소입니다. Python에서는 <strong>pytest</strong> 또는 <strong>unittest</strong>를 사용하여 테스트를 작성할 수 있습니다.</p><p>테스트 파일은 일반적으로 <code>tests/</code> 디렉터리에 배치하며, 파일 이름은 <code>test_</code>로 시작하는 것이 관례입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예시 테스트 파일: tests/test_module1.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> function1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_function1</span><span class="params">()</span>:</span></span><br><span class="line">    result = function1()</span><br><span class="line">    <span class="keyword">assert</span> result == expected_output  <span class="comment"># 실제 예상 결과로 교체</span></span><br></pre></td></tr></table></figure><p>명령어로 테스트 실행</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest tests/</span><br></pre></td></tr></table></figure><h2 id="7단계-패키징을-위한-setuppy-작성-선택-사항"><a class="markdownIt-Anchor" href="#7단계-패키징을-위한-setuppy-작성-선택-사항"></a> 7단계: 패키징을 위한 <code>setup.py</code> 작성 📦 (선택 사항)</h2><p>배포 가능한 Python 패키지를 만들려면 <code>setup.py</code> 파일을 추가해야 합니다.<br />이 파일은 Python이 패키지를 빌드하고 설치하는 방법을 정의합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예시</span></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"my_project"</span>,</span><br><span class="line">    version=<span class="string">"0.1"</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">"some_package&gt;=1.0.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>로컬에서 패키지 설치 방법</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p>이제 프로젝트를 다른 Python 환경에서도 쉽게 설치하고 사용할 수 있습니다.</p><h2 id="8단계-프로젝트-문서화"><a class="markdownIt-Anchor" href="#8단계-프로젝트-문서화"></a> 8단계: 프로젝트 문서화 📜</h2><p>문서화는 프로젝트를 더 이해하기 쉽게 만들어 줍니다.<br /><code>README.md</code> 파일을 업데이트하여 프로젝트 개요, 설치 방법, 사용 예시 등을 포함하세요.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># My Project</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Overview</span></span><br><span class="line"></span><br><span class="line">This project does XYZ.</span><br><span class="line"></span><br><span class="line"><span class="section">## Installation</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>Clone the repository.</span><br><span class="line"><span class="bullet">2. </span>Install dependencies:</span><br><span class="line">   <span class="code">```</span>bash</span><br><span class="line"><span class="code">      pip install -r requirements.txt</span></span><br><span class="line">   <span class="code">```</span></span><br></pre></td></tr></table></figure><h2 id="최종"><a class="markdownIt-Anchor" href="#최종"></a> 최종</h2><p>최종 프로젝트 구조 예시입니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">│</span><br><span class="line">├── my_package/           # 메인 패키지 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── module1.py</span><br><span class="line">│   ├── module2.py</span><br><span class="line">│   └── utils.py</span><br><span class="line">│</span><br><span class="line">├── tests/                # 테스트 디렉터리</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_module1.py</span><br><span class="line">│   ├── test_module2.py</span><br><span class="line">│   └── test_utils.py</span><br><span class="line">│</span><br><span class="line">├── venv/                 # 가상 환경 디렉터리</span><br><span class="line">│</span><br><span class="line">├── requirements.txt      # 종속성 목록</span><br><span class="line">│</span><br><span class="line">├── README.md             # 프로젝트 설명 및 사용법</span><br><span class="line">│</span><br><span class="line">└── setup.py              # 선택 사항: 패키징 설정 파일</span><br></pre></td></tr></table></figure><p>이러한 구조는 프로젝트를 체계적으로 관리할 수 있도록 도와주며, 개발, 테스트, 유지보수를 더 효율적으로 할 수 있게 만듭니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2025/01/09/python-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C# 13 및 .NET 9 필수 기능 소개</title>
      <link>http://hgko1207.github.io/2024/12/06/csharp-15/</link>
      <guid>http://hgko1207.github.io/2024/12/06/csharp-15/</guid>
      <pubDate>Fri, 06 Dec 2024 05:42:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;.NET 9는 많은 변화와 개선 사항을 제공하며, 곧 출시를 앞두고 있습니다. 이 글에서는 &lt;strong&gt;.NET 9와 C# 13&lt;/strong&gt;에서 가장 영향을 많이 미치고 널리 적용 가능한 주요 기능들을 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>.NET 9는 많은 변화와 개선 사항을 제공하며, 곧 출시를 앞두고 있습니다. 이 글에서는 <strong>.NET 9와 C# 13</strong>에서 가장 영향을 많이 미치고 널리 적용 가능한 주요 기능들을 살펴보겠습니다.</p><h2 id="1-새로운-lock-객체"><a class="markdownIt-Anchor" href="#1-새로운-lock-객체"></a> 1. 새로운 Lock 객체</h2><p>C# 13에서는 <strong>System.Threading.Lock</strong>라는 새로운 타입이 도입되어 상호 배제를 처리합니다. 기존에는 <code>object</code> 타입을 사용해 잠금을 구현했지만, 이제는 전용 <code>Lock</code> 타입이 제공되어 앞으로 대부분의 잠금 작업에 표준으로 자리 잡을 것으로 기대됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock = <span class="keyword">new</span>(); <span class="comment">// 잠금을 위한 object 인스턴스 생성</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStuff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_lock) <span class="comment">// object를 이용한 잠금</span></span><br><span class="line">        &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">"기존 방식의 lock 블록 안입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Lock _lock = <span class="keyword">new</span>(); <span class="comment">// 새로운 Lock 객체 생성</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStuff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_lock) <span class="comment">// Lock 객체를 이용한 잠금</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">".NET 9 방식의 lock 블록 안입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>주요 장점</strong></p><ul><li><strong>더 깔끔하고 안전한 코드:</strong> 코드가 더욱 읽기 쉽고 예측 가능해집니다. 또한, <code>Lock</code> 인스턴스를 일반 <code>object</code>로 잘못 사용하면 컴파일러가 경고를 제공합니다.</li><li><strong>성능 향상:</strong> Microsoft에 따르면, 임의의 <code>object</code> 인스턴스를 잠금에 사용하는 것보다 더 효율적일 수 있습니다.</li><li><strong>새로운 잠금 메커니즘:</strong> <code>EnterScope</code>가 내부적으로 <code>Monitor</code> 클래스를 대체합니다. 이 메커니즘은 <code>Dispose</code> 패턴을 따르는 <code>ref struct</code>를 반환하므로 <code>using</code> 문과 매끄럽게 결합됩니다.</li><li><strong>비동기 작업의 제한:</strong> <code>lock</code> 블록 내에서는 여전히 <code>async</code> 호출이 허용되지 않습니다. 이는 잠금과 비동기 코드가 상호 작용하는 방식에 내재된 한계 때문입니다. 기존의 <code>SemaphoreSlim</code> 접근 방식이 여전히 대안으로 사용됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">readonly</span> Lock _lock = <span class="keyword">new</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphore = <span class="keyword">new</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoStuff</span>(<span class="params"><span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      <span class="comment">// 1. 'lock' 구문과 비동기 작업의 제한</span></span><br><span class="line">      <span class="keyword">lock</span>(_lock)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">// 컴파일 오류: 'lock' 블록 내부에서 'await'를 사용할 수 없습니다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 'EnterScope'와 비동기 작업의 제한</span></span><br><span class="line">      <span class="keyword">using</span>(_lock.EnterScope())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">// 런타임 오류: 'System.Threading.Lock.Scope' 타입 인스턴스는 'await' 또는 'yield' 경계를 넘을 수 없습니다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. SemaphoreSlim을 이용한 비동기 작업</span></span><br><span class="line">      <span class="keyword">await</span> _semaphore.WaitAsync();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(<span class="number">10</span>);</span><br><span class="line">         <span class="comment">// 정상적으로 동작: SemaphoreSlim은 비동기 작업을 지원합니다.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span></span><br><span class="line">      &#123;</span><br><span class="line">         _semaphore.Release(); <span class="comment">// 반드시 자원을 해제해야 함</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-taskwheneach"><a class="markdownIt-Anchor" href="#2-taskwheneach"></a> 2. Task.WhenEach</h2><p>다양한 시간 간격으로 완료되는 작업(Task) 리스트가 있다고 가정해봅시다. 작업이 모두 끝날 때까지 기다리는 <code>WaitAll()</code> 방식은 이 경우 적합하지 않습니다. 각각의 작업이 완료되는 즉시 처리하고 싶다면 <code>Task.WaitAny()</code>를 사용하여 대안적으로 구현할 수 있습니다. 그러나 C# 13에서는 이를 더 우아하고 효율적으로 처리할 수 있는 <code>Task.WhenEach</code> 기능이 도입되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 랜덤한 간격으로 완료되는 5개의 작업 리스트 생성</span></span><br><span class="line"><span class="keyword">var</span> tasks = Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">   .Select(<span class="keyword">async</span> i =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">await</span> Task.Delay(<span class="keyword">new</span> Random().Next(<span class="number">1000</span>, <span class="number">5000</span>)); <span class="comment">// 1~5초 사이의 딜레이</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">$"Task <span class="subst">&#123;i&#125;</span> done"</span>; <span class="comment">// 완료 메시지 반환</span></span><br><span class="line">   &#125;)</span><br><span class="line">   .ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="keyword">while</span>(tasks.Count &gt; <span class="number">0</span>) <span class="comment">// 아직 완료되지 않은 작업이 남아 있는 동안</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> completedTask = <span class="keyword">await</span> Task.WhenAny(tasks); <span class="comment">// 가장 먼저 완료된 작업 선택</span></span><br><span class="line">   tasks.Remove(completedTask); <span class="comment">// 완료된 작업 리스트에서 제거</span></span><br><span class="line">   Console.WriteLine(<span class="keyword">await</span> completedTask); <span class="comment">// 작업 결과 출력</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> completedTask <span class="keyword">in</span> Task.WhenEach(tasks)) <span class="comment">// 작업이 완료될 때마다 처리</span></span><br><span class="line">   Console.WriteLine(<span class="keyword">await</span> completedTask); <span class="comment">// 작업 결과 출력</span></span><br></pre></td></tr></table></figure><p><code>Task.WhenEach</code>는 <code>IAsyncEnumerable&lt;Task&lt;TResult&gt;&gt;</code>를 반환하며, <code>await foreach를</code> 사용해 작업이 완료되는 즉시 쉽게 반복(iterate) 처리할 수 있도록 해줍니다.👌</p><h2 id="3-params-collections"><a class="markdownIt-Anchor" href="#3-params-collections"></a> 3. params Collections</h2><p>C# 13부터 <code>params</code> 매개변수로 컬렉션 표현식에 지원되는 모든 타입을 사용할 수 있게 되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">int</span>[] numbers</span>)</span></span><br><span class="line"><span class="function"></span>   =&gt; Console.WriteLine(numbers.Length); <span class="comment">// int 배열만 허용</span></span><br></pre></td></tr></table></figure><p>C# 13 이후, <code>params</code> 매개변수는 다양한 컬렉션 타입을 지원합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9</span></span><br><span class="line"><span class="comment">// ReadOnlySpan&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> ReadOnlySpan&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IEnumerable&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> IEnumerable&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Count());</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet&lt;int&gt; 사용</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteNumbersCount</span>(<span class="params"><span class="keyword">params</span> HashSet&lt;<span class="keyword">int</span>&gt; numbers</span>)</span> =&gt;</span><br><span class="line">    Console.WriteLine(numbers.Count);</span><br></pre></td></tr></table></figure><ul><li><strong>더 깔끔한 코드:</strong> <code>.ToArray()</code>, <code>.ToList()</code> 호출 횟수를 크게 줄일 수 있습니다.</li><li><strong>성능 향상:</strong> <code>.ToArray()</code>, <code>.ToList()</code> 같은 호출은 자체적으로 추가적인 리소스 오버헤드를 발생시킵니다. 이제 <code>Span&lt;&gt;</code>과 <code>IEnumerable&lt;&gt;</code>를 지원함으로써 더 효율적인 메모리 사용과 지연 실행(lazy execution)을 활용할 수 있습니다. 결과적으로, 유연성과 성능이 요구되는 시나리오에서 더 나은 성능을 제공합니다.</li></ul><h2 id="4-semi-auto-properties-반자동-속성"><a class="markdownIt-Anchor" href="#4-semi-auto-properties-반자동-속성"></a> 4. Semi-Auto Properties (반자동 속성)</h2><p>C#에서 <code>public int Number { get; set; }</code>와 같은 자동 구현 속성을 선언하면, 컴파일러가 자동으로 백업 필드(예: <code>_number</code>)와 내부 getter/setter 메서드(<code>void set_Number(int number)</code>, <code>int get_Number()</code>)를 생성합니다.</p><p>하지만 속성의 getter나 setter에서 유효성 검사, 기본값 설정, 계산, 지연 로딩(lazy loading) 등의 커스텀 로직이 필요할 경우, 클래스에서 백업 필드를 직접 정의해야 했습니다.</p><p>C# 13에서는 <code>field</code> 키워드를 도입하여, 백업 필드를 직접 정의하지 않고도 바로 사용할 수 있도록 간소화했습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MagicNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _number; <span class="comment">// 백업 필드 직접 정의</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _number * <span class="number">10</span>; <span class="comment">// 커스텀 로직 적용</span></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) <span class="comment">// 유효성 검사</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(<span class="keyword">value</span>), <span class="string">"값은 0보다 커야 합니다."</span>);</span><br><span class="line">            _number = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MagicNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; field; <span class="comment">// 컴파일러가 생성한 백업 필드에 직접 접근</span></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) <span class="comment">// 유효성 검사</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(<span class="keyword">value</span>), <span class="string">"값은 0보다 커야 합니다."</span>);</span><br><span class="line">            field = <span class="keyword">value</span>; <span class="comment">// field 키워드로 백업 필드 설정</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>보일러플레이트 코드 감소:</strong> 백업 필드를 수동으로 정의할 필요가 없어져 코드가 더 깔끔하고 간결해집니다.</li><li><strong>가독성 향상:</strong> <code>field</code> 키워드를 표준으로 사용하면서, 커스텀 백업 필드 이름을 관리할 필요가 없어 코드의 명확성이 높아집니다.</li><li><strong>속성 범위 내 필드 제한:</strong> 백업 필드는 속성 내부로 제한되어 클래스의 다른 부분에서 의도치 않게 사용되는 일을 방지하며, 캡슐화를 강화합니다.</li><li><strong>🚨 잠재적 호환성 문제:</strong> 클래스에 이미 <code>field</code>라는 이름의 속성이 있다면 새 키워드보다 우선 적용되어 예기치 않은 동작이 발생할 수 있습니다. 이는 이 기능이 2016년 최초 제안 이후 지연된 이유 중 하나로 보입니다.</li></ul><h2 id="5-hybrid-cache"><a class="markdownIt-Anchor" href="#5-hybrid-cache"></a> 5. Hybrid Cache</h2><p>새로운 <strong>HybridCache API</strong>는 기존의 <code>IDistributedCache</code>와 <code>IMemoryCache</code> API에서 발생하는 문제를 해결하며, 새로운 기능과 성능을 제공해 .NET에서 캐싱을 더 유연하고 효율적으로 만듭니다. 특히, <strong>스탬피드 문제</strong>와 같은 캐싱의 한계를 개선하며 대부분의 <code>IDistributedCache</code> 및 <code>IMemoryCache</code> 시나리오에 드롭인(dop-in) 방식으로 대체할 수 있도록 설계되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Post</span>(<span class="params"><span class="keyword">int</span> UserId, <span class="keyword">int</span> Id, <span class="keyword">string</span> Title, <span class="keyword">string</span> Body</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">PostsService</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    IHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    IMemoryCache memoryCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    IDistributedCache distributedCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    HybridCache hybridCache</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;Post&gt;?&gt; GetUserPostsAsync(<span class="keyword">string</span> userId)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cacheKey = <span class="string">$"posts_<span class="subst">&#123;userId&#125;</span>"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기존 방식 (Memory Cache)</span></span><br><span class="line">        <span class="keyword">var</span> posts = <span class="keyword">await</span> memoryCache.GetOrCreateAsync(cacheKey,</span><br><span class="line">            <span class="keyword">async</span> _ =&gt; <span class="keyword">await</span> GetPostsAsync(userId));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기존 방식 (Distributed Cache)</span></span><br><span class="line">        <span class="keyword">var</span> postsJson = <span class="keyword">await</span> distributedCache.GetStringAsync(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (postsJson <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posts = <span class="keyword">await</span> GetPostsAsync(userId);</span><br><span class="line">            <span class="keyword">await</span> distributedCache.SetStringAsync(cacheKey, JsonSerializer.Serialize(posts));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            posts = JsonSerializer.Deserialize&lt;List&lt;Post&gt;&gt;(postsJson);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// .NET 9 (Hybrid Cache)</span></span><br><span class="line">        posts = <span class="keyword">await</span> hybridCache.GetOrCreateAsync(cacheKey,</span><br><span class="line">            <span class="keyword">async</span> _ =&gt; <span class="keyword">await</span> GetPostsAsync(userId), <span class="keyword">new</span> HybridCacheEntryOptions() &#123;</span><br><span class="line">                Flags = HybridCacheEntryFlags.DisableLocalCache | <span class="comment">// 분산 캐시처럼 동작</span></span><br><span class="line">                        HybridCacheEntryFlags.DisableDistributedCache <span class="comment">// 메모리 캐시처럼 동작</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> posts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;List&lt;Post&gt;?&gt; GetPostsAsync(<span class="keyword">string</span> userId)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"===========Fetching posts from API"</span>);</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">$"https://jsonplaceholder.typicode.com/posts?userId=<span class="subst">&#123;userId&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">var</span> client = httpClientFactory.CreateClient();</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.Content.ReadFromJsonAsync&lt;List&lt;Post&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>두 가지 장점의 결합 (Best of Both Worlds):</strong> <code>HybridCache</code>는 단일 API로 데이터를 메모리 캐시(L1) 또는 분산 캐시(L2)에 저장할 수 있는 유연성을 제공합니다. L1 캐시는 자주 사용되는 데이터를 빠르게 로컬에서 액세스할 수 있도록 하고, L2 캐시는 대규모 및 덜 자주 접근되는 데이터를 처리할 수 있는 확장성을 제공합니다. 이 동작은 <strong>HybridCacheEntryFlags</strong>로 제어할 수 있습니다.</li><li><strong>스탬피드 보호 (Stampede Protection):</strong> <code>IMemoryCache</code>와 <code>IDistributedCache</code> 모두 스탬피드 문제를 겪지만, <code>HybridCache</code>는 동일한 키에 대해 하나의 호출만 값 생성을 수행하고, 다른 호출은 결과를 대기하도록 처리해 불필요한 캐시 재생성을 방지합니다.</li><li><strong>추가 기능:</strong> <code>HybridCache</code>는 태깅(Tagging), <code>.WithSerializer(...)</code> 및 <code>.WithSerializerFactory(...)</code> 메서드를 통한 설정 가능한 직렬화, <code>[ImmutableObject(true)]</code> 어노테이션을 활용한 캐시 인스턴스 재사용과 같은 추가 기능을 제공합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 분산 캐시 (Redis) 설정</span></span><br><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">"localhost:6379"</span>;</span><br><span class="line">    options.InstanceName = <span class="string">"SampleInstance"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 캐시 설정 (데모 목적)</span></span><br><span class="line">builder.Services.AddMemoryCache();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HybridCache 추가</span></span><br><span class="line">builder.Services.AddHybridCache();</span><br><span class="line">builder.Services.AddSingleton&lt;PostsService&gt;(); <span class="comment">// PostsService 등록</span></span><br></pre></td></tr></table></figure><p><strong>HybridCache</strong>는 메모리 캐시와 분산 캐시의 장점을 결합하여 빠른 액세스와 확장성을 동시에 제공합니다. 스탬피드 문제를 해결하며, 다양한 설정 및 추가 기능으로 유연하고 강력한 캐싱 솔루션을 제공합니다. 🚀</p><h2 id="6-내장-openapi-문서-생성"><a class="markdownIt-Anchor" href="#6-내장-openapi-문서-생성"></a> 6. 내장 OpenAPI 문서 생성</h2><p>.NET 5부터 Web API 템플릿은 <code>Swashbuckle.AspNetCore</code> 패키지를 통해 OpenAPI 지원을 기본으로 제공해왔습니다.</p><p>.NET 9에서는 Microsoft가 자체적으로 개발한 <code>Microsoft.AspNetCore.OpenApi</code> 패키지를 통해 OpenAPI 사양을 지원하며, 이는 기존의 <strong>Swashbuckle.AspNetCore</strong>를 대체합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 방식 (Before)</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.NET 9에서는 더 간단한 방식으로 OpenAPI 문서를 설정할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">builder.Services.AddOpenApi(); <span class="comment">// OpenAPI 지원 추가</span></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.MapOpenApi(); <span class="comment">// OpenAPI 엔드포인트 매핑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 실행한 후 <strong>/openapi/v1.json</strong>으로 이동하면 생성된 OpenAPI 문서를 확인할 수 있습니다.</p><ul><li><p><strong>Swagger UI:</strong> 문법이 더 짧아지고 처음 보기에 더 &quot;네이티브&quot;하게 보이지만, 기본적으로는 상호작용 가능한 API 문서(Swagger UI)는 제공되지 않고 OpenAPI 문서만 생성됩니다. 😢 Swagger UI 같은 상호작용 가능한 API 문서가 필요하다면 Scalar와 같은 서드파티 도구를 통합해야 합니다. 자세한 가이드는 Scalar .NET API Reference Integration에서 확인할 수 있습니다.</p></li><li><p><strong>Build-Time Generation:</strong> <code>Microsoft.Extensions.ApiDescription.Server</code> 패키지를 사용해 빌드 시점에 OpenAPI 문서를 생성할 수도 있습니다.</p></li></ul><h2 id="7-searchvalues-개선-사항"><a class="markdownIt-Anchor" href="#7-searchvalues-개선-사항"></a> 7. SearchValues 개선 사항</h2><p><strong>SearchValues</strong>는 .NET 8에서 도입된 불변(immutable) 및 읽기 전용 값 집합으로, 기존의 <strong>ICollection.Contains</strong>보다 훨씬 더 효율적인 검색을 제공합니다. 처음에는 문자(char)나 바이트(byte) 집합만 지원했지만, .NET 9에서는 문자열(string)도 지원하도록 확장되었습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Exploring new capabilities of SearchValues!"</span>.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> vowelSearch = SearchValues.Create([ <span class="string">'n'</span>, <span class="string">'e'</span>, <span class="string">'w'</span> ]); <span class="comment">// 문자 집합 검색</span></span><br><span class="line">Console.WriteLine(text.ContainsAny(vowelSearch));</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">var</span> keywordSearch = SearchValues.Create([<span class="string">"new"</span>, <span class="string">"of"</span>], StringComparison.OrdinalIgnoreCase); <span class="comment">// 문자열 검색</span></span><br><span class="line">Console.WriteLine(text.ContainsAny(keywordSearch));</span><br></pre></td></tr></table></figure><p>.NET 9에서는 <code>StringComparison</code> 매개변수를 사용해 비교 방식을 지정할 수 있습니다.</p><p>이제 문자열도 지원하며, 대소문자 무시 등의 비교 옵션을 지정할 수 있는 기능이 추가되었습니다. 앞으로 이 기능은 문서 파싱, 입력 필터링, 스팸 감지, 데이터 편집, 검색 등 광범위한 텍스트 처리 애플리케이션에서 필수적인 도구가 될 것입니다. 🚀</p><h2 id="8-새로운-linq-메서드"><a class="markdownIt-Anchor" href="#8-새로운-linq-메서드"></a> 8. 새로운 LINQ 메서드</h2><p>.NET 9에서는 <code>CountBy</code>, <code>AggregateBy</code>, <code>Index</code>라는 세 가지 새로운 LINQ 메서드가 추가되었습니다. 이 메서드들은 일반적인 데이터 조작 작업에서 성능과 간결성을 향상시키도록 설계되었습니다. 아래는 각 메서드의 예시와 설명입니다.</p><h3 id="countby"><a class="markdownIt-Anchor" href="#countby"></a> <code>CountBy</code></h3><p>특정 키로 그룹화하고 각 그룹의 항목 수를 계산합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> firstName, <span class="keyword">string</span> lastName)[] people =</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John"</span>, <span class="meta-string">"Doe"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Jane"</span>, <span class="meta-string">"Peterson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John"</span>, <span class="meta-string">"Smith"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary"</span>, <span class="meta-string">"Johnson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Nick"</span>, <span class="meta-string">"Carson"</span>),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary"</span>, <span class="meta-string">"Morgan"</span>)</span></span><br><span class="line"><span class="meta"></span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> firstNameCounts = people</span><br><span class="line">   .GroupBy(p =&gt; p.firstName)</span><br><span class="line">   .ToDictionary(<span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Key, <span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Count())</span><br><span class="line">   .AsEnumerable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">firstNameCounts = people</span><br><span class="line">   .CountBy(p =&gt; p.firstName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> entry <span class="keyword">in</span> firstNameCounts)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(<span class="string">$"First Name <span class="subst">&#123;entry.Key&#125;</span> appears <span class="subst">&#123;entry.Value&#125;</span> times"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">First Name John appears 2 times</span></span><br><span class="line"><span class="comment">First Name Jane appears 1 times</span></span><br><span class="line"><span class="comment">First Name Mary appears 2 times</span></span><br><span class="line"><span class="comment">First Name Nick appears 1 times</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="aggregateby"><a class="markdownIt-Anchor" href="#aggregateby"></a> <code>AggregateBy</code></h3><p>그룹화된 데이터에서 값들을 집계합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> name, <span class="keyword">string</span> department, <span class="keyword">int</span> vacationDaysLeft)[] employees =</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John Doe"</span>, <span class="meta-string">"IT"</span>, 12),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Jane Peterson"</span>, <span class="meta-string">"Marketing"</span>, 18),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"John Smith"</span>, <span class="meta-string">"IT"</span>, 28),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary Johnson"</span>, <span class="meta-string">"HR"</span>, 17),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Nick Carson"</span>, <span class="meta-string">"Marketing"</span>, 5),</span></span><br><span class="line"><span class="meta">   (<span class="meta-string">"Mary Morgan"</span>, <span class="meta-string">"HR"</span>, 9)</span></span><br><span class="line"><span class="meta"></span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">var</span> departmentVacationDaysLeft = employees</span><br><span class="line">   .GroupBy(emp =&gt; emp.department)</span><br><span class="line">   .ToDictionary(<span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Key, <span class="keyword">group</span> =&gt; <span class="keyword">group</span>.Sum(emp =&gt; emp.vacationDaysLeft))</span><br><span class="line">   .AsEnumerable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line">departmentVacationDaysLeft = employees</span><br><span class="line">   .AggregateBy(emp =&gt; emp.department, <span class="number">0</span>, (acc, emp) =&gt; acc + emp.vacationDaysLeft);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> departmentVacationDaysLeft)</span><br><span class="line">   Console.WriteLine(<span class="string">$"Department <span class="subst">&#123;entry.Key&#125;</span> has a total of <span class="subst">&#123;entry.Value&#125;</span> vacation days left."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">Department IT has a total of 40 vacation days left.</span></span><br><span class="line"><span class="comment">Department Marketing has a total of 23 vacation days left.</span></span><br><span class="line"><span class="comment">Department HR has a total of 26 vacation days left.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="index"><a class="markdownIt-Anchor" href="#index"></a> <code>Index</code></h3><p>컬렉션의 각 항목에 인덱스를 매핑합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> managers = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"John Doe"</span>,</span><br><span class="line">   <span class="string">"Jane Peterson"</span>,</span><br><span class="line">   <span class="string">"John Smith"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 방식</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (index, manager) <span class="keyword">in</span> managers.Select((m, i) =&gt; (i, m)))</span><br><span class="line">   Console.WriteLine(<span class="string">$"Manager <span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;manager&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .NET 9 방식</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (index, manager) <span class="keyword">in</span> managers.Index())</span><br><span class="line">   Console.WriteLine(<span class="string">$"Manager <span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;manager&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">출력:</span></span><br><span class="line"><span class="comment">Manager 0: John Doe</span></span><br><span class="line"><span class="comment">Manager 1: Jane Peterson</span></span><br><span class="line"><span class="comment">Manager 2: John Smith</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>가장 좋은 함수는 <code>Index()</code>입니다. foreach에서 인덱스가 없는 점은 항상 골칫거리였고, 종종 더 복잡한 우회 방법을 사용하게 만들었기 때문입니다.</p><h2 id="9-내장-uuid-v7-생성"><a class="markdownIt-Anchor" href="#9-내장-uuid-v7-생성"></a> 9. 내장 UUID v7 생성</h2><p>.NET 초기부터 <code>Guid.NewGuid()</code>를 사용해 UUID를 생성해왔습니다. 이 방식은 <strong>UUID v4</strong>를 생성합니다. 그러나 UUID 사양은 지속적으로 발전해 현재의 안정된 버전은 <strong>UUID v7</strong>입니다.</p><p><strong>UUID v7</strong>의 주요 특징 중 하나는 UUID에 포함된 <strong>타임스탬프</strong>(timestamp)입니다. 구조는 다음과 같습니다:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------------+----------------------+</span><br><span class="line">| <span class="number">48</span>-<span class="built_in">bit</span> timestamp | <span class="number">12</span>-<span class="built_in">bit</span> <span class="built_in">random</span> |    <span class="number">62</span>-<span class="built_in">bit</span> <span class="built_in">random</span>     |</span><br><span class="line">+------------------+---------------+----------------------+</span><br></pre></td></tr></table></figure><p>이 타임스탬프 덕분에 UUID를 생성 시간에 따라 정렬할 수 있습니다. 이는 데이터베이스에서 더욱 적합하며, 분산 환경에서 더 나은 고유성을 보장합니다.</p><p>이제 .NET에서는 외부 라이브러리(예: <code>UUIDNext</code>)를 사용하지 않고도 UUID v7을 생성할 수 있습니다. 새로운 <code>Guid.CreateVersion7()</code> 메서드가 이를 지원하며, 특정 타임스탬프를 받아 UUID를 생성할 수도 있습니다. 이는 테스트 목적이나 정렬된 시퀀스에 특정 위치에 항목을 삽입할 때 유용합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> guid = Guid.NewGuid(); <span class="comment">// v4 UUID</span></span><br><span class="line">guid = Guid.CreateVersion7(); <span class="comment">// v7 UUID 생성</span></span><br><span class="line">guid = Guid.CreateVersion7(TimeProvider.System.GetUtcNow()); <span class="comment">// 타임스탬프가 포함된 v7 UUID 생성</span></span><br></pre></td></tr></table></figure><ul><li><code>Guid.CreateVersion7()</code>는 내부적으로 <code>NewGuid()</code>를 사용하며, 48비트 타임스탬프를 추가하고 UUID v7 표준에 맞게 올바른 버전 및 변형 비트를 설정합니다.</li><li>이로 인해 <code>NewGuid()</code>보다 약간 느릴 수 있지만, 수백만 개의 UUID를 생성해야 하는 경우가 아니라면 성능 차이는 거의 느껴지지 않습니다.</li></ul><h2 id="10-기타-기능"><a class="markdownIt-Anchor" href="#10-기타-기능"></a> 10. 기타 기능</h2><p>아래는 흥미로운 변경 사항들의 목록으로, 특정한 사용 사례에 적합하며 널리 채택되기보다는 특정 상황에서 유용하게 사용될 수 있는 기능들입니다.</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13#implicit-index-access" target="_blank" rel="noopener">암시적 인덱스 접근(Implicit index access)</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/csharp.md#partial-properties" target="_blank" rel="noopener">부분 속성(Partial properties)</a></li><li><a href="https://github.com/dotnet/core/blob/main/release-notes/9.0/preview/preview6/libraries.md#allows-ref-struct-used-in-many-places-throughout-the-libraries" target="_blank" rel="noopener">ref struct 허용</a></li><li><a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/libraries#base64url" target="_blank" rel="noopener">Base64Url 지원</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#collection-lookups-with-spans" target="_blank" rel="noopener">Span을 사용한 컬렉션 조회</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#regexenumeratesplits" target="_blank" rel="noopener">Regex.EnumerateSplits</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#systemtextjson" target="_blank" rel="noopener">System.Text.Json의 새로운 기능</a></li><li><a href="https://github.com/dotnet/core/blob/2f5ecee9ea988b4d85e288178c9d16131f3b0c43/release-notes/9.0/preview/preview6/libraries.md#ordereddictionarytkey-tvalue" target="_blank" rel="noopener"><code>OrderedDictionary&lt;TKey, TValue&gt;</code></a></li><li><a href="https://github.com/dotnet/core/blob/d6826c747b07bb4f050e2692bc309b8acd6ec1ec/release-notes/9.0/preview/preview6/libraries.md#readonlysett" target="_blank" rel="noopener"><code>ReadOnlySet&lt;T&gt;</code></a></li><li><a href="https://github.com/dotnet/core/blob/main/release-notes/9.0/preview/preview4/libraries.md#new-tensort-type" target="_blank" rel="noopener">New <code>Tensor&lt;T&gt;</code> 타입</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/12/06/csharp-15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>일상 작업을 자동화하는 10가지 Python 스크립트</title>
      <link>http://hgko1207.github.io/2024/12/05/python-11/</link>
      <guid>http://hgko1207.github.io/2024/12/05/python-11/</guid>
      <pubDate>Thu, 05 Dec 2024 14:39:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Python의 진정한 힘은 바로 자동화에 있습니다.&lt;/strong&gt; 일상 작업에 이 힘을 활용하지 않으시겠습니까?&lt;/p&gt;
&lt;p&gt;다음의 10가지 Python 스크립트는 초보자부터 숙련된 개발자까지 반복적인 작업을 자동화하고, 시간을 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Python의 진정한 힘은 바로 자동화에 있습니다.</strong> 일상 작업에 이 힘을 활용하지 않으시겠습니까?</p><p>다음의 10가지 Python 스크립트는 초보자부터 숙련된 개발자까지 반복적인 작업을 자동화하고, 시간을 절약하며, 효율성을 높이는 데 도움을 줄 것입니다.</p><p>전문가 수준이 아니더라도 지금 바로 시작할 수 있습니다!</p><h2 id="1-이미지-최적화-도구-photoshop이-필요-없어요"><a class="markdownIt-Anchor" href="#1-이미지-최적화-도구-photoshop이-필요-없어요"></a> 1. 이미지 최적화 도구: Photoshop이 필요 없어요!</h2><p>웹사이트나 소셜 미디어에 이미지를 최적화해야 할 때 Photoshop을 열기 귀찮으셨죠? 이제는 간단한 Python 스크립트로 해결할 수 있습니다. <strong>Pillow</strong> 라이브러리를 사용해 이미지 크기 조정, 회전, 필터 적용 등 다양한 작업을 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter, ImageOps, ImageEnhance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이미지 로드</span></span><br><span class="line">im = Image.open(<span class="string">"Image1.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이미지 작업 예제</span></span><br><span class="line">im = im.crop((<span class="number">34</span>, <span class="number">23</span>, <span class="number">100</span>, <span class="number">100</span>))  <span class="comment"># 자르기</span></span><br><span class="line">im = im.resize((<span class="number">50</span>, <span class="number">50</span>))          <span class="comment"># 크기 조정</span></span><br><span class="line">im = im.transpose(Image.FLIP_LEFT_RIGHT)  <span class="comment"># 좌우 반전</span></span><br><span class="line">im = im.rotate(<span class="number">360</span>)               <span class="comment"># 회전</span></span><br><span class="line">im.save(<span class="string">"Image1.jpg"</span>, optimize=<span class="literal">True</span>, quality=<span class="number">90</span>)  <span class="comment"># 압축 저장</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 필터 및 효과 적용</span></span><br><span class="line">im = im.filter(ImageFilter.BLUR)          <span class="comment"># 블러 효과</span></span><br><span class="line">im = im.filter(ImageFilter.SHARPEN)       <span class="comment"># 선명도 효과</span></span><br><span class="line">im = ImageOps.grayscale(im)               <span class="comment"># 흑백 변환</span></span><br><span class="line">im = ImageOps.invert(im)                  <span class="comment"># 색상 반전</span></span><br><span class="line">im.save(<span class="string">"Image1_optimized.jpg"</span>)</span><br></pre></td></tr></table></figure><h2 id="2-비디오-최적화-전문가급-비디오-만들기"><a class="markdownIt-Anchor" href="#2-비디오-최적화-전문가급-비디오-만들기"></a> 2. 비디오 최적화: 전문가급 비디오 만들기</h2><p>요즘 시대에서 비디오 편집은 단지 유튜버만의 영역이 아닙니다. <strong>MoviePy</strong>를 통해 자르기, 속도 조절, 효과 추가 등 기본적인 기능뿐만 아니라 멋진 효과까지 손쉽게 추가할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moviepy.editor <span class="keyword">as</span> pyedit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 로드</span></span><br><span class="line">video = pyedit.VideoFileClip(<span class="string">"vid.mp4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 자르기</span></span><br><span class="line">vid1 = video.subclip(<span class="number">0</span>, <span class="number">10</span>)  <span class="comment"># 0초부터 10초까지</span></span><br><span class="line">vid2 = video.subclip(<span class="number">20</span>, <span class="number">40</span>)  <span class="comment"># 20초부터 40초까지</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])  <span class="comment"># 두 클립 합치기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 속도 증가</span></span><br><span class="line">final_vid = final_vid.speedx(<span class="number">2</span>)  <span class="comment"># 2배 속도</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 오디오 추가</span></span><br><span class="line">aud = pyedit.AudioFileClip(<span class="string">"bg.mp3"</span>)  <span class="comment"># 오디오 파일 로드</span></span><br><span class="line">final_vid = final_vid.set_audio(aud)  <span class="comment"># 비디오에 오디오 설정</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오 뒤집기 (역재생)</span></span><br><span class="line">final_vid = final_vid.fx(pyedit.vfx.time_mirror)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 두 비디오 병합</span></span><br><span class="line">vid1 = pyedit.VideoFileClip(<span class="string">"vid1.mp4"</span>)</span><br><span class="line">vid2 = pyedit.VideoFileClip(<span class="string">"vid2.mp4"</span>)</span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오에 시각 효과(VFX) 추가</span></span><br><span class="line">vid1 = final_vid.fx(pyedit.vfx.mirror_x)  <span class="comment"># 좌우 반전 효과</span></span><br><span class="line">vid2 = final_vid.fx(pyedit.vfx.invert_colors)  <span class="comment"># 색상 반전 효과</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([vid1, vid2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 비디오에 이미지 추가</span></span><br><span class="line">img1 = pyedit.ImageClip(<span class="string">"img1.jpg"</span>)  <span class="comment"># 이미지 1</span></span><br><span class="line">img2 = pyedit.ImageClip(<span class="string">"img2.jpg"</span>)  <span class="comment"># 이미지 2</span></span><br><span class="line">final_vid = pyedit.concatenate_videoclips([img1, img2])  <span class="comment"># 이미지와 비디오 합치기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 최종 비디오 저장</span></span><br><span class="line">final_vid.write_videofile(<span class="string">"final.mp4"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-이메일-스케줄러-이메일-잊지-마세요"><a class="markdownIt-Anchor" href="#3-이메일-스케줄러-이메일-잊지-마세요"></a> 3. 이메일 스케줄러: 이메일 잊지 마세요!</h2><p><strong>smtplib</strong>과 <strong>schedule</strong>을 사용하여 이메일을 자동으로 예약하고 발송할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">()</span>:</span></span><br><span class="line">    sender_email = <span class="string">"your_email@gmail.com"</span></span><br><span class="line">    receiver_email = <span class="string">"recipient_email@gmail.com"</span></span><br><span class="line">    password = <span class="string">"your_email_password"</span></span><br><span class="line"></span><br><span class="line">    subject = <span class="string">"자동 이메일"</span></span><br><span class="line">    body = <span class="string">"이것은 Python으로 전송된 자동 이메일입니다."</span></span><br><span class="line"></span><br><span class="line">    message = <span class="string">f"Subject: <span class="subst">&#123;subject&#125;</span>\n\n<span class="subst">&#123;body&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> smtplib.SMTP_SSL(<span class="string">"smtp.gmail.com"</span>, <span class="number">465</span>) <span class="keyword">as</span> server:</span><br><span class="line">        server.login(sender_email, password)</span><br><span class="line">        server.sendmail(sender_email, receiver_email, message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 매일 오전 8시에 이메일을 보내도록 예약</span></span><br><span class="line">schedule.every().day.at(<span class="string">"08:00"</span>).do(send_email)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="4-소셜-미디어-자동-게시-도구"><a class="markdownIt-Anchor" href="#4-소셜-미디어-자동-게시-도구"></a> 4. 소셜 미디어 자동 게시 도구</h2><p><strong>Tweepy</strong> 라이브러리를 사용해 Twitter와 같은 플랫폼에 자동으로 게시물을 올릴 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_to_twitter</span><span class="params">()</span>:</span></span><br><span class="line">    api_key = <span class="string">"YOUR_API_KEY"</span></span><br><span class="line">    api_secret = <span class="string">"YOUR_API_SECRET"</span></span><br><span class="line">    access_token = <span class="string">"YOUR_ACCESS_TOKEN"</span></span><br><span class="line">    access_token_secret = <span class="string">"YOUR_ACCESS_TOKEN_SECRET"</span></span><br><span class="line"></span><br><span class="line">    auth = tweepy.OAuthHandler(api_key, api_secret)</span><br><span class="line">    auth.set_access_token(access_token, access_token_secret)</span><br><span class="line">    api = tweepy.API(auth)</span><br><span class="line"></span><br><span class="line">    tweet = <span class="string">"이것은 Python으로 자동 게시된 트윗입니다!"</span></span><br><span class="line">    api.update_status(tweet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6시간마다 게시되도록 예약합니다.</span></span><br><span class="line">schedule.every(<span class="number">6</span>).hours.do(post_to_twitter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="5-pdf를-이미지로-변환"><a class="markdownIt-Anchor" href="#5-pdf를-이미지로-변환"></a> 5. PDF를 이미지로 변환</h2><p><strong>PyMuPDF</strong>를 사용하여 PDF 페이지를 고화질 이미지로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pdf_to_images</span><span class="params">(pdf_file)</span>:</span></span><br><span class="line">    doc = fitz.open(pdf_file)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> doc:</span><br><span class="line">        pix = page.get_pixmap()</span><br><span class="line">        output = <span class="string">f"page<span class="subst">&#123;page.number&#125;</span>.png"</span></span><br><span class="line">        pix.writePNG(output)</span><br><span class="line"></span><br><span class="line">pdf_to_images(<span class="string">"test.pdf"</span>)</span><br></pre></td></tr></table></figure><h2 id="6-api-데이터-가져오기"><a class="markdownIt-Anchor" href="#6-api-데이터-가져오기"></a> 6. API 데이터 가져오기</h2><p><strong>urllib3</strong>를 사용하여 API 데이터를 자동으로 가져오며, 날씨 정보, 주가, GitHub 저장소 정보 등 어떤 데이터든 처리할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line"><span class="comment"># GET 요청으로 API 데이터 가져오기</span></span><br><span class="line">url = <span class="string">"https://api.github.com/users/psf/repos"</span>  <span class="comment"># GitHub 저장소 API URL</span></span><br><span class="line">http = urllib3.PoolManager()  <span class="comment"># HTTP 연결 풀 생성</span></span><br><span class="line">response = http.request(<span class="string">'GET'</span>, url)  <span class="comment"># GET 요청 전송</span></span><br><span class="line">print(<span class="string">"Status Code:"</span>, response.status)  <span class="comment"># 상태 코드 출력</span></span><br><span class="line">print(<span class="string">"Response Data:"</span>, response.data)  <span class="comment"># 응답 데이터 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 요청으로 API 데이터 전송</span></span><br><span class="line">url = <span class="string">"https://httpbin.org/post"</span>  <span class="comment"># POST 테스트 API URL</span></span><br><span class="line">http = urllib3.PoolManager()  <span class="comment"># HTTP 연결 풀 생성</span></span><br><span class="line">response = http.request(<span class="string">'POST'</span>, url, fields=&#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;)  <span class="comment"># POST 요청 전송</span></span><br><span class="line">print(<span class="string">"Status Code:"</span>, response.status)  <span class="comment"># 상태 코드 출력</span></span><br></pre></td></tr></table></figure><h2 id="7-배터리-알림-배터리-상태를-항상-주시하세요"><a class="markdownIt-Anchor" href="#7-배터리-알림-배터리-상태를-항상-주시하세요"></a> 7. 배터리 알림: 배터리 상태를 항상 주시하세요</h2><p><strong>plyer</strong>와 <strong>psutil</strong>을 사용해 배터리 상태를 모니터링하고 충전이 필요할 때 알림을 보냅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plyer <span class="keyword">import</span> notification</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    battery = psutil.sensors_battery()</span><br><span class="line">    life = battery.percent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> life &lt; <span class="number">50</span>:</span><br><span class="line">        notification.notify(</span><br><span class="line">            title=<span class="string">"Battery Low"</span>,</span><br><span class="line">            message=<span class="string">"Please connect to a power source"</span>,</span><br><span class="line">            timeout=<span class="number">10</span></span><br><span class="line">        )</span><br><span class="line">    sleep(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><h2 id="8-웹-스크래핑"><a class="markdownIt-Anchor" href="#8-웹-스크래핑"></a> 8. 웹 스크래핑</h2><p><strong>BeautifulSoup</strong>와 <strong>requests</strong>를 사용해 웹사이트에서 데이터를 자동으로 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://example.com"</span>  <span class="comment"># 스크래핑할 URL</span></span><br><span class="line">response = requests.get(url)  <span class="comment"># GET 요청</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">"html.parser"</span>)  <span class="comment"># HTML 파싱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 웹사이트에서 특정 데이터 추출</span></span><br><span class="line">data = soup.find(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>: <span class="string">"content"</span>&#125;).get_text()  <span class="comment"># "content" 클래스 데이터 추출</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h2 id="9-pytest-자동화된-테스트로-오류-없는-코드-유지"><a class="markdownIt-Anchor" href="#9-pytest-자동화된-테스트로-오류-없는-코드-유지"></a> 9. Pytest: 자동화된 테스트로 오류 없는 코드 유지</h2><p><strong>Pytest</strong>를 사용해 Python 코드가 올바르게 작동하는지 자동으로 테스트할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트할 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트 케이스</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_addition</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">-1</span>, <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> add_numbers(<span class="number">10</span>, <span class="number">5</span>) == <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main()</span><br></pre></td></tr></table></figure><h2 id="10-파일-백업-및-동기화"><a class="markdownIt-Anchor" href="#10-파일-백업-및-동기화"></a> 10. 파일 백업 및 동기화</h2><p>파일을 자동으로 백업하고 동기화하여 데이터를 안전하게 관리할 수 있습니다. 이 스크립트는 두 폴더 간 파일 백업 및 동기화를 수행합니다. 한 폴더에서 문서를 수정하면 다른 폴더도 자동으로 업데이트됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backup_and_sync</span><span class="params">(source_folder, backup_folder)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(source_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            source_path = os.path.join(root, file)</span><br><span class="line">            backup_path = os.path.join(backup_folder, root.replace(source_folder, <span class="string">""</span>), file)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 백업 폴더에 디렉토리가 없으면 생성</span></span><br><span class="line">            os.makedirs(os.path.dirname(backup_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 백업 폴더로 파일 복사</span></span><br><span class="line">            shutil.copy2(source_path, backup_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 백업 폴더에 남아있는 불필요한 파일 삭제</span></span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(backup_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            backup_path = os.path.join(root, file)</span><br><span class="line">            source_path = os.path.join(source_folder, root.replace(backup_folder, <span class="string">""</span>), file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(source_path):</span><br><span class="line">                os.remove(backup_path)</span><br><span class="line"></span><br><span class="line">source_folder = <span class="string">"path/to/source/folder"</span>  <span class="comment"># 원본 폴더 경로</span></span><br><span class="line">backup_folder = <span class="string">"path/to/backup/folder"</span>  <span class="comment"># 백업 폴더 경로</span></span><br><span class="line"></span><br><span class="line">backup_and_sync(source_folder, backup_folder)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/12/05/python-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 Lombok을 활용한 효율적인 Java 개발 가이드 🌟</title>
      <link>http://hgko1207.github.io/2024/11/25/spring-9/</link>
      <guid>http://hgko1207.github.io/2024/11/25/spring-9/</guid>
      <pubDate>Mon, 25 Nov 2024 05:38:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Project Lombok&lt;/strong&gt;은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Project Lombok</strong>은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보일러플레이트 코드를 자동으로 생성해줍니다.</p><h2 id="lombok을-사용하는-이유"><a class="markdownIt-Anchor" href="#lombok을-사용하는-이유"></a> Lombok을 사용하는 이유</h2><ul><li><strong>코드 간소화:</strong> <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, getters, setters 등의 일반적인 메서드를 자동으로 생성합니다.</li><li><strong>가독성 향상:</strong> 불필요한 코드가 줄어들어 코드의 의도가 더 명확하게 드러납니다.</li><li><strong>개발 시간 단축:</strong> 작성해야 할 코드가 줄어들어 비즈니스 로직에 집중할 수 있습니다.</li><li><strong>리팩토링 용이성:</strong> 필드 이름을 변경하더라도 getter/setter를 따로 수정할 필요가 없습니다.</li></ul><h2 id="lombok의-주요-기능"><a class="markdownIt-Anchor" href="#lombok의-주요-기능"></a> Lombok의 주요 기능</h2><p>Lombok은 수많은 주석을 제공합니다. 다음은 몇 가지 주요 기능을 살펴보겠습니다.</p><h2 id="data"><a class="markdownIt-Anchor" href="#data"></a> @Data</h2><p>모든 필드에 대한 getter를 생성하고, <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> 메서드와 생성자를 자동으로 만듭니다. 또한, final 필드에 대해 setter도 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">               <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-nonnull"><a class="markdownIt-Anchor" href="#2-nonnull"></a> 2. @NonNull</h2><p>메서드 또는 생성자의 매개변수에 대해 null 체크를 자동으로 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(@NonNull String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-cleanup"><a class="markdownIt-Anchor" href="#3-cleanup"></a> 3. @Cleanup</h2><p>특정 리소스를 자동으로 정리하여 리소스 누수를 방지합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="comment">// 스트림 작업</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-sneakythrows"><a class="markdownIt-Anchor" href="#4-sneakythrows"></a> 4. @SneakyThrows</h2><p>메서드 선언에 <code>throws</code>를 명시하지 않고도 체크 예외를 던질 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Files.readAllBytes(Paths.get(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-builder"><a class="markdownIt-Anchor" href="#5-builder"></a> 5. @Builder</h2><p>객체 생성을 위한 빌더 패턴을 자동으로 구현합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">email</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(name, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-value"><a class="markdownIt-Anchor" href="#6-value"></a> 6. @Value</h2><p><code>@Data</code>의 불변(immutable) 버전으로, 모든 필드를 private 및 final로 설정하며 setter를 생성하지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-생성자-어노테이션"><a class="markdownIt-Anchor" href="#7-생성자-어노테이션"></a> 7. 생성자 어노테이션</h2><p>Lombok은 생성자를 자동으로 생성하는 여러 어노테이션을 제공합니다.</p><h3 id="noargsconstructor"><a class="markdownIt-Anchor" href="#noargsconstructor"></a> @NoArgsConstructor</h3><p>인수 없는 생성자를 생성합니다. 프레임워크(JPA 등)에서 필요한 경우 유용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requiredargsconstructor"><a class="markdownIt-Anchor" href="#requiredargsconstructor"></a> @RequiredArgsConstructor</h3><p><code>final</code> 필드 및 <code>@NonNull</code> 필드에 대해 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@NonNull String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allargsconstructor"><a class="markdownIt-Anchor" href="#allargsconstructor"></a> @AllArgsConstructor</h3><p>모든 필드에 대한 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intellij-및-eclipse에서-lombok-설정"><a class="markdownIt-Anchor" href="#intellij-및-eclipse에서-lombok-설정"></a> IntelliJ 및 Eclipse에서 Lombok 설정</h2><h3 id="intellij-idea"><a class="markdownIt-Anchor" href="#intellij-idea"></a> IntelliJ IDEA</h3><ul><li><strong>플러그인 설치:</strong> 마켓플레이스에서 Lombok 플러그인을 설치합니다.</li><li><strong>어노테이션 프로세싱 활성화:</strong><br />Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors에서 활성화.</li></ul><h3 id="eclipse"><a class="markdownIt-Anchor" href="#eclipse"></a> Eclipse</h3><ul><li><strong>Lombok JAR 다운로드 및 실행:</strong> Eclipse 설치 경로에 Lombok을 통합합니다.</li><li><strong>재시작 및 설정 확인:</strong> 프로젝트 속성에서 어노테이션 프로세싱 활성화.</li></ul><h2 id="maven-및-gradle-통합"><a class="markdownIt-Anchor" href="#maven-및-gradle-통합"></a> Maven 및 Gradle 통합</h2><ul><li><strong>Maven 설정</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Gradle 설정</strong></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Lombok은 특히 Spring Boot 생태계에서 자바 개발자에게 필수적인 도구로 자리 잡았습니다. 보일러플레이트 코드를 줄이고 유지보수를 간소화하며, 코드 생산성을 크게 향상시킵니다.</p><p><strong>Lombok을 제대로 이해하고 활용하면, Spring Boot 애플리케이션 개발의 효율성이 크게 향상될 것입니다.</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/spring-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모든 개발자가 알아야 할 20가지 Git 명령어</title>
      <link>http://hgko1207.github.io/2024/11/25/git-4/</link>
      <guid>http://hgko1207.github.io/2024/11/25/git-4/</guid>
      <pubDate>Mon, 25 Nov 2024 04:55:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/git-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 &lt;code&gt;push&lt;/code&gt;, &lt;code
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/git-4.png" alt="" /></p><p><strong>Git</strong>은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 <code>push</code>, <code>pull</code>, <code>commit</code> 정도만 활용합니다. 그러나 Git은 우리가 상상하지 못한 다양한 기능을 제공하며, 이를 활용하면 생산성과 효율성을 대폭 향상시킬 수 있습니다.</p><p>이 글에서는 <strong>Git의 유용한 명령어 20가지</strong>를 소개하며, 이를 통해 더욱 효율적이고 자신감 있게 버전 관리를 할 수 있도록 도와드립니다.</p><h2 id="1-인터랙티브-추가"><a class="markdownIt-Anchor" href="#1-인터랙티브-추가"></a> 1. 인터랙티브 추가</h2><ul><li><strong>설명:</strong> 파일 전체가 아닌 특정 부분만 스테이징할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 내의 특정 변경 사항만 선택적으로 커밋할 수 있어, 작은 단위의 커밋을 만들 때 유용합니다.</li><li><strong>팁:</strong> 한 파일에서 여러 작업을 진행한 경우, 각 작업을 개별 커밋으로 나누는 데 사용하세요.</li></ul><h2 id="2-마지막-커밋-되돌리기"><a class="markdownIt-Anchor" href="#2-마지막-커밋-되돌리기"></a> 2. 마지막 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 마지막 커밋을 취소하되, 작업 디렉토리의 변경 사항은 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 커밋을 수정하거나 다시 커밋할 수 있는 “타임머신” 같은 기능입니다.</li><li><strong>팁:</strong> <code>--soft</code>는 변경 사항을 유지하고, <code>--hard</code>는 변경 사항까지 모두 되돌립니다.</li></ul><h2 id="3-브랜치의-업스트림-상태-확인하기"><a class="markdownIt-Anchor" href="#3-브랜치의-업스트림-상태-확인하기"></a> 3. 브랜치의 업스트림 상태 확인하기</h2><ul><li><strong>설명:</strong> 원격의 모든 업데이트를 가져오고, 삭제된 원격 브랜치의 참조를 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all --prune</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 로컬 환경을 최신 상태로 유지하며, 불필요한 브랜치를 정리합니다.</li><li><strong>팁:</strong> 대규모 팀에서 작업할 때 브랜치 목록을 깔끔하게 유지하세요.</li></ul><h2 id="4-빠른-커밋-수정"><a class="markdownIt-Anchor" href="#4-빠른-커밋-수정"></a> 4. 빠른 커밋 수정</h2><ul><li><strong>설명:</strong> 마지막 커밋을 수정하거나 커밋 메시지를 변경합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> Git 로그를 깔끔하게 유지하며 작은 실수를 빠르게 수정할 수 있습니다.</li><li><strong>팁:</strong> 여러 번의 커밋 없이 작은 실수를 수정하세요.</li></ul><h2 id="5-작업-임시-저장"><a class="markdownIt-Anchor" href="#5-작업-임시-저장"></a> 5. 작업 임시 저장</h2><ul><li><strong>설명:</strong> 현재 변경 사항을 커밋하지 않고 임시로 저장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 현재 작업을 보류하고 다른 브랜치로 전환할 수 있습니다.</li><li><strong>팁:</strong> <code>git stash save &quot;설명&quot;</code>으로 임시 저장 항목에 설명을 추가하면 더 쉽게 찾을 수 있습니다.</li></ul><h2 id="6-임시-저장-복원"><a class="markdownIt-Anchor" href="#6-임시-저장-복원"></a> 6. 임시 저장 복원</h2><ul><li><strong>설명:</strong> 임시 저장된 작업을 복원합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 저장한 작업을 다시 가져오며, 목록에서 자동으로 삭제됩니다.</li><li><strong>팁:</strong> <code>git stash apply</code>를 사용하면 삭제 없이 적용할 수 있습니다.</li></ul><h2 id="7-특정-커밋-가져오기"><a class="markdownIt-Anchor" href="#7-특정-커밋-가져오기"></a> 7. 특정 커밋 가져오기</h2><ul><li><strong>설명:</strong> 특정 커밋만 현재 브랜치에 적용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 브랜치 전체를 병합하지 않고 필요한 기능이나 버그 수정을 가져올 수 있습니다.</li><li><strong>팁:</strong> 버그 수정이나 특정 기능만 백포트(backport)할 때 유용합니다.</li></ul><h2 id="8-로컬-브랜치-정리"><a class="markdownIt-Anchor" href="#8-로컬-브랜치-정리"></a> 8. 로컬 브랜치 정리</h2><ul><li><strong>설명:</strong> 사용하지 않는 브랜치를 삭제합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 오래된 브랜치를 정리해 작업 공간을 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 병합되지 않은 브랜치를 삭제하려면 <code>-D</code> 플래그를 사용하세요.</li></ul><h2 id="9-파일-히스토리-보기"><a class="markdownIt-Anchor" href="#9-파일-히스토리-보기"></a> 9. 파일 히스토리 보기</h2><ul><li><strong>설명:</strong> 특정 파일에 영향을 준 모든 커밋을 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 변경 이력을 추적해 변경 이유를 이해할 수 있습니다.</li><li><strong>팁:</strong> <code>--stat</code> 옵션을 추가하면 더 자세한 변경 내용을 볼 수 있습니다.</li></ul><h2 id="10-라인별-코드-작성자-확인"><a class="markdownIt-Anchor" href="#10-라인별-코드-작성자-확인"></a> 10. 라인별 코드 작성자 확인</h2><ul><li><strong>설명:</strong> 특정 파일의 각 줄을 누가 작성했는지 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 디버깅 시 특정 코드 작성자를 추적하는 데 유용합니다.</li><li><strong>팁:</strong> <code>git log</code>와 함께 사용해 더 자세한 히스토리를 확인하세요.</li></ul><h2 id="11-버그-소스-찾기"><a class="markdownIt-Anchor" href="#11-버그-소스-찾기"></a> 11. 버그 소스 찾기</h2><ul><li><strong>설명:</strong> 이진 검색을 통해 버그가 도입된 커밋을 찾습니다.</li><li><strong>장점:</strong> 대규모 프로젝트에서 버그가 발생한 커밋을 빠르게 찾습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good &lt;older-commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="12-병합-중단"><a class="markdownIt-Anchor" href="#12-병합-중단"></a> 12. 병합 중단</h2><ul><li><strong>설명:</strong> 병합 중 문제가 발생하면 병합을 중단하고 이전 상태로 되돌립니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 병합 중단 후 새로운 시작점을 제공합니다.</li><li><strong>팁:</strong> 병합 전에 작업 디렉토리를 깨끗하게 유지하세요.</li></ul><h2 id="13-커밋-메시지-검색"><a class="markdownIt-Anchor" href="#13-커밋-메시지-검색"></a> 13. 커밋 메시지 검색</h2><ul><li><strong>설명:</strong> 커밋 메시지를 검색합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=<span class="string">"검색어"</span></span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 메시지 키워드로 커밋을 빠르게 찾습니다.</li><li><strong>팁:</strong> <code>--author</code>를 추가해 특정 작성자의 커밋을 검색하세요.</li></ul><h2 id="14-태그-추가"><a class="markdownIt-Anchor" href="#14-태그-추가"></a> 14. 태그 추가</h2><ul><li><strong>설명:</strong> Git 히스토리에서 특정 지점을 태그로 표시합니다.</li><li><strong>장점:</strong> 특정 버전을 표시해 쉽게 참조할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">"Version 1.0 release"</span></span><br></pre></td></tr></table></figure><h2 id="15-작업-공간-정리"><a class="markdownIt-Anchor" href="#15-작업-공간-정리"></a> 15. 작업 공간 정리</h2><ul><li><strong>설명:</strong> 추적되지 않은 파일과 디렉터리를 제거합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 작업 디렉토리를 정리하고 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 삭제된 파일이 필요 없는지 확인하세요.</li></ul><h2 id="16-git-작업-기록-보기"><a class="markdownIt-Anchor" href="#16-git-작업-기록-보기"></a> 16. Git 작업 기록 보기</h2><ul><li><strong>설명:</strong> 모든 Git 작업 기록을 확인합니다.</li><li><strong>장점:</strong> 손실된 커밋이나 작업을 복구할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="17-커밋-합치기"><a class="markdownIt-Anchor" href="#17-커밋-합치기"></a> 17. 커밋 합치기</h2><ul><li><strong>설명:</strong> 여러 커밋을 하나로 합쳐 Git 로그를 깔끔하게 만듭니다.</li><li><strong>장점:</strong> 커밋 기록을 깔끔하고 전문적으로 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~&lt;number-of-commits&gt;</span><br></pre></td></tr></table></figure><h2 id="18-커밋-되돌리기"><a class="markdownIt-Anchor" href="#18-커밋-되돌리기"></a> 18. 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 특정 커밋을 되돌리되, 전체 히스토리는 유지합니다.</li><li><strong>장점:</strong> 히스토리를 변경하지 않고 실수를 수정할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="19-브랜치-그래프-보기"><a class="markdownIt-Anchor" href="#19-브랜치-그래프-보기"></a> 19. 브랜치 그래프 보기</h2><ul><li><strong>설명:</strong> 프로젝트의 브랜치와 병합 기록을 그래프로 표시합니다.</li><li><strong>장점:</strong> 브랜치 구조를 한눈에 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all</span><br></pre></td></tr></table></figure><h2 id="20-자동-완성-사용"><a class="markdownIt-Anchor" href="#20-자동-완성-사용"></a> 20. 자동 완성 사용</h2><ul><li><strong>설명:</strong> Git 명령어 입력 시 탭을 눌러 자동 완성을 활성화합니다.</li><li><strong>장점:</strong> 생산성을 높이고 타이핑 오류를 줄입니다.</li></ul><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 20가지 Git 명령어 트릭은 생산성을 높이고 팀 내 Git 관리 능력을 향상시키는 필수 도구입니다. 이를 익히고 활용하면 동료들에게 &quot;Git 마스터&quot;로 인정받을 것입니다. 🚀</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/git-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(2)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-3/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-3/</guid>
      <pubDate>Mon, 25 Nov 2024 04:37:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;16-docker-image-prune&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#16-docker-image-prune&quot;&gt;&lt;/a&gt; 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.</p><h2 id="16-docker-image-prune"><a class="markdownIt-Anchor" href="#16-docker-image-prune"></a> 16. <code>docker image prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 이미지를 삭제합니다.</li><li><strong>장점:</strong> 개발 환경을 깔끔하게 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="17-docker-volume-prune"><a class="markdownIt-Anchor" href="#17-docker-volume-prune"></a> 17. <code>docker volume prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 볼륨을 삭제합니다.</li><li><strong>장점:</strong> 불필요한 스토리지 사용을 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><h2 id="18-docker-events"><a class="markdownIt-Anchor" href="#18-docker-events"></a> 18. <code>docker events</code></h2><ul><li><strong>설명:</strong> Docker 서버의 실시간 이벤트를 스트리밍합니다.</li><li><strong>장점:</strong> 컨테이너 수명 주기 이벤트를 추적합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events</span><br></pre></td></tr></table></figure><h2 id="19-docker-inspect-format"><a class="markdownIt-Anchor" href="#19-docker-inspect-format"></a> 19. <code>docker inspect --format</code></h2><ul><li><strong>설명:</strong> <code>docker inspect</code> 출력에서 특정 정보를 추출합니다.</li><li><strong>장점:</strong> 자동화 스크립트에서 필요한 데이터만 효율적으로 가져옵니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123; .Config.Env &#125;&#125;'</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="20-docker-build-no-cache"><a class="markdownIt-Anchor" href="#20-docker-build-no-cache"></a> 20. <code>docker build --no-cache</code></h2><ul><li><strong>설명:</strong> 캐시를 사용하지 않고 이미지를 빌드합니다.</li><li><strong>장점:</strong> 깨끗한 빌드를 보장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="21-docker-run-d"><a class="markdownIt-Anchor" href="#21-docker-run-d"></a> 21. <code>docker run -d</code></h2><ul><li><strong>설명:</strong> 컨테이너를 백그라운드에서 실행합니다.</li><li><strong>장점:</strong> 터미널을 자유롭게 사용하면서 여러 컨테이너를 관리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="22-docker-image-inspect"><a class="markdownIt-Anchor" href="#22-docker-image-inspect"></a> 22. <code>docker image inspect</code></h2><ul><li><strong>설명:</strong> 이미지의 세부 정보를 제공합니다.</li><li><strong>장점:</strong> 디버깅 및 이미지 최적화에 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="23-docker-save-docker-load"><a class="markdownIt-Anchor" href="#23-docker-save-docker-load"></a> 23. <code>docker save / docker load</code></h2><ul><li><strong>설명:</strong> 이미지를 tar 파일로 저장하거나 로드합니다.</li><li><strong>장점:</strong> 인터넷 없이 이미지를 전송할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;image_name&gt;.tar &lt;image_name&gt;</span><br><span class="line">docker load -i &lt;image_name&gt;.tar</span><br></pre></td></tr></table></figure><h2 id="24-docker-exec-it"><a class="markdownIt-Anchor" href="#24-docker-exec-it"></a> 24. <code>docker exec -it</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너에서 대화형 bash 셸을 엽니다.</li><li><strong>장점:</strong> 컨테이너 내부에서 디버깅과 테스트를 빠르게 수행할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name&gt; bash</span><br></pre></td></tr></table></figure><h2 id="25-docker-ps-q-docker-stop-docker-ps-q"><a class="markdownIt-Anchor" href="#25-docker-ps-q-docker-stop-docker-ps-q"></a> 25. docker ps -q / docker stop $(docker ps -q)</h2><ul><li><strong>설명:</strong> 실행 중인 모든 컨테이너를 빠르게 중지합니다.</li><li><strong>장점:</strong> 개발 환경을 한 번에 정리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 25가지 Docker 명령어는 일상적인 워크플로를 개선하고 컨테이너 환경을 보다 효율적으로 관리할 수 있도록 도와줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(1)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-2/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-2/</guid>
      <pubDate>Mon, 25 Nov 2024 04:10:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Docker</strong>는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.</p><p>이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은 <strong>Docker 명령어</strong>를 활용해 워크플로를 최적화하고, 성능을 개선하며, 확장 가능한 애플리케이션을 구축하는 능력입니다.</p><p>이 글에서는 Docker 명령어 25가지를 소개하며, 이를 통해 개발 및 배포 프로세스를 완벽하게 제어하고 일상적인 작업을 개선하는 방법을 알려드립니다.</p><h2 id="1-docker-update"><a class="markdownIt-Anchor" href="#1-docker-update"></a> 1. <code>docker update</code></h2><ul><li><strong>설명:</strong> 컨테이너를 재시작하지 않고 리소스 제한을 업데이트합니다.</li><li><strong>장점:</strong> 중단 없이 리소스를 조정해 컨테이너 성능 저하를 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --cpus 2 --memory 1g &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> 트래픽이 많은 시간대에 리소스를 늘렸다가, 이후 다시 축소하여 자원을 절약하세요.</li></ul><h2 id="2-docker-stats"><a class="markdownIt-Anchor" href="#2-docker-stats"></a> 2. <code>docker stats</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너의 실시간 리소스 사용량을 표시합니다.</li><li><strong>장점:</strong> CPU, 메모리, 네트워크 사용량을 실시간으로 모니터링할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> --all 옵션으로 백그라운드 컨테이너까지 모니터링하세요.</li></ul><h2 id="3-docker-diff"><a class="markdownIt-Anchor" href="#3-docker-diff"></a> 3. <code>docker diff</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템에서 변경된 내용을 보여줍니다.</li><li><strong>장점:</strong> 배포 후 변경된 파일을 빠르게 확인하고 문제를 해결합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="4-docker-commit"><a class="markdownIt-Anchor" href="#4-docker-commit"></a> 4. <code>docker commit</code></h2><ul><li><strong>설명:</strong> 컨테이너의 현재 상태를 기반으로 새로운 이미지를 생성합니다.</li><li><strong>장점:</strong> 변경된 상태를 저장해 디버깅이나 테스트 환경에 활용할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;container_name&gt; &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="5-docker-cp"><a class="markdownIt-Anchor" href="#5-docker-cp"></a> 5. <code>docker cp</code></h2><ul><li><strong>설명:</strong> 컨테이너와 호스트 간 파일을 복사합니다.</li><li><strong>장점:</strong> 컨테이너를 중단하지 않고 로그나 설정 파일에 접근할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;container_name&gt;:/path/to/file /host/path</span><br></pre></td></tr></table></figure><h2 id="6-docker-build-squash"><a class="markdownIt-Anchor" href="#6-docker-build-squash"></a> 6. <code>docker build --squash</code></h2><ul><li><strong>설명:</strong> 빌드 중 레이어를 하나로 압축하여 이미지 크기를 줄입니다.</li><li><strong>장점:</strong> 이미지 크기를 줄여 로드 시간을 단축하고 저장 공간을 절약합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="7-docker-system-df"><a class="markdownIt-Anchor" href="#7-docker-system-df"></a> 7. <code>docker system df</code></h2><ul><li><strong>설명:</strong> Docker 디스크 사용량 요약 정보를 제공합니다.</li><li><strong>장점:</strong> 디스크 공간을 많이 차지하는 요소를 빠르게 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="8-docker-network-inspect"><a class="markdownIt-Anchor" href="#8-docker-network-inspect"></a> 8. <code>docker network inspect</code></h2><ul><li><strong>설명:</strong> Docker 네트워크의 상세 정보를 확인합니다.</li><li><strong>장점:</strong> 컨테이너 간 네트워킹 문제를 디버깅하는 데 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;network_name&gt;</span><br></pre></td></tr></table></figure><h2 id="9-docker-exec-u"><a class="markdownIt-Anchor" href="#9-docker-exec-u"></a> 9. <code>docker exec -u</code></h2><ul><li><strong>설명:</strong> 특정 사용자를 지정해 컨테이너에서 명령을 실행합니다.</li><li><strong>장점:</strong> 다양한 사용자 환경을 테스트할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u &lt;user&gt; &lt;container_name&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="10-docker-run-rm"><a class="markdownIt-Anchor" href="#10-docker-run-rm"></a> 10. <code>docker run --rm</code></h2><ul><li><strong>설명:</strong> 컨테이너 종료 후 자동으로 삭제합니다.</li><li><strong>장점:</strong> 임시 작업 후 불필요한 컨테이너를 자동으로 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="11-docker-compose-config"><a class="markdownIt-Anchor" href="#11-docker-compose-config"></a> 11. <code>docker-compose config</code></h2><ul><li><strong>설명:</strong> <code>docker-compose.yml</code> 파일을 검증하고 구성을 표시합니다.</li><li><strong>장점:</strong> 구성 파일의 구문 오류를 사전에 감지할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose config</span><br></pre></td></tr></table></figure><h2 id="12-docker-rm-v"><a class="markdownIt-Anchor" href="#12-docker-rm-v"></a> 12. <code>docker rm -v</code></h2><ul><li><strong>설명:</strong> 컨테이너와 관련된 익명의 볼륨을 함께 삭제합니다.</li><li><strong>장점:</strong> 고아 볼륨을 방지해 디스크 공간을 효율적으로 사용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="13-docker-export-docker-import"><a class="markdownIt-Anchor" href="#13-docker-export-docker-import"></a> 13. <code>docker export / docker import</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템을 tar 파일로 내보내거나 새 이미지로 가져옵니다.</li><li><strong>장점:</strong> 특정 상태를 다른 환경으로 쉽게 전환할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> &lt;container_name&gt; &gt; container.tar</span><br><span class="line">docker import container.tar &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="14-docker-history"><a class="markdownIt-Anchor" href="#14-docker-history"></a> 14. <code>docker history</code></h2><ul><li><strong>설명:</strong> 이미지의 각 레이어 변경 이력을 보여줍니다.</li><li><strong>장점:</strong> 큰 이미지를 디버깅하거나 최적화할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="15-docker-logs-since"><a class="markdownIt-Anchor" href="#15-docker-logs-since"></a> 15. <code>docker logs --since</code></h2><ul><li><strong>설명:</strong> 특정 시간 이후의 로그를 검색합니다.</li><li><strong>장점:</strong> 최근 업데이트 이후의 문제를 빠르게 찾을 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since <span class="string">"10m"</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p>내용이 많아, 다음 글에서 추가로 설명드리겠습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법</title>
      <link>http://hgko1207.github.io/2024/11/21/spring-8/</link>
      <guid>http://hgko1207.github.io/2024/11/21/spring-8/</guid>
      <pubDate>Thu, 21 Nov 2024 03:12:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 있을 것입니다.</p><h2 id="api-응답-구조가-왜-중요할까"><a class="markdownIt-Anchor" href="#api-응답-구조가-왜-중요할까"></a> API 응답 구조가 왜 중요할까?</h2><p>먼저, 잘 구조화된 API 응답이 왜 중요한지 살펴봅시다. 일관된 응답 구조는 다음과 같은 장점을 제공합니다:</p><ul><li><strong>클라이언트 측 에러 처리 개선:</strong> 프론트엔드 팀에서 크게 감사할 것입니다.</li><li><strong>가독성과 유지보수성 향상:</strong> 미래의 당신이나 팀이 명확함에 감동할 것입니다.</li><li><strong>디버깅과 로깅 간소화:</strong> 문제를 빠르고 효율적으로 파악할 수 있습니다.</li></ul><h2 id="좋은-api-응답의-조건"><a class="markdownIt-Anchor" href="#좋은-api-응답의-조건"></a> 좋은 API 응답의 조건</h2><p>잘 구조화된 API 응답은 다음과 같은 특징을 가져야 합니다:</p><ul><li><strong>일관성:</strong> 다양한 엔드포인트에서 동일한 형식 유지</li><li><strong>정보 제공:</strong> 관련 데이터, 메시지, 상태 코드 및 에러 코드를 포함</li><li><strong>단순함:</strong> 쉽게 파싱하고 이해할 수 있는 형식</li></ul><h2 id="이상적인-응답-구조-만들기"><a class="markdownIt-Anchor" href="#이상적인-응답-구조-만들기"></a> 이상적인 응답 구조 만들기</h2><h3 id="1-표준-응답-형식-정의"><a class="markdownIt-Anchor" href="#1-표준-응답-형식-정의"></a> 1. 표준 응답 형식 정의</h3><p>모든 API가 따를 표준 응답 형식을 먼저 정의합니다. 다음은 간단하면서도 효과적인 형식입니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"요청이 성공적으로 처리되었습니다."</span>,</span><br><span class="line">  "data": &#123; ... &#125;,</span><br><span class="line">  "errors": null,</span><br><span class="line">  "errorCode": 0,</span><br><span class="line">  "timestamp": 1633017600000,</span><br><span class="line">  "path": "/api/example"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 필드의 역할</p><ul><li><code>success</code>: (<code>boolean</code>) 요청이 성공했는지 여부를 나타냅니다.</li><li><code>message</code>: (<code>String</code>) 요청 처리 결과에 대한 사람이 읽을 수 있는 메시지를 제공합니다.</li><li><code>data</code>: (<code>T</code>) 클라이언트가 요청한 실제 데이터를 포함합니다.</li><li><code>errors</code>: (<code>List&lt;String&gt;</code>) 요청이 실패한 경우 발생한 에러 메시지 목록입니다.</li><li><code>errorCode</code>: (<code>int</code>) 비즈니스 로직 관련 에러 유형을 나타내는 코드입니다.</li><li><code>timestamp</code>: (<code>long</code>) 응답이 생성된 시간을 나타냅니다.</li><li><code>path</code>: (<code>String</code>) 호출된 API 엔드포인트를 나타냅니다.</li></ul><h3 id="2-응답-유틸리티-메서드-생성"><a class="markdownIt-Anchor" href="#2-응답-유틸리티-메서드-생성"></a> 2. 응답 유틸리티 메서드 생성</h3><p>코드 중복을 피하기 위해 응답을 생성하는 유틸리티 메서드를 만들어봅니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String message, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(data);</span><br><span class="line">        response.setErrors(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrorCode(<span class="number">0</span>);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(List&lt;String&gt; errors, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrors(errors);</span><br><span class="line">        response.setErrorCode(errorCode);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(String error, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error(Arrays.asList(error), message, errorCode, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-전역-예외-처리-구현"><a class="markdownIt-Anchor" href="#3-전역-예외-처리-구현"></a> 3. 전역 예외 처리 구현</h3><p>전역적으로 예외를 처리하면 처리되지 않은 에러도 표준 응답 형식으로 반환할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = Arrays.asList(ex.getMessage());</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(errors, <span class="string">"An error occurred"</span>, <span class="number">1000</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ResourceNotFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleResourceNotFoundException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ResourceNotFoundException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getMessage(), <span class="string">"Resource not found"</span>, <span class="number">1001</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ValidationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleValidationException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ValidationException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getErrors(), <span class="string">"Validation failed"</span>, <span class="number">1002</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-컨트롤러에서-응답-형식-사용"><a class="markdownIt-Anchor" href="#4-컨트롤러에서-응답-형식-사용"></a> 4. 컨트롤러에서 응답 형식 사용</h3><p>표준화된 응답 형식을 컨트롤러에서도 활용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/products"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; getProductById(<span class="meta">@PathVariable</span> Long id, HttpServletRequest request) &#123;</span><br><span class="line">        Product product = productService.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (product == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ResourceNotFoundException(<span class="string">"Product not found with id "</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(product, <span class="string">"Product fetched successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; createProduct(<span class="meta">@RequestBody</span> Product product, HttpServletRequest request) &#123;</span><br><span class="line">        Product createdProduct = productService.save(product);</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(createdProduct, <span class="string">"Product created successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="에러-코드의-예시"><a class="markdownIt-Anchor" href="#에러-코드의-예시"></a> 에러 코드의 예시</h2><p>아래는 전자상거래 애플리케이션에서 사용할 수 있는 에러 코드의 예입니다.</p><table><thead><tr><th>에러 코드</th><th>설명</th></tr></thead><tbody><tr><td>2000</td><td>재고 없음</td></tr><tr><td>2001</td><td>결제 수단 거부</td></tr><tr><td>2002</td><td>유효하지 않은 쿠폰 코드</td></tr><tr><td>2003</td><td>주문 취소 기간 초과</td></tr><tr><td>2004</td><td>계정 일시 정지</td></tr><tr><td>2005</td><td>동일 상품에 대한 중복 주문</td></tr></tbody></table><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법을 알아보았습니다. 위 단계를 구현하면 API가 더 깔끔하고 유지보수가 쉬워질 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/21/spring-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>시니어 개발자들이 절대 놓치지 않는 10가지 코딩 습관</title>
      <link>http://hgko1207.github.io/2024/11/19/info-31/</link>
      <guid>http://hgko1207.github.io/2024/11/19/info-31/</guid>
      <pubDate>Tue, 19 Nov 2024 05:46:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다루기 쉽게 유지하는 방법을 살펴봅시다.</p><h2 id="1-코드를-미래의-나를-위해-작성하라"><a class="markdownIt-Anchor" href="#1-코드를-미래의-나를-위해-작성하라"></a> 1. 코드를 미래의 나를 위해 작성하라</h2><p>새벽 3시에 디버깅해야 하는 상황을 상상해 보세요. x, y, temp 같은 이름을 사용하는 변수와 복잡하게 중첩된 함수들이 난잡하게 얽혀 있다면 고통스럽겠죠. 코드를 작성할 때는 미래의 자신이 코드를 리뷰한다고 생각하고 작성하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = x * y;</span><br><span class="line">  <span class="keyword">return</span> temp + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalPrice</span>(<span class="params">itemPrice, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalCost = itemPrice * quantity;</span><br><span class="line">  <span class="keyword">return</span> totalCost + <span class="number">5</span>; <span class="comment">// 배송비 포함</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>좋은 코드에서는 <code>itemPrice</code>, <code>quantity</code>, <code>totalCost</code> 같은 이름이 함수의 목적을 즉시 알 수 있게 해줍니다. 코드를 다시 살펴보지 않아도 이해할 수 있죠.</p><p>코드는 유지보수를 염두에 두고 작성해야 합니다. 구조, 의미 있는 이름, 논리적 흐름에 신경 써서 단순함을 추구하세요.</p><h2 id="2-이름-짓기는-중요하다"><a class="markdownIt-Anchor" href="#2-이름-짓기는-중요하다"></a> 2. 이름 짓기는 중요하다</h2><p>시니어 개발자는 변수, 함수, 클래스의 이름을 짓는 일이 중요하다는 것을 압니다. 모호한 이름은 혼란을 야기합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = fetchData();</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = fetchUserData();</span><br></pre></td></tr></table></figure><p>좋은 이름은 코드를 읽는 사람이 추가적인 맥락을 찾을 필요가 없게 만듭니다.</p><h2 id="3-중복을-피하라dry-그러나-과유불급은-피하라"><a class="markdownIt-Anchor" href="#3-중복을-피하라dry-그러나-과유불급은-피하라"></a> 3. 중복을 피하라(DRY), 그러나 과유불급은 피하라</h2><p>코드 중복은 시간 낭비를 초래합니다. DRY(Don’t Repeat Yourself) 원칙을 따르되, 지나친 추상화는 피하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tax = price * <span class="number">0.13</span>;</span><br><span class="line">  <span class="keyword">return</span> price + tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TAX_RATE = <span class="number">0.13</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * TAX_RATE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price + calculateTax(price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-무엇을-설명하는-대신-왜를-설명하라"><a class="markdownIt-Anchor" href="#4-무엇을-설명하는-대신-왜를-설명하라"></a> 4. '무엇’을 설명하는 대신 '왜’를 설명하라</h2><p>불필요한 주석은 코드 읽기를 방해합니다. 대신 복잡한 알고리즘의 이유나 가정 같은 맥락을 설명하세요.</p><p><strong>좋은 주석</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대규모 배열의 빠른 조회를 위해 이진 탐색 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">arr, target</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="5-단일-책임-원칙을-지켜라"><a class="markdownIt-Anchor" href="#5-단일-책임-원칙을-지켜라"></a> 5. 단일 책임 원칙을 지켜라</h2><p>함수는 하나의 작업만 수행해야 합니다. 이 원칙을 따르면 테스트가 쉬워지고, 코드가 더 읽기 쉽고 모듈화됩니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndProcessAndSaveUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"><a class="markdownIt-Anchor" href="#6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"></a> 6. 버전 관리는 필수다 (의미 있는 커밋 메시지와 함께)</h2><p>시니어 개발자는 의미 없는 커밋 메시지를 작성하지 않습니다.</p><p><strong>나쁜 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"버그 수정"</span></span><br></pre></td></tr></table></figure><p><strong>좋은 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"검증이 누락되어 사용자 세부 정보가 저장되지 않는 문제 해결"</span></span><br></pre></td></tr></table></figure><h2 id="7-에러를-우아하게-처리하라"><a class="markdownIt-Anchor" href="#7-에러를-우아하게-처리하라"></a> 7. 에러를 우아하게 처리하라</h2><p>애플리케이션이 충돌하며 “뭔가 잘못되었습니다” 같은 에러 메시지를 띄운다면, 이는 사용자 경험을 망칩니다. 의미 있는 에러 메시지와 로그를 제공하세요.</p><p><strong>나쁜 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  logError(error);</span><br><span class="line">  showErrorNotification(<span class="string">'문제가 발생했습니다. 나중에 다시 시도해주세요.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-테스트를-작성하라"><a class="markdownIt-Anchor" href="#8-테스트를-작성하라"></a> 8. 테스트를 작성하라</h2><p>테스트는 코드가 제대로 작동하는지 확인하는 중요한 도구입니다.</p><p><strong>테스트 없는 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> price = calculateTotal(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong>테스트 작성</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'calculateTotal'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should return the correct total'</span>, () =&gt; &#123;</span><br><span class="line">    expect(calculateTotal(<span class="number">100</span>)).toBe(<span class="number">115</span>); <span class="comment">// 15% 세금 포함</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-종속성-관리를-신중히-하라"><a class="markdownIt-Anchor" href="#9-종속성-관리를-신중히-하라"></a> 9. 종속성 관리를 신중히 하라</h2><p>불필요한 라이브러리 의존성은 프로젝트를 복잡하게 만들고, 보안 문제를 초래하며, 유지보수를 어렵게 합니다.</p><p><strong>나쁜 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure><p><strong>좋은 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash.debounce</span><br></pre></td></tr></table></figure><h2 id="10-정기적으로-과감하게-리팩터링하라"><a class="markdownIt-Anchor" href="#10-정기적으로-과감하게-리팩터링하라"></a> 10. 정기적으로 과감하게 리팩터링하라</h2><p>코드는 정원을 가꾸는 것과 같습니다. 정기적으로 구조를 개선하고 읽기 쉽게 최적화해야 합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; orderList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (orderList[i].status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// process the order</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterPendingOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> orderList.filter(<span class="function">(<span class="params">order</span>) =&gt;</span> order.status === <span class="string">'pending'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pendingOrders = filterPendingOrders(orderList);</span><br><span class="line">  pendingOrders.forEach(<span class="function">(<span class="params">order</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// process the order</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>위 10가지 실천법은 시니어 개발자의 작업 방식을 반영한 기본적인 습관들입니다. 이를 점진적으로 적용하면 더 깨끗하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 당신의 코드가 미래의 자신과 동료 개발자들에게 편리함을 제공하게 될 것입니다. 😉</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/info-31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>필수로 알아야할 13가지 SQL 문법</title>
      <link>http://hgko1207.github.io/2024/11/19/sql-1/</link>
      <guid>http://hgko1207.github.io/2024/11/19/sql-1/</guid>
      <pubDate>Tue, 19 Nov 2024 05:15:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Structured Query Language&lt;/strong&gt;(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Structured Query Language</strong>(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리 사용됩니다.</p><p>SQL은 데이터를 필터링, 정렬, 그룹화, 집계하는 등 다양한 데이터 조작 작업을 수행할 수 있는 강력한 도구입니다. 이 글에서는 데이터 과학 작업의 90%를 수행할 수 있는 13가지 필수 SQL 문법에 대해 다룹니다. 이러한 문법은 이해하기 쉽고 구현하기 쉬우며, SQL 작업의 기초를 다지는 데에 도움을 줍니다.</p><h2 id="1-select"><a class="markdownIt-Anchor" href="#1-select"></a> 1. SELECT</h2><p><code>SELECT</code> 문은 데이터베이스에서 하나 이상의 테이블에서 데이터를 조회하는 데 사용됩니다. <code>WHERE</code>, <code>ORDER BY</code>, <code>GROUP BY</code>와 같은 다양한 함수와 함께 사용하여 데이터를 필터링, 정렬, 그룹화하는 데 익숙해져야 합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>column1</code>, <code>column2</code>, <code>column3</code>는 조회하려는 열의 이름이며, <code>table_name</code>은 데이터를 포함한 테이블의 이름입니다. <code>WHERE</code> 절은 선택 사항이지만, 쿼리가 데이터를 조회하기 위해 충족해야 하는 조건을 지정하는 데 사용됩니다.</p><h3 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h3><p>고객 테이블에서 18세 이상인 모든 고객을 조회</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> age &gt;= <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h2 id="2-join"><a class="markdownIt-Anchor" href="#2-join"></a> 2. JOIN</h2><p><code>JOIN</code> 문은 데이터베이스의 두 개 이상의 테이블에서 데이터를 결합할 때 사용됩니다. 필요한 경우 적합한 JOIN 유형(예: <code>INNER</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>FULL OUTER</code>)을 지정해야 합니다.</p><h3 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> INNER JOIN</h3><p><code>INNER JOIN</code>은 두 테이블의 열에서 일치하는 행만 반환합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orders.order_id, customers.customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id = customers.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블과 <code>customers</code> 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 두 테이블의 <code>customer_id</code> 열에서 일치하는 데이터가 있는 경우에만 <code>order_id</code>와 <code>customer_name</code> 열이 포함됩니다.</p><h3 id="left-join"><a class="markdownIt-Anchor" href="#left-join"></a> LEFT JOIN</h3><p><code>LEFT JOIN</code>은 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 행을 반환합니다. 오른쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되고, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="right-join"><a class="markdownIt-Anchor" href="#right-join"></a> RIGHT JOIN</h3><p><code>RIGHT JOIN</code>은 오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 행을 반환합니다. 왼쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고, <code>customers</code> 테이블은 왼쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되고, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="outer-join"><a class="markdownIt-Anchor" href="#outer-join"></a> OUTER JOIN</h3><p><code>OUTER JOIN</code>은 두 테이블 중 하나 또는 두 테이블의 모든 행을 반환하며, 일치하지 않는 행도 포함합니다. <code>LEFT OUTER JOIN</code>과 <code>RIGHT OUTER JOIN</code> 두 가지 유형이 있습니다.</p><h4 id="left-outer-join-예제"><a class="markdownIt-Anchor" href="#left-outer-join-예제"></a> LEFT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되며, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h4 id="right-outer-join-예제"><a class="markdownIt-Anchor" href="#right-outer-join-예제"></a> RIGHT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고 <code>customers</code> 테이블은 왼쪽 테이블입니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되며, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><p><strong>참고:</strong> 일부 데이터베이스는 <code>RIGHT OUTER JOIN</code>을 지원하지 않을 수 있습니다. 이 경우, <code>LEFT OUTER JOIN</code>을 사용하고 테이블의 순서를 바꾸어 동일한 결과를 얻을 수 있습니다.</p><h2 id="3-where"><a class="markdownIt-Anchor" href="#3-where"></a> 3. WHERE</h2><p><code>WHERE</code> 문은 지정된 조건에 따라 데이터를 필터링하는 데 사용됩니다. 특정 기준을 충족하는 데이터만 조회하려면 <code>WHERE</code> 문을 능숙하게 사용하는 것이 중요합니다.</p><p>아래는 테이블에서 데이터를 필터링하기 위해 <code>WHERE</code> 문을 사용하는 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, department, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department = <span class="string">'Sales'</span> <span class="keyword">AND</span> salary &gt; <span class="number">50000</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “Sales” 부서에서 근무하며 급여가 $50,000 이상인 모든 직원의 이름, 부서, 급여를 결과로 반환합니다.</p><h2 id="4-group-by"><a class="markdownIt-Anchor" href="#4-group-by"></a> 4. GROUP BY</h2><p><code>GROUP BY</code> 문은 하나 이상의 열을 기준으로 데이터를 그룹화하며, <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>와 같은 집계 함수를 사용하여 그룹화된 데이터의 요약 정보를 계산할 수 있습니다. GROUP BY를 활용하여 카테고리별로 데이터를 분석하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="keyword">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 부서와 각 부서의 평균 급여를 반환합니다. 각 부서의 평균 급여는 해당 부서 직원들의 모든 급여 합계를 직원 수로 나눈 값으로 계산됩니다. <code>GROUP BY</code> 절은 부서별로 직원을 그룹화하는 데 사용되며, <code>AVG</code> 함수는 각 부서의 평균 급여를 계산하는 데 사용됩니다.</p><table><thead><tr><th>Department</th><th>Avg Salary</th></tr></thead><tbody><tr><td>Sales</td><td>65,000</td></tr><tr><td>Marketing</td><td>55,000</td></tr><tr><td>Engineering</td><td>80,000</td></tr></tbody></table><p>위 예제에서, <strong>Sales</strong> 부서는 평균 급여가 $65,000, <strong>Marketing</strong> 부서는 $55,000, <strong>Engineering</strong> 부서는 $80,000임을 확인할 수 있습니다.</p><h2 id="5-having"><a class="markdownIt-Anchor" href="#5-having"></a> 5. HAVING</h2><p><code>HAVING</code> 문은 <code>GROUP BY</code>로 그룹화된 데이터를 특정 조건에 따라 필터링하는 데 사용됩니다. 그룹화된 데이터를 추가로 필터링하는 방법을 숙달하는 것이 중요합니다.</p><p>아래는 <code>HAVING</code> 절을 사용하는 SQL 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantity) &gt;= <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 고객과 그들이 주문한 총 제품 수량을 반환하지만, 총 수량이 50단위 이상인 고객만 결과에 포함됩니다. <code>GROUP BY</code> 절은 고객별로 주문을 그룹화하는 데 사용되고, <code>SUM</code> 함수는 각 고객이 주문한 제품의 총 수량을 계산하는 데 사용됩니다. 마지막으로 <code>HAVING</code> 절은 결과를 필터링하여 조건을 만족하는 데이터만 반환합니다.</p><h2 id="6-윈도우-함수-window-function"><a class="markdownIt-Anchor" href="#6-윈도우-함수-window-function"></a> 6. 윈도우 함수 (Window Function)</h2><p>SQL에서 윈도우 함수는 현재 행과 관련된 행 집합에 대해 계산을 수행하는 데 사용됩니다. 이러한 함수는 지정된 조건이나 파티션에 기반한 테이블의 일부 행(윈도우)에 적용됩니다. 아래는 SQL에서 윈도우 함수를 사용하는 몇 가지 예제입니다.</p><h3 id="1-row_number"><a class="markdownIt-Anchor" href="#1-row_number"></a> 1. <code>ROW_NUMBER()</code></h3><p><code>ROW_NUMBER()</code> 함수는 각 파티션 내에서 각 행에 고유한 순차 번호를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>row_num</code>이라는 추가 열을 포함하며, 이 열은 <code>column1</code>의 순서에 따라 각 행에 순차적으로 번호를 부여합니다.</p><h3 id="2-sum"><a class="markdownIt-Anchor" href="#2-sum"></a> 2. <code>SUM()</code></h3><p><code>SUM()</code> 함수는 각 파티션 내에서 특정 열의 합계를 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_sum</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_sum</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 합계를 계산합니다.</p><h3 id="3-rank"><a class="markdownIt-Anchor" href="#3-rank"></a> 3. <code>RANK()</code></h3><p><code>RANK()</code> 함수는 특정 열의 값에 따라 각 파티션 내에서 각 행에 순위를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column3 <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>rank_num</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column3</code> 값을 기준으로 내림차순 정렬된 순위를 나타냅니다.</p><h3 id="4-avg"><a class="markdownIt-Anchor" href="#4-avg"></a> 4. <code>AVG()</code></h3><p><code>AVG()</code> 함수는 각 파티션 내에서 특정 열의 평균을 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">AVG</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_avg</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_avg</code>라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 평균을 계산합니다.</p><h3 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h3><p>윈도우 함수의 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다. 사용하려는 DBMS의 문서를 참고하여 정확한 문법을 확인하는 것이 좋습니다.</p><h2 id="7-union"><a class="markdownIt-Anchor" href="#7-union"></a> 7. UNION</h2><p>SQL에서 <code>UNION</code> 연산자는 두 개 이상의 <code>SELECT</code> 문의 결과를 하나의 결과 집합으로 결합하는 데 사용됩니다. 각 <code>SELECT</code> 문은 동일한 열 개수와 호환 가능한 데이터 유형을 가져야 합니다. 결과 집합에서는 중복된 행이 자동으로 제거됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 뉴욕에 거주하는 모든 사람(고객과 직원 포함)의 목록을 반환합니다. 첫 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 고객을 조회하며, 두 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 직원을 조회합니다. <code>UNION</code> 연산자는 이 두 <code>SELECT</code> 문의 결과를 결합하고 중복된 행을 제거합니다.</p><h2 id="8-create"><a class="markdownIt-Anchor" href="#8-create"></a> 8. CREATE</h2><p><code>CREATE</code> 문은 새로운 데이터베이스 테이블, 뷰 또는 기타 데이터베이스 객체를 생성하는 데 사용됩니다. 새로운 테이블, 뷰, 기타 객체를 생성하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 쿼리는 &quot;customers&quot;라는 이름의 새 테이블을 생성하며, 네 개의 열(“id”, “name”, “email”, “phone”)을 포함합니다.</p><ul><li><strong>id:</strong> 정수형으로 설정되며, 테이블의 기본 키로 지정됩니다.</li><li><strong>name:</strong> 최대 50자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>email:</strong> 최대 100자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>phone:</strong> 최대 20자까지 저장할 수 있는 문자열로 설정됩니다.</li></ul><h2 id="9-insert"><a class="markdownIt-Anchor" href="#9-insert"></a> 9. INSERT</h2><p><code>INSERT</code> 문은 데이터베이스 테이블에 새 데이터를 삽입하는 데 사용됩니다. 테이블에 데이터를 추가하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, <span class="keyword">name</span>, major, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1234</span>, <span class="string">'John Doe'</span>, <span class="string">'Computer Science'</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음 값으로 새 행을 “students” 테이블에 삽입합니다:</p><ul><li><strong>id:</strong> 1234</li><li><strong>name:</strong> John Doe</li><li><strong>major:</strong> Computer Science</li><li><strong>gpa:</strong> 3.5</li></ul><p><code>INSERT</code> 문은 데이터를 삽입하려는 테이블의 이름을 지정하고, 삽입할 열 목록을 작성한 뒤, <code>VALUES</code> 키워드를 사용해 해당 열에 삽입할 값을 순서대로 지정합니다.</p><h2 id="10-update"><a class="markdownIt-Anchor" href="#10-update"></a> 10. UPDATE</h2><p><code>UPDATE</code> 문은 데이터베이스 테이블의 기존 데이터를 수정하는 데 사용됩니다. 테이블의 하나 이상의 열 값을 업데이트하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> major = <span class="string">'Mathematics'</span>, gpa = <span class="number">3.7</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음과 같은 작업을 수행합니다:</p><ul><li><strong>major</strong> 열의 값을 'Mathematics’로 업데이트</li><li><strong>gpa</strong> 열의 값을 3.7로 업데이트</li><li><strong>WHERE</strong> 절을 사용하여 ID가 1234인 행만 업데이트</li></ul><p><code>UPDATE</code> 문은 업데이트하려는 테이블의 이름을 지정한 후, <code>SET</code> 키워드를 사용하여 업데이트할 열과 새 값을 나열합니다. 특정 행만 업데이트하려면 <code>WHERE</code> 절을 사용하여 조건을 지정해야 합니다.</p><h2 id="11-delete"><a class="markdownIt-Anchor" href="#11-delete"></a> 11. DELETE</h2><p><code>DELETE</code> 문은 데이터베이스 테이블에서 하나 이상의 행을 삭제하는 데 사용됩니다. 테이블에서 데이터를 제거하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “students” 테이블에서 ID가 1234인 행을 제거합니다.</p><ul><li><code>DELETE FROM</code>은 데이터를 삭제하려는 테이블의 이름을 지정합니다.</li><li><code>WHERE</code> 절은 삭제할 행을 지정하는 조건을 나타냅니다. 이 경우, ID가 1234인 행을 삭제하도록 설정했습니다.</li></ul><h2 id="12-drop"><a class="markdownIt-Anchor" href="#12-drop"></a> 12. DROP</h2><p><code>DROP</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체를 삭제하는 데 사용됩니다. 불필요한 테이블이나 기타 객체를 데이터베이스에서 제거하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-drop-table"><a class="markdownIt-Anchor" href="#1-drop-table"></a> 1. DROP TABLE</h3><p>기존 테이블과 해당 테이블의 모든 데이터 및 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="2-drop-index"><a class="markdownIt-Anchor" href="#2-drop-index"></a> 2. DROP INDEX</h3><p>테이블에서 기존 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="3-drop-view"><a class="markdownIt-Anchor" href="#3-drop-view"></a> 3. DROP VIEW</h3><p>기존의 뷰(View)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure><h3 id="4-drop-procedure"><a class="markdownIt-Anchor" href="#4-drop-procedure"></a> 4. DROP PROCEDURE</h3><p>기존의 저장 프로시저(Stored Procedure)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br></pre></td></tr></table></figure><h3 id="주의-사항"><a class="markdownIt-Anchor" href="#주의-사항"></a> 주의 사항</h3><ul><li><code>DROP</code> 문은 지정된 객체와 관련된 모든 데이터 및 인덱스를 <strong>영구적으로 삭제</strong>합니다.</li><li>삭제된 데이터나 객체는 복구할 수 없으므로, 삭제 작업을 실행하기 전에 데이터를 반드시 백업해야 합니다.</li><li>사용하는 데이터베이스 관리 시스템(DBMS)에 따라 <code>DROP</code> 문의 정확한 문법이 다를 수 있으므로, 사용하는 DBMS의 문서를 참조하는 것이 좋습니다.</li></ul><h2 id="13-alter"><a class="markdownIt-Anchor" href="#13-alter"></a> 13. ALTER</h2><p><code>ALTER</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체의 구조를 수정하는 데 사용됩니다. 열 추가 및 삭제, 데이터 유형 변경, 제약 조건 설정 등 다양한 작업을 수행하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-alter-table"><a class="markdownIt-Anchor" href="#1-alter-table"></a> 1. ALTER TABLE</h3><p>기존 테이블의 구조를 수정합니다. 열을 추가하거나 삭제하고, 데이터 유형을 변경하거나 제약 조건을 설정하는 데 사용됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">MODIFY</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">DROP</span> column_name,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name constraint_definition,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></table></figure><p>테이블에 새로운 열 추가</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">ADD</span> phone_number <span class="built_in">VARCHAR</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>기존 열 삭제</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> phone_number;</span><br></pre></td></tr></table></figure><h3 id="2-alter-index"><a class="markdownIt-Anchor" href="#2-alter-index"></a> 2. ALTER INDEX</h3><p>기존 인덱스의 구조를 수정합니다. 열을 추가하거나 제거하고, 인덱스 유형을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ADD</span> column_name,</span><br><span class="line"><span class="keyword">DROP</span> column_name;</span><br></pre></td></tr></table></figure><h3 id="3-alter-view"><a class="markdownIt-Anchor" href="#3-alter-view"></a> 3. ALTER VIEW</h3><p>기존 뷰(View)의 정의를 수정합니다. 생성 시 사용된 <code>SELECT</code> 문을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">AS</span> select_statement;</span><br></pre></td></tr></table></figure><h3 id="참고-2"><a class="markdownIt-Anchor" href="#참고-2"></a> 참고</h3><ul><li><code>ALTER</code> 문의 정확한 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다.</li><li>구조를 수정하는 작업은 데이터 무결성에 영향을 미칠 수 있으므로, 변경 전에 데이터베이스 구조와 데이터에 미치는 영향을 철저히 검토해야 합니다.</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/sql-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 컴포넌트 작성, 전문가처럼!</title>
      <link>http://hgko1207.github.io/2024/11/12/react-19/</link>
      <guid>http://hgko1207.github.io/2024/11/12/react-19/</guid>
      <pubDate>Tue, 12 Nov 2024 06:08:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/react-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/react-19.png" alt="" /></p><p><strong>React</strong>에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포넌트를 만드는 예술입니다. 오늘은 React 컴포넌트를 전문가처럼 작성하는 방법을 알아보며, 가독성, 재사용성, 효율성에 중점을 두고 설명해드리겠습니다.</p><h2 id="1-기본-list-컴포넌트-만들기"><a class="markdownIt-Anchor" href="#1-기본-list-컴포넌트-만들기"></a> 1. 기본 List 컴포넌트 만들기</h2><p>먼저, 간단한 <code>List</code> 컴포넌트부터 시작해 보겠습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/List.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> List;</span><br></pre></td></tr></table></figure><p>이 컴포넌트는 배열 형태의 <code>data</code>를 받아 이를 목록 형태로 렌더링합니다.</p><h2 id="2-hoc로-컴포넌트-확장하기"><a class="markdownIt-Anchor" href="#2-hoc로-컴포넌트-확장하기"></a> 2. HOC로 컴포넌트 확장하기</h2><p>고차 컴포넌트(Higher-Order Components, HOC)는 컴포넌트의 구조를 변경하지 않고 기능을 확장할 수 있는 강력한 패턴입니다. HOC는 다른 컴포넌트를 감싸 추가적인 기능을 제공하도록 설계되었습니다.</p><p>예를 들어, <code>withLoading</code> HOC를 사용해 로딩 상태를 표시하는 방법은 다음과 같습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withLoading.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithLoading</span>(<span class="params">&#123; isLoading, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLoading;</span><br></pre></td></tr></table></figure><p>이 HOC는 <code>isLoading</code> prop을 확인하여, <code>isLoading</code>이 <code>true</code>일 때는 “Loading…” 메시지를, 그렇지 않을 때는 감싼 컴포넌트를 렌더링합니다. 이를 통해 데이터 로딩 중에도 사용자 경험을 자연스럽게 유지할 수 있습니다.</p><p>비슷하게, <code>withErrorHandling</code> HOC를 사용해 에러 상태를 관리할 수도 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withErrorHandling.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withErrorHandling</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithErrorHandling</span>(<span class="params">&#123; error, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withErrorHandling;</span><br></pre></td></tr></table></figure><p>에러가 발생하면 <code>withErrorHandling</code>은 에러 메시지를 표시하고, 그렇지 않으면 컴포넌트를 일반적으로 렌더링합니다. 이 HOC는 데이터 가져오기(fetch) 오류 또는 컴포넌트 수명 주기 내에서 발생하는 문제를 처리하는 데 유용합니다.</p><p>이제 <code>withLoading</code>과 <code>withErrorHandling</code>을 결합해 로딩과 에러 상태를 모두 처리할 수 있는 컴포넌트를 만들 수 있습니다. 이 접근법은 코드 재사용과 관심사 분리를 촉진하여, 컴포넌트의 유지 보수를 더 용이하게 하고 이해하기 쉽게 만듭니다.</p><h2 id="3-hooks로-데이터-가져오기"><a class="markdownIt-Anchor" href="#3-hooks로-데이터-가져오기"></a> 3. Hooks로 데이터 가져오기</h2><p>React의 hooks는 클래스 없이도 상태나 기타 React 기능을 사용할 수 있게 합니다. <code>useFetch</code>는 API에서 데이터를 가져오는 커스텀 훅입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hooks/useFetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useFetch = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setLoading(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">        <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Network response was not ok'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">        setData(json);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setError(error);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클린업 함수</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 필요 시 클린업 로직 작성</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useFetch;</span><br></pre></td></tr></table></figure><p>이 훅은 로딩 상태, 데이터 저장, 에러 처리를 담당하여, 컴포넌트에서 데이터를 쉽게 가져와 표시할 수 있도록 합니다.</p><h2 id="4-앱-구성하기"><a class="markdownIt-Anchor" href="#4-앱-구성하기"></a> 4. 앱 구성하기</h2><p>마지막으로, 모든 요소를 <code>App</code> 컴포넌트에 통합합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLoading <span class="keyword">from</span> <span class="string">'./hocs/withLoading'</span>;</span><br><span class="line"><span class="keyword">import</span> withErrorHandling <span class="keyword">from</span> <span class="string">'./hocs/withErrorHandling'</span>;</span><br><span class="line"><span class="keyword">import</span> useFetch <span class="keyword">from</span> <span class="string">'./hooks/useFetch'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./components/List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ListWithLoading = withLoading(List);</span><br><span class="line"><span class="keyword">const</span> ListWithErrorHandling = withErrorHandling(ListWithLoading);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, error &#125; = useFetch(<span class="string">'https://api.example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;List Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ListWithErrorHandling data=&#123;data&#125; isLoading=&#123;isLoading&#125; error=&#123;error&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>useFetch</code> 훅을 사용하여 데이터를 로드하고, <code>List</code> 컴포넌트에 전달합니다. 이 <code>List</code> 컴포넌트는 <code>withLoading</code>과 <code>withErrorHandling</code> HOC로 확장되어 로딩과 에러 상태를 처리합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>프로처럼 컴포넌트를 작성하는 것은 전체적인 그림을 보는 것에서 시작됩니다. 가독성, 유지보수성, 재사용성이 높은 컴포넌트를 만드는 것이 핵심입니다. HOC와 hooks 같은 패턴을 사용하면, 시간이 지나도 견고하고 효율적인 코드베이스를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/12/react-19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>주말에 만들 수 있는 5가지 AI 프로젝트 (Python 사용)</title>
      <link>http://hgko1207.github.io/2024/10/29/python-10/</link>
      <guid>http://hgko1207.github.io/2024/10/29/python-10/</guid>
      <pubDate>Tue, 29 Oct 2024 05:26:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디어를 공유합니다. 각 아이디어를 구현하는 데 필요한 단계와 Python 라이브러리를 설명해드리겠습니다.</p><p>프로젝트 아이디어를 생각할 때, 초보자들이 가장 많이 하는 실수는 &quot;<strong>이 새로운 기술을 어떻게 사용할 수 있을까?</strong>&quot;라는 질문에서 시작하는 것입니다. 물론, 새로운 도구를 배우는 방법으로는 괜찮지만, 더 나은 접근법이 있습니다.</p><p>좋은 프로젝트 아이디어는 &quot;<strong>내가 해결할 수 있는 문제가 무엇인가?</strong>&quot;라는 질문에서 시작됩니다. 문제 해결은 기술을 가치로 전환하는 방법이며, 잠재적 고용주에게도 설득력 있는 스토리가 됩니다.</p><p>다음 프로젝트들은 모두 이 문제 해결 접근법을 따릅니다. 아이디어를 그대로 구현하거나, 더 나아가 개인적으로 해결하고 싶은 문제에 적용할 수도 있습니다.</p><h2 id="1-이력서-최적화-초급">1) 이력서 최적화 (초급)</h2><p>구직 활동에서 시간이 많이 소요되는 작업 중 하나는 각 채용 공고에 맞게 이력서를 조정하는 것입니다. 과거에는 이러한 작업을 자동화하는 것이 고급 프로젝트에 속했지만, 오늘날의 LLM(Large Language Model) 덕분에 이제는 간단한 API 호출만으로도 해결할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>이력서를 Markdown 형식으로 작성합니다. (참고: ChatGPT를 통해 이 작업을 쉽게 할 수 있습니다).</li><li>Markdown 이력서와 채용 공고를 받아 새롭게 이력서를 작성하는 다양한 프롬프트 템플릿을 실험해봅니다.</li><li>OpenAI의 Python API를 사용해 GPT-4o-mini를 통해 이력서를 동적으로 수정합니다.</li><li><code>markdown</code> 및 <code>pdfkit</code> 라이브러리를 각각 사용하여 Markdown 파일을 HTML과 PDF로 변환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>markdown</code>, <code>pdfkit</code></p><p>ChatGPT를 통해 간단히 이 작업을 처리할 수 있지만, Python으로 구현하면 더 쉽게 대규모 처리를 할 수 있습니다. 아래는 Step 3의 시작 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = <span class="string">"your_sk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 프롬프트 (md_resume 및 job_desciption이 정의되어 있다고 가정)</span></span><br><span class="line">prompt = <span class="string">f"""</span></span><br><span class="line"><span class="string">Markdown 형식의 이력서와 채용 공고가 있습니다. \</span></span><br><span class="line"><span class="string">이력서를 채용 요구 사항에 더 잘 맞게 조정해 주세요. \</span></span><br><span class="line"><span class="string">필요한 기술, 경험, 성과를 강조하여 이력서를 수정해 주세요. \</span></span><br><span class="line"><span class="string">이력서에는 여전히 나만의 독특한 자격과 강점이 반영되도록 하되, \</span></span><br><span class="line"><span class="string">채용 공고와 일치하는 기술과 경험이 강조되도록 해주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 내 이력서 (Markdown 형식):</span></span><br><span class="line"><span class="string"><span class="subst">&#123;md_resume&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 채용 공고:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;job_desciption&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이력서를 수정해 주세요:</span></span><br><span class="line"><span class="string">- 채용 공고의 키워드와 구문을 사용하세요.</span></span><br><span class="line"><span class="string">- 각 역할 아래에 관련 기술과 성과를 강조하세요.</span></span><br><span class="line"><span class="string">- 나의 경험이 요구되는 자격에 맞게 잘 나타나도록 수정해 주세요.</span></span><br><span class="line"><span class="string">- 명확성, 간결성, 그리고 전문성을 유지하세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">업데이트된 이력서를 Markdown 형식으로 반환해 주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API 호출</span></span><br><span class="line">response = openai.chat.completions.create(</span><br><span class="line">    model=<span class="string">"gpt-4o-mini"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are a helpful assistant."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: prompt&#125;</span><br><span class="line">    ],</span><br><span class="line">    temperature = <span class="number">0.25</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 응답 추출</span></span><br><span class="line">resume = response.choices[<span class="number">0</span>].message.content</span><br></pre></td></tr></table></figure><p>참고: ChatGPT는 짧은 코드 스니펫(및 프롬프트)을 작성할 때 매우 유용합니다. Step 4에서 막히면 ChatGPT에 도움을 요청해 보세요!</p><h2 id="2-YouTube-강의-요약-도구-초급">2) YouTube 강의 요약 도구 (초급)</h2><p>기술 강연을 YouTube의 “<strong>나중에 보기</strong>” 목록에 추가해 두는 것을 좋아하지만, 나중에 보려다 보지 못할 때가 많습니다. 이러한 문제를 해결하기 위해 동영상을 대신 시청하고 주요 포인트로 구성된 요약을 생성해 주는 도구를 만들 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li>정규 표현식을 사용하여 YouTube 비디오 링크에서 비디오 ID를 추출합니다.</li><li><code>youtube-transcript-api</code>를 사용해 비디오 ID로 트랜스크립트를 추출합니다.</li><li>트랜스크립트를 효과적으로 요약하는 다양한 ChatGPT 프롬프트를 실험해 봅니다.</li><li>OpenAI의 Python API를 사용하여 이 과정을 자동화합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>youtube-transcript-api</code></p><p>기술적으로, 이 프로젝트는 앞서 소개한 프로젝트와 유사합니다. 다만, 이 프로젝트에서는 비디오 트랜스크립트를 자동으로 추출하여 언어 모델(LLM)에 입력해야 한다는 점이 다릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> youtube_transcript_api <span class="keyword">import</span> YouTubeTranscriptApi</span><br><span class="line"></span><br><span class="line">youtube_url = <span class="string">"video link here"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 정규 표현식으로 비디오 ID 추출</span></span><br><span class="line">video_id_regex = <span class="string">r'(?:v=|\/)([0-9A-Za-z_-]&#123;11&#125;).*'</span></span><br><span class="line">match = re.search(video_id_regex, youtube_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    <span class="keyword">return</span> match.group(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 트랜스크립트 추출</span></span><br><span class="line">text_list = [transcript[i][<span class="string">'text'</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(transcript))]</span><br><span class="line">transcript_text = <span class="string">'\n'</span>.join(text_list)</span><br></pre></td></tr></table></figure><h2 id="3-PDF-자동-정리-도구-중급">3) PDF 자동 정리 도구 (중급)</h2><p>데스크탑에는 정리되지 않은 논문(PDF)들이 쌓여 있을 수 있습니다. 수동으로 이러한 논문을 검토하는 것은 시간이 많이 걸리기 때문에, AI를 활용해 보겠습니다.</p><p>데스크탑에 있는 각 PDF의 내용을 분석하고 주제별로 폴더를 만들어 자동으로 정리하는 도구를 구축할 수 있습니다. 텍스트 임베딩을 사용해 각 논문을 밀집 벡터 표현으로 변환한 뒤, 유사한 논문끼리 K-Means와 같은 전통적인 머신러닝 알고리즘으로 클러스터링할 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li><code>PyMuPDF</code>를 사용하여 각 논문의 초록을 읽습니다.</li><li><code>sentence-transformers</code> 라이브러리를 사용하여 초록을 텍스트 임베딩으로 변환하고, 이를 Pandas 데이터프레임에 저장합니다.</li><li><code>sklearn</code>의 선호하는 클러스터링 알고리즘을 사용하여 임베딩을 유사성 기반으로 그룹화합니다.</li><li>각 클러스터에 대한 폴더를 생성하고, 파일을 해당 폴더로 이동합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>sentence_transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 핵심 단계는 텍스트 임베딩 생성입니다. 다음은 <code>sentence_transformers</code>를 사용하여 임베딩을 생성하는 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 모델 로드</span></span><br><span class="line">model = SentenceTransformer(<span class="string">"all-MiniLM-L6-v2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록을 목록에 저장</span></span><br><span class="line">abstract_list = [<span class="string">"abstract 1"</span>, <span class="string">"abstract 2"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 계산</span></span><br><span class="line">embeddings = model.encode(abstract_list)</span><br></pre></td></tr></table></figure><h2 id="4-멀티모달-검색-시스템-중급">4) 멀티모달 검색 시스템 (중급)</h2><p>특정 기술 보고서들을 위한 기본적인 RAG(검색 증강 생성) 시스템을 구축할 때, 보고서의 주요 정보가 <strong>텍스트가 아닌 플롯과 그림</strong>으로 표현되는 경우가 많아 검색에 어려움을 겪을 수 있습니다.</p><p>시각적 정보를 검색 과정에 포함시키기 위해 <strong>텍스트와 이미지를 동일한 공간에 표현하는 멀티모달 임베딩 모델</strong>을 사용하는 방법이 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>PDF를 섹션별로 나누고, PyMuPDF를 사용해 이미지를 추출합니다.</li><li>nomic-ai/nomic-embed-text-v1.5와 같은 멀티모달 임베딩 모델을 사용해 각 섹션과 이미지를 밀집 벡터로 표현하고, 데이터프레임에 저장합니다.</li><li>지식 베이스에 있는 모든 PDF에 대해 이 작업을 반복합니다.</li><li>사용자가 쿼리를 입력하면 지식 베이스에서 사용한 동일한 임베딩 모델을 통해 쿼리를 임베딩으로 변환합니다.</li><li>쿼리 임베딩과 지식 베이스 항목의 임베딩 간 코사인 유사도 점수를 계산합니다.</li><li>상위 k개의 결과를 반환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 중요한 부분은 PDF를 어떻게 나누느냐에 있습니다. 가장 간단한 방법은 고정된 문자 수를 기준으로 약간의 중첩을 포함하여 나누는 것입니다. 또한, 각 청크에 파일 이름과 페이지 번호 같은 메타데이터를 포함하는 것이 유용합니다.</p><p>아래는 기본 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz  <span class="comment"># PyMuPDF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_text_chunks</span><span class="params">(pdf_path, chunk_size, overlap_size)</span>:</span></span><br><span class="line">    <span class="comment"># PDF 파일 열기</span></span><br><span class="line">    pdf_document = fitz.open(pdf_path)</span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 각 페이지를 반복하여 처리</span></span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> range(len(pdf_document)):</span><br><span class="line">        page = pdf_document[page_num]</span><br><span class="line">        page_text = page.get_text()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 현재 페이지의 텍스트를 중첩을 포함하여 청크로 분할</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; len(page_text):</span><br><span class="line">            end = start + chunk_size</span><br><span class="line">            chunk = page_text[start:end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 청크와 페이지 번호 저장</span></span><br><span class="line">            chunks.append((page_num + <span class="number">1</span>, chunk))</span><br><span class="line">            <span class="comment"># 중첩 크기만큼 이동하여 다음 청크 설정</span></span><br><span class="line">            start += chunk_size - overlap_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 추출 매개 변수 설정</span></span><br><span class="line">pdf_path = <span class="string">"your_file.pdf"</span></span><br><span class="line">chunk_size = <span class="number">1000</span>  <span class="comment"># 각 텍스트 청크의 크기 (문자 수 기준)</span></span><br><span class="line">overlap_size = <span class="number">200</span>  <span class="comment"># 중첩 크기 (문자 수 기준)</span></span><br><span class="line"></span><br><span class="line">text_chunks = extract_text_chunks(pdf_path, chunk_size, overlap_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 페이지 번호와 함께 청크 출력</span></span><br><span class="line"><span class="keyword">for</span> i, (page_number, chunk) <span class="keyword">in</span> enumerate(text_chunks):</span><br><span class="line">    print(<span class="string">f"청크 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (페이지 <span class="subst">&#123;page_number&#125;</span>):\n<span class="subst">&#123;chunk&#125;</span>\n<span class="subst">&#123;<span class="string">'-'</span> * <span class="number">50</span>&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-지식-기반-질문-응답-QA-시스템-고급">5) 지식 기반 질문-응답(QA) 시스템 (고급)</h2><p>가장 자주 요청받은 프로젝트가 바로 문서 질문-응답(QA) 시스템입니다. 이전 프로젝트를 기반으로, 이를 간단하게 구현할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>지식 베이스에서 검색을 수행합니다 (프로젝트 4에서 만든 것처럼).</li><li>사용자 쿼리와 상위 k개의 검색 결과를 결합하여 멀티모달 모델에 전달합니다.</li><li>질문-응답 시스템을 위한 간단한 Gradio 사용자 인터페이스를 생성합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code>, <code>together/openai</code>, <code>Gradio</code></p><p>참고: Together AI의 API를 통해 Llama 3.2 Vision을 2025년까지 무료로 사용할 수 있습니다.</p><p>이 프로젝트는 본질적으로 프로젝트 2와 4를 결합한 형태입니다. 그러나 여기에는 사용자 인터페이스가 필수 요소로 포함됩니다. Gradio와 같은 대시보드 도구를 사용하여 간단한 채팅 UI를 몇 줄의 코드로 만들 수 있습니다.</p><p>아래는 Gradio의 문서에서 가져온 예시 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_response</span><span class="params">(message, history)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        응답을 생성하는 코드 작성</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">demo = gr.ChatInterface(</span><br><span class="line">    fn=generate_response,</span><br><span class="line">    examples=[&#123;<span class="string">"text"</span>: <span class="string">"Hello"</span>, <span class="string">"files"</span>: []&#125;],</span><br><span class="line">    title=<span class="string">"Echo Bot"</span>,</span><br><span class="line">    multimodal=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">demo.launch()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/python-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>효율적인 .NET 개발을 위한 4가지 필수 라이브러리 소개</title>
      <link>http://hgko1207.github.io/2024/10/29/csharp-14/</link>
      <guid>http://hgko1207.github.io/2024/10/29/csharp-14/</guid>
      <pubDate>Tue, 29 Oct 2024 04:49:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 &lt;strong&gt;.NET Core&lt;/strong&gt;를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 <strong>.NET Core</strong>를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 앞으로 모든 .NET 릴리스의 기초로 .NET Core를 활용하겠다고 밝혔고, 오픈 소스 기여는 .NET Foundation의 가이드 하에 이루어지게 되었습니다.</p><p>.NET Core는 큰 성공을 거두었고, 2020년에는 .NET Framework와 .NET Core가 하나의 오픈 소스 크로스 플랫폼 기술로 통합된 .NET 5가 출시되었습니다.</p><p>오픈 소스로 전환됨에 따라 .NET 플랫폼에는 활기 넘치는 커뮤니티가 형성되었습니다. 많은 뛰어난 개발자들이 고품질의 도구와 라이브러리를 게시해 개발자들의 일상 업무를 한결 쉽게 만들고 있습니다.</p><p>이번 글에서는 새 프로젝트를 시작할 때 꼭 설치하는 필수 라이브러리 4가지를 소개하고자 합니다.</p><h2 id="1-Refit">1. Refit</h2><p>.NET에서 HTTP 요청을 다루는 작업은 상당히 많은 수작업과 반복되는 코드를 요구합니다. 예를 들어 <code>HttpClient</code> 클래스를 직접 구현해 요청을 처리하는 코드는 다음과 같습니다</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> GetUserAsync(<span class="number">123</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"User Name: <span class="subst">&#123;user.Name&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 필요한 경우 기본 주소와 기본 헤더를 설정합니다.</span></span><br><span class="line">        client.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://api.example.com/"</span>);</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Clear();</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Add(<span class="keyword">new</span> MediaTypeWithQualityHeaderValue(<span class="string">"application/json"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 요청하기</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">$"users/<span class="subst">&#123;userId&#125;</span>"</span>);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 응답 역직렬화</span></span><br><span class="line">        <span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;User&gt;(responseBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같은 구현 방식은 복잡하고, 반복적인 코드가 많아지기 쉽습니다.</p><p><strong>Refit</strong>은 이런 작업을 간편하게 해주는 라이브러리입니다. 단순히 인터페이스를 정의하여 REST API를 사용하게 도와줍니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyApi</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Get(<span class="meta-string">"/users/&#123;userId&#125;"</span>)</span>]</span><br><span class="line">    <span class="function">Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 후, 원하는 곳에 주입하여 다음과 같이 사용할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyApi _myApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">IMyApi myApi</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _myApi = myApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetUser</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _myApi.GetUserAsync(id);</span><br><span class="line">        <span class="keyword">return</span> Ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 HTTP 요청 관련 코드가 간소화되어 유지보수가 용이하며, API 호출이 컴파일 시간에 타입 검사까지 지원됩니다.</p><h2 id="2-Coravel">2. Coravel</h2><p><strong>Coravel</strong>은 작업 스케줄링, 큐잉, 캐싱, 백그라운드 작업, 이벤트 브로드캐스팅과 같은 반복적이고 어려운 작업을 매우 쉽게 처리할 수 있도록 도와주는 훌륭한 라이브러리입니다. Coravel은 다양한 영역을 포괄하는 대규모 라이브러리이며, 특히 스케줄링 기능이 뛰어납니다.</p><p>일반적으로 시스템을 구축할 때 어떤 형태로든 반복 작업을 처리해야 할 경우가 많습니다. 예를 들어, 매 시간마다 제3자 시스템에 데이터를 전달하거나, 매일 자정에 데이터베이스 백업을 수행해야 하는 경우가 있을 수 있습니다. Coravel은 이러한 작업을 매우 간단하게 처리할 수 있는 설정 방식을 제공하며, 주요 클라우드 제공 업체의 솔루션보다 유지보수가 더 쉬운 편입니다.</p><p>Coravel에서 작업을 정의하려면 <code>IInvocable</code> 인터페이스를 상속하는 클래스를 만들어야 합니다. 이 클래스가 바로 Coravel이 다양한 애플리케이션 파트에서 사용할 수 있는 특정 작업을 나타내며, 주기적으로 실행될 비즈니스 로직을 넣는 부분입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel.Invocable;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScheduledTask</span> : <span class="title">IInvocable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 여기에 실행할 로직을 작성합니다</span></span><br><span class="line">        Console.WriteLine(<span class="string">$"스케줄된 작업 실행 시간: <span class="subst">&#123;DateTime.Now&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>Program.cs</code> 파일에서 Coravel 스케줄러 서비스를 등록하고, 작업을 실행할 주기와 시점을 지정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서비스 등록</span></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coravel 서비스 추가</span></span><br><span class="line">builder.Services.AddScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업(MyScheduledTask) 등록</span></span><br><span class="line">builder.Services.AddTransient&lt;MyScheduledTask&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 요청 파이프라인 구성</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업 스케줄 설정</span></span><br><span class="line"><span class="keyword">var</span> provider = app.Services;</span><br><span class="line"></span><br><span class="line">provider.UseScheduler(scheduler =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    scheduler.Schedule&lt;MyScheduledTask&gt;().EveryMinute();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>이렇게 설정이 완료됩니다. Coravel은 내부적으로 작업을 스케줄에 맞춰 실행할 코드를 자동으로 관리합니다. 또한, 원하는 주기로 정확하게 작업이 실행되도록 설정할 수 있으며, CRON 표현식도 사용할 수 있어 더욱 세부적인 스케줄 관리가 가능합니다.</p><h2 id="3-FluentValidation">3. FluentValidation</h2><p><strong>FluentValidation</strong>은 .NET 애플리케이션에서 데이터 유효성 검사를 간편하게 정의하고 적용할 수 있도록 해주는 인기 있는 라이브러리입니다. 전통적으로 .NET에서의 데이터 유효성 검사는 커스텀 로직을 클래스 내부에 추가하거나 유연성이 부족한 데이터 주석을 사용하는 방식으로 이루어졌습니다.</p><p>대신 FluentValidation을 사용하면, 검증 로직을 작성하는 부담을 줄이고 커스터마이징 가능한 유효성 검사를 위한 인터페이스를 제공합니다. 이는 번잡하고 반복적인 유효성 검사 코드를 작성하지 않아도 되며, 자연스러운 언어처럼 유효성 검사를 정의할 수 있어 코드 가독성이 크게 향상됩니다. 또한, 다른 개발자들이 향후 코드를 쉽게 이해하고 유지보수할 수 있게 만듭니다.</p><p>먼저 <code>AbstractValidator</code> 클래스를 상속하는 클래스를 정의하고, <code>RuleFor</code> 메서드를 통해 유효성 검사 규칙을 간단히 설정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomerValidator : AbstractValidator&lt;Customer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        RuleFor(customer =&gt; customer.Name)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">"이름은 필수 항목입니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Age)</span><br><span class="line">            .InclusiveBetween(<span class="number">18</span>, <span class="number">60</span>).WithMessage(<span class="string">"나이는 18세에서 60세 사이여야 합니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Email)</span><br><span class="line">            .EmailAddress().WithMessage(<span class="string">"유효하지 않은 이메일 주소입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FluentValidation에는 <code>.EmailAddress()</code>, <code>.NotEmpty()</code>, <code>.GreaterThan()</code>, <code>.CreditCard()</code>와 같은 편리한 기본 제공 메서드가 다수 포함되어 있으며, 필요에 따라 사용자 정의 유효성 검사 로직도 구현할 수 있습니다.</p><p>이제 정의된 <code>CustomerValidator</code>를 사용하여 필요한 곳에서 <code>Customer</code> 객체를 검증할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customer = <span class="keyword">new</span> Customer &#123; Name = <span class="string">""</span>, Age = <span class="number">25</span>, Email = <span class="string">"invalid-email"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> CustomerValidator();</span><br><span class="line"><span class="keyword">var</span> result = validator.Validate(customer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result.IsValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> failure <span class="keyword">in</span> result.Errors)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"속성 <span class="subst">&#123;failure.PropertyName&#125;</span>이(가) 유효성 검사를 통과하지 못했습니다. 오류: <span class="subst">&#123;failure.ErrorMessage&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Polly">4. Polly</h2><p><strong>Polly</strong>는 .NET 애플리케이션의 강인성과 장애 처리 기능을 크게 향상시켜주는 인기 있는 라이브러리입니다. Polly를 사용하면 개발자가 재시도(retry) 로직, 회로 차단(circuit breaking), 타임아웃(timeout), 벌크헤드 격리(bulkhead isolation), 폴백(fallback) 등의 다양한 정책을 정의하여 소프트웨어의 안정성을 높일 수 있습니다.</p><p>소프트웨어를 작성하다 보면 예외와 일시적인 오류가 불가피하게 발생합니다. 예를 들어, 프로그램이 네트워크 타임아웃을 겪는 경우가 있을 수 있으며, 이러한 상황을 우아하게 처리하지 못하면 비즈니스에 중요한 애플리케이션 부분에 악영향을 미칠 수 있습니다. 이러한 상황에서 Polly가 매우 유용합니다. Polly의 정책은 모듈식으로 구성되어 있으며, 복잡한 오류 처리 시나리오도 대응할 수 있도록 조합할 수 있습니다.</p><p>예를 들어, 재시도 정책과 회로 차단 정책을 결합하여 강력한 오류 처리 전략을 만들 수 있습니다.</p><p>외부 API에서 데이터를 가져오는 서비스를 예로 들어, 일시적인 오류에도 잘 견딜 수 있도록 설정해 보겠습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Polly;</span><br><span class="line"><span class="keyword">using</span> Polly.CircuitBreaker;</span><br><span class="line"><span class="keyword">using</span> Polly.Fallback;</span><br><span class="line"><span class="keyword">using</span> Polly.Retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 재시도 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .WaitAndRetryAsync(<span class="number">3</span>, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 회로 차단 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> circuitBreakerPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .CircuitBreakerAsync(<span class="number">3</span>, TimeSpan.FromSeconds(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 폴백 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> fallbackPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">            .Handle&lt;BrokenCircuitException&gt;()</span><br><span class="line">            .OrResult(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .FallbackAsync(</span><br><span class="line">                <span class="keyword">new</span> HttpResponseMessage(System.Net.HttpStatusCode.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    Content = <span class="keyword">new</span> StringContent(<span class="string">"&#123;\"message\": \"Fallback response\"&#125;"</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                onFallbackAsync: <span class="keyword">async</span> b =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"폴백 로직 실행 중..."</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 정책 조합</span></span><br><span class="line">        <span class="keyword">var</span> combinedPolicy = fallbackPolicy.WrapAsync(circuitBreakerPolicy).WrapAsync(retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, <span class="string">"https://external-api.com/data"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 조합된 정책을 사용하여 요청 실행</span></span><br><span class="line">                HttpResponseMessage response = <span class="keyword">await</span> combinedPolicy.ExecuteAsync(() =&gt; httpClient.SendAsync(request));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 성공!"</span>);</span><br><span class="line">                    <span class="comment">// 응답 처리</span></span><br><span class="line">                    <span class="keyword">string</span> data = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">                    Console.WriteLine(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 실패. 상태 코드: "</span> + response.StatusCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"예외 발생: "</span> + ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선, 세 가지 정책을 정의했습니다: <strong>재시도 정책</strong>, <strong>회로 차단 정책</strong>, 그리고 <strong>폴백 정책</strong>입니다.</p><ul><li><p><strong>재시도 정책</strong>은 HTTP 요청이 실패하여 성공하지 않은 상태 코드가 반환되면 최대 3회까지 재시도하도록 합니다. 재시도 간격은 지수 백오프(exponential backoff) 전략을 사용해 실패할 때마다 재시도 간격이 증가합니다.</p></li><li><p><strong>회로 차단 정책</strong>은 연속해서 세 번 실패하면 30초 동안 추가 시도를 중단하게 됩니다. 이로 인해 시스템에 회복할 시간을 주고 이후에 다시 시도하게 됩니다.</p></li><li><p>마지막으로, <strong>폴백 정책</strong>은 모든 재시도가 실패하고 회로가 여전히 열린 경우 기본 응답을 제공하여 애플리케이션이 계속 정상적으로 동작할 수 있도록 합니다.</p></li></ul><p>이렇게 조합된 정책을 통해 HTTP 요청 실행 중 발생할 수 있는 오류나 예외를 강력하게 처리할 수 있는 시스템을 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/csharp-14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자가 싫어하는 작업을 ChatGPT로 해결하는 방법</title>
      <link>http://hgko1207.github.io/2024/10/28/chatgpt-32/</link>
      <guid>http://hgko1207.github.io/2024/10/28/chatgpt-32/</guid>
      <pubDate>Mon, 28 Oct 2024 06:44:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-31.png" alt=""></p><p>반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업을 훨씬 더 쉽게 만들어 주고 있습니다.</p><p>이번 글에서는 ChatGPT를 활용해 다음과 같은 개발 작업을 손쉽게 처리하는 방법을 소개합니다.</p><ul><li>파일 생성 및 업데이트</li><li>메서드/함수 이름 생성</li><li>다국어(i18n) 파일 생성</li><li>복잡한 코드 이해</li><li>데이터베이스 삽입문(insert) 생성</li></ul><h2 id="1-파일-생성-및-업데이트">1. 파일 생성 및 업데이트</h2><p>CSV 파일은 여전히 데이터 입력이나 테스트 데이터로 종종 사용됩니다. ChatGPT를 이용해 손쉽게 CSV 파일을 생성하거나 수정할 수 있습니다.</p><p>예를 들어, 고객 목록이 담긴 CSV 파일을 생성하려면 다음과 같은 프롬프트를 사용할 수 있습니다.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10명의 고객 정보가 담긴 CSV 파일을 생성해 주세요. 각 고객은 다음과 같은 열을 포함해야 합니다:</span><br><span class="line"><span class="deletion">- id: 정수</span></span><br><span class="line"><span class="deletion">- firstName: 문자열</span></span><br><span class="line"><span class="deletion">- lastName: 문자열</span></span><br><span class="line"><span class="deletion">- email: 문자열</span></span><br><span class="line"><span class="deletion">- phone: 문자열</span></span><br></pre></td></tr></table></figure><p>세미콜론(;) 구분자를 사용하고 국제 표준 전화번호 형식을 적용하려면 다음과 같이 요청할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">쉼표 대신 세미콜론을 사용하고, 전화번호는 국제 표준을 따르도록 해 주세요.</span><br></pre></td></tr></table></figure><p>또한, 시스템이 JSON 형식으로 전환되었다면 다음과 같이 요청하면 JSON 형식으로 변환된 파일을 생성해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSV 대신 JSON 형식으로 변환해 주세요.</span><br></pre></td></tr></table></figure><h2 id="2-메서드-함수-이름-생성">2. 메서드/함수 이름 생성</h2><p>메서드나 함수를 개발할 때 이름을 짓기 어려운 경우가 있습니다. 적절한 이름을 찾지 못한다면, 그 함수가 지나치게 많은 작업을 수행하고 있을 가능성이 높습니다. 하지만 이번에는 아이디어가 떠오르지 않거나, 익숙하지 않은 코드를 리팩토링해야 할 때의 상황에 초점을 맞춰 봅시다.</p><p>예를 들어, 다음 메서드에 대한 이름을 추천해 달라고 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Entity entity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entity.getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    insert(entity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update(entity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 적절한 메서드 이름을 제안해 주어 코드의 가독성을 높일 수 있습니다.</p><h2 id="3-다국어-i18n-파일-생성">3. 다국어(i18n) 파일 생성</h2><p>한 번은 시스템에서 사용하는 레이블의 번역본을 XML 파일로 받았는데, 시스템에서는 i18n 형식이 필요했습니다. XML 파일 예시는 다음과 같습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>phone<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Phone number<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>E-mail<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 XML을 사용해 영어와 스페인어의 i18n 파일을 생성하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">주어진 <span class="selector-tag">XML</span> 파일을 바탕으로 영어와 스페인어 각각에 대한 <span class="selector-tag">i18n</span> 파일을 생성해 주세요. 형식은 다음과 같아야 합니다:</span><br><span class="line">label=description</span><br></pre></td></tr></table></figure><p>결과는 다음과 같습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># English i18n file(en.i18n)</span></span><br><span class="line">name=Name</span><br><span class="line">phone=Phone number</span><br><span class="line">email=E-mail</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spanish i18n file(es.i18n)</span></span><br><span class="line">name=Nombre</span><br><span class="line">phone=Número de teléfono</span><br><span class="line">email=Correo electrónico</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-복잡한-코드-이해하기">4. 복잡한 코드 이해하기</h2><p>레거시 코드를 유지보수할 때, 메서드 이름만으로는 코드의 기능을 파악하기 어려운 경우가 있습니다.</p><p>예를 들어, 다음 코드가 어떤 기능을 수행하는지 ChatGPT에게 물어볼 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">boolean</span> swapped;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    swapped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (swapped == <span class="keyword">false</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 이 코드가 배열의 요소를 정렬하기 위해 버블 정렬을 사용하고 있음을 설명해 줍니다.</p><h2 id="5-삽입문-insert-생성">5. 삽입문(insert) 생성</h2><p>데이터베이스에 데이터를 삽입하는 작업을 자동화할 수 있다면 많은 시간이 절약될 수 있습니다. ChatGPT는 삽입문을 작성하는 데도 도움이 됩니다!</p><p>다음과 같은 테이블이 있다고 가정해 봅시다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>그리고 다음과 같은 CSV 파일로 데이터를 받았다고 합시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customer_id,first_name,last_name,email,phone_number</span><br><span class="line">1,John,Doe,johndoe@example.com,555-1234</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이 데이터를 삽입문으로 변환하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">주어진 CSV 데이터를 기반으로 삽입문을 생성해 주세요. 테이블 구조는 다음과 같습니다:</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>ChatGPT에게 코드를 작성하도록 요청하는 데 회의적일 수 있지만, 반복 작업이나 파일 변환, 테스트 데이터 생성에는 아주 유용하게 사용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/chatgpt-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] LINQ 모범 사례</title>
      <link>http://hgko1207.github.io/2024/10/28/csharp-13/</link>
      <guid>http://hgko1207.github.io/2024/10/28/csharp-13/</guid>
      <pubDate>Mon, 28 Oct 2024 05:07:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;.NET 개발자라면 &lt;strong&gt;LINQ&lt;/strong&gt;(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>.NET 개발자라면 <strong>LINQ</strong>(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는 영향을 이해하고 신중하게 사용해야 합니다. 이번 글에서는 LINQ 사용 시의 모범 사례, 가이드라인, 그리고 벤치마크 정보를 제공해 LINQ를 언제, 어떻게 사용할지에 대한 인사이트를 드리겠습니다.</p><h2 id="LINQ-이해하기">LINQ 이해하기</h2><p>LINQ는 .NET에서 컬렉션과 다른 데이터 소스 작업을 표현력 있고 읽기 쉽게 쿼리할 수 있게 해주는 강력한 기능입니다. 메모리 내 객체, 데이터베이스, XML 등 다양한 데이터 소스에서 일관된 쿼리 환경을 제공합니다.</p><h2 id="LINQ의-장점">LINQ의 장점</h2><ul><li><strong>가독성:</strong> LINQ 쿼리는 기존의 루프 및 조건보다 가독성과 표현력이 뛰어난 경우가 많습니다.</li><li><strong>일관성:</strong> 다양한 데이터 소스를 대상으로 일관된 쿼리 방식을 제공합니다.</li><li><strong>컴파일 타임 검사:</strong> 컴파일 시점에서 쿼리를 검사하여 런타임 오류를 줄입니다.</li><li><strong>지연 실행:</strong> 많은 LINQ 작업이 지연 실행되므로 특정 시나리오에서 성능이 향상될 수 있습니다.</li></ul><h2 id="성능-고려사항">성능 고려사항</h2><p>LINQ는 많은 이점을 제공하지만 성능 특성을 이해하는 것이 중요합니다.</p><ul><li><strong>오버헤드:</strong> LINQ 작업에는 종종 델리게이트 인스턴스 생성과 반복자 사용으로 인해 약간의 오버헤드가 발생할 수 있습니다.</li><li><strong>메모리 사용량:</strong> 일부 LINQ 연산은 임시 컬렉션을 생성하여 잠재적으로 메모리 사용량을 증가시킬 수 있습니다.</li><li><strong>쿼리 복잡성:</strong> 복잡한 LINQ 쿼리는 수동 반복문보다 효율이 떨어질 수 있습니다.</li><li><strong>지연 실행:</strong> 유용하지만, 이해 없이 사용하면 예상치 못한 성능 문제가 발생할 수 있습니다.</li></ul><h2 id="모범-사례">모범 사례</h2><h3 id="1-가독성과-유지보수를-위해-LINQ-사용하기">1. 가독성과 유지보수를 위해 LINQ 사용하기</h3><p>작은~중간 크기의 컬렉션에서, 성능이 중요한 요구사항이 아니라면 가독성을 우선시하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = users.Where(u =&gt; u.IsActive).ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비추천 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = <span class="keyword">new</span> List&lt;User&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.IsActive)</span><br><span class="line">    &#123;</span><br><span class="line">        activeUsers.Add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-큰-컬렉션에서-LINQ-사용-주의하기">2. 큰 컬렉션에서 LINQ 사용 주의하기</h3><p>매우 큰 컬렉션이나 성능이 중요한 구간에서는 기존 반복문 사용을 고려하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 큰 컬렉션에서 더 빠를 수 있음:</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> largeCollection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.SomeProperty &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LINQ 방식:</span></span><br><span class="line"><span class="keyword">var</span> count = largeCollection.Count(item =&gt; item.SomeProperty &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="3-지연-실행-이해하고-활용하기">3. 지연 실행 이해하고 활용하기</h3><p>LINQ는 많은 작업에서 지연 실행을 사용하므로 결과가 실제로 필요할 때까지 쿼리가 실행되지 않습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 쿼리 실행 안 됨</span></span><br><span class="line"><span class="keyword">var</span> query = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기서 쿼리 실행됨</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지연 실행을 활용하여 복잡한 쿼리를 단계별로 작성하고 필요한 시점에만 실행하세요.</p><h3 id="4-ToList-ToArray-ToDictionary-를-목적에-맞게-사용하기">4. <code>ToList()</code>, <code>ToArray()</code>, <code>ToDictionary()</code>를 목적에 맞게 사용하기</h3><p>이 메서드들은 쿼리를 즉시 실행합니다. 다음과 같은 경우 사용하세요.</p><ul><li>쿼리가 한 번만 실행되도록 하고 싶을 때</li><li>동일한 쿼리를 여러 번 열거하는 것을 방지하고 싶을 때</li><li>데이터 스냅샷을 생성할 때</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> activeUsersList = users.Where(u =&gt; u.IsActive).ToList();</span><br></pre></td></tr></table></figure><h3 id="5-LINQ와-기존-반복문-혼용-피하기">5. LINQ와 기존 반복문 혼용 피하기</h3><p>혼합하면 코드가 혼란스러워지고 유지보수가 어려워질 수 있으니 한 가지 방식만 사용하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 혼용하지 말기</span></span><br><span class="line"><span class="keyword">var</span> query = users.Where(u =&gt; u.IsActive);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.Age &gt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 작업 수행</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> relevantUsers = users.Where(u =&gt; u.IsActive &amp;&amp; u.Age &gt; <span class="number">30</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> relevantUsers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 작업 수행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-복잡한-쿼리에는-메서드-구문-사용하기">6. 복잡한 쿼리에는 메서드 구문 사용하기</h3><p>복잡한 쿼리는 메서드 구문이 더 읽기 쉽고 유연합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메서드 구문</span></span><br><span class="line"><span class="keyword">var</span> result = users</span><br><span class="line">    .Where(u =&gt; u.IsActive)</span><br><span class="line">    .OrderBy(u =&gt; u.LastName)</span><br><span class="line">    .ThenBy(u =&gt; u.FirstName)</span><br><span class="line">    .Select(u =&gt; <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 쿼리 구문</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> u <span class="keyword">in</span> users</span><br><span class="line">             <span class="keyword">where</span> u.IsActive</span><br><span class="line">             <span class="keyword">orderby</span> u.LastName, u.FirstName</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;;</span><br></pre></td></tr></table></figure><h3 id="7-여러-번-열거-피하기">7. 여러 번 열거 피하기</h3><p>같은 LINQ 쿼리를 여러 번 열거하면 성능이 저하될 수 있습니다. 여러 번 사용해야 한다면 결과를 리스트에 저장하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비효율적: 두 번 열거함</span></span><br><span class="line"><span class="keyword">var</span> count = query.Count();</span><br><span class="line"><span class="keyword">var</span> firstItem = query.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 효율적: 한 번만 열거</span></span><br><span class="line"><span class="keyword">var</span> results = query.ToList();</span><br><span class="line"><span class="keyword">var</span> count = results.Count;</span><br><span class="line"><span class="keyword">var</span> firstItem = results.FirstOrDefault();</span><br></pre></td></tr></table></figure><h3 id="8-적절한-LINQ-메서드-사용하기">8. 적절한 LINQ 메서드 사용하기</h3><p>상황에 맞는 LINQ 메서드를 선택하세요.</p><ul><li>한 개의 항목만 필요할 때 <code>First()</code> 또는 <code>FirstOrDefault()</code> 사용</li><li>존재 여부를 확인할 때는 <code>Count() &gt; 0</code> 대신 <code>Any()</code> 사용</li><li>0 또는 1개의 항목을 기대할 때는 <code>SingleOrDefault()</code> 사용</li><li>결과 수를 제한할 때는 <code>Take()</code> 사용</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Any(u =&gt; u.IsAdmin))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Count(u =&gt; u.IsAdmin) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="벤치마크-예제">벤치마크 예제</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benchmarks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">GlobalSetup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        numbers = Enumerable.Range(<span class="number">1</span>, <span class="number">1</span>_000_000).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.Add(numbers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과 예시 (예시일 뿐 실제 결과는 다를 수 있음)</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th></tr></thead><tbody><tr><td>SumWithLinq</td><td style="text-align:right">463.7 μs</td><td style="text-align:right">4.61 μs</td><td style="text-align:right">4.31 μs</td></tr><tr><td>SumWithLoop</td><td style="text-align:right">395.8 μs</td><td style="text-align:right">2.81 μs</td><td style="text-align:right">2.63 μs</td></tr><tr><td>FilterWithLinq</td><td style="text-align:right">10,523.3 μs</td><td style="text-align:right">102.40 μs</td><td style="text-align:right">95.78 μs</td></tr><tr><td>FilterWithLoop</td><td style="text-align:right">5,837.7 μs</td><td style="text-align:right">40.91 μs</td><td style="text-align:right">38.27 μs</td></tr></tbody></table><p>단순 작업에서는 LINQ와 반복문의 성능 차이가 크지 않지만, 필터링 같은 복잡한 작업에서는 반복문이 훨씬 빠를 수 있습니다.</p><h2 id="결론">결론</h2><p>LINQ는 코드 가독성과 유지보수성을 크게 향상할 수 있는 강력한 도구입니다. 하지만 성능이 중요한 경우 신중히 사용해야 합니다. 주요 포인트는 다음과 같습니다:</p><ul><li>작은~중간 크기 컬렉션에서는 LINQ를 사용해 가독성을 향상하세요.</li><li>큰 컬렉션이나 성능이 중요한 경우 기존 반복문을 고려하세요.</li><li>지연 실행을 이해하고 활용하세요.</li><li>여러 번 열거 시 <code>ToList()</code>나 <code>ToArray()</code>를 적절히 사용하세요.</li><li>사용 목적에 맞는 LINQ 메서드를 선택하세요.</li></ul><p>이 가이드라인을 따르면 LINQ의 장점을 활용하면서도 성능 문제를 피할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/csharp-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬에서 함수형 프로그래밍 실습</title>
      <link>http://hgko1207.github.io/2024/10/24/python-9/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-9/</guid>
      <pubDate>Thu, 24 Oct 2024 04:43:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;함수형 프로그래밍&lt;/strong&gt;은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-9.png" alt="" /></p><p><strong>함수형 프로그래밍</strong>은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 함수형 프로그래밍은 함수의 계산에 중점을 두며, 부수효과는 최소화합니다.</p><p>함수형 프로그래밍에서는 함수가 일급 객체(first-class citizen)로 취급되며, 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p><strong>Python</strong>은 객체 지향 프로그래밍 언어이지만, 함수형 프로그래밍의 특징도 지원합니다. Python에서 우리는 함수형 스타일의 코드를 작성하여 그 간결함과 효율성을 활용해 실질적인 문제를 해결할 수 있습니다.</p><h2 id="1-필수-개념"><a class="markdownIt-Anchor" href="#1-필수-개념"></a> 1. 필수 개념</h2><h3 id="11-함수는-일급-객체이다"><a class="markdownIt-Anchor" href="#11-함수는-일급-객체이다"></a> 1.1 함수는 일급 객체이다</h3><p>함수형 프로그래밍에서 함수는 일급 객체로 취급됩니다. 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p>이 덕분에 함수를 다른 함수의 인수로 전달하거나, 함수에서 함수를 반환할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span><span class="params">(f, g)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line"></span><br><span class="line">square_of_cube = compose(square, cube)</span><br><span class="line"></span><br><span class="line">print(square_of_cube(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 출력: 64</span></span><br></pre></td></tr></table></figure><h3 id="12-불변-데이터"><a class="markdownIt-Anchor" href="#12-불변-데이터"></a> 1.2 불변 데이터</h3><p>함수형 프로그래밍은 불변 데이터를 중시합니다. 이는 데이터 구조가 한 번 생성되면 변경할 수 없음을 의미합니다.</p><p>모든 연산은 원래 데이터를 수정하지 않고, 새로운 데이터를 반환해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num_plus_one = increment(num)</span><br><span class="line"></span><br><span class="line">print(num_plus_one)</span><br><span class="line"><span class="comment"># 출력: 2</span></span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line"><span class="comment"># 출력: 1</span></span><br></pre></td></tr></table></figure><h2 id="2-python의-기능"><a class="markdownIt-Anchor" href="#2-python의-기능"></a> 2. Python의 기능</h2><p>Python은 순수 함수형 프로그래밍 언어는 아니지만, 함수형 프로그래밍의 일부 기능을 갖추고 있습니다. 이러한 기능은 더 깔끔하고 효율적인 코드를 작성하는 데 도움을 줍니다.</p><h3 id="21-익명-함수와-람다lambda-표현식"><a class="markdownIt-Anchor" href="#21-익명-함수와-람다lambda-표현식"></a> 2.1 익명 함수와 람다(Lambda) 표현식</h3><p>Python은 익명 함수를 지원하여 코드의 가독성을 높여줍니다. 람다 표현식은 간단한 익명 함수를 생성할 수 있는 Python의 중요한 기능입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 피보나치 수열을 생성하는 람다 함수</span></span><br><span class="line">fibonacci = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 람다 함수를 사용하여 10번째 피보나치 수를 계산</span></span><br><span class="line">tenth_fibonacci = fibonacci(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(tenth_fibonacci)</span><br><span class="line"><span class="comment"># 출력: 55</span></span><br></pre></td></tr></table></figure><p>이 예시에서 <code>fibonacci</code> 람다 함수는 재귀적으로 피보나치 수열을 생성합니다. 그런 다음, 이 함수를 사용해 10번째 피보나치 수를 계산하면 결과는 55가 됩니다.</p><h3 id="22-리스트-컴프리헨션"><a class="markdownIt-Anchor" href="#22-리스트-컴프리헨션"></a> 2.2 리스트 컴프리헨션</h3><p>리스트 컴프리헨션(List Comprehension)은 Python에서 매우 강력한 기능으로, 간결한 구문을 통해 리스트를 생성할 수 있게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트 컴프리헨션 사용</span></span><br><span class="line">squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">print(squares)</span><br><span class="line"><span class="comment"># 출력: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><h2 id="3-함수형-프로그래밍-실습"><a class="markdownIt-Anchor" href="#3-함수형-프로그래밍-실습"></a> 3. 함수형 프로그래밍 실습</h2><h3 id="31-정렬과-맵핑"><a class="markdownIt-Anchor" href="#31-정렬과-맵핑"></a> 3.1 정렬과 맵핑</h3><p>Python의 내장 함수 <code>sorted</code>와 <code>map</code>을 사용하면 리스트를 쉽게 정렬하고 맵핑할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 정렬</span></span><br><span class="line">sorted_numbers = sorted(numbers)</span><br><span class="line">print(sorted_numbers)</span><br><span class="line"><span class="comment"># 출력: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 제곱 함수 정의</span></span><br><span class="line">square = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 맵핑</span></span><br><span class="line">squared_numbers = list(map(square, numbers))</span><br><span class="line">print(squared_numbers)</span><br><span class="line"><span class="comment"># 출력: [9, 1, 16, 1, 25, 81, 4, 36, 25, 9, 25]</span></span><br></pre></td></tr></table></figure><h3 id="32-필터링과-집계"><a class="markdownIt-Anchor" href="#32-필터링과-집계"></a> 3.2 필터링과 집계</h3><p>Python은 <code>filter</code>와 <code>reduce</code> 같은 내장 필터링 및 집계 함수를 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필터링</span></span><br><span class="line">even_numbers = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers))</span><br><span class="line">print(even_numbers)</span><br><span class="line"><span class="comment"># 출력: [4, 2, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 집계</span></span><br><span class="line">summed = reduce(<span class="keyword">lambda</span> x, y: x + y, numbers)</span><br><span class="line">print(summed)</span><br><span class="line"><span class="comment"># 출력: 43</span></span><br></pre></td></tr></table></figure><h2 id="4-메서드-체이닝을-사용한-파이프-시뮬레이션"><a class="markdownIt-Anchor" href="#4-메서드-체이닝을-사용한-파이프-시뮬레이션"></a> 4. 메서드 체이닝을 사용한 파이프 시뮬레이션</h2><p>Python에서는 Unix 쉘 스크립트와 같은 “Pipe” 개념이 기본적으로 제공되지는 않지만, 메서드 체이닝(Method Chaining)이나 함수 조합을 사용해 유사한 기능을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_five</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이프 같은 구성을 위한 메서드 체이닝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pipe</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.value = func(self.value)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">number = Pipeable(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 메서드 체이닝을 통한 파이프 구성</span></span><br><span class="line">result = number.pipe(square).pipe(double).pipe(add_five)</span><br><span class="line"></span><br><span class="line">print(result.value)</span><br><span class="line"><span class="comment"># 출력: 23</span></span><br></pre></td></tr></table></figure><p>이 예시는 <code>Pipeable</code> 클래스를 사용하여 파이프와 같은 구성을 구현하는 방법을 보여줍니다. <code>pipe</code> 메서드를 사용해 각 함수가 이전 결과를 받아들여 처리할 수 있습니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>함수형 프로그래밍은 함수 계산에 중점을 두며, 부수효과를 최소화하는 새로운 프로그래밍 패러다임입니다.</p><p>Python은 함수형 프로그래밍 기능을 지원하여 더 간단하고 효율적인 코드를 작성할 수 있게 합니다. Python은 순수 함수형 언어는 아니지만, 데이터 처리와 응용 프로그램 개발에서 매우 강력한 기능을 제공합니다.</p><p><strong>장점:</strong></p><ul><li>코드가 간결함</li><li>이해 및 유지보수가 쉬움</li><li>코드 재사용성을 높임</li></ul><p><strong>단점:</strong></p><ul><li>학습 비용이 있을 수 있음</li><li>일부 상황에서는 명령형 프로그래밍보다 성능이 낮을 수 있음</li></ul><p>결론적으로, 함수형 프로그래밍은 모듈화되고 이해하기 쉬운 유지보수성이 높은 코드를 작성하는 데 도움이 되는 강력한 프로그래밍 패러다임입니다. Python에서 함수형 프로그래밍의 기능을 활용해 실질적인 문제를 해결하고, 프로그래밍 효율성을 높여보세요!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 데코레이터(Decorator) 5가지 소개</title>
      <link>http://hgko1207.github.io/2024/10/24/python-8/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-8/</guid>
      <pubDate>Thu, 24 Oct 2024 03:35:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-8.png" alt="" /></p><p><strong>Python</strong>은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아하는 프로그래밍 언어입니다.</p><p>하지만 오랜 기간 코드를 작성하면서도 데코레이터 기능을 거의 사용하지 않았습니다. 클래스의 정적 메서드를 데코레이트하기 위한 <code>@staticmethod</code>를 사용하는 경우를 제외하면 말이죠.</p><p>그래서 이번 글에서는 데코레이터의 개념을 깊이 탐구하고, 파이썬 코드의 효율성을 높일 수 있는 실용적인 데코레이터 5가지를 소개하고자 합니다.</p><h2 id="데코레이터decorator란-무엇인가"><a class="markdownIt-Anchor" href="#데코레이터decorator란-무엇인가"></a> 데코레이터(Decorator)란 무엇인가?</h2><p>데코레이터는 파이썬의 강력한 언어 기능으로, 원래의 함수 코드를 수정하지 않고도 동적으로 기능을 추가하거나 함수의 동작을 수정할 수 있습니다. 데코레이터는 기본적으로 다른 함수나 클래스를 인자로 받아 새로운 함수나 클래스를 반환하는 함수입니다.</p><p>데코레이터는 함수를 확장하거나 감싸는 간결하고 우아한 방법을 제공하여 코드의 가독성과 유지보수성을 향상시킵니다.</p><p>주로 다음과 같은 상황에서 데코레이터가 사용됩니다:</p><ul><li>로깅, 성능 분석, 입력 유효성 검사 등 추가적인 기능이나 로직을 추가할 때.</li><li>캐시 결과, 재시도 메커니즘 추가 등 함수의 동작을 수정할 때.</li><li>주요 비즈니스 로직에서 공통적으로 발생하는 문제를 분리할 때.</li></ul><p>이제 간단하지만 유용한 5가지 데코레이터를 알아보겠습니다.</p><h2 id="01-timer-함수의-실행-시간-측정"><a class="markdownIt-Anchor" href="#01-timer-함수의-실행-시간-측정"></a> 01. <code>timer</code>: 함수의 실행 시간 측정</h2><p>코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력합니다. 이 데코레이터를 사용하여 코드의 병목 지점을 쉽게 파악하고 중요한 부분을 최적화할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        execution_time = end_time - start_time</span><br><span class="line">        print(<span class="string">f"Execution time: <span class="subst">&#123;execution_time&#125;</span> seconds"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>데코레이터를 사용하려면 원하는 함수 위에 <code>@</code> 기호를 사용해 적용하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Starting the model training function..."</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"Model training completed!"</span>)</span><br><span class="line"></span><br><span class="line">train_model()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Starting the model training <span class="keyword">function</span>…</span><br><span class="line">Model Training completed!</span><br><span class="line">Execution time: 5.006425619125366 seconds</span><br></pre></td></tr></table></figure><hr /><h2 id="02-debugger-디버깅을-쉽게"><a class="markdownIt-Anchor" href="#02-debugger-디버깅을-쉽게"></a> 02. <code>debugger</code>: 디버깅을 쉽게</h2><p>각 함수의 입력과 출력을 출력하여 디버깅을 더 쉽게 할 수 있는 래퍼 함수를 만들 수 있습니다. 이 방법은 여러 개의 print 문을 사용하지 않고도 함수의 실행 흐름을 쉽게 파악할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debugger</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"Calling <span class="subst">&#123;func.__name__&#125;</span> with args: <span class="subst">&#123;args&#125;</span> kwargs: <span class="subst">&#123;kwargs&#125;</span>"</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;func.__name__&#125;</span> returned: <span class="subst">&#123;result&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@debugger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add_numbers(<span class="number">7</span>, y=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Calling add_numbers with args: (7,) kwargs: &#123;<span class="string">'y'</span>: 5&#125;</span><br><span class="line">add_numbers returned: 12</span><br></pre></td></tr></table></figure><hr /><h2 id="03-memoize-결과-캐싱"><a class="markdownIt-Anchor" href="#03-memoize-결과-캐싱"></a> 03. <code>memoize</code>: 결과 캐싱</h2><p>코드에서 일부 반복 실행되는 부분은 큰 컴퓨팅 자원을 소모할 수 있습니다. 이 경우 <code>memoize</code> 데코레이터를 사용하여 함수 호출 결과를 캐싱할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = func(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>피보나치 수 계산 함수에 캐싱을 적용하면, 동일한 입력에 대해 함수가 한 번만 실행되고 이후에는 캐시된 결과를 사용하게 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>캐싱을 사용하지 않은 경우와 비교해 보면, 캐싱된 버전은 몇 밀리초밖에 걸리지 않는 반면, 캐싱되지 않은 버전은 거의 1분이 걸릴 수 있습니다.</p><hr /><h2 id="04-retry-재시도-로직"><a class="markdownIt-Anchor" href="#04-retry-재시도-로직"></a> 04. <code>retry</code>: 재시도 로직</h2><p>데이터 과학과 소프트웨어 개발에서 외부 시스템에 의존하는 경우가 많지만, 모든 외부 시스템이 안정적이지는 않습니다. 예기치 않은 오류가 발생했을 때, 코드가 잠시 기다렸다가 다시 시도하도록 할 수 있습니다. 이 재시도 로직을 데코레이터로 구현하여 쉽게 적용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span><span class="params">(max_attempts, delay=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            attempts = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> attempts &lt; max_attempts:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    attempts += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">f"Attempt <span class="subst">&#123;attempts&#125;</span> failed: <span class="subst">&#123;e&#125;</span>"</span>)</span><br><span class="line">                    time.sleep(delay)</span><br><span class="line">            print(<span class="string">f"Function failed after <span class="subst">&#123;max_attempts&#125;</span> attempts"</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@retry(max_attempts=3, delay=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"Fetching the data.."</span>)</span><br><span class="line">    <span class="keyword">raise</span> TimeoutError(<span class="string">"Server is not responding."</span>)</span><br><span class="line"></span><br><span class="line">fetch_data(<span class="string">"https://example.com/data"</span>)</span><br></pre></td></tr></table></figure><p>이 코드는 최대 3번까지 2초 간격으로 재시도합니다.</p><h2 id="05-exception_handler-예외-처리-간소화"><a class="markdownIt-Anchor" href="#05-exception_handler-예외-처리-간소화"></a> 05. <code>exception_handler</code>: 예외 처리 간소화</h2><p><code>exception_handler</code> 데코레이터는 함수에서 발생하는 예외를 잡아 처리할 수 있습니다. 필요에 따라 로깅하거나 추가적인 오류 처리를 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">f"An exception occurred: <span class="subst">&#123;str(e)&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@exception_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = x / y</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">An exception occurred: division by zero</span><br></pre></td></tr></table></figure><p>이 데코레이터는 코드를 단순화하고 예외 처리와 오류 로깅을 위한 일관된 절차를 설정하는 데 매우 유용합니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>데코레이터는 함수에 새로운 동작을 적용하는 매우 편리한 방법입니다. 데코레이터를 사용하면 복잡한 작업을 간소화하고 코드 가독성을 높이며, 생산성을 향상시킬 수 있습니다.</p><p>데코레이터는 파이썬의 강력한 기능 중 하나이며, 적절히 활용하면 코드의 유지보수성과 확장성을 높일 수 있습니다. 데코레이터를 사용해 여러분의 파이썬 코드를 한 단계 더 발전시켜보세요. 😊</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 디자인 패턴 사용 방법</title>
      <link>http://hgko1207.github.io/2024/10/24/python-7/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-7/</guid>
      <pubDate>Thu, 24 Oct 2024 03:08:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Python</strong>은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한다고 생각합니다.</p><p>이 생각은 잘못된 것입니다. Python은 객체 지향 프로그래밍을 지원할 뿐만 아니라 <strong>디자인 패턴</strong>도 효과적으로 적용할 수 있습니다.</p><h2 id="디자인-패턴이란-무엇인가"><a class="markdownIt-Anchor" href="#디자인-패턴이란-무엇인가"></a> 디자인 패턴이란 무엇인가?</h2><p>디자인 패턴(Design Pattern)은 널리 인정받고 검증된 프로그래밍 경험의 집합입니다. 이는 다양한 프로그래밍 시나리오에서 적용할 수 있는 일반적인 솔루션을 제공합니다. 디자인 패턴의 등장은 코드 재사용, 시스템 확장성, 코드 가독성 등 소프트웨어 개발의 일반적인 문제를 해결하기 위함입니다.</p><h2 id="디자인-패턴을-사용하는-이유는"><a class="markdownIt-Anchor" href="#디자인-패턴을-사용하는-이유는"></a> 디자인 패턴을 사용하는 이유는?</h2><p>디자인 패턴을 사용하는 이점은 다음과 같습니다:</p><ul><li><strong>코드 재사용:</strong> 디자인 패턴을 사용하면 코드를 분해하고 조합하여 코드 재사용을 달성할 수 있습니다.</li><li><strong>시스템 확장성:</strong> 디자인 패턴은 시스템을 더 유연하게 만들고, 확장이 용이하며, 다양한 요구에 적응할 수 있게 합니다.</li><li><strong>코드 가독성:</strong> 디자인 패턴을 사용하면 코드의 가독성을 높여 코드가 더 명확해집니다.</li></ul><h2 id="파이썬에서의-디자인-패턴"><a class="markdownIt-Anchor" href="#파이썬에서의-디자인-패턴"></a> 파이썬에서의 디자인 패턴</h2><p>파이썬에서의 디자인 패턴은 다른 언어에서의 디자인 패턴과 유사하지만, 몇 가지 차이점이 있습니다. 파이썬에서의 디자인 패턴은 크게 세 가지로 나눌 수 있습니다: 생성 패턴, 구조 패턴, 행동 패턴.</p><p>이번 글에서는 몇 가지 일반적인 패턴을 설명합니다.</p><h2 id="1-팩토리-패턴-factory-pattern"><a class="markdownIt-Anchor" href="#1-팩토리-패턴-factory-pattern"></a> 1. 팩토리 패턴 (Factory Pattern)</h2><p>팩토리 패턴은 생성 패턴으로, 객체를 생성하는 가장 좋은 방법을 제공합니다. 이 패턴은 객체의 생성과 사용을 분리하여 객체 생성을 더 유연하게 만듭니다.</p><p>파이썬에서 팩토리 패턴을 사용하여 다양한 객체를 생성할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_animal</span><span class="params">(self, animal_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> animal_type == <span class="string">"dog"</span>:</span><br><span class="line">            <span class="keyword">return</span> Dog()</span><br><span class="line">        <span class="keyword">elif</span> animal_type == <span class="string">"cat"</span>:</span><br><span class="line">            <span class="keyword">return</span> Cat()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">factory = AnimalFactory()</span><br><span class="line">animal = factory.create_animal(<span class="string">"dog"</span>)</span><br><span class="line">print(animal.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: dog</span></span><br></pre></td></tr></table></figure><h2 id="2-싱글톤-패턴-singleton-pattern"><a class="markdownIt-Anchor" href="#2-싱글톤-패턴-singleton-pattern"></a> 2. 싱글톤 패턴 (Singleton Pattern)</h2><p>싱글톤 패턴은 클래스에 하나의 인스턴스만 존재하도록 보장하며, 전역 접근 지점을 제공합니다.</p><p><img src="/images/header/python-7_1.png" alt="" /></p><p>파이썬에서는 데코레이터를 사용하여 싱글톤 패턴을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton()</span><br><span class="line">b = Singleton()</span><br><span class="line"></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: True</span></span><br></pre></td></tr></table></figure><h2 id="3-어댑터-패턴-adapter-pattern"><a class="markdownIt-Anchor" href="#3-어댑터-패턴-adapter-pattern"></a> 3. 어댑터 패턴 (Adapter Pattern)</h2><p>어댑터 패턴은 구조 패턴으로, 클래스의 인터페이스를 클라이언트가 원하는 다른 인터페이스로 변환합니다.</p><p>파이썬에서는 어댑터 패턴을 사용하여 호환되지 않는 인터페이스 간의 호환성을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">specific_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(Target)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, adaptee)</span>:</span></span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.adaptee.specific_request()</span><br><span class="line"></span><br><span class="line">adaptee = Adaptee()</span><br><span class="line">adapter = Adapter(adaptee)</span><br><span class="line">adapter.request()</span><br></pre></td></tr></table></figure><h2 id="4-데코레이터-패턴-decorator-pattern"><a class="markdownIt-Anchor" href="#4-데코레이터-패턴-decorator-pattern"></a> 4. 데코레이터 패턴 (Decorator Pattern)</h2><p>데코레이터 패턴은 구조 패턴으로, 객체에 새로운 동작을 동적으로 추가할 수 있습니다.</p><p><img src="/images/header/python-7_2.png" alt="" /></p><p>파이썬에서는 데코레이터 함수를 사용하여 함수나 클래스의 동작을 수정할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call function:"</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: call function: foo hello world</span></span><br></pre></td></tr></table></figure><h2 id="5-옵저버-패턴-observer-pattern"><a class="markdownIt-Anchor" href="#5-옵저버-패턴-observer-pattern"></a> 5. 옵저버 패턴 (Observer Pattern)</h2><p>옵저버 패턴은 행동 패턴으로, 객체 간 일대다 관계를 정의하여, 객체의 상태가 변경될 때 이를 의존하는 모든 객체가 자동으로 업데이트됩니다.</p><p><img src="/images/header/python-7_3.png" alt="" /></p><p>파이썬에서는 옵저버 패턴을 사용하여 이벤트 중심의 프로그래밍을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        self.state = state</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span><span class="params">(Observer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        print(<span class="string">"state changed to:"</span>, subject.get_state())</span><br><span class="line"></span><br><span class="line">subject = ConcreteSubject()</span><br><span class="line">observer = ConcreteObserver()</span><br><span class="line">subject.attach(observer)</span><br><span class="line">subject.set_state(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: state changed to: 1</span></span><br></pre></td></tr></table></figure><h2 id="6-빌더-패턴-builder-pattern"><a class="markdownIt-Anchor" href="#6-빌더-패턴-builder-pattern"></a> 6. 빌더 패턴 (Builder Pattern)</h2><p>빌더 패턴은 복잡한 객체의 생성 과정을 그 표현과 분리하여 동일한 생성 과정으로 다양한 표현을 만들 수 있게 합니다.</p><p><img src="/images/header/python-7_4.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_car</span><span class="params">(self, builder)</span>:</span></span><br><span class="line">        builder.create_new_car()</span><br><span class="line">        builder.add_model()</span><br><span class="line">        builder.add_engine()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_new_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = Car()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.car</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.model = <span class="string">"Sports Car"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_engine</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.engine = <span class="string">"V8"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.engine = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">director = Director()</span><br><span class="line">car_builder = CarBuilder()</span><br><span class="line"></span><br><span class="line">director.construct_car(car_builder)</span><br><span class="line">car = car_builder.get_car()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Car Model: <span class="subst">&#123;car.model&#125;</span>, Engine: <span class="subst">&#123;car.engine&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="7-전략-패턴-strategy-pattern"><a class="markdownIt-Anchor" href="#7-전략-패턴-strategy-pattern"></a> 7. 전략 패턴 (Strategy Pattern)</h2><p>전략 패턴은 알고리즘 군을 정의하고, 이를 캡슐화하며, 이 알고리즘을 상호 교체 가능하게 만드는 패턴입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentContext</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, payment_strategy)</span>:</span></span><br><span class="line">        self.payment_strategy = payment_strategy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_payment</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.payment_strategy.pay(amount)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCardPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using Credit Card."</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PayPalPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using PayPal."</span></span><br><span class="line"></span><br><span class="line">credit_card_payment = CreditCardPayment()</span><br><span class="line">paypal_payment = PayPalPayment()</span><br><span class="line"></span><br><span class="line">context_credit_card = PaymentContext(credit_card_payment)</span><br><span class="line">context_paypal = PaymentContext(paypal_payment)</span><br><span class="line"></span><br><span class="line">print(context_credit_card.execute_payment(<span class="number">100</span>))</span><br><span class="line">print(context_paypal.execute_payment(<span class="number">50</span>))</span><br></pre></td></tr></table></figure><h2 id="8-책임-연쇄-패턴-chain-of-responsibility-pattern"><a class="markdownIt-Anchor" href="#8-책임-연쇄-패턴-chain-of-responsibility-pattern"></a> 8. 책임 연쇄 패턴 (Chain of Responsibility Pattern)</h2><p>책임 연쇄 패턴은 요청을 처리할 수 있는 여러 핸들러가 체인으로 연결되어 각 핸들러가 요청을 처리할지 또는 다음 핸들러로 전달할지 결정하는 패턴입니다.</p><p><img src="/images/header/python-7_5.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, successor=None)</span>:</span></span><br><span class="line">        self.successor = successor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.successor:</span><br><span class="line">            self.successor.handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"A"</span>:</span><br><span class="line">            print(<span class="string">"Handler A processing request A."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"B"</span>:</span><br><span class="line">            print(<span class="string">"Handler B processing request B."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.handler_chain = ConcreteHandlerA(ConcreteHandlerB())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        self.handler_chain.handle_request(request)</span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.make_request(<span class="string">"A"</span>)</span><br><span class="line">client.make_request(<span class="string">"B"</span>)</span><br></pre></td></tr></table></figure><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>Python은 절차 지향 언어일 뿐만 아니라 객체 지향 프로그래밍 스타일도 지원합니다. 디자인 패턴을 사용하면 Python의 객체 지향 기능을 더 잘 활용하여 코드를 더 유연하고, 읽기 쉽고, 유지보수가 용이하게 만들 수 있습니다.</p><p>파이썬에서의 디자인 패턴에는 팩토리 패턴, 싱글톤 패턴, 어댑터 패턴, 데코레이터 패턴, 옵저버 패턴 등이 포함됩니다. 이러한 패턴들은 다양한 프로그래밍 시나리오에 적용할 수 있으며, 소프트웨어 개발의 공통적인 문제를 해결하는 데 도움을 줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-7/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
