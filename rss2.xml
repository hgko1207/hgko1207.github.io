<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Thu, 31 Oct 2024 12:04:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>주말에 만들 수 있는 5가지 AI 프로젝트 (Python 사용)</title>
      <link>http://hgko1207.github.io/2024/10/29/python-10/</link>
      <guid>http://hgko1207.github.io/2024/10/29/python-10/</guid>
      <pubDate>Tue, 29 Oct 2024 05:26:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디어를 공유합니다. 각 아이디어를 구현하는 데 필요한 단계와 Python 라이브러리를 설명해드리겠습니다.</p><p>프로젝트 아이디어를 생각할 때, 초보자들이 가장 많이 하는 실수는 &quot;<strong>이 새로운 기술을 어떻게 사용할 수 있을까?</strong>&quot;라는 질문에서 시작하는 것입니다. 물론, 새로운 도구를 배우는 방법으로는 괜찮지만, 더 나은 접근법이 있습니다.</p><p>좋은 프로젝트 아이디어는 &quot;<strong>내가 해결할 수 있는 문제가 무엇인가?</strong>&quot;라는 질문에서 시작됩니다. 문제 해결은 기술을 가치로 전환하는 방법이며, 잠재적 고용주에게도 설득력 있는 스토리가 됩니다.</p><p>다음 프로젝트들은 모두 이 문제 해결 접근법을 따릅니다. 아이디어를 그대로 구현하거나, 더 나아가 개인적으로 해결하고 싶은 문제에 적용할 수도 있습니다.</p><h2 id="1-이력서-최적화-초급">1) 이력서 최적화 (초급)</h2><p>구직 활동에서 시간이 많이 소요되는 작업 중 하나는 각 채용 공고에 맞게 이력서를 조정하는 것입니다. 과거에는 이러한 작업을 자동화하는 것이 고급 프로젝트에 속했지만, 오늘날의 LLM(Large Language Model) 덕분에 이제는 간단한 API 호출만으로도 해결할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>이력서를 Markdown 형식으로 작성합니다. (참고: ChatGPT를 통해 이 작업을 쉽게 할 수 있습니다).</li><li>Markdown 이력서와 채용 공고를 받아 새롭게 이력서를 작성하는 다양한 프롬프트 템플릿을 실험해봅니다.</li><li>OpenAI의 Python API를 사용해 GPT-4o-mini를 통해 이력서를 동적으로 수정합니다.</li><li><code>markdown</code> 및 <code>pdfkit</code> 라이브러리를 각각 사용하여 Markdown 파일을 HTML과 PDF로 변환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>markdown</code>, <code>pdfkit</code></p><p>ChatGPT를 통해 간단히 이 작업을 처리할 수 있지만, Python으로 구현하면 더 쉽게 대규모 처리를 할 수 있습니다. 아래는 Step 3의 시작 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = <span class="string">"your_sk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 프롬프트 (md_resume 및 job_desciption이 정의되어 있다고 가정)</span></span><br><span class="line">prompt = <span class="string">f"""</span></span><br><span class="line"><span class="string">Markdown 형식의 이력서와 채용 공고가 있습니다. \</span></span><br><span class="line"><span class="string">이력서를 채용 요구 사항에 더 잘 맞게 조정해 주세요. \</span></span><br><span class="line"><span class="string">필요한 기술, 경험, 성과를 강조하여 이력서를 수정해 주세요. \</span></span><br><span class="line"><span class="string">이력서에는 여전히 나만의 독특한 자격과 강점이 반영되도록 하되, \</span></span><br><span class="line"><span class="string">채용 공고와 일치하는 기술과 경험이 강조되도록 해주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 내 이력서 (Markdown 형식):</span></span><br><span class="line"><span class="string"><span class="subst">&#123;md_resume&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 채용 공고:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;job_desciption&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이력서를 수정해 주세요:</span></span><br><span class="line"><span class="string">- 채용 공고의 키워드와 구문을 사용하세요.</span></span><br><span class="line"><span class="string">- 각 역할 아래에 관련 기술과 성과를 강조하세요.</span></span><br><span class="line"><span class="string">- 나의 경험이 요구되는 자격에 맞게 잘 나타나도록 수정해 주세요.</span></span><br><span class="line"><span class="string">- 명확성, 간결성, 그리고 전문성을 유지하세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">업데이트된 이력서를 Markdown 형식으로 반환해 주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API 호출</span></span><br><span class="line">response = openai.chat.completions.create(</span><br><span class="line">    model=<span class="string">"gpt-4o-mini"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are a helpful assistant."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: prompt&#125;</span><br><span class="line">    ],</span><br><span class="line">    temperature = <span class="number">0.25</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 응답 추출</span></span><br><span class="line">resume = response.choices[<span class="number">0</span>].message.content</span><br></pre></td></tr></table></figure><p>참고: ChatGPT는 짧은 코드 스니펫(및 프롬프트)을 작성할 때 매우 유용합니다. Step 4에서 막히면 ChatGPT에 도움을 요청해 보세요!</p><h2 id="2-YouTube-강의-요약-도구-초급">2) YouTube 강의 요약 도구 (초급)</h2><p>기술 강연을 YouTube의 “<strong>나중에 보기</strong>” 목록에 추가해 두는 것을 좋아하지만, 나중에 보려다 보지 못할 때가 많습니다. 이러한 문제를 해결하기 위해 동영상을 대신 시청하고 주요 포인트로 구성된 요약을 생성해 주는 도구를 만들 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li>정규 표현식을 사용하여 YouTube 비디오 링크에서 비디오 ID를 추출합니다.</li><li><code>youtube-transcript-api</code>를 사용해 비디오 ID로 트랜스크립트를 추출합니다.</li><li>트랜스크립트를 효과적으로 요약하는 다양한 ChatGPT 프롬프트를 실험해 봅니다.</li><li>OpenAI의 Python API를 사용하여 이 과정을 자동화합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>youtube-transcript-api</code></p><p>기술적으로, 이 프로젝트는 앞서 소개한 프로젝트와 유사합니다. 다만, 이 프로젝트에서는 비디오 트랜스크립트를 자동으로 추출하여 언어 모델(LLM)에 입력해야 한다는 점이 다릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> youtube_transcript_api <span class="keyword">import</span> YouTubeTranscriptApi</span><br><span class="line"></span><br><span class="line">youtube_url = <span class="string">"video link here"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 정규 표현식으로 비디오 ID 추출</span></span><br><span class="line">video_id_regex = <span class="string">r'(?:v=|\/)([0-9A-Za-z_-]&#123;11&#125;).*'</span></span><br><span class="line">match = re.search(video_id_regex, youtube_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    <span class="keyword">return</span> match.group(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 트랜스크립트 추출</span></span><br><span class="line">text_list = [transcript[i][<span class="string">'text'</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(transcript))]</span><br><span class="line">transcript_text = <span class="string">'\n'</span>.join(text_list)</span><br></pre></td></tr></table></figure><h2 id="3-PDF-자동-정리-도구-중급">3) PDF 자동 정리 도구 (중급)</h2><p>데스크탑에는 정리되지 않은 논문(PDF)들이 쌓여 있을 수 있습니다. 수동으로 이러한 논문을 검토하는 것은 시간이 많이 걸리기 때문에, AI를 활용해 보겠습니다.</p><p>데스크탑에 있는 각 PDF의 내용을 분석하고 주제별로 폴더를 만들어 자동으로 정리하는 도구를 구축할 수 있습니다. 텍스트 임베딩을 사용해 각 논문을 밀집 벡터 표현으로 변환한 뒤, 유사한 논문끼리 K-Means와 같은 전통적인 머신러닝 알고리즘으로 클러스터링할 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li><code>PyMuPDF</code>를 사용하여 각 논문의 초록을 읽습니다.</li><li><code>sentence-transformers</code> 라이브러리를 사용하여 초록을 텍스트 임베딩으로 변환하고, 이를 Pandas 데이터프레임에 저장합니다.</li><li><code>sklearn</code>의 선호하는 클러스터링 알고리즘을 사용하여 임베딩을 유사성 기반으로 그룹화합니다.</li><li>각 클러스터에 대한 폴더를 생성하고, 파일을 해당 폴더로 이동합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>sentence_transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 핵심 단계는 텍스트 임베딩 생성입니다. 다음은 <code>sentence_transformers</code>를 사용하여 임베딩을 생성하는 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 모델 로드</span></span><br><span class="line">model = SentenceTransformer(<span class="string">"all-MiniLM-L6-v2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록을 목록에 저장</span></span><br><span class="line">abstract_list = [<span class="string">"abstract 1"</span>, <span class="string">"abstract 2"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 계산</span></span><br><span class="line">embeddings = model.encode(abstract_list)</span><br></pre></td></tr></table></figure><h2 id="4-멀티모달-검색-시스템-중급">4) 멀티모달 검색 시스템 (중급)</h2><p>특정 기술 보고서들을 위한 기본적인 RAG(검색 증강 생성) 시스템을 구축할 때, 보고서의 주요 정보가 <strong>텍스트가 아닌 플롯과 그림</strong>으로 표현되는 경우가 많아 검색에 어려움을 겪을 수 있습니다.</p><p>시각적 정보를 검색 과정에 포함시키기 위해 <strong>텍스트와 이미지를 동일한 공간에 표현하는 멀티모달 임베딩 모델</strong>을 사용하는 방법이 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>PDF를 섹션별로 나누고, PyMuPDF를 사용해 이미지를 추출합니다.</li><li>nomic-ai/nomic-embed-text-v1.5와 같은 멀티모달 임베딩 모델을 사용해 각 섹션과 이미지를 밀집 벡터로 표현하고, 데이터프레임에 저장합니다.</li><li>지식 베이스에 있는 모든 PDF에 대해 이 작업을 반복합니다.</li><li>사용자가 쿼리를 입력하면 지식 베이스에서 사용한 동일한 임베딩 모델을 통해 쿼리를 임베딩으로 변환합니다.</li><li>쿼리 임베딩과 지식 베이스 항목의 임베딩 간 코사인 유사도 점수를 계산합니다.</li><li>상위 k개의 결과를 반환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 중요한 부분은 PDF를 어떻게 나누느냐에 있습니다. 가장 간단한 방법은 고정된 문자 수를 기준으로 약간의 중첩을 포함하여 나누는 것입니다. 또한, 각 청크에 파일 이름과 페이지 번호 같은 메타데이터를 포함하는 것이 유용합니다.</p><p>아래는 기본 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz  <span class="comment"># PyMuPDF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_text_chunks</span><span class="params">(pdf_path, chunk_size, overlap_size)</span>:</span></span><br><span class="line">    <span class="comment"># PDF 파일 열기</span></span><br><span class="line">    pdf_document = fitz.open(pdf_path)</span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 각 페이지를 반복하여 처리</span></span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> range(len(pdf_document)):</span><br><span class="line">        page = pdf_document[page_num]</span><br><span class="line">        page_text = page.get_text()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 현재 페이지의 텍스트를 중첩을 포함하여 청크로 분할</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; len(page_text):</span><br><span class="line">            end = start + chunk_size</span><br><span class="line">            chunk = page_text[start:end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 청크와 페이지 번호 저장</span></span><br><span class="line">            chunks.append((page_num + <span class="number">1</span>, chunk))</span><br><span class="line">            <span class="comment"># 중첩 크기만큼 이동하여 다음 청크 설정</span></span><br><span class="line">            start += chunk_size - overlap_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 추출 매개 변수 설정</span></span><br><span class="line">pdf_path = <span class="string">"your_file.pdf"</span></span><br><span class="line">chunk_size = <span class="number">1000</span>  <span class="comment"># 각 텍스트 청크의 크기 (문자 수 기준)</span></span><br><span class="line">overlap_size = <span class="number">200</span>  <span class="comment"># 중첩 크기 (문자 수 기준)</span></span><br><span class="line"></span><br><span class="line">text_chunks = extract_text_chunks(pdf_path, chunk_size, overlap_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 페이지 번호와 함께 청크 출력</span></span><br><span class="line"><span class="keyword">for</span> i, (page_number, chunk) <span class="keyword">in</span> enumerate(text_chunks):</span><br><span class="line">    print(<span class="string">f"청크 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (페이지 <span class="subst">&#123;page_number&#125;</span>):\n<span class="subst">&#123;chunk&#125;</span>\n<span class="subst">&#123;<span class="string">'-'</span> * <span class="number">50</span>&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-지식-기반-질문-응답-QA-시스템-고급">5) 지식 기반 질문-응답(QA) 시스템 (고급)</h2><p>가장 자주 요청받은 프로젝트가 바로 문서 질문-응답(QA) 시스템입니다. 이전 프로젝트를 기반으로, 이를 간단하게 구현할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>지식 베이스에서 검색을 수행합니다 (프로젝트 4에서 만든 것처럼).</li><li>사용자 쿼리와 상위 k개의 검색 결과를 결합하여 멀티모달 모델에 전달합니다.</li><li>질문-응답 시스템을 위한 간단한 Gradio 사용자 인터페이스를 생성합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code>, <code>together/openai</code>, <code>Gradio</code></p><p>참고: Together AI의 API를 통해 Llama 3.2 Vision을 2025년까지 무료로 사용할 수 있습니다.</p><p>이 프로젝트는 본질적으로 프로젝트 2와 4를 결합한 형태입니다. 그러나 여기에는 사용자 인터페이스가 필수 요소로 포함됩니다. Gradio와 같은 대시보드 도구를 사용하여 간단한 채팅 UI를 몇 줄의 코드로 만들 수 있습니다.</p><p>아래는 Gradio의 문서에서 가져온 예시 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_response</span><span class="params">(message, history)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        응답을 생성하는 코드 작성</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">demo = gr.ChatInterface(</span><br><span class="line">    fn=generate_response,</span><br><span class="line">    examples=[&#123;<span class="string">"text"</span>: <span class="string">"Hello"</span>, <span class="string">"files"</span>: []&#125;],</span><br><span class="line">    title=<span class="string">"Echo Bot"</span>,</span><br><span class="line">    multimodal=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">demo.launch()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/python-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>효율적인 .NET 개발을 위한 4가지 필수 라이브러리 소개</title>
      <link>http://hgko1207.github.io/2024/10/29/csharp-14/</link>
      <guid>http://hgko1207.github.io/2024/10/29/csharp-14/</guid>
      <pubDate>Tue, 29 Oct 2024 04:49:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 &lt;strong&gt;.NET Core&lt;/strong&gt;를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 <strong>.NET Core</strong>를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 앞으로 모든 .NET 릴리스의 기초로 .NET Core를 활용하겠다고 밝혔고, 오픈 소스 기여는 .NET Foundation의 가이드 하에 이루어지게 되었습니다.</p><p>.NET Core는 큰 성공을 거두었고, 2020년에는 .NET Framework와 .NET Core가 하나의 오픈 소스 크로스 플랫폼 기술로 통합된 .NET 5가 출시되었습니다.</p><p>오픈 소스로 전환됨에 따라 .NET 플랫폼에는 활기 넘치는 커뮤니티가 형성되었습니다. 많은 뛰어난 개발자들이 고품질의 도구와 라이브러리를 게시해 개발자들의 일상 업무를 한결 쉽게 만들고 있습니다.</p><p>이번 글에서는 새 프로젝트를 시작할 때 꼭 설치하는 필수 라이브러리 4가지를 소개하고자 합니다.</p><h2 id="1-Refit">1. Refit</h2><p>.NET에서 HTTP 요청을 다루는 작업은 상당히 많은 수작업과 반복되는 코드를 요구합니다. 예를 들어 <code>HttpClient</code> 클래스를 직접 구현해 요청을 처리하는 코드는 다음과 같습니다</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> GetUserAsync(<span class="number">123</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"User Name: <span class="subst">&#123;user.Name&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 필요한 경우 기본 주소와 기본 헤더를 설정합니다.</span></span><br><span class="line">        client.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://api.example.com/"</span>);</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Clear();</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Add(<span class="keyword">new</span> MediaTypeWithQualityHeaderValue(<span class="string">"application/json"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 요청하기</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">$"users/<span class="subst">&#123;userId&#125;</span>"</span>);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 응답 역직렬화</span></span><br><span class="line">        <span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;User&gt;(responseBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같은 구현 방식은 복잡하고, 반복적인 코드가 많아지기 쉽습니다.</p><p><strong>Refit</strong>은 이런 작업을 간편하게 해주는 라이브러리입니다. 단순히 인터페이스를 정의하여 REST API를 사용하게 도와줍니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyApi</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Get(<span class="meta-string">"/users/&#123;userId&#125;"</span>)</span>]</span><br><span class="line">    <span class="function">Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 후, 원하는 곳에 주입하여 다음과 같이 사용할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyApi _myApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">IMyApi myApi</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _myApi = myApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetUser</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _myApi.GetUserAsync(id);</span><br><span class="line">        <span class="keyword">return</span> Ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 HTTP 요청 관련 코드가 간소화되어 유지보수가 용이하며, API 호출이 컴파일 시간에 타입 검사까지 지원됩니다.</p><h2 id="2-Coravel">2. Coravel</h2><p><strong>Coravel</strong>은 작업 스케줄링, 큐잉, 캐싱, 백그라운드 작업, 이벤트 브로드캐스팅과 같은 반복적이고 어려운 작업을 매우 쉽게 처리할 수 있도록 도와주는 훌륭한 라이브러리입니다. Coravel은 다양한 영역을 포괄하는 대규모 라이브러리이며, 특히 스케줄링 기능이 뛰어납니다.</p><p>일반적으로 시스템을 구축할 때 어떤 형태로든 반복 작업을 처리해야 할 경우가 많습니다. 예를 들어, 매 시간마다 제3자 시스템에 데이터를 전달하거나, 매일 자정에 데이터베이스 백업을 수행해야 하는 경우가 있을 수 있습니다. Coravel은 이러한 작업을 매우 간단하게 처리할 수 있는 설정 방식을 제공하며, 주요 클라우드 제공 업체의 솔루션보다 유지보수가 더 쉬운 편입니다.</p><p>Coravel에서 작업을 정의하려면 <code>IInvocable</code> 인터페이스를 상속하는 클래스를 만들어야 합니다. 이 클래스가 바로 Coravel이 다양한 애플리케이션 파트에서 사용할 수 있는 특정 작업을 나타내며, 주기적으로 실행될 비즈니스 로직을 넣는 부분입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel.Invocable;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScheduledTask</span> : <span class="title">IInvocable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 여기에 실행할 로직을 작성합니다</span></span><br><span class="line">        Console.WriteLine(<span class="string">$"스케줄된 작업 실행 시간: <span class="subst">&#123;DateTime.Now&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>Program.cs</code> 파일에서 Coravel 스케줄러 서비스를 등록하고, 작업을 실행할 주기와 시점을 지정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서비스 등록</span></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coravel 서비스 추가</span></span><br><span class="line">builder.Services.AddScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업(MyScheduledTask) 등록</span></span><br><span class="line">builder.Services.AddTransient&lt;MyScheduledTask&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 요청 파이프라인 구성</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업 스케줄 설정</span></span><br><span class="line"><span class="keyword">var</span> provider = app.Services;</span><br><span class="line"></span><br><span class="line">provider.UseScheduler(scheduler =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    scheduler.Schedule&lt;MyScheduledTask&gt;().EveryMinute();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>이렇게 설정이 완료됩니다. Coravel은 내부적으로 작업을 스케줄에 맞춰 실행할 코드를 자동으로 관리합니다. 또한, 원하는 주기로 정확하게 작업이 실행되도록 설정할 수 있으며, CRON 표현식도 사용할 수 있어 더욱 세부적인 스케줄 관리가 가능합니다.</p><h2 id="3-FluentValidation">3. FluentValidation</h2><p><strong>FluentValidation</strong>은 .NET 애플리케이션에서 데이터 유효성 검사를 간편하게 정의하고 적용할 수 있도록 해주는 인기 있는 라이브러리입니다. 전통적으로 .NET에서의 데이터 유효성 검사는 커스텀 로직을 클래스 내부에 추가하거나 유연성이 부족한 데이터 주석을 사용하는 방식으로 이루어졌습니다.</p><p>대신 FluentValidation을 사용하면, 검증 로직을 작성하는 부담을 줄이고 커스터마이징 가능한 유효성 검사를 위한 인터페이스를 제공합니다. 이는 번잡하고 반복적인 유효성 검사 코드를 작성하지 않아도 되며, 자연스러운 언어처럼 유효성 검사를 정의할 수 있어 코드 가독성이 크게 향상됩니다. 또한, 다른 개발자들이 향후 코드를 쉽게 이해하고 유지보수할 수 있게 만듭니다.</p><p>먼저 <code>AbstractValidator</code> 클래스를 상속하는 클래스를 정의하고, <code>RuleFor</code> 메서드를 통해 유효성 검사 규칙을 간단히 설정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomerValidator : AbstractValidator&lt;Customer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        RuleFor(customer =&gt; customer.Name)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">"이름은 필수 항목입니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Age)</span><br><span class="line">            .InclusiveBetween(<span class="number">18</span>, <span class="number">60</span>).WithMessage(<span class="string">"나이는 18세에서 60세 사이여야 합니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Email)</span><br><span class="line">            .EmailAddress().WithMessage(<span class="string">"유효하지 않은 이메일 주소입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FluentValidation에는 <code>.EmailAddress()</code>, <code>.NotEmpty()</code>, <code>.GreaterThan()</code>, <code>.CreditCard()</code>와 같은 편리한 기본 제공 메서드가 다수 포함되어 있으며, 필요에 따라 사용자 정의 유효성 검사 로직도 구현할 수 있습니다.</p><p>이제 정의된 <code>CustomerValidator</code>를 사용하여 필요한 곳에서 <code>Customer</code> 객체를 검증할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customer = <span class="keyword">new</span> Customer &#123; Name = <span class="string">""</span>, Age = <span class="number">25</span>, Email = <span class="string">"invalid-email"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> CustomerValidator();</span><br><span class="line"><span class="keyword">var</span> result = validator.Validate(customer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result.IsValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> failure <span class="keyword">in</span> result.Errors)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"속성 <span class="subst">&#123;failure.PropertyName&#125;</span>이(가) 유효성 검사를 통과하지 못했습니다. 오류: <span class="subst">&#123;failure.ErrorMessage&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Polly">4. Polly</h2><p><strong>Polly</strong>는 .NET 애플리케이션의 강인성과 장애 처리 기능을 크게 향상시켜주는 인기 있는 라이브러리입니다. Polly를 사용하면 개발자가 재시도(retry) 로직, 회로 차단(circuit breaking), 타임아웃(timeout), 벌크헤드 격리(bulkhead isolation), 폴백(fallback) 등의 다양한 정책을 정의하여 소프트웨어의 안정성을 높일 수 있습니다.</p><p>소프트웨어를 작성하다 보면 예외와 일시적인 오류가 불가피하게 발생합니다. 예를 들어, 프로그램이 네트워크 타임아웃을 겪는 경우가 있을 수 있으며, 이러한 상황을 우아하게 처리하지 못하면 비즈니스에 중요한 애플리케이션 부분에 악영향을 미칠 수 있습니다. 이러한 상황에서 Polly가 매우 유용합니다. Polly의 정책은 모듈식으로 구성되어 있으며, 복잡한 오류 처리 시나리오도 대응할 수 있도록 조합할 수 있습니다.</p><p>예를 들어, 재시도 정책과 회로 차단 정책을 결합하여 강력한 오류 처리 전략을 만들 수 있습니다.</p><p>외부 API에서 데이터를 가져오는 서비스를 예로 들어, 일시적인 오류에도 잘 견딜 수 있도록 설정해 보겠습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Polly;</span><br><span class="line"><span class="keyword">using</span> Polly.CircuitBreaker;</span><br><span class="line"><span class="keyword">using</span> Polly.Fallback;</span><br><span class="line"><span class="keyword">using</span> Polly.Retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 재시도 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .WaitAndRetryAsync(<span class="number">3</span>, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 회로 차단 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> circuitBreakerPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .CircuitBreakerAsync(<span class="number">3</span>, TimeSpan.FromSeconds(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 폴백 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> fallbackPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">            .Handle&lt;BrokenCircuitException&gt;()</span><br><span class="line">            .OrResult(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .FallbackAsync(</span><br><span class="line">                <span class="keyword">new</span> HttpResponseMessage(System.Net.HttpStatusCode.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    Content = <span class="keyword">new</span> StringContent(<span class="string">"&#123;\"message\": \"Fallback response\"&#125;"</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                onFallbackAsync: <span class="keyword">async</span> b =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"폴백 로직 실행 중..."</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 정책 조합</span></span><br><span class="line">        <span class="keyword">var</span> combinedPolicy = fallbackPolicy.WrapAsync(circuitBreakerPolicy).WrapAsync(retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, <span class="string">"https://external-api.com/data"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 조합된 정책을 사용하여 요청 실행</span></span><br><span class="line">                HttpResponseMessage response = <span class="keyword">await</span> combinedPolicy.ExecuteAsync(() =&gt; httpClient.SendAsync(request));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 성공!"</span>);</span><br><span class="line">                    <span class="comment">// 응답 처리</span></span><br><span class="line">                    <span class="keyword">string</span> data = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">                    Console.WriteLine(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 실패. 상태 코드: "</span> + response.StatusCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"예외 발생: "</span> + ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선, 세 가지 정책을 정의했습니다: <strong>재시도 정책</strong>, <strong>회로 차단 정책</strong>, 그리고 <strong>폴백 정책</strong>입니다.</p><ul><li><p><strong>재시도 정책</strong>은 HTTP 요청이 실패하여 성공하지 않은 상태 코드가 반환되면 최대 3회까지 재시도하도록 합니다. 재시도 간격은 지수 백오프(exponential backoff) 전략을 사용해 실패할 때마다 재시도 간격이 증가합니다.</p></li><li><p><strong>회로 차단 정책</strong>은 연속해서 세 번 실패하면 30초 동안 추가 시도를 중단하게 됩니다. 이로 인해 시스템에 회복할 시간을 주고 이후에 다시 시도하게 됩니다.</p></li><li><p>마지막으로, <strong>폴백 정책</strong>은 모든 재시도가 실패하고 회로가 여전히 열린 경우 기본 응답을 제공하여 애플리케이션이 계속 정상적으로 동작할 수 있도록 합니다.</p></li></ul><p>이렇게 조합된 정책을 통해 HTTP 요청 실행 중 발생할 수 있는 오류나 예외를 강력하게 처리할 수 있는 시스템을 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/csharp-14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자가 싫어하는 작업을 ChatGPT로 해결하는 방법</title>
      <link>http://hgko1207.github.io/2024/10/28/chatgpt-32/</link>
      <guid>http://hgko1207.github.io/2024/10/28/chatgpt-32/</guid>
      <pubDate>Mon, 28 Oct 2024 06:44:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-31.png" alt=""></p><p>반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업을 훨씬 더 쉽게 만들어 주고 있습니다.</p><p>이번 글에서는 ChatGPT를 활용해 다음과 같은 개발 작업을 손쉽게 처리하는 방법을 소개합니다.</p><ul><li>파일 생성 및 업데이트</li><li>메서드/함수 이름 생성</li><li>다국어(i18n) 파일 생성</li><li>복잡한 코드 이해</li><li>데이터베이스 삽입문(insert) 생성</li></ul><h2 id="1-파일-생성-및-업데이트">1. 파일 생성 및 업데이트</h2><p>CSV 파일은 여전히 데이터 입력이나 테스트 데이터로 종종 사용됩니다. ChatGPT를 이용해 손쉽게 CSV 파일을 생성하거나 수정할 수 있습니다.</p><p>예를 들어, 고객 목록이 담긴 CSV 파일을 생성하려면 다음과 같은 프롬프트를 사용할 수 있습니다.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10명의 고객 정보가 담긴 CSV 파일을 생성해 주세요. 각 고객은 다음과 같은 열을 포함해야 합니다:</span><br><span class="line"><span class="deletion">- id: 정수</span></span><br><span class="line"><span class="deletion">- firstName: 문자열</span></span><br><span class="line"><span class="deletion">- lastName: 문자열</span></span><br><span class="line"><span class="deletion">- email: 문자열</span></span><br><span class="line"><span class="deletion">- phone: 문자열</span></span><br></pre></td></tr></table></figure><p>세미콜론(;) 구분자를 사용하고 국제 표준 전화번호 형식을 적용하려면 다음과 같이 요청할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">쉼표 대신 세미콜론을 사용하고, 전화번호는 국제 표준을 따르도록 해 주세요.</span><br></pre></td></tr></table></figure><p>또한, 시스템이 JSON 형식으로 전환되었다면 다음과 같이 요청하면 JSON 형식으로 변환된 파일을 생성해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSV 대신 JSON 형식으로 변환해 주세요.</span><br></pre></td></tr></table></figure><h2 id="2-메서드-함수-이름-생성">2. 메서드/함수 이름 생성</h2><p>메서드나 함수를 개발할 때 이름을 짓기 어려운 경우가 있습니다. 적절한 이름을 찾지 못한다면, 그 함수가 지나치게 많은 작업을 수행하고 있을 가능성이 높습니다. 하지만 이번에는 아이디어가 떠오르지 않거나, 익숙하지 않은 코드를 리팩토링해야 할 때의 상황에 초점을 맞춰 봅시다.</p><p>예를 들어, 다음 메서드에 대한 이름을 추천해 달라고 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Entity entity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entity.getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    insert(entity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update(entity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 적절한 메서드 이름을 제안해 주어 코드의 가독성을 높일 수 있습니다.</p><h2 id="3-다국어-i18n-파일-생성">3. 다국어(i18n) 파일 생성</h2><p>한 번은 시스템에서 사용하는 레이블의 번역본을 XML 파일로 받았는데, 시스템에서는 i18n 형식이 필요했습니다. XML 파일 예시는 다음과 같습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>phone<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Phone number<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>E-mail<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 XML을 사용해 영어와 스페인어의 i18n 파일을 생성하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">주어진 <span class="selector-tag">XML</span> 파일을 바탕으로 영어와 스페인어 각각에 대한 <span class="selector-tag">i18n</span> 파일을 생성해 주세요. 형식은 다음과 같아야 합니다:</span><br><span class="line">label=description</span><br></pre></td></tr></table></figure><p>결과는 다음과 같습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># English i18n file(en.i18n)</span></span><br><span class="line">name=Name</span><br><span class="line">phone=Phone number</span><br><span class="line">email=E-mail</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spanish i18n file(es.i18n)</span></span><br><span class="line">name=Nombre</span><br><span class="line">phone=Número de teléfono</span><br><span class="line">email=Correo electrónico</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-복잡한-코드-이해하기">4. 복잡한 코드 이해하기</h2><p>레거시 코드를 유지보수할 때, 메서드 이름만으로는 코드의 기능을 파악하기 어려운 경우가 있습니다.</p><p>예를 들어, 다음 코드가 어떤 기능을 수행하는지 ChatGPT에게 물어볼 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">boolean</span> swapped;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    swapped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (swapped == <span class="keyword">false</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 이 코드가 배열의 요소를 정렬하기 위해 버블 정렬을 사용하고 있음을 설명해 줍니다.</p><h2 id="5-삽입문-insert-생성">5. 삽입문(insert) 생성</h2><p>데이터베이스에 데이터를 삽입하는 작업을 자동화할 수 있다면 많은 시간이 절약될 수 있습니다. ChatGPT는 삽입문을 작성하는 데도 도움이 됩니다!</p><p>다음과 같은 테이블이 있다고 가정해 봅시다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>그리고 다음과 같은 CSV 파일로 데이터를 받았다고 합시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customer_id,first_name,last_name,email,phone_number</span><br><span class="line">1,John,Doe,johndoe@example.com,555-1234</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이 데이터를 삽입문으로 변환하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">주어진 CSV 데이터를 기반으로 삽입문을 생성해 주세요. 테이블 구조는 다음과 같습니다:</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>ChatGPT에게 코드를 작성하도록 요청하는 데 회의적일 수 있지만, 반복 작업이나 파일 변환, 테스트 데이터 생성에는 아주 유용하게 사용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/chatgpt-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] LINQ 모범 사례</title>
      <link>http://hgko1207.github.io/2024/10/28/csharp-13/</link>
      <guid>http://hgko1207.github.io/2024/10/28/csharp-13/</guid>
      <pubDate>Mon, 28 Oct 2024 05:07:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;.NET 개발자라면 &lt;strong&gt;LINQ&lt;/strong&gt;(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>.NET 개발자라면 <strong>LINQ</strong>(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는 영향을 이해하고 신중하게 사용해야 합니다. 이번 글에서는 LINQ 사용 시의 모범 사례, 가이드라인, 그리고 벤치마크 정보를 제공해 LINQ를 언제, 어떻게 사용할지에 대한 인사이트를 드리겠습니다.</p><h2 id="LINQ-이해하기">LINQ 이해하기</h2><p>LINQ는 .NET에서 컬렉션과 다른 데이터 소스 작업을 표현력 있고 읽기 쉽게 쿼리할 수 있게 해주는 강력한 기능입니다. 메모리 내 객체, 데이터베이스, XML 등 다양한 데이터 소스에서 일관된 쿼리 환경을 제공합니다.</p><h2 id="LINQ의-장점">LINQ의 장점</h2><ul><li><strong>가독성:</strong> LINQ 쿼리는 기존의 루프 및 조건보다 가독성과 표현력이 뛰어난 경우가 많습니다.</li><li><strong>일관성:</strong> 다양한 데이터 소스를 대상으로 일관된 쿼리 방식을 제공합니다.</li><li><strong>컴파일 타임 검사:</strong> 컴파일 시점에서 쿼리를 검사하여 런타임 오류를 줄입니다.</li><li><strong>지연 실행:</strong> 많은 LINQ 작업이 지연 실행되므로 특정 시나리오에서 성능이 향상될 수 있습니다.</li></ul><h2 id="성능-고려사항">성능 고려사항</h2><p>LINQ는 많은 이점을 제공하지만 성능 특성을 이해하는 것이 중요합니다.</p><ul><li><strong>오버헤드:</strong> LINQ 작업에는 종종 델리게이트 인스턴스 생성과 반복자 사용으로 인해 약간의 오버헤드가 발생할 수 있습니다.</li><li><strong>메모리 사용량:</strong> 일부 LINQ 연산은 임시 컬렉션을 생성하여 잠재적으로 메모리 사용량을 증가시킬 수 있습니다.</li><li><strong>쿼리 복잡성:</strong> 복잡한 LINQ 쿼리는 수동 반복문보다 효율이 떨어질 수 있습니다.</li><li><strong>지연 실행:</strong> 유용하지만, 이해 없이 사용하면 예상치 못한 성능 문제가 발생할 수 있습니다.</li></ul><h2 id="모범-사례">모범 사례</h2><h3 id="1-가독성과-유지보수를-위해-LINQ-사용하기">1. 가독성과 유지보수를 위해 LINQ 사용하기</h3><p>작은~중간 크기의 컬렉션에서, 성능이 중요한 요구사항이 아니라면 가독성을 우선시하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = users.Where(u =&gt; u.IsActive).ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비추천 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = <span class="keyword">new</span> List&lt;User&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.IsActive)</span><br><span class="line">    &#123;</span><br><span class="line">        activeUsers.Add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-큰-컬렉션에서-LINQ-사용-주의하기">2. 큰 컬렉션에서 LINQ 사용 주의하기</h3><p>매우 큰 컬렉션이나 성능이 중요한 구간에서는 기존 반복문 사용을 고려하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 큰 컬렉션에서 더 빠를 수 있음:</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> largeCollection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.SomeProperty &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LINQ 방식:</span></span><br><span class="line"><span class="keyword">var</span> count = largeCollection.Count(item =&gt; item.SomeProperty &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="3-지연-실행-이해하고-활용하기">3. 지연 실행 이해하고 활용하기</h3><p>LINQ는 많은 작업에서 지연 실행을 사용하므로 결과가 실제로 필요할 때까지 쿼리가 실행되지 않습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 쿼리 실행 안 됨</span></span><br><span class="line"><span class="keyword">var</span> query = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기서 쿼리 실행됨</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지연 실행을 활용하여 복잡한 쿼리를 단계별로 작성하고 필요한 시점에만 실행하세요.</p><h3 id="4-ToList-ToArray-ToDictionary-를-목적에-맞게-사용하기">4. <code>ToList()</code>, <code>ToArray()</code>, <code>ToDictionary()</code>를 목적에 맞게 사용하기</h3><p>이 메서드들은 쿼리를 즉시 실행합니다. 다음과 같은 경우 사용하세요.</p><ul><li>쿼리가 한 번만 실행되도록 하고 싶을 때</li><li>동일한 쿼리를 여러 번 열거하는 것을 방지하고 싶을 때</li><li>데이터 스냅샷을 생성할 때</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> activeUsersList = users.Where(u =&gt; u.IsActive).ToList();</span><br></pre></td></tr></table></figure><h3 id="5-LINQ와-기존-반복문-혼용-피하기">5. LINQ와 기존 반복문 혼용 피하기</h3><p>혼합하면 코드가 혼란스러워지고 유지보수가 어려워질 수 있으니 한 가지 방식만 사용하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 혼용하지 말기</span></span><br><span class="line"><span class="keyword">var</span> query = users.Where(u =&gt; u.IsActive);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.Age &gt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 작업 수행</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> relevantUsers = users.Where(u =&gt; u.IsActive &amp;&amp; u.Age &gt; <span class="number">30</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> relevantUsers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 작업 수행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-복잡한-쿼리에는-메서드-구문-사용하기">6. 복잡한 쿼리에는 메서드 구문 사용하기</h3><p>복잡한 쿼리는 메서드 구문이 더 읽기 쉽고 유연합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메서드 구문</span></span><br><span class="line"><span class="keyword">var</span> result = users</span><br><span class="line">    .Where(u =&gt; u.IsActive)</span><br><span class="line">    .OrderBy(u =&gt; u.LastName)</span><br><span class="line">    .ThenBy(u =&gt; u.FirstName)</span><br><span class="line">    .Select(u =&gt; <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 쿼리 구문</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> u <span class="keyword">in</span> users</span><br><span class="line">             <span class="keyword">where</span> u.IsActive</span><br><span class="line">             <span class="keyword">orderby</span> u.LastName, u.FirstName</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;;</span><br></pre></td></tr></table></figure><h3 id="7-여러-번-열거-피하기">7. 여러 번 열거 피하기</h3><p>같은 LINQ 쿼리를 여러 번 열거하면 성능이 저하될 수 있습니다. 여러 번 사용해야 한다면 결과를 리스트에 저장하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비효율적: 두 번 열거함</span></span><br><span class="line"><span class="keyword">var</span> count = query.Count();</span><br><span class="line"><span class="keyword">var</span> firstItem = query.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 효율적: 한 번만 열거</span></span><br><span class="line"><span class="keyword">var</span> results = query.ToList();</span><br><span class="line"><span class="keyword">var</span> count = results.Count;</span><br><span class="line"><span class="keyword">var</span> firstItem = results.FirstOrDefault();</span><br></pre></td></tr></table></figure><h3 id="8-적절한-LINQ-메서드-사용하기">8. 적절한 LINQ 메서드 사용하기</h3><p>상황에 맞는 LINQ 메서드를 선택하세요.</p><ul><li>한 개의 항목만 필요할 때 <code>First()</code> 또는 <code>FirstOrDefault()</code> 사용</li><li>존재 여부를 확인할 때는 <code>Count() &gt; 0</code> 대신 <code>Any()</code> 사용</li><li>0 또는 1개의 항목을 기대할 때는 <code>SingleOrDefault()</code> 사용</li><li>결과 수를 제한할 때는 <code>Take()</code> 사용</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Any(u =&gt; u.IsAdmin))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Count(u =&gt; u.IsAdmin) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="벤치마크-예제">벤치마크 예제</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benchmarks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">GlobalSetup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        numbers = Enumerable.Range(<span class="number">1</span>, <span class="number">1</span>_000_000).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.Add(numbers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과 예시 (예시일 뿐 실제 결과는 다를 수 있음)</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th></tr></thead><tbody><tr><td>SumWithLinq</td><td style="text-align:right">463.7 μs</td><td style="text-align:right">4.61 μs</td><td style="text-align:right">4.31 μs</td></tr><tr><td>SumWithLoop</td><td style="text-align:right">395.8 μs</td><td style="text-align:right">2.81 μs</td><td style="text-align:right">2.63 μs</td></tr><tr><td>FilterWithLinq</td><td style="text-align:right">10,523.3 μs</td><td style="text-align:right">102.40 μs</td><td style="text-align:right">95.78 μs</td></tr><tr><td>FilterWithLoop</td><td style="text-align:right">5,837.7 μs</td><td style="text-align:right">40.91 μs</td><td style="text-align:right">38.27 μs</td></tr></tbody></table><p>단순 작업에서는 LINQ와 반복문의 성능 차이가 크지 않지만, 필터링 같은 복잡한 작업에서는 반복문이 훨씬 빠를 수 있습니다.</p><h2 id="결론">결론</h2><p>LINQ는 코드 가독성과 유지보수성을 크게 향상할 수 있는 강력한 도구입니다. 하지만 성능이 중요한 경우 신중히 사용해야 합니다. 주요 포인트는 다음과 같습니다:</p><ul><li>작은~중간 크기 컬렉션에서는 LINQ를 사용해 가독성을 향상하세요.</li><li>큰 컬렉션이나 성능이 중요한 경우 기존 반복문을 고려하세요.</li><li>지연 실행을 이해하고 활용하세요.</li><li>여러 번 열거 시 <code>ToList()</code>나 <code>ToArray()</code>를 적절히 사용하세요.</li><li>사용 목적에 맞는 LINQ 메서드를 선택하세요.</li></ul><p>이 가이드라인을 따르면 LINQ의 장점을 활용하면서도 성능 문제를 피할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/csharp-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬에서 함수형 프로그래밍 실습</title>
      <link>http://hgko1207.github.io/2024/10/24/python-9/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-9/</guid>
      <pubDate>Thu, 24 Oct 2024 04:43:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;함수형 프로그래밍은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 함수형 프로그래밍은 함수의 계산
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-9.png" alt="" /></p><p>함수형 프로그래밍은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 함수형 프로그래밍은 함수의 계산에 중점을 두며, 부수효과는 최소화합니다.</p><p>함수형 프로그래밍에서는 함수가 일급 객체(first-class citizen)로 취급되며, 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p>Python은 객체 지향 프로그래밍 언어이지만, 함수형 프로그래밍의 특징도 지원합니다. Python에서 우리는 함수형 스타일의 코드를 작성하여 그 간결함과 효율성을 활용해 실질적인 문제를 해결할 수 있습니다.</p><h2 id="1-필수-개념"><a class="markdownIt-Anchor" href="#1-필수-개념"></a> 1. 필수 개념</h2><h3 id="11-함수는-일급-객체이다"><a class="markdownIt-Anchor" href="#11-함수는-일급-객체이다"></a> 1.1 함수는 일급 객체이다</h3><p>함수형 프로그래밍에서 함수는 일급 객체로 취급됩니다. 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p>이 덕분에 함수를 다른 함수의 인수로 전달하거나, 함수에서 함수를 반환할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span><span class="params">(f, g)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line"></span><br><span class="line">square_of_cube = compose(square, cube)</span><br><span class="line"></span><br><span class="line">print(square_of_cube(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 출력: 64</span></span><br></pre></td></tr></table></figure><h3 id="12-불변-데이터"><a class="markdownIt-Anchor" href="#12-불변-데이터"></a> 1.2 불변 데이터</h3><p>함수형 프로그래밍은 불변 데이터를 중시합니다. 이는 데이터 구조가 한 번 생성되면 변경할 수 없음을 의미합니다.</p><p>모든 연산은 원래 데이터를 수정하지 않고, 새로운 데이터를 반환해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num_plus_one = increment(num)</span><br><span class="line"></span><br><span class="line">print(num_plus_one)</span><br><span class="line"><span class="comment"># 출력: 2</span></span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line"><span class="comment"># 출력: 1</span></span><br></pre></td></tr></table></figure><h2 id="2-python의-기능"><a class="markdownIt-Anchor" href="#2-python의-기능"></a> 2. Python의 기능</h2><p>Python은 순수 함수형 프로그래밍 언어는 아니지만, 함수형 프로그래밍의 일부 기능을 갖추고 있습니다. 이러한 기능은 더 깔끔하고 효율적인 코드를 작성하는 데 도움을 줍니다.</p><h3 id="21-익명-함수와-람다lambda-표현식"><a class="markdownIt-Anchor" href="#21-익명-함수와-람다lambda-표현식"></a> 2.1 익명 함수와 람다(Lambda) 표현식</h3><p>Python은 익명 함수를 지원하여 코드의 가독성을 높여줍니다. 람다 표현식은 간단한 익명 함수를 생성할 수 있는 Python의 중요한 기능입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 피보나치 수열을 생성하는 람다 함수</span></span><br><span class="line">fibonacci = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 람다 함수를 사용하여 10번째 피보나치 수를 계산</span></span><br><span class="line">tenth_fibonacci = fibonacci(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(tenth_fibonacci)</span><br><span class="line"><span class="comment"># 출력: 55</span></span><br></pre></td></tr></table></figure><p>이 예시에서 <code>fibonacci</code> 람다 함수는 재귀적으로 피보나치 수열을 생성합니다. 그런 다음, 이 함수를 사용해 10번째 피보나치 수를 계산하면 결과는 55가 됩니다.</p><h3 id="22-리스트-컴프리헨션"><a class="markdownIt-Anchor" href="#22-리스트-컴프리헨션"></a> 2.2 리스트 컴프리헨션</h3><p>리스트 컴프리헨션(List Comprehension)은 Python에서 매우 강력한 기능으로, 간결한 구문을 통해 리스트를 생성할 수 있게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트 컴프리헨션 사용</span></span><br><span class="line">squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">print(squares)</span><br><span class="line"><span class="comment"># 출력: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><h2 id="3-함수형-프로그래밍-실습"><a class="markdownIt-Anchor" href="#3-함수형-프로그래밍-실습"></a> 3. 함수형 프로그래밍 실습</h2><h3 id="31-정렬과-맵핑"><a class="markdownIt-Anchor" href="#31-정렬과-맵핑"></a> 3.1 정렬과 맵핑</h3><p>Python의 내장 함수 <code>sorted</code>와 <code>map</code>을 사용하면 리스트를 쉽게 정렬하고 맵핑할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 정렬</span></span><br><span class="line">sorted_numbers = sorted(numbers)</span><br><span class="line">print(sorted_numbers)</span><br><span class="line"><span class="comment"># 출력: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 제곱 함수 정의</span></span><br><span class="line">square = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 맵핑</span></span><br><span class="line">squared_numbers = list(map(square, numbers))</span><br><span class="line">print(squared_numbers)</span><br><span class="line"><span class="comment"># 출력: [9, 1, 16, 1, 25, 81, 4, 36, 25, 9, 25]</span></span><br></pre></td></tr></table></figure><h3 id="32-필터링과-집계"><a class="markdownIt-Anchor" href="#32-필터링과-집계"></a> 3.2 필터링과 집계</h3><p>Python은 <code>filter</code>와 <code>reduce</code> 같은 내장 필터링 및 집계 함수를 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필터링</span></span><br><span class="line">even_numbers = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers))</span><br><span class="line">print(even_numbers)</span><br><span class="line"><span class="comment"># 출력: [4, 2, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 집계</span></span><br><span class="line">summed = reduce(<span class="keyword">lambda</span> x, y: x + y, numbers)</span><br><span class="line">print(summed)</span><br><span class="line"><span class="comment"># 출력: 43</span></span><br></pre></td></tr></table></figure><h2 id="4-메서드-체이닝을-사용한-파이프-시뮬레이션"><a class="markdownIt-Anchor" href="#4-메서드-체이닝을-사용한-파이프-시뮬레이션"></a> 4. 메서드 체이닝을 사용한 파이프 시뮬레이션</h2><p>Python에서는 Unix 쉘 스크립트와 같은 “Pipe” 개념이 기본적으로 제공되지는 않지만, 메서드 체이닝(Method Chaining)이나 함수 조합을 사용해 유사한 기능을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_five</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이프 같은 구성을 위한 메서드 체이닝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pipe</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.value = func(self.value)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">number = Pipeable(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 메서드 체이닝을 통한 파이프 구성</span></span><br><span class="line">result = number.pipe(square).pipe(double).pipe(add_five)</span><br><span class="line"></span><br><span class="line">print(result.value)</span><br><span class="line"><span class="comment"># 출력: 23</span></span><br></pre></td></tr></table></figure><p>이 예시는 <code>Pipeable</code> 클래스를 사용하여 파이프와 같은 구성을 구현하는 방법을 보여줍니다. <code>pipe</code> 메서드를 사용해 각 함수가 이전 결과를 받아들여 처리할 수 있습니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>함수형 프로그래밍은 함수 계산에 중점을 두며, 부수효과를 최소화하는 새로운 프로그래밍 패러다임입니다.</p><p>Python은 함수형 프로그래밍 기능을 지원하여 더 간단하고 효율적인 코드를 작성할 수 있게 합니다. Python은 순수 함수형 언어는 아니지만, 데이터 처리와 응용 프로그램 개발에서 매우 강력한 기능을 제공합니다.</p><p><strong>장점:</strong></p><ul><li>코드가 간결함</li><li>이해 및 유지보수가 쉬움</li><li>코드 재사용성을 높임</li></ul><p><strong>단점:</strong></p><ul><li>학습 비용이 있을 수 있음</li><li>일부 상황에서는 명령형 프로그래밍보다 성능이 낮을 수 있음</li></ul><p>결론적으로, 함수형 프로그래밍은 모듈화되고 이해하기 쉬운 유지보수성이 높은 코드를 작성하는 데 도움이 되는 강력한 프로그래밍 패러다임입니다. Python에서 함수형 프로그래밍의 기능을 활용해 실질적인 문제를 해결하고, 프로그래밍 효율성을 높여보세요!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 데코레이터(Decorator) 5가지 소개</title>
      <link>http://hgko1207.github.io/2024/10/24/python-8/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-8/</guid>
      <pubDate>Thu, 24 Oct 2024 03:35:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Python은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아하는 프로그래밍 언어입니다.&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-8.png" alt="" /></p><p>Python은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아하는 프로그래밍 언어입니다.</p><p>하지만 오랜 기간 코드를 작성하면서도 데코레이터 기능을 거의 사용하지 않았습니다. 클래스의 정적 메서드를 데코레이트하기 위한 <code>@staticmethod</code>를 사용하는 경우를 제외하면 말이죠.</p><p>그래서 이번 글에서는 데코레이터의 개념을 깊이 탐구하고, 파이썬 코드의 효율성을 높일 수 있는 실용적인 데코레이터 5가지를 소개하고자 합니다.</p><h2 id="데코레이터decorator란-무엇인가"><a class="markdownIt-Anchor" href="#데코레이터decorator란-무엇인가"></a> 데코레이터(Decorator)란 무엇인가?</h2><p>데코레이터는 파이썬의 강력한 언어 기능으로, 원래의 함수 코드를 수정하지 않고도 동적으로 기능을 추가하거나 함수의 동작을 수정할 수 있습니다. 데코레이터는 기본적으로 다른 함수나 클래스를 인자로 받아 새로운 함수나 클래스를 반환하는 함수입니다.</p><p>데코레이터는 함수를 확장하거나 감싸는 간결하고 우아한 방법을 제공하여 코드의 가독성과 유지보수성을 향상시킵니다.</p><p>주로 다음과 같은 상황에서 데코레이터가 사용됩니다:</p><ul><li>로깅, 성능 분석, 입력 유효성 검사 등 추가적인 기능이나 로직을 추가할 때.</li><li>캐시 결과, 재시도 메커니즘 추가 등 함수의 동작을 수정할 때.</li><li>주요 비즈니스 로직에서 공통적으로 발생하는 문제를 분리할 때.</li></ul><p>이제 간단하지만 유용한 5가지 데코레이터를 알아보겠습니다.</p><h2 id="01-timer-함수의-실행-시간-측정"><a class="markdownIt-Anchor" href="#01-timer-함수의-실행-시간-측정"></a> 01. <code>timer</code>: 함수의 실행 시간 측정</h2><p>코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력합니다. 이 데코레이터를 사용하여 코드의 병목 지점을 쉽게 파악하고 중요한 부분을 최적화할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        execution_time = end_time - start_time</span><br><span class="line">        print(<span class="string">f"Execution time: <span class="subst">&#123;execution_time&#125;</span> seconds"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>데코레이터를 사용하려면 원하는 함수 위에 <code>@</code> 기호를 사용해 적용하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Starting the model training function..."</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"Model training completed!"</span>)</span><br><span class="line"></span><br><span class="line">train_model()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Starting the model training <span class="keyword">function</span>…</span><br><span class="line">Model Training completed!</span><br><span class="line">Execution time: 5.006425619125366 seconds</span><br></pre></td></tr></table></figure><hr /><h2 id="02-debugger-디버깅을-쉽게"><a class="markdownIt-Anchor" href="#02-debugger-디버깅을-쉽게"></a> 02. <code>debugger</code>: 디버깅을 쉽게</h2><p>각 함수의 입력과 출력을 출력하여 디버깅을 더 쉽게 할 수 있는 래퍼 함수를 만들 수 있습니다. 이 방법은 여러 개의 print 문을 사용하지 않고도 함수의 실행 흐름을 쉽게 파악할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debugger</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"Calling <span class="subst">&#123;func.__name__&#125;</span> with args: <span class="subst">&#123;args&#125;</span> kwargs: <span class="subst">&#123;kwargs&#125;</span>"</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;func.__name__&#125;</span> returned: <span class="subst">&#123;result&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@debugger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add_numbers(<span class="number">7</span>, y=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Calling add_numbers with args: (7,) kwargs: &#123;<span class="string">'y'</span>: 5&#125;</span><br><span class="line">add_numbers returned: 12</span><br></pre></td></tr></table></figure><hr /><h2 id="03-memoize-결과-캐싱"><a class="markdownIt-Anchor" href="#03-memoize-결과-캐싱"></a> 03. <code>memoize</code>: 결과 캐싱</h2><p>코드에서 일부 반복 실행되는 부분은 큰 컴퓨팅 자원을 소모할 수 있습니다. 이 경우 <code>memoize</code> 데코레이터를 사용하여 함수 호출 결과를 캐싱할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = func(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>피보나치 수 계산 함수에 캐싱을 적용하면, 동일한 입력에 대해 함수가 한 번만 실행되고 이후에는 캐시된 결과를 사용하게 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>캐싱을 사용하지 않은 경우와 비교해 보면, 캐싱된 버전은 몇 밀리초밖에 걸리지 않는 반면, 캐싱되지 않은 버전은 거의 1분이 걸릴 수 있습니다.</p><hr /><h2 id="04-retry-재시도-로직"><a class="markdownIt-Anchor" href="#04-retry-재시도-로직"></a> 04. <code>retry</code>: 재시도 로직</h2><p>데이터 과학과 소프트웨어 개발에서 외부 시스템에 의존하는 경우가 많지만, 모든 외부 시스템이 안정적이지는 않습니다. 예기치 않은 오류가 발생했을 때, 코드가 잠시 기다렸다가 다시 시도하도록 할 수 있습니다. 이 재시도 로직을 데코레이터로 구현하여 쉽게 적용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span><span class="params">(max_attempts, delay=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            attempts = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> attempts &lt; max_attempts:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    attempts += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">f"Attempt <span class="subst">&#123;attempts&#125;</span> failed: <span class="subst">&#123;e&#125;</span>"</span>)</span><br><span class="line">                    time.sleep(delay)</span><br><span class="line">            print(<span class="string">f"Function failed after <span class="subst">&#123;max_attempts&#125;</span> attempts"</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@retry(max_attempts=3, delay=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"Fetching the data.."</span>)</span><br><span class="line">    <span class="keyword">raise</span> TimeoutError(<span class="string">"Server is not responding."</span>)</span><br><span class="line"></span><br><span class="line">fetch_data(<span class="string">"https://example.com/data"</span>)</span><br></pre></td></tr></table></figure><p>이 코드는 최대 3번까지 2초 간격으로 재시도합니다.</p><h2 id="05-exception_handler-예외-처리-간소화"><a class="markdownIt-Anchor" href="#05-exception_handler-예외-처리-간소화"></a> 05. <code>exception_handler</code>: 예외 처리 간소화</h2><p><code>exception_handler</code> 데코레이터는 함수에서 발생하는 예외를 잡아 처리할 수 있습니다. 필요에 따라 로깅하거나 추가적인 오류 처리를 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">f"An exception occurred: <span class="subst">&#123;str(e)&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@exception_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = x / y</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">An exception occurred: division by zero</span><br></pre></td></tr></table></figure><p>이 데코레이터는 코드를 단순화하고 예외 처리와 오류 로깅을 위한 일관된 절차를 설정하는 데 매우 유용합니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>데코레이터는 함수에 새로운 동작을 적용하는 매우 편리한 방법입니다. 데코레이터를 사용하면 복잡한 작업을 간소화하고 코드 가독성을 높이며, 생산성을 향상시킬 수 있습니다.</p><p>데코레이터는 파이썬의 강력한 기능 중 하나이며, 적절히 활용하면 코드의 유지보수성과 확장성을 높일 수 있습니다. 데코레이터를 사용해 여러분의 파이썬 코드를 한 단계 더 발전시켜보세요. 😊</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬에서 디자인 패턴 사용 방법</title>
      <link>http://hgko1207.github.io/2024/10/24/python-7/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-7/</guid>
      <pubDate>Thu, 24 Oct 2024 03:08:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Python은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한다고 생각합니다.&lt;/p&gt;
&lt;p&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Python은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한다고 생각합니다.</p><p>이 생각은 잘못된 것입니다. Python은 객체 지향 프로그래밍을 지원할 뿐만 아니라 디자인 패턴도 효과적으로 적용할 수 있습니다.</p><h2 id="디자인-패턴이란-무엇인가"><a class="markdownIt-Anchor" href="#디자인-패턴이란-무엇인가"></a> 디자인 패턴이란 무엇인가?</h2><p>디자인 패턴(Design Pattern)은 널리 인정받고 검증된 프로그래밍 경험의 집합입니다. 이는 다양한 프로그래밍 시나리오에서 적용할 수 있는 일반적인 솔루션을 제공합니다. 디자인 패턴의 등장은 코드 재사용, 시스템 확장성, 코드 가독성 등 소프트웨어 개발의 일반적인 문제를 해결하기 위함입니다.</p><h2 id="디자인-패턴을-사용하는-이유는"><a class="markdownIt-Anchor" href="#디자인-패턴을-사용하는-이유는"></a> 디자인 패턴을 사용하는 이유는?</h2><p>디자인 패턴을 사용하는 이점은 다음과 같습니다:</p><ul><li><strong>코드 재사용:</strong> 디자인 패턴을 사용하면 코드를 분해하고 조합하여 코드 재사용을 달성할 수 있습니다.</li><li><strong>시스템 확장성:</strong> 디자인 패턴은 시스템을 더 유연하게 만들고, 확장이 용이하며, 다양한 요구에 적응할 수 있게 합니다.</li><li><strong>코드 가독성:</strong> 디자인 패턴을 사용하면 코드의 가독성을 높여 코드가 더 명확해집니다.</li></ul><h2 id="파이썬에서의-디자인-패턴"><a class="markdownIt-Anchor" href="#파이썬에서의-디자인-패턴"></a> 파이썬에서의 디자인 패턴</h2><p>파이썬에서의 디자인 패턴은 다른 언어에서의 디자인 패턴과 유사하지만, 몇 가지 차이점이 있습니다. 파이썬에서의 디자인 패턴은 크게 세 가지로 나눌 수 있습니다: 생성 패턴, 구조 패턴, 행동 패턴.</p><p>이번 글에서는 몇 가지 일반적인 패턴을 설명합니다.</p><h2 id="1-팩토리-패턴-factory-pattern"><a class="markdownIt-Anchor" href="#1-팩토리-패턴-factory-pattern"></a> 1. 팩토리 패턴 (Factory Pattern)</h2><p>팩토리 패턴은 생성 패턴으로, 객체를 생성하는 가장 좋은 방법을 제공합니다. 이 패턴은 객체의 생성과 사용을 분리하여 객체 생성을 더 유연하게 만듭니다.</p><p>파이썬에서 팩토리 패턴을 사용하여 다양한 객체를 생성할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_animal</span><span class="params">(self, animal_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> animal_type == <span class="string">"dog"</span>:</span><br><span class="line">            <span class="keyword">return</span> Dog()</span><br><span class="line">        <span class="keyword">elif</span> animal_type == <span class="string">"cat"</span>:</span><br><span class="line">            <span class="keyword">return</span> Cat()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">factory = AnimalFactory()</span><br><span class="line">animal = factory.create_animal(<span class="string">"dog"</span>)</span><br><span class="line">print(animal.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: dog</span></span><br></pre></td></tr></table></figure><h2 id="2-싱글톤-패턴-singleton-pattern"><a class="markdownIt-Anchor" href="#2-싱글톤-패턴-singleton-pattern"></a> 2. 싱글톤 패턴 (Singleton Pattern)</h2><p>싱글톤 패턴은 클래스에 하나의 인스턴스만 존재하도록 보장하며, 전역 접근 지점을 제공합니다.</p><p><img src="/images/header/python-7_1.png" alt="" /></p><p>파이썬에서는 데코레이터를 사용하여 싱글톤 패턴을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton()</span><br><span class="line">b = Singleton()</span><br><span class="line"></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: True</span></span><br></pre></td></tr></table></figure><h2 id="3-어댑터-패턴-adapter-pattern"><a class="markdownIt-Anchor" href="#3-어댑터-패턴-adapter-pattern"></a> 3. 어댑터 패턴 (Adapter Pattern)</h2><p>어댑터 패턴은 구조 패턴으로, 클래스의 인터페이스를 클라이언트가 원하는 다른 인터페이스로 변환합니다.</p><p>파이썬에서는 어댑터 패턴을 사용하여 호환되지 않는 인터페이스 간의 호환성을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">specific_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(Target)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, adaptee)</span>:</span></span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.adaptee.specific_request()</span><br><span class="line"></span><br><span class="line">adaptee = Adaptee()</span><br><span class="line">adapter = Adapter(adaptee)</span><br><span class="line">adapter.request()</span><br></pre></td></tr></table></figure><h2 id="4-데코레이터-패턴-decorator-pattern"><a class="markdownIt-Anchor" href="#4-데코레이터-패턴-decorator-pattern"></a> 4. 데코레이터 패턴 (Decorator Pattern)</h2><p>데코레이터 패턴은 구조 패턴으로, 객체에 새로운 동작을 동적으로 추가할 수 있습니다.</p><p><img src="/images/header/python-7_2.png" alt="" /></p><p>파이썬에서는 데코레이터 함수를 사용하여 함수나 클래스의 동작을 수정할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call function:"</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: call function: foo hello world</span></span><br></pre></td></tr></table></figure><h2 id="5-옵저버-패턴-observer-pattern"><a class="markdownIt-Anchor" href="#5-옵저버-패턴-observer-pattern"></a> 5. 옵저버 패턴 (Observer Pattern)</h2><p>옵저버 패턴은 행동 패턴으로, 객체 간 일대다 관계를 정의하여, 객체의 상태가 변경될 때 이를 의존하는 모든 객체가 자동으로 업데이트됩니다.</p><p><img src="/images/header/python-7_3.png" alt="" /></p><p>파이썬에서는 옵저버 패턴을 사용하여 이벤트 중심의 프로그래밍을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        self.state = state</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span><span class="params">(Observer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        print(<span class="string">"state changed to:"</span>, subject.get_state())</span><br><span class="line"></span><br><span class="line">subject = ConcreteSubject()</span><br><span class="line">observer = ConcreteObserver()</span><br><span class="line">subject.attach(observer)</span><br><span class="line">subject.set_state(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: state changed to: 1</span></span><br></pre></td></tr></table></figure><h2 id="6-빌더-패턴-builder-pattern"><a class="markdownIt-Anchor" href="#6-빌더-패턴-builder-pattern"></a> 6. 빌더 패턴 (Builder Pattern)</h2><p>빌더 패턴은 복잡한 객체의 생성 과정을 그 표현과 분리하여 동일한 생성 과정으로 다양한 표현을 만들 수 있게 합니다.</p><p><img src="/images/header/python-7_4.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_car</span><span class="params">(self, builder)</span>:</span></span><br><span class="line">        builder.create_new_car()</span><br><span class="line">        builder.add_model()</span><br><span class="line">        builder.add_engine()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_new_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = Car()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.car</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.model = <span class="string">"Sports Car"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_engine</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.engine = <span class="string">"V8"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.engine = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">director = Director()</span><br><span class="line">car_builder = CarBuilder()</span><br><span class="line"></span><br><span class="line">director.construct_car(car_builder)</span><br><span class="line">car = car_builder.get_car()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Car Model: <span class="subst">&#123;car.model&#125;</span>, Engine: <span class="subst">&#123;car.engine&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="7-전략-패턴-strategy-pattern"><a class="markdownIt-Anchor" href="#7-전략-패턴-strategy-pattern"></a> 7. 전략 패턴 (Strategy Pattern)</h2><p>전략 패턴은 알고리즘 군을 정의하고, 이를 캡슐화하며, 이 알고리즘을 상호 교체 가능하게 만드는 패턴입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentContext</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, payment_strategy)</span>:</span></span><br><span class="line">        self.payment_strategy = payment_strategy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_payment</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.payment_strategy.pay(amount)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCardPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using Credit Card."</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PayPalPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using PayPal."</span></span><br><span class="line"></span><br><span class="line">credit_card_payment = CreditCardPayment()</span><br><span class="line">paypal_payment = PayPalPayment()</span><br><span class="line"></span><br><span class="line">context_credit_card = PaymentContext(credit_card_payment)</span><br><span class="line">context_paypal = PaymentContext(paypal_payment)</span><br><span class="line"></span><br><span class="line">print(context_credit_card.execute_payment(<span class="number">100</span>))</span><br><span class="line">print(context_paypal.execute_payment(<span class="number">50</span>))</span><br></pre></td></tr></table></figure><h2 id="8-책임-연쇄-패턴-chain-of-responsibility-pattern"><a class="markdownIt-Anchor" href="#8-책임-연쇄-패턴-chain-of-responsibility-pattern"></a> 8. 책임 연쇄 패턴 (Chain of Responsibility Pattern)</h2><p>책임 연쇄 패턴은 요청을 처리할 수 있는 여러 핸들러가 체인으로 연결되어 각 핸들러가 요청을 처리할지 또는 다음 핸들러로 전달할지 결정하는 패턴입니다.</p><p><img src="/images/header/python-7_5.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, successor=None)</span>:</span></span><br><span class="line">        self.successor = successor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.successor:</span><br><span class="line">            self.successor.handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"A"</span>:</span><br><span class="line">            print(<span class="string">"Handler A processing request A."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"B"</span>:</span><br><span class="line">            print(<span class="string">"Handler B processing request B."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.handler_chain = ConcreteHandlerA(ConcreteHandlerB())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        self.handler_chain.handle_request(request)</span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.make_request(<span class="string">"A"</span>)</span><br><span class="line">client.make_request(<span class="string">"B"</span>)</span><br></pre></td></tr></table></figure><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>Python은 절차 지향 언어일 뿐만 아니라 객체 지향 프로그래밍 스타일도 지원합니다. 디자인 패턴을 사용하면 Python의 객체 지향 기능을 더 잘 활용하여 코드를 더 유연하고, 읽기 쉽고, 유지보수가 용이하게 만들 수 있습니다.</p><p>파이썬에서의 디자인 패턴에는 팩토리 패턴, 싱글톤 패턴, 어댑터 패턴, 데코레이터 패턴, 옵저버 패턴 등이 포함됩니다. 이러한 패턴들은 다양한 프로그래밍 시나리오에 적용할 수 있으며, 소프트웨어 개발의 공통적인 문제를 해결하는 데 도움을 줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알아두면 유용한 12가지 파이썬 라이브러리</title>
      <link>http://hgko1207.github.io/2024/10/22/python-6/</link>
      <guid>http://hgko1207.github.io/2024/10/22/python-6/</guid>
      <pubDate>Tue, 22 Oct 2024 06:25:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Python은 그 단순함, 가독성, 그리고 방대한 라이브러리 생태계 덕분에 매우 유용한 언어입니다. 많은 개발자들이 &lt;code&gt;NumPy&lt;/code&gt;, &lt;code&gt;pandas&lt;/code&gt;, &lt;code&gt;requests&lt;/code&gt;, &lt;code&gt;Fl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Python은 그 단순함, 가독성, 그리고 방대한 라이브러리 생태계 덕분에 매우 유용한 언어입니다. 많은 개발자들이 <code>NumPy</code>, <code>pandas</code>, <code>requests</code>, <code>Flask</code>와 같은 유명한 라이브러리에 익숙하지만, 그 외에도 생산성을 높이고 특정 문제를 더 효율적으로 해결할 수 있는 덜 알려진 라이브러리들이 많이 존재합니다.</p><p>이러한 라이브러리들은 잘 알려진 라이브러리들에 비해 덜 주목받지만, 작업을 단순화하고, 워크플로를 최적화하며, 프로젝트에 혁신을 가져올 수 있는 독특한 기능들을 제공합니다.</p><p>Python에는 매우 유용하지만 널리 알려지지 않은 라이브러리들이 많이 있습니다. 이러한 라이브러리는 반복 작업을 자동화하고, 데이터를 더 효율적으로 처리하며, 적은 코드로 강력한 애플리케이션을 구축하는 데 도움을 줄 수 있습니다.</p><p>이번 글에서는 파일 처리, 데이터 처리, 웹 개발 등 다양한 분야에 걸친 라이브러리들을 소개하며, 개발 과정을 더 원활하고 효율적으로 만드는 방법을 알아보겠습니다.</p><h2 id="1-WeasyPrint-HTML과-CSS를-PDF로-변환">1. WeasyPrint - HTML과 CSS를 PDF로 변환</h2><p><strong>WeasyPrint</strong>는 HTML과 CSS를 PDF로 변환할 수 있는 간단하고 우아한 라이브러리입니다. 다른 PDF 라이브러리와 달리 복잡한 레이아웃을 지원하며, 웹 기술을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weasyprint <span class="keyword">import</span> HTML</span><br><span class="line"></span><br><span class="line">html_content = <span class="string">"""&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;p&gt;This is a PDF generated</span></span><br><span class="line"><span class="string">from HTML and CSS.&lt;/p&gt;"""</span></span><br><span class="line"></span><br><span class="line">HTML(string=html_content).write_pdf(<span class="string">"output.pdf"</span>)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 청구서나 보고서와 같은 PDF 파일을 동적으로 생성해야 하는 웹 애플리케이션에서 사용할 수 있습니다.</p><h2 id="2-Pyexcel-간단한-엑셀-데이터-처리">2. Pyexcel - 간단한 엑셀 데이터 처리</h2><p><strong>Pyexcel</strong>은 다양한 형식(.xls, .xlsx, .ods)의 엑셀 파일을 읽고, 쓰고, 조작할 수 있는 경량 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyexcel <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">data = p.get_array(file_name=<span class="string">"example.xlsx"</span>)</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 프로젝트에서 여러 엑셀 형식을 처리해야 할 때 유용합니다.</p><h2 id="3-Pendulum-간단한-날짜-시간-처리">3. Pendulum - 간단한 날짜/시간 처리</h2><p><strong>Pendulum</strong>은 Python의 <code>datetime</code> 라이브러리를 대체할 수 있는 라이브러리로, 직관적이고 간단한 API를 제공하며, 시간대 지원, 파싱, 포맷팅, 날짜 연산 등을 포함합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pendulum</span><br><span class="line"></span><br><span class="line">now = pendulum.now(<span class="string">'UTC'</span>)</span><br><span class="line"></span><br><span class="line">print(now.to_datetime_string())</span><br><span class="line"><span class="comment"># 출력: 2024-10-22 6:32:10</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 표준 <code>datetime</code> 라이브러리로 처리하기 번거로운 많은 복잡한 날짜 계산을 단순화합니다. 서머타임 변환과 같은 까다로운 부분도 자동으로 처리할 수 있습니다.</p><h2 id="4-Tenacity-Python용-재시도-라이브러리">4. Tenacity - Python용 재시도 라이브러리</h2><p><strong>Tenacity</strong>는 네트워크 요청이나 데이터베이스 연결과 같이 신뢰할 수 없는 함수에 대한 재시도 로직을 간단하게 처리할 수 있는 범용 재시도 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(stop=stop_after_attempt(3))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unreliable_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Attempting to execute..."</span>)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Failed"</span>)</span><br><span class="line"></span><br><span class="line">unreliable_function()</span><br></pre></td></tr></table></figure><p>이 라이브러리는 간헐적인 네트워크 오류를 유연하게 처리하는 데 유용합니다. 수동으로 재시도 로직을 작성하지 않고, 함수에 데코레이터를 적용하여 코드 복잡성을 줄이고 신뢰성을 높일 수 있습니다.</p><h2 id="5-Dataset-간단한-데이터베이스-상호작용">5. Dataset - 간단한 데이터베이스 상호작용</h2><p><strong>Dataset</strong>은 SQL 데이터베이스와 Python 구문을 사용해 상호작용할 수 있는 데이터베이스 추상화 계층입니다. SQL을 작성하지 않고도 데이터베이스 기반 애플리케이션을 빠르게 프로토타입할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dataset</span><br><span class="line"></span><br><span class="line">db = dataset.connect(<span class="string">'sqlite:///mydatabase.db'</span>)</span><br><span class="line"></span><br><span class="line">db[<span class="string">'users'</span>].insert(dict(name=<span class="string">'hgko'</span>, age=<span class="number">30</span>))</span><br></pre></td></tr></table></figure><p>이 라이브러리는 복잡한 ORM 설정을 걱정하지 않고 데이터베이스 상호작용을 처리할 수 있어, 애플리케이션 로직에 집중할 수 있게 해줍니다.</p><h2 id="6-Poetry-의존성-관리-및-패키징">6. Poetry - 의존성 관리 및 패키징</h2><p><strong>Poetry</strong>는 Python 프로젝트 관리의 의존성 관리 및 패키징 도구입니다. 단순한 설정 파일로 의존성 관리, 빌드, PyPI에 배포까지 처리할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry new my_project</span><br><span class="line">poetry add pendulum</span><br><span class="line">poetry add requests</span><br></pre></td></tr></table></figure><p>이 라이브러리는 가상 환경 설정, 의존성 관리, 프로젝트 패키징 과정을 간소화하며, pip, pipenv, setup.py와 같은 도구를 하나의 통합된 솔루션으로 대체할 수 있습니다.</p><h2 id="7-Dask-병렬-컴퓨팅-및-태스크-스케줄링">7. Dask - 병렬 컴퓨팅 및 태스크 스케줄링</h2><p><strong>Dask</strong>는 유연한 병렬 컴퓨팅 라이브러리로, 기존 Python 코드에 쉽게 통합할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 큰 데이터셋 읽기</span></span><br><span class="line">df = dd.read_csv(<span class="string">'large_dataset.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 병렬로 그룹화 연산 수행</span></span><br><span class="line">result = df.groupby(<span class="string">'category'</span>).sum().compute()</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 메모리에 적재하기 어려운 대규모 데이터셋을 처리할 때 유용합니다. Dask는 태스크를 더 작은 청크로 나누어 병렬로 처리함으로써 처리 시간을 크게 줄일 수 있습니다.</p><h2 id="8-Faker-테스트를-위한-가짜-데이터-생성">8. Faker - 테스트를 위한 가짜 데이터 생성</h2><p><strong>Faker</strong>는 이름, 주소, 이메일, 전화번호 등과 같은 가짜 데이터를 생성할 수 있는 라이브러리입니다. 테스트, 데이터 생성, 데이터베이스 시드(seed) 작업에 유용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fake = Faker()</span><br><span class="line"></span><br><span class="line">print(fake.name())  <span class="comment"># 랜덤한 이름 출력</span></span><br><span class="line">print(fake.address())  <span class="comment"># 랜덤한 주소 출력</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 애플리케이션 성능을 테스트할 대규모 데이터셋이 필요할 때 유용합니다.</p><h2 id="9-FlashText-빠른-키워드-검색-및-치환">9. FlashText - 빠른 키워드 검색 및 치환</h2><p><strong>FlashText</strong>는 키워드 기반의 빠른 검색 및 치환을 위한 라이브러리입니다. 정규 표현식보다 키워드 검색 작업에 훨씬 효율적입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flashtext <span class="keyword">import</span> KeywordProcessor</span><br><span class="line"></span><br><span class="line">keyword_processor = KeywordProcessor()</span><br><span class="line">keyword_processor.add_keyword(<span class="string">'JavaScript'</span>, <span class="string">'JS'</span>)</span><br><span class="line"></span><br><span class="line">text = <span class="string">"JavaScript is a popular programming language."</span></span><br><span class="line"></span><br><span class="line">print(keyword_processor.replace_keywords(text))</span><br><span class="line"><span class="comment"># 출력: JS is a popular programming language.</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 수백만 개의 레코드에서 여러 키워드를 치환해야 하는 경우에 특히 유용합니다.</p><h2 id="10-PyPDF2-PDF-파일-조작">10. PyPDF2 - PDF 파일 조작</h2><p><strong>PyPDF2</strong>는 PDF 파일을 합치거나, 분할하거나, 회전하거나, 텍스트를 추출할 수 있는 라이브러리입니다. 자동화된 워크플로에서 PDF 문서를 처리할 때 적합합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfReader, PdfWriter</span><br><span class="line"></span><br><span class="line">reader = PdfReader(<span class="string">'input.pdf'</span>)</span><br><span class="line"></span><br><span class="line">writer = PdfWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> reader.pages:</span><br><span class="line">    writer.add_page(page)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output.pdf'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer.write(f)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 여러 PDF 문서를 하나의 파일로 합치는 작업을 자동화하는 데 유용합니다.</p><h2 id="11-Humanize-데이터의-인간-친화적-변환">11. Humanize - 데이터의 인간 친화적 변환</h2><p><strong>Humanize</strong>는 숫자를 단어로 바꾸거나 날짜를 자연어로 표현하는 등 데이터를 더 읽기 쉽게 변환하는 도구를 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> humanize</span><br><span class="line"></span><br><span class="line">print(humanize.naturalsize(<span class="number">1024</span>))</span><br><span class="line"><span class="comment"># 출력: '1.0 kB'</span></span><br><span class="line"></span><br><span class="line">print(humanize.intword(<span class="number">1234567890</span>))</span><br><span class="line"><span class="comment"># 출력: '1.2 billion'</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 비기술적인 이해관계자에게 더 이해하기 쉬운 형식으로 데이터를 제시해야 하는 보고 도구에 특히 유용합니다.</p><h2 id="12-Memory-Profiler-Python-코드의-메모리-사용량-모니터링">12. Memory-Profiler - Python 코드의 메모리 사용량 모니터링</h2><p><strong>Memory-Profiler</strong>는 Python 프로그램의 메모리 사용량을 줄 단위로 모니터링할 수 있는 모듈입니다. 메모리 누수 식별이나 메모리 사용량 최적화에 유용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">my_func()</span><br></pre></td></tr></table></figure><p>이 라이브러리는 비효율적인 데이터 구조로 인해 메모리 사용량이 과도한 Python 스크립트를 최적화하는 데 사용할 수 있습니다. 병목 지점을 식별하고 애플리케이션의 메모리 사용량을 줄이는 데 도움이 됩니다.</p><h2 id="결론">결론</h2><p>Python의 방대한 생태계에는 잘 알려지지 않았지만 개발 경험을 크게 향상시킬 수 있는 라이브러리들이 많이 있습니다. 이러한 도구들을 적극적으로 사용해 보세요. 이러한 라이브러리들은 당신이 예상하지 못한 문제에 대한 해결책이 될 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/python-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 데이터 캐싱 방법</title>
      <link>http://hgko1207.github.io/2024/10/22/spring-7/</link>
      <guid>http://hgko1207.github.io/2024/10/22/spring-7/</guid>
      <pubDate>Tue, 22 Oct 2024 04:00:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 시스템 실행 중 성능을 향상시키기 위해 데이터를 캐싱하는 몇 가지 기술을 살펴보겠습니다. 일반적으로 계산하는 데 시간이 오래 걸리는 값을 캐싱하면 나중에 액세스할 때 시간을 절약할 수 있습니다. 캐싱되는 값은 자주 변경되지 않거나, 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 시스템 실행 중 성능을 향상시키기 위해 데이터를 캐싱하는 몇 가지 기술을 살펴보겠습니다. 일반적으로 계산하는 데 시간이 오래 걸리는 값을 캐싱하면 나중에 액세스할 때 시간을 절약할 수 있습니다. 캐싱되는 값은 자주 변경되지 않거나, 최신 버전이 필요하지 않은 경우가 많습니다.</p><p><img src="/images/header/spring-7.png" alt=""></p><h2 id="Spring-Boot에서-캐싱">Spring Boot에서 캐싱</h2><p>Spring Boot REST API에서 캐싱을 활성화하는 가장 간단한 방법은 애플리케이션에 설정하고, 엔드포인트에 <code>@Cacheable</code> 어노테이션을 사용하는 것입니다.</p><p>애플리케이션에서 다음과 같이 <code>@EnableCaching</code> 어노테이션을 추가하기만 하면 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootCachingApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootCachingApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러에서, 캐싱하고자 하는 메서드에 <code>@Cacheable</code> 어노테이션을 추가합니다.</p><ul><li><code>/v1/status</code> API는 캐싱이 설정되지 않았으므로, 호출할 때마다 실제 메서드가 실행됩니다.</li><li><code>/v2/status</code> API는 캐싱이 설정되어 있으므로, 첫 번째 호출만 메서드를 실행하고 이후 호출에서는 캐싱된 결과를 반환합니다.</li><li><code>/v3/status</code> API는 캐싱 설정에 매개변수를 포함하여, 캐시가 매개변수에 따라 결과를 다르게 저장하도록 합니다. 즉, 이전에 사용된 매개변수로 호출하면 캐싱된 결과를 사용하고, 그렇지 않으면 메서드를 실행합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v1/status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V1 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"DONE"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v2/status"</span>)</span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V2 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"DONE"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v3/status/&#123;param&#125;"</span>)</span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV3</span><span class="params">(@PathVariable <span class="keyword">final</span> <span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V3 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(param == <span class="number">1</span> ? <span class="string">"DONE"</span> : <span class="string">"IN PROCESS"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JPA-캐싱">JPA 캐싱</h2><p>때로는 API의 결과를 캐싱할 수 없지만, 쿼리의 결과를 캐싱함으로써 동일한 쿼리를 여러 번 실행하는 것을 피할 수 있습니다. JPA와 Spring Boot는 이를 스마트하게 처리할 수 있습니다.</p><p>엔티티를 정의해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런 다음, 리포지토리에서 <code>@Cacheable</code> 어노테이션을 추가하여 결과를 캐시에 저장할 메서드를 지정합니다. <code>findById</code>와 같은 “standard” 메서드를 캐싱해야 하는 경우, 이를 오버라이드하고 어노테이션을 추가할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"customers"</span>)</span><br><span class="line">  <span class="function">Optional&lt;Customer&gt; <span class="title">findById</span><span class="params">(Long aLong)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"customers"</span>)</span><br><span class="line">  <span class="function">List&lt;Customer&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Caffeine">Caffeine</h2><p>일부 경우에는 REST 엔드포인트나 JPA 레벨에서 캐시를 사용할 수 없는 경우가 있습니다. 이때는 캐시를 수동으로 구현해야 하며, 이를 위해 <a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a> 라이브러리를 사용할 수 있습니다.</p><p>Caffeine은 캐시에 저장할 요소의 최대 개수를 정의하고 만료 조건을 설정할 수 있습니다.</p><p>프로젝트에 다음 의존성을 추가해야 합니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>사용법은 매우 직관적입니다:</p><ul><li>키와 값을 사용해 캐시를 정의합니다.</li><li>캐시의 최대 크기를 설정할 수 있습니다.</li><li>만료 기간을 설정할 수 있습니다.</li><li>build 메서드에서 캐시 미스가 발생했을 때 캐시를 채우는 방법을 정의합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Long, String&gt; customerCache =</span><br><span class="line">      Caffeine.newBuilder()</span><br><span class="line">          .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">          .expireAfterWrite(Duration.ofMinutes(<span class="number">5</span>))</span><br><span class="line">          .refreshAfterWrite(Duration.ofMinutes(<span class="number">1</span>))</span><br><span class="line">          .build(<span class="keyword">this</span>::findCustomerName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">findCustomerName</span><span class="params">(<span class="keyword">final</span> Long key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> customerRepository.findById(key).map(Customer::getName).orElse(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getCustomerName</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> customerCache.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getCustomerName</code>을 호출하면, 이 메서드는 캐시 정의에 따라 실행됩니다. 먼저, 해당 키와 일치하는 항목이 있는지 확인하고, 그렇지 않으면 <code>findCustomerName</code> 메서드를 호출해 캐시를 채웁니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/spring-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 성능 향상을 위한 작은 팁들</title>
      <link>http://hgko1207.github.io/2024/10/22/java-5/</link>
      <guid>http://hgko1207.github.io/2024/10/22/java-5/</guid>
      <pubDate>Tue, 22 Oct 2024 03:02:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;극한의 애플리케이션에서 성능을 최적화해야 하는 문제에 직면한 Java 개발자라면, 이는 쉽지 않은 과제임을 잘 아실 것입니다. 이 글에서는 시스템 아키텍처를 그대로 유지하면서 약간의 코드 수정을 통해 성능을 향상시킬 수 있는 몇 가지 전략과 요령
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>극한의 애플리케이션에서 성능을 최적화해야 하는 문제에 직면한 Java 개발자라면, 이는 쉽지 않은 과제임을 잘 아실 것입니다. 이 글에서는 시스템 아키텍처를 그대로 유지하면서 약간의 코드 수정을 통해 성능을 향상시킬 수 있는 몇 가지 전략과 요령을 살펴봅니다.</p><h2 id="극한-상황이란-무엇인가요">극한 상황이란 무엇인가요?</h2><p>이 글에서 '극한 상황’이란 반복적인 작업을 수행하거나 대량의 데이터를 처리해야 하는 애플리케이션을 의미합니다. 이러한 요구는 다양한 분야에서 흔히 발생합니다.</p><ul><li><strong>금융 애플리케이션:</strong> 금융에서는 백그라운드 작업이 수백만에서 수십억 개의 레코드를 처리하는 일이 일반적입니다.</li><li><strong>머신 러닝:</strong> Java는 머신 러닝에 자주 사용되지는 않지만, 이러한 애플리케이션들은 대규모 데이터셋을 처리하는 경우가 많습니다.</li><li><strong>분석:</strong> 분석 애플리케이션은 대규모 데이터셋에 접근해 보고서를 생성하는 경우가 많습니다.</li></ul><h2 id="HashMap">HashMap</h2><p>대량의 데이터를 저장하기 위해 HashMap을 생성할 때는 문자열 대신 숫자 필드를 키로 사용하는 것이 좋습니다. 이를 설명하기 위해 각 키 유형에 대해 요소를 추가하는 경우와 요소를 액세스하는 경우를 비교해 보겠습니다.</p><p>아래 차트는 String 키와 Integer 키를 사용해 HashMap에 엔트리를 추가할 때의 실행 시간을 비교합니다. x축은 HashMap에 추가된 레코드 수를 나타내고, y축은 해당 작업을 100회 반복하는 데 소요된 시간을 나타냅니다.</p><p><img src="/images/header/java-5_1.png" alt=""></p><p>Java는 HashMap 작업 처리에서 최적화된 성능을 보여주며, 특히 백만 개의 엔트리까지는 키 유형과 상관없이 일관된 성능을 유지합니다. 이는 Java의 해시 계산 메커니즘이 내부 구조에 숫자 값을 사용해 효율적으로 엔트리를 배치하기 때문입니다.</p><p>그러나 백만 개 이상의 엔트리를 처리하는 극한 상황에서는 성능 저하가 나타납니다. 이는 해시 함수가 서로 다른 엔트리에 대해 동일한 값을 생성하여, HashMap 내부에서 해시 충돌을 해결하기 위한 추가 처리가 발생하기 때문입니다. 특히 문자열 키를 사용할 때 이러한 성능 저하가 더 두드러집니다.</p><p>HashMap에서 요소를 액세스하기 위해 <code>get</code> 메서드를 사용할 때도 유사한 성능 패턴을 보이며, 이는 큰 데이터셋이나 해시 충돌을 처리할 때 성능 저하가 나타나는 현상을 반영합니다.</p><p><img src="/images/header/java-5_2.png" alt=""></p><h2 id="BigDecimal-vs-BigInteger-vs-Long-vs-long">BigDecimal vs BigInteger vs Long vs long</h2><p>Java에서 대규모 데이터셋을 처리할 때는 수치 연산이 필요하며, 다양한 요구에 맞게 여러 데이터 타입을 제공합니다:</p><ul><li><strong>long:</strong> -2⁶³에서 2⁶³ - 1 사이의 정수를 저장할 수 있는 기본 타입입니다.</li><li><strong>Long:</strong> long 타입의 박싱된 객체 타입입니다.</li><li><strong>BigDecimal:</strong> 높은 정밀도로 큰 소수 값을 저장하기 위한 클래스입니다.</li><li><strong>BigInteger:</strong> long의 범위를 초과하는 큰 정수를 처리하기 위한 클래스입니다.</li></ul><p>금융이나 과학적 데이터 처리를 위해서는 정확한 소수 계산이 필요하므로 <strong>BigDecimal</strong>을 사용하는 것이 권장됩니다. 그러나 비소수 연산에서는 <strong>long</strong>, <strong>Long</strong>, <strong>BigInteger</strong>를 상황에 맞게 사용할 수 있습니다.</p><p>다음 차트는 각 데이터 타입으로 100만 개 요소를 생성했을 때의 메모리 사용량을 보여줍니다.</p><p><img src="/images/header/java-5_3.png" alt=""></p><p>메모리 사용량 비교를 보면 <strong>Long</strong>(박싱된 타입), <strong>long</strong>(기본 타입), <strong>BigInteger</strong> 사이에 큰 차이가 있음을 알 수 있습니다. 특히 <strong>BigInteger</strong>로 100만 개 요소를 생성하면 60MB 이상의 메모리가 소모되지만, <strong>long</strong>을 사용하면 10MB 미만으로 메모리가 필요합니다. 이는 대규모 데이터셋을 처리하는 애플리케이션에서 메모리 할당을 고려해야 하는 중요성을 강조합니다.</p><h2 id="리스트-정렬">리스트 정렬</h2><p>Java는 효율적인 리스트 정렬로 잘 알려져 있지만, 몇 가지 고려 사항이 필요합니다. 여기서는 String을 비교 필드로 사용하는 리스트, Integer를 사용하는 리스트, 그리고 복잡한 객체(Complex Object)를 사용하는 리스트의 정렬 시간을 살펴보겠습니다. 각 리스트 유형(ArrayList, LinkedList, Vector)을 분석합니다.</p><p>ArrayList 중에서는 Integer 비교를 기반으로 한 정렬이 특히 백만 개 이상의 요소를 가진 리스트에서 빠른 성능을 보입니다. 반면, 복잡한 객체를 포함한 리스트의 정렬은 다른 유형에 비해 느립니다.</p><p><img src="/images/header/java-5_4.png" alt=""></p><p>아래 차트는 ArrayList 대신 LinkedList를 사용한 경우를 비교한 것입니다. 동작은 일관되지만, Integer를 비교 기준으로 한 리스트의 정렬이 백만 개 이상의 요소를 처리할 때 더 빠르게 수행됩니다. 또한, ArrayList에 비해 전반적으로 실행 시간이 느린 점도 주목할 만합니다.</p><p><img src="/images/header/java-5_5.png" alt=""></p><p>이번에는 종종 개발에서 간과되는 Java 리스트인 Vector를 살펴보겠습니다. 이전 비교와 유사한 패턴을 보이지만, Vector가 속도 면에서 다른 두 리스트보다 더 우수한 성능을 보여 다소 놀라운 결과를 나타냈습니다.</p><p><img src="/images/header/java-5_6.png" alt=""></p><p>String, Integer, Complex Object를 사용하여 1000만 개 요소를 정렬하는 데 걸린 시간을 비교한 후 다음과 같은 결론을 도출할 수 있습니다:</p><ul><li>LinkedList는 긴 리스트를 정렬할 때 느린 성능을 보였습니다.</li><li>Vector는 정렬 시 가장 빠른 리스트 구현으로 나타났습니다.</li><li>숫자, 특히 Integer를 정렬하는 것이 다른 데이터 타입을 정렬하는 것보다 더 빠릅니다.</li></ul><p><img src="/images/header/java-5_7.png" alt=""></p><h2 id="결론">결론</h2><p>대량의 데이터를 처리하는 애플리케이션을 개발할 때 성능 최적화는 매우 중요한 과제입니다. 적절한 Java 리스트 구현을 선택하면 성능을 크게 향상시킬 수 있으며, 적절한 데이터 타입을 선택하면 시스템 성능을 향상시키는 동시에 메모리도 절약할 수 있습니다.</p><p>이 글에서는 대규모 데이터를 처리하는 애플리케이션에서 데이터 타입과 Java 리스트 구현을 신중하게 선택하는 것이 중요하다는 점을 강조했습니다. 처리하는 요소가 수천 개에 불과한 경우에는 성능 향상이 큰 의미가 없을 수 있으므로, 이러한 선택을 신중하게 고려해야 합니다.</p><p>많은 경우, Java 구현을 단순히 변경하는 것만으로는 시스템 아키텍처를 수정하거나 데이터베이스 쿼리를 최적화하는 것만큼 큰 성능 향상을 기대하기 어렵습니다. 적절한 데이터 타입과 리스트 구현을 선택하는 것도 중요하지만, 전반적인 아키텍처적 고려가 성능에 더 큰 영향을 미칠 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/java-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바 스트림의 7가지 활용 팁</title>
      <link>http://hgko1207.github.io/2024/10/21/java-4/</link>
      <guid>http://hgko1207.github.io/2024/10/21/java-4/</guid>
      <pubDate>Mon, 21 Oct 2024 05:19:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;스트림(Stream)은 여러 해 전 도입되었지만, Java 개발자들은 여전히 이 강력한 도구를 완전히 활용하지 못하고 있습니다. 이 글에서는 다음 프로젝트에 참고할 수 있는 유용한 스트림 활용 팁을 소개합니다.&lt;/p&gt;
&lt;p&gt;아래 예제에서는 다음 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>스트림(Stream)은 여러 해 전 도입되었지만, Java 개발자들은 여전히 이 강력한 도구를 완전히 활용하지 못하고 있습니다. 이 글에서는 다음 프로젝트에 참고할 수 있는 유용한 스트림 활용 팁을 소개합니다.</p><p>아래 예제에서는 다음 클래스들을 사용할 것입니다.</p><p><img src="/images/header/java-4_1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Address address;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Person&gt; personList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String street;</span><br><span class="line">  <span class="keyword">private</span> City city;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-메서드-참조를-사용하여-map-단순화하기">1. 메서드 참조를 사용하여 map 단순화하기</h2><p>다음 코드는 회사들의 주소에서 도시 이름을 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(company -&gt; company.getAddress().getCity().getName())</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 더 가독성 있게 다음과 같이 변경할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Null-체크하기">2. Null 체크하기</h2><p>위 코드를 null 체크와 함께 작성하면 다음과 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-스트림을-단일-스트림으로-변환하기">3. 스트림을 단일 스트림으로 변환하기</h2><p>다음 코드는 모든 회사로부터 사람 목록을 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAllPerson</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Person의 리스트를 가진 리스트를 만듭니다.</span></span><br><span class="line">  List&lt;List&lt;Person&gt;&gt; partialResult = companyList.stream()</span><br><span class="line">    .map(Company::getPersonList)</span><br><span class="line">    .toList();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 각 Person 리스트를 결과에 추가합니다.</span></span><br><span class="line">  List&lt;Person&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  partialResult.forEach(result::addAll);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 동일한 작업을 다음과 같이 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAllPerson</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getPersonList) <span class="comment">// Stream&lt;List&lt;Person&gt;&gt;을 반환합니다.</span></span><br><span class="line">    .flatMap(List::stream)  <span class="comment">// Stream&lt;Person&gt;으로 변환합니다.</span></span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-속성별-그룹화하기">4. 속성별 그룹화하기</h2><p>다음 코드는 각 도시에 있는 회사 목록을 Map으로 반환합니다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;City, List&lt;Company&gt;&gt; getCompaniesByCity(List&lt;Company&gt; companyList)&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(company -&gt; company.getAddress().getCity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-스트림에-특정-항목이-있는지-확인하기">5. 스트림에 특정 항목이 있는지 확인하기</h2><p>다음 코드는 특정 도시에 회사가 있는지 확인합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCompanyInCity</span><span class="params">(List&lt;Company&gt; companyList, String cityName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .anyMatch(cityName::equals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 도시에 회사가 없는지를 확인하려면 noneMatch를 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNoCompanyInCity</span><span class="params">(List&lt;Company&gt; companyList, String cityName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .noneMatch(cityName::equals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-로깅하기">6. 로깅하기</h2><p>각 도시 이름을 반환할 때 로그를 기록하려면 peek 메서드를 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .peek(cityName -&gt; log.info(cityName))</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-고유한-도시-이름-가져오기">7. 고유한 도시 이름 가져오기</h2><p>distinct를 사용해 스트림에서 중복된 도시 이름을 제거할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUniqueCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .distinct()</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>이 방법들을 통해 스트림을 보다 효과적으로 사용하고 코드의 가독성과 성능을 높일 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/21/java-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring Boot] 대용량 데이터 쿼리 REST 엔드포인트 처리</title>
      <link>http://hgko1207.github.io/2024/10/21/spring-6/</link>
      <guid>http://hgko1207.github.io/2024/10/21/spring-6/</guid>
      <pubDate>Mon, 21 Oct 2024 04:53:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/spring-6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 글에서는 메모리 소비 문제로 인해 기존 방식으로는 구현할 수 없는 REST 엔드포인트의 예를 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;시나리오&quot;&gt;시나
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/spring-6.png" alt=""></p><p>이 글에서는 메모리 소비 문제로 인해 기존 방식으로는 구현할 수 없는 REST 엔드포인트의 예를 살펴보겠습니다.</p><h2 id="시나리오">시나리오</h2><p>이번 예제에서는 Customer, Order, OrderItem, 그리고 Product로 구성된 간단한 시나리오를 사용합니다.</p><p><img src="/images/header/spring-6_1.png" alt=""></p><p>우리의 목표는 보고서를 생성하는 엔드포인트를 만드는 것입니다. 이 엔드포인트는 다음 데이터를 쿼리하고 반환해야 합니다.</p><ul><li>백만 개의 주문(Orders)</li><li>500만 개 이상의 주문 항목(OrderItems)</li></ul><h2 id="기존-구현">기존 구현</h2><p>몇 가지 필드를 가진 DTO를 정의해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportDto</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Long orderId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LocalDate date;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String customerName;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer quantity;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리포지토리는 Order 엔티티를 위한 <code>CrudRepository</code>이며, JPA 관계를 통해 다른 데이터를 모두 가져올 수 있습니다. 여기서는 단순함을 위해 <code>findAll</code> 메서드를 사용하여 데이터를 반환합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스는 다음 작업을 수행합니다.</p><ul><li>결과를 저장할 <code>ArrayList</code>를 생성합니다.</li><li>리포지토리의 <code>findAll</code> 메서드를 호출해 주문 데이터를 가져옵니다.</li><li>쿼리 결과를 반복하여 DTO로 매핑합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ReportDto&gt; <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> ArrayList&lt;ReportDto&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> order : orderRepository.findAll()) &#123;</span><br><span class="line">      result.add(mapToOrder(order));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러는 단순히 서비스의 메서드를 호출하고 결과를 반환합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReportService reportService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v1/report"</span>)</span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;List&lt;ReportDto&gt;&gt; report() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = reportService.getResult();</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>curl</code>을 사용해 엔드포인트를 테스트한 결과, 45분 후 다음과 같은 오류가 발생했습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"\n"</span> -X GET http://localhost:8000/v1/report</span><br><span class="line">&#123;<span class="string">"timestamp"</span>:<span class="string">"2024-06-21T19:50:05.720+00:00"</span>,<span class="string">"status"</span>:500,<span class="string">"error"</span>:<span class="string">"Internal Server Error"</span>,<span class="string">"path"</span>:<span class="string">"/v1/report"</span>&#125;</span><br></pre></td></tr></table></figure><p>서비스 출력에서 다음과 같은 로그를 확인할 수 있었습니다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Exception</span>: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread <span class="string">"http-nio-8000-Poller"</span></span><br><span class="line"><span class="keyword">Exception</span> in thread <span class="string">"mysql-cj-abandoned-connection-cleanup"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>데이터베이스 쿼리 결과가 사용 가능한 메모리보다 커서 데이터 쿼리에 실패했습니다.</p><h2 id="쿼리-해결">쿼리 해결</h2><p>첫 번째 단계는 대용량 데이터를 효율적으로 처리하기 위해 쿼리 프로세스를 개선하는 것입니다.</p><p>우선, 리포지토리에서 <code>List</code>이나 <code>Iterable</code> 대신 <code>Stream</code>을 반환하는 메서드를 정의해 보겠습니다. 반환 유형으로 <code>Stream</code>을 사용하면 데이터베이스에서 데이터를 한꺼번에 가져오지 않습니다. 대신 스트림을 소비하면서 청크 단위로 반환됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Stream&lt;Order&gt; <span class="title">findAllBy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스도 수정해야 합니다.</p><ul><li>리포지토리가 스트림을 반환하고 데이터가 데이터베이스에서 필요할 때만 가져오므로, 전체 실행 동안 트랜잭션을 열어 두어야 합니다. 읽기 전용 트랜잭션을 사용하기 위해 <code>@Transactional(readOnly = true)</code> 어노테이션을 사용합니다.</li><li>데이터베이스에서 데이터를 가져오는 스트림을 처리할 때 스트림을 올바르게 닫아야 하므로, <code>try-with-resources</code> 구문을 사용합니다.</li><li>JPA가 엔티티를 메모리에 계속 유지하지 않도록 <code>EntityManager</code>를 사용해 수동으로 분리(detach)합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ReportDto&gt; <span class="title">getResult2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> ArrayList&lt;ReportDto&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> orderStream = orderRepository.findAllBy()) &#123;</span><br><span class="line">      orderStream.forEach(</span><br><span class="line">          order -&gt; &#123;</span><br><span class="line">            result.add(mapToOrder(order));</span><br><span class="line">            entityManager.detach(order);</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러는 동일하지만 이제 API의 두 번째 버전을 참조합니다. 이를 통해 다음과 같은 응답을 얻을 수 있습니다.</p><p>컨트롤러는 동일하지만 이제 API 버전 2를 참조합니다. 이를 통해 다음과 같은 응답을 얻을 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"\n"</span> -X GET http://localhost:8000/v2/report</span><br></pre></td></tr></table></figure><p>응답</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"orderId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"date"</span>:<span class="string">"2022-08-25"</span>,</span><br><span class="line">    <span class="attr">"customerName"</span>:<span class="string">"Booker"</span>,</span><br><span class="line">    <span class="attr">"totalAmount"</span>:<span class="number">19104.36</span>,</span><br><span class="line">    <span class="attr">"currency"</span>:<span class="string">"CDF"</span>,</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"Shipped"</span>,</span><br><span class="line">    <span class="attr">"paymentMethod"</span>:<span class="string">"Credit Card"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">93</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Rustic Bronze Bag"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">41</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">465.96</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">19104.36</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"orderId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"date"</span>:<span class="string">"2022-03-29"</span>,</span><br><span class="line">    <span class="attr">"customerName"</span>:<span class="string">"Danielle"</span>,</span><br><span class="line">    <span class="attr">"totalAmount"</span>:<span class="number">14685.35</span>,</span><br><span class="line">    <span class="attr">"currency"</span>:<span class="string">"MUR"</span>,</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"Processing"</span>,</span><br><span class="line">    <span class="attr">"paymentMethod"</span>:<span class="string">"Credit Card"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">52</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Mediocre Copper Bench"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">98</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">46.02</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">4509.96</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">71</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Fantastic Bronze Hat"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">31</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">233.61</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">7241.91</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Mediocre Silk Bottle"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">22</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">133.34</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">2933.48</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>JPA 메모리 문제를 해결했지만, 결과를 반환하는 데 42분이 소요되었습니다. 더 나은 방법이 필요해 보입니다.</p><h2 id="결과-스트리밍">결과 스트리밍</h2><p>Java가 대량의 데이터를 처리하는 데 시간이 오래 걸리는 이유는 데이터 구조가 커질수록 성능이 저하되기 때문입니다. 해결책은 스트림을 사용해 데이터를 반환하는 것입니다. 클라이언트 측에서는 파일을 다운로드하는 것과 유사하게 서버가 데이터를 청크 단위로 전송합니다.</p><p>컨트롤러는 이제 <code>StreamingResponseBody</code>를 반환합니다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/v3/report"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;StreamingResponseBody&gt; <span class="title">report3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = reportService.getResult();</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스도 몇 가지 변경 사항이 필요합니다.</p><ul><li>스트림을 사용해 데이터를 반환하므로, <code>TransactionTemplate</code>을 사용해 트랜잭션을 수동으로 제어해야 합니다. 이를 위해 <code>PlatformTransactionManager</code>가 필요하며, 생성자에서 전달받습니다.</li><li><code>TransactionTemplate</code>을 사용해 핵심 실행 로직을 캡슐화하고, <code>fillStream</code> 메서드가 이를 수행합니다.</li><li><code>fillStream</code> 메서드는 <code>ObjectMapper</code>를 사용해 결과를 JSON으로 변환합니다. 데이터베이스에서 각 주문을 가져와 DTO로 매핑하고, JSON으로 변환한 후 <code>StreamingResponseBody</code>에 씁니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReportService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      PlatformTransactionManager platformTransactionManager,</span></span></span><br><span class="line"><span class="function"><span class="params">      OrderRepository orderRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">      EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionTemplate = <span class="keyword">new</span> TransactionTemplate(platformTransactionManager);</span><br><span class="line">    <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line"></span><br><span class="line">    objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StreamingResponseBody <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> outputStream -&gt; transactionTemplate.execute(</span><br><span class="line">        <span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            fillStream(outputStream);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillStream</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> orderStream = orderRepository.findAllBy()) &#123;</span><br><span class="line">      orderStream.forEach(order -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> json = objectMapper.writeValueAsString(mapToOrder(order));</span><br><span class="line">          outputStream.write(json.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">          entityManager.detach(order);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 변경 사항을 적용한 후, 엔드포인트를 호출하면 몇 초 후부터 응답을 받을 수 있습니다. 데이터가 스트리밍 방식으로 반환되므로, Java가 이를 처리하는 데 사용하는 메모리 양은 매우 적어져 성능이 크게 향상됩니다. 실제로, 성능 개선 효과는 매우 커서 실행 시간이 42분에서 단 30초로 줄어들었습니다!</p><h2 id="결론">결론</h2><p>쿼리 자체를 최적화해, 데이터베이스 조회 횟수를 줄이는 방식으로 DTO 형식의 결과를 직접 반환하는 특정 쿼리를 사용하면 이 코드를 더욱 개선할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/21/spring-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>가장 강력한 머신 러닝 모델 설명 (Transformers, CNNs, RNNs, GANs 등)</title>
      <link>http://hgko1207.github.io/2024/10/18/ai-27/</link>
      <guid>http://hgko1207.github.io/2024/10/18/ai-27/</guid>
      <pubDate>Fri, 18 Oct 2024 05:35:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;머신 러닝은 방대한 분야이며, 현재 기술의 최전선에 있는 모델과 기법들을 개괄적으로 다룬 자료를 찾는 것이 어렵게 느껴질 수 있습니다. 따라서, 이 글에서
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-27.png" alt=""></p><p>머신 러닝은 방대한 분야이며, 현재 기술의 최전선에 있는 모델과 기법들을 개괄적으로 다룬 자료를 찾는 것이 어렵게 느껴질 수 있습니다. 따라서, 이 글에서는 각 모델을 과학적으로 분석하기보다는 개념적으로 탐구해보겠습니다. 각 모델에 대해 더 깊이 파고들기를 권장하며, 이론이 실무와 연결되어야 한다고 생각하기 때문에 실제 사용 예시도 제공하겠습니다. 만약 빠진 정보가 있다면 피드백을 주시고, 추가 정보를 요청해주세요.</p><p>시작하기 전에 다룰 모델 목록은 다음과 같습니다.</p><ul><li>CNN (Convolutional Neural Networks)</li><li>RNN (Recurrent Neural Networks)</li><li>Transformers</li><li>GAN (Generative Adversarial Networks)</li></ul><h2 id="CNN-합성곱-신경망">CNN (합성곱 신경망)</h2><p>CNN(Convolutional Neural Network, 합성곱 신경망)은 신경망의 한 종류로, 토폴로지 데이터(위상적 데이터)에 뛰어나며 패턴 감지에 특화되도록 수정된 모델입니다. 그렇다면 CNN은 어떻게 다를까요? 시작하기 전에, 신경망이 무엇인지 간단히 설명해 드리겠습니다.</p><p>간단히 말해, 신경망은 입력 데이터를 처리하여 출력을 생성하는 &quot;노드의 맵&quot;입니다. 신경망은 입력을 결과로 변환하면서 한 레이어의 노드 집합을 다른 레이어의 노드 집합으로 매핑하는 여러 레이어로 구성되어 있습니다. 이 매핑 과정은 가중치(weights)를 통해 이루어지며, 이는 입력을 변경하여 원하는 결과를 도출하는 데 사용됩니다. 각 단계 후에는 편향(bias)이 적용됩니다. 학습 과정에서 변경되는 것은 바로 이 가중치와 편향입니다.</p><p><img src="/images/header/ai-27_1.png" alt=""></p><h3 id="CNN의-특별한-점은-무엇일까요">CNN의 특별한 점은 무엇일까요?</h3><p>CNN을 다른 신경망과 구분 짓는 것은 바로 <strong>합성곱 레이어</strong>(convolutional layers)를 사용하는 점입니다. CNN은 다른 유형의 레이어도 가질 수 있지만, 합성곱이 그만의 독특함을 부여합니다. 다음은 이 레이어가 어떻게 작동하는지 설명입니다.</p><p>이미지의 각 픽셀이 밝기 값이라고 가정하면, 이미지는 2차원 숫자 행렬로 표현될 수 있습니다. 합성곱은 이 행렬에 커널(kernel)을 적용하여 출력 행렬을 생성합니다. 커널은 이미지의 각 영역에 필터처럼 작용하는 작은 행렬입니다.</p><p>이 작은 커널 행렬은 이미지라는 큰 행렬을 &quot;Steps&quot;하며 출력 행렬을 생성합니다.</p><p><img src="/images/header/ai-27_2.gif" alt=""></p><h3 id="주요-개념">주요 개념</h3><p>몇 가지 중요한 개념은 다음과 같습니다.</p><ul><li>커널은 이미지의 각 픽셀과 그 주변 영역에 적용되지만, 전체적으로 동일하게 유지됩니다. 이는 커널이 해당 픽셀 영역의 패턴이나 특징을 감지하기 위한 것이기 때문입니다.</li><li>커널은 이미지보다 훨씬 작기 때문에 학습 과정에서 큰 도움이 됩니다.</li><li>커널의 아이디어는 어떤 이미지든 우리가 분해할 수 있는 패턴들의 집합이라는 점에 기반합니다. 예를 들어, 얼굴을 가지고 있다고 가정해봅시다. 동그라미를 감지할 수 있는 커널이 있다고 할 때, 이 커널의 출력은 이미지 상단 부분(눈 부분)에 두 개의 밝은 점을 생성할 수 있습니다. 이제 가까운 두 개의 선을 감지하는 커널을 사용하면, 출력은 하단 부분(입 부분)에 밝은 점을 생성합니다. 마지막으로, 이러한 두 개의 동그라미와 하단의 두 선을 감지할 수 있는 커널이 있다면, 이는 얼굴을 인식할 수 있게 됩니다.</li><li>합성곱 레이어는 이러한 커널을 여러 개 적용하여 여러 개의 새로운 이미지를 생성할 수 있습니다. 이러한 이미지는 네트워크에서 다음 레이어로 전달되며, 이후 또 다른 합성곱 레이어가 다른 커널을 적용합니다.</li><li>CNN은 보통 이미지의 크기와 복잡성을 줄이기 위해 풀링 레이어(<strong>pooling</strong> layers)를 포함합니다.</li></ul><p>물론, 여기에는 더 많은 수학적 상세 정보가 있지만, CNN의 주요 직관은 <strong>커널</strong>에 있습니다.</p><p>CNN을 사용하는 인기 있는 도구와 제품으로는 Google Photos, DeepMind의 AlphaGo, Tesla의 자율주행 시스템 등이 있습니다.</p><h2 id="RNN-순환-신경망">RNN (순환 신경망)</h2><p>CNN이 주로 이미지 처리에 사용되는 반면, RNN은 주로 자연어 처리(NLP)와 시계열 분석과 같은 분야에 사용됩니다. RNN의 아키텍처를 이해하려면, 먼저 NLP 문제에서 단순한 신경망을 사용하는 데 있어서의 문제점을 살펴보겠습니다.</p><p>예를 들어, 텍스트 자동 완성 문제를 생각해 봅시다. 모델의 입력은 텍스트 조각이고, 출력 역시 또 다른 텍스트 조각입니다. 문제는 입력이 <strong>가변적인 크기</strong>(몇 단어일 수도 있고 많은 단어일 수도 있음)라는 점입니다. 단순 신경망은 일반적으로 <strong>고정된 입력 크기</strong>를 가지기 때문에 이러한 문제를 처리하기 어렵습니다. 또 다른 문제는 입력 내 단어들 간의 복잡한 관계를 포착하여 올바른 출력을 생성하는 것입니다. 예를 들어, 영어에는 수천 개의 단어가 있으며, 문장에서 단어의 순서가 의미를 크게 변경하지 않을 수 있습니다. 예를 들어, &quot;The fluffy cat came here on Sunday&quot;와 &quot;On Sunday, the cat which was fluffy came here&quot;는 유사한 의미를 가지지만, &quot;The Sunday came here on a fluffy cat&quot;은 다른 의미를 가집니다. 그렇다면 어떻게 이러한 문장이 유사하게 처리되도록 할까요?</p><p>RNN의 핵심 개념은 정보가 네트워크를 통과하는 방식에서 비롯됩니다. 예를 들어, &quot;The cat eats&quot;라는 문장을 RNN이 어떻게 처리하는지 살펴봅시다.</p><p>문장을 “The”, “cat”, &quot;eats&quot;와 같은 단어들의 시퀀스로 생각해 봅시다(실제로는 숫자나 벡터의 시퀀스로 표현될 것입니다). RNN은 이 시퀀스를 순차적으로 처리합니다. 먼저, 단어 &quot;The&quot;를 입력으로 받아 가중치와 편향을 통해 x1이라는 출력을 생성합니다. 그 다음, RNN은 x1과 시퀀스의 다음 단어인 &quot;cat&quot;을 받아, 같은 가중치와 편향을 통해 x2를 생성합니다. 이후, x2와 다음 단어인 &quot;eats&quot;를 사용하여 x3을 생성합니다. 이와 같은 방식으로, RNN은 이전 출력과 다음 입력을 결합하여 새로운 출력을 생성합니다. RNN의 현재 상태를 은닉 상태(<strong>hidden state</strong>)라고 부릅니다.</p><p><img src="/images/header/ai-27_3.gif" alt=""></p><h3 id="어떻게-RNN을-사용해-다음-단어를-예측할-수-있을까요">어떻게 RNN을 사용해 다음 단어를 예측할 수 있을까요?</h3><p>각 출력(x1, x2, x3)이 실제로 새로운 단어를 나타낸다고 가정해 보세요. 모델을 학습시켜 출력이 실제로 다음 단어를 예측하도록 할 수 있습니다. 예를 들어, 다음과 같이 문장을 처리한다고 해봅시다.</p><ol><li>“The” -&gt; 모델을 통과 -&gt; x0 생성, x0이 &quot;cat&quot;으로 올바르게 예측되도록 모델을 학습시킵니다.</li><li>&quot;cat&quot;과 이전 출력 x0 -&gt; 모델을 통과 -&gt; x1 생성, x1이 &quot;eats&quot;로 올바르게 예측되도록 학습합니다.</li><li>&quot;eats&quot;와 이전 출력 x1 -&gt; 모델을 통과 -&gt; x2 생성. 이때, x2가 &quot;tuna&quot;라는 단어를 나타내도록 학습됩니다. 이제 이를 다음 입력으로 사용할 수 있습니다.</li><li>&quot;tuna&quot;와 이전 출력 x2 -&gt; 모델을 통과 -&gt; x3 생성… 이와 같은 방식으로 계속 진행됩니다.</li></ol><h3 id="주요-개념-2">주요 개념</h3><p>RNN의 주요 개념은 다음과 같습니다.</p><ul><li>RNN은 은닉 상태를 통해 이전에 본 정보를 항상 추적할 수 있으며, 이는 단어들 간의 관계나 일련의 데이터를 포착하는 데 유용합니다.</li><li><strong>동일한 모델</strong>이 시퀀스의 각 부분에 반복적으로 적용되기 때문에, RNN은 학습하기에 적합합니다(거대한 모델로 전체 입력을 한꺼번에 처리하는 것보다 효율적임).</li></ul><p>하지만 이 접근 방식의 문제점도 이미 예상할 수 있습니다. 텍스트가 길어질수록 초기의 몇 단어가 현재의 은닉 상태에 거의 영향을 미치지 못해 이상적이지 않습니다. 또한, 이 방식은 순차적으로 처리해야 하므로, 처리 속도와 학습 속도가 알고리즘 자체에 의해 제한됩니다.</p><p>여전히 RNN은 매우 강력한 모델이며, 더 깊게 탐구해 볼 것을 권장합니다!</p><p>RNN을 사용하는 대표적인 도구와 제품으로는 Google 번역, OpenAI의 GPT-2, Spotify의 추천 시스템 등이 있습니다.</p><h2 id="Transformer-트랜스포머">Transformer (트랜스포머)</h2><p>트랜스포머! 현재 머신 러닝 세계에서 가장 주목받고 있는 기술입니다. GPT-4와 BERT(구글의 고급 언어 모델) 모두 트랜스포머 아키텍처를 기반으로 하고 있습니다. 그렇다면 트랜스포머란 무엇일까요?</p><p>트랜스포머는 RNN처럼 주로 NLP 문제를 해결하는 데 사용되며, 앞서 설명한 언어 처리와 관련된 유사한 문제들을 해결해야 합니다. 그러나, RNN과는 다르게 이러한 문제들을 해결하기 위한 몇 가지 주요한 아이디어를 가지고 있습니다.</p><ul><li><strong>위치 인코딩(Positional Encoding)</strong> — RNN은 은닉 상태를 통해 자연스럽게 언어의 순서를 유지하지만, 트랜스포머는 이 정보를 입력에 직접적으로 추가합니다. 위치 인코딩이 단어 임베딩(단어의 벡터 표현)에 더해져, 문장 내 각 단어의 위치를 파악할 수 있도록 합니다. 예를 들어, &quot;dog&quot;의 표현은 텍스트 내 위치에 따라 다르게 조정됩니다.</li><li><strong>대규모 학습 데이터셋(Huge training dataset size)</strong> — 위치 인코딩의 이점을 활용하기 위해, 트랜스포머는 방대한 데이터셋을 통해 학습해야 합니다. 이러한 순서의 차이와 단어 유형은 데이터에 반영되기 때문에, 다양한 가능성을 충분히 학습하지 않으면 모델의 성능이 떨어집니다.</li><li><strong>자기 주의(Self-attention)</strong> — 모델은 입력에서 특정 단어들과 다른 모든 단어들 간의 관계를 더 중요하게 여기는 법을 학습합니다. 결국, 어떤 단어들은 예측이나 번역에서 더 많은 의미를 가지고 있으며, 다른 단어들과 함께 사용될 때 더 강한 힘을 발휘합니다. 트랜스포머는 이를 대규모 학습 데이터와 자체적인 아키텍처를 통해 학습합니다.</li></ul><p>트랜스포머의 아키텍처는 다소 복잡하며, 짧은 글에서 설명하기 어렵지만, 여기서 간단하게 개략적인 설명을 드리겠습니다. 트랜스포머는 <strong>인코더</strong>(Encoder)와 <strong>디코더</strong>(Decoder)로 구성됩니다. 인코더는 동일한 레이어들의 스택으로 이루어져 있으며, 텍스트를 처리하여 디코더에 필요한 중요한 정보를 제공합니다. 디코더는 이 입력을 받아, 동일한 레이어 스택을 통해 우리가 원하는 출력을 생성하는 역할을 합니다. 아래 그림은 이 아키텍처를 보여주는 이미지입니다.</p><p><img src="/images/header/ai-27_4.png" alt=""></p><p>특히 트랜스포머의 핵심인 “자기 주의(Self-attention)” 메커니즘에 대해 깊이 공부해 보시기를 추천드립니다.</p><h2 id="GAN-생산적-적대-신경망">GAN (생산적 적대 신경망)</h2><p>GANs(Generative Adversarial Networks, 생성적 적대 신경망)은 기본적으로 두 개의 대립하는 모델이 서로 경쟁하는 구조입니다. GAN은 보통 이러한 모델들을 학습시키는 방법을 가리키며, 모델 자체보다는 학습 방식에 초점을 맞춥니다. 사실, 두 모델의 아키텍처가 중요한 것은 아니며, 하나는 생성 모델(Generative Model)이고 다른 하나는 판별 모델(Classifier, 또는 Discriminator)이기만 하면 됩니다.</p><p>먼저, 표준적인 지도 학습 기법을 설명해 보겠습니다.</p><ul><li>모델에 입력 데이터를 제공하고, 모델이 출력을 생성합니다.</li><li>이 출력과 원하는 출력(정답)을 비교하여, 모델이 더 나은 결과를 내도록 업데이트합니다.</li></ul><p>그러나 우리가 생성 모델을 만들고자 할 때 문제가 발생합니다. 이 모델은 현실적인 출력을 생성해야 하지만, 그 출력이 꼭 우리가 가지고 있는 데이터와 동일할 필요는 없습니다(예: 이미지 생성 또는 음악 생성). 바로 이때 GAN이 유용하게 쓰입니다. GAN에는 두 개의 모델이 있는데, 생성자(Generator) 모델과 판별자(Discriminator) 모델입니다.</p><p><strong>예시를 들어 설명해 보겠습니다.</strong></p><p>생성자 모델이 이미지를 생성한다고 가정해 봅시다. 먼저 이 모델을 이용해 여러 개의 가짜 이미지를 생성하도록 합니다. 그리고 실제 이미지를 몇 개 찾아서 이 가짜 이미지들과 결합합니다. 그런 다음, 이 이미지들을 판별자 모델에 입력하여 진짜인지 가짜인지를 구분하게 합니다. 만약 생성자 모델이 잘 작동한다면, 판별자 모델은 진짜와 가짜를 구분하기 어려워할 것이며, 진짜인지 가짜인지 맞출 확률이 약 50%에 가까워집니다. 당연히 초기에는 판별자가 더 잘 구분합니다(판별자는 보통 사전 학습이 약간 되어 있음). 따라서, 지도 학습 방식으로(우리 스스로 어떤 이미지가 진짜인지 가짜인지 알고 있기 때문에) 판별자 모델을 더 잘 학습시키게 됩니다. 또한, 생성자 모델도 판별자를 얼마나 잘 속였는지에 따라 학습할 수 있습니다. 학습은 생성자 모델이 판별자를 약 50% 확률로 속일 수 있을 때 완료됩니다.</p><p><img src="/images/header/ai-27_5.png" alt=""></p><p>GAN이 실제로 사용되는 몇 가지 예로는 Runway ML, Midjourney의 아트 생성, OpenAI의 DALL·E가 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/18/ai-27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>꼭 알아야 할 시스템 설계 용어 50가지</title>
      <link>http://hgko1207.github.io/2024/10/17/info-30/</link>
      <guid>http://hgko1207.github.io/2024/10/17/info-30/</guid>
      <pubDate>Thu, 17 Oct 2024 03:46:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;시스템 설계 면접은 지원자가 확장 가능하고 효율적인 시스템을 만들 수 있는지를 검증하는 데 있어 항상 중요한 요소입니다. 주요 용어에 대한 지식은 면접
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-30.png" alt=""></p><p>시스템 설계 면접은 지원자가 확장 가능하고 효율적인 시스템을 만들 수 있는지를 검증하는 데 있어 항상 중요한 요소입니다. 주요 용어에 대한 지식은 면접에서 좋은 점수를 받는 데 도움이 될 것입니다. 아래는 반드시 알아야 할 시스템 설계 면접 용어 50가지에 대한 정의와 실제 예시시를 학습을 위한 추가 자료와 함께 설명합니다.</p><h2 id="1-Scalability">1. Scalability</h2><ul><li><strong>정의:</strong> 리소스를 추가하여 증가하는 부하를 지원할 수 있는 시스템의 능력입니다.</li><li><strong>예시:</strong> 웹 트래픽 증가를 처리하기 위해 서버를 더 추가합니다.</li><li><a href="https://www.geeksforgeeks.org/what-is-scalability/" target="_blank" rel="noopener">What is Scalability and How to Achieve it?</a></li></ul><h2 id="2-Load-Balancer-로드-밸런서">2. Load Balancer(로드 밸런서)</h2><ul><li><strong>정의:</strong> 들어오는 네트워크 트래픽을 여러 서버로 분할하여 한 서버에서 많은 양의 부하를 처리하지 않도록 합니다.</li><li><strong>예시:</strong> AWS Elastic Load Balancer(ELB) 서비스를 사용하여 여러 EC2 인스턴스 간에 웹 트래픽 부하를 분산합니다.</li><li><a href="https://www.f5.com/glossary/load-balancer" target="_blank" rel="noopener">로드 밸런서 이해</a></li></ul><h2 id="3-Microservice-마이크로서비스">3. Microservice(마이크로서비스)</h2><ul><li><strong>정의:</strong> 느슨하게 결합된 서비스들의 모음으로 애플리케이션을 구조화하는 아키텍처 패턴입니다.</li><li><strong>예시:</strong> 모놀리식(monolithic) 애플리케이션을 사용자 관리, 결제 처리, 알림 전송을 담당하는 독립적인 서비스로 세분화합니다.</li><li><a href="https://aws.amazon.com/ko/microservices/" target="_blank" rel="noopener">마이크로서비스란 무엇인가요?</a></li></ul><h2 id="4-CAP-Theorem-CAP-정리">4. CAP Theorem(CAP 정리)</h2><ul><li><strong>정의:</strong> 분산 시스템에서는 일관성, 가용성, 분할 허용성이라는 세 가지 보장 중 최대 두 가지만 얻을 수 있다는 것을 의미합니다.</li><li><strong>예시:</strong> 분산 데이터베이스 설계에서 가용성을 위해 일관성을 희생해야 하는 경우(또는 그 반대의 경우)</li><li><a href="https://www.scylladb.com/glossary/cap-theorem/" target="_blank" rel="noopener">CAP 정리 이해하기</a></li></ul><h2 id="5-Sharding-샤딩">5. Sharding(샤딩)</h2><ul><li><strong>정의:</strong> 더 나은 관리를 위해 대규모 데이터베이스를 샤드라고 하는 작은 조각으로 나누는 것을 말합니다.</li><li><strong>예시:</strong> 지리적 지역을 기반으로 사용자 데이터베이스를 샤딩합니다.</li><li><a href="https://aws.amazon.com/what-is/database-sharding/" target="_blank" rel="noopener">데이터베이스 샤딩 설명</a></li></ul><h2 id="6-Latency">6. Latency</h2><ul><li><strong>정의:</strong> 데이터가 A 지점에서 B 지점까지 이동하는 데 걸리는 시간으로 정의됩니다.</li><li><strong>예시:</strong> 채팅 애플리케이션을 통한 메시지 전달과 관련된 지연 시간 측정.</li><li><a href="https://www.cloudflare.com/ko-kr/learning/performance/glossary/what-is-latency/" target="_blank" rel="noopener">지연 시간에 대해 설명!</a></li></ul><h2 id="7-Throughput-쓰루풋">7. Throughput(쓰루풋)</h2><ul><li><strong>정의:</strong> 시스템이 일정 시간 내에 처리하는 데이터의 양을 측정한 것 입니다. 처리율, 처리량라고도 불립니다.</li><li><strong>예시:</strong> 웹 서버가 1초 동안 처리하는 요청 수입니다.</li><li><a href="https://www.techtarget.com/searchnetworking/definition/throughput" target="_blank" rel="noopener">컴퓨터 네트워크에서의 처리량(Throughput)</a></li></ul><h2 id="8-캐시-Cache">8. 캐시(Cache)</h2><ul><li><strong>정의:</strong> 동일한 데이터를 반복 요청할 필요가 없도록 데이터를 저장하고 빠르게 제공하는 하드웨어 또는 소프트웨어 구성 요소</li><li><strong>예시:</strong> 반복적인 데이터베이스 쿼리를 위해 Redis 캐싱을 구현하는 것</li><li><a href="https://aws.amazon.com/ko/caching/" target="_blank" rel="noopener">캐싱 설명</a></li></ul><h2 id="9-Content-Delivery-Network-CDN">9. Content Delivery Network(CDN)</h2><ul><li><strong>정의:</strong> 지리적으로 분산된 서버 시스템으로, 사용자가 액세스하는 지리적 위치에 따라 웹 콘텐츠를 사용자에게 표시합니다.</li><li><strong>예시:</strong> 더 빠른 웹 페이지 로딩을 위해 Cloudflare CDN 사용.</li><li><a href="https://www.cloudflare.com/ko-kr/learning/cdn/what-is-a-cdn/" target="_blank" rel="noopener">CDN이란 무엇인가요?</a></li></ul><h2 id="10-REST-API">10. REST API</h2><ul><li><strong>정의:</strong> HTTP 요청을 사용하여 데이터에 액세스하고 조작하는 웹 서비스를 구축하도록 설계된 아키텍처 스타일의 한 유형입니다.</li><li><strong>예시:</strong> REST(Representational State Transfer) 원칙에 따른 소셜 미디어 API 설계.</li><li><a href="https://restfulapi.net/" target="_blank" rel="noopener">REST API 튜토리얼</a></li></ul><h2 id="11-GraphQL">11. GraphQL</h2><ul><li><strong>정의:</strong> 데이터를 쿼리하도록 설계된 언어이므로 REST보다 훨씬 더 강력하고 효율적이며 유연합니다.</li><li><strong>예시:</strong> GraphQL을 사용하여 단일 요청으로 사용자 정보 쿼리.</li><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-graphql" target="_blank" rel="noopener">GraphQL 소개</a></li></ul><h2 id="12-ACID">12. ACID</h2><ul><li><strong>정의:</strong> 데이터베이스 트랜잭션의 안정적인 처리를 보장하는 속성 집합입니다. 속성은 원자성, 일관성, 고립성 및 내구성입니다.</li><li><strong>예시:</strong> 은행 거래에 ACID 속성이 있는지 확인하면 데이터 손상을 방지할 수 있습니다.</li><li><a href="https://www.geeksforgeeks.org/acid-properties-in-dbms/" target="_blank" rel="noopener">데이터베이스의 ACID 속성</a></li></ul><h2 id="13-BASE">13. BASE</h2><ul><li><strong>정의:</strong> ACID의 대안으로, 엄격한 일관성(Consistency)보다 가용성(Availability)과 파티션 허용성(Partition tolerance)을 강조하는 시스템. 기본적으로 가용하며(Basically Available), 변화하는 상태를 허용하고(Soft state), 결국에는 일관성을 이루는(Eventually consistent) 시스템.</li><li><strong>예시:</strong> 높은 가용성과 최종 일관성을 제공하는 NoSQL 데이터베이스의 설계.</li><li><a href="https://aws.amazon.com/ko/compare/the-difference-between-acid-and-base-database/" target="_blank" rel="noopener">BASE vs ACID</a></li></ul><h2 id="14-NoSQL">14. NoSQL</h2><ul><li><strong>정의:</strong> 관계형 데이터베이스에서 사용되는 표 형식의 관계가 아닌 다른 방식으로 모델링된 데이터의 저장 및 검색을 촉진하도록 설계된 데이터베이스 유형입니다.</li><li><strong>예시:</strong> 문서 기반 데이터 저장소에 MongoDB 사용.</li><li><a href="https://www.mongodb.com/resources/basics/databases/nosql-explained" target="_blank" rel="noopener">NoSQL 데이터베이스란 무엇인가요?</a></li></ul><h2 id="15-SQL">15. SQL</h2><ul><li><strong>정의:</strong> 관계형 데이터베이스에서 데이터를 저장, 조작 및 검색하는 데 사용되는 표준 언어입니다.</li><li><strong>예시:</strong> 관계형 데이터베이스에서 데이터를 가져오기 위해 SQL 쿼리를 작성합니다.</li><li><a href="https://www.geeksforgeeks.org/sql-tutorial/" target="_blank" rel="noopener">SQL 튜토리얼</a></li></ul><h2 id="16-데이터베이스-인덱싱">16. 데이터베이스 인덱싱</h2><ul><li><strong>정의:</strong> 데이터베이스에서 데이터를 빠르게 검색하고 액세스할 수 있도록 하는 데이터 구조 기법입니다.</li><li><strong>예시:</strong> 검색 속도 향상을 위해 사용자 ID 열에 인덱싱을 생성합니다.</li><li><a href="https://www.codecademy.com/article/sql-indexes" target="_blank" rel="noopener">데이터베이스 인덱싱</a></li></ul><h2 id="17-Replication">17. Replication</h2><ul><li><strong>정의:</strong> 분산 데이터베이스 시스템을 구성하는 여러 데이터베이스에서 데이터베이스 객체를 복사하고 유지 관리하는 프로세스입니다.</li><li><strong>예시:</strong> 복제를 사용하여 다양한 지리적 위치에서 데이터베이스의 고가용성을 유지.</li><li><a href="https://www.geeksforgeeks.org/data-replication-in-dbms/" target="_blank" rel="noopener">데이터베이스 복제(Database Replication)</a></li></ul><h2 id="18-Failover-장애-조치">18. Failover(장애 조치)</h2><ul><li><strong>정의:</strong> 주요 시스템 구성 요소가 손실되었을 때, 다른 시스템 구성 요소가 그 기능을 대신하는 백업 운영 모드.</li><li><strong>예시:</strong> 인터넷 애플리케이션 서버가 장애가 발생할 경우, 대기 서버로 자동으로 전환되는 내장된 자동 장애 조치 기능.</li><li><a href="https://macquariecloudservices.com/blog/failover-vs-disaster-recovery/" target="_blank" rel="noopener">장애 조치(Failover)와 재해 복구(Disaster Recovery) 비교</a></li></ul><h2 id="19-API-Gateway">19. API Gateway</h2><ul><li><strong>정의:</strong> API의 앞단에 위치하여 API 요청을 수신하고 제한 및 보안 정책을 적용한 다음 백엔드 서비스로 전달하는 서버입니다.</li><li><strong>예시:</strong> AWS API 게이트웨이를 사용하여 API 관리.</li><li><a href="https://www.f5.com/glossary/api-gateway" target="_blank" rel="noopener">API 게이트웨이란?</a></li></ul><h2 id="20-Service-Mesh">20. Service Mesh</h2><ul><li><strong>정의:</strong> 마이크로서비스 간의 서비스 간 통신을 원활하게 하기 위한 전용 인프라 계층.</li><li><strong>예시:</strong> 마이크로서비스 상호 작용 관리를 위한 서비스 메시로 <a href="https://istio.io/latest/about/service-mesh/" target="_blank" rel="noopener">Istio 통합</a>.</li><li><a href="https://aws.amazon.com/what-is/service-mesh/#:~:text=A%20service%20mesh%20is%20a,the%20performance%20of%20the%20services." target="_blank" rel="noopener">Service Mesh 소개</a></li></ul><h2 id="21-Serverless-Computing">21. Serverless Computing</h2><ul><li><strong>정의:</strong> 클라우드 공급자가 동적으로 컴퓨팅 자원을 할당하는 클라우드 컴퓨팅 구현 방식.</li><li><strong>예시:</strong> AWS Lambda를 사용하여 서버 설정 없이 백엔드 코드를 실행</li><li><a href="https://www.cloudflare.com/ko-kr/learning/serverless/what-is-serverless/" target="_blank" rel="noopener">서버리스 컴퓨팅이란 무엇인가요?</a></li></ul><h2 id="22-Event-Driven-Architecture">22. Event-Driven Architecture</h2><ul><li><strong>정의:</strong> 일반적으로 이벤트를 생성, 감지, 소비하고 이에 반응하도록 장려하는 소프트웨어 아키텍처 패러다임.</li><li><strong>예시:</strong> Apache Kafka를 사용하여 마이크로서비스 간의 이벤트 통신으로 시스템을 설계하기.</li><li><a href="https://aws.amazon.com/ko/event-driven-architecture/" target="_blank" rel="noopener">이벤트 기반 아키텍처(Event-Driven Architecture)</a></li></ul><h2 id="23-Monolithic-Architecture">23. Monolithic Architecture</h2><ul><li><strong>정의:</strong> 모든 요소가 하나의 애플리케이션에 장착되어 단일 서비스로 실행되는 소프트웨어 아키텍처.</li><li><strong>예시:</strong> 하나의 거대한 단위로 구축된 전통적인 기업 애플리케이션.</li><li><a href="https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith" target="_blank" rel="noopener">모놀리식 아키텍처와 마이크로서비스 아키텍처 비교</a></li></ul><h2 id="24-분산-시스템">24. 분산 시스템</h2><ul><li><strong>정의:</strong> 네트워크로 연결된 컴퓨터에 위치한 구성 요소들이 메시지를 주고받으며 서로의 동작을 조정하는 모델.</li><li><strong>예시:</strong> Hadoop과 같은 분산 파일 시스템 설계.</li><li><a href="https://www.geeksforgeeks.org/what-is-a-distributed-system/" target="_blank" rel="noopener">분산 시스템 소개</a></li></ul><h2 id="25-메시지-큐-Message-Queue">25. 메시지 큐(Message Queue)</h2><ul><li><strong>정의:</strong> 아키텍처에서 비동기 서비스 간 통신을 가능하게 하는 방법.</li><li><strong>예시:</strong> RabbitMQ를 사용하여 서비스 간 메시지를 큐에 저장.</li><li><a href="https://aws.amazon.com/ko/message-queue/#:~:text=Message%20queues%20allow%20different%20parts,to%20send%20and%20receive%20messages." target="_blank" rel="noopener">메시지 큐 설명</a></li></ul><h2 id="26-Pub-Sub-모델">26. Pub/Sub 모델</h2><ul><li><strong>정의:</strong> 발신자(게시자)가 메시지를 발행하고, 수신자(구독자)가 목적지를 알 필요 없이 메시지를 수신하는 메시징 패턴.</li><li><strong>예시:</strong> Google Cloud Pub/Sub를 사용하는 알림 시스템.</li><li><a href="https://aws.amazon.com/what-is/pub-sub-messaging/" target="_blank" rel="noopener">Pub/Sub 메시징</a></li></ul><h2 id="27-데이터-파티셔닝-Data-Partitioning">27. 데이터 파티셔닝(Data Partitioning)</h2><ul><li><strong>정의:</strong> 데이터베이스를 더 작고 관리하기 쉬운 부분으로 분할 하는 것.</li><li><strong>예시:</strong> 데이터베이스의 테이블을 날짜별로 분할하여 쿼리를 매우 빠르게 실행할 수 있습니다.</li><li><a href="https://www.cockroachlabs.com/blog/what-is-data-partitioning-and-how-to-do-it-right/" target="_blank" rel="noopener">데이터베이스 파티셔닝</a></li></ul><h2 id="28-Horizontal-Scaling">28. Horizontal Scaling</h2><ul><li><strong>정의:</strong> 시스템 내에 더 많은 머신이나 노드를 추가하여 용량을 증가시키는 것.</li><li><strong>예시:</strong> 사용자 트래픽이 증가할 때 웹 서버를 추가로 설치.</li><li><a href="https://www.digitalocean.com/resources/articles/horizontal-scaling-vs-vertical-scaling" target="_blank" rel="noopener">Horizontal vs Vertical Scaling</a></li></ul><h2 id="29-Vertical-Scaling">29. Vertical Scaling</h2><ul><li><strong>정의:</strong> 기존 머신의 CPU나 RAM 같은 성능을 업그레이드하는 것.</li><li><strong>예시:</strong> 서버의 RAM을 업그레이드하여 더 많은 요청을 처리할 수 있게 함.</li><li><a href="https://www.digitalocean.com/resources/articles/horizontal-scaling-vs-vertical-scaling" target="_blank" rel="noopener">Horizontal vs Vertical Scaling</a></li></ul><h2 id="30-속도-제한-Rate-Limiting">30. 속도 제한(Rate Limiting)</h2><ul><li><strong>정의:</strong> 네트워크 인터페이스 컨트롤러가 보내거나 받는 트래픽의 속도를 제어하는 것.</li><li><strong>예시:</strong> API의 남용을 방지하기 위해 API를 제한.</li><li><a href="https://www.solo.io/topics/rate-limiting/" target="_blank" rel="noopener">속도 제한 이해하기</a></li></ul><h2 id="31-Circuit-Breaker-패턴">31. Circuit Breaker 패턴</h2><ul><li><strong>정의:</strong> 최신 소프트웨어 개발에 사용되는 디자인 패턴으로, 장애를 감지하고 장애가 지속적으로 반복되는 것을 방지하는 로직을 캡슐화 함.</li><li><strong>예시:</strong> 마이크로서비스 아키텍처에서 서킷 브레이커를 사용하여 원격 서비스 호출 실패 처리.</li><li><a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/" target="_blank" rel="noopener">Circuit Breaker 패턴</a></li></ul><h2 id="32-데이터-일관성-Data-Consistency">32. 데이터 일관성(Data Consistency)</h2><ul><li><strong>정의:</strong> 여러 인스턴스 간에 데이터가 동일하고 손상되지 않도록 보장하는 것.</li><li><strong>예시:</strong> 데이터베이스의 여러 복제본을 통해 사용자 데이터의 일관성을 유지.</li><li><a href="https://www.geeksforgeeks.org/consistency-model-in-distributed-system/" target="_blank" rel="noopener">데이터 일관성 모델</a></li></ul><h2 id="33-궁극적-일관성-Eventual-Consistency">33. 궁극적 일관성(Eventual Consistency)</h2><ul><li><strong>정의:</strong> 높은 가용성을 목표로 하는 분산 컴퓨팅에서 사용되는 일관성 모델로, 시스템의 업데이트가 시간이 지나면 모든 노드에 반영될 것을 보장함.</li><li><strong>예시:</strong> Amazon DynamoDB는 읽기 작업에 대해 최종 일관성 모델을 제공함.</li><li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html" target="_blank" rel="noopener">궁극적 일관성</a></li></ul><h2 id="34-강력한-일관성-Strong-Consistency">34. 강력한 일관성(Strong Consistency)</h2><ul><li><strong>정의:</strong> 모든 읽기 작업이 가장 최근의 쓰기 작업을 반영하도록 보장하는 일관성 모델.</li><li><strong>예시:</strong> 금융 거래 시스템에서 강력한 일관성 사용.</li><li><a href="https://www.geeksforgeeks.org/eventual-vs-strong-consistency-in-distributed-databases/" target="_blank" rel="noopener">강력한 일관성</a></li></ul><h2 id="35-컨테이너화-Containerization">35. 컨테이너화(Containerization)</h2><ul><li><strong>정의:</strong> 기본적으로 애플리케이션과 그 종속성을 컨테이너에 캡슐화하여 다양한 컴퓨팅 환경에서 실행할 수 있도록 하는 것.</li><li><strong>예시:</strong> Docker를 사용하여 애플리케이션을 개발, 테스트, 프로덕션 환경에 배포할 수 있도록 컨테이너화.</li><li><a href="https://aws.amazon.com/what-is/containerization/" target="_blank" rel="noopener">컨테이너화란 무엇인가요?</a></li></ul><h2 id="36-쿠버네티스-Kubernetes">36. 쿠버네티스(Kubernetes)</h2><ul><li><strong>정의:</strong> 애플리케이션 컨테이너의 배포, 확장 및 운영 프로세스를 자동화하는 오픈소스 플랫폼.</li><li><strong>예시:</strong> Kubernetes를 사용하여 컨테이너화된 애플리케이션 실행 및 배포.</li><li><a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">Kubernetes 문서</a></li></ul><h2 id="37-오토스케일링-Autoscaling">37. 오토스케일링(Autoscaling)</h2><ul><li><strong>정의:</strong> 사용자 부하에 따라 컴퓨팅 리소스 수를 자동으로 조정하는 것.</li><li><strong>예시:</strong> AWS EC2 오토스케일링 기능을 사용하여 인스턴스 수를 동적으로 조정.</li><li><a href="https://aws.amazon.com/ko/autoscaling/" target="_blank" rel="noopener">오토스케일링 설명</a></li></ul><h2 id="38-Multi-Tenancy">38. Multi-Tenancy</h2><ul><li><strong>정의:</strong> 단일 소프트웨어 애플리케이션 인스턴스가 여러 소비자/고객에게 서비스를 제공하는 아키텍처.</li><li><strong>예시:</strong> Salesforce와 같은 SaaS 애플리케이션이 다양한 고객 그룹에게 Multi-Tenancy를 사용하여 서비스 제공.</li><li><a href="https://www.digitalguardian.com/blog/saas-single-tenant-vs-multi-tenant-whats-difference" target="_blank" rel="noopener">Single Tenancy Vs Multi-Tenancy?</a></li></ul><h2 id="39-로드-셰딩-Load-Shedding">39. 로드 셰딩(Load Shedding)</h2><ul><li><strong>정의:</strong> 높은 부하 상태에서 시스템 전체의 건강을 유지하기 위해 일부 요청을 처리하지 않거나 서비스를 저하시키는 것.</li><li><strong>예시:</strong> 트래픽이 폭주하는 시간대에 필수적이지 않은 모든 서비스를 종료.</li><li><a href="https://www.techtarget.com/searchdatacenter/definition/load-shedding" target="_blank" rel="noopener">Load Shedding</a></li></ul><h2 id="40-멱등성-Idempotence">40. 멱등성(Idempotence)</h2><ul><li><strong>정의:</strong> 수학 및 컴퓨터 과학에서 특정 연산을 여러 번 수행해도 결과가 동일한 특성.</li><li><strong>예시:</strong> HTTP DELETE 요청은 멱등성을 가짐.</li><li><a href="https://restfulapi.net/idempotent-rest-apis/" target="_blank" rel="noopener">API의 멱등성</a></li></ul><h2 id="41-Quorum">41. Quorum</h2><ul><li><strong>정의:</strong> 분산 트랜잭션을 커밋하기 위해 필요한 최소 투표 수.</li><li><strong>예시:</strong> 분산 데이터베이스에서 일관성을 보장하기 위해 쿼럼 기반 복제를 사용.</li><li><a href="https://en.wikipedia.org/wiki/Quorum_(distributed_computing)" target="_blank" rel="noopener">Quorum Systems</a></li></ul><h2 id="42-오케스트레이션-Orchestration">42. 오케스트레이션(Orchestration)</h2><ul><li><strong>정의:</strong> 서비스 간 상호작용을 중앙에서 조정자가 제어하는 패턴.</li><li><strong>예시:</strong> 다단계 비즈니스 프로세스를 관리하기 위해 워크플로 엔진을 사용.</li><li><a href="https://www.redhat.com/en/topics/automation/what-is-orchestration" target="_blank" rel="noopener">오케스트레이션</a></li></ul><h2 id="43-Choreography">43. Choreography</h2><ul><li><strong>정의:</strong> 각 서비스가 독립적으로 이벤트를 통해 다른 서비스와 상호작용하며, 중앙 조정자 없이 작동하는 서비스 상호작용 패턴.</li><li><strong>예시:</strong> 이벤트 버스를 통해 마이크로서비스가 상호작용하는 Choreography 패턴.</li><li><a href="https://www.wallarm.com/what/orchestration-vs-choreography#:~:text=With%20orchestration%2C%20the%20control%20logic,its%20part%20of%20the%20workflow." target="_blank" rel="noopener">Choreography vs. Orchestration</a></li></ul><h2 id="44-서비스-레지스트리">44. 서비스 레지스트리</h2><ul><li><strong>정의:</strong> 마이크로서비스 인스턴스를 추적하는 데이터베이스.</li><li><strong>예시:</strong> 마이크로서비스 아키텍처에서 Eureka 서비스 레지스트리 사용.</li><li><a href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server" target="_blank" rel="noopener">서비스 레지스트리와 디스커버리</a></li></ul><h2 id="45-API-속도-제한">45. API 속도 제한</h2><ul><li><strong>정의:</strong> 특정 시간 내에 클라이언트가 API에 요청할 수 있는 횟수를 제어하는 것.</li><li><strong>예시:</strong> API 남용을 방지하기 위해 분당 100개의 요청으로 제한.</li><li><a href="https://datadome.co/bot-management-protection/what-is-api-rate-limiting/#:~:text=API%20rate%20limiting%20is%2C%20in,API%20product' target="_blank" rel="noopener"s%20growth%20and%20scalability.">API 속도 제한</a></li></ul><h2 id="46-데이터-웨어하우스-Data-Warehouse">46. 데이터 웨어하우스(Data Warehouse)</h2><ul><li><strong>정의:</strong> 보고서 생성 및 비즈니스 데이터 분석을 돕는 시스템; 비즈니스 인텔리전스의 허브.</li><li><strong>예시:</strong> 데이터 웨어하우징에 Amazon Redshift를 도입.</li><li><a href="https://aws.amazon.com/ko/what-is/data-warehouse/" target="_blank" rel="noopener">데이터 웨어하우스 이해하기</a></li></ul><h2 id="47-데이터-레이크-Data-Lake">47. 데이터 레이크(Data Lake)</h2><ul><li><strong>정의:</strong> 데이터를 네이티브/원시 형식으로 저장하는 시스템 또는 저장소, 일반적으로 객체 블롭이나 파일 형태로 저장.</li><li><strong>예시:</strong> 데이터 레이크에서 구조적 및 비구조적 데이터를 페타바이트 규모로 저장 및 관리.</li><li><a href="https://azure.microsoft.com/en-us/solutions/data-lake/" target="_blank" rel="noopener">데이터 레이크</a></li></ul><h2 id="48-OLAP-Online-Analytical-Processing">48. OLAP(Online Analytical Processing)</h2><ul><li><strong>정의:</strong> 데이터베이스에 저장된 데이터를 분석할 수 있는 소프트웨어 카테고리.</li><li><strong>예시:</strong> 정교한 분석 및 임의의 쿼리를 위해 OLAP 큐브 사용.</li><li><a href="https://aws.amazon.com/what-is/olap/#:~:text=Online%20analytical%20processing%20(OLAP)%20is,smart%20meters%2C%20and%20internal%20systems." target="_blank" rel="noopener">OLAP 설명</a></li></ul><h2 id="49-OLTP-Online-Transaction-Processing">49. OLTP(Online Transaction Processing)</h2><ul><li><strong>정의:</strong> 트랜잭션 중심 애플리케이션을 관리하는 시스템.</li><li><strong>예시:</strong> 은행 시스템과 같은 트랜잭션 데이터 관리를 위한 OLTP 시스템 사용.</li><li><a href="https://www.oracle.com/kr/database/what-is-oltp/" target="_blank" rel="noopener">OLTP 설명</a></li></ul><h2 id="50-빅-데이터">50. 빅 데이터</h2><ul><li><strong>정의:</strong> 기존 데이터 처리 소프트웨어로는 효율적으로 관리할 수 없는 크고 복잡한 데이터 세트.</li><li><strong>예시:</strong> 패션 트렌드를 예측하기 위해 소셜 미디어 상호작용 분석.</li><li><a href="https://www.geeksforgeeks.org/what-is-big-data/" target="_blank" rel="noopener">빅데이터 소개</a></li></ul><h2 id="마무리">마무리</h2><p>계속 학습하고, 시스템 설계에서 이러한 개념들을 실제로 적용해보는 것이 중요합니다. 프로젝트에 이러한 개념들을 적용하고, 관련된 논의에 참여하면서 배워가세요. 이러한 리소스와 논의는 개념의 용어와 사용 사례에 익숙해지는 데 도움을 줄 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/17/info-30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C# 개발에 도움을 주는 기본 개념 7가지</title>
      <link>http://hgko1207.github.io/2024/10/17/csharp-12/</link>
      <guid>http://hgko1207.github.io/2024/10/17/csharp-12/</guid>
      <pubDate>Thu, 17 Oct 2024 03:09:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 모든 개발자가 반드시 알아야 할 다양한 C# 개념을 살펴봅니다. 코드 예제를 알고 이해한다면 .NET에서 꽤 잘하고 있는 것일 가능성이 높습니다.&lt;/p&gt;
&lt;h2 id=&quot;1-IEnumerable-T-와-ICollection-T-의-차이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 모든 개발자가 반드시 알아야 할 다양한 C# 개념을 살펴봅니다. 코드 예제를 알고 이해한다면 .NET에서 꽤 잘하고 있는 것일 가능성이 높습니다.</p><h2 id="1-IEnumerable-T-와-ICollection-T-의-차이점">1. <code>IEnumerable&lt;T&gt;</code>와 <code>ICollection&lt;T&gt;</code>의 차이점</h2><p>C#으로 로직을 작성할 때 개발자는 <code>IEnumerable&lt;T&gt;</code>와 <code>ICollection&lt;T&gt;</code>를 자주 접하게 됩니다. 이 둘은 매우 비슷해 보이지만 소프트웨어 개발에서 서로 다른 용도로 사용됩니다.</p><ul><li><code>IEnumerable&lt;T&gt;</code>는 일반 컬렉션이 아닌 컬렉션의 기본 인터페이스 역할을 합니다. 정의된 유형의 컬렉션을 반복하는 데 도움이 됩니다.</li></ul><p>데이터 조작이 허용되지 않으므로 더 안전한 경량 컬렉션을 사용하는 것이 좋습니다. 데이터 조작을 방지하려면 어떤 컬렉션이든 <code>IEnumerable&lt;T&gt;</code>을 사용하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">    Console.WriteLine(number); <span class="comment">// Outputs: 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ICollection&lt;T&gt;</code>는 <code>IEnumerable&lt;T&gt;</code>를 확장하여 변경 메서드를 사용하여 수정할 수 있습니다. 이 인터페이스는 컬렉션의 개수를 추가, 제거 및 확인하는 메서드로 구성됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ICollection&lt;<span class="keyword">int</span>&gt; data = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span> &#125;;</span><br><span class="line">data.Add(<span class="number">4</span>);</span><br><span class="line">Console.WriteLine(data.Count); <span class="comment">// Outputs: 4</span></span><br></pre></td></tr></table></figure><p>컬렉션에 변경 메서드가 필요한 경우 <code>ICollection&lt;T&gt;</code>, 간단한 읽기 작업에는 <code>IEnumerable&lt;T&gt;</code>를 사용하는 것이 좋습니다.</p><h2 id="2-NET-Core에서-종속성-주입의-역할">2. .NET Core에서 종속성 주입의 역할</h2><p>느슨하게 결합되고 테스트 가능한 코드를 작성하려는 경우, DI(Dependency Injection) 디자인 패턴을 사용하는 것을 권장합니다. .NET Core는 DI를 기본적으로 지원하므로 쉽게 구현할 수 있습니다.</p><ul><li><code>Startup.cs</code> 파일의 <code>ConfigureServices</code> 메서드에 서비스를 등록합니다. 여기에서 주입할 수 있는 서비스를 정의합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 서비스 등록</span></span><br><span class="line">    services.AddTransient&lt;IMyService, MyService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자 주입을 통해 클래스에 서비스를 주입하세요. 이렇게 하면 클래스가 직접 생성할 필요 없이 종속성을 받을 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyService _myService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyController</span>(<span class="params">IMyService myService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = _myService.GetData();</span><br><span class="line">        <span class="keyword">return</span> View(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개발자가 서비스 생성을 분리하면 코드의 유지 관리와 테스트가 더 쉬워집니다.</p><h2 id="3-ref와-out-매개변수의-차이점">3. <code>ref</code>와 <code>out</code> 매개변수의 차이점</h2><p>C#에서 <code>ref</code>와 <code>out</code>은 매개변수를 참조로 전달하는 데 사용되지만, 서로 다른 특징이 있습니다.</p><ul><li><code>ref</code> 매개변수는 메서드에 전달되기 전에 변수를 초기화해야 합니다. 그런 다음 메서드는 변수 값을 수정할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateValue</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myNumber = <span class="number">5</span>;</span><br><span class="line">UpdateValue(<span class="keyword">ref</span> myNumber);</span><br><span class="line">Console.WriteLine(myNumber); <span class="comment">// Outputs: 15</span></span><br></pre></td></tr></table></figure><ul><li><code>out</code> 매개변수는 전달되기 전에 초기화가 필요하지 않습니다. 이 메서드는 반환하기 전에 out 매개변수에 값을 할당해야 합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetValues</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> value1, <span class="keyword">out</span> <span class="keyword">int</span> value2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value1 = <span class="number">10</span>;</span><br><span class="line">    value2 = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetValues(<span class="keyword">out</span> <span class="keyword">int</span> a, <span class="keyword">out</span> <span class="keyword">int</span> b);</span><br><span class="line">Console.WriteLine(a); <span class="comment">// Outputs: 10</span></span><br><span class="line">Console.WriteLine(b); <span class="comment">// Outputs: 20</span></span><br></pre></td></tr></table></figure><p><code>ref</code>는 일반적으로 메서드가 기존 변수를 수정해야 할 때 사용되며, <code>out</code>은 메서드가 여러 값을 반환하거나 호출자가 제공하지 않은 값을 초기화해야 할 때 사용됩니다.</p><h2 id="4-async-및-await">4. <code>async</code> 및 <code>await</code></h2><p>.NET에서 비동기 프로그래밍은 부하가 걸린 상태에서도 잘 작동하는 효율적인 애플리케이션을 작성하는 데 필수적입니다. <code>async</code> 및 <code>await</code> 키워드는 비동기 작업을 간소화합니다.</p><ul><li><code>async</code> 메서드를 사용하면 작업을 비동기적으로 수행할 수 있습니다. 메서드에 <code>async</code> 키워드를 표시하면 그 안에 <code>await</code>을 사용할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// Simulates an asynchronous operation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Data fetched"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>await</code>은 메인 스레드를 차단하지 않아 애플리케이션 UI에 도움이 됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ShowDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> data = <span class="keyword">await</span> FetchDataAsync();</span><br><span class="line">    Console.WriteLine(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애플리케이션의 성능을 향상시키려면 <code>async</code> 및 <code>await</code> 기능을 효과적으로 사용하면서 동시에 애플리케이션 UI의 반응성을 유지하세요.</p><h2 id="5-예외-처리">5. 예외 처리</h2><p>예외를 원활하게 처리하는 것은 견고하고 사용자 친화적인 애플리케이션을 유지하는 데 매우 중요합니다. .NET Core는 예외 처리를 위한 다양한 메커니즘을 제공합니다.</p><ul><li><strong>Local 예외 처리:</strong> try-catch 블록을 사용하여 예외를 포착하고 처리합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// DivideByZeroException을 던집니다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"오류가 발생했습니다: "</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Global 예외 처리</strong>는 미들웨어를 사용하여 관리할 수 있습니다. 모든 유형의 예외를 공통된 위치에서 잡으면 개발자가 사용자에게 친숙하고 일반적인 오류 메시지를 관리할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseExceptionHandler(<span class="string">"/Home/Error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Global 예외 처리 미들웨어는 모든 애플리케이션 오류와 예외를 처리할 수 있는 공통된 장소를 제공합니다. 이를 통해 애플리케이션이 일관되게 응답을 처리할 수 있습니다.</p><h2 id="6-ASP-NET-Core에서-appsettings-json의-역할">6. <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core에서 <code>appsettings.json</code>의 역할</h2><p><code>appsettings.json</code> 파일은 구성(configuration) 문자열 및 애플리케이션별 키와 같은 애플리케이션 자격 증명을 관리하는 데 사용됩니다. 구성 설정은 환경별로 나눌 수도 있습니다.</p><ul><li><code>appsettings.json</code> 파일 예시:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ConnectionStrings"</span>: &#123;</span><br><span class="line">    <span class="attr">"DefaultConnection"</span>: <span class="string">"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Warning"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애플리케이션의 구성 설정 값에 액세스하는 방법은 내장된 구성 시스템을 사용하면 간단합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> _connectionString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _connectionString = configuration.GetConnectionString(<span class="string">"DefaultConnection"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>appettings.json</code> 파일을 사용하면 구성 설정을 쉽게 가져올 수 있으므로 효율적으로 처리해야 합니다.</p><h2 id="7-C-에서-Task와-Thread-이해하기">7. C#에서 <code>Task</code>와 <code>Thread</code> 이해하기</h2><p><code>Task</code>와 <code>Thread</code>는 모두 C#에서 동시(concurrent) 프로그래밍에 사용되지만 서로 다른 용도로 사용됩니다.</p><ul><li><code>Thread</code>는 단일 실행 경로를 나타내며 하위 레벨 구조입니다. 실행에 대한 더 많은 제어 기능을 제공하지만 수동 관리가 필요합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"새 스레드에서 실행 중"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><ul><li><code>Task</code>는 비동기 연산을 구현하는 추상적인 기능을 제공하며 async/await과 함께 사용됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"비동기적으로 실행 중"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Task</code>는 비동기 연산의 관리를 간소화하며 최신 C# 개발에서 선호되는 선택입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/17/csharp-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Backend for Frontend (BFF) Architecture</title>
      <link>http://hgko1207.github.io/2024/10/15/info-29/</link>
      <guid>http://hgko1207.github.io/2024/10/15/info-29/</guid>
      <pubDate>Tue, 15 Oct 2024 06:13:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-29.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;최신 소프트웨어 개발에서 마이크로서비스, 클라우드 네이티브 아키텍처, 그리고 계속 증가하는 클라이언트 디바이스(모바일 앱, 웹 앱, IoT 등)로의 전
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-29.png" alt=""></p><p>최신 소프트웨어 개발에서 마이크로서비스, 클라우드 네이티브 아키텍처, 그리고 계속 증가하는 클라이언트 디바이스(모바일 앱, 웹 앱, IoT 등)로의 전환으로 인해 새로운 아키텍처 패러다임이 필요해졌습니다. 가장 두드러진 패턴 중 하나는 <strong>Backend for Frontend(BFF)</strong> 아키텍처입니다. 애플리케이션이 더욱 분산됨에 따라 빠르고 유지 관리가 용이하며 안전한 사용자 경험을 제공하기 위해 개별 고객의 요구에 맞게 백엔드 서비스를 맞춤화해야 할 필요성이 커지고 있습니다.</p><h2 id="Backend-for-Frontend-BFF-아키텍처란-무엇인가요">Backend for Frontend(BFF) 아키텍처란 무엇인가요?</h2><p><strong>Backend for Frontend</strong>의 ​​핵심은 각 프런트엔드 인터페이스에 대한 전용 백엔드 계층을 제공하는 아키텍처 패턴입니다. 각 프런트엔드(예: 모바일 앱, 웹 앱, 스마트 기기 등)는 성능, 데이터 및 상호 작용 요구 사항이 다를 수 있습니다. BFF는 하나의 모놀리식 또는 일반화된 API에 의존하는 대신 특정 프론트엔드의 특정 요구사항에 맞게 백엔드를 맞춤화합니다.</p><p>즉, 모든 클라이언트 또는 클라이언트 그룹(예: 모바일 또는 웹)에 대해 별도의 백엔드를 구축하는 것입니다.</p><ul><li>다양한 서비스에 대한 호출을 통합하거나 조율합니다.</li><li>클라이언트 친화적인 형식으로 데이터를 준비합니다.</li><li>프론트엔드에 연결된 특정 로직을 처리합니다.</li></ul><p>이를 통해 우려 사항을 분리할 수 있으므로 클라이언트의 특정 사용 사례에 맞게 각 백엔드를 더 쉽게 최적화할 수 있습니다.</p><h2 id="BFF-작동-방식">BFF 작동 방식</h2><ul><li><strong>클라이언트 요청:</strong> 클라이언트(모바일, 웹 등)가 해당 BFF에 요청을 합니다.</li><li><strong>BFF 레이어:</strong> BFF는 여러 마이크로서비스의 데이터를 통합하고, 변환 또는 최적화를 수행하며, 맞춤형 응답으로 응답합니다.</li><li><strong>마이크로 서비스:</strong> BFF는 기본 서비스(예: 사용자 서비스, 주문 서비스 등)와 상호 작용합니다.</li></ul><h2 id="기존-아키텍처와-BFF-비교">기존 아키텍처와 BFF 비교</h2><p><img src="/images/header/info-29_1.png" alt=""></p><p>기존 아키텍처에서는 단일 API 게이트웨이가 여러 클라이언트(예: 웹, 모바일, IoT)의 요청을 처리하는 경우가 많습니다. API 게이트웨이는 요청 라우팅, 인증 추가, 속도 제한에는 유용하지만 다음과 같은 프런트엔드별 요구 사항을 처리할 수 있는 유연성이 부족합니다.</p><ul><li>다양한 클라이언트 앱을 위한 <strong>맞춤형 데이터 모델.</strong></li><li>느린 모바일 네트워크를 위한 특화된 <strong>성능 최적화.</strong></li><li>특정 프론트엔드에 대한 서비스 간의 <strong>복잡한 오케스트레이션 관리.</strong></li></ul><p><strong>모놀리식 API 접근 방식</strong>은 종종 over-fetching(너무 많은 데이터) 또는 under-fetching(너무 적은 데이터)으로 이어져 클라이언트가 필요한 정보를 수집하기 위해 여러 번 왕복해야 하는 경우가 많습니다. BFF는 백엔드를 분리하여 각 클라이언트가 필요한 정보를 정확하게 얻을 수 있도록 함으로써 이 문제를 해결합니다.</p><h2 id="BFF가-현대-아키텍처의-슈퍼스타인-이유">BFF가 현대 아키텍처의 슈퍼스타인 이유</h2><p>그렇다면 BFF가 백엔드 아키텍처의 슈퍼스타가 된 이유는 무엇일까요?</p><ul><li><strong>맞춤형 사용자 경험:</strong> 모바일 앱, 데스크톱 또는 웨어러블 기기 등 각 프런트엔드는 군더더기 없이 필요한 데이터를 정확하게 얻을 수 있습니다. 마치 모든 상황에 딱 맞는 사이즈의 정장을 입은 것과 같습니다.</li><li><strong>복잡성 감소:</strong> BFF는 각 백엔드를 사용자 지정하여 작업을 간소화함으로써 플랫폼 전반에서 원활한 경험을 보장합니다.</li><li><strong>성능 향상:</strong> BFF는 앱의 터보차저입니다. 불필요한 API 호출을 줄임으로써 더 빠른 응답과 더 행복한 사용자를 보장합니다.</li><li><strong>더 빠른 개발:</strong> 팀이 프런트엔드마다 서로 다른 BFF를 작업할 때, 서로의 발을 밟지 않고 더 빨리 움직일 수 있습니다. 마치 주방에 여러 명의 셰프가 각자의 요리를 마스터하는 것과 같습니다.</li><li><strong>보안 강화:</strong> BFF는 백엔드와의 모든 상호작용을 제어하기 때문에 토큰 검증, 입력 검증, 속도 제한과 같은 엄격한 보안 조치를 시행하여 시스템을 더욱 안전하게 보호할 수 있습니다.</li></ul><h2 id="BFF는-언제-사용하나요">BFF는 언제 사용하나요?</h2><ul><li><p><strong>다중 플랫폼 애플리케이션:</strong> 다중 플랫폼 앱(웹, 모바일, 스마트 기기)을 구축하는 회사의 경우 BFF를 사용하면 각 플랫폼에 맞는 맞춤형 경험을 제공할 수 있습니다.</p></li><li><p><strong>마이크로서비스 오케스트레이션:</strong> 마이크로 서비스 아키텍처에서 클라이언트는 여러 서비스(예: 사용자 서비스, 주문 서비스, 재고 서비스)에서 데이터를 가져와야 할 수 있습니다. BFF는 다양한 서비스에서 필요한 데이터를 취합하여 클라이언트에게 일관된 응답으로 제시하는 오케스트레이터 역할을 할 수 있습니다.</p></li><li><p><strong>레거시 API 최적화:</strong> 마이크로서비스로 마이그레이션하거나 레거시 시스템을 사용할 때 BFF는 기본 아키텍처의 복잡성을 가리는 데 도움이 될 수 있습니다. 이전 시스템과 상호 작용하면서도 프런트엔드에 대한 최신 인터페이스를 제공합니다.</p></li></ul><h2 id="도전-과제-및-고려-사항">도전 과제 및 고려 사항</h2><p>BFF는 많은 이점을 제공하지만 몇 가지 과제를 안고 있습니다.</p><ul><li><strong>유지 관리 오버헤드 증가:</strong> 유지 관리할 백엔드가 여러 개(프론트엔드당 하나씩)가 있으면 복잡성이 증가할 수 있습니다. 따라서 추가적인 모니터링, 확장 및 보안 조치가 필요합니다.</li><li><strong>일관성 문제:</strong> 신중하게 설계하지 않으면 백엔드를 별도로 두는 것으로 인해 여러 클라이언트에서 반환되는 데이터에 일관성이 떨어질 수 있습니다.</li><li><strong>성능 병목 현상:</strong> BFF 계층이 수많은 요청을 처리하는 데 최적화되어 있지 않거나 무거운 연산을 수행하는 경우 성능 병목 현상이 발생할 수 있습니다.</li></ul><h2 id="구현-모범-사례">구현 모범 사례</h2><p>BFF 아키텍처를 구현할 때는 다음 사항을 고려하세요.</p><ul><li><strong>BFF에서 비즈니스 로직을 제한하세요:</strong> BFF는 복잡한 비즈니스 로직을 구현하는 것이 아니라 프런트엔드의 데이터를 조정하고 포맷하는 데 집중해야 합니다.</li><li><strong>캐싱 사용:</strong> 특히 모바일 클라이언트의 성능을 개선하기 위해 BFF 계층에서 일반적인 응답을 캐싱할 수 있습니다.</li><li><strong>오류 처리:</strong> 클라이언트가 겪는 문제를 방지하기 위해 BFF에서 오류 처리 및 로깅을 중앙 집중화합니다.</li><li><strong>보안:</strong> 백엔드 서비스를 보호하기 위해 BFF 수준에서 인증, 권한 부여 및 속도 제한을 적용하여 BFF를 보호합니다.</li></ul><h2 id="실제-BFF-성공-사례">실제 BFF 성공 사례</h2><ul><li><strong>Netflix:</strong> 넷플릭스의 원활한 크로스 디바이스 경험의 배경에는 BFF 아키텍처가 있습니다. 모바일 앱은 가벼운 데이터만 가져오고, 데스크톱 앱은 더 풍부한 기능을 위해 더 자세한 정보를 가져옵니다.</li><li><strong>Spotify:</strong> 휴대폰, 태블릿, 스마트 스피커 등 어떤 기기를 사용하든 Spotify의 BFF는 각 기기에 최적화된 데이터를 전송하여 플랫폼 간에 빠르고 원활한 음악 경험을 보장합니다.</li></ul><h2 id="결론">결론</h2><p>Backend for Frontend 아키텍처는 획기적인 기술입니다. 개발자는 이를 통해 각 사용자 인터페이스에 필요한 기능을 정확하게 제공할 수 있습니다. 여러 개의 BFF를 관리하면 복잡성이 증가할 수 있지만 성능 향상과 유연성은 그만한 가치가 있습니다. 웹 앱, 모바일 앱, IoT 디바이스를 확장할 때 BFF는 여러분이 놓치고 있던 비장의 무기일 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/15/info-29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[CORS] 간단하게 설명하기</title>
      <link>http://hgko1207.github.io/2024/10/15/info-28/</link>
      <guid>http://hgko1207.github.io/2024/10/15/info-28/</guid>
      <pubDate>Tue, 15 Oct 2024 04:34:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-28.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/header/info-28_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 내용을 본 적이 있나요? 아마도… 그리고 아마도
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-28.png" alt=""></p><p><img src="/images/header/info-28_1.png" alt=""></p><p>위의 내용을 본 적이 있나요? 아마도… 그리고 아마도 꽤 많이…봤을거에요.</p><p>위의 오류를 수정하는 방법을 설명하는 수백만 개의 문서가 있지만 &quot;<strong>Cross-Origin Resource Sharing(CORS)</strong>&quot;는 정확히 무엇이며 왜 존재하는 것일까요?</p><h2 id="왜">왜??</h2><p>먼저 시나리오를 통해 그 이유에 대한 질문에 답하고 다양한 시점에 어떻게 작동하는지 살펴봅시다.</p><p>뱅킹 서비스인 <code>bank.com</code>에 로그인한다고 상상해 보세요. 로그인하면 '세션 쿠키(Session Cookie)'가 브라우저에 저장됩니다. (세션 쿠키는 기본적으로 <code>bank.com</code> 뒤에 있는 서버에 브라우저가 계정에 로그인했음을 알려줍니다). 앞으로 <code>bank.com</code>에 대한 모든 요청에는 이 쿠키가 포함되며, <code>bank.com</code>은 사용자가 로그인한 것을 알고 제대로 응답할 수 있습니다.</p><p>이제 메일함을 확인해 보겠습니다. 의심스러운 이메일이 보이면 당연히 그 안에 있는 링크를 클릭해 <code>attack.com</code>으로 이동합니다. 다음으로, 이 웹사이트는 은행 정보를 얻기 위해 <code>bank.com</code>에 요청을 보냅니다. 이 세션 쿠키가 브라우저에 저장되어 있기 때문에 <code>bank.com</code>은 여전히 사용자가 로그인한 것으로 간주합니다. <code>bank.com</code> 뒤에 있는 서버는 사용자가 정상적으로 뱅킹 정보를 요청한 것처럼 보이므로 이를 다시 전송합니다. 이제 공격자는 이 쿠키에 액세스하여 악의적으로 다른 곳에 저장합니다.</p><p>사람들은 이것이 좋지 않다는 것을 깨달았고, 브라우저는 SOP(Same-Origin Policy; 동일-출처 정책)를 채택하여 사용자가 <code>bank.com</code>이 아닌 다른 곳에서 <code>bank.com</code>에 요청을 시도하는 것을 브라우저가 감지하면 이를 차단합니다. 여기서 중요한 점은 브라우저 기반 정책이라는 점입니다. <code>bank.com</code>은 요청의 출처를 알 수 있는 방법이 없기 때문에 CSRF와 같은 공격으로부터 크게 보호할 수 없습니다. 사용 중인 브라우저는 기본적으로 Origin에 대한 세부 정보(스키마 + 도메인 이름 + 포트, https//foo.com:4000, http//bar.org:3000 등… 기본적으로 URL)를 요청하는 것처럼 보이는 경우 동일한 Origin의 요청만 전송한다고 말합니다.</p><p>이 기능은 훌륭하지만 매우 제한적이었습니다. 즉, 공개 API는 전혀 작동하지 않았습니다. 일종의 프록시 솔루션을 사용하지 않는 한 데이터를 요청할 수 없었습니다.</p><h2 id="CSRF">CSRF</h2><p>서버는 요청이 어디에서 왔는지 어느 정도 알 수 있습니다. 요청에는 어떤 출처에서 요청을 했는지 보여주는 <strong>‘Origin’</strong> 헤더가 있어야 합니다. 예를 들어, 위의 예에서 요청은 다음과 같이 보입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----&gt; bank.com으로 요청</span></span><br><span class="line">&#123;</span><br><span class="line">  Headers: &#123; <span class="attr">Origin</span>: http:<span class="comment">//attack.com &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이론적으로 <code>bank.com</code>은 이를 확인하여 출처가 합당한 요청에만 응답해야 합니다. 그리고 보통은 그렇게 하므로 SOP는 다소 제한적인 것 같습니다.<br>바로 이때 CORS가 등장합니다.</p><h2 id="CORS">CORS</h2><p><code>example.com</code>의 웹 애플리케이션이 <code>bank.com</code>에서 리소스를 요청하려고 하면 브라우저는 요청에 요청의 출처(<code>example.com</code>)를 나타내는 Origin 헤더를 자동으로 포함합니다. 여기서 중요한 부분이 있습니다: <code>bank.com</code>의 서버는 SOP에 따라 이러한 cross-origin 요청을 전면적으로 차단하는 대신 이 Origin 헤더를 검사하고 자체 CORS 정책에 따라 요청을 허용할지 거부할지 결정할 수 있습니다.</p><p><code>example.com</code>이 신뢰할 수 있거나 요청되는 리소스가 공개적으로 액세스할 수 있는 리소스라고 판단되는 경우, <code>bank.com</code>은 리소스에 액세스할 수 있는 출처를 나타내는 <code>Access-Control-Allow-Origin</code>과 같은 특정 CORS 헤더를 사용하여 응답할 수 있습니다. 이 헤더는 이 Origin을 명시적으로 허용하는 <code>http://example.com</code> 또는 모든 Origin이 액세스할 수 있는 공개 리소스의 경우 <code>*</code>로 설정할 수 있습니다.</p><p>물론 브라우저는 이 모든 작업을 용이하게 합니다. 이 중 하나라도 잘못되면 불쾌한 오류가 발생합니다.</p><p>자 이제 요청에 Origin 헤더가 없으면 어떻게 될까요? 다른 헤더가 많고 기본 HTTP 메서드 중 하나를 사용하지 않는다면 어떨까요?</p><p>이러한 상황에서는 더 이상 &quot;Simple Request&quot;가 아니므로 CORS 처리가 조금 더 복잡해집니다. 바로 이 지점에서 CORS의 “Preflight” 요청이라는 개념이 등장합니다.</p><h2 id="Preflight">Preflight</h2><p>서버의 데이터를 수정할 수 있는 특정 타입의 요청(PUT, DELETE와 같은 HTTP 메서드를 사용하거나 모든 요청에 자동으로 포함되지 않는 헤더를 사용하는 요청)의 경우 브라우저는 실제 요청을 하기 전에 먼저 “Preflight” 요청을 보냅니다. 이 Preflight 요청은 HTTP 옵션 요청으로, 실제 요청을 전송해도 안전한지 서버에 확인하는 데 목적이 있습니다.</p><p>Preflight 요청에는 HTTP 메소드를 설명하는 헤더와 실제 요청의 헤더가 포함됩니다. 다음과 같습니다.</p><ol><li><strong>서버 응답:</strong> 서버가 CORS 정책과 실제 요청을 지원하는 경우, 서버는 허용되는 메소드와 헤더를 나타내는 헤더를 사용하여 Preflight 요청에 응답합니다. 여기에는 <code>Access-Control-Allow-Methods</code> 및 <code>Access-Control-Allow-Headers</code>와 같은 헤더가 포함될 수 있습니다.</li><li><strong>브라우저 결정:</strong> Preflight에 대한 서버의 응답에 따라 브라우저는 실제 요청을 진행할지 여부를 결정합니다. 서버의 응답이 요청이 허용됨을 나타내면 브라우저는 요청을 전송하고, 허용되지 않으면 브라우저는 요청을 차단하고 CORS 관련 오류가 표시됩니다.</li></ol><h2 id="결론">결론</h2><p>이제 CORS에 대해 조금 더 이해하셨기를 바랍니다. 가장 중요한 점은 이것이 모두 브라우저 정책이며 서버가 이를 준수하도록 코딩되어야 한다는 것입니다. 이는 사용자의 안전을 지키기 위해 마련된 것입니다. Chrome을 사용하는 경우 잘못된 링크를 클릭하는 것에 대해 크게 걱정할 필요는 없습니다(물론 여전히 조금은 걱정해야 합니다). 하지만 완벽한 정책은 아닙니다. 표준을 준수하지 않는 타사 브라우저를 사용하면 이 모든 것이 없어질 수 있습니다. 그렇기 때문에 어떤 소프트웨어를 사용하는지 신중해야 합니다!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/15/info-28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] async, await 기능을 사용한 비동기 프로그래밍</title>
      <link>http://hgko1207.github.io/2024/10/14/csharp-11/</link>
      <guid>http://hgko1207.github.io/2024/10/14/csharp-11/</guid>
      <pubDate>Mon, 14 Oct 2024 06:32:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/csharp-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;비동기 프로그래밍은 고성능, 확장성, 반응성이 뛰어난 애플리케이션을 구축하는 데 매우 중요합니다. .NET C#에 &lt;code&gt;async&lt;/code&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/csharp-11.png" alt=""></p><p>비동기 프로그래밍은 고성능, 확장성, 반응성이 뛰어난 애플리케이션을 구축하는 데 매우 중요합니다. .NET C#에 <code>async</code> 및 <code>await</code> 키워드가 도입되면서 비동기 코드 작성 프로세스가 크게 간소화되었습니다. 이 글에서는 비동기 프로그래밍의 복잡성을 자세히 살펴보고, 애플리케이션이 .NET의 비동기 기능의 잠재력을 최대한 활용할 수 있도록 모범 사례와 고급 기술을 제공합니다.</p><h2 id="async-await-이해">async, await 이해</h2><p><code>async</code> 및 <code>await</code> 키워드는 .NET C#에서 비동기 프로그래밍의 기초를 형성합니다. 이를 통해 개발자는 동기식 코드처럼 읽히는 비동기 코드를 작성하여 가독성과 유지 관리성을 모두 향상시킬 수 있습니다.</p><h2 id="async-await-기본-사항">async, await 기본 사항</h2><p><code>async</code> 메서드는 일반적으로 비동기 연산을 수행한다는 의미의 <code>Task</code> 또는 <code>Task&lt;T&gt;</code>를 반환합니다. <code>await</code> 키워드는 스레드를 차단하지 않고 대기 중인 작업이 완료될 때까지 <code>async</code> 메서드의 실행을 일시 중지하는 데 사용됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ExampleAsyncMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// 비동기 작업을 시뮬레이션합니다.</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Operation Completed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await-내부-살펴보기">async, await 내부 살펴보기</h2><p><code>await</code> 키워드가 발생하면 메서드 실행이 일시 중단되고 대기 중인 작업이 완료될 때까지 호출자에게 제어권이 반환됩니다. 이 프로세스는 컴파일러에서 생성된 상태 머신에 의해 관리되며, 이 머신은 메서드의 진행 상황을 추적하고 작업이 완료되면 실행을 재개합니다.</p><h2 id="비동기-프로그래밍-모범-사례">비동기 프로그래밍 모범 사례</h2><p>비동기 프로그래밍의 모범 사례를 준수하는 것은 함정을 피하고 효율적이고 유지 관리 가능한 코드를 보장하는 데 필수적입니다.</p><h3 id="호출-차단-방지">호출 차단 방지</h3><p><code>Task.Wait()</code> 또는 <code>Task.Result</code>와 같은 메서드로 호출 스레드를 차단하면 스레드가 작업이 완료될 때까지 대기하게 되어 비동기 프로그래밍의 이점이 훼손됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt; LongRunningOperation()).Wait();</span><br></pre></td></tr></table></figure><p>대신 <code>await</code>을 사용하여 차단하지 않고 비동기 작업을 처리하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Run(() =&gt; LongRunningOperation());</span><br></pre></td></tr></table></figure><h3 id="ConfigureAwait-false-사용">ConfigureAwait(false) 사용</h3><p>라이브러리 코드에서 <code>ConfigureAwait(false)</code>를 사용하면 현재 동기화 컨텍스트를 캡처하지 않으므로 성능이 향상되고 잠재적인 교착 상태를 방지할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> SomeAsyncMethod().ConfigureAwait(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="예외를-효과적으로-처리하기">예외를 효과적으로 처리하기</h3><p>비동기 코드에서 적절한 예외 처리는 매우 중요합니다. 비동기 메서드 내에서 try-catch 블록을 사용하여 예외를 포착하고 처리하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> SomeAsyncMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 예외 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="고급-기술">고급 기술</h2><p>.NET C#에서 비동기 프로그래밍의 모든 기능을 활용하려면 고급 기술을 이해하고 적용하는 것이 중요합니다.</p><h3 id="Task-based-Asynchronous-TAP-패턴">Task-based Asynchronous(TAP) 패턴</h3><p>작업 기반 비동기 패턴(TAP)은 비동기 연산을 표현하기 위해 <code>Task</code> 및 <code>Task&lt;T&gt;</code> 유형을 사용하는 디자인 패턴입니다. TAP는 비동기 코드 작성을 위한 일관된 접근 방식을 제공하므로 복잡한 연산을 더 쉽게 작성하고 관리할 수 있습니다.</p><h3 id="IAsyncEnumerable-T-를-사용한-비동기-스트림">IAsyncEnumerable<T>를 사용한 비동기 스트림</h3><p>C# 8.0에 도입된 비동기 스트림(<code>IAsyncEnumerable&lt;T&gt;</code>)을 사용하면 데이터의 비동기 시퀀스를 반복할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GenerateNumbersAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="성능-고려-사항-및-최적화">성능 고려 사항 및 최적화</h3><p>비동기 프로그래밍은 작업 할당 및 컨텍스트 전환으로 인해 오버헤드가 발생할 수 있습니다. 결과를 동기적으로 사용할 수 있는 경우가 많은 성능에 중요한 경로에는 <code>ValueTask</code>를 사용하여 이를 최소화하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> ValueTask&lt;<span class="keyword">int</span>&gt; <span class="title">ComputeAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실제-예제">실제 예제</h2><h3 id="ASP-NET-Core의-비동기-프로그래밍"><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core의 비동기 프로그래밍</h3><p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core에서 비동기 프로그래밍은 I/O 바인딩 작업을 효율적으로 처리하고 부하가 걸린 상태에서도 애플리케이션의 응답성을 유지하는 데 필수적입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">await</span> _dataService.GetDataAsync();</span><br><span class="line">    <span class="keyword">return</span> Ok(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="비동기-파일-작업">비동기 파일 작업</h3><p>비동기 파일 작업을 활용하여 특히 I/O 바인딩 애플리케이션에서 성능을 향상시킬 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">ReadFileAsync</span>(<span class="params"><span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> reader.ReadToEndAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>.NET C#에서 <code>async</code> 및 <code>await</code>을 사용한 비동기 프로그래밍은 반응성이 뛰어난 고성능 애플리케이션을 구축하기 위한 강력한 프레임워크를 제공합니다. 개발자는 모범 사례를 준수하고 고급 기술을 사용하여 효율적이고 유지 관리가 쉬운 비동기 코드를 작성할 수 있습니다. 이러한 개념을 도입하여 애플리케이션의 확장성과 성능을 향상시키고 .NET의 강력한 비동기 기능을 최대한 활용하세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/14/csharp-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>.NET Core로 고성능 API 빌드하기</title>
      <link>http://hgko1207.github.io/2024/10/10/netcore-1/</link>
      <guid>http://hgko1207.github.io/2024/10/10/netcore-1/</guid>
      <pubDate>Thu, 10 Oct 2024 04:11:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/netcore-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;디지털 환경에서 API는 최신 웹 애플리케이션의 중추로, 서로 다른 소프트웨어 시스템 간의 원활한 통신을 가능하게 합니다. &lt;strong&gt;.NET 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/netcore-1.png" alt=""></p><p>디지털 환경에서 API는 최신 웹 애플리케이션의 중추로, 서로 다른 소프트웨어 시스템 간의 원활한 통신을 가능하게 합니다. <strong>.NET Web API</strong>는 개발자가 강력하고 확장 가능한 API를 구축할 수 있는 강력한 프레임워크입니다. 이 글에서는 효율적이고 안전하며 유지 관리가 용이한 API를 만들기 위해 .NET Web API를 마스터하기 위한 모범 사례를 살펴봅니다.</p><h2 id="1-RESTful-API-설계">1. RESTful API 설계</h2><h3 id="REST-원칙-준수">REST 원칙 준수</h3><p>Stateless, 확장성, 이해하기 쉽도록 REST 원칙을 준수하여 API를 설계하세요. 다양한 작업에 적절한 HTTP 메서드(GET, POST, PUT, DELETE)와 표준 상태 코드를 사용하여 API 호출의 결과를 표시하세요.</p><h3 id="API-버전-관리">API 버전 관리</h3><p>버전 관리를 구현하여 변경 사항을 관리하고 이전 버전과의 호환성을 보장하세요. URL, Query String 또는 헤더에 버전 번호를 포함할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiVersion(<span class="meta-string">"1.0"</span>)</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/v&#123;version:apiVersion&#125;/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-강력한-보안-구현">2. 강력한 보안 구현</h2><h3 id="HTTPS-사용">HTTPS 사용</h3><p>항상 HTTPS를 사용하여 클라이언트와 서버 간에 전송되는 데이터를 암호화하여 가로채기 및 변조로부터 데이터를 보호하세요.</p><h3 id="인증-및-권한-부여-구현">인증 및 권한 부여 구현</h3><p>Stateless(무상태) 인증 및 권한 부여를 위한 역할 기반 액세스 제어를 위해 JWT(JSON Web Token)를 사용하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer((options) =&gt; &#123;</span><br><span class="line">  options.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters();</span><br><span class="line">  &#123;</span><br><span class="line">      (ValidateIssuer = <span class="literal">true</span>),</span><br><span class="line">      (ValidateAudience = <span class="literal">true</span>),</span><br><span class="line">      (ValidateLifetime = <span class="literal">true</span>),</span><br><span class="line">      (ValidateIssuerSigningKey = <span class="literal">true</span>),</span><br><span class="line">      (ValidIssuer = Configuration[<span class="string">'Jwt:Issuer'</span>]),</span><br><span class="line">      (ValidAudience = Configuration[<span class="string">'Jwt:Issuer'</span>]),</span><br><span class="line">      (IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[<span class="string">'Jwt:Key'</span>])));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-성능-최적화">3. 성능 최적화</h2><h3 id="캐싱-구현">캐싱 구현</h3><p>자주 액세스하는 데이터에는 인메모리 캐싱을 사용하고 대규모 분산 시스템에는 분산 캐싱(예: Redis)을 사용합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache _cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductService</span>(<span class="params">IMemoryCache cache</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">GetProduct</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cache.GetOrCreate(id, entry =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> _context.Products.Find(id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="비동기-프로그래밍-사용">비동기 프로그래밍 사용</h3><p><code>async</code> 및 <code>await</code>을 활용하여 I/O 바인딩 연산을 효율적으로 처리하고 다른 요청을 처리할 수 있는 스레드를 확보하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProduct</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> product = <span class="keyword">await</span> _context.Products.FindAsync(id);</span><br><span class="line">    <span class="keyword">return</span> Ok(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-유지보수성-향상">4. 유지보수성 향상</h2><h3 id="종속성-주입-사용">종속성 주입 사용</h3><p>종속성 주입을 도입하여 종속성을 관리하고 코드를 보다 모듈화하고 테스트할 수 있도록 하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddScoped&lt;IProductService, ProductService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SOLID-원칙-준수">SOLID 원칙 준수</h3><p>SOLID 원칙(Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)을 준수하여 깔끔하고 유지 관리 가능한 코드를 작성하세요.</p><h2 id="5-모니터링-및-진단">5. 모니터링 및 진단</h2><h3 id="로깅-구현">로깅 구현</h3><p>Serilog 또는 NLog와 같은 로깅 프레임워크를 사용하여 모니터링 및 문제 해결을 위한 자세한 로그를 캡처하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddLogging(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.AddSerilog();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="애플리케이션-인사이트-Insights-사용">애플리케이션 인사이트(Insights) 사용</h3><p>애플리케이션 인사이트를 통합하여 API의 성능과 사용량에 대한 종합적인 모니터링 및 진단을 수행하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddApplicationInsightsTelemetry(Configuration[<span class="string">"ApplicationInsights:InstrumentationKey"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>.NET Web API를 마스터하려면 디자인, 보안, 성능, 유지 관리 및 모니터링에 대한 모범 사례를 조합해야 합니다. 이러한 전략을 구현하면 최신 웹 애플리케이션의 요구 사항을 충족하는 강력하고 확장 가능하며 안전한 API를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/10/netcore-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>백엔드 개발자로서 ChatGPT를 사용하는 방법(5가지 방법)</title>
      <link>http://hgko1207.github.io/2024/10/10/chatgpt-31/</link>
      <guid>http://hgko1207.github.io/2024/10/10/chatgpt-31/</guid>
      <pubDate>Thu, 10 Oct 2024 03:54:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 생산성과 문제 해결 능력을 향상시키는 귀중한 도구입니다. 백엔드 개발을 할 때 ChatGPT를 활용
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-31.png" alt=""></p><p><strong>ChatGPT</strong>는 생산성과 문제 해결 능력을 향상시키는 귀중한 도구입니다. 백엔드 개발을 할 때 ChatGPT를 활용하는 5가지 방법을 소개합니다.</p><h2 id="1-API-문서-생성">1. API 문서 생성</h2><p>백엔드 개발자에게 가장 시간이 많이 걸리는 작업 중 하나는 포괄적인 API 문서를 작성하는 것입니다. ChatGPT는 이 작업에 탁월합니다,</p><ul><li><strong>엔드포인트 설명:</strong> 엔드포인트 세부 정보를 제공하면 ChatGPT가 명확하고 간결한 설명을 생성합니다.</li><li><strong>요청/응답 예제:</strong> 현실적인 페이로드와 응답 예제를 생성할 수 있습니다.</li><li><strong>오류 시나리오:</strong> ChatGPT는 잠재적인 오류 사례와 해당 상태 코드를 문서화하는 데 도움을 줍니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChatGPT로 생성된 API 문서 예시</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"endpoint"</span>: <span class="string">"/api/v1/users"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Creates a new user account"</span>,</span><br><span class="line">  <span class="attr">"request_body"</span>: &#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"string"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"response"</span>: &#123;</span><br><span class="line">    <span class="attr">"201"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"User successfully created"</span>,</span><br><span class="line">      <span class="attr">"content"</span>: &#123;</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="string">"uuid"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"400"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Invalid input"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-데이터베이스-쿼리-최적화">2. 데이터베이스 쿼리 최적화</h2><p>ChatGPT는 쿼리 최적화 전략을 브레인스토밍하는 데 탁월합니다.</p><ul><li><strong>쿼리 분석:</strong> 문제가 있는 쿼리를 붙여넣으면 ChatGPT가 개선점을 제안합니다.</li><li><strong>인덱스 추천:</strong> 쿼리 성능을 향상시킬 수 있는 잠재적인 인덱스를 제안할 수 있습니다.</li><li><strong>대체 접근 방식:</strong> 종종 더 효율적일 수 있는 다른 쿼리 구조를 제안합니다.</li></ul><h2 id="3-코드-리팩토링-도우미">3. 코드 리팩토링 도우미</h2><p>레거시 코드 또는 복잡한 리팩터링 작업에 직면했을 때 활동합니다.</p><ul><li><strong>코드 분석:</strong> ChatGPT는 코드 냄새와 잠재적인 개선 사항을 식별하는 데 도움을 줍니다.</li><li><strong>디자인 패턴:</strong> 특정 시나리오에 적합한 디자인 패턴을 제안합니다.</li><li><strong>현대화:</strong> 최신 언어 기능 및 모범 사례를 사용하도록 오래된 코드를 업데이트하는 데 도움을 줍니다.</li></ul><p>예를 들어, 아래 코드를 변환합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 수정 전</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserData</span>(<span class="params">$userId</span>) </span>&#123;</span><br><span class="line">    $data = array();</span><br><span class="line">    $result = mysql_query(<span class="string">"SELECT * FROM users WHERE id = "</span> . $userId);</span><br><span class="line">    <span class="keyword">while</span> ($row = mysql_fetch_assoc($result)) &#123;</span><br><span class="line">        $data[] = $row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 수정 후</span></span><br><span class="line">public <span class="function"><span class="keyword">function</span> <span class="title">getUserData</span>(<span class="params">int $userId</span>): <span class="title">array</span> </span>&#123;</span><br><span class="line">    $pdo = Database::getInstance()-&gt;getConnection();</span><br><span class="line">    $stmt = $pdo-&gt;prepare(<span class="string">"SELECT * FROM users WHERE id = :userId"</span>);</span><br><span class="line">    $stmt-&gt;execute([<span class="string">'userId'</span> =&gt; $userId]);</span><br><span class="line">    <span class="keyword">return</span> $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-테스트-시나리오-생성">4. 테스트 시나리오 생성</h2><p>ChatGPT는 다양한 테스트 시나리오를 생각하도록 도와주는 데 탁월합니다.</p><ul><li><strong>Edge 케이스:</strong> 제가 놓쳤을 수 있는 경계 조건을 식별합니다.</li><li><strong>테스트 데이터:</strong> 다양한 시나리오에 대한 현실적인 테스트 데이터를 생성합니다.</li><li><strong>테스트 구조:</strong> 테스트 사례를 명확하고 체계적으로 정리할 수 있도록 도와줍니다.</li></ul><p>ChatGPT가 생성한 테스트 시나리오 예시입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="keyword">function</span> <span class="title">testUserRegistration</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 등록 성공 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testSuccessfulRegistration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 중복 이메일 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testDuplicateEmailRegistration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 유효하지 않은 이메일 형식 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testInvalidEmailFormat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비밀번호 요구 사항 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testPasswordTooShort();</span><br><span class="line">    $<span class="keyword">this</span>-&gt;testPasswordRequiresSpecialChar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 사용자 이름 요구 사항 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testUsernameTooLong();</span><br><span class="line">    $<span class="keyword">this</span>-&gt;testUsernameWithInvalidChars();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-디버깅-파트너">5. 디버깅 파트너</h2><p>까다로운 버그에 걸렸을 때 사용합니다.</p><ul><li><strong>오류 분석:</strong> 오류 메시지를 공유하면 ChatGPT가 해석을 도와줍니다.</li><li><strong>디버깅 단계:</strong> 문제를 격리하기 위한 체계적인 접근 방식을 제안합니다.</li><li><strong>솔루션 브레인스토밍:</strong> 잠재적인 수정 사항과 설명을 제공합니다.</li></ul><p>ChatGPT 사용 모범 사례</p><ol><li><strong>결과물 확인:</strong> 구현하기 전에 항상 ChatGPT의 제안을 검토하고 테스트하세요.</li><li><strong>컨텍스트 제공:</strong> 더 많은 컨텍스트를 제공할수록 더 나은 응답을 얻을 수 있습니다.</li><li><strong>반복하기:</strong> ChatGPT를 시작점으로 삼아 제안을 구체화하세요.</li><li><strong>보안 인식:</strong> 민감한 정보나 자격 증명을 절대 공유하지 마세요.</li></ol>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/10/chatgpt-31/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
