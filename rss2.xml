<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Mon, 25 Nov 2024 05:54:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Spring Boot에서 Lombok을 활용한 효율적인 Java 개발 가이드 🌟</title>
      <link>http://hgko1207.github.io/2024/11/25/spring-9/</link>
      <guid>http://hgko1207.github.io/2024/11/25/spring-9/</guid>
      <pubDate>Mon, 25 Nov 2024 05:38:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Project Lombok&lt;/strong&gt;은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Project Lombok</strong>은 자바 코드의 반복적인 작업을 줄이고, 생산성을 향상시키는 라이브러리입니다. Lombok은 어노테이션(Annotation)을 통해 getter, setter, constructor 등의 보일러플레이트 코드를 자동으로 생성해줍니다.</p><h2 id="lombok을-사용하는-이유"><a class="markdownIt-Anchor" href="#lombok을-사용하는-이유"></a> Lombok을 사용하는 이유</h2><ul><li><strong>코드 간소화:</strong> <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, getters, setters 등의 일반적인 메서드를 자동으로 생성합니다.</li><li><strong>가독성 향상:</strong> 불필요한 코드가 줄어들어 코드의 의도가 더 명확하게 드러납니다.</li><li><strong>개발 시간 단축:</strong> 작성해야 할 코드가 줄어들어 비즈니스 로직에 집중할 수 있습니다.</li><li><strong>리팩토링 용이성:</strong> 필드 이름을 변경하더라도 getter/setter를 따로 수정할 필요가 없습니다.</li></ul><h2 id="lombok의-주요-기능"><a class="markdownIt-Anchor" href="#lombok의-주요-기능"></a> Lombok의 주요 기능</h2><p>Lombok은 수많은 주석을 제공합니다. 다음은 몇 가지 주요 기능을 살펴보겠습니다.</p><h2 id="data"><a class="markdownIt-Anchor" href="#data"></a> @Data</h2><p>모든 필드에 대한 getter를 생성하고, <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> 메서드와 생성자를 자동으로 만듭니다. 또한, final 필드에 대해 setter도 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 구현</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">               <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-nonnull"><a class="markdownIt-Anchor" href="#2-nonnull"></a> 2. @NonNull</h2><p>메서드 또는 생성자의 매개변수에 대해 null 체크를 자동으로 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(@NonNull String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-cleanup"><a class="markdownIt-Anchor" href="#3-cleanup"></a> 3. @Cleanup</h2><p>특정 리소스를 자동으로 정리하여 리소스 누수를 방지합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="comment">// 스트림 작업</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-sneakythrows"><a class="markdownIt-Anchor" href="#4-sneakythrows"></a> 4. @SneakyThrows</h2><p>메서드 선언에 <code>throws</code>를 명시하지 않고도 체크 예외를 던질 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Files.readAllBytes(Paths.get(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-builder"><a class="markdownIt-Anchor" href="#5-builder"></a> 5. @Builder</h2><p>객체 생성을 위한 빌더 패턴을 자동으로 구현합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>생성되는 코드:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">email</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(name, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-value"><a class="markdownIt-Anchor" href="#6-value"></a> 6. @Value</h2><p><code>@Data</code>의 불변(immutable) 버전으로, 모든 필드를 private 및 final로 설정하며 setter를 생성하지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-생성자-어노테이션"><a class="markdownIt-Anchor" href="#7-생성자-어노테이션"></a> 7. 생성자 어노테이션</h2><p>Lombok은 생성자를 자동으로 생성하는 여러 어노테이션을 제공합니다.</p><h3 id="noargsconstructor"><a class="markdownIt-Anchor" href="#noargsconstructor"></a> @NoArgsConstructor</h3><p>인수 없는 생성자를 생성합니다. 프레임워크(JPA 등)에서 필요한 경우 유용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requiredargsconstructor"><a class="markdownIt-Anchor" href="#requiredargsconstructor"></a> @RequiredArgsConstructor</h3><p><code>final</code> 필드 및 <code>@NonNull</code> 필드에 대해 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@NonNull String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allargsconstructor"><a class="markdownIt-Anchor" href="#allargsconstructor"></a> @AllArgsConstructor</h3><p>모든 필드에 대한 생성자를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intellij-및-eclipse에서-lombok-설정"><a class="markdownIt-Anchor" href="#intellij-및-eclipse에서-lombok-설정"></a> IntelliJ 및 Eclipse에서 Lombok 설정</h2><h3 id="intellij-idea"><a class="markdownIt-Anchor" href="#intellij-idea"></a> IntelliJ IDEA</h3><ul><li><strong>플러그인 설치:</strong> 마켓플레이스에서 Lombok 플러그인을 설치합니다.</li><li><strong>어노테이션 프로세싱 활성화:</strong><br />Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors에서 활성화.</li></ul><h3 id="eclipse"><a class="markdownIt-Anchor" href="#eclipse"></a> Eclipse</h3><ul><li><strong>Lombok JAR 다운로드 및 실행:</strong> Eclipse 설치 경로에 Lombok을 통합합니다.</li><li><strong>재시작 및 설정 확인:</strong> 프로젝트 속성에서 어노테이션 프로세싱 활성화.</li></ul><h2 id="maven-및-gradle-통합"><a class="markdownIt-Anchor" href="#maven-및-gradle-통합"></a> Maven 및 Gradle 통합</h2><ul><li><strong>Maven 설정</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Gradle 설정</strong></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok:1.18.22'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Lombok은 특히 Spring Boot 생태계에서 자바 개발자에게 필수적인 도구로 자리 잡았습니다. 보일러플레이트 코드를 줄이고 유지보수를 간소화하며, 코드 생산성을 크게 향상시킵니다.</p><p><strong>Lombok을 제대로 이해하고 활용하면, Spring Boot 애플리케이션 개발의 효율성이 크게 향상될 것입니다.</strong></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/spring-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모든 개발자가 알아야 할 20가지 Git 명령어</title>
      <link>http://hgko1207.github.io/2024/11/25/git-4/</link>
      <guid>http://hgko1207.github.io/2024/11/25/git-4/</guid>
      <pubDate>Mon, 25 Nov 2024 04:55:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/git-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 &lt;code&gt;push&lt;/code&gt;, &lt;code
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/git-4.png" alt="" /></p><p><strong>Git</strong>은 대부분의 개발자가 매일 사용하는 필수 도구지만, 많은 경우 기본적인 <code>push</code>, <code>pull</code>, <code>commit</code> 정도만 활용합니다. 그러나 Git은 우리가 상상하지 못한 다양한 기능을 제공하며, 이를 활용하면 생산성과 효율성을 대폭 향상시킬 수 있습니다.</p><p>이 글에서는 <strong>Git의 유용한 명령어 20가지</strong>를 소개하며, 이를 통해 더욱 효율적이고 자신감 있게 버전 관리를 할 수 있도록 도와드립니다.</p><h2 id="1-인터랙티브-추가"><a class="markdownIt-Anchor" href="#1-인터랙티브-추가"></a> 1. 인터랙티브 추가</h2><ul><li><strong>설명:</strong> 파일 전체가 아닌 특정 부분만 스테이징할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 내의 특정 변경 사항만 선택적으로 커밋할 수 있어, 작은 단위의 커밋을 만들 때 유용합니다.</li><li><strong>팁:</strong> 한 파일에서 여러 작업을 진행한 경우, 각 작업을 개별 커밋으로 나누는 데 사용하세요.</li></ul><h2 id="2-마지막-커밋-되돌리기"><a class="markdownIt-Anchor" href="#2-마지막-커밋-되돌리기"></a> 2. 마지막 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 마지막 커밋을 취소하되, 작업 디렉토리의 변경 사항은 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 커밋을 수정하거나 다시 커밋할 수 있는 “타임머신” 같은 기능입니다.</li><li><strong>팁:</strong> <code>--soft</code>는 변경 사항을 유지하고, <code>--hard</code>는 변경 사항까지 모두 되돌립니다.</li></ul><h2 id="3-브랜치의-업스트림-상태-확인하기"><a class="markdownIt-Anchor" href="#3-브랜치의-업스트림-상태-확인하기"></a> 3. 브랜치의 업스트림 상태 확인하기</h2><ul><li><strong>설명:</strong> 원격의 모든 업데이트를 가져오고, 삭제된 원격 브랜치의 참조를 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all --prune</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 로컬 환경을 최신 상태로 유지하며, 불필요한 브랜치를 정리합니다.</li><li><strong>팁:</strong> 대규모 팀에서 작업할 때 브랜치 목록을 깔끔하게 유지하세요.</li></ul><h2 id="4-빠른-커밋-수정"><a class="markdownIt-Anchor" href="#4-빠른-커밋-수정"></a> 4. 빠른 커밋 수정</h2><ul><li><strong>설명:</strong> 마지막 커밋을 수정하거나 커밋 메시지를 변경합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> Git 로그를 깔끔하게 유지하며 작은 실수를 빠르게 수정할 수 있습니다.</li><li><strong>팁:</strong> 여러 번의 커밋 없이 작은 실수를 수정하세요.</li></ul><h2 id="5-작업-임시-저장"><a class="markdownIt-Anchor" href="#5-작업-임시-저장"></a> 5. 작업 임시 저장</h2><ul><li><strong>설명:</strong> 현재 변경 사항을 커밋하지 않고 임시로 저장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 현재 작업을 보류하고 다른 브랜치로 전환할 수 있습니다.</li><li><strong>팁:</strong> <code>git stash save &quot;설명&quot;</code>으로 임시 저장 항목에 설명을 추가하면 더 쉽게 찾을 수 있습니다.</li></ul><h2 id="6-임시-저장-복원"><a class="markdownIt-Anchor" href="#6-임시-저장-복원"></a> 6. 임시 저장 복원</h2><ul><li><strong>설명:</strong> 임시 저장된 작업을 복원합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 저장한 작업을 다시 가져오며, 목록에서 자동으로 삭제됩니다.</li><li><strong>팁:</strong> <code>git stash apply</code>를 사용하면 삭제 없이 적용할 수 있습니다.</li></ul><h2 id="7-특정-커밋-가져오기"><a class="markdownIt-Anchor" href="#7-특정-커밋-가져오기"></a> 7. 특정 커밋 가져오기</h2><ul><li><strong>설명:</strong> 특정 커밋만 현재 브랜치에 적용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 브랜치 전체를 병합하지 않고 필요한 기능이나 버그 수정을 가져올 수 있습니다.</li><li><strong>팁:</strong> 버그 수정이나 특정 기능만 백포트(backport)할 때 유용합니다.</li></ul><h2 id="8-로컬-브랜치-정리"><a class="markdownIt-Anchor" href="#8-로컬-브랜치-정리"></a> 8. 로컬 브랜치 정리</h2><ul><li><strong>설명:</strong> 사용하지 않는 브랜치를 삭제합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 오래된 브랜치를 정리해 작업 공간을 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 병합되지 않은 브랜치를 삭제하려면 <code>-D</code> 플래그를 사용하세요.</li></ul><h2 id="9-파일-히스토리-보기"><a class="markdownIt-Anchor" href="#9-파일-히스토리-보기"></a> 9. 파일 히스토리 보기</h2><ul><li><strong>설명:</strong> 특정 파일에 영향을 준 모든 커밋을 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 파일 변경 이력을 추적해 변경 이유를 이해할 수 있습니다.</li><li><strong>팁:</strong> <code>--stat</code> 옵션을 추가하면 더 자세한 변경 내용을 볼 수 있습니다.</li></ul><h2 id="10-라인별-코드-작성자-확인"><a class="markdownIt-Anchor" href="#10-라인별-코드-작성자-확인"></a> 10. 라인별 코드 작성자 확인</h2><ul><li><strong>설명:</strong> 특정 파일의 각 줄을 누가 작성했는지 확인합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 디버깅 시 특정 코드 작성자를 추적하는 데 유용합니다.</li><li><strong>팁:</strong> <code>git log</code>와 함께 사용해 더 자세한 히스토리를 확인하세요.</li></ul><h2 id="11-버그-소스-찾기"><a class="markdownIt-Anchor" href="#11-버그-소스-찾기"></a> 11. 버그 소스 찾기</h2><ul><li><strong>설명:</strong> 이진 검색을 통해 버그가 도입된 커밋을 찾습니다.</li><li><strong>장점:</strong> 대규모 프로젝트에서 버그가 발생한 커밋을 빠르게 찾습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good &lt;older-commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="12-병합-중단"><a class="markdownIt-Anchor" href="#12-병합-중단"></a> 12. 병합 중단</h2><ul><li><strong>설명:</strong> 병합 중 문제가 발생하면 병합을 중단하고 이전 상태로 되돌립니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 병합 중단 후 새로운 시작점을 제공합니다.</li><li><strong>팁:</strong> 병합 전에 작업 디렉토리를 깨끗하게 유지하세요.</li></ul><h2 id="13-커밋-메시지-검색"><a class="markdownIt-Anchor" href="#13-커밋-메시지-검색"></a> 13. 커밋 메시지 검색</h2><ul><li><strong>설명:</strong> 커밋 메시지를 검색합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=<span class="string">"검색어"</span></span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 메시지 키워드로 커밋을 빠르게 찾습니다.</li><li><strong>팁:</strong> <code>--author</code>를 추가해 특정 작성자의 커밋을 검색하세요.</li></ul><h2 id="14-태그-추가"><a class="markdownIt-Anchor" href="#14-태그-추가"></a> 14. 태그 추가</h2><ul><li><strong>설명:</strong> Git 히스토리에서 특정 지점을 태그로 표시합니다.</li><li><strong>장점:</strong> 특정 버전을 표시해 쉽게 참조할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">"Version 1.0 release"</span></span><br></pre></td></tr></table></figure><h2 id="15-작업-공간-정리"><a class="markdownIt-Anchor" href="#15-작업-공간-정리"></a> 15. 작업 공간 정리</h2><ul><li><strong>설명:</strong> 추적되지 않은 파일과 디렉터리를 제거합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd</span><br></pre></td></tr></table></figure><ul><li><strong>장점:</strong> 작업 디렉토리를 정리하고 깔끔하게 유지합니다.</li><li><strong>팁:</strong> 삭제된 파일이 필요 없는지 확인하세요.</li></ul><h2 id="16-git-작업-기록-보기"><a class="markdownIt-Anchor" href="#16-git-작업-기록-보기"></a> 16. Git 작업 기록 보기</h2><ul><li><strong>설명:</strong> 모든 Git 작업 기록을 확인합니다.</li><li><strong>장점:</strong> 손실된 커밋이나 작업을 복구할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="17-커밋-합치기"><a class="markdownIt-Anchor" href="#17-커밋-합치기"></a> 17. 커밋 합치기</h2><ul><li><strong>설명:</strong> 여러 커밋을 하나로 합쳐 Git 로그를 깔끔하게 만듭니다.</li><li><strong>장점:</strong> 커밋 기록을 깔끔하고 전문적으로 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~&lt;number-of-commits&gt;</span><br></pre></td></tr></table></figure><h2 id="18-커밋-되돌리기"><a class="markdownIt-Anchor" href="#18-커밋-되돌리기"></a> 18. 커밋 되돌리기</h2><ul><li><strong>설명:</strong> 특정 커밋을 되돌리되, 전체 히스토리는 유지합니다.</li><li><strong>장점:</strong> 히스토리를 변경하지 않고 실수를 수정할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><h2 id="19-브랜치-그래프-보기"><a class="markdownIt-Anchor" href="#19-브랜치-그래프-보기"></a> 19. 브랜치 그래프 보기</h2><ul><li><strong>설명:</strong> 프로젝트의 브랜치와 병합 기록을 그래프로 표시합니다.</li><li><strong>장점:</strong> 브랜치 구조를 한눈에 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all</span><br></pre></td></tr></table></figure><h2 id="20-자동-완성-사용"><a class="markdownIt-Anchor" href="#20-자동-완성-사용"></a> 20. 자동 완성 사용</h2><ul><li><strong>설명:</strong> Git 명령어 입력 시 탭을 눌러 자동 완성을 활성화합니다.</li><li><strong>장점:</strong> 생산성을 높이고 타이핑 오류를 줄입니다.</li></ul><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 20가지 Git 명령어 트릭은 생산성을 높이고 팀 내 Git 관리 능력을 향상시키는 필수 도구입니다. 이를 익히고 활용하면 동료들에게 &quot;Git 마스터&quot;로 인정받을 것입니다. 🚀</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/git-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(2)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-3/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-3/</guid>
      <pubDate>Mon, 25 Nov 2024 04:37:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;16-docker-image-prune&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#16-docker-image-prune&quot;&gt;&lt;/a&gt; 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 지난글에 이어서 Docker 명령어를 알려드리겠습니다.</p><h2 id="16-docker-image-prune"><a class="markdownIt-Anchor" href="#16-docker-image-prune"></a> 16. <code>docker image prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 이미지를 삭제합니다.</li><li><strong>장점:</strong> 개발 환경을 깔끔하게 유지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="17-docker-volume-prune"><a class="markdownIt-Anchor" href="#17-docker-volume-prune"></a> 17. <code>docker volume prune</code></h2><ul><li><strong>설명:</strong> 사용하지 않는 볼륨을 삭제합니다.</li><li><strong>장점:</strong> 불필요한 스토리지 사용을 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><h2 id="18-docker-events"><a class="markdownIt-Anchor" href="#18-docker-events"></a> 18. <code>docker events</code></h2><ul><li><strong>설명:</strong> Docker 서버의 실시간 이벤트를 스트리밍합니다.</li><li><strong>장점:</strong> 컨테이너 수명 주기 이벤트를 추적합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events</span><br></pre></td></tr></table></figure><h2 id="19-docker-inspect-format"><a class="markdownIt-Anchor" href="#19-docker-inspect-format"></a> 19. <code>docker inspect --format</code></h2><ul><li><strong>설명:</strong> <code>docker inspect</code> 출력에서 특정 정보를 추출합니다.</li><li><strong>장점:</strong> 자동화 스크립트에서 필요한 데이터만 효율적으로 가져옵니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123; .Config.Env &#125;&#125;'</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="20-docker-build-no-cache"><a class="markdownIt-Anchor" href="#20-docker-build-no-cache"></a> 20. <code>docker build --no-cache</code></h2><ul><li><strong>설명:</strong> 캐시를 사용하지 않고 이미지를 빌드합니다.</li><li><strong>장점:</strong> 깨끗한 빌드를 보장합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="21-docker-run-d"><a class="markdownIt-Anchor" href="#21-docker-run-d"></a> 21. <code>docker run -d</code></h2><ul><li><strong>설명:</strong> 컨테이너를 백그라운드에서 실행합니다.</li><li><strong>장점:</strong> 터미널을 자유롭게 사용하면서 여러 컨테이너를 관리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="22-docker-image-inspect"><a class="markdownIt-Anchor" href="#22-docker-image-inspect"></a> 22. <code>docker image inspect</code></h2><ul><li><strong>설명:</strong> 이미지의 세부 정보를 제공합니다.</li><li><strong>장점:</strong> 디버깅 및 이미지 최적화에 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="23-docker-save-docker-load"><a class="markdownIt-Anchor" href="#23-docker-save-docker-load"></a> 23. <code>docker save / docker load</code></h2><ul><li><strong>설명:</strong> 이미지를 tar 파일로 저장하거나 로드합니다.</li><li><strong>장점:</strong> 인터넷 없이 이미지를 전송할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;image_name&gt;.tar &lt;image_name&gt;</span><br><span class="line">docker load -i &lt;image_name&gt;.tar</span><br></pre></td></tr></table></figure><h2 id="24-docker-exec-it"><a class="markdownIt-Anchor" href="#24-docker-exec-it"></a> 24. <code>docker exec -it</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너에서 대화형 bash 셸을 엽니다.</li><li><strong>장점:</strong> 컨테이너 내부에서 디버깅과 테스트를 빠르게 수행할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name&gt; bash</span><br></pre></td></tr></table></figure><h2 id="25-docker-ps-q-docker-stop-docker-ps-q"><a class="markdownIt-Anchor" href="#25-docker-ps-q-docker-stop-docker-ps-q"></a> 25. docker ps -q / docker stop $(docker ps -q)</h2><ul><li><strong>설명:</strong> 실행 중인 모든 컨테이너를 빠르게 중지합니다.</li><li><strong>장점:</strong> 개발 환경을 한 번에 정리할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이 25가지 Docker 명령어는 일상적인 워크플로를 개선하고 컨테이너 환경을 보다 효율적으로 관리할 수 있도록 도와줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 성장시키는 25가지 Docker 명령어(1)</title>
      <link>http://hgko1207.github.io/2024/11/25/devops-2/</link>
      <guid>http://hgko1207.github.io/2024/11/25/devops-2/</guid>
      <pubDate>Mon, 25 Nov 2024 04:10:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Docker</strong>는 애플리케이션과 그 의존성을 패키징하여 이식 가능하고 격리된 컨테이너를 효율적으로 관리할 수 있게 해줍니다.</p><p>이론만 이해하는 것으로는 충분하지 않습니다. 개발자를 한 단계 더 성장시키는 것은 <strong>Docker 명령어</strong>를 활용해 워크플로를 최적화하고, 성능을 개선하며, 확장 가능한 애플리케이션을 구축하는 능력입니다.</p><p>이 글에서는 Docker 명령어 25가지를 소개하며, 이를 통해 개발 및 배포 프로세스를 완벽하게 제어하고 일상적인 작업을 개선하는 방법을 알려드립니다.</p><h2 id="1-docker-update"><a class="markdownIt-Anchor" href="#1-docker-update"></a> 1. <code>docker update</code></h2><ul><li><strong>설명:</strong> 컨테이너를 재시작하지 않고 리소스 제한을 업데이트합니다.</li><li><strong>장점:</strong> 중단 없이 리소스를 조정해 컨테이너 성능 저하를 방지합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --cpus 2 --memory 1g &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> 트래픽이 많은 시간대에 리소스를 늘렸다가, 이후 다시 축소하여 자원을 절약하세요.</li></ul><h2 id="2-docker-stats"><a class="markdownIt-Anchor" href="#2-docker-stats"></a> 2. <code>docker stats</code></h2><ul><li><strong>설명:</strong> 실행 중인 컨테이너의 실시간 리소스 사용량을 표시합니다.</li><li><strong>장점:</strong> CPU, 메모리, 네트워크 사용량을 실시간으로 모니터링할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container_name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>팁:</strong> --all 옵션으로 백그라운드 컨테이너까지 모니터링하세요.</li></ul><h2 id="3-docker-diff"><a class="markdownIt-Anchor" href="#3-docker-diff"></a> 3. <code>docker diff</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템에서 변경된 내용을 보여줍니다.</li><li><strong>장점:</strong> 배포 후 변경된 파일을 빠르게 확인하고 문제를 해결합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="4-docker-commit"><a class="markdownIt-Anchor" href="#4-docker-commit"></a> 4. <code>docker commit</code></h2><ul><li><strong>설명:</strong> 컨테이너의 현재 상태를 기반으로 새로운 이미지를 생성합니다.</li><li><strong>장점:</strong> 변경된 상태를 저장해 디버깅이나 테스트 환경에 활용할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;container_name&gt; &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="5-docker-cp"><a class="markdownIt-Anchor" href="#5-docker-cp"></a> 5. <code>docker cp</code></h2><ul><li><strong>설명:</strong> 컨테이너와 호스트 간 파일을 복사합니다.</li><li><strong>장점:</strong> 컨테이너를 중단하지 않고 로그나 설정 파일에 접근할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;container_name&gt;:/path/to/file /host/path</span><br></pre></td></tr></table></figure><h2 id="6-docker-build-squash"><a class="markdownIt-Anchor" href="#6-docker-build-squash"></a> 6. <code>docker build --squash</code></h2><ul><li><strong>설명:</strong> 빌드 중 레이어를 하나로 압축하여 이미지 크기를 줄입니다.</li><li><strong>장점:</strong> 이미지 크기를 줄여 로드 시간을 단축하고 저장 공간을 절약합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure><h2 id="7-docker-system-df"><a class="markdownIt-Anchor" href="#7-docker-system-df"></a> 7. <code>docker system df</code></h2><ul><li><strong>설명:</strong> Docker 디스크 사용량 요약 정보를 제공합니다.</li><li><strong>장점:</strong> 디스크 공간을 많이 차지하는 요소를 빠르게 파악할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="8-docker-network-inspect"><a class="markdownIt-Anchor" href="#8-docker-network-inspect"></a> 8. <code>docker network inspect</code></h2><ul><li><strong>설명:</strong> Docker 네트워크의 상세 정보를 확인합니다.</li><li><strong>장점:</strong> 컨테이너 간 네트워킹 문제를 디버깅하는 데 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;network_name&gt;</span><br></pre></td></tr></table></figure><h2 id="9-docker-exec-u"><a class="markdownIt-Anchor" href="#9-docker-exec-u"></a> 9. <code>docker exec -u</code></h2><ul><li><strong>설명:</strong> 특정 사용자를 지정해 컨테이너에서 명령을 실행합니다.</li><li><strong>장점:</strong> 다양한 사용자 환경을 테스트할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u &lt;user&gt; &lt;container_name&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="10-docker-run-rm"><a class="markdownIt-Anchor" href="#10-docker-run-rm"></a> 10. <code>docker run --rm</code></h2><ul><li><strong>설명:</strong> 컨테이너 종료 후 자동으로 삭제합니다.</li><li><strong>장점:</strong> 임시 작업 후 불필요한 컨테이너를 자동으로 정리합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="11-docker-compose-config"><a class="markdownIt-Anchor" href="#11-docker-compose-config"></a> 11. <code>docker-compose config</code></h2><ul><li><strong>설명:</strong> <code>docker-compose.yml</code> 파일을 검증하고 구성을 표시합니다.</li><li><strong>장점:</strong> 구성 파일의 구문 오류를 사전에 감지할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose config</span><br></pre></td></tr></table></figure><h2 id="12-docker-rm-v"><a class="markdownIt-Anchor" href="#12-docker-rm-v"></a> 12. <code>docker rm -v</code></h2><ul><li><strong>설명:</strong> 컨테이너와 관련된 익명의 볼륨을 함께 삭제합니다.</li><li><strong>장점:</strong> 고아 볼륨을 방지해 디스크 공간을 효율적으로 사용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h2 id="13-docker-export-docker-import"><a class="markdownIt-Anchor" href="#13-docker-export-docker-import"></a> 13. <code>docker export / docker import</code></h2><ul><li><strong>설명:</strong> 컨테이너 파일 시스템을 tar 파일로 내보내거나 새 이미지로 가져옵니다.</li><li><strong>장점:</strong> 특정 상태를 다른 환경으로 쉽게 전환할 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> &lt;container_name&gt; &gt; container.tar</span><br><span class="line">docker import container.tar &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="14-docker-history"><a class="markdownIt-Anchor" href="#14-docker-history"></a> 14. <code>docker history</code></h2><ul><li><strong>설명:</strong> 이미지의 각 레이어 변경 이력을 보여줍니다.</li><li><strong>장점:</strong> 큰 이미지를 디버깅하거나 최적화할 때 유용합니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="15-docker-logs-since"><a class="markdownIt-Anchor" href="#15-docker-logs-since"></a> 15. <code>docker logs --since</code></h2><ul><li><strong>설명:</strong> 특정 시간 이후의 로그를 검색합니다.</li><li><strong>장점:</strong> 최근 업데이트 이후의 문제를 빠르게 찾을 수 있습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since <span class="string">"10m"</span> &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p>내용이 많아, 다음 글에서 추가로 설명드리겠습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/25/devops-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법</title>
      <link>http://hgko1207.github.io/2024/11/21/spring-8/</link>
      <guid>http://hgko1207.github.io/2024/11/21/spring-8/</guid>
      <pubDate>Thu, 21 Nov 2024 03:12:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>오늘은 Spring Boot에서 API 응답을 깔끔하고 일관되며 사용하기 쉽게 구조화하는 가장 좋은 방법에 대해 이야기해보려고 합니다. 이 글을 끝까지 읽으면, 당신의 API가 더 깔끔하고 일관성 있으며, 사용자 친화적으로 바뀌는 모습을 볼 수 있을 것입니다.</p><h2 id="api-응답-구조가-왜-중요할까"><a class="markdownIt-Anchor" href="#api-응답-구조가-왜-중요할까"></a> API 응답 구조가 왜 중요할까?</h2><p>먼저, 잘 구조화된 API 응답이 왜 중요한지 살펴봅시다. 일관된 응답 구조는 다음과 같은 장점을 제공합니다:</p><ul><li><strong>클라이언트 측 에러 처리 개선:</strong> 프론트엔드 팀에서 크게 감사할 것입니다.</li><li><strong>가독성과 유지보수성 향상:</strong> 미래의 당신이나 팀이 명확함에 감동할 것입니다.</li><li><strong>디버깅과 로깅 간소화:</strong> 문제를 빠르고 효율적으로 파악할 수 있습니다.</li></ul><h2 id="좋은-api-응답의-조건"><a class="markdownIt-Anchor" href="#좋은-api-응답의-조건"></a> 좋은 API 응답의 조건</h2><p>잘 구조화된 API 응답은 다음과 같은 특징을 가져야 합니다:</p><ul><li><strong>일관성:</strong> 다양한 엔드포인트에서 동일한 형식 유지</li><li><strong>정보 제공:</strong> 관련 데이터, 메시지, 상태 코드 및 에러 코드를 포함</li><li><strong>단순함:</strong> 쉽게 파싱하고 이해할 수 있는 형식</li></ul><h2 id="이상적인-응답-구조-만들기"><a class="markdownIt-Anchor" href="#이상적인-응답-구조-만들기"></a> 이상적인 응답 구조 만들기</h2><h3 id="1-표준-응답-형식-정의"><a class="markdownIt-Anchor" href="#1-표준-응답-형식-정의"></a> 1. 표준 응답 형식 정의</h3><p>모든 API가 따를 표준 응답 형식을 먼저 정의합니다. 다음은 간단하면서도 효과적인 형식입니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"요청이 성공적으로 처리되었습니다."</span>,</span><br><span class="line">  "data": &#123; ... &#125;,</span><br><span class="line">  "errors": null,</span><br><span class="line">  "errorCode": 0,</span><br><span class="line">  "timestamp": 1633017600000,</span><br><span class="line">  "path": "/api/example"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 필드의 역할</p><ul><li><code>success</code>: (<code>boolean</code>) 요청이 성공했는지 여부를 나타냅니다.</li><li><code>message</code>: (<code>String</code>) 요청 처리 결과에 대한 사람이 읽을 수 있는 메시지를 제공합니다.</li><li><code>data</code>: (<code>T</code>) 클라이언트가 요청한 실제 데이터를 포함합니다.</li><li><code>errors</code>: (<code>List&lt;String&gt;</code>) 요청이 실패한 경우 발생한 에러 메시지 목록입니다.</li><li><code>errorCode</code>: (<code>int</code>) 비즈니스 로직 관련 에러 유형을 나타내는 코드입니다.</li><li><code>timestamp</code>: (<code>long</code>) 응답이 생성된 시간을 나타냅니다.</li><li><code>path</code>: (<code>String</code>) 호출된 API 엔드포인트를 나타냅니다.</li></ul><h3 id="2-응답-유틸리티-메서드-생성"><a class="markdownIt-Anchor" href="#2-응답-유틸리티-메서드-생성"></a> 2. 응답 유틸리티 메서드 생성</h3><p>코드 중복을 피하기 위해 응답을 생성하는 유틸리티 메서드를 만들어봅니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String message, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(data);</span><br><span class="line">        response.setErrors(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrorCode(<span class="number">0</span>);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(List&lt;String&gt; errors, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        ApiResponse&lt;T&gt; response = <span class="keyword">new</span> ApiResponse&lt;&gt;();</span><br><span class="line">        response.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        response.setMessage(message);</span><br><span class="line">        response.setData(<span class="keyword">null</span>);</span><br><span class="line">        response.setErrors(errors);</span><br><span class="line">        response.setErrorCode(errorCode);</span><br><span class="line">        response.setTimestamp(System.currentTimeMillis());</span><br><span class="line">        response.setPath(path);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse&lt;T&gt; <span class="title">error</span><span class="params">(String error, String message, <span class="keyword">int</span> errorCode, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error(Arrays.asList(error), message, errorCode, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-전역-예외-처리-구현"><a class="markdownIt-Anchor" href="#3-전역-예외-처리-구현"></a> 3. 전역 예외 처리 구현</h3><p>전역적으로 예외를 처리하면 처리되지 않은 에러도 표준 응답 형식으로 반환할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = Arrays.asList(ex.getMessage());</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(errors, <span class="string">"An error occurred"</span>, <span class="number">1000</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ResourceNotFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleResourceNotFoundException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ResourceNotFoundException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getMessage(), <span class="string">"Resource not found"</span>, <span class="number">1001</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ValidationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">Void</span>&gt;&gt; <span class="title">handleValidationException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ValidationException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        ApiResponse&lt;Void&gt; response = ResponseUtil.error(ex.getErrors(), <span class="string">"Validation failed"</span>, <span class="number">1002</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-컨트롤러에서-응답-형식-사용"><a class="markdownIt-Anchor" href="#4-컨트롤러에서-응답-형식-사용"></a> 4. 컨트롤러에서 응답 형식 사용</h3><p>표준화된 응답 형식을 컨트롤러에서도 활용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/products"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; getProductById(<span class="meta">@PathVariable</span> Long id, HttpServletRequest request) &#123;</span><br><span class="line">        Product product = productService.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (product == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ResourceNotFoundException(<span class="string">"Product not found with id "</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(product, <span class="string">"Product fetched successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ApiResponse&lt;Product&gt;&gt; createProduct(<span class="meta">@RequestBody</span> Product product, HttpServletRequest request) &#123;</span><br><span class="line">        Product createdProduct = productService.save(product);</span><br><span class="line">        ApiResponse&lt;Product&gt; response = ResponseUtil.success(createdProduct, <span class="string">"Product created successfully"</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="에러-코드의-예시"><a class="markdownIt-Anchor" href="#에러-코드의-예시"></a> 에러 코드의 예시</h2><p>아래는 전자상거래 애플리케이션에서 사용할 수 있는 에러 코드의 예입니다.</p><table><thead><tr><th>에러 코드</th><th>설명</th></tr></thead><tbody><tr><td>2000</td><td>재고 없음</td></tr><tr><td>2001</td><td>결제 수단 거부</td></tr><tr><td>2002</td><td>유효하지 않은 쿠폰 코드</td></tr><tr><td>2003</td><td>주문 취소 기간 초과</td></tr><tr><td>2004</td><td>계정 일시 정지</td></tr><tr><td>2005</td><td>동일 상품에 대한 중복 주문</td></tr></tbody></table><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>Spring Boot에서 API 응답을 구조화하는 가장 좋은 방법을 알아보았습니다. 위 단계를 구현하면 API가 더 깔끔하고 유지보수가 쉬워질 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/21/spring-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>시니어 개발자들이 절대 놓치지 않는 10가지 코딩 습관</title>
      <link>http://hgko1207.github.io/2024/11/19/info-31/</link>
      <guid>http://hgko1207.github.io/2024/11/19/info-31/</guid>
      <pubDate>Tue, 19 Nov 2024 05:46:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>시니어 개발자들이 작성하는 코드는 단순히 작동할 뿐 아니라 오랜 시간 동안 유지보수가 가능합니다. 그 비결은 경험을 통해 터득한 코딩 습관에 있습니다. 아래에서 시니어 개발자들이 실천하는 10가지 코딩 습관과 그들이 코드를 깔끔하고 안정적이며 다루기 쉽게 유지하는 방법을 살펴봅시다.</p><h2 id="1-코드를-미래의-나를-위해-작성하라"><a class="markdownIt-Anchor" href="#1-코드를-미래의-나를-위해-작성하라"></a> 1. 코드를 미래의 나를 위해 작성하라</h2><p>새벽 3시에 디버깅해야 하는 상황을 상상해 보세요. x, y, temp 같은 이름을 사용하는 변수와 복잡하게 중첩된 함수들이 난잡하게 얽혀 있다면 고통스럽겠죠. 코드를 작성할 때는 미래의 자신이 코드를 리뷰한다고 생각하고 작성하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = x * y;</span><br><span class="line">  <span class="keyword">return</span> temp + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalPrice</span>(<span class="params">itemPrice, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalCost = itemPrice * quantity;</span><br><span class="line">  <span class="keyword">return</span> totalCost + <span class="number">5</span>; <span class="comment">// 배송비 포함</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>좋은 코드에서는 <code>itemPrice</code>, <code>quantity</code>, <code>totalCost</code> 같은 이름이 함수의 목적을 즉시 알 수 있게 해줍니다. 코드를 다시 살펴보지 않아도 이해할 수 있죠.</p><p>코드는 유지보수를 염두에 두고 작성해야 합니다. 구조, 의미 있는 이름, 논리적 흐름에 신경 써서 단순함을 추구하세요.</p><h2 id="2-이름-짓기는-중요하다"><a class="markdownIt-Anchor" href="#2-이름-짓기는-중요하다"></a> 2. 이름 짓기는 중요하다</h2><p>시니어 개발자는 변수, 함수, 클래스의 이름을 짓는 일이 중요하다는 것을 압니다. 모호한 이름은 혼란을 야기합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = fetchData();</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = fetchUserData();</span><br></pre></td></tr></table></figure><p>좋은 이름은 코드를 읽는 사람이 추가적인 맥락을 찾을 필요가 없게 만듭니다.</p><h2 id="3-중복을-피하라dry-그러나-과유불급은-피하라"><a class="markdownIt-Anchor" href="#3-중복을-피하라dry-그러나-과유불급은-피하라"></a> 3. 중복을 피하라(DRY), 그러나 과유불급은 피하라</h2><p>코드 중복은 시간 낭비를 초래합니다. DRY(Don’t Repeat Yourself) 원칙을 따르되, 지나친 추상화는 피하세요.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tax = price * <span class="number">0.13</span>;</span><br><span class="line">  <span class="keyword">return</span> price + tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TAX_RATE = <span class="number">0.13</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * TAX_RATE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalWithTax</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price + calculateTax(price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-무엇을-설명하는-대신-왜를-설명하라"><a class="markdownIt-Anchor" href="#4-무엇을-설명하는-대신-왜를-설명하라"></a> 4. '무엇’을 설명하는 대신 '왜’를 설명하라</h2><p>불필요한 주석은 코드 읽기를 방해합니다. 대신 복잡한 알고리즘의 이유나 가정 같은 맥락을 설명하세요.</p><p><strong>좋은 주석</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대규모 배열의 빠른 조회를 위해 이진 탐색 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">arr, target</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="5-단일-책임-원칙을-지켜라"><a class="markdownIt-Anchor" href="#5-단일-책임-원칙을-지켜라"></a> 5. 단일 책임 원칙을 지켜라</h2><p>함수는 하나의 작업만 수행해야 합니다. 이 원칙을 따르면 테스트가 쉬워지고, 코드가 더 읽기 쉽고 모듈화됩니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndProcessAndSaveUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUserData</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveUserData</span>(<span class="params">data</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"><a class="markdownIt-Anchor" href="#6-버전-관리는-필수다-의미-있는-커밋-메시지와-함께"></a> 6. 버전 관리는 필수다 (의미 있는 커밋 메시지와 함께)</h2><p>시니어 개발자는 의미 없는 커밋 메시지를 작성하지 않습니다.</p><p><strong>나쁜 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"버그 수정"</span></span><br></pre></td></tr></table></figure><p><strong>좋은 커밋 메시지</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"검증이 누락되어 사용자 세부 정보가 저장되지 않는 문제 해결"</span></span><br></pre></td></tr></table></figure><h2 id="7-에러를-우아하게-처리하라"><a class="markdownIt-Anchor" href="#7-에러를-우아하게-처리하라"></a> 7. 에러를 우아하게 처리하라</h2><p>애플리케이션이 충돌하며 “뭔가 잘못되었습니다” 같은 에러 메시지를 띄운다면, 이는 사용자 경험을 망칩니다. 의미 있는 에러 메시지와 로그를 제공하세요.</p><p><strong>나쁜 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 에러 처리</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = fetchData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  logError(error);</span><br><span class="line">  showErrorNotification(<span class="string">'문제가 발생했습니다. 나중에 다시 시도해주세요.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-테스트를-작성하라"><a class="markdownIt-Anchor" href="#8-테스트를-작성하라"></a> 8. 테스트를 작성하라</h2><p>테스트는 코드가 제대로 작동하는지 확인하는 중요한 도구입니다.</p><p><strong>테스트 없는 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> price = calculateTotal(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong>테스트 작성</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'calculateTotal'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should return the correct total'</span>, () =&gt; &#123;</span><br><span class="line">    expect(calculateTotal(<span class="number">100</span>)).toBe(<span class="number">115</span>); <span class="comment">// 15% 세금 포함</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-종속성-관리를-신중히-하라"><a class="markdownIt-Anchor" href="#9-종속성-관리를-신중히-하라"></a> 9. 종속성 관리를 신중히 하라</h2><p>불필요한 라이브러리 의존성은 프로젝트를 복잡하게 만들고, 보안 문제를 초래하며, 유지보수를 어렵게 합니다.</p><p><strong>나쁜 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure><p><strong>좋은 관행</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash.debounce</span><br></pre></td></tr></table></figure><h2 id="10-정기적으로-과감하게-리팩터링하라"><a class="markdownIt-Anchor" href="#10-정기적으로-과감하게-리팩터링하라"></a> 10. 정기적으로 과감하게 리팩터링하라</h2><p>코드는 정원을 가꾸는 것과 같습니다. 정기적으로 구조를 개선하고 읽기 쉽게 최적화해야 합니다.</p><p><strong>나쁜 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; orderList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (orderList[i].status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// process the order</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>좋은 코드</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterPendingOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> orderList.filter(<span class="function">(<span class="params">order</span>) =&gt;</span> order.status === <span class="string">'pending'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOrders</span>(<span class="params">orderList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pendingOrders = filterPendingOrders(orderList);</span><br><span class="line">  pendingOrders.forEach(<span class="function">(<span class="params">order</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// process the order</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>위 10가지 실천법은 시니어 개발자의 작업 방식을 반영한 기본적인 습관들입니다. 이를 점진적으로 적용하면 더 깨끗하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 당신의 코드가 미래의 자신과 동료 개발자들에게 편리함을 제공하게 될 것입니다. 😉</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/info-31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>필수로 알아야할 13가지 SQL 문법</title>
      <link>http://hgko1207.github.io/2024/11/19/sql-1/</link>
      <guid>http://hgko1207.github.io/2024/11/19/sql-1/</guid>
      <pubDate>Tue, 19 Nov 2024 05:15:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Structured Query Language&lt;/strong&gt;(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Structured Query Language</strong>(SQL)은 관계형 데이터베이스를 관리하고 조작하기 위해 설계된 프로그래밍 언어입니다. 이는 데이터 분석가와 데이터 과학자가 대규모 데이터셋에서 통찰을 추출하기 위해 널리 사용됩니다.</p><p>SQL은 데이터를 필터링, 정렬, 그룹화, 집계하는 등 다양한 데이터 조작 작업을 수행할 수 있는 강력한 도구입니다. 이 글에서는 데이터 과학 작업의 90%를 수행할 수 있는 13가지 필수 SQL 문법에 대해 다룹니다. 이러한 문법은 이해하기 쉽고 구현하기 쉬우며, SQL 작업의 기초를 다지는 데에 도움을 줍니다.</p><h2 id="1-select"><a class="markdownIt-Anchor" href="#1-select"></a> 1. SELECT</h2><p><code>SELECT</code> 문은 데이터베이스에서 하나 이상의 테이블에서 데이터를 조회하는 데 사용됩니다. <code>WHERE</code>, <code>ORDER BY</code>, <code>GROUP BY</code>와 같은 다양한 함수와 함께 사용하여 데이터를 필터링, 정렬, 그룹화하는 데 익숙해져야 합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>column1</code>, <code>column2</code>, <code>column3</code>는 조회하려는 열의 이름이며, <code>table_name</code>은 데이터를 포함한 테이블의 이름입니다. <code>WHERE</code> 절은 선택 사항이지만, 쿼리가 데이터를 조회하기 위해 충족해야 하는 조건을 지정하는 데 사용됩니다.</p><h3 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h3><p>고객 테이블에서 18세 이상인 모든 고객을 조회</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> age &gt;= <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h2 id="2-join"><a class="markdownIt-Anchor" href="#2-join"></a> 2. JOIN</h2><p><code>JOIN</code> 문은 데이터베이스의 두 개 이상의 테이블에서 데이터를 결합할 때 사용됩니다. 필요한 경우 적합한 JOIN 유형(예: <code>INNER</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>FULL OUTER</code>)을 지정해야 합니다.</p><h3 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> INNER JOIN</h3><p><code>INNER JOIN</code>은 두 테이블의 열에서 일치하는 행만 반환합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orders.order_id, customers.customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id = customers.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블과 <code>customers</code> 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 두 테이블의 <code>customer_id</code> 열에서 일치하는 데이터가 있는 경우에만 <code>order_id</code>와 <code>customer_name</code> 열이 포함됩니다.</p><h3 id="left-join"><a class="markdownIt-Anchor" href="#left-join"></a> LEFT JOIN</h3><p><code>LEFT JOIN</code>은 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 행을 반환합니다. 오른쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되고, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="right-join"><a class="markdownIt-Anchor" href="#right-join"></a> RIGHT JOIN</h3><p><code>RIGHT JOIN</code>은 오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 행을 반환합니다. 왼쪽 테이블에 일치하는 데이터가 없으면 결과에 <code>NULL</code> 값이 포함됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고, <code>customers</code> 테이블은 왼쪽 테이블입니다. 두 테이블은 <code>customer_id</code> 열을 사용하여 조인됩니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되고, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><h3 id="outer-join"><a class="markdownIt-Anchor" href="#outer-join"></a> OUTER JOIN</h3><p><code>OUTER JOIN</code>은 두 테이블 중 하나 또는 두 테이블의 모든 행을 반환하며, 일치하지 않는 행도 포함합니다. <code>LEFT OUTER JOIN</code>과 <code>RIGHT OUTER JOIN</code> 두 가지 유형이 있습니다.</p><h4 id="left-outer-join-예제"><a class="markdownIt-Anchor" href="#left-outer-join-예제"></a> LEFT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>customers</code> 테이블은 왼쪽 테이블이고 <code>orders</code> 테이블은 오른쪽 테이블입니다. 결과 테이블에는 <code>customers</code> 테이블의 모든 행이 포함되며, <code>orders</code> 테이블에 일치하는 데이터가 없는 경우 <code>order_id</code> 열은 <code>NULL</code> 값을 가집니다.</p><h4 id="right-outer-join-예제"><a class="markdownIt-Anchor" href="#right-outer-join-예제"></a> RIGHT OUTER JOIN 예제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.customer_name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>orders</code> 테이블은 오른쪽 테이블이고 <code>customers</code> 테이블은 왼쪽 테이블입니다. 결과 테이블에는 <code>orders</code> 테이블의 모든 행이 포함되며, <code>customers</code> 테이블에 일치하는 데이터가 없는 경우 <code>customer_name</code> 열은 <code>NULL</code> 값을 가집니다.</p><p><strong>참고:</strong> 일부 데이터베이스는 <code>RIGHT OUTER JOIN</code>을 지원하지 않을 수 있습니다. 이 경우, <code>LEFT OUTER JOIN</code>을 사용하고 테이블의 순서를 바꾸어 동일한 결과를 얻을 수 있습니다.</p><h2 id="3-where"><a class="markdownIt-Anchor" href="#3-where"></a> 3. WHERE</h2><p><code>WHERE</code> 문은 지정된 조건에 따라 데이터를 필터링하는 데 사용됩니다. 특정 기준을 충족하는 데이터만 조회하려면 <code>WHERE</code> 문을 능숙하게 사용하는 것이 중요합니다.</p><p>아래는 테이블에서 데이터를 필터링하기 위해 <code>WHERE</code> 문을 사용하는 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, department, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department = <span class="string">'Sales'</span> <span class="keyword">AND</span> salary &gt; <span class="number">50000</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “Sales” 부서에서 근무하며 급여가 $50,000 이상인 모든 직원의 이름, 부서, 급여를 결과로 반환합니다.</p><h2 id="4-group-by"><a class="markdownIt-Anchor" href="#4-group-by"></a> 4. GROUP BY</h2><p><code>GROUP BY</code> 문은 하나 이상의 열을 기준으로 데이터를 그룹화하며, <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>와 같은 집계 함수를 사용하여 그룹화된 데이터의 요약 정보를 계산할 수 있습니다. GROUP BY를 활용하여 카테고리별로 데이터를 분석하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="keyword">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 부서와 각 부서의 평균 급여를 반환합니다. 각 부서의 평균 급여는 해당 부서 직원들의 모든 급여 합계를 직원 수로 나눈 값으로 계산됩니다. <code>GROUP BY</code> 절은 부서별로 직원을 그룹화하는 데 사용되며, <code>AVG</code> 함수는 각 부서의 평균 급여를 계산하는 데 사용됩니다.</p><table><thead><tr><th>Department</th><th>Avg Salary</th></tr></thead><tbody><tr><td>Sales</td><td>65,000</td></tr><tr><td>Marketing</td><td>55,000</td></tr><tr><td>Engineering</td><td>80,000</td></tr></tbody></table><p>위 예제에서, <strong>Sales</strong> 부서는 평균 급여가 $65,000, <strong>Marketing</strong> 부서는 $55,000, <strong>Engineering</strong> 부서는 $80,000임을 확인할 수 있습니다.</p><h2 id="5-having"><a class="markdownIt-Anchor" href="#5-having"></a> 5. HAVING</h2><p><code>HAVING</code> 문은 <code>GROUP BY</code>로 그룹화된 데이터를 특정 조건에 따라 필터링하는 데 사용됩니다. 그룹화된 데이터를 추가로 필터링하는 방법을 숙달하는 것이 중요합니다.</p><p>아래는 <code>HAVING</code> 절을 사용하는 SQL 예제입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantity) &gt;= <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 모든 고객과 그들이 주문한 총 제품 수량을 반환하지만, 총 수량이 50단위 이상인 고객만 결과에 포함됩니다. <code>GROUP BY</code> 절은 고객별로 주문을 그룹화하는 데 사용되고, <code>SUM</code> 함수는 각 고객이 주문한 제품의 총 수량을 계산하는 데 사용됩니다. 마지막으로 <code>HAVING</code> 절은 결과를 필터링하여 조건을 만족하는 데이터만 반환합니다.</p><h2 id="6-윈도우-함수-window-function"><a class="markdownIt-Anchor" href="#6-윈도우-함수-window-function"></a> 6. 윈도우 함수 (Window Function)</h2><p>SQL에서 윈도우 함수는 현재 행과 관련된 행 집합에 대해 계산을 수행하는 데 사용됩니다. 이러한 함수는 지정된 조건이나 파티션에 기반한 테이블의 일부 행(윈도우)에 적용됩니다. 아래는 SQL에서 윈도우 함수를 사용하는 몇 가지 예제입니다.</p><h3 id="1-row_number"><a class="markdownIt-Anchor" href="#1-row_number"></a> 1. <code>ROW_NUMBER()</code></h3><p><code>ROW_NUMBER()</code> 함수는 각 파티션 내에서 각 행에 고유한 순차 번호를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>row_num</code>이라는 추가 열을 포함하며, 이 열은 <code>column1</code>의 순서에 따라 각 행에 순차적으로 번호를 부여합니다.</p><h3 id="2-sum"><a class="markdownIt-Anchor" href="#2-sum"></a> 2. <code>SUM()</code></h3><p><code>SUM()</code> 함수는 각 파티션 내에서 특정 열의 합계를 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_sum</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_sum</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 합계를 계산합니다.</p><h3 id="3-rank"><a class="markdownIt-Anchor" href="#3-rank"></a> 3. <code>RANK()</code></h3><p><code>RANK()</code> 함수는 특정 열의 값에 따라 각 파티션 내에서 각 행에 순위를 할당합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column3 <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>rank_num</code>이라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column3</code> 값을 기준으로 내림차순 정렬된 순위를 나타냅니다.</p><h3 id="4-avg"><a class="markdownIt-Anchor" href="#4-avg"></a> 4. <code>AVG()</code></h3><p><code>AVG()</code> 함수는 각 파티션 내에서 특정 열의 평균을 계산합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., <span class="keyword">AVG</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1) <span class="keyword">AS</span> column3_avg</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>이 쿼리는 결과 집합에 <code>column3_avg</code>라는 추가 열을 포함하며, 이 열은 각 파티션에서 <code>column1</code> 값에 따라 <code>column3</code>의 평균을 계산합니다.</p><h3 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h3><p>윈도우 함수의 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다. 사용하려는 DBMS의 문서를 참고하여 정확한 문법을 확인하는 것이 좋습니다.</p><h2 id="7-union"><a class="markdownIt-Anchor" href="#7-union"></a> 7. UNION</h2><p>SQL에서 <code>UNION</code> 연산자는 두 개 이상의 <code>SELECT</code> 문의 결과를 하나의 결과 집합으로 결합하는 데 사용됩니다. 각 <code>SELECT</code> 문은 동일한 열 개수와 호환 가능한 데이터 유형을 가져야 합니다. 결과 집합에서는 중복된 행이 자동으로 제거됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, city</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'New York'</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 뉴욕에 거주하는 모든 사람(고객과 직원 포함)의 목록을 반환합니다. 첫 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 고객을 조회하며, 두 번째 <code>SELECT</code> 문은 뉴욕에 거주하는 직원을 조회합니다. <code>UNION</code> 연산자는 이 두 <code>SELECT</code> 문의 결과를 결합하고 중복된 행을 제거합니다.</p><h2 id="8-create"><a class="markdownIt-Anchor" href="#8-create"></a> 8. CREATE</h2><p><code>CREATE</code> 문은 새로운 데이터베이스 테이블, 뷰 또는 기타 데이터베이스 객체를 생성하는 데 사용됩니다. 새로운 테이블, 뷰, 기타 객체를 생성하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 쿼리는 &quot;customers&quot;라는 이름의 새 테이블을 생성하며, 네 개의 열(“id”, “name”, “email”, “phone”)을 포함합니다.</p><ul><li><strong>id:</strong> 정수형으로 설정되며, 테이블의 기본 키로 지정됩니다.</li><li><strong>name:</strong> 최대 50자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>email:</strong> 최대 100자까지 저장할 수 있는 문자열로 설정됩니다.</li><li><strong>phone:</strong> 최대 20자까지 저장할 수 있는 문자열로 설정됩니다.</li></ul><h2 id="9-insert"><a class="markdownIt-Anchor" href="#9-insert"></a> 9. INSERT</h2><p><code>INSERT</code> 문은 데이터베이스 테이블에 새 데이터를 삽입하는 데 사용됩니다. 테이블에 데이터를 추가하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, <span class="keyword">name</span>, major, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1234</span>, <span class="string">'John Doe'</span>, <span class="string">'Computer Science'</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음 값으로 새 행을 “students” 테이블에 삽입합니다:</p><ul><li><strong>id:</strong> 1234</li><li><strong>name:</strong> John Doe</li><li><strong>major:</strong> Computer Science</li><li><strong>gpa:</strong> 3.5</li></ul><p><code>INSERT</code> 문은 데이터를 삽입하려는 테이블의 이름을 지정하고, 삽입할 열 목록을 작성한 뒤, <code>VALUES</code> 키워드를 사용해 해당 열에 삽입할 값을 순서대로 지정합니다.</p><h2 id="10-update"><a class="markdownIt-Anchor" href="#10-update"></a> 10. UPDATE</h2><p><code>UPDATE</code> 문은 데이터베이스 테이블의 기존 데이터를 수정하는 데 사용됩니다. 테이블의 하나 이상의 열 값을 업데이트하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> major = <span class="string">'Mathematics'</span>, gpa = <span class="number">3.7</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 다음과 같은 작업을 수행합니다:</p><ul><li><strong>major</strong> 열의 값을 'Mathematics’로 업데이트</li><li><strong>gpa</strong> 열의 값을 3.7로 업데이트</li><li><strong>WHERE</strong> 절을 사용하여 ID가 1234인 행만 업데이트</li></ul><p><code>UPDATE</code> 문은 업데이트하려는 테이블의 이름을 지정한 후, <code>SET</code> 키워드를 사용하여 업데이트할 열과 새 값을 나열합니다. 특정 행만 업데이트하려면 <code>WHERE</code> 절을 사용하여 조건을 지정해야 합니다.</p><h2 id="11-delete"><a class="markdownIt-Anchor" href="#11-delete"></a> 11. DELETE</h2><p><code>DELETE</code> 문은 데이터베이스 테이블에서 하나 이상의 행을 삭제하는 데 사용됩니다. 테이블에서 데이터를 제거하는 방법을 숙달하는 것이 중요합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 “students” 테이블에서 ID가 1234인 행을 제거합니다.</p><ul><li><code>DELETE FROM</code>은 데이터를 삭제하려는 테이블의 이름을 지정합니다.</li><li><code>WHERE</code> 절은 삭제할 행을 지정하는 조건을 나타냅니다. 이 경우, ID가 1234인 행을 삭제하도록 설정했습니다.</li></ul><h2 id="12-drop"><a class="markdownIt-Anchor" href="#12-drop"></a> 12. DROP</h2><p><code>DROP</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체를 삭제하는 데 사용됩니다. 불필요한 테이블이나 기타 객체를 데이터베이스에서 제거하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-drop-table"><a class="markdownIt-Anchor" href="#1-drop-table"></a> 1. DROP TABLE</h3><p>기존 테이블과 해당 테이블의 모든 데이터 및 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="2-drop-index"><a class="markdownIt-Anchor" href="#2-drop-index"></a> 2. DROP INDEX</h3><p>테이블에서 기존 인덱스를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="3-drop-view"><a class="markdownIt-Anchor" href="#3-drop-view"></a> 3. DROP VIEW</h3><p>기존의 뷰(View)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure><h3 id="4-drop-procedure"><a class="markdownIt-Anchor" href="#4-drop-procedure"></a> 4. DROP PROCEDURE</h3><p>기존의 저장 프로시저(Stored Procedure)를 삭제합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br></pre></td></tr></table></figure><h3 id="주의-사항"><a class="markdownIt-Anchor" href="#주의-사항"></a> 주의 사항</h3><ul><li><code>DROP</code> 문은 지정된 객체와 관련된 모든 데이터 및 인덱스를 <strong>영구적으로 삭제</strong>합니다.</li><li>삭제된 데이터나 객체는 복구할 수 없으므로, 삭제 작업을 실행하기 전에 데이터를 반드시 백업해야 합니다.</li><li>사용하는 데이터베이스 관리 시스템(DBMS)에 따라 <code>DROP</code> 문의 정확한 문법이 다를 수 있으므로, 사용하는 DBMS의 문서를 참조하는 것이 좋습니다.</li></ul><h2 id="13-alter"><a class="markdownIt-Anchor" href="#13-alter"></a> 13. ALTER</h2><p><code>ALTER</code> 문은 데이터베이스 테이블이나 기타 데이터베이스 객체의 구조를 수정하는 데 사용됩니다. 열 추가 및 삭제, 데이터 유형 변경, 제약 조건 설정 등 다양한 작업을 수행하는 방법을 숙달하는 것이 중요합니다.</p><h3 id="1-alter-table"><a class="markdownIt-Anchor" href="#1-alter-table"></a> 1. ALTER TABLE</h3><p>기존 테이블의 구조를 수정합니다. 열을 추가하거나 삭제하고, 데이터 유형을 변경하거나 제약 조건을 설정하는 데 사용됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">MODIFY</span> column_name data_type [<span class="keyword">constraint</span>],</span><br><span class="line"><span class="keyword">DROP</span> column_name,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name constraint_definition,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></table></figure><p>테이블에 새로운 열 추가</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">ADD</span> phone_number <span class="built_in">VARCHAR</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>기존 열 삭제</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> phone_number;</span><br></pre></td></tr></table></figure><h3 id="2-alter-index"><a class="markdownIt-Anchor" href="#2-alter-index"></a> 2. ALTER INDEX</h3><p>기존 인덱스의 구조를 수정합니다. 열을 추가하거나 제거하고, 인덱스 유형을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ADD</span> column_name,</span><br><span class="line"><span class="keyword">DROP</span> column_name;</span><br></pre></td></tr></table></figure><h3 id="3-alter-view"><a class="markdownIt-Anchor" href="#3-alter-view"></a> 3. ALTER VIEW</h3><p>기존 뷰(View)의 정의를 수정합니다. 생성 시 사용된 <code>SELECT</code> 문을 변경할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">AS</span> select_statement;</span><br></pre></td></tr></table></figure><h3 id="참고-2"><a class="markdownIt-Anchor" href="#참고-2"></a> 참고</h3><ul><li><code>ALTER</code> 문의 정확한 문법은 사용하는 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다.</li><li>구조를 수정하는 작업은 데이터 무결성에 영향을 미칠 수 있으므로, 변경 전에 데이터베이스 구조와 데이터에 미치는 영향을 철저히 검토해야 합니다.</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/19/sql-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 컴포넌트 작성, 전문가처럼!</title>
      <link>http://hgko1207.github.io/2024/11/12/react-19/</link>
      <guid>http://hgko1207.github.io/2024/11/12/react-19/</guid>
      <pubDate>Tue, 12 Nov 2024 06:08:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/react-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/react-19.png" alt="" /></p><p><strong>React</strong>에서 컴포넌트를 작성하는 것은 단순히 기능을 구현하는 것이 아니라, 잘 작동하면서도 우아하게 기능하는 컴포넌트를 만드는 예술입니다. 오늘은 React 컴포넌트를 전문가처럼 작성하는 방법을 알아보며, 가독성, 재사용성, 효율성에 중점을 두고 설명해드리겠습니다.</p><h2 id="1-기본-list-컴포넌트-만들기"><a class="markdownIt-Anchor" href="#1-기본-list-컴포넌트-만들기"></a> 1. 기본 List 컴포넌트 만들기</h2><p>먼저, 간단한 <code>List</code> 컴포넌트부터 시작해 보겠습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/List.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> List;</span><br></pre></td></tr></table></figure><p>이 컴포넌트는 배열 형태의 <code>data</code>를 받아 이를 목록 형태로 렌더링합니다.</p><h2 id="2-hoc로-컴포넌트-확장하기"><a class="markdownIt-Anchor" href="#2-hoc로-컴포넌트-확장하기"></a> 2. HOC로 컴포넌트 확장하기</h2><p>고차 컴포넌트(Higher-Order Components, HOC)는 컴포넌트의 구조를 변경하지 않고 기능을 확장할 수 있는 강력한 패턴입니다. HOC는 다른 컴포넌트를 감싸 추가적인 기능을 제공하도록 설계되었습니다.</p><p>예를 들어, <code>withLoading</code> HOC를 사용해 로딩 상태를 표시하는 방법은 다음과 같습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withLoading.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithLoading</span>(<span class="params">&#123; isLoading, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLoading;</span><br></pre></td></tr></table></figure><p>이 HOC는 <code>isLoading</code> prop을 확인하여, <code>isLoading</code>이 <code>true</code>일 때는 “Loading…” 메시지를, 그렇지 않을 때는 감싼 컴포넌트를 렌더링합니다. 이를 통해 데이터 로딩 중에도 사용자 경험을 자연스럽게 유지할 수 있습니다.</p><p>비슷하게, <code>withErrorHandling</code> HOC를 사용해 에러 상태를 관리할 수도 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hocs/withErrorHandling.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withErrorHandling</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithErrorHandling</span>(<span class="params">&#123; error, ...props &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withErrorHandling;</span><br></pre></td></tr></table></figure><p>에러가 발생하면 <code>withErrorHandling</code>은 에러 메시지를 표시하고, 그렇지 않으면 컴포넌트를 일반적으로 렌더링합니다. 이 HOC는 데이터 가져오기(fetch) 오류 또는 컴포넌트 수명 주기 내에서 발생하는 문제를 처리하는 데 유용합니다.</p><p>이제 <code>withLoading</code>과 <code>withErrorHandling</code>을 결합해 로딩과 에러 상태를 모두 처리할 수 있는 컴포넌트를 만들 수 있습니다. 이 접근법은 코드 재사용과 관심사 분리를 촉진하여, 컴포넌트의 유지 보수를 더 용이하게 하고 이해하기 쉽게 만듭니다.</p><h2 id="3-hooks로-데이터-가져오기"><a class="markdownIt-Anchor" href="#3-hooks로-데이터-가져오기"></a> 3. Hooks로 데이터 가져오기</h2><p>React의 hooks는 클래스 없이도 상태나 기타 React 기능을 사용할 수 있게 합니다. <code>useFetch</code>는 API에서 데이터를 가져오는 커스텀 훅입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hooks/useFetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useFetch = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setLoading(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">        <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Network response was not ok'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">        setData(json);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setError(error);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클린업 함수</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 필요 시 클린업 로직 작성</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useFetch;</span><br></pre></td></tr></table></figure><p>이 훅은 로딩 상태, 데이터 저장, 에러 처리를 담당하여, 컴포넌트에서 데이터를 쉽게 가져와 표시할 수 있도록 합니다.</p><h2 id="4-앱-구성하기"><a class="markdownIt-Anchor" href="#4-앱-구성하기"></a> 4. 앱 구성하기</h2><p>마지막으로, 모든 요소를 <code>App</code> 컴포넌트에 통합합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLoading <span class="keyword">from</span> <span class="string">'./hocs/withLoading'</span>;</span><br><span class="line"><span class="keyword">import</span> withErrorHandling <span class="keyword">from</span> <span class="string">'./hocs/withErrorHandling'</span>;</span><br><span class="line"><span class="keyword">import</span> useFetch <span class="keyword">from</span> <span class="string">'./hooks/useFetch'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./components/List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ListWithLoading = withLoading(List);</span><br><span class="line"><span class="keyword">const</span> ListWithErrorHandling = withErrorHandling(ListWithLoading);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, error &#125; = useFetch(<span class="string">'https://api.example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;List Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ListWithErrorHandling data=&#123;data&#125; isLoading=&#123;isLoading&#125; error=&#123;error&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>useFetch</code> 훅을 사용하여 데이터를 로드하고, <code>List</code> 컴포넌트에 전달합니다. 이 <code>List</code> 컴포넌트는 <code>withLoading</code>과 <code>withErrorHandling</code> HOC로 확장되어 로딩과 에러 상태를 처리합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>프로처럼 컴포넌트를 작성하는 것은 전체적인 그림을 보는 것에서 시작됩니다. 가독성, 유지보수성, 재사용성이 높은 컴포넌트를 만드는 것이 핵심입니다. HOC와 hooks 같은 패턴을 사용하면, 시간이 지나도 견고하고 효율적인 코드베이스를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/11/12/react-19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>주말에 만들 수 있는 5가지 AI 프로젝트 (Python 사용)</title>
      <link>http://hgko1207.github.io/2024/10/29/python-10/</link>
      <guid>http://hgko1207.github.io/2024/10/29/python-10/</guid>
      <pubDate>Tue, 29 Oct 2024 05:26:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>AI 기술을 향상시키는 최고의 방법은 프로젝트를 직접 구축해 보는 것입니다. 그러나 어떤 프로젝트를 시작해야 할지 결정하기 어려울 때도 있습니다. 이 글에서는 초급부터 고급까지 세 가지 수준에서 빠르게 구축할 수 있는 5가지 AI 프로젝트 아이디어를 공유합니다. 각 아이디어를 구현하는 데 필요한 단계와 Python 라이브러리를 설명해드리겠습니다.</p><p>프로젝트 아이디어를 생각할 때, 초보자들이 가장 많이 하는 실수는 &quot;<strong>이 새로운 기술을 어떻게 사용할 수 있을까?</strong>&quot;라는 질문에서 시작하는 것입니다. 물론, 새로운 도구를 배우는 방법으로는 괜찮지만, 더 나은 접근법이 있습니다.</p><p>좋은 프로젝트 아이디어는 &quot;<strong>내가 해결할 수 있는 문제가 무엇인가?</strong>&quot;라는 질문에서 시작됩니다. 문제 해결은 기술을 가치로 전환하는 방법이며, 잠재적 고용주에게도 설득력 있는 스토리가 됩니다.</p><p>다음 프로젝트들은 모두 이 문제 해결 접근법을 따릅니다. 아이디어를 그대로 구현하거나, 더 나아가 개인적으로 해결하고 싶은 문제에 적용할 수도 있습니다.</p><h2 id="1-이력서-최적화-초급">1) 이력서 최적화 (초급)</h2><p>구직 활동에서 시간이 많이 소요되는 작업 중 하나는 각 채용 공고에 맞게 이력서를 조정하는 것입니다. 과거에는 이러한 작업을 자동화하는 것이 고급 프로젝트에 속했지만, 오늘날의 LLM(Large Language Model) 덕분에 이제는 간단한 API 호출만으로도 해결할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>이력서를 Markdown 형식으로 작성합니다. (참고: ChatGPT를 통해 이 작업을 쉽게 할 수 있습니다).</li><li>Markdown 이력서와 채용 공고를 받아 새롭게 이력서를 작성하는 다양한 프롬프트 템플릿을 실험해봅니다.</li><li>OpenAI의 Python API를 사용해 GPT-4o-mini를 통해 이력서를 동적으로 수정합니다.</li><li><code>markdown</code> 및 <code>pdfkit</code> 라이브러리를 각각 사용하여 Markdown 파일을 HTML과 PDF로 변환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>markdown</code>, <code>pdfkit</code></p><p>ChatGPT를 통해 간단히 이 작업을 처리할 수 있지만, Python으로 구현하면 더 쉽게 대규모 처리를 할 수 있습니다. 아래는 Step 3의 시작 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = <span class="string">"your_sk"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 프롬프트 (md_resume 및 job_desciption이 정의되어 있다고 가정)</span></span><br><span class="line">prompt = <span class="string">f"""</span></span><br><span class="line"><span class="string">Markdown 형식의 이력서와 채용 공고가 있습니다. \</span></span><br><span class="line"><span class="string">이력서를 채용 요구 사항에 더 잘 맞게 조정해 주세요. \</span></span><br><span class="line"><span class="string">필요한 기술, 경험, 성과를 강조하여 이력서를 수정해 주세요. \</span></span><br><span class="line"><span class="string">이력서에는 여전히 나만의 독특한 자격과 강점이 반영되도록 하되, \</span></span><br><span class="line"><span class="string">채용 공고와 일치하는 기술과 경험이 강조되도록 해주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 내 이력서 (Markdown 형식):</span></span><br><span class="line"><span class="string"><span class="subst">&#123;md_resume&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 여기에 채용 공고:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;job_desciption&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이력서를 수정해 주세요:</span></span><br><span class="line"><span class="string">- 채용 공고의 키워드와 구문을 사용하세요.</span></span><br><span class="line"><span class="string">- 각 역할 아래에 관련 기술과 성과를 강조하세요.</span></span><br><span class="line"><span class="string">- 나의 경험이 요구되는 자격에 맞게 잘 나타나도록 수정해 주세요.</span></span><br><span class="line"><span class="string">- 명확성, 간결성, 그리고 전문성을 유지하세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">업데이트된 이력서를 Markdown 형식으로 반환해 주세요.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API 호출</span></span><br><span class="line">response = openai.chat.completions.create(</span><br><span class="line">    model=<span class="string">"gpt-4o-mini"</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"system"</span>, <span class="string">"content"</span>: <span class="string">"You are a helpful assistant."</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: prompt&#125;</span><br><span class="line">    ],</span><br><span class="line">    temperature = <span class="number">0.25</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 응답 추출</span></span><br><span class="line">resume = response.choices[<span class="number">0</span>].message.content</span><br></pre></td></tr></table></figure><p>참고: ChatGPT는 짧은 코드 스니펫(및 프롬프트)을 작성할 때 매우 유용합니다. Step 4에서 막히면 ChatGPT에 도움을 요청해 보세요!</p><h2 id="2-YouTube-강의-요약-도구-초급">2) YouTube 강의 요약 도구 (초급)</h2><p>기술 강연을 YouTube의 “<strong>나중에 보기</strong>” 목록에 추가해 두는 것을 좋아하지만, 나중에 보려다 보지 못할 때가 많습니다. 이러한 문제를 해결하기 위해 동영상을 대신 시청하고 주요 포인트로 구성된 요약을 생성해 주는 도구를 만들 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li>정규 표현식을 사용하여 YouTube 비디오 링크에서 비디오 ID를 추출합니다.</li><li><code>youtube-transcript-api</code>를 사용해 비디오 ID로 트랜스크립트를 추출합니다.</li><li>트랜스크립트를 효과적으로 요약하는 다양한 ChatGPT 프롬프트를 실험해 봅니다.</li><li>OpenAI의 Python API를 사용하여 이 과정을 자동화합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>openai</code>, <code>youtube-transcript-api</code></p><p>기술적으로, 이 프로젝트는 앞서 소개한 프로젝트와 유사합니다. 다만, 이 프로젝트에서는 비디오 트랜스크립트를 자동으로 추출하여 언어 모델(LLM)에 입력해야 한다는 점이 다릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> youtube_transcript_api <span class="keyword">import</span> YouTubeTranscriptApi</span><br><span class="line"></span><br><span class="line">youtube_url = <span class="string">"video link here"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 정규 표현식으로 비디오 ID 추출</span></span><br><span class="line">video_id_regex = <span class="string">r'(?:v=|\/)([0-9A-Za-z_-]&#123;11&#125;).*'</span></span><br><span class="line">match = re.search(video_id_regex, youtube_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    <span class="keyword">return</span> match.group(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 트랜스크립트 추출</span></span><br><span class="line">text_list = [transcript[i][<span class="string">'text'</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(transcript))]</span><br><span class="line">transcript_text = <span class="string">'\n'</span>.join(text_list)</span><br></pre></td></tr></table></figure><h2 id="3-PDF-자동-정리-도구-중급">3) PDF 자동 정리 도구 (중급)</h2><p>데스크탑에는 정리되지 않은 논문(PDF)들이 쌓여 있을 수 있습니다. 수동으로 이러한 논문을 검토하는 것은 시간이 많이 걸리기 때문에, AI를 활용해 보겠습니다.</p><p>데스크탑에 있는 각 PDF의 내용을 분석하고 주제별로 폴더를 만들어 자동으로 정리하는 도구를 구축할 수 있습니다. 텍스트 임베딩을 사용해 각 논문을 밀집 벡터 표현으로 변환한 뒤, 유사한 논문끼리 K-Means와 같은 전통적인 머신러닝 알고리즘으로 클러스터링할 수 있습니다.</p><p><strong>구현 방법:</strong></p><ul><li><code>PyMuPDF</code>를 사용하여 각 논문의 초록을 읽습니다.</li><li><code>sentence-transformers</code> 라이브러리를 사용하여 초록을 텍스트 임베딩으로 변환하고, 이를 Pandas 데이터프레임에 저장합니다.</li><li><code>sklearn</code>의 선호하는 클러스터링 알고리즘을 사용하여 임베딩을 유사성 기반으로 그룹화합니다.</li><li>각 클러스터에 대한 폴더를 생성하고, 파일을 해당 폴더로 이동합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>sentence_transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 핵심 단계는 텍스트 임베딩 생성입니다. 다음은 <code>sentence_transformers</code>를 사용하여 임베딩을 생성하는 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 모델 로드</span></span><br><span class="line">model = SentenceTransformer(<span class="string">"all-MiniLM-L6-v2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록을 목록에 저장</span></span><br><span class="line">abstract_list = [<span class="string">"abstract 1"</span>, <span class="string">"abstract 2"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임베딩 계산</span></span><br><span class="line">embeddings = model.encode(abstract_list)</span><br></pre></td></tr></table></figure><h2 id="4-멀티모달-검색-시스템-중급">4) 멀티모달 검색 시스템 (중급)</h2><p>특정 기술 보고서들을 위한 기본적인 RAG(검색 증강 생성) 시스템을 구축할 때, 보고서의 주요 정보가 <strong>텍스트가 아닌 플롯과 그림</strong>으로 표현되는 경우가 많아 검색에 어려움을 겪을 수 있습니다.</p><p>시각적 정보를 검색 과정에 포함시키기 위해 <strong>텍스트와 이미지를 동일한 공간에 표현하는 멀티모달 임베딩 모델</strong>을 사용하는 방법이 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>PDF를 섹션별로 나누고, PyMuPDF를 사용해 이미지를 추출합니다.</li><li>nomic-ai/nomic-embed-text-v1.5와 같은 멀티모달 임베딩 모델을 사용해 각 섹션과 이미지를 밀집 벡터로 표현하고, 데이터프레임에 저장합니다.</li><li>지식 베이스에 있는 모든 PDF에 대해 이 작업을 반복합니다.</li><li>사용자가 쿼리를 입력하면 지식 베이스에서 사용한 동일한 임베딩 모델을 통해 쿼리를 임베딩으로 변환합니다.</li><li>쿼리 임베딩과 지식 베이스 항목의 임베딩 간 코사인 유사도 점수를 계산합니다.</li><li>상위 k개의 결과를 반환합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code></p><p>이 프로젝트의 중요한 부분은 PDF를 어떻게 나누느냐에 있습니다. 가장 간단한 방법은 고정된 문자 수를 기준으로 약간의 중첩을 포함하여 나누는 것입니다. 또한, 각 청크에 파일 이름과 페이지 번호 같은 메타데이터를 포함하는 것이 유용합니다.</p><p>아래는 기본 코드 예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz  <span class="comment"># PyMuPDF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_text_chunks</span><span class="params">(pdf_path, chunk_size, overlap_size)</span>:</span></span><br><span class="line">    <span class="comment"># PDF 파일 열기</span></span><br><span class="line">    pdf_document = fitz.open(pdf_path)</span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 각 페이지를 반복하여 처리</span></span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> range(len(pdf_document)):</span><br><span class="line">        page = pdf_document[page_num]</span><br><span class="line">        page_text = page.get_text()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 현재 페이지의 텍스트를 중첩을 포함하여 청크로 분할</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; len(page_text):</span><br><span class="line">            end = start + chunk_size</span><br><span class="line">            chunk = page_text[start:end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 청크와 페이지 번호 저장</span></span><br><span class="line">            chunks.append((page_num + <span class="number">1</span>, chunk))</span><br><span class="line">            <span class="comment"># 중첩 크기만큼 이동하여 다음 청크 설정</span></span><br><span class="line">            start += chunk_size - overlap_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 추출 매개 변수 설정</span></span><br><span class="line">pdf_path = <span class="string">"your_file.pdf"</span></span><br><span class="line">chunk_size = <span class="number">1000</span>  <span class="comment"># 각 텍스트 청크의 크기 (문자 수 기준)</span></span><br><span class="line">overlap_size = <span class="number">200</span>  <span class="comment"># 중첩 크기 (문자 수 기준)</span></span><br><span class="line"></span><br><span class="line">text_chunks = extract_text_chunks(pdf_path, chunk_size, overlap_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 페이지 번호와 함께 청크 출력</span></span><br><span class="line"><span class="keyword">for</span> i, (page_number, chunk) <span class="keyword">in</span> enumerate(text_chunks):</span><br><span class="line">    print(<span class="string">f"청크 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (페이지 <span class="subst">&#123;page_number&#125;</span>):\n<span class="subst">&#123;chunk&#125;</span>\n<span class="subst">&#123;<span class="string">'-'</span> * <span class="number">50</span>&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-지식-기반-질문-응답-QA-시스템-고급">5) 지식 기반 질문-응답(QA) 시스템 (고급)</h2><p>가장 자주 요청받은 프로젝트가 바로 문서 질문-응답(QA) 시스템입니다. 이전 프로젝트를 기반으로, 이를 간단하게 구현할 수 있습니다.</p><p><strong>구현 단계:</strong></p><ul><li>지식 베이스에서 검색을 수행합니다 (프로젝트 4에서 만든 것처럼).</li><li>사용자 쿼리와 상위 k개의 검색 결과를 결합하여 멀티모달 모델에 전달합니다.</li><li>질문-응답 시스템을 위한 간단한 Gradio 사용자 인터페이스를 생성합니다.</li></ul><p><strong>사용 라이브러리:</strong> <code>PyMuPDF</code>, <code>transformers</code>, <code>pandas</code>, <code>sklearn</code>, <code>together/openai</code>, <code>Gradio</code></p><p>참고: Together AI의 API를 통해 Llama 3.2 Vision을 2025년까지 무료로 사용할 수 있습니다.</p><p>이 프로젝트는 본질적으로 프로젝트 2와 4를 결합한 형태입니다. 그러나 여기에는 사용자 인터페이스가 필수 요소로 포함됩니다. Gradio와 같은 대시보드 도구를 사용하여 간단한 채팅 UI를 몇 줄의 코드로 만들 수 있습니다.</p><p>아래는 Gradio의 문서에서 가져온 예시 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_response</span><span class="params">(message, history)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        응답을 생성하는 코드 작성</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">demo = gr.ChatInterface(</span><br><span class="line">    fn=generate_response,</span><br><span class="line">    examples=[&#123;<span class="string">"text"</span>: <span class="string">"Hello"</span>, <span class="string">"files"</span>: []&#125;],</span><br><span class="line">    title=<span class="string">"Echo Bot"</span>,</span><br><span class="line">    multimodal=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">demo.launch()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/python-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>효율적인 .NET 개발을 위한 4가지 필수 라이브러리 소개</title>
      <link>http://hgko1207.github.io/2024/10/29/csharp-14/</link>
      <guid>http://hgko1207.github.io/2024/10/29/csharp-14/</guid>
      <pubDate>Tue, 29 Oct 2024 04:49:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 &lt;strong&gt;.NET Core&lt;/strong&gt;를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>2014년에 마이크로소프트는 기존 .NET Framework의 오픈 소스 후속작인 <strong>.NET Core</strong>를 발표했습니다. 이 발표는 큰 변화였으며, 곧 .NET 소스 코드가 GitHub에 공개되었습니다. 마이크로소프트는 앞으로 모든 .NET 릴리스의 기초로 .NET Core를 활용하겠다고 밝혔고, 오픈 소스 기여는 .NET Foundation의 가이드 하에 이루어지게 되었습니다.</p><p>.NET Core는 큰 성공을 거두었고, 2020년에는 .NET Framework와 .NET Core가 하나의 오픈 소스 크로스 플랫폼 기술로 통합된 .NET 5가 출시되었습니다.</p><p>오픈 소스로 전환됨에 따라 .NET 플랫폼에는 활기 넘치는 커뮤니티가 형성되었습니다. 많은 뛰어난 개발자들이 고품질의 도구와 라이브러리를 게시해 개발자들의 일상 업무를 한결 쉽게 만들고 있습니다.</p><p>이번 글에서는 새 프로젝트를 시작할 때 꼭 설치하는 필수 라이브러리 4가지를 소개하고자 합니다.</p><h2 id="1-Refit">1. Refit</h2><p>.NET에서 HTTP 요청을 다루는 작업은 상당히 많은 수작업과 반복되는 코드를 요구합니다. 예를 들어 <code>HttpClient</code> 클래스를 직접 구현해 요청을 처리하는 코드는 다음과 같습니다</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> GetUserAsync(<span class="number">123</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"User Name: <span class="subst">&#123;user.Name&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 필요한 경우 기본 주소와 기본 헤더를 설정합니다.</span></span><br><span class="line">        client.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://api.example.com/"</span>);</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Clear();</span><br><span class="line">        client.DefaultRequestHeaders.Accept.Add(<span class="keyword">new</span> MediaTypeWithQualityHeaderValue(<span class="string">"application/json"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 요청하기</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">$"users/<span class="subst">&#123;userId&#125;</span>"</span>);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 응답 역직렬화</span></span><br><span class="line">        <span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;User&gt;(responseBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같은 구현 방식은 복잡하고, 반복적인 코드가 많아지기 쉽습니다.</p><p><strong>Refit</strong>은 이런 작업을 간편하게 해주는 라이브러리입니다. 단순히 인터페이스를 정의하여 REST API를 사용하게 도와줍니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyApi</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Get(<span class="meta-string">"/users/&#123;userId&#125;"</span>)</span>]</span><br><span class="line">    <span class="function">Task&lt;User&gt; <span class="title">GetUserAsync</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 후, 원하는 곳에 주입하여 다음과 같이 사용할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyApi _myApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">IMyApi myApi</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _myApi = myApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetUser</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _myApi.GetUserAsync(id);</span><br><span class="line">        <span class="keyword">return</span> Ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 HTTP 요청 관련 코드가 간소화되어 유지보수가 용이하며, API 호출이 컴파일 시간에 타입 검사까지 지원됩니다.</p><h2 id="2-Coravel">2. Coravel</h2><p><strong>Coravel</strong>은 작업 스케줄링, 큐잉, 캐싱, 백그라운드 작업, 이벤트 브로드캐스팅과 같은 반복적이고 어려운 작업을 매우 쉽게 처리할 수 있도록 도와주는 훌륭한 라이브러리입니다. Coravel은 다양한 영역을 포괄하는 대규모 라이브러리이며, 특히 스케줄링 기능이 뛰어납니다.</p><p>일반적으로 시스템을 구축할 때 어떤 형태로든 반복 작업을 처리해야 할 경우가 많습니다. 예를 들어, 매 시간마다 제3자 시스템에 데이터를 전달하거나, 매일 자정에 데이터베이스 백업을 수행해야 하는 경우가 있을 수 있습니다. Coravel은 이러한 작업을 매우 간단하게 처리할 수 있는 설정 방식을 제공하며, 주요 클라우드 제공 업체의 솔루션보다 유지보수가 더 쉬운 편입니다.</p><p>Coravel에서 작업을 정의하려면 <code>IInvocable</code> 인터페이스를 상속하는 클래스를 만들어야 합니다. 이 클래스가 바로 Coravel이 다양한 애플리케이션 파트에서 사용할 수 있는 특정 작업을 나타내며, 주기적으로 실행될 비즈니스 로직을 넣는 부분입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel.Invocable;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScheduledTask</span> : <span class="title">IInvocable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 여기에 실행할 로직을 작성합니다</span></span><br><span class="line">        Console.WriteLine(<span class="string">$"스케줄된 작업 실행 시간: <span class="subst">&#123;DateTime.Now&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>Program.cs</code> 파일에서 Coravel 스케줄러 서비스를 등록하고, 작업을 실행할 주기와 시점을 지정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coravel;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서비스 등록</span></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coravel 서비스 추가</span></span><br><span class="line">builder.Services.AddScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업(MyScheduledTask) 등록</span></span><br><span class="line">builder.Services.AddTransient&lt;MyScheduledTask&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 요청 파이프라인 구성</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IInvocable 작업 스케줄 설정</span></span><br><span class="line"><span class="keyword">var</span> provider = app.Services;</span><br><span class="line"></span><br><span class="line">provider.UseScheduler(scheduler =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    scheduler.Schedule&lt;MyScheduledTask&gt;().EveryMinute();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>이렇게 설정이 완료됩니다. Coravel은 내부적으로 작업을 스케줄에 맞춰 실행할 코드를 자동으로 관리합니다. 또한, 원하는 주기로 정확하게 작업이 실행되도록 설정할 수 있으며, CRON 표현식도 사용할 수 있어 더욱 세부적인 스케줄 관리가 가능합니다.</p><h2 id="3-FluentValidation">3. FluentValidation</h2><p><strong>FluentValidation</strong>은 .NET 애플리케이션에서 데이터 유효성 검사를 간편하게 정의하고 적용할 수 있도록 해주는 인기 있는 라이브러리입니다. 전통적으로 .NET에서의 데이터 유효성 검사는 커스텀 로직을 클래스 내부에 추가하거나 유연성이 부족한 데이터 주석을 사용하는 방식으로 이루어졌습니다.</p><p>대신 FluentValidation을 사용하면, 검증 로직을 작성하는 부담을 줄이고 커스터마이징 가능한 유효성 검사를 위한 인터페이스를 제공합니다. 이는 번잡하고 반복적인 유효성 검사 코드를 작성하지 않아도 되며, 자연스러운 언어처럼 유효성 검사를 정의할 수 있어 코드 가독성이 크게 향상됩니다. 또한, 다른 개발자들이 향후 코드를 쉽게 이해하고 유지보수할 수 있게 만듭니다.</p><p>먼저 <code>AbstractValidator</code> 클래스를 상속하는 클래스를 정의하고, <code>RuleFor</code> 메서드를 통해 유효성 검사 규칙을 간단히 설정합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomerValidator : AbstractValidator&lt;Customer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        RuleFor(customer =&gt; customer.Name)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">"이름은 필수 항목입니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Age)</span><br><span class="line">            .InclusiveBetween(<span class="number">18</span>, <span class="number">60</span>).WithMessage(<span class="string">"나이는 18세에서 60세 사이여야 합니다."</span>);</span><br><span class="line">        RuleFor(customer =&gt; customer.Email)</span><br><span class="line">            .EmailAddress().WithMessage(<span class="string">"유효하지 않은 이메일 주소입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FluentValidation에는 <code>.EmailAddress()</code>, <code>.NotEmpty()</code>, <code>.GreaterThan()</code>, <code>.CreditCard()</code>와 같은 편리한 기본 제공 메서드가 다수 포함되어 있으며, 필요에 따라 사용자 정의 유효성 검사 로직도 구현할 수 있습니다.</p><p>이제 정의된 <code>CustomerValidator</code>를 사용하여 필요한 곳에서 <code>Customer</code> 객체를 검증할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customer = <span class="keyword">new</span> Customer &#123; Name = <span class="string">""</span>, Age = <span class="number">25</span>, Email = <span class="string">"invalid-email"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> CustomerValidator();</span><br><span class="line"><span class="keyword">var</span> result = validator.Validate(customer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result.IsValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> failure <span class="keyword">in</span> result.Errors)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"속성 <span class="subst">&#123;failure.PropertyName&#125;</span>이(가) 유효성 검사를 통과하지 못했습니다. 오류: <span class="subst">&#123;failure.ErrorMessage&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Polly">4. Polly</h2><p><strong>Polly</strong>는 .NET 애플리케이션의 강인성과 장애 처리 기능을 크게 향상시켜주는 인기 있는 라이브러리입니다. Polly를 사용하면 개발자가 재시도(retry) 로직, 회로 차단(circuit breaking), 타임아웃(timeout), 벌크헤드 격리(bulkhead isolation), 폴백(fallback) 등의 다양한 정책을 정의하여 소프트웨어의 안정성을 높일 수 있습니다.</p><p>소프트웨어를 작성하다 보면 예외와 일시적인 오류가 불가피하게 발생합니다. 예를 들어, 프로그램이 네트워크 타임아웃을 겪는 경우가 있을 수 있으며, 이러한 상황을 우아하게 처리하지 못하면 비즈니스에 중요한 애플리케이션 부분에 악영향을 미칠 수 있습니다. 이러한 상황에서 Polly가 매우 유용합니다. Polly의 정책은 모듈식으로 구성되어 있으며, 복잡한 오류 처리 시나리오도 대응할 수 있도록 조합할 수 있습니다.</p><p>예를 들어, 재시도 정책과 회로 차단 정책을 결합하여 강력한 오류 처리 전략을 만들 수 있습니다.</p><p>외부 API에서 데이터를 가져오는 서비스를 예로 들어, 일시적인 오류에도 잘 견딜 수 있도록 설정해 보겠습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Polly;</span><br><span class="line"><span class="keyword">using</span> Polly.CircuitBreaker;</span><br><span class="line"><span class="keyword">using</span> Polly.Fallback;</span><br><span class="line"><span class="keyword">using</span> Polly.Retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 재시도 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .WaitAndRetryAsync(<span class="number">3</span>, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 회로 차단 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> circuitBreakerPolicy = Policy</span><br><span class="line">            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .CircuitBreakerAsync(<span class="number">3</span>, TimeSpan.FromSeconds(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 폴백 정책 정의</span></span><br><span class="line">        <span class="keyword">var</span> fallbackPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">            .Handle&lt;BrokenCircuitException&gt;()</span><br><span class="line">            .OrResult(r =&gt; !r.IsSuccessStatusCode)</span><br><span class="line">            .FallbackAsync(</span><br><span class="line">                <span class="keyword">new</span> HttpResponseMessage(System.Net.HttpStatusCode.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    Content = <span class="keyword">new</span> StringContent(<span class="string">"&#123;\"message\": \"Fallback response\"&#125;"</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                onFallbackAsync: <span class="keyword">async</span> b =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"폴백 로직 실행 중..."</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 정책 조합</span></span><br><span class="line">        <span class="keyword">var</span> combinedPolicy = fallbackPolicy.WrapAsync(circuitBreakerPolicy).WrapAsync(retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, <span class="string">"https://external-api.com/data"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 조합된 정책을 사용하여 요청 실행</span></span><br><span class="line">                HttpResponseMessage response = <span class="keyword">await</span> combinedPolicy.ExecuteAsync(() =&gt; httpClient.SendAsync(request));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 성공!"</span>);</span><br><span class="line">                    <span class="comment">// 응답 처리</span></span><br><span class="line">                    <span class="keyword">string</span> data = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">                    Console.WriteLine(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"요청 실패. 상태 코드: "</span> + response.StatusCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"예외 발생: "</span> + ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선, 세 가지 정책을 정의했습니다: <strong>재시도 정책</strong>, <strong>회로 차단 정책</strong>, 그리고 <strong>폴백 정책</strong>입니다.</p><ul><li><p><strong>재시도 정책</strong>은 HTTP 요청이 실패하여 성공하지 않은 상태 코드가 반환되면 최대 3회까지 재시도하도록 합니다. 재시도 간격은 지수 백오프(exponential backoff) 전략을 사용해 실패할 때마다 재시도 간격이 증가합니다.</p></li><li><p><strong>회로 차단 정책</strong>은 연속해서 세 번 실패하면 30초 동안 추가 시도를 중단하게 됩니다. 이로 인해 시스템에 회복할 시간을 주고 이후에 다시 시도하게 됩니다.</p></li><li><p>마지막으로, <strong>폴백 정책</strong>은 모든 재시도가 실패하고 회로가 여전히 열린 경우 기본 응답을 제공하여 애플리케이션이 계속 정상적으로 동작할 수 있도록 합니다.</p></li></ul><p>이렇게 조합된 정책을 통해 HTTP 요청 실행 중 발생할 수 있는 오류나 예외를 강력하게 처리할 수 있는 시스템을 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/29/csharp-14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자가 싫어하는 작업을 ChatGPT로 해결하는 방법</title>
      <link>http://hgko1207.github.io/2024/10/28/chatgpt-32/</link>
      <guid>http://hgko1207.github.io/2024/10/28/chatgpt-32/</guid>
      <pubDate>Mon, 28 Oct 2024 06:44:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-31.png" alt=""></p><p>반복적이거나 기계적인 작업을 좋아하는 개발자는 많지 않을 것입니다. 다행히도 2022년부터 아주 강력한 도구, ChatGPT가 이 “지루한” 작업을 훨씬 더 쉽게 만들어 주고 있습니다.</p><p>이번 글에서는 ChatGPT를 활용해 다음과 같은 개발 작업을 손쉽게 처리하는 방법을 소개합니다.</p><ul><li>파일 생성 및 업데이트</li><li>메서드/함수 이름 생성</li><li>다국어(i18n) 파일 생성</li><li>복잡한 코드 이해</li><li>데이터베이스 삽입문(insert) 생성</li></ul><h2 id="1-파일-생성-및-업데이트">1. 파일 생성 및 업데이트</h2><p>CSV 파일은 여전히 데이터 입력이나 테스트 데이터로 종종 사용됩니다. ChatGPT를 이용해 손쉽게 CSV 파일을 생성하거나 수정할 수 있습니다.</p><p>예를 들어, 고객 목록이 담긴 CSV 파일을 생성하려면 다음과 같은 프롬프트를 사용할 수 있습니다.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10명의 고객 정보가 담긴 CSV 파일을 생성해 주세요. 각 고객은 다음과 같은 열을 포함해야 합니다:</span><br><span class="line"><span class="deletion">- id: 정수</span></span><br><span class="line"><span class="deletion">- firstName: 문자열</span></span><br><span class="line"><span class="deletion">- lastName: 문자열</span></span><br><span class="line"><span class="deletion">- email: 문자열</span></span><br><span class="line"><span class="deletion">- phone: 문자열</span></span><br></pre></td></tr></table></figure><p>세미콜론(;) 구분자를 사용하고 국제 표준 전화번호 형식을 적용하려면 다음과 같이 요청할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">쉼표 대신 세미콜론을 사용하고, 전화번호는 국제 표준을 따르도록 해 주세요.</span><br></pre></td></tr></table></figure><p>또한, 시스템이 JSON 형식으로 전환되었다면 다음과 같이 요청하면 JSON 형식으로 변환된 파일을 생성해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSV 대신 JSON 형식으로 변환해 주세요.</span><br></pre></td></tr></table></figure><h2 id="2-메서드-함수-이름-생성">2. 메서드/함수 이름 생성</h2><p>메서드나 함수를 개발할 때 이름을 짓기 어려운 경우가 있습니다. 적절한 이름을 찾지 못한다면, 그 함수가 지나치게 많은 작업을 수행하고 있을 가능성이 높습니다. 하지만 이번에는 아이디어가 떠오르지 않거나, 익숙하지 않은 코드를 리팩토링해야 할 때의 상황에 초점을 맞춰 봅시다.</p><p>예를 들어, 다음 메서드에 대한 이름을 추천해 달라고 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Entity entity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entity.getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    insert(entity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update(entity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 적절한 메서드 이름을 제안해 주어 코드의 가독성을 높일 수 있습니다.</p><h2 id="3-다국어-i18n-파일-생성">3. 다국어(i18n) 파일 생성</h2><p>한 번은 시스템에서 사용하는 레이블의 번역본을 XML 파일로 받았는데, 시스템에서는 i18n 형식이 필요했습니다. XML 파일 예시는 다음과 같습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>phone<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Phone number<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>E-mail<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 XML을 사용해 영어와 스페인어의 i18n 파일을 생성하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">주어진 <span class="selector-tag">XML</span> 파일을 바탕으로 영어와 스페인어 각각에 대한 <span class="selector-tag">i18n</span> 파일을 생성해 주세요. 형식은 다음과 같아야 합니다:</span><br><span class="line">label=description</span><br></pre></td></tr></table></figure><p>결과는 다음과 같습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># English i18n file(en.i18n)</span></span><br><span class="line">name=Name</span><br><span class="line">phone=Phone number</span><br><span class="line">email=E-mail</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spanish i18n file(es.i18n)</span></span><br><span class="line">name=Nombre</span><br><span class="line">phone=Número de teléfono</span><br><span class="line">email=Correo electrónico</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-복잡한-코드-이해하기">4. 복잡한 코드 이해하기</h2><p>레거시 코드를 유지보수할 때, 메서드 이름만으로는 코드의 기능을 파악하기 어려운 경우가 있습니다.</p><p>예를 들어, 다음 코드가 어떤 기능을 수행하는지 ChatGPT에게 물어볼 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">boolean</span> swapped;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    swapped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (swapped == <span class="keyword">false</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatGPT는 이 코드가 배열의 요소를 정렬하기 위해 버블 정렬을 사용하고 있음을 설명해 줍니다.</p><h2 id="5-삽입문-insert-생성">5. 삽입문(insert) 생성</h2><p>데이터베이스에 데이터를 삽입하는 작업을 자동화할 수 있다면 많은 시간이 절약될 수 있습니다. ChatGPT는 삽입문을 작성하는 데도 도움이 됩니다!</p><p>다음과 같은 테이블이 있다고 가정해 봅시다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>그리고 다음과 같은 CSV 파일로 데이터를 받았다고 합시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customer_id,first_name,last_name,email,phone_number</span><br><span class="line">1,John,Doe,johndoe@example.com,555-1234</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이 데이터를 삽입문으로 변환하려면 ChatGPT에 다음과 같이 요청할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">주어진 CSV 데이터를 기반으로 삽입문을 생성해 주세요. 테이블 구조는 다음과 같습니다:</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">  customer_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  first_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  last_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>ChatGPT에게 코드를 작성하도록 요청하는 데 회의적일 수 있지만, 반복 작업이나 파일 변환, 테스트 데이터 생성에는 아주 유용하게 사용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/chatgpt-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] LINQ 모범 사례</title>
      <link>http://hgko1207.github.io/2024/10/28/csharp-13/</link>
      <guid>http://hgko1207.github.io/2024/10/28/csharp-13/</guid>
      <pubDate>Mon, 28 Oct 2024 05:07:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;.NET 개발자라면 &lt;strong&gt;LINQ&lt;/strong&gt;(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>.NET 개발자라면 <strong>LINQ</strong>(Language Integrated Query)를 프로젝트에서 효과적으로 사용하는 가이드라인을 확립하는 것이 중요합니다. LINQ는 코드 간결성과 가독성을 높일 수 있지만, 성능에 미치는 영향을 이해하고 신중하게 사용해야 합니다. 이번 글에서는 LINQ 사용 시의 모범 사례, 가이드라인, 그리고 벤치마크 정보를 제공해 LINQ를 언제, 어떻게 사용할지에 대한 인사이트를 드리겠습니다.</p><h2 id="LINQ-이해하기">LINQ 이해하기</h2><p>LINQ는 .NET에서 컬렉션과 다른 데이터 소스 작업을 표현력 있고 읽기 쉽게 쿼리할 수 있게 해주는 강력한 기능입니다. 메모리 내 객체, 데이터베이스, XML 등 다양한 데이터 소스에서 일관된 쿼리 환경을 제공합니다.</p><h2 id="LINQ의-장점">LINQ의 장점</h2><ul><li><strong>가독성:</strong> LINQ 쿼리는 기존의 루프 및 조건보다 가독성과 표현력이 뛰어난 경우가 많습니다.</li><li><strong>일관성:</strong> 다양한 데이터 소스를 대상으로 일관된 쿼리 방식을 제공합니다.</li><li><strong>컴파일 타임 검사:</strong> 컴파일 시점에서 쿼리를 검사하여 런타임 오류를 줄입니다.</li><li><strong>지연 실행:</strong> 많은 LINQ 작업이 지연 실행되므로 특정 시나리오에서 성능이 향상될 수 있습니다.</li></ul><h2 id="성능-고려사항">성능 고려사항</h2><p>LINQ는 많은 이점을 제공하지만 성능 특성을 이해하는 것이 중요합니다.</p><ul><li><strong>오버헤드:</strong> LINQ 작업에는 종종 델리게이트 인스턴스 생성과 반복자 사용으로 인해 약간의 오버헤드가 발생할 수 있습니다.</li><li><strong>메모리 사용량:</strong> 일부 LINQ 연산은 임시 컬렉션을 생성하여 잠재적으로 메모리 사용량을 증가시킬 수 있습니다.</li><li><strong>쿼리 복잡성:</strong> 복잡한 LINQ 쿼리는 수동 반복문보다 효율이 떨어질 수 있습니다.</li><li><strong>지연 실행:</strong> 유용하지만, 이해 없이 사용하면 예상치 못한 성능 문제가 발생할 수 있습니다.</li></ul><h2 id="모범-사례">모범 사례</h2><h3 id="1-가독성과-유지보수를-위해-LINQ-사용하기">1. 가독성과 유지보수를 위해 LINQ 사용하기</h3><p>작은~중간 크기의 컬렉션에서, 성능이 중요한 요구사항이 아니라면 가독성을 우선시하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = users.Where(u =&gt; u.IsActive).ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비추천 방식</span></span><br><span class="line"><span class="keyword">var</span> activeUsers = <span class="keyword">new</span> List&lt;User&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.IsActive)</span><br><span class="line">    &#123;</span><br><span class="line">        activeUsers.Add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-큰-컬렉션에서-LINQ-사용-주의하기">2. 큰 컬렉션에서 LINQ 사용 주의하기</h3><p>매우 큰 컬렉션이나 성능이 중요한 구간에서는 기존 반복문 사용을 고려하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 큰 컬렉션에서 더 빠를 수 있음:</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> largeCollection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.SomeProperty &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LINQ 방식:</span></span><br><span class="line"><span class="keyword">var</span> count = largeCollection.Count(item =&gt; item.SomeProperty &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="3-지연-실행-이해하고-활용하기">3. 지연 실행 이해하고 활용하기</h3><p>LINQ는 많은 작업에서 지연 실행을 사용하므로 결과가 실제로 필요할 때까지 쿼리가 실행되지 않습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 쿼리 실행 안 됨</span></span><br><span class="line"><span class="keyword">var</span> query = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기서 쿼리 실행됨</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지연 실행을 활용하여 복잡한 쿼리를 단계별로 작성하고 필요한 시점에만 실행하세요.</p><h3 id="4-ToList-ToArray-ToDictionary-를-목적에-맞게-사용하기">4. <code>ToList()</code>, <code>ToArray()</code>, <code>ToDictionary()</code>를 목적에 맞게 사용하기</h3><p>이 메서드들은 쿼리를 즉시 실행합니다. 다음과 같은 경우 사용하세요.</p><ul><li>쿼리가 한 번만 실행되도록 하고 싶을 때</li><li>동일한 쿼리를 여러 번 열거하는 것을 방지하고 싶을 때</li><li>데이터 스냅샷을 생성할 때</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> activeUsersList = users.Where(u =&gt; u.IsActive).ToList();</span><br></pre></td></tr></table></figure><h3 id="5-LINQ와-기존-반복문-혼용-피하기">5. LINQ와 기존 반복문 혼용 피하기</h3><p>혼합하면 코드가 혼란스러워지고 유지보수가 어려워질 수 있으니 한 가지 방식만 사용하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 혼용하지 말기</span></span><br><span class="line"><span class="keyword">var</span> query = users.Where(u =&gt; u.IsActive);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.Age &gt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 작업 수행</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">var</span> relevantUsers = users.Where(u =&gt; u.IsActive &amp;&amp; u.Age &gt; <span class="number">30</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> relevantUsers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 작업 수행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-복잡한-쿼리에는-메서드-구문-사용하기">6. 복잡한 쿼리에는 메서드 구문 사용하기</h3><p>복잡한 쿼리는 메서드 구문이 더 읽기 쉽고 유연합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메서드 구문</span></span><br><span class="line"><span class="keyword">var</span> result = users</span><br><span class="line">    .Where(u =&gt; u.IsActive)</span><br><span class="line">    .OrderBy(u =&gt; u.LastName)</span><br><span class="line">    .ThenBy(u =&gt; u.FirstName)</span><br><span class="line">    .Select(u =&gt; <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 쿼리 구문</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> u <span class="keyword">in</span> users</span><br><span class="line">             <span class="keyword">where</span> u.IsActive</span><br><span class="line">             <span class="keyword">orderby</span> u.LastName, u.FirstName</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; u.FullName, u.Email &#125;;</span><br></pre></td></tr></table></figure><h3 id="7-여러-번-열거-피하기">7. 여러 번 열거 피하기</h3><p>같은 LINQ 쿼리를 여러 번 열거하면 성능이 저하될 수 있습니다. 여러 번 사용해야 한다면 결과를 리스트에 저장하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비효율적: 두 번 열거함</span></span><br><span class="line"><span class="keyword">var</span> count = query.Count();</span><br><span class="line"><span class="keyword">var</span> firstItem = query.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 효율적: 한 번만 열거</span></span><br><span class="line"><span class="keyword">var</span> results = query.ToList();</span><br><span class="line"><span class="keyword">var</span> count = results.Count;</span><br><span class="line"><span class="keyword">var</span> firstItem = results.FirstOrDefault();</span><br></pre></td></tr></table></figure><h3 id="8-적절한-LINQ-메서드-사용하기">8. 적절한 LINQ 메서드 사용하기</h3><p>상황에 맞는 LINQ 메서드를 선택하세요.</p><ul><li>한 개의 항목만 필요할 때 <code>First()</code> 또는 <code>FirstOrDefault()</code> 사용</li><li>존재 여부를 확인할 때는 <code>Count() &gt; 0</code> 대신 <code>Any()</code> 사용</li><li>0 또는 1개의 항목을 기대할 때는 <code>SingleOrDefault()</code> 사용</li><li>결과 수를 제한할 때는 <code>Take()</code> 사용</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Any(u =&gt; u.IsAdmin))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비권장 방식</span></span><br><span class="line"><span class="keyword">if</span> (users.Count(u =&gt; u.IsAdmin) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="벤치마크-예제">벤치마크 예제</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benchmarks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">GlobalSetup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        numbers = Enumerable.Range(<span class="number">1</span>, <span class="number">1</span>_000_000).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SumWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLinq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">FilterWithLoop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.Add(numbers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과 예시 (예시일 뿐 실제 결과는 다를 수 있음)</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th></tr></thead><tbody><tr><td>SumWithLinq</td><td style="text-align:right">463.7 μs</td><td style="text-align:right">4.61 μs</td><td style="text-align:right">4.31 μs</td></tr><tr><td>SumWithLoop</td><td style="text-align:right">395.8 μs</td><td style="text-align:right">2.81 μs</td><td style="text-align:right">2.63 μs</td></tr><tr><td>FilterWithLinq</td><td style="text-align:right">10,523.3 μs</td><td style="text-align:right">102.40 μs</td><td style="text-align:right">95.78 μs</td></tr><tr><td>FilterWithLoop</td><td style="text-align:right">5,837.7 μs</td><td style="text-align:right">40.91 μs</td><td style="text-align:right">38.27 μs</td></tr></tbody></table><p>단순 작업에서는 LINQ와 반복문의 성능 차이가 크지 않지만, 필터링 같은 복잡한 작업에서는 반복문이 훨씬 빠를 수 있습니다.</p><h2 id="결론">결론</h2><p>LINQ는 코드 가독성과 유지보수성을 크게 향상할 수 있는 강력한 도구입니다. 하지만 성능이 중요한 경우 신중히 사용해야 합니다. 주요 포인트는 다음과 같습니다:</p><ul><li>작은~중간 크기 컬렉션에서는 LINQ를 사용해 가독성을 향상하세요.</li><li>큰 컬렉션이나 성능이 중요한 경우 기존 반복문을 고려하세요.</li><li>지연 실행을 이해하고 활용하세요.</li><li>여러 번 열거 시 <code>ToList()</code>나 <code>ToArray()</code>를 적절히 사용하세요.</li><li>사용 목적에 맞는 LINQ 메서드를 선택하세요.</li></ul><p>이 가이드라인을 따르면 LINQ의 장점을 활용하면서도 성능 문제를 피할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/28/csharp-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬에서 함수형 프로그래밍 실습</title>
      <link>http://hgko1207.github.io/2024/10/24/python-9/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-9/</guid>
      <pubDate>Thu, 24 Oct 2024 04:43:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;함수형 프로그래밍&lt;/strong&gt;은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-9.png" alt="" /></p><p><strong>함수형 프로그래밍</strong>은 계산을 함수의 평가로 간주하며, 가변 상태와 반복문 사용을 지양하는 프로그래밍 패러다임입니다. 함수형 프로그래밍은 함수의 계산에 중점을 두며, 부수효과는 최소화합니다.</p><p>함수형 프로그래밍에서는 함수가 일급 객체(first-class citizen)로 취급되며, 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p><strong>Python</strong>은 객체 지향 프로그래밍 언어이지만, 함수형 프로그래밍의 특징도 지원합니다. Python에서 우리는 함수형 스타일의 코드를 작성하여 그 간결함과 효율성을 활용해 실질적인 문제를 해결할 수 있습니다.</p><h2 id="1-필수-개념"><a class="markdownIt-Anchor" href="#1-필수-개념"></a> 1. 필수 개념</h2><h3 id="11-함수는-일급-객체이다"><a class="markdownIt-Anchor" href="#11-함수는-일급-객체이다"></a> 1.1 함수는 일급 객체이다</h3><p>함수형 프로그래밍에서 함수는 일급 객체로 취급됩니다. 이는 함수가 다른 객체처럼 조작되고 전달될 수 있다는 것을 의미합니다.</p><p>이 덕분에 함수를 다른 함수의 인수로 전달하거나, 함수에서 함수를 반환할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span><span class="params">(f, g)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line"></span><br><span class="line">square_of_cube = compose(square, cube)</span><br><span class="line"></span><br><span class="line">print(square_of_cube(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 출력: 64</span></span><br></pre></td></tr></table></figure><h3 id="12-불변-데이터"><a class="markdownIt-Anchor" href="#12-불변-데이터"></a> 1.2 불변 데이터</h3><p>함수형 프로그래밍은 불변 데이터를 중시합니다. 이는 데이터 구조가 한 번 생성되면 변경할 수 없음을 의미합니다.</p><p>모든 연산은 원래 데이터를 수정하지 않고, 새로운 데이터를 반환해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num_plus_one = increment(num)</span><br><span class="line"></span><br><span class="line">print(num_plus_one)</span><br><span class="line"><span class="comment"># 출력: 2</span></span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line"><span class="comment"># 출력: 1</span></span><br></pre></td></tr></table></figure><h2 id="2-python의-기능"><a class="markdownIt-Anchor" href="#2-python의-기능"></a> 2. Python의 기능</h2><p>Python은 순수 함수형 프로그래밍 언어는 아니지만, 함수형 프로그래밍의 일부 기능을 갖추고 있습니다. 이러한 기능은 더 깔끔하고 효율적인 코드를 작성하는 데 도움을 줍니다.</p><h3 id="21-익명-함수와-람다lambda-표현식"><a class="markdownIt-Anchor" href="#21-익명-함수와-람다lambda-표현식"></a> 2.1 익명 함수와 람다(Lambda) 표현식</h3><p>Python은 익명 함수를 지원하여 코드의 가독성을 높여줍니다. 람다 표현식은 간단한 익명 함수를 생성할 수 있는 Python의 중요한 기능입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 피보나치 수열을 생성하는 람다 함수</span></span><br><span class="line">fibonacci = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 람다 함수를 사용하여 10번째 피보나치 수를 계산</span></span><br><span class="line">tenth_fibonacci = fibonacci(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(tenth_fibonacci)</span><br><span class="line"><span class="comment"># 출력: 55</span></span><br></pre></td></tr></table></figure><p>이 예시에서 <code>fibonacci</code> 람다 함수는 재귀적으로 피보나치 수열을 생성합니다. 그런 다음, 이 함수를 사용해 10번째 피보나치 수를 계산하면 결과는 55가 됩니다.</p><h3 id="22-리스트-컴프리헨션"><a class="markdownIt-Anchor" href="#22-리스트-컴프리헨션"></a> 2.2 리스트 컴프리헨션</h3><p>리스트 컴프리헨션(List Comprehension)은 Python에서 매우 강력한 기능으로, 간결한 구문을 통해 리스트를 생성할 수 있게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트 컴프리헨션 사용</span></span><br><span class="line">squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">print(squares)</span><br><span class="line"><span class="comment"># 출력: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><h2 id="3-함수형-프로그래밍-실습"><a class="markdownIt-Anchor" href="#3-함수형-프로그래밍-실습"></a> 3. 함수형 프로그래밍 실습</h2><h3 id="31-정렬과-맵핑"><a class="markdownIt-Anchor" href="#31-정렬과-맵핑"></a> 3.1 정렬과 맵핑</h3><p>Python의 내장 함수 <code>sorted</code>와 <code>map</code>을 사용하면 리스트를 쉽게 정렬하고 맵핑할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 정렬</span></span><br><span class="line">sorted_numbers = sorted(numbers)</span><br><span class="line">print(sorted_numbers)</span><br><span class="line"><span class="comment"># 출력: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 제곱 함수 정의</span></span><br><span class="line">square = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 맵핑</span></span><br><span class="line">squared_numbers = list(map(square, numbers))</span><br><span class="line">print(squared_numbers)</span><br><span class="line"><span class="comment"># 출력: [9, 1, 16, 1, 25, 81, 4, 36, 25, 9, 25]</span></span><br></pre></td></tr></table></figure><h3 id="32-필터링과-집계"><a class="markdownIt-Anchor" href="#32-필터링과-집계"></a> 3.2 필터링과 집계</h3><p>Python은 <code>filter</code>와 <code>reduce</code> 같은 내장 필터링 및 집계 함수를 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필터링</span></span><br><span class="line">even_numbers = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers))</span><br><span class="line">print(even_numbers)</span><br><span class="line"><span class="comment"># 출력: [4, 2, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 집계</span></span><br><span class="line">summed = reduce(<span class="keyword">lambda</span> x, y: x + y, numbers)</span><br><span class="line">print(summed)</span><br><span class="line"><span class="comment"># 출력: 43</span></span><br></pre></td></tr></table></figure><h2 id="4-메서드-체이닝을-사용한-파이프-시뮬레이션"><a class="markdownIt-Anchor" href="#4-메서드-체이닝을-사용한-파이프-시뮬레이션"></a> 4. 메서드 체이닝을 사용한 파이프 시뮬레이션</h2><p>Python에서는 Unix 쉘 스크립트와 같은 “Pipe” 개념이 기본적으로 제공되지는 않지만, 메서드 체이닝(Method Chaining)이나 함수 조합을 사용해 유사한 기능을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_five</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이프 같은 구성을 위한 메서드 체이닝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pipe</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.value = func(self.value)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">number = Pipeable(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 메서드 체이닝을 통한 파이프 구성</span></span><br><span class="line">result = number.pipe(square).pipe(double).pipe(add_five)</span><br><span class="line"></span><br><span class="line">print(result.value)</span><br><span class="line"><span class="comment"># 출력: 23</span></span><br></pre></td></tr></table></figure><p>이 예시는 <code>Pipeable</code> 클래스를 사용하여 파이프와 같은 구성을 구현하는 방법을 보여줍니다. <code>pipe</code> 메서드를 사용해 각 함수가 이전 결과를 받아들여 처리할 수 있습니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>함수형 프로그래밍은 함수 계산에 중점을 두며, 부수효과를 최소화하는 새로운 프로그래밍 패러다임입니다.</p><p>Python은 함수형 프로그래밍 기능을 지원하여 더 간단하고 효율적인 코드를 작성할 수 있게 합니다. Python은 순수 함수형 언어는 아니지만, 데이터 처리와 응용 프로그램 개발에서 매우 강력한 기능을 제공합니다.</p><p><strong>장점:</strong></p><ul><li>코드가 간결함</li><li>이해 및 유지보수가 쉬움</li><li>코드 재사용성을 높임</li></ul><p><strong>단점:</strong></p><ul><li>학습 비용이 있을 수 있음</li><li>일부 상황에서는 명령형 프로그래밍보다 성능이 낮을 수 있음</li></ul><p>결론적으로, 함수형 프로그래밍은 모듈화되고 이해하기 쉬운 유지보수성이 높은 코드를 작성하는 데 도움이 되는 강력한 프로그래밍 패러다임입니다. Python에서 함수형 프로그래밍의 기능을 활용해 실질적인 문제를 해결하고, 프로그래밍 효율성을 높여보세요!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 데코레이터(Decorator) 5가지 소개</title>
      <link>http://hgko1207.github.io/2024/10/24/python-8/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-8/</guid>
      <pubDate>Thu, 24 Oct 2024 03:35:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/python-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/python-8.png" alt="" /></p><p><strong>Python</strong>은 간결한 문법과 데이터 분석, 웹 개발 등 다양한 분야에서 강력한 응용 프로그램을 지원하는 덕분에 좋아하는 프로그래밍 언어입니다.</p><p>하지만 오랜 기간 코드를 작성하면서도 데코레이터 기능을 거의 사용하지 않았습니다. 클래스의 정적 메서드를 데코레이트하기 위한 <code>@staticmethod</code>를 사용하는 경우를 제외하면 말이죠.</p><p>그래서 이번 글에서는 데코레이터의 개념을 깊이 탐구하고, 파이썬 코드의 효율성을 높일 수 있는 실용적인 데코레이터 5가지를 소개하고자 합니다.</p><h2 id="데코레이터decorator란-무엇인가"><a class="markdownIt-Anchor" href="#데코레이터decorator란-무엇인가"></a> 데코레이터(Decorator)란 무엇인가?</h2><p>데코레이터는 파이썬의 강력한 언어 기능으로, 원래의 함수 코드를 수정하지 않고도 동적으로 기능을 추가하거나 함수의 동작을 수정할 수 있습니다. 데코레이터는 기본적으로 다른 함수나 클래스를 인자로 받아 새로운 함수나 클래스를 반환하는 함수입니다.</p><p>데코레이터는 함수를 확장하거나 감싸는 간결하고 우아한 방법을 제공하여 코드의 가독성과 유지보수성을 향상시킵니다.</p><p>주로 다음과 같은 상황에서 데코레이터가 사용됩니다:</p><ul><li>로깅, 성능 분석, 입력 유효성 검사 등 추가적인 기능이나 로직을 추가할 때.</li><li>캐시 결과, 재시도 메커니즘 추가 등 함수의 동작을 수정할 때.</li><li>주요 비즈니스 로직에서 공통적으로 발생하는 문제를 분리할 때.</li></ul><p>이제 간단하지만 유용한 5가지 데코레이터를 알아보겠습니다.</p><h2 id="01-timer-함수의-실행-시간-측정"><a class="markdownIt-Anchor" href="#01-timer-함수의-실행-시간-측정"></a> 01. <code>timer</code>: 함수의 실행 시간 측정</h2><p>코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력합니다. 이 데코레이터를 사용하여 코드의 병목 지점을 쉽게 파악하고 중요한 부분을 최적화할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        execution_time = end_time - start_time</span><br><span class="line">        print(<span class="string">f"Execution time: <span class="subst">&#123;execution_time&#125;</span> seconds"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>데코레이터를 사용하려면 원하는 함수 위에 <code>@</code> 기호를 사용해 적용하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Starting the model training function..."</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"Model training completed!"</span>)</span><br><span class="line"></span><br><span class="line">train_model()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Starting the model training <span class="keyword">function</span>…</span><br><span class="line">Model Training completed!</span><br><span class="line">Execution time: 5.006425619125366 seconds</span><br></pre></td></tr></table></figure><hr /><h2 id="02-debugger-디버깅을-쉽게"><a class="markdownIt-Anchor" href="#02-debugger-디버깅을-쉽게"></a> 02. <code>debugger</code>: 디버깅을 쉽게</h2><p>각 함수의 입력과 출력을 출력하여 디버깅을 더 쉽게 할 수 있는 래퍼 함수를 만들 수 있습니다. 이 방법은 여러 개의 print 문을 사용하지 않고도 함수의 실행 흐름을 쉽게 파악할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debugger</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"Calling <span class="subst">&#123;func.__name__&#125;</span> with args: <span class="subst">&#123;args&#125;</span> kwargs: <span class="subst">&#123;kwargs&#125;</span>"</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;func.__name__&#125;</span> returned: <span class="subst">&#123;result&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@debugger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add_numbers(<span class="number">7</span>, y=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">Calling add_numbers with args: (7,) kwargs: &#123;<span class="string">'y'</span>: 5&#125;</span><br><span class="line">add_numbers returned: 12</span><br></pre></td></tr></table></figure><hr /><h2 id="03-memoize-결과-캐싱"><a class="markdownIt-Anchor" href="#03-memoize-결과-캐싱"></a> 03. <code>memoize</code>: 결과 캐싱</h2><p>코드에서 일부 반복 실행되는 부분은 큰 컴퓨팅 자원을 소모할 수 있습니다. 이 경우 <code>memoize</code> 데코레이터를 사용하여 함수 호출 결과를 캐싱할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = func(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>피보나치 수 계산 함수에 캐싱을 적용하면, 동일한 입력에 대해 함수가 한 번만 실행되고 이후에는 캐시된 결과를 사용하게 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>캐싱을 사용하지 않은 경우와 비교해 보면, 캐싱된 버전은 몇 밀리초밖에 걸리지 않는 반면, 캐싱되지 않은 버전은 거의 1분이 걸릴 수 있습니다.</p><hr /><h2 id="04-retry-재시도-로직"><a class="markdownIt-Anchor" href="#04-retry-재시도-로직"></a> 04. <code>retry</code>: 재시도 로직</h2><p>데이터 과학과 소프트웨어 개발에서 외부 시스템에 의존하는 경우가 많지만, 모든 외부 시스템이 안정적이지는 않습니다. 예기치 않은 오류가 발생했을 때, 코드가 잠시 기다렸다가 다시 시도하도록 할 수 있습니다. 이 재시도 로직을 데코레이터로 구현하여 쉽게 적용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span><span class="params">(max_attempts, delay=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            attempts = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> attempts &lt; max_attempts:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    attempts += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">f"Attempt <span class="subst">&#123;attempts&#125;</span> failed: <span class="subst">&#123;e&#125;</span>"</span>)</span><br><span class="line">                    time.sleep(delay)</span><br><span class="line">            print(<span class="string">f"Function failed after <span class="subst">&#123;max_attempts&#125;</span> attempts"</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@retry(max_attempts=3, delay=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"Fetching the data.."</span>)</span><br><span class="line">    <span class="keyword">raise</span> TimeoutError(<span class="string">"Server is not responding."</span>)</span><br><span class="line"></span><br><span class="line">fetch_data(<span class="string">"https://example.com/data"</span>)</span><br></pre></td></tr></table></figure><p>이 코드는 최대 3번까지 2초 간격으로 재시도합니다.</p><h2 id="05-exception_handler-예외-처리-간소화"><a class="markdownIt-Anchor" href="#05-exception_handler-예외-처리-간소화"></a> 05. <code>exception_handler</code>: 예외 처리 간소화</h2><p><code>exception_handler</code> 데코레이터는 함수에서 발생하는 예외를 잡아 처리할 수 있습니다. 필요에 따라 로깅하거나 추가적인 오류 처리를 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">f"An exception occurred: <span class="subst">&#123;str(e)&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@exception_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = x / y</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 출력:</span></span><br><span class="line">An exception occurred: division by zero</span><br></pre></td></tr></table></figure><p>이 데코레이터는 코드를 단순화하고 예외 처리와 오류 로깅을 위한 일관된 절차를 설정하는 데 매우 유용합니다.</p><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>데코레이터는 함수에 새로운 동작을 적용하는 매우 편리한 방법입니다. 데코레이터를 사용하면 복잡한 작업을 간소화하고 코드 가독성을 높이며, 생산성을 향상시킬 수 있습니다.</p><p>데코레이터는 파이썬의 강력한 기능 중 하나이며, 적절히 활용하면 코드의 유지보수성과 확장성을 높일 수 있습니다. 데코레이터를 사용해 여러분의 파이썬 코드를 한 단계 더 발전시켜보세요. 😊</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 디자인 패턴 사용 방법</title>
      <link>http://hgko1207.github.io/2024/10/24/python-7/</link>
      <guid>http://hgko1207.github.io/2024/10/24/python-7/</guid>
      <pubDate>Thu, 24 Oct 2024 03:08:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Python</strong>은 배우기 쉽고 유연하며 강력한 매우 인기 있는 프로그래밍 언어로, 다양한 분야에서 널리 사용됩니다. 그러나 많은 사람들은 Python이 절차 지향 언어이며 객체 지향 프로그래밍 스타일을 잘 지원하지 못한다고 생각합니다.</p><p>이 생각은 잘못된 것입니다. Python은 객체 지향 프로그래밍을 지원할 뿐만 아니라 <strong>디자인 패턴</strong>도 효과적으로 적용할 수 있습니다.</p><h2 id="디자인-패턴이란-무엇인가"><a class="markdownIt-Anchor" href="#디자인-패턴이란-무엇인가"></a> 디자인 패턴이란 무엇인가?</h2><p>디자인 패턴(Design Pattern)은 널리 인정받고 검증된 프로그래밍 경험의 집합입니다. 이는 다양한 프로그래밍 시나리오에서 적용할 수 있는 일반적인 솔루션을 제공합니다. 디자인 패턴의 등장은 코드 재사용, 시스템 확장성, 코드 가독성 등 소프트웨어 개발의 일반적인 문제를 해결하기 위함입니다.</p><h2 id="디자인-패턴을-사용하는-이유는"><a class="markdownIt-Anchor" href="#디자인-패턴을-사용하는-이유는"></a> 디자인 패턴을 사용하는 이유는?</h2><p>디자인 패턴을 사용하는 이점은 다음과 같습니다:</p><ul><li><strong>코드 재사용:</strong> 디자인 패턴을 사용하면 코드를 분해하고 조합하여 코드 재사용을 달성할 수 있습니다.</li><li><strong>시스템 확장성:</strong> 디자인 패턴은 시스템을 더 유연하게 만들고, 확장이 용이하며, 다양한 요구에 적응할 수 있게 합니다.</li><li><strong>코드 가독성:</strong> 디자인 패턴을 사용하면 코드의 가독성을 높여 코드가 더 명확해집니다.</li></ul><h2 id="파이썬에서의-디자인-패턴"><a class="markdownIt-Anchor" href="#파이썬에서의-디자인-패턴"></a> 파이썬에서의 디자인 패턴</h2><p>파이썬에서의 디자인 패턴은 다른 언어에서의 디자인 패턴과 유사하지만, 몇 가지 차이점이 있습니다. 파이썬에서의 디자인 패턴은 크게 세 가지로 나눌 수 있습니다: 생성 패턴, 구조 패턴, 행동 패턴.</p><p>이번 글에서는 몇 가지 일반적인 패턴을 설명합니다.</p><h2 id="1-팩토리-패턴-factory-pattern"><a class="markdownIt-Anchor" href="#1-팩토리-패턴-factory-pattern"></a> 1. 팩토리 패턴 (Factory Pattern)</h2><p>팩토리 패턴은 생성 패턴으로, 객체를 생성하는 가장 좋은 방법을 제공합니다. 이 패턴은 객체의 생성과 사용을 분리하여 객체 생성을 더 유연하게 만듭니다.</p><p>파이썬에서 팩토리 패턴을 사용하여 다양한 객체를 생성할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_animal</span><span class="params">(self, animal_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> animal_type == <span class="string">"dog"</span>:</span><br><span class="line">            <span class="keyword">return</span> Dog()</span><br><span class="line">        <span class="keyword">elif</span> animal_type == <span class="string">"cat"</span>:</span><br><span class="line">            <span class="keyword">return</span> Cat()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">factory = AnimalFactory()</span><br><span class="line">animal = factory.create_animal(<span class="string">"dog"</span>)</span><br><span class="line">print(animal.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: dog</span></span><br></pre></td></tr></table></figure><h2 id="2-싱글톤-패턴-singleton-pattern"><a class="markdownIt-Anchor" href="#2-싱글톤-패턴-singleton-pattern"></a> 2. 싱글톤 패턴 (Singleton Pattern)</h2><p>싱글톤 패턴은 클래스에 하나의 인스턴스만 존재하도록 보장하며, 전역 접근 지점을 제공합니다.</p><p><img src="/images/header/python-7_1.png" alt="" /></p><p>파이썬에서는 데코레이터를 사용하여 싱글톤 패턴을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton()</span><br><span class="line">b = Singleton()</span><br><span class="line"></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: True</span></span><br></pre></td></tr></table></figure><h2 id="3-어댑터-패턴-adapter-pattern"><a class="markdownIt-Anchor" href="#3-어댑터-패턴-adapter-pattern"></a> 3. 어댑터 패턴 (Adapter Pattern)</h2><p>어댑터 패턴은 구조 패턴으로, 클래스의 인터페이스를 클라이언트가 원하는 다른 인터페이스로 변환합니다.</p><p>파이썬에서는 어댑터 패턴을 사용하여 호환되지 않는 인터페이스 간의 호환성을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">specific_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(Target)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, adaptee)</span>:</span></span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.adaptee.specific_request()</span><br><span class="line"></span><br><span class="line">adaptee = Adaptee()</span><br><span class="line">adapter = Adapter(adaptee)</span><br><span class="line">adapter.request()</span><br></pre></td></tr></table></figure><h2 id="4-데코레이터-패턴-decorator-pattern"><a class="markdownIt-Anchor" href="#4-데코레이터-패턴-decorator-pattern"></a> 4. 데코레이터 패턴 (Decorator Pattern)</h2><p>데코레이터 패턴은 구조 패턴으로, 객체에 새로운 동작을 동적으로 추가할 수 있습니다.</p><p><img src="/images/header/python-7_2.png" alt="" /></p><p>파이썬에서는 데코레이터 함수를 사용하여 함수나 클래스의 동작을 수정할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call function:"</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: call function: foo hello world</span></span><br></pre></td></tr></table></figure><h2 id="5-옵저버-패턴-observer-pattern"><a class="markdownIt-Anchor" href="#5-옵저버-패턴-observer-pattern"></a> 5. 옵저버 패턴 (Observer Pattern)</h2><p>옵저버 패턴은 행동 패턴으로, 객체 간 일대다 관계를 정의하여, 객체의 상태가 변경될 때 이를 의존하는 모든 객체가 자동으로 업데이트됩니다.</p><p><img src="/images/header/python-7_3.png" alt="" /></p><p>파이썬에서는 옵저버 패턴을 사용하여 이벤트 중심의 프로그래밍을 구현할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        self.observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        self.state = state</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span><span class="params">(Observer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        print(<span class="string">"state changed to:"</span>, subject.get_state())</span><br><span class="line"></span><br><span class="line">subject = ConcreteSubject()</span><br><span class="line">observer = ConcreteObserver()</span><br><span class="line">subject.attach(observer)</span><br><span class="line">subject.set_state(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 출력: state changed to: 1</span></span><br></pre></td></tr></table></figure><h2 id="6-빌더-패턴-builder-pattern"><a class="markdownIt-Anchor" href="#6-빌더-패턴-builder-pattern"></a> 6. 빌더 패턴 (Builder Pattern)</h2><p>빌더 패턴은 복잡한 객체의 생성 과정을 그 표현과 분리하여 동일한 생성 과정으로 다양한 표현을 만들 수 있게 합니다.</p><p><img src="/images/header/python-7_4.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_car</span><span class="params">(self, builder)</span>:</span></span><br><span class="line">        builder.create_new_car()</span><br><span class="line">        builder.add_model()</span><br><span class="line">        builder.add_engine()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_new_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = Car()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.car</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.model = <span class="string">"Sports Car"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_engine</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car.engine = <span class="string">"V8"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.engine = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">director = Director()</span><br><span class="line">car_builder = CarBuilder()</span><br><span class="line"></span><br><span class="line">director.construct_car(car_builder)</span><br><span class="line">car = car_builder.get_car()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Car Model: <span class="subst">&#123;car.model&#125;</span>, Engine: <span class="subst">&#123;car.engine&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="7-전략-패턴-strategy-pattern"><a class="markdownIt-Anchor" href="#7-전략-패턴-strategy-pattern"></a> 7. 전략 패턴 (Strategy Pattern)</h2><p>전략 패턴은 알고리즘 군을 정의하고, 이를 캡슐화하며, 이 알고리즘을 상호 교체 가능하게 만드는 패턴입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentContext</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, payment_strategy)</span>:</span></span><br><span class="line">        self.payment_strategy = payment_strategy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_payment</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.payment_strategy.pay(amount)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCardPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using Credit Card."</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PayPalPayment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Paying $<span class="subst">&#123;amount&#125;</span> using PayPal."</span></span><br><span class="line"></span><br><span class="line">credit_card_payment = CreditCardPayment()</span><br><span class="line">paypal_payment = PayPalPayment()</span><br><span class="line"></span><br><span class="line">context_credit_card = PaymentContext(credit_card_payment)</span><br><span class="line">context_paypal = PaymentContext(paypal_payment)</span><br><span class="line"></span><br><span class="line">print(context_credit_card.execute_payment(<span class="number">100</span>))</span><br><span class="line">print(context_paypal.execute_payment(<span class="number">50</span>))</span><br></pre></td></tr></table></figure><h2 id="8-책임-연쇄-패턴-chain-of-responsibility-pattern"><a class="markdownIt-Anchor" href="#8-책임-연쇄-패턴-chain-of-responsibility-pattern"></a> 8. 책임 연쇄 패턴 (Chain of Responsibility Pattern)</h2><p>책임 연쇄 패턴은 요청을 처리할 수 있는 여러 핸들러가 체인으로 연결되어 각 핸들러가 요청을 처리할지 또는 다음 핸들러로 전달할지 결정하는 패턴입니다.</p><p><img src="/images/header/python-7_5.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, successor=None)</span>:</span></span><br><span class="line">        self.successor = successor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.successor:</span><br><span class="line">            self.successor.handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"A"</span>:</span><br><span class="line">            print(<span class="string">"Handler A processing request A."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">"B"</span>:</span><br><span class="line">            print(<span class="string">"Handler B processing request B."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.handler_chain = ConcreteHandlerA(ConcreteHandlerB())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        self.handler_chain.handle_request(request)</span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.make_request(<span class="string">"A"</span>)</span><br><span class="line">client.make_request(<span class="string">"B"</span>)</span><br></pre></td></tr></table></figure><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><p>Python은 절차 지향 언어일 뿐만 아니라 객체 지향 프로그래밍 스타일도 지원합니다. 디자인 패턴을 사용하면 Python의 객체 지향 기능을 더 잘 활용하여 코드를 더 유연하고, 읽기 쉽고, 유지보수가 용이하게 만들 수 있습니다.</p><p>파이썬에서의 디자인 패턴에는 팩토리 패턴, 싱글톤 패턴, 어댑터 패턴, 데코레이터 패턴, 옵저버 패턴 등이 포함됩니다. 이러한 패턴들은 다양한 프로그래밍 시나리오에 적용할 수 있으며, 소프트웨어 개발의 공통적인 문제를 해결하는 데 도움을 줍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/24/python-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알아두면 유용한 12가지 파이썬 라이브러리</title>
      <link>http://hgko1207.github.io/2024/10/22/python-6/</link>
      <guid>http://hgko1207.github.io/2024/10/22/python-6/</guid>
      <pubDate>Tue, 22 Oct 2024 06:25:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Python은 그 단순함, 가독성, 그리고 방대한 라이브러리 생태계 덕분에 매우 유용한 언어입니다. 많은 개발자들이 &lt;code&gt;NumPy&lt;/code&gt;, &lt;code&gt;pandas&lt;/code&gt;, &lt;code&gt;requests&lt;/code&gt;, &lt;code&gt;Fl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Python은 그 단순함, 가독성, 그리고 방대한 라이브러리 생태계 덕분에 매우 유용한 언어입니다. 많은 개발자들이 <code>NumPy</code>, <code>pandas</code>, <code>requests</code>, <code>Flask</code>와 같은 유명한 라이브러리에 익숙하지만, 그 외에도 생산성을 높이고 특정 문제를 더 효율적으로 해결할 수 있는 덜 알려진 라이브러리들이 많이 존재합니다.</p><p>이러한 라이브러리들은 잘 알려진 라이브러리들에 비해 덜 주목받지만, 작업을 단순화하고, 워크플로를 최적화하며, 프로젝트에 혁신을 가져올 수 있는 독특한 기능들을 제공합니다.</p><p>Python에는 매우 유용하지만 널리 알려지지 않은 라이브러리들이 많이 있습니다. 이러한 라이브러리는 반복 작업을 자동화하고, 데이터를 더 효율적으로 처리하며, 적은 코드로 강력한 애플리케이션을 구축하는 데 도움을 줄 수 있습니다.</p><p>이번 글에서는 파일 처리, 데이터 처리, 웹 개발 등 다양한 분야에 걸친 라이브러리들을 소개하며, 개발 과정을 더 원활하고 효율적으로 만드는 방법을 알아보겠습니다.</p><h2 id="1-WeasyPrint-HTML과-CSS를-PDF로-변환">1. WeasyPrint - HTML과 CSS를 PDF로 변환</h2><p><strong>WeasyPrint</strong>는 HTML과 CSS를 PDF로 변환할 수 있는 간단하고 우아한 라이브러리입니다. 다른 PDF 라이브러리와 달리 복잡한 레이아웃을 지원하며, 웹 기술을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weasyprint <span class="keyword">import</span> HTML</span><br><span class="line"></span><br><span class="line">html_content = <span class="string">"""&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;p&gt;This is a PDF generated</span></span><br><span class="line"><span class="string">from HTML and CSS.&lt;/p&gt;"""</span></span><br><span class="line"></span><br><span class="line">HTML(string=html_content).write_pdf(<span class="string">"output.pdf"</span>)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 청구서나 보고서와 같은 PDF 파일을 동적으로 생성해야 하는 웹 애플리케이션에서 사용할 수 있습니다.</p><h2 id="2-Pyexcel-간단한-엑셀-데이터-처리">2. Pyexcel - 간단한 엑셀 데이터 처리</h2><p><strong>Pyexcel</strong>은 다양한 형식(.xls, .xlsx, .ods)의 엑셀 파일을 읽고, 쓰고, 조작할 수 있는 경량 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyexcel <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">data = p.get_array(file_name=<span class="string">"example.xlsx"</span>)</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 프로젝트에서 여러 엑셀 형식을 처리해야 할 때 유용합니다.</p><h2 id="3-Pendulum-간단한-날짜-시간-처리">3. Pendulum - 간단한 날짜/시간 처리</h2><p><strong>Pendulum</strong>은 Python의 <code>datetime</code> 라이브러리를 대체할 수 있는 라이브러리로, 직관적이고 간단한 API를 제공하며, 시간대 지원, 파싱, 포맷팅, 날짜 연산 등을 포함합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pendulum</span><br><span class="line"></span><br><span class="line">now = pendulum.now(<span class="string">'UTC'</span>)</span><br><span class="line"></span><br><span class="line">print(now.to_datetime_string())</span><br><span class="line"><span class="comment"># 출력: 2024-10-22 6:32:10</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 표준 <code>datetime</code> 라이브러리로 처리하기 번거로운 많은 복잡한 날짜 계산을 단순화합니다. 서머타임 변환과 같은 까다로운 부분도 자동으로 처리할 수 있습니다.</p><h2 id="4-Tenacity-Python용-재시도-라이브러리">4. Tenacity - Python용 재시도 라이브러리</h2><p><strong>Tenacity</strong>는 네트워크 요청이나 데이터베이스 연결과 같이 신뢰할 수 없는 함수에 대한 재시도 로직을 간단하게 처리할 수 있는 범용 재시도 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(stop=stop_after_attempt(3))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unreliable_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Attempting to execute..."</span>)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Failed"</span>)</span><br><span class="line"></span><br><span class="line">unreliable_function()</span><br></pre></td></tr></table></figure><p>이 라이브러리는 간헐적인 네트워크 오류를 유연하게 처리하는 데 유용합니다. 수동으로 재시도 로직을 작성하지 않고, 함수에 데코레이터를 적용하여 코드 복잡성을 줄이고 신뢰성을 높일 수 있습니다.</p><h2 id="5-Dataset-간단한-데이터베이스-상호작용">5. Dataset - 간단한 데이터베이스 상호작용</h2><p><strong>Dataset</strong>은 SQL 데이터베이스와 Python 구문을 사용해 상호작용할 수 있는 데이터베이스 추상화 계층입니다. SQL을 작성하지 않고도 데이터베이스 기반 애플리케이션을 빠르게 프로토타입할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dataset</span><br><span class="line"></span><br><span class="line">db = dataset.connect(<span class="string">'sqlite:///mydatabase.db'</span>)</span><br><span class="line"></span><br><span class="line">db[<span class="string">'users'</span>].insert(dict(name=<span class="string">'hgko'</span>, age=<span class="number">30</span>))</span><br></pre></td></tr></table></figure><p>이 라이브러리는 복잡한 ORM 설정을 걱정하지 않고 데이터베이스 상호작용을 처리할 수 있어, 애플리케이션 로직에 집중할 수 있게 해줍니다.</p><h2 id="6-Poetry-의존성-관리-및-패키징">6. Poetry - 의존성 관리 및 패키징</h2><p><strong>Poetry</strong>는 Python 프로젝트 관리의 의존성 관리 및 패키징 도구입니다. 단순한 설정 파일로 의존성 관리, 빌드, PyPI에 배포까지 처리할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry new my_project</span><br><span class="line">poetry add pendulum</span><br><span class="line">poetry add requests</span><br></pre></td></tr></table></figure><p>이 라이브러리는 가상 환경 설정, 의존성 관리, 프로젝트 패키징 과정을 간소화하며, pip, pipenv, setup.py와 같은 도구를 하나의 통합된 솔루션으로 대체할 수 있습니다.</p><h2 id="7-Dask-병렬-컴퓨팅-및-태스크-스케줄링">7. Dask - 병렬 컴퓨팅 및 태스크 스케줄링</h2><p><strong>Dask</strong>는 유연한 병렬 컴퓨팅 라이브러리로, 기존 Python 코드에 쉽게 통합할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 큰 데이터셋 읽기</span></span><br><span class="line">df = dd.read_csv(<span class="string">'large_dataset.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 병렬로 그룹화 연산 수행</span></span><br><span class="line">result = df.groupby(<span class="string">'category'</span>).sum().compute()</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 메모리에 적재하기 어려운 대규모 데이터셋을 처리할 때 유용합니다. Dask는 태스크를 더 작은 청크로 나누어 병렬로 처리함으로써 처리 시간을 크게 줄일 수 있습니다.</p><h2 id="8-Faker-테스트를-위한-가짜-데이터-생성">8. Faker - 테스트를 위한 가짜 데이터 생성</h2><p><strong>Faker</strong>는 이름, 주소, 이메일, 전화번호 등과 같은 가짜 데이터를 생성할 수 있는 라이브러리입니다. 테스트, 데이터 생성, 데이터베이스 시드(seed) 작업에 유용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line">fake = Faker()</span><br><span class="line"></span><br><span class="line">print(fake.name())  <span class="comment"># 랜덤한 이름 출력</span></span><br><span class="line">print(fake.address())  <span class="comment"># 랜덤한 주소 출력</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 애플리케이션 성능을 테스트할 대규모 데이터셋이 필요할 때 유용합니다.</p><h2 id="9-FlashText-빠른-키워드-검색-및-치환">9. FlashText - 빠른 키워드 검색 및 치환</h2><p><strong>FlashText</strong>는 키워드 기반의 빠른 검색 및 치환을 위한 라이브러리입니다. 정규 표현식보다 키워드 검색 작업에 훨씬 효율적입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flashtext <span class="keyword">import</span> KeywordProcessor</span><br><span class="line"></span><br><span class="line">keyword_processor = KeywordProcessor()</span><br><span class="line">keyword_processor.add_keyword(<span class="string">'JavaScript'</span>, <span class="string">'JS'</span>)</span><br><span class="line"></span><br><span class="line">text = <span class="string">"JavaScript is a popular programming language."</span></span><br><span class="line"></span><br><span class="line">print(keyword_processor.replace_keywords(text))</span><br><span class="line"><span class="comment"># 출력: JS is a popular programming language.</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 수백만 개의 레코드에서 여러 키워드를 치환해야 하는 경우에 특히 유용합니다.</p><h2 id="10-PyPDF2-PDF-파일-조작">10. PyPDF2 - PDF 파일 조작</h2><p><strong>PyPDF2</strong>는 PDF 파일을 합치거나, 분할하거나, 회전하거나, 텍스트를 추출할 수 있는 라이브러리입니다. 자동화된 워크플로에서 PDF 문서를 처리할 때 적합합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfReader, PdfWriter</span><br><span class="line"></span><br><span class="line">reader = PdfReader(<span class="string">'input.pdf'</span>)</span><br><span class="line"></span><br><span class="line">writer = PdfWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> reader.pages:</span><br><span class="line">    writer.add_page(page)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output.pdf'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer.write(f)</span><br></pre></td></tr></table></figure><p>이 라이브러리는 여러 PDF 문서를 하나의 파일로 합치는 작업을 자동화하는 데 유용합니다.</p><h2 id="11-Humanize-데이터의-인간-친화적-변환">11. Humanize - 데이터의 인간 친화적 변환</h2><p><strong>Humanize</strong>는 숫자를 단어로 바꾸거나 날짜를 자연어로 표현하는 등 데이터를 더 읽기 쉽게 변환하는 도구를 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> humanize</span><br><span class="line"></span><br><span class="line">print(humanize.naturalsize(<span class="number">1024</span>))</span><br><span class="line"><span class="comment"># 출력: '1.0 kB'</span></span><br><span class="line"></span><br><span class="line">print(humanize.intword(<span class="number">1234567890</span>))</span><br><span class="line"><span class="comment"># 출력: '1.2 billion'</span></span><br></pre></td></tr></table></figure><p>이 라이브러리는 비기술적인 이해관계자에게 더 이해하기 쉬운 형식으로 데이터를 제시해야 하는 보고 도구에 특히 유용합니다.</p><h2 id="12-Memory-Profiler-Python-코드의-메모리-사용량-모니터링">12. Memory-Profiler - Python 코드의 메모리 사용량 모니터링</h2><p><strong>Memory-Profiler</strong>는 Python 프로그램의 메모리 사용량을 줄 단위로 모니터링할 수 있는 모듈입니다. 메모리 누수 식별이나 메모리 사용량 최적화에 유용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">my_func()</span><br></pre></td></tr></table></figure><p>이 라이브러리는 비효율적인 데이터 구조로 인해 메모리 사용량이 과도한 Python 스크립트를 최적화하는 데 사용할 수 있습니다. 병목 지점을 식별하고 애플리케이션의 메모리 사용량을 줄이는 데 도움이 됩니다.</p><h2 id="결론">결론</h2><p>Python의 방대한 생태계에는 잘 알려지지 않았지만 개발 경험을 크게 향상시킬 수 있는 라이브러리들이 많이 있습니다. 이러한 도구들을 적극적으로 사용해 보세요. 이러한 라이브러리들은 당신이 예상하지 못한 문제에 대한 해결책이 될 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/python-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot에서 데이터 캐싱 방법</title>
      <link>http://hgko1207.github.io/2024/10/22/spring-7/</link>
      <guid>http://hgko1207.github.io/2024/10/22/spring-7/</guid>
      <pubDate>Tue, 22 Oct 2024 04:00:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 시스템 실행 중 성능을 향상시키기 위해 데이터를 캐싱하는 몇 가지 기술을 살펴보겠습니다. 일반적으로 계산하는 데 시간이 오래 걸리는 값을 캐싱하면 나중에 액세스할 때 시간을 절약할 수 있습니다. 캐싱되는 값은 자주 변경되지 않거나, 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 시스템 실행 중 성능을 향상시키기 위해 데이터를 캐싱하는 몇 가지 기술을 살펴보겠습니다. 일반적으로 계산하는 데 시간이 오래 걸리는 값을 캐싱하면 나중에 액세스할 때 시간을 절약할 수 있습니다. 캐싱되는 값은 자주 변경되지 않거나, 최신 버전이 필요하지 않은 경우가 많습니다.</p><p><img src="/images/header/spring-7.png" alt=""></p><h2 id="Spring-Boot에서-캐싱">Spring Boot에서 캐싱</h2><p>Spring Boot REST API에서 캐싱을 활성화하는 가장 간단한 방법은 애플리케이션에 설정하고, 엔드포인트에 <code>@Cacheable</code> 어노테이션을 사용하는 것입니다.</p><p>애플리케이션에서 다음과 같이 <code>@EnableCaching</code> 어노테이션을 추가하기만 하면 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootCachingApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootCachingApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러에서, 캐싱하고자 하는 메서드에 <code>@Cacheable</code> 어노테이션을 추가합니다.</p><ul><li><code>/v1/status</code> API는 캐싱이 설정되지 않았으므로, 호출할 때마다 실제 메서드가 실행됩니다.</li><li><code>/v2/status</code> API는 캐싱이 설정되어 있으므로, 첫 번째 호출만 메서드를 실행하고 이후 호출에서는 캐싱된 결과를 반환합니다.</li><li><code>/v3/status</code> API는 캐싱 설정에 매개변수를 포함하여, 캐시가 매개변수에 따라 결과를 다르게 저장하도록 합니다. 즉, 이전에 사용된 매개변수로 호출하면 캐싱된 결과를 사용하고, 그렇지 않으면 메서드를 실행합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v1/status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V1 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"DONE"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v2/status"</span>)</span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V2 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"DONE"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v3/status/&#123;param&#125;"</span>)</span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"status"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">statusV3</span><span class="params">(@PathVariable <span class="keyword">final</span> <span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"status V3 called"</span>);</span><br><span class="line">    <span class="comment">// 약간의 무거운 처리</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(param == <span class="number">1</span> ? <span class="string">"DONE"</span> : <span class="string">"IN PROCESS"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JPA-캐싱">JPA 캐싱</h2><p>때로는 API의 결과를 캐싱할 수 없지만, 쿼리의 결과를 캐싱함으로써 동일한 쿼리를 여러 번 실행하는 것을 피할 수 있습니다. JPA와 Spring Boot는 이를 스마트하게 처리할 수 있습니다.</p><p>엔티티를 정의해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런 다음, 리포지토리에서 <code>@Cacheable</code> 어노테이션을 추가하여 결과를 캐시에 저장할 메서드를 지정합니다. <code>findById</code>와 같은 “standard” 메서드를 캐싱해야 하는 경우, 이를 오버라이드하고 어노테이션을 추가할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"customers"</span>)</span><br><span class="line">  <span class="function">Optional&lt;Customer&gt; <span class="title">findById</span><span class="params">(Long aLong)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"customers"</span>)</span><br><span class="line">  <span class="function">List&lt;Customer&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Caffeine">Caffeine</h2><p>일부 경우에는 REST 엔드포인트나 JPA 레벨에서 캐시를 사용할 수 없는 경우가 있습니다. 이때는 캐시를 수동으로 구현해야 하며, 이를 위해 <a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a> 라이브러리를 사용할 수 있습니다.</p><p>Caffeine은 캐시에 저장할 요소의 최대 개수를 정의하고 만료 조건을 설정할 수 있습니다.</p><p>프로젝트에 다음 의존성을 추가해야 합니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>사용법은 매우 직관적입니다:</p><ul><li>키와 값을 사용해 캐시를 정의합니다.</li><li>캐시의 최대 크기를 설정할 수 있습니다.</li><li>만료 기간을 설정할 수 있습니다.</li><li>build 메서드에서 캐시 미스가 발생했을 때 캐시를 채우는 방법을 정의합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Long, String&gt; customerCache =</span><br><span class="line">      Caffeine.newBuilder()</span><br><span class="line">          .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">          .expireAfterWrite(Duration.ofMinutes(<span class="number">5</span>))</span><br><span class="line">          .refreshAfterWrite(Duration.ofMinutes(<span class="number">1</span>))</span><br><span class="line">          .build(<span class="keyword">this</span>::findCustomerName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">findCustomerName</span><span class="params">(<span class="keyword">final</span> Long key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> customerRepository.findById(key).map(Customer::getName).orElse(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getCustomerName</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> customerCache.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getCustomerName</code>을 호출하면, 이 메서드는 캐시 정의에 따라 실행됩니다. 먼저, 해당 키와 일치하는 항목이 있는지 확인하고, 그렇지 않으면 <code>findCustomerName</code> 메서드를 호출해 캐시를 채웁니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/spring-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 성능 향상을 위한 작은 팁들</title>
      <link>http://hgko1207.github.io/2024/10/22/java-5/</link>
      <guid>http://hgko1207.github.io/2024/10/22/java-5/</guid>
      <pubDate>Tue, 22 Oct 2024 03:02:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;극한의 애플리케이션에서 성능을 최적화해야 하는 문제에 직면한 Java 개발자라면, 이는 쉽지 않은 과제임을 잘 아실 것입니다. 이 글에서는 시스템 아키텍처를 그대로 유지하면서 약간의 코드 수정을 통해 성능을 향상시킬 수 있는 몇 가지 전략과 요령
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>극한의 애플리케이션에서 성능을 최적화해야 하는 문제에 직면한 Java 개발자라면, 이는 쉽지 않은 과제임을 잘 아실 것입니다. 이 글에서는 시스템 아키텍처를 그대로 유지하면서 약간의 코드 수정을 통해 성능을 향상시킬 수 있는 몇 가지 전략과 요령을 살펴봅니다.</p><h2 id="극한-상황이란-무엇인가요"><a class="markdownIt-Anchor" href="#극한-상황이란-무엇인가요"></a> 극한 상황이란 무엇인가요?</h2><p>이 글에서 '극한 상황’이란 반복적인 작업을 수행하거나 대량의 데이터를 처리해야 하는 애플리케이션을 의미합니다. 이러한 요구는 다양한 분야에서 흔히 발생합니다.</p><ul><li><strong>금융 애플리케이션:</strong> 금융에서는 백그라운드 작업이 수백만에서 수십억 개의 레코드를 처리하는 일이 일반적입니다.</li><li><strong>머신 러닝:</strong> Java는 머신 러닝에 자주 사용되지는 않지만, 이러한 애플리케이션들은 대규모 데이터셋을 처리하는 경우가 많습니다.</li><li><strong>분석:</strong> 분석 애플리케이션은 대규모 데이터셋에 접근해 보고서를 생성하는 경우가 많습니다.</li></ul><h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2><p>대량의 데이터를 저장하기 위해 HashMap을 생성할 때는 문자열 대신 숫자 필드를 키로 사용하는 것이 좋습니다. 이를 설명하기 위해 각 키 유형에 대해 요소를 추가하는 경우와 요소를 액세스하는 경우를 비교해 보겠습니다.</p><p>아래 차트는 String 키와 Integer 키를 사용해 HashMap에 엔트리를 추가할 때의 실행 시간을 비교합니다. x축은 HashMap에 추가된 레코드 수를 나타내고, y축은 해당 작업을 100회 반복하는 데 소요된 시간을 나타냅니다.</p><p><img src="/images/header/java-5_1.png" alt="" /></p><p>Java는 HashMap 작업 처리에서 최적화된 성능을 보여주며, 특히 백만 개의 엔트리까지는 키 유형과 상관없이 일관된 성능을 유지합니다. 이는 Java의 해시 계산 메커니즘이 내부 구조에 숫자 값을 사용해 효율적으로 엔트리를 배치하기 때문입니다.</p><p>그러나 백만 개 이상의 엔트리를 처리하는 극한 상황에서는 성능 저하가 나타납니다. 이는 해시 함수가 서로 다른 엔트리에 대해 동일한 값을 생성하여, HashMap 내부에서 해시 충돌을 해결하기 위한 추가 처리가 발생하기 때문입니다. 특히 문자열 키를 사용할 때 이러한 성능 저하가 더 두드러집니다.</p><p>HashMap에서 요소를 액세스하기 위해 <code>get</code> 메서드를 사용할 때도 유사한 성능 패턴을 보이며, 이는 큰 데이터셋이나 해시 충돌을 처리할 때 성능 저하가 나타나는 현상을 반영합니다.</p><p><img src="/images/header/java-5_2.png" alt="" /></p><h2 id="bigdecimal-vs-biginteger-vs-long-vs-long"><a class="markdownIt-Anchor" href="#bigdecimal-vs-biginteger-vs-long-vs-long"></a> BigDecimal vs BigInteger vs Long vs long</h2><p>Java에서 대규모 데이터셋을 처리할 때는 수치 연산이 필요하며, 다양한 요구에 맞게 여러 데이터 타입을 제공합니다.</p><ul><li><strong>long:</strong> -2⁶³에서 2⁶³ - 1 사이의 정수를 저장할 수 있는 기본 타입입니다.</li><li><strong>Long:</strong> long 타입의 박싱된 객체 타입입니다.</li><li><strong>BigDecimal:</strong> 높은 정밀도로 큰 소수 값을 저장하기 위한 클래스입니다.</li><li><strong>BigInteger:</strong> long의 범위를 초과하는 큰 정수를 처리하기 위한 클래스입니다.</li></ul><p>금융이나 과학적 데이터 처리를 위해서는 정확한 소수 계산이 필요하므로 <strong>BigDecimal</strong>을 사용하는 것이 권장됩니다. 그러나 비소수 연산에서는 <strong>long</strong>, <strong>Long</strong>, <strong>BigInteger</strong>를 상황에 맞게 사용할 수 있습니다.</p><p>다음 차트는 각 데이터 타입으로 100만 개 요소를 생성했을 때의 메모리 사용량을 보여줍니다.</p><p><img src="/images/header/java-5_3.png" alt="" /></p><p>메모리 사용량 비교를 보면 <strong>Long</strong>(박싱된 타입), <strong>long</strong>(기본 타입), <strong>BigInteger</strong> 사이에 큰 차이가 있음을 알 수 있습니다. 특히 <strong>BigInteger</strong>로 100만 개 요소를 생성하면 60MB 이상의 메모리가 소모되지만, <strong>long</strong>을 사용하면 10MB 미만으로 메모리가 필요합니다. 이는 대규모 데이터셋을 처리하는 애플리케이션에서 메모리 할당을 고려해야 하는 중요성을 강조합니다.</p><h2 id="리스트-정렬"><a class="markdownIt-Anchor" href="#리스트-정렬"></a> 리스트 정렬</h2><p>Java는 효율적인 리스트 정렬로 잘 알려져 있지만, 몇 가지 고려 사항이 필요합니다. 여기서는 String을 비교 필드로 사용하는 리스트, Integer를 사용하는 리스트, 그리고 복잡한 객체(Complex Object)를 사용하는 리스트의 정렬 시간을 살펴보겠습니다. 각 리스트 유형(ArrayList, LinkedList, Vector)을 분석합니다.</p><p>ArrayList 중에서는 Integer 비교를 기반으로 한 정렬이 특히 백만 개 이상의 요소를 가진 리스트에서 빠른 성능을 보입니다. 반면, 복잡한 객체를 포함한 리스트의 정렬은 다른 유형에 비해 느립니다.</p><p><img src="/images/header/java-5_4.png" alt="" /></p><p>아래 차트는 ArrayList 대신 LinkedList를 사용한 경우를 비교한 것입니다. 동작은 일관되지만, Integer를 비교 기준으로 한 리스트의 정렬이 백만 개 이상의 요소를 처리할 때 더 빠르게 수행됩니다. 또한, ArrayList에 비해 전반적으로 실행 시간이 느린 점도 주목할 만합니다.</p><p><img src="/images/header/java-5_5.png" alt="" /></p><p>이번에는 종종 개발에서 간과되는 Java 리스트인 Vector를 살펴보겠습니다. 이전 비교와 유사한 패턴을 보이지만, Vector가 속도 면에서 다른 두 리스트보다 더 우수한 성능을 보여 다소 놀라운 결과를 나타냈습니다.</p><p><img src="/images/header/java-5_6.png" alt="" /></p><p>String, Integer, Complex Object를 사용하여 1000만 개 요소를 정렬하는 데 걸린 시간을 비교한 후 다음과 같은 결론을 도출할 수 있습니다.</p><ul><li>LinkedList는 긴 리스트를 정렬할 때 느린 성능을 보였습니다.</li><li>Vector는 정렬 시 가장 빠른 리스트 구현으로 나타났습니다.</li><li>숫자, 특히 Integer를 정렬하는 것이 다른 데이터 타입을 정렬하는 것보다 더 빠릅니다.</li></ul><p><img src="/images/header/java-5_7.png" alt="" /></p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>대량의 데이터를 처리하는 애플리케이션을 개발할 때 성능 최적화는 매우 중요한 과제입니다. 적절한 Java 리스트 구현을 선택하면 성능을 크게 향상시킬 수 있으며, 적절한 데이터 타입을 선택하면 시스템 성능을 향상시키는 동시에 메모리도 절약할 수 있습니다.</p><p>이 글에서는 대규모 데이터를 처리하는 애플리케이션에서 데이터 타입과 Java 리스트 구현을 신중하게 선택하는 것이 중요하다는 점을 강조했습니다. 처리하는 요소가 수천 개에 불과한 경우에는 성능 향상이 큰 의미가 없을 수 있으므로, 이러한 선택을 신중하게 고려해야 합니다.</p><p>많은 경우, Java 구현을 단순히 변경하는 것만으로는 시스템 아키텍처를 수정하거나 데이터베이스 쿼리를 최적화하는 것만큼 큰 성능 향상을 기대하기 어렵습니다. 적절한 데이터 타입과 리스트 구현을 선택하는 것도 중요하지만, 전반적인 아키텍처적 고려가 성능에 더 큰 영향을 미칠 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/22/java-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바 스트림의 7가지 활용 팁</title>
      <link>http://hgko1207.github.io/2024/10/21/java-4/</link>
      <guid>http://hgko1207.github.io/2024/10/21/java-4/</guid>
      <pubDate>Mon, 21 Oct 2024 05:19:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;스트림(Stream)은 여러 해 전 도입되었지만, Java 개발자들은 여전히 이 강력한 도구를 완전히 활용하지 못하고 있습니다. 이 글에서는 다음 프로젝트에 참고할 수 있는 유용한 스트림 활용 팁을 소개합니다.&lt;/p&gt;
&lt;p&gt;아래 예제에서는 다음 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>스트림(Stream)은 여러 해 전 도입되었지만, Java 개발자들은 여전히 이 강력한 도구를 완전히 활용하지 못하고 있습니다. 이 글에서는 다음 프로젝트에 참고할 수 있는 유용한 스트림 활용 팁을 소개합니다.</p><p>아래 예제에서는 다음 클래스들을 사용할 것입니다.</p><p><img src="/images/header/java-4_1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Address address;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Person&gt; personList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String street;</span><br><span class="line">  <span class="keyword">private</span> City city;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-메서드-참조를-사용하여-map-단순화하기">1. 메서드 참조를 사용하여 map 단순화하기</h2><p>다음 코드는 회사들의 주소에서 도시 이름을 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(company -&gt; company.getAddress().getCity().getName())</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 더 가독성 있게 다음과 같이 변경할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Null-체크하기">2. Null 체크하기</h2><p>위 코드를 null 체크와 함께 작성하면 다음과 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .filter(Objects::nonNull)</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-스트림을-단일-스트림으로-변환하기">3. 스트림을 단일 스트림으로 변환하기</h2><p>다음 코드는 모든 회사로부터 사람 목록을 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAllPerson</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Person의 리스트를 가진 리스트를 만듭니다.</span></span><br><span class="line">  List&lt;List&lt;Person&gt;&gt; partialResult = companyList.stream()</span><br><span class="line">    .map(Company::getPersonList)</span><br><span class="line">    .toList();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 각 Person 리스트를 결과에 추가합니다.</span></span><br><span class="line">  List&lt;Person&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  partialResult.forEach(result::addAll);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 동일한 작업을 다음과 같이 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAllPerson</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getPersonList) <span class="comment">// Stream&lt;List&lt;Person&gt;&gt;을 반환합니다.</span></span><br><span class="line">    .flatMap(List::stream)  <span class="comment">// Stream&lt;Person&gt;으로 변환합니다.</span></span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-속성별-그룹화하기">4. 속성별 그룹화하기</h2><p>다음 코드는 각 도시에 있는 회사 목록을 Map으로 반환합니다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;City, List&lt;Company&gt;&gt; getCompaniesByCity(List&lt;Company&gt; companyList)&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(company -&gt; company.getAddress().getCity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-스트림에-특정-항목이-있는지-확인하기">5. 스트림에 특정 항목이 있는지 확인하기</h2><p>다음 코드는 특정 도시에 회사가 있는지 확인합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCompanyInCity</span><span class="params">(List&lt;Company&gt; companyList, String cityName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .anyMatch(cityName::equals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 도시에 회사가 없는지를 확인하려면 noneMatch를 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNoCompanyInCity</span><span class="params">(List&lt;Company&gt; companyList, String cityName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .noneMatch(cityName::equals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-로깅하기">6. 로깅하기</h2><p>각 도시 이름을 반환할 때 로그를 기록하려면 peek 메서드를 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .peek(cityName -&gt; log.info(cityName))</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-고유한-도시-이름-가져오기">7. 고유한 도시 이름 가져오기</h2><p>distinct를 사용해 스트림에서 중복된 도시 이름을 제거할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUniqueCityNames</span><span class="params">(List&lt;Company&gt; companyList)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> companyList.stream()</span><br><span class="line">    .map(Company::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .distinct()</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>이 방법들을 통해 스트림을 보다 효과적으로 사용하고 코드의 가독성과 성능을 높일 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/21/java-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring Boot] 대용량 데이터 쿼리 REST 엔드포인트 처리</title>
      <link>http://hgko1207.github.io/2024/10/21/spring-6/</link>
      <guid>http://hgko1207.github.io/2024/10/21/spring-6/</guid>
      <pubDate>Mon, 21 Oct 2024 04:53:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/spring-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이 글에서는 메모리 소비 문제로 인해 기존 방식으로는 구현할 수 없는 REST 엔드포인트의 예를 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;시나리오&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/spring-6.png" alt="" /></p><p>이 글에서는 메모리 소비 문제로 인해 기존 방식으로는 구현할 수 없는 REST 엔드포인트의 예를 살펴보겠습니다.</p><h2 id="시나리오"><a class="markdownIt-Anchor" href="#시나리오"></a> 시나리오</h2><p>이번 예제에서는 Customer, Order, OrderItem, 그리고 Product로 구성된 간단한 시나리오를 사용합니다.</p><p><img src="/images/header/spring-6_1.png" alt="" /></p><p>우리의 목표는 보고서를 생성하는 엔드포인트를 만드는 것입니다. 이 엔드포인트는 다음 데이터를 쿼리하고 반환해야 합니다.</p><ul><li>백만 개의 주문(Orders)</li><li>500만 개 이상의 주문 항목(OrderItems)</li></ul><h2 id="기존-구현"><a class="markdownIt-Anchor" href="#기존-구현"></a> 기존 구현</h2><p>몇 가지 필드를 가진 DTO를 정의해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportDto</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Long orderId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LocalDate date;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String customerName;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer quantity;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리포지토리는 Order 엔티티를 위한 <code>CrudRepository</code>이며, JPA 관계를 통해 다른 데이터를 모두 가져올 수 있습니다. 여기서는 단순함을 위해 <code>findAll</code> 메서드를 사용하여 데이터를 반환합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스는 다음 작업을 수행합니다.</p><ul><li>결과를 저장할 <code>ArrayList</code>를 생성합니다.</li><li>리포지토리의 <code>findAll</code> 메서드를 호출해 주문 데이터를 가져옵니다.</li><li>쿼리 결과를 반복하여 DTO로 매핑합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ReportDto&gt; <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> ArrayList&lt;ReportDto&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> order : orderRepository.findAll()) &#123;</span><br><span class="line">      result.add(mapToOrder(order));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러는 단순히 서비스의 메서드를 호출하고 결과를 반환합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReportService reportService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/v1/report"</span>)</span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;List&lt;ReportDto&gt;&gt; report() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = reportService.getResult();</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>curl</code>을 사용해 엔드포인트를 테스트한 결과, 45분 후 다음과 같은 오류가 발생했습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"\n"</span> -X GET http://localhost:8000/v1/report</span><br><span class="line">&#123;<span class="string">"timestamp"</span>:<span class="string">"2024-06-21T19:50:05.720+00:00"</span>,<span class="string">"status"</span>:500,<span class="string">"error"</span>:<span class="string">"Internal Server Error"</span>,<span class="string">"path"</span>:<span class="string">"/v1/report"</span>&#125;</span><br></pre></td></tr></table></figure><p>서비스 출력에서 다음과 같은 로그를 확인할 수 있었습니다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Exception</span>: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread <span class="string">"http-nio-8000-Poller"</span></span><br><span class="line"><span class="keyword">Exception</span> in thread <span class="string">"mysql-cj-abandoned-connection-cleanup"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>데이터베이스 쿼리 결과가 사용 가능한 메모리보다 커서 데이터 쿼리에 실패했습니다.</p><h2 id="쿼리-해결"><a class="markdownIt-Anchor" href="#쿼리-해결"></a> 쿼리 해결</h2><p>첫 번째 단계는 대용량 데이터를 효율적으로 처리하기 위해 쿼리 프로세스를 개선하는 것입니다.</p><p>우선, 리포지토리에서 <code>List</code>이나 <code>Iterable</code> 대신 <code>Stream</code>을 반환하는 메서드를 정의해 보겠습니다. 반환 유형으로 <code>Stream</code>을 사용하면 데이터베이스에서 데이터를 한꺼번에 가져오지 않습니다. 대신 스트림을 소비하면서 청크 단위로 반환됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Stream&lt;Order&gt; <span class="title">findAllBy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스도 수정해야 합니다.</p><ul><li>리포지토리가 스트림을 반환하고 데이터가 데이터베이스에서 필요할 때만 가져오므로, 전체 실행 동안 트랜잭션을 열어 두어야 합니다. 읽기 전용 트랜잭션을 사용하기 위해 <code>@Transactional(readOnly = true)</code> 어노테이션을 사용합니다.</li><li>데이터베이스에서 데이터를 가져오는 스트림을 처리할 때 스트림을 올바르게 닫아야 하므로, <code>try-with-resources</code> 구문을 사용합니다.</li><li>JPA가 엔티티를 메모리에 계속 유지하지 않도록 <code>EntityManager</code>를 사용해 수동으로 분리(detach)합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ReportDto&gt; <span class="title">getResult2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> ArrayList&lt;ReportDto&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> orderStream = orderRepository.findAllBy()) &#123;</span><br><span class="line">      orderStream.forEach(</span><br><span class="line">          order -&gt; &#123;</span><br><span class="line">            result.add(mapToOrder(order));</span><br><span class="line">            entityManager.detach(order);</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러는 동일하지만 이제 API 버전 2를 참조합니다. 이를 통해 다음과 같은 응답을 얻을 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"\n"</span> -X GET http://localhost:8000/v2/report</span><br></pre></td></tr></table></figure><p>응답</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"orderId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"date"</span>:<span class="string">"2022-08-25"</span>,</span><br><span class="line">    <span class="attr">"customerName"</span>:<span class="string">"Booker"</span>,</span><br><span class="line">    <span class="attr">"totalAmount"</span>:<span class="number">19104.36</span>,</span><br><span class="line">    <span class="attr">"currency"</span>:<span class="string">"CDF"</span>,</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"Shipped"</span>,</span><br><span class="line">    <span class="attr">"paymentMethod"</span>:<span class="string">"Credit Card"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">93</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Rustic Bronze Bag"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">41</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">465.96</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">19104.36</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"orderId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"date"</span>:<span class="string">"2022-03-29"</span>,</span><br><span class="line">    <span class="attr">"customerName"</span>:<span class="string">"Danielle"</span>,</span><br><span class="line">    <span class="attr">"totalAmount"</span>:<span class="number">14685.35</span>,</span><br><span class="line">    <span class="attr">"currency"</span>:<span class="string">"MUR"</span>,</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"Processing"</span>,</span><br><span class="line">    <span class="attr">"paymentMethod"</span>:<span class="string">"Credit Card"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">52</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Mediocre Copper Bench"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">98</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">46.02</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">4509.96</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">71</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Fantastic Bronze Hat"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">31</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">233.61</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">7241.91</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"productId"</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="attr">"productName"</span>:<span class="string">"Mediocre Silk Bottle"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>:<span class="number">22</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">133.34</span>,</span><br><span class="line">        <span class="attr">"totalAmount"</span>:<span class="number">2933.48</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>JPA 메모리 문제를 해결했지만, 결과를 반환하는 데 42분이 소요되었습니다. 더 나은 방법이 필요해 보입니다.</p><h2 id="결과-스트리밍"><a class="markdownIt-Anchor" href="#결과-스트리밍"></a> 결과 스트리밍</h2><p>Java가 대량의 데이터를 처리하는 데 시간이 오래 걸리는 이유는 데이터 구조가 커질수록 성능이 저하되기 때문입니다. 해결책은 스트림을 사용해 데이터를 반환하는 것입니다. 클라이언트 측에서는 파일을 다운로드하는 것과 유사하게 서버가 데이터를 청크 단위로 전송합니다.</p><p>컨트롤러는 이제 <code>StreamingResponseBody</code>를 반환합니다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/v3/report"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;StreamingResponseBody&gt; <span class="title">report3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = reportService.getResult();</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서비스 클래스도 몇 가지 변경 사항이 필요합니다.</p><ul><li>스트림을 사용해 데이터를 반환하므로, <code>TransactionTemplate</code>을 사용해 트랜잭션을 수동으로 제어해야 합니다. 이를 위해 <code>PlatformTransactionManager</code>가 필요하며, 생성자에서 전달받습니다.</li><li><code>TransactionTemplate</code>을 사용해 핵심 실행 로직을 캡슐화하고, <code>fillStream</code> 메서드가 이를 수행합니다.</li><li><code>fillStream</code> 메서드는 <code>ObjectMapper</code>를 사용해 결과를 JSON으로 변환합니다. 데이터베이스에서 각 주문을 가져와 DTO로 매핑하고, JSON으로 변환한 후 <code>StreamingResponseBody</code>에 씁니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReportService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      PlatformTransactionManager platformTransactionManager,</span></span></span><br><span class="line"><span class="function"><span class="params">      OrderRepository orderRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">      EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionTemplate = <span class="keyword">new</span> TransactionTemplate(platformTransactionManager);</span><br><span class="line">    <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line"></span><br><span class="line">    objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StreamingResponseBody <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> outputStream -&gt; transactionTemplate.execute(</span><br><span class="line">        <span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            fillStream(outputStream);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillStream</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> orderStream = orderRepository.findAllBy()) &#123;</span><br><span class="line">      orderStream.forEach(order -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> json = objectMapper.writeValueAsString(mapToOrder(order));</span><br><span class="line">          outputStream.write(json.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">          entityManager.detach(order);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 변경 사항을 적용한 후, 엔드포인트를 호출하면 몇 초 후부터 응답을 받을 수 있습니다. 데이터가 스트리밍 방식으로 반환되므로, Java가 이를 처리하는 데 사용하는 메모리 양은 매우 적어져 성능이 크게 향상됩니다. 실제로, 성능 개선 효과는 매우 커서 실행 시간이 42분에서 단 30초로 줄어들었습니다!</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>쿼리 자체를 최적화해, 데이터베이스 조회 횟수를 줄이는 방식으로 DTO 형식의 결과를 직접 반환하는 특정 쿼리를 사용하면 이 코드를 더욱 개선할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/21/spring-6/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
