<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Fri, 18 Oct 2024 06:32:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>가장 강력한 머신 러닝 모델 설명 (Transformers, CNNs, RNNs, GANs 등)</title>
      <link>http://hgko1207.github.io/2024/10/18/ai-27/</link>
      <guid>http://hgko1207.github.io/2024/10/18/ai-27/</guid>
      <pubDate>Fri, 18 Oct 2024 05:35:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;머신 러닝은 방대한 분야이며, 현재 기술의 최전선에 있는 모델과 기법들을 개괄적으로 다룬 자료를 찾는 것이 어렵게 느껴질 수 있습니다. 따라서, 이 글에서
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-27.png" alt=""></p><p>머신 러닝은 방대한 분야이며, 현재 기술의 최전선에 있는 모델과 기법들을 개괄적으로 다룬 자료를 찾는 것이 어렵게 느껴질 수 있습니다. 따라서, 이 글에서는 각 모델을 과학적으로 분석하기보다는 개념적으로 탐구해보겠습니다. 각 모델에 대해 더 깊이 파고들기를 권장하며, 이론이 실무와 연결되어야 한다고 생각하기 때문에 실제 사용 예시도 제공하겠습니다. 만약 빠진 정보가 있다면 피드백을 주시고, 추가 정보를 요청해주세요.</p><p>시작하기 전에 다룰 모델 목록은 다음과 같습니다.</p><ul><li>CNN (Convolutional Neural Networks)</li><li>RNN (Recurrent Neural Networks)</li><li>Transformers</li><li>GAN (Generative Adversarial Networks)</li></ul><h2 id="CNN-합성곱-신경망">CNN (합성곱 신경망)</h2><p>CNN(Convolutional Neural Network, 합성곱 신경망)은 신경망의 한 종류로, 토폴로지 데이터(위상적 데이터)에 뛰어나며 패턴 감지에 특화되도록 수정된 모델입니다. 그렇다면 CNN은 어떻게 다를까요? 시작하기 전에, 신경망이 무엇인지 간단히 설명해 드리겠습니다.</p><p>간단히 말해, 신경망은 입력 데이터를 처리하여 출력을 생성하는 &quot;노드의 맵&quot;입니다. 신경망은 입력을 결과로 변환하면서 한 레이어의 노드 집합을 다른 레이어의 노드 집합으로 매핑하는 여러 레이어로 구성되어 있습니다. 이 매핑 과정은 가중치(weights)를 통해 이루어지며, 이는 입력을 변경하여 원하는 결과를 도출하는 데 사용됩니다. 각 단계 후에는 편향(bias)이 적용됩니다. 학습 과정에서 변경되는 것은 바로 이 가중치와 편향입니다.</p><p><img src="/images/header/ai-27_1.png" alt=""></p><h3 id="CNN의-특별한-점은-무엇일까요">CNN의 특별한 점은 무엇일까요?</h3><p>CNN을 다른 신경망과 구분 짓는 것은 바로 <strong>합성곱 레이어</strong>(convolutional layers)를 사용하는 점입니다. CNN은 다른 유형의 레이어도 가질 수 있지만, 합성곱이 그만의 독특함을 부여합니다. 다음은 이 레이어가 어떻게 작동하는지 설명입니다.</p><p>이미지의 각 픽셀이 밝기 값이라고 가정하면, 이미지는 2차원 숫자 행렬로 표현될 수 있습니다. 합성곱은 이 행렬에 커널(kernel)을 적용하여 출력 행렬을 생성합니다. 커널은 이미지의 각 영역에 필터처럼 작용하는 작은 행렬입니다.</p><p>이 작은 커널 행렬은 이미지라는 큰 행렬을 &quot;Steps&quot;하며 출력 행렬을 생성합니다.</p><p><img src="/images/header/ai-27_2.gif" alt=""></p><h3 id="주요-개념">주요 개념</h3><p>몇 가지 중요한 개념은 다음과 같습니다.</p><ul><li>커널은 이미지의 각 픽셀과 그 주변 영역에 적용되지만, 전체적으로 동일하게 유지됩니다. 이는 커널이 해당 픽셀 영역의 패턴이나 특징을 감지하기 위한 것이기 때문입니다.</li><li>커널은 이미지보다 훨씬 작기 때문에 학습 과정에서 큰 도움이 됩니다.</li><li>커널의 아이디어는 어떤 이미지든 우리가 분해할 수 있는 패턴들의 집합이라는 점에 기반합니다. 예를 들어, 얼굴을 가지고 있다고 가정해봅시다. 동그라미를 감지할 수 있는 커널이 있다고 할 때, 이 커널의 출력은 이미지 상단 부분(눈 부분)에 두 개의 밝은 점을 생성할 수 있습니다. 이제 가까운 두 개의 선을 감지하는 커널을 사용하면, 출력은 하단 부분(입 부분)에 밝은 점을 생성합니다. 마지막으로, 이러한 두 개의 동그라미와 하단의 두 선을 감지할 수 있는 커널이 있다면, 이는 얼굴을 인식할 수 있게 됩니다.</li><li>합성곱 레이어는 이러한 커널을 여러 개 적용하여 여러 개의 새로운 이미지를 생성할 수 있습니다. 이러한 이미지는 네트워크에서 다음 레이어로 전달되며, 이후 또 다른 합성곱 레이어가 다른 커널을 적용합니다.</li><li>CNN은 보통 이미지의 크기와 복잡성을 줄이기 위해 풀링 레이어(<strong>pooling</strong> layers)를 포함합니다.</li></ul><p>물론, 여기에는 더 많은 수학적 상세 정보가 있지만, CNN의 주요 직관은 <strong>커널</strong>에 있습니다.</p><p>CNN을 사용하는 인기 있는 도구와 제품으로는 Google Photos, DeepMind의 AlphaGo, Tesla의 자율주행 시스템 등이 있습니다.</p><h2 id="RNN-순환-신경망">RNN (순환 신경망)</h2><p>CNN이 주로 이미지 처리에 사용되는 반면, RNN은 주로 자연어 처리(NLP)와 시계열 분석과 같은 분야에 사용됩니다. RNN의 아키텍처를 이해하려면, 먼저 NLP 문제에서 단순한 신경망을 사용하는 데 있어서의 문제점을 살펴보겠습니다.</p><p>예를 들어, 텍스트 자동 완성 문제를 생각해 봅시다. 모델의 입력은 텍스트 조각이고, 출력 역시 또 다른 텍스트 조각입니다. 문제는 입력이 <strong>가변적인 크기</strong>(몇 단어일 수도 있고 많은 단어일 수도 있음)라는 점입니다. 단순 신경망은 일반적으로 <strong>고정된 입력 크기</strong>를 가지기 때문에 이러한 문제를 처리하기 어렵습니다. 또 다른 문제는 입력 내 단어들 간의 복잡한 관계를 포착하여 올바른 출력을 생성하는 것입니다. 예를 들어, 영어에는 수천 개의 단어가 있으며, 문장에서 단어의 순서가 의미를 크게 변경하지 않을 수 있습니다. 예를 들어, &quot;The fluffy cat came here on Sunday&quot;와 &quot;On Sunday, the cat which was fluffy came here&quot;는 유사한 의미를 가지지만, &quot;The Sunday came here on a fluffy cat&quot;은 다른 의미를 가집니다. 그렇다면 어떻게 이러한 문장이 유사하게 처리되도록 할까요?</p><p>RNN의 핵심 개념은 정보가 네트워크를 통과하는 방식에서 비롯됩니다. 예를 들어, &quot;The cat eats&quot;라는 문장을 RNN이 어떻게 처리하는지 살펴봅시다.</p><p>문장을 “The”, “cat”, &quot;eats&quot;와 같은 단어들의 시퀀스로 생각해 봅시다(실제로는 숫자나 벡터의 시퀀스로 표현될 것입니다). RNN은 이 시퀀스를 순차적으로 처리합니다. 먼저, 단어 &quot;The&quot;를 입력으로 받아 가중치와 편향을 통해 x1이라는 출력을 생성합니다. 그 다음, RNN은 x1과 시퀀스의 다음 단어인 &quot;cat&quot;을 받아, 같은 가중치와 편향을 통해 x2를 생성합니다. 이후, x2와 다음 단어인 &quot;eats&quot;를 사용하여 x3을 생성합니다. 이와 같은 방식으로, RNN은 이전 출력과 다음 입력을 결합하여 새로운 출력을 생성합니다. RNN의 현재 상태를 은닉 상태(<strong>hidden state</strong>)라고 부릅니다.</p><p><img src="/images/header/ai-27_3.gif" alt=""></p><h3 id="어떻게-RNN을-사용해-다음-단어를-예측할-수-있을까요">어떻게 RNN을 사용해 다음 단어를 예측할 수 있을까요?</h3><p>각 출력(x1, x2, x3)이 실제로 새로운 단어를 나타낸다고 가정해 보세요. 모델을 학습시켜 출력이 실제로 다음 단어를 예측하도록 할 수 있습니다. 예를 들어, 다음과 같이 문장을 처리한다고 해봅시다.</p><ol><li>“The” -&gt; 모델을 통과 -&gt; x0 생성, x0이 &quot;cat&quot;으로 올바르게 예측되도록 모델을 학습시킵니다.</li><li>&quot;cat&quot;과 이전 출력 x0 -&gt; 모델을 통과 -&gt; x1 생성, x1이 &quot;eats&quot;로 올바르게 예측되도록 학습합니다.</li><li>&quot;eats&quot;와 이전 출력 x1 -&gt; 모델을 통과 -&gt; x2 생성. 이때, x2가 &quot;tuna&quot;라는 단어를 나타내도록 학습됩니다. 이제 이를 다음 입력으로 사용할 수 있습니다.</li><li>&quot;tuna&quot;와 이전 출력 x2 -&gt; 모델을 통과 -&gt; x3 생성… 이와 같은 방식으로 계속 진행됩니다.</li></ol><h3 id="주요-개념-2">주요 개념</h3><p>RNN의 주요 개념은 다음과 같습니다.</p><ul><li>RNN은 은닉 상태를 통해 이전에 본 정보를 항상 추적할 수 있으며, 이는 단어들 간의 관계나 일련의 데이터를 포착하는 데 유용합니다.</li><li><strong>동일한 모델</strong>이 시퀀스의 각 부분에 반복적으로 적용되기 때문에, RNN은 학습하기에 적합합니다(거대한 모델로 전체 입력을 한꺼번에 처리하는 것보다 효율적임).</li></ul><p>하지만 이 접근 방식의 문제점도 이미 예상할 수 있습니다. 텍스트가 길어질수록 초기의 몇 단어가 현재의 은닉 상태에 거의 영향을 미치지 못해 이상적이지 않습니다. 또한, 이 방식은 순차적으로 처리해야 하므로, 처리 속도와 학습 속도가 알고리즘 자체에 의해 제한됩니다.</p><p>여전히 RNN은 매우 강력한 모델이며, 더 깊게 탐구해 볼 것을 권장합니다!</p><p>RNN을 사용하는 대표적인 도구와 제품으로는 Google 번역, OpenAI의 GPT-2, Spotify의 추천 시스템 등이 있습니다.</p><h2 id="Transformer-트랜스포머">Transformer (트랜스포머)</h2><p>트랜스포머! 현재 머신 러닝 세계에서 가장 주목받고 있는 기술입니다. GPT-4와 BERT(구글의 고급 언어 모델) 모두 트랜스포머 아키텍처를 기반으로 하고 있습니다. 그렇다면 트랜스포머란 무엇일까요?</p><p>트랜스포머는 RNN처럼 주로 NLP 문제를 해결하는 데 사용되며, 앞서 설명한 언어 처리와 관련된 유사한 문제들을 해결해야 합니다. 그러나, RNN과는 다르게 이러한 문제들을 해결하기 위한 몇 가지 주요한 아이디어를 가지고 있습니다.</p><ul><li><strong>위치 인코딩(Positional Encoding)</strong> — RNN은 은닉 상태를 통해 자연스럽게 언어의 순서를 유지하지만, 트랜스포머는 이 정보를 입력에 직접적으로 추가합니다. 위치 인코딩이 단어 임베딩(단어의 벡터 표현)에 더해져, 문장 내 각 단어의 위치를 파악할 수 있도록 합니다. 예를 들어, &quot;dog&quot;의 표현은 텍스트 내 위치에 따라 다르게 조정됩니다.</li><li><strong>대규모 학습 데이터셋(Huge training dataset size)</strong> — 위치 인코딩의 이점을 활용하기 위해, 트랜스포머는 방대한 데이터셋을 통해 학습해야 합니다. 이러한 순서의 차이와 단어 유형은 데이터에 반영되기 때문에, 다양한 가능성을 충분히 학습하지 않으면 모델의 성능이 떨어집니다.</li><li><strong>자기 주의(Self-attention)</strong> — 모델은 입력에서 특정 단어들과 다른 모든 단어들 간의 관계를 더 중요하게 여기는 법을 학습합니다. 결국, 어떤 단어들은 예측이나 번역에서 더 많은 의미를 가지고 있으며, 다른 단어들과 함께 사용될 때 더 강한 힘을 발휘합니다. 트랜스포머는 이를 대규모 학습 데이터와 자체적인 아키텍처를 통해 학습합니다.</li></ul><p>트랜스포머의 아키텍처는 다소 복잡하며, 짧은 글에서 설명하기 어렵지만, 여기서 간단하게 개략적인 설명을 드리겠습니다. 트랜스포머는 <strong>인코더</strong>(Encoder)와 <strong>디코더</strong>(Decoder)로 구성됩니다. 인코더는 동일한 레이어들의 스택으로 이루어져 있으며, 텍스트를 처리하여 디코더에 필요한 중요한 정보를 제공합니다. 디코더는 이 입력을 받아, 동일한 레이어 스택을 통해 우리가 원하는 출력을 생성하는 역할을 합니다. 아래 그림은 이 아키텍처를 보여주는 이미지입니다.</p><p><img src="/images/header/ai-27_4.png" alt=""></p><p>특히 트랜스포머의 핵심인 “자기 주의(Self-attention)” 메커니즘에 대해 깊이 공부해 보시기를 추천드립니다.</p><h2 id="GAN-생산적-적대-신경망">GAN (생산적 적대 신경망)</h2><p>GANs(Generative Adversarial Networks, 생성적 적대 신경망)은 기본적으로 두 개의 대립하는 모델이 서로 경쟁하는 구조입니다. GAN은 보통 이러한 모델들을 학습시키는 방법을 가리키며, 모델 자체보다는 학습 방식에 초점을 맞춥니다. 사실, 두 모델의 아키텍처가 중요한 것은 아니며, 하나는 생성 모델(Generative Model)이고 다른 하나는 판별 모델(Classifier, 또는 Discriminator)이기만 하면 됩니다.</p><p>먼저, 표준적인 지도 학습 기법을 설명해 보겠습니다.</p><ul><li>모델에 입력 데이터를 제공하고, 모델이 출력을 생성합니다.</li><li>이 출력과 원하는 출력(정답)을 비교하여, 모델이 더 나은 결과를 내도록 업데이트합니다.</li></ul><p>그러나 우리가 생성 모델을 만들고자 할 때 문제가 발생합니다. 이 모델은 현실적인 출력을 생성해야 하지만, 그 출력이 꼭 우리가 가지고 있는 데이터와 동일할 필요는 없습니다(예: 이미지 생성 또는 음악 생성). 바로 이때 GAN이 유용하게 쓰입니다. GAN에는 두 개의 모델이 있는데, 생성자(Generator) 모델과 판별자(Discriminator) 모델입니다.</p><p><strong>예시를 들어 설명해 보겠습니다.</strong></p><p>생성자 모델이 이미지를 생성한다고 가정해 봅시다. 먼저 이 모델을 이용해 여러 개의 가짜 이미지를 생성하도록 합니다. 그리고 실제 이미지를 몇 개 찾아서 이 가짜 이미지들과 결합합니다. 그런 다음, 이 이미지들을 판별자 모델에 입력하여 진짜인지 가짜인지를 구분하게 합니다. 만약 생성자 모델이 잘 작동한다면, 판별자 모델은 진짜와 가짜를 구분하기 어려워할 것이며, 진짜인지 가짜인지 맞출 확률이 약 50%에 가까워집니다. 당연히 초기에는 판별자가 더 잘 구분합니다(판별자는 보통 사전 학습이 약간 되어 있음). 따라서, 지도 학습 방식으로(우리 스스로 어떤 이미지가 진짜인지 가짜인지 알고 있기 때문에) 판별자 모델을 더 잘 학습시키게 됩니다. 또한, 생성자 모델도 판별자를 얼마나 잘 속였는지에 따라 학습할 수 있습니다. 학습은 생성자 모델이 판별자를 약 50% 확률로 속일 수 있을 때 완료됩니다.</p><p><img src="/images/header/ai-27_5.png" alt=""></p><p>GAN이 실제로 사용되는 몇 가지 예로는 Runway ML, Midjourney의 아트 생성, OpenAI의 DALL·E가 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/18/ai-27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>꼭 알아야 할 시스템 설계 용어 50가지</title>
      <link>http://hgko1207.github.io/2024/10/17/info-30/</link>
      <guid>http://hgko1207.github.io/2024/10/17/info-30/</guid>
      <pubDate>Thu, 17 Oct 2024 03:46:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;시스템 설계 면접은 지원자가 확장 가능하고 효율적인 시스템을 만들 수 있는지를 검증하는 데 있어 항상 중요한 요소입니다. 주요 용어에 대한 지식은 면접
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-30.png" alt=""></p><p>시스템 설계 면접은 지원자가 확장 가능하고 효율적인 시스템을 만들 수 있는지를 검증하는 데 있어 항상 중요한 요소입니다. 주요 용어에 대한 지식은 면접에서 좋은 점수를 받는 데 도움이 될 것입니다. 아래는 반드시 알아야 할 시스템 설계 면접 용어 50가지에 대한 정의와 실제 예시시를 학습을 위한 추가 자료와 함께 설명합니다.</p><h2 id="1-Scalability">1. Scalability</h2><ul><li><strong>정의:</strong> 리소스를 추가하여 증가하는 부하를 지원할 수 있는 시스템의 능력입니다.</li><li><strong>예시:</strong> 웹 트래픽 증가를 처리하기 위해 서버를 더 추가합니다.</li><li><a href="https://www.geeksforgeeks.org/what-is-scalability/" target="_blank" rel="noopener">What is Scalability and How to Achieve it?</a></li></ul><h2 id="2-Load-Balancer-로드-밸런서">2. Load Balancer(로드 밸런서)</h2><ul><li><strong>정의:</strong> 들어오는 네트워크 트래픽을 여러 서버로 분할하여 한 서버에서 많은 양의 부하를 처리하지 않도록 합니다.</li><li><strong>예시:</strong> AWS Elastic Load Balancer(ELB) 서비스를 사용하여 여러 EC2 인스턴스 간에 웹 트래픽 부하를 분산합니다.</li><li><a href="https://www.f5.com/glossary/load-balancer" target="_blank" rel="noopener">로드 밸런서 이해</a></li></ul><h2 id="3-Microservice-마이크로서비스">3. Microservice(마이크로서비스)</h2><ul><li><strong>정의:</strong> 느슨하게 결합된 서비스들의 모음으로 애플리케이션을 구조화하는 아키텍처 패턴입니다.</li><li><strong>예시:</strong> 모놀리식(monolithic) 애플리케이션을 사용자 관리, 결제 처리, 알림 전송을 담당하는 독립적인 서비스로 세분화합니다.</li><li><a href="https://aws.amazon.com/ko/microservices/" target="_blank" rel="noopener">마이크로서비스란 무엇인가요?</a></li></ul><h2 id="4-CAP-Theorem-CAP-정리">4. CAP Theorem(CAP 정리)</h2><ul><li><strong>정의:</strong> 분산 시스템에서는 일관성, 가용성, 분할 허용성이라는 세 가지 보장 중 최대 두 가지만 얻을 수 있다는 것을 의미합니다.</li><li><strong>예시:</strong> 분산 데이터베이스 설계에서 가용성을 위해 일관성을 희생해야 하는 경우(또는 그 반대의 경우)</li><li><a href="https://www.scylladb.com/glossary/cap-theorem/" target="_blank" rel="noopener">CAP 정리 이해하기</a></li></ul><h2 id="5-Sharding-샤딩">5. Sharding(샤딩)</h2><ul><li><strong>정의:</strong> 더 나은 관리를 위해 대규모 데이터베이스를 샤드라고 하는 작은 조각으로 나누는 것을 말합니다.</li><li><strong>예시:</strong> 지리적 지역을 기반으로 사용자 데이터베이스를 샤딩합니다.</li><li><a href="https://aws.amazon.com/what-is/database-sharding/" target="_blank" rel="noopener">데이터베이스 샤딩 설명</a></li></ul><h2 id="6-Latency">6. Latency</h2><ul><li><strong>정의:</strong> 데이터가 A 지점에서 B 지점까지 이동하는 데 걸리는 시간으로 정의됩니다.</li><li><strong>예시:</strong> 채팅 애플리케이션을 통한 메시지 전달과 관련된 지연 시간 측정.</li><li><a href="https://www.cloudflare.com/ko-kr/learning/performance/glossary/what-is-latency/" target="_blank" rel="noopener">지연 시간에 대해 설명!</a></li></ul><h2 id="7-Throughput-쓰루풋">7. Throughput(쓰루풋)</h2><ul><li><strong>정의:</strong> 시스템이 일정 시간 내에 처리하는 데이터의 양을 측정한 것 입니다. 처리율, 처리량라고도 불립니다.</li><li><strong>예시:</strong> 웹 서버가 1초 동안 처리하는 요청 수입니다.</li><li><a href="https://www.techtarget.com/searchnetworking/definition/throughput" target="_blank" rel="noopener">컴퓨터 네트워크에서의 처리량(Throughput)</a></li></ul><h2 id="8-캐시-Cache">8. 캐시(Cache)</h2><ul><li><strong>정의:</strong> 동일한 데이터를 반복 요청할 필요가 없도록 데이터를 저장하고 빠르게 제공하는 하드웨어 또는 소프트웨어 구성 요소</li><li><strong>예시:</strong> 반복적인 데이터베이스 쿼리를 위해 Redis 캐싱을 구현하는 것</li><li><a href="https://aws.amazon.com/ko/caching/" target="_blank" rel="noopener">캐싱 설명</a></li></ul><h2 id="9-Content-Delivery-Network-CDN">9. Content Delivery Network(CDN)</h2><ul><li><strong>정의:</strong> 지리적으로 분산된 서버 시스템으로, 사용자가 액세스하는 지리적 위치에 따라 웹 콘텐츠를 사용자에게 표시합니다.</li><li><strong>예시:</strong> 더 빠른 웹 페이지 로딩을 위해 Cloudflare CDN 사용.</li><li><a href="https://www.cloudflare.com/ko-kr/learning/cdn/what-is-a-cdn/" target="_blank" rel="noopener">CDN이란 무엇인가요?</a></li></ul><h2 id="10-REST-API">10. REST API</h2><ul><li><strong>정의:</strong> HTTP 요청을 사용하여 데이터에 액세스하고 조작하는 웹 서비스를 구축하도록 설계된 아키텍처 스타일의 한 유형입니다.</li><li><strong>예시:</strong> REST(Representational State Transfer) 원칙에 따른 소셜 미디어 API 설계.</li><li><a href="https://restfulapi.net/" target="_blank" rel="noopener">REST API 튜토리얼</a></li></ul><h2 id="11-GraphQL">11. GraphQL</h2><ul><li><strong>정의:</strong> 데이터를 쿼리하도록 설계된 언어이므로 REST보다 훨씬 더 강력하고 효율적이며 유연합니다.</li><li><strong>예시:</strong> GraphQL을 사용하여 단일 요청으로 사용자 정보 쿼리.</li><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-graphql" target="_blank" rel="noopener">GraphQL 소개</a></li></ul><h2 id="12-ACID">12. ACID</h2><ul><li><strong>정의:</strong> 데이터베이스 트랜잭션의 안정적인 처리를 보장하는 속성 집합입니다. 속성은 원자성, 일관성, 고립성 및 내구성입니다.</li><li><strong>예시:</strong> 은행 거래에 ACID 속성이 있는지 확인하면 데이터 손상을 방지할 수 있습니다.</li><li><a href="https://www.geeksforgeeks.org/acid-properties-in-dbms/" target="_blank" rel="noopener">데이터베이스의 ACID 속성</a></li></ul><h2 id="13-BASE">13. BASE</h2><ul><li><strong>정의:</strong> ACID의 대안으로, 엄격한 일관성(Consistency)보다 가용성(Availability)과 파티션 허용성(Partition tolerance)을 강조하는 시스템. 기본적으로 가용하며(Basically Available), 변화하는 상태를 허용하고(Soft state), 결국에는 일관성을 이루는(Eventually consistent) 시스템.</li><li><strong>예시:</strong> 높은 가용성과 최종 일관성을 제공하는 NoSQL 데이터베이스의 설계.</li><li><a href="https://aws.amazon.com/ko/compare/the-difference-between-acid-and-base-database/" target="_blank" rel="noopener">BASE vs ACID</a></li></ul><h2 id="14-NoSQL">14. NoSQL</h2><ul><li><strong>정의:</strong> 관계형 데이터베이스에서 사용되는 표 형식의 관계가 아닌 다른 방식으로 모델링된 데이터의 저장 및 검색을 촉진하도록 설계된 데이터베이스 유형입니다.</li><li><strong>예시:</strong> 문서 기반 데이터 저장소에 MongoDB 사용.</li><li><a href="https://www.mongodb.com/resources/basics/databases/nosql-explained" target="_blank" rel="noopener">NoSQL 데이터베이스란 무엇인가요?</a></li></ul><h2 id="15-SQL">15. SQL</h2><ul><li><strong>정의:</strong> 관계형 데이터베이스에서 데이터를 저장, 조작 및 검색하는 데 사용되는 표준 언어입니다.</li><li><strong>예시:</strong> 관계형 데이터베이스에서 데이터를 가져오기 위해 SQL 쿼리를 작성합니다.</li><li><a href="https://www.geeksforgeeks.org/sql-tutorial/" target="_blank" rel="noopener">SQL 튜토리얼</a></li></ul><h2 id="16-데이터베이스-인덱싱">16. 데이터베이스 인덱싱</h2><ul><li><strong>정의:</strong> 데이터베이스에서 데이터를 빠르게 검색하고 액세스할 수 있도록 하는 데이터 구조 기법입니다.</li><li><strong>예시:</strong> 검색 속도 향상을 위해 사용자 ID 열에 인덱싱을 생성합니다.</li><li><a href="https://www.codecademy.com/article/sql-indexes" target="_blank" rel="noopener">데이터베이스 인덱싱</a></li></ul><h2 id="17-Replication">17. Replication</h2><ul><li><strong>정의:</strong> 분산 데이터베이스 시스템을 구성하는 여러 데이터베이스에서 데이터베이스 객체를 복사하고 유지 관리하는 프로세스입니다.</li><li><strong>예시:</strong> 복제를 사용하여 다양한 지리적 위치에서 데이터베이스의 고가용성을 유지.</li><li><a href="https://www.geeksforgeeks.org/data-replication-in-dbms/" target="_blank" rel="noopener">데이터베이스 복제(Database Replication)</a></li></ul><h2 id="18-Failover-장애-조치">18. Failover(장애 조치)</h2><ul><li><strong>정의:</strong> 주요 시스템 구성 요소가 손실되었을 때, 다른 시스템 구성 요소가 그 기능을 대신하는 백업 운영 모드.</li><li><strong>예시:</strong> 인터넷 애플리케이션 서버가 장애가 발생할 경우, 대기 서버로 자동으로 전환되는 내장된 자동 장애 조치 기능.</li><li><a href="https://macquariecloudservices.com/blog/failover-vs-disaster-recovery/" target="_blank" rel="noopener">장애 조치(Failover)와 재해 복구(Disaster Recovery) 비교</a></li></ul><h2 id="19-API-Gateway">19. API Gateway</h2><ul><li><strong>정의:</strong> API의 앞단에 위치하여 API 요청을 수신하고 제한 및 보안 정책을 적용한 다음 백엔드 서비스로 전달하는 서버입니다.</li><li><strong>예시:</strong> AWS API 게이트웨이를 사용하여 API 관리.</li><li><a href="https://www.f5.com/glossary/api-gateway" target="_blank" rel="noopener">API 게이트웨이란?</a></li></ul><h2 id="20-Service-Mesh">20. Service Mesh</h2><ul><li><strong>정의:</strong> 마이크로서비스 간의 서비스 간 통신을 원활하게 하기 위한 전용 인프라 계층.</li><li><strong>예시:</strong> 마이크로서비스 상호 작용 관리를 위한 서비스 메시로 <a href="https://istio.io/latest/about/service-mesh/" target="_blank" rel="noopener">Istio 통합</a>.</li><li><a href="https://aws.amazon.com/what-is/service-mesh/#:~:text=A%20service%20mesh%20is%20a,the%20performance%20of%20the%20services." target="_blank" rel="noopener">Service Mesh 소개</a></li></ul><h2 id="21-Serverless-Computing">21. Serverless Computing</h2><ul><li><strong>정의:</strong> 클라우드 공급자가 동적으로 컴퓨팅 자원을 할당하는 클라우드 컴퓨팅 구현 방식.</li><li><strong>예시:</strong> AWS Lambda를 사용하여 서버 설정 없이 백엔드 코드를 실행</li><li><a href="https://www.cloudflare.com/ko-kr/learning/serverless/what-is-serverless/" target="_blank" rel="noopener">서버리스 컴퓨팅이란 무엇인가요?</a></li></ul><h2 id="22-Event-Driven-Architecture">22. Event-Driven Architecture</h2><ul><li><strong>정의:</strong> 일반적으로 이벤트를 생성, 감지, 소비하고 이에 반응하도록 장려하는 소프트웨어 아키텍처 패러다임.</li><li><strong>예시:</strong> Apache Kafka를 사용하여 마이크로서비스 간의 이벤트 통신으로 시스템을 설계하기.</li><li><a href="https://aws.amazon.com/ko/event-driven-architecture/" target="_blank" rel="noopener">이벤트 기반 아키텍처(Event-Driven Architecture)</a></li></ul><h2 id="23-Monolithic-Architecture">23. Monolithic Architecture</h2><ul><li><strong>정의:</strong> 모든 요소가 하나의 애플리케이션에 장착되어 단일 서비스로 실행되는 소프트웨어 아키텍처.</li><li><strong>예시:</strong> 하나의 거대한 단위로 구축된 전통적인 기업 애플리케이션.</li><li><a href="https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith" target="_blank" rel="noopener">모놀리식 아키텍처와 마이크로서비스 아키텍처 비교</a></li></ul><h2 id="24-분산-시스템">24. 분산 시스템</h2><ul><li><strong>정의:</strong> 네트워크로 연결된 컴퓨터에 위치한 구성 요소들이 메시지를 주고받으며 서로의 동작을 조정하는 모델.</li><li><strong>예시:</strong> Hadoop과 같은 분산 파일 시스템 설계.</li><li><a href="https://www.geeksforgeeks.org/what-is-a-distributed-system/" target="_blank" rel="noopener">분산 시스템 소개</a></li></ul><h2 id="25-메시지-큐-Message-Queue">25. 메시지 큐(Message Queue)</h2><ul><li><strong>정의:</strong> 아키텍처에서 비동기 서비스 간 통신을 가능하게 하는 방법.</li><li><strong>예시:</strong> RabbitMQ를 사용하여 서비스 간 메시지를 큐에 저장.</li><li><a href="https://aws.amazon.com/ko/message-queue/#:~:text=Message%20queues%20allow%20different%20parts,to%20send%20and%20receive%20messages." target="_blank" rel="noopener">메시지 큐 설명</a></li></ul><h2 id="26-Pub-Sub-모델">26. Pub/Sub 모델</h2><ul><li><strong>정의:</strong> 발신자(게시자)가 메시지를 발행하고, 수신자(구독자)가 목적지를 알 필요 없이 메시지를 수신하는 메시징 패턴.</li><li><strong>예시:</strong> Google Cloud Pub/Sub를 사용하는 알림 시스템.</li><li><a href="https://aws.amazon.com/what-is/pub-sub-messaging/" target="_blank" rel="noopener">Pub/Sub 메시징</a></li></ul><h2 id="27-데이터-파티셔닝-Data-Partitioning">27. 데이터 파티셔닝(Data Partitioning)</h2><ul><li><strong>정의:</strong> 데이터베이스를 더 작고 관리하기 쉬운 부분으로 분할 하는 것.</li><li><strong>예시:</strong> 데이터베이스의 테이블을 날짜별로 분할하여 쿼리를 매우 빠르게 실행할 수 있습니다.</li><li><a href="https://www.cockroachlabs.com/blog/what-is-data-partitioning-and-how-to-do-it-right/" target="_blank" rel="noopener">데이터베이스 파티셔닝</a></li></ul><h2 id="28-Horizontal-Scaling">28. Horizontal Scaling</h2><ul><li><strong>정의:</strong> 시스템 내에 더 많은 머신이나 노드를 추가하여 용량을 증가시키는 것.</li><li><strong>예시:</strong> 사용자 트래픽이 증가할 때 웹 서버를 추가로 설치.</li><li><a href="https://www.digitalocean.com/resources/articles/horizontal-scaling-vs-vertical-scaling" target="_blank" rel="noopener">Horizontal vs Vertical Scaling</a></li></ul><h2 id="29-Vertical-Scaling">29. Vertical Scaling</h2><ul><li><strong>정의:</strong> 기존 머신의 CPU나 RAM 같은 성능을 업그레이드하는 것.</li><li><strong>예시:</strong> 서버의 RAM을 업그레이드하여 더 많은 요청을 처리할 수 있게 함.</li><li><a href="https://www.digitalocean.com/resources/articles/horizontal-scaling-vs-vertical-scaling" target="_blank" rel="noopener">Horizontal vs Vertical Scaling</a></li></ul><h2 id="30-속도-제한-Rate-Limiting">30. 속도 제한(Rate Limiting)</h2><ul><li><strong>정의:</strong> 네트워크 인터페이스 컨트롤러가 보내거나 받는 트래픽의 속도를 제어하는 것.</li><li><strong>예시:</strong> API의 남용을 방지하기 위해 API를 제한.</li><li><a href="https://www.solo.io/topics/rate-limiting/" target="_blank" rel="noopener">속도 제한 이해하기</a></li></ul><h2 id="31-Circuit-Breaker-패턴">31. Circuit Breaker 패턴</h2><ul><li><strong>정의:</strong> 최신 소프트웨어 개발에 사용되는 디자인 패턴으로, 장애를 감지하고 장애가 지속적으로 반복되는 것을 방지하는 로직을 캡슐화 함.</li><li><strong>예시:</strong> 마이크로서비스 아키텍처에서 서킷 브레이커를 사용하여 원격 서비스 호출 실패 처리.</li><li><a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/" target="_blank" rel="noopener">Circuit Breaker 패턴</a></li></ul><h2 id="32-데이터-일관성-Data-Consistency">32. 데이터 일관성(Data Consistency)</h2><ul><li><strong>정의:</strong> 여러 인스턴스 간에 데이터가 동일하고 손상되지 않도록 보장하는 것.</li><li><strong>예시:</strong> 데이터베이스의 여러 복제본을 통해 사용자 데이터의 일관성을 유지.</li><li><a href="https://www.geeksforgeeks.org/consistency-model-in-distributed-system/" target="_blank" rel="noopener">데이터 일관성 모델</a></li></ul><h2 id="33-궁극적-일관성-Eventual-Consistency">33. 궁극적 일관성(Eventual Consistency)</h2><ul><li><strong>정의:</strong> 높은 가용성을 목표로 하는 분산 컴퓨팅에서 사용되는 일관성 모델로, 시스템의 업데이트가 시간이 지나면 모든 노드에 반영될 것을 보장함.</li><li><strong>예시:</strong> Amazon DynamoDB는 읽기 작업에 대해 최종 일관성 모델을 제공함.</li><li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html" target="_blank" rel="noopener">궁극적 일관성</a></li></ul><h2 id="34-강력한-일관성-Strong-Consistency">34. 강력한 일관성(Strong Consistency)</h2><ul><li><strong>정의:</strong> 모든 읽기 작업이 가장 최근의 쓰기 작업을 반영하도록 보장하는 일관성 모델.</li><li><strong>예시:</strong> 금융 거래 시스템에서 강력한 일관성 사용.</li><li><a href="https://www.geeksforgeeks.org/eventual-vs-strong-consistency-in-distributed-databases/" target="_blank" rel="noopener">강력한 일관성</a></li></ul><h2 id="35-컨테이너화-Containerization">35. 컨테이너화(Containerization)</h2><ul><li><strong>정의:</strong> 기본적으로 애플리케이션과 그 종속성을 컨테이너에 캡슐화하여 다양한 컴퓨팅 환경에서 실행할 수 있도록 하는 것.</li><li><strong>예시:</strong> Docker를 사용하여 애플리케이션을 개발, 테스트, 프로덕션 환경에 배포할 수 있도록 컨테이너화.</li><li><a href="https://aws.amazon.com/what-is/containerization/" target="_blank" rel="noopener">컨테이너화란 무엇인가요?</a></li></ul><h2 id="36-쿠버네티스-Kubernetes">36. 쿠버네티스(Kubernetes)</h2><ul><li><strong>정의:</strong> 애플리케이션 컨테이너의 배포, 확장 및 운영 프로세스를 자동화하는 오픈소스 플랫폼.</li><li><strong>예시:</strong> Kubernetes를 사용하여 컨테이너화된 애플리케이션 실행 및 배포.</li><li><a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">Kubernetes 문서</a></li></ul><h2 id="37-오토스케일링-Autoscaling">37. 오토스케일링(Autoscaling)</h2><ul><li><strong>정의:</strong> 사용자 부하에 따라 컴퓨팅 리소스 수를 자동으로 조정하는 것.</li><li><strong>예시:</strong> AWS EC2 오토스케일링 기능을 사용하여 인스턴스 수를 동적으로 조정.</li><li><a href="https://aws.amazon.com/ko/autoscaling/" target="_blank" rel="noopener">오토스케일링 설명</a></li></ul><h2 id="38-Multi-Tenancy">38. Multi-Tenancy</h2><ul><li><strong>정의:</strong> 단일 소프트웨어 애플리케이션 인스턴스가 여러 소비자/고객에게 서비스를 제공하는 아키텍처.</li><li><strong>예시:</strong> Salesforce와 같은 SaaS 애플리케이션이 다양한 고객 그룹에게 Multi-Tenancy를 사용하여 서비스 제공.</li><li><a href="https://www.digitalguardian.com/blog/saas-single-tenant-vs-multi-tenant-whats-difference" target="_blank" rel="noopener">Single Tenancy Vs Multi-Tenancy?</a></li></ul><h2 id="39-로드-셰딩-Load-Shedding">39. 로드 셰딩(Load Shedding)</h2><ul><li><strong>정의:</strong> 높은 부하 상태에서 시스템 전체의 건강을 유지하기 위해 일부 요청을 처리하지 않거나 서비스를 저하시키는 것.</li><li><strong>예시:</strong> 트래픽이 폭주하는 시간대에 필수적이지 않은 모든 서비스를 종료.</li><li><a href="https://www.techtarget.com/searchdatacenter/definition/load-shedding" target="_blank" rel="noopener">Load Shedding</a></li></ul><h2 id="40-멱등성-Idempotence">40. 멱등성(Idempotence)</h2><ul><li><strong>정의:</strong> 수학 및 컴퓨터 과학에서 특정 연산을 여러 번 수행해도 결과가 동일한 특성.</li><li><strong>예시:</strong> HTTP DELETE 요청은 멱등성을 가짐.</li><li><a href="https://restfulapi.net/idempotent-rest-apis/" target="_blank" rel="noopener">API의 멱등성</a></li></ul><h2 id="41-Quorum">41. Quorum</h2><ul><li><strong>정의:</strong> 분산 트랜잭션을 커밋하기 위해 필요한 최소 투표 수.</li><li><strong>예시:</strong> 분산 데이터베이스에서 일관성을 보장하기 위해 쿼럼 기반 복제를 사용.</li><li><a href="https://en.wikipedia.org/wiki/Quorum_(distributed_computing)" target="_blank" rel="noopener">Quorum Systems</a></li></ul><h2 id="42-오케스트레이션-Orchestration">42. 오케스트레이션(Orchestration)</h2><ul><li><strong>정의:</strong> 서비스 간 상호작용을 중앙에서 조정자가 제어하는 패턴.</li><li><strong>예시:</strong> 다단계 비즈니스 프로세스를 관리하기 위해 워크플로 엔진을 사용.</li><li><a href="https://www.redhat.com/en/topics/automation/what-is-orchestration" target="_blank" rel="noopener">오케스트레이션</a></li></ul><h2 id="43-Choreography">43. Choreography</h2><ul><li><strong>정의:</strong> 각 서비스가 독립적으로 이벤트를 통해 다른 서비스와 상호작용하며, 중앙 조정자 없이 작동하는 서비스 상호작용 패턴.</li><li><strong>예시:</strong> 이벤트 버스를 통해 마이크로서비스가 상호작용하는 Choreography 패턴.</li><li><a href="https://www.wallarm.com/what/orchestration-vs-choreography#:~:text=With%20orchestration%2C%20the%20control%20logic,its%20part%20of%20the%20workflow." target="_blank" rel="noopener">Choreography vs. Orchestration</a></li></ul><h2 id="44-서비스-레지스트리">44. 서비스 레지스트리</h2><ul><li><strong>정의:</strong> 마이크로서비스 인스턴스를 추적하는 데이터베이스.</li><li><strong>예시:</strong> 마이크로서비스 아키텍처에서 Eureka 서비스 레지스트리 사용.</li><li><a href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server" target="_blank" rel="noopener">서비스 레지스트리와 디스커버리</a></li></ul><h2 id="45-API-속도-제한">45. API 속도 제한</h2><ul><li><strong>정의:</strong> 특정 시간 내에 클라이언트가 API에 요청할 수 있는 횟수를 제어하는 것.</li><li><strong>예시:</strong> API 남용을 방지하기 위해 분당 100개의 요청으로 제한.</li><li><a href="https://datadome.co/bot-management-protection/what-is-api-rate-limiting/#:~:text=API%20rate%20limiting%20is%2C%20in,API%20product' target="_blank" rel="noopener"s%20growth%20and%20scalability.">API 속도 제한</a></li></ul><h2 id="46-데이터-웨어하우스-Data-Warehouse">46. 데이터 웨어하우스(Data Warehouse)</h2><ul><li><strong>정의:</strong> 보고서 생성 및 비즈니스 데이터 분석을 돕는 시스템; 비즈니스 인텔리전스의 허브.</li><li><strong>예시:</strong> 데이터 웨어하우징에 Amazon Redshift를 도입.</li><li><a href="https://aws.amazon.com/ko/what-is/data-warehouse/" target="_blank" rel="noopener">데이터 웨어하우스 이해하기</a></li></ul><h2 id="47-데이터-레이크-Data-Lake">47. 데이터 레이크(Data Lake)</h2><ul><li><strong>정의:</strong> 데이터를 네이티브/원시 형식으로 저장하는 시스템 또는 저장소, 일반적으로 객체 블롭이나 파일 형태로 저장.</li><li><strong>예시:</strong> 데이터 레이크에서 구조적 및 비구조적 데이터를 페타바이트 규모로 저장 및 관리.</li><li><a href="https://azure.microsoft.com/en-us/solutions/data-lake/" target="_blank" rel="noopener">데이터 레이크</a></li></ul><h2 id="48-OLAP-Online-Analytical-Processing">48. OLAP(Online Analytical Processing)</h2><ul><li><strong>정의:</strong> 데이터베이스에 저장된 데이터를 분석할 수 있는 소프트웨어 카테고리.</li><li><strong>예시:</strong> 정교한 분석 및 임의의 쿼리를 위해 OLAP 큐브 사용.</li><li><a href="https://aws.amazon.com/what-is/olap/#:~:text=Online%20analytical%20processing%20(OLAP)%20is,smart%20meters%2C%20and%20internal%20systems." target="_blank" rel="noopener">OLAP 설명</a></li></ul><h2 id="49-OLTP-Online-Transaction-Processing">49. OLTP(Online Transaction Processing)</h2><ul><li><strong>정의:</strong> 트랜잭션 중심 애플리케이션을 관리하는 시스템.</li><li><strong>예시:</strong> 은행 시스템과 같은 트랜잭션 데이터 관리를 위한 OLTP 시스템 사용.</li><li><a href="https://www.oracle.com/kr/database/what-is-oltp/" target="_blank" rel="noopener">OLTP 설명</a></li></ul><h2 id="50-빅-데이터">50. 빅 데이터</h2><ul><li><strong>정의:</strong> 기존 데이터 처리 소프트웨어로는 효율적으로 관리할 수 없는 크고 복잡한 데이터 세트.</li><li><strong>예시:</strong> 패션 트렌드를 예측하기 위해 소셜 미디어 상호작용 분석.</li><li><a href="https://www.geeksforgeeks.org/what-is-big-data/" target="_blank" rel="noopener">빅데이터 소개</a></li></ul><h2 id="마무리">마무리</h2><p>계속 학습하고, 시스템 설계에서 이러한 개념들을 실제로 적용해보는 것이 중요합니다. 프로젝트에 이러한 개념들을 적용하고, 관련된 논의에 참여하면서 배워가세요. 이러한 리소스와 논의는 개념의 용어와 사용 사례에 익숙해지는 데 도움을 줄 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/17/info-30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C# 개발에 도움을 주는 기본 개념 7가지</title>
      <link>http://hgko1207.github.io/2024/10/17/csharp-12/</link>
      <guid>http://hgko1207.github.io/2024/10/17/csharp-12/</guid>
      <pubDate>Thu, 17 Oct 2024 03:09:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 모든 개발자가 반드시 알아야 할 다양한 C# 개념을 살펴봅니다. 코드 예제를 알고 이해한다면 .NET에서 꽤 잘하고 있는 것일 가능성이 높습니다.&lt;/p&gt;
&lt;h2 id=&quot;1-IEnumerable-T-와-ICollection-T-의-차이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 모든 개발자가 반드시 알아야 할 다양한 C# 개념을 살펴봅니다. 코드 예제를 알고 이해한다면 .NET에서 꽤 잘하고 있는 것일 가능성이 높습니다.</p><h2 id="1-IEnumerable-T-와-ICollection-T-의-차이점">1. <code>IEnumerable&lt;T&gt;</code>와 <code>ICollection&lt;T&gt;</code>의 차이점</h2><p>C#으로 로직을 작성할 때 개발자는 <code>IEnumerable&lt;T&gt;</code>와 <code>ICollection&lt;T&gt;</code>를 자주 접하게 됩니다. 이 둘은 매우 비슷해 보이지만 소프트웨어 개발에서 서로 다른 용도로 사용됩니다.</p><ul><li><code>IEnumerable&lt;T&gt;</code>는 일반 컬렉션이 아닌 컬렉션의 기본 인터페이스 역할을 합니다. 정의된 유형의 컬렉션을 반복하는 데 도움이 됩니다.</li></ul><p>데이터 조작이 허용되지 않으므로 더 안전한 경량 컬렉션을 사용하는 것이 좋습니다. 데이터 조작을 방지하려면 어떤 컬렉션이든 <code>IEnumerable&lt;T&gt;</code>을 사용하는 것이 좋습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">    Console.WriteLine(number); <span class="comment">// Outputs: 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ICollection&lt;T&gt;</code>는 <code>IEnumerable&lt;T&gt;</code>를 확장하여 변경 메서드를 사용하여 수정할 수 있습니다. 이 인터페이스는 컬렉션의 개수를 추가, 제거 및 확인하는 메서드로 구성됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ICollection&lt;<span class="keyword">int</span>&gt; data = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span> &#125;;</span><br><span class="line">data.Add(<span class="number">4</span>);</span><br><span class="line">Console.WriteLine(data.Count); <span class="comment">// Outputs: 4</span></span><br></pre></td></tr></table></figure><p>컬렉션에 변경 메서드가 필요한 경우 <code>ICollection&lt;T&gt;</code>, 간단한 읽기 작업에는 <code>IEnumerable&lt;T&gt;</code>를 사용하는 것이 좋습니다.</p><h2 id="2-NET-Core에서-종속성-주입의-역할">2. .NET Core에서 종속성 주입의 역할</h2><p>느슨하게 결합되고 테스트 가능한 코드를 작성하려는 경우, DI(Dependency Injection) 디자인 패턴을 사용하는 것을 권장합니다. .NET Core는 DI를 기본적으로 지원하므로 쉽게 구현할 수 있습니다.</p><ul><li><code>Startup.cs</code> 파일의 <code>ConfigureServices</code> 메서드에 서비스를 등록합니다. 여기에서 주입할 수 있는 서비스를 정의합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 서비스 등록</span></span><br><span class="line">    services.AddTransient&lt;IMyService, MyService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자 주입을 통해 클래스에 서비스를 주입하세요. 이렇게 하면 클래스가 직접 생성할 필요 없이 종속성을 받을 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyService _myService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyController</span>(<span class="params">IMyService myService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = _myService.GetData();</span><br><span class="line">        <span class="keyword">return</span> View(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개발자가 서비스 생성을 분리하면 코드의 유지 관리와 테스트가 더 쉬워집니다.</p><h2 id="3-ref와-out-매개변수의-차이점">3. <code>ref</code>와 <code>out</code> 매개변수의 차이점</h2><p>C#에서 <code>ref</code>와 <code>out</code>은 매개변수를 참조로 전달하는 데 사용되지만, 서로 다른 특징이 있습니다.</p><ul><li><code>ref</code> 매개변수는 메서드에 전달되기 전에 변수를 초기화해야 합니다. 그런 다음 메서드는 변수 값을 수정할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateValue</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myNumber = <span class="number">5</span>;</span><br><span class="line">UpdateValue(<span class="keyword">ref</span> myNumber);</span><br><span class="line">Console.WriteLine(myNumber); <span class="comment">// Outputs: 15</span></span><br></pre></td></tr></table></figure><ul><li><code>out</code> 매개변수는 전달되기 전에 초기화가 필요하지 않습니다. 이 메서드는 반환하기 전에 out 매개변수에 값을 할당해야 합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetValues</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> value1, <span class="keyword">out</span> <span class="keyword">int</span> value2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value1 = <span class="number">10</span>;</span><br><span class="line">    value2 = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetValues(<span class="keyword">out</span> <span class="keyword">int</span> a, <span class="keyword">out</span> <span class="keyword">int</span> b);</span><br><span class="line">Console.WriteLine(a); <span class="comment">// Outputs: 10</span></span><br><span class="line">Console.WriteLine(b); <span class="comment">// Outputs: 20</span></span><br></pre></td></tr></table></figure><p><code>ref</code>는 일반적으로 메서드가 기존 변수를 수정해야 할 때 사용되며, <code>out</code>은 메서드가 여러 값을 반환하거나 호출자가 제공하지 않은 값을 초기화해야 할 때 사용됩니다.</p><h2 id="4-async-및-await">4. <code>async</code> 및 <code>await</code></h2><p>.NET에서 비동기 프로그래밍은 부하가 걸린 상태에서도 잘 작동하는 효율적인 애플리케이션을 작성하는 데 필수적입니다. <code>async</code> 및 <code>await</code> 키워드는 비동기 작업을 간소화합니다.</p><ul><li><code>async</code> 메서드를 사용하면 작업을 비동기적으로 수행할 수 있습니다. 메서드에 <code>async</code> 키워드를 표시하면 그 안에 <code>await</code>을 사용할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// Simulates an asynchronous operation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Data fetched"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>await</code>은 메인 스레드를 차단하지 않아 애플리케이션 UI에 도움이 됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ShowDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> data = <span class="keyword">await</span> FetchDataAsync();</span><br><span class="line">    Console.WriteLine(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애플리케이션의 성능을 향상시키려면 <code>async</code> 및 <code>await</code> 기능을 효과적으로 사용하면서 동시에 애플리케이션 UI의 반응성을 유지하세요.</p><h2 id="5-예외-처리">5. 예외 처리</h2><p>예외를 원활하게 처리하는 것은 견고하고 사용자 친화적인 애플리케이션을 유지하는 데 매우 중요합니다. .NET Core는 예외 처리를 위한 다양한 메커니즘을 제공합니다.</p><ul><li><strong>Local 예외 처리:</strong> try-catch 블록을 사용하여 예외를 포착하고 처리합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// DivideByZeroException을 던집니다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"오류가 발생했습니다: "</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Global 예외 처리</strong>는 미들웨어를 사용하여 관리할 수 있습니다. 모든 유형의 예외를 공통된 위치에서 잡으면 개발자가 사용자에게 친숙하고 일반적인 오류 메시지를 관리할 수 있습니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseExceptionHandler(<span class="string">"/Home/Error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Global 예외 처리 미들웨어는 모든 애플리케이션 오류와 예외를 처리할 수 있는 공통된 장소를 제공합니다. 이를 통해 애플리케이션이 일관되게 응답을 처리할 수 있습니다.</p><h2 id="6-ASP-NET-Core에서-appsettings-json의-역할">6. <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core에서 <code>appsettings.json</code>의 역할</h2><p><code>appsettings.json</code> 파일은 구성(configuration) 문자열 및 애플리케이션별 키와 같은 애플리케이션 자격 증명을 관리하는 데 사용됩니다. 구성 설정은 환경별로 나눌 수도 있습니다.</p><ul><li><code>appsettings.json</code> 파일 예시:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ConnectionStrings"</span>: &#123;</span><br><span class="line">    <span class="attr">"DefaultConnection"</span>: <span class="string">"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Warning"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애플리케이션의 구성 설정 값에 액세스하는 방법은 내장된 구성 시스템을 사용하면 간단합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> _connectionString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _connectionString = configuration.GetConnectionString(<span class="string">"DefaultConnection"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>appettings.json</code> 파일을 사용하면 구성 설정을 쉽게 가져올 수 있으므로 효율적으로 처리해야 합니다.</p><h2 id="7-C-에서-Task와-Thread-이해하기">7. C#에서 <code>Task</code>와 <code>Thread</code> 이해하기</h2><p><code>Task</code>와 <code>Thread</code>는 모두 C#에서 동시(concurrent) 프로그래밍에 사용되지만 서로 다른 용도로 사용됩니다.</p><ul><li><code>Thread</code>는 단일 실행 경로를 나타내며 하위 레벨 구조입니다. 실행에 대한 더 많은 제어 기능을 제공하지만 수동 관리가 필요합니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"새 스레드에서 실행 중"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><ul><li><code>Task</code>는 비동기 연산을 구현하는 추상적인 기능을 제공하며 async/await과 함께 사용됩니다.</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"비동기적으로 실행 중"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Task</code>는 비동기 연산의 관리를 간소화하며 최신 C# 개발에서 선호되는 선택입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/17/csharp-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Backend for Frontend (BFF) Architecture</title>
      <link>http://hgko1207.github.io/2024/10/15/info-29/</link>
      <guid>http://hgko1207.github.io/2024/10/15/info-29/</guid>
      <pubDate>Tue, 15 Oct 2024 06:13:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-29.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;최신 소프트웨어 개발에서 마이크로서비스, 클라우드 네이티브 아키텍처, 그리고 계속 증가하는 클라이언트 디바이스(모바일 앱, 웹 앱, IoT 등)로의 전
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-29.png" alt=""></p><p>최신 소프트웨어 개발에서 마이크로서비스, 클라우드 네이티브 아키텍처, 그리고 계속 증가하는 클라이언트 디바이스(모바일 앱, 웹 앱, IoT 등)로의 전환으로 인해 새로운 아키텍처 패러다임이 필요해졌습니다. 가장 두드러진 패턴 중 하나는 <strong>Backend for Frontend(BFF)</strong> 아키텍처입니다. 애플리케이션이 더욱 분산됨에 따라 빠르고 유지 관리가 용이하며 안전한 사용자 경험을 제공하기 위해 개별 고객의 요구에 맞게 백엔드 서비스를 맞춤화해야 할 필요성이 커지고 있습니다.</p><h2 id="Backend-for-Frontend-BFF-아키텍처란-무엇인가요">Backend for Frontend(BFF) 아키텍처란 무엇인가요?</h2><p><strong>Backend for Frontend</strong>의 ​​핵심은 각 프런트엔드 인터페이스에 대한 전용 백엔드 계층을 제공하는 아키텍처 패턴입니다. 각 프런트엔드(예: 모바일 앱, 웹 앱, 스마트 기기 등)는 성능, 데이터 및 상호 작용 요구 사항이 다를 수 있습니다. BFF는 하나의 모놀리식 또는 일반화된 API에 의존하는 대신 특정 프론트엔드의 특정 요구사항에 맞게 백엔드를 맞춤화합니다.</p><p>즉, 모든 클라이언트 또는 클라이언트 그룹(예: 모바일 또는 웹)에 대해 별도의 백엔드를 구축하는 것입니다.</p><ul><li>다양한 서비스에 대한 호출을 통합하거나 조율합니다.</li><li>클라이언트 친화적인 형식으로 데이터를 준비합니다.</li><li>프론트엔드에 연결된 특정 로직을 처리합니다.</li></ul><p>이를 통해 우려 사항을 분리할 수 있으므로 클라이언트의 특정 사용 사례에 맞게 각 백엔드를 더 쉽게 최적화할 수 있습니다.</p><h2 id="BFF-작동-방식">BFF 작동 방식</h2><ul><li><strong>클라이언트 요청:</strong> 클라이언트(모바일, 웹 등)가 해당 BFF에 요청을 합니다.</li><li><strong>BFF 레이어:</strong> BFF는 여러 마이크로서비스의 데이터를 통합하고, 변환 또는 최적화를 수행하며, 맞춤형 응답으로 응답합니다.</li><li><strong>마이크로 서비스:</strong> BFF는 기본 서비스(예: 사용자 서비스, 주문 서비스 등)와 상호 작용합니다.</li></ul><h2 id="기존-아키텍처와-BFF-비교">기존 아키텍처와 BFF 비교</h2><p><img src="/images/header/info-29_1.png" alt=""></p><p>기존 아키텍처에서는 단일 API 게이트웨이가 여러 클라이언트(예: 웹, 모바일, IoT)의 요청을 처리하는 경우가 많습니다. API 게이트웨이는 요청 라우팅, 인증 추가, 속도 제한에는 유용하지만 다음과 같은 프런트엔드별 요구 사항을 처리할 수 있는 유연성이 부족합니다.</p><ul><li>다양한 클라이언트 앱을 위한 <strong>맞춤형 데이터 모델.</strong></li><li>느린 모바일 네트워크를 위한 특화된 <strong>성능 최적화.</strong></li><li>특정 프론트엔드에 대한 서비스 간의 <strong>복잡한 오케스트레이션 관리.</strong></li></ul><p><strong>모놀리식 API 접근 방식</strong>은 종종 over-fetching(너무 많은 데이터) 또는 under-fetching(너무 적은 데이터)으로 이어져 클라이언트가 필요한 정보를 수집하기 위해 여러 번 왕복해야 하는 경우가 많습니다. BFF는 백엔드를 분리하여 각 클라이언트가 필요한 정보를 정확하게 얻을 수 있도록 함으로써 이 문제를 해결합니다.</p><h2 id="BFF가-현대-아키텍처의-슈퍼스타인-이유">BFF가 현대 아키텍처의 슈퍼스타인 이유</h2><p>그렇다면 BFF가 백엔드 아키텍처의 슈퍼스타가 된 이유는 무엇일까요?</p><ul><li><strong>맞춤형 사용자 경험:</strong> 모바일 앱, 데스크톱 또는 웨어러블 기기 등 각 프런트엔드는 군더더기 없이 필요한 데이터를 정확하게 얻을 수 있습니다. 마치 모든 상황에 딱 맞는 사이즈의 정장을 입은 것과 같습니다.</li><li><strong>복잡성 감소:</strong> BFF는 각 백엔드를 사용자 지정하여 작업을 간소화함으로써 플랫폼 전반에서 원활한 경험을 보장합니다.</li><li><strong>성능 향상:</strong> BFF는 앱의 터보차저입니다. 불필요한 API 호출을 줄임으로써 더 빠른 응답과 더 행복한 사용자를 보장합니다.</li><li><strong>더 빠른 개발:</strong> 팀이 프런트엔드마다 서로 다른 BFF를 작업할 때, 서로의 발을 밟지 않고 더 빨리 움직일 수 있습니다. 마치 주방에 여러 명의 셰프가 각자의 요리를 마스터하는 것과 같습니다.</li><li><strong>보안 강화:</strong> BFF는 백엔드와의 모든 상호작용을 제어하기 때문에 토큰 검증, 입력 검증, 속도 제한과 같은 엄격한 보안 조치를 시행하여 시스템을 더욱 안전하게 보호할 수 있습니다.</li></ul><h2 id="BFF는-언제-사용하나요">BFF는 언제 사용하나요?</h2><ul><li><p><strong>다중 플랫폼 애플리케이션:</strong> 다중 플랫폼 앱(웹, 모바일, 스마트 기기)을 구축하는 회사의 경우 BFF를 사용하면 각 플랫폼에 맞는 맞춤형 경험을 제공할 수 있습니다.</p></li><li><p><strong>마이크로서비스 오케스트레이션:</strong> 마이크로 서비스 아키텍처에서 클라이언트는 여러 서비스(예: 사용자 서비스, 주문 서비스, 재고 서비스)에서 데이터를 가져와야 할 수 있습니다. BFF는 다양한 서비스에서 필요한 데이터를 취합하여 클라이언트에게 일관된 응답으로 제시하는 오케스트레이터 역할을 할 수 있습니다.</p></li><li><p><strong>레거시 API 최적화:</strong> 마이크로서비스로 마이그레이션하거나 레거시 시스템을 사용할 때 BFF는 기본 아키텍처의 복잡성을 가리는 데 도움이 될 수 있습니다. 이전 시스템과 상호 작용하면서도 프런트엔드에 대한 최신 인터페이스를 제공합니다.</p></li></ul><h2 id="도전-과제-및-고려-사항">도전 과제 및 고려 사항</h2><p>BFF는 많은 이점을 제공하지만 몇 가지 과제를 안고 있습니다.</p><ul><li><strong>유지 관리 오버헤드 증가:</strong> 유지 관리할 백엔드가 여러 개(프론트엔드당 하나씩)가 있으면 복잡성이 증가할 수 있습니다. 따라서 추가적인 모니터링, 확장 및 보안 조치가 필요합니다.</li><li><strong>일관성 문제:</strong> 신중하게 설계하지 않으면 백엔드를 별도로 두는 것으로 인해 여러 클라이언트에서 반환되는 데이터에 일관성이 떨어질 수 있습니다.</li><li><strong>성능 병목 현상:</strong> BFF 계층이 수많은 요청을 처리하는 데 최적화되어 있지 않거나 무거운 연산을 수행하는 경우 성능 병목 현상이 발생할 수 있습니다.</li></ul><h2 id="구현-모범-사례">구현 모범 사례</h2><p>BFF 아키텍처를 구현할 때는 다음 사항을 고려하세요.</p><ul><li><strong>BFF에서 비즈니스 로직을 제한하세요:</strong> BFF는 복잡한 비즈니스 로직을 구현하는 것이 아니라 프런트엔드의 데이터를 조정하고 포맷하는 데 집중해야 합니다.</li><li><strong>캐싱 사용:</strong> 특히 모바일 클라이언트의 성능을 개선하기 위해 BFF 계층에서 일반적인 응답을 캐싱할 수 있습니다.</li><li><strong>오류 처리:</strong> 클라이언트가 겪는 문제를 방지하기 위해 BFF에서 오류 처리 및 로깅을 중앙 집중화합니다.</li><li><strong>보안:</strong> 백엔드 서비스를 보호하기 위해 BFF 수준에서 인증, 권한 부여 및 속도 제한을 적용하여 BFF를 보호합니다.</li></ul><h2 id="실제-BFF-성공-사례">실제 BFF 성공 사례</h2><ul><li><strong>Netflix:</strong> 넷플릭스의 원활한 크로스 디바이스 경험의 배경에는 BFF 아키텍처가 있습니다. 모바일 앱은 가벼운 데이터만 가져오고, 데스크톱 앱은 더 풍부한 기능을 위해 더 자세한 정보를 가져옵니다.</li><li><strong>Spotify:</strong> 휴대폰, 태블릿, 스마트 스피커 등 어떤 기기를 사용하든 Spotify의 BFF는 각 기기에 최적화된 데이터를 전송하여 플랫폼 간에 빠르고 원활한 음악 경험을 보장합니다.</li></ul><h2 id="결론">결론</h2><p>Backend for Frontend 아키텍처는 획기적인 기술입니다. 개발자는 이를 통해 각 사용자 인터페이스에 필요한 기능을 정확하게 제공할 수 있습니다. 여러 개의 BFF를 관리하면 복잡성이 증가할 수 있지만 성능 향상과 유연성은 그만한 가치가 있습니다. 웹 앱, 모바일 앱, IoT 디바이스를 확장할 때 BFF는 여러분이 놓치고 있던 비장의 무기일 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/15/info-29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[CORS] 간단하게 설명하기</title>
      <link>http://hgko1207.github.io/2024/10/15/info-28/</link>
      <guid>http://hgko1207.github.io/2024/10/15/info-28/</guid>
      <pubDate>Tue, 15 Oct 2024 04:34:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-28.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/header/info-28_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 내용을 본 적이 있나요? 아마도… 그리고 아마도
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-28.png" alt=""></p><p><img src="/images/header/info-28_1.png" alt=""></p><p>위의 내용을 본 적이 있나요? 아마도… 그리고 아마도 꽤 많이…봤을거에요.</p><p>위의 오류를 수정하는 방법을 설명하는 수백만 개의 문서가 있지만 &quot;<strong>Cross-Origin Resource Sharing(CORS)</strong>&quot;는 정확히 무엇이며 왜 존재하는 것일까요?</p><h2 id="왜">왜??</h2><p>먼저 시나리오를 통해 그 이유에 대한 질문에 답하고 다양한 시점에 어떻게 작동하는지 살펴봅시다.</p><p>뱅킹 서비스인 <code>bank.com</code>에 로그인한다고 상상해 보세요. 로그인하면 '세션 쿠키(Session Cookie)'가 브라우저에 저장됩니다. (세션 쿠키는 기본적으로 <code>bank.com</code> 뒤에 있는 서버에 브라우저가 계정에 로그인했음을 알려줍니다). 앞으로 <code>bank.com</code>에 대한 모든 요청에는 이 쿠키가 포함되며, <code>bank.com</code>은 사용자가 로그인한 것을 알고 제대로 응답할 수 있습니다.</p><p>이제 메일함을 확인해 보겠습니다. 의심스러운 이메일이 보이면 당연히 그 안에 있는 링크를 클릭해 <code>attack.com</code>으로 이동합니다. 다음으로, 이 웹사이트는 은행 정보를 얻기 위해 <code>bank.com</code>에 요청을 보냅니다. 이 세션 쿠키가 브라우저에 저장되어 있기 때문에 <code>bank.com</code>은 여전히 사용자가 로그인한 것으로 간주합니다. <code>bank.com</code> 뒤에 있는 서버는 사용자가 정상적으로 뱅킹 정보를 요청한 것처럼 보이므로 이를 다시 전송합니다. 이제 공격자는 이 쿠키에 액세스하여 악의적으로 다른 곳에 저장합니다.</p><p>사람들은 이것이 좋지 않다는 것을 깨달았고, 브라우저는 SOP(Same-Origin Policy; 동일-출처 정책)를 채택하여 사용자가 <code>bank.com</code>이 아닌 다른 곳에서 <code>bank.com</code>에 요청을 시도하는 것을 브라우저가 감지하면 이를 차단합니다. 여기서 중요한 점은 브라우저 기반 정책이라는 점입니다. <code>bank.com</code>은 요청의 출처를 알 수 있는 방법이 없기 때문에 CSRF와 같은 공격으로부터 크게 보호할 수 없습니다. 사용 중인 브라우저는 기본적으로 Origin에 대한 세부 정보(스키마 + 도메인 이름 + 포트, https//foo.com:4000, http//bar.org:3000 등… 기본적으로 URL)를 요청하는 것처럼 보이는 경우 동일한 Origin의 요청만 전송한다고 말합니다.</p><p>이 기능은 훌륭하지만 매우 제한적이었습니다. 즉, 공개 API는 전혀 작동하지 않았습니다. 일종의 프록시 솔루션을 사용하지 않는 한 데이터를 요청할 수 없었습니다.</p><h2 id="CSRF">CSRF</h2><p>서버는 요청이 어디에서 왔는지 어느 정도 알 수 있습니다. 요청에는 어떤 출처에서 요청을 했는지 보여주는 <strong>‘Origin’</strong> 헤더가 있어야 합니다. 예를 들어, 위의 예에서 요청은 다음과 같이 보입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----&gt; bank.com으로 요청</span></span><br><span class="line">&#123;</span><br><span class="line">  Headers: &#123; <span class="attr">Origin</span>: http:<span class="comment">//attack.com &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이론적으로 <code>bank.com</code>은 이를 확인하여 출처가 합당한 요청에만 응답해야 합니다. 그리고 보통은 그렇게 하므로 SOP는 다소 제한적인 것 같습니다.<br>바로 이때 CORS가 등장합니다.</p><h2 id="CORS">CORS</h2><p><code>example.com</code>의 웹 애플리케이션이 <code>bank.com</code>에서 리소스를 요청하려고 하면 브라우저는 요청에 요청의 출처(<code>example.com</code>)를 나타내는 Origin 헤더를 자동으로 포함합니다. 여기서 중요한 부분이 있습니다: <code>bank.com</code>의 서버는 SOP에 따라 이러한 cross-origin 요청을 전면적으로 차단하는 대신 이 Origin 헤더를 검사하고 자체 CORS 정책에 따라 요청을 허용할지 거부할지 결정할 수 있습니다.</p><p><code>example.com</code>이 신뢰할 수 있거나 요청되는 리소스가 공개적으로 액세스할 수 있는 리소스라고 판단되는 경우, <code>bank.com</code>은 리소스에 액세스할 수 있는 출처를 나타내는 <code>Access-Control-Allow-Origin</code>과 같은 특정 CORS 헤더를 사용하여 응답할 수 있습니다. 이 헤더는 이 Origin을 명시적으로 허용하는 <code>http://example.com</code> 또는 모든 Origin이 액세스할 수 있는 공개 리소스의 경우 <code>*</code>로 설정할 수 있습니다.</p><p>물론 브라우저는 이 모든 작업을 용이하게 합니다. 이 중 하나라도 잘못되면 불쾌한 오류가 발생합니다.</p><p>자 이제 요청에 Origin 헤더가 없으면 어떻게 될까요? 다른 헤더가 많고 기본 HTTP 메서드 중 하나를 사용하지 않는다면 어떨까요?</p><p>이러한 상황에서는 더 이상 &quot;Simple Request&quot;가 아니므로 CORS 처리가 조금 더 복잡해집니다. 바로 이 지점에서 CORS의 “Preflight” 요청이라는 개념이 등장합니다.</p><h2 id="Preflight">Preflight</h2><p>서버의 데이터를 수정할 수 있는 특정 타입의 요청(PUT, DELETE와 같은 HTTP 메서드를 사용하거나 모든 요청에 자동으로 포함되지 않는 헤더를 사용하는 요청)의 경우 브라우저는 실제 요청을 하기 전에 먼저 “Preflight” 요청을 보냅니다. 이 Preflight 요청은 HTTP 옵션 요청으로, 실제 요청을 전송해도 안전한지 서버에 확인하는 데 목적이 있습니다.</p><p>Preflight 요청에는 HTTP 메소드를 설명하는 헤더와 실제 요청의 헤더가 포함됩니다. 다음과 같습니다.</p><ol><li><strong>서버 응답:</strong> 서버가 CORS 정책과 실제 요청을 지원하는 경우, 서버는 허용되는 메소드와 헤더를 나타내는 헤더를 사용하여 Preflight 요청에 응답합니다. 여기에는 <code>Access-Control-Allow-Methods</code> 및 <code>Access-Control-Allow-Headers</code>와 같은 헤더가 포함될 수 있습니다.</li><li><strong>브라우저 결정:</strong> Preflight에 대한 서버의 응답에 따라 브라우저는 실제 요청을 진행할지 여부를 결정합니다. 서버의 응답이 요청이 허용됨을 나타내면 브라우저는 요청을 전송하고, 허용되지 않으면 브라우저는 요청을 차단하고 CORS 관련 오류가 표시됩니다.</li></ol><h2 id="결론">결론</h2><p>이제 CORS에 대해 조금 더 이해하셨기를 바랍니다. 가장 중요한 점은 이것이 모두 브라우저 정책이며 서버가 이를 준수하도록 코딩되어야 한다는 것입니다. 이는 사용자의 안전을 지키기 위해 마련된 것입니다. Chrome을 사용하는 경우 잘못된 링크를 클릭하는 것에 대해 크게 걱정할 필요는 없습니다(물론 여전히 조금은 걱정해야 합니다). 하지만 완벽한 정책은 아닙니다. 표준을 준수하지 않는 타사 브라우저를 사용하면 이 모든 것이 없어질 수 있습니다. 그렇기 때문에 어떤 소프트웨어를 사용하는지 신중해야 합니다!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/15/info-28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] async, await 기능을 사용한 비동기 프로그래밍</title>
      <link>http://hgko1207.github.io/2024/10/14/csharp-11/</link>
      <guid>http://hgko1207.github.io/2024/10/14/csharp-11/</guid>
      <pubDate>Mon, 14 Oct 2024 06:32:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/csharp-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;비동기 프로그래밍은 고성능, 확장성, 반응성이 뛰어난 애플리케이션을 구축하는 데 매우 중요합니다. .NET C#에 &lt;code&gt;async&lt;/code&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/csharp-11.png" alt=""></p><p>비동기 프로그래밍은 고성능, 확장성, 반응성이 뛰어난 애플리케이션을 구축하는 데 매우 중요합니다. .NET C#에 <code>async</code> 및 <code>await</code> 키워드가 도입되면서 비동기 코드 작성 프로세스가 크게 간소화되었습니다. 이 글에서는 비동기 프로그래밍의 복잡성을 자세히 살펴보고, 애플리케이션이 .NET의 비동기 기능의 잠재력을 최대한 활용할 수 있도록 모범 사례와 고급 기술을 제공합니다.</p><h2 id="async-await-이해">async, await 이해</h2><p><code>async</code> 및 <code>await</code> 키워드는 .NET C#에서 비동기 프로그래밍의 기초를 형성합니다. 이를 통해 개발자는 동기식 코드처럼 읽히는 비동기 코드를 작성하여 가독성과 유지 관리성을 모두 향상시킬 수 있습니다.</p><h2 id="async-await-기본-사항">async, await 기본 사항</h2><p><code>async</code> 메서드는 일반적으로 비동기 연산을 수행한다는 의미의 <code>Task</code> 또는 <code>Task&lt;T&gt;</code>를 반환합니다. <code>await</code> 키워드는 스레드를 차단하지 않고 대기 중인 작업이 완료될 때까지 <code>async</code> 메서드의 실행을 일시 중지하는 데 사용됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ExampleAsyncMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// 비동기 작업을 시뮬레이션합니다.</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Operation Completed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await-내부-살펴보기">async, await 내부 살펴보기</h2><p><code>await</code> 키워드가 발생하면 메서드 실행이 일시 중단되고 대기 중인 작업이 완료될 때까지 호출자에게 제어권이 반환됩니다. 이 프로세스는 컴파일러에서 생성된 상태 머신에 의해 관리되며, 이 머신은 메서드의 진행 상황을 추적하고 작업이 완료되면 실행을 재개합니다.</p><h2 id="비동기-프로그래밍-모범-사례">비동기 프로그래밍 모범 사례</h2><p>비동기 프로그래밍의 모범 사례를 준수하는 것은 함정을 피하고 효율적이고 유지 관리 가능한 코드를 보장하는 데 필수적입니다.</p><h3 id="호출-차단-방지">호출 차단 방지</h3><p><code>Task.Wait()</code> 또는 <code>Task.Result</code>와 같은 메서드로 호출 스레드를 차단하면 스레드가 작업이 완료될 때까지 대기하게 되어 비동기 프로그래밍의 이점이 훼손됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt; LongRunningOperation()).Wait();</span><br></pre></td></tr></table></figure><p>대신 <code>await</code>을 사용하여 차단하지 않고 비동기 작업을 처리하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Run(() =&gt; LongRunningOperation());</span><br></pre></td></tr></table></figure><h3 id="ConfigureAwait-false-사용">ConfigureAwait(false) 사용</h3><p>라이브러리 코드에서 <code>ConfigureAwait(false)</code>를 사용하면 현재 동기화 컨텍스트를 캡처하지 않으므로 성능이 향상되고 잠재적인 교착 상태를 방지할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> SomeAsyncMethod().ConfigureAwait(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="예외를-효과적으로-처리하기">예외를 효과적으로 처리하기</h3><p>비동기 코드에서 적절한 예외 처리는 매우 중요합니다. 비동기 메서드 내에서 try-catch 블록을 사용하여 예외를 포착하고 처리하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> SomeAsyncMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 예외 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="고급-기술">고급 기술</h2><p>.NET C#에서 비동기 프로그래밍의 모든 기능을 활용하려면 고급 기술을 이해하고 적용하는 것이 중요합니다.</p><h3 id="Task-based-Asynchronous-TAP-패턴">Task-based Asynchronous(TAP) 패턴</h3><p>작업 기반 비동기 패턴(TAP)은 비동기 연산을 표현하기 위해 <code>Task</code> 및 <code>Task&lt;T&gt;</code> 유형을 사용하는 디자인 패턴입니다. TAP는 비동기 코드 작성을 위한 일관된 접근 방식을 제공하므로 복잡한 연산을 더 쉽게 작성하고 관리할 수 있습니다.</p><h3 id="IAsyncEnumerable-T-를-사용한-비동기-스트림">IAsyncEnumerable<T>를 사용한 비동기 스트림</h3><p>C# 8.0에 도입된 비동기 스트림(<code>IAsyncEnumerable&lt;T&gt;</code>)을 사용하면 데이터의 비동기 시퀀스를 반복할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GenerateNumbersAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="성능-고려-사항-및-최적화">성능 고려 사항 및 최적화</h3><p>비동기 프로그래밍은 작업 할당 및 컨텍스트 전환으로 인해 오버헤드가 발생할 수 있습니다. 결과를 동기적으로 사용할 수 있는 경우가 많은 성능에 중요한 경로에는 <code>ValueTask</code>를 사용하여 이를 최소화하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> ValueTask&lt;<span class="keyword">int</span>&gt; <span class="title">ComputeAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실제-예제">실제 예제</h2><h3 id="ASP-NET-Core의-비동기-프로그래밍"><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core의 비동기 프로그래밍</h3><p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core에서 비동기 프로그래밍은 I/O 바인딩 작업을 효율적으로 처리하고 부하가 걸린 상태에서도 애플리케이션의 응답성을 유지하는 데 필수적입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">await</span> _dataService.GetDataAsync();</span><br><span class="line">    <span class="keyword">return</span> Ok(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="비동기-파일-작업">비동기 파일 작업</h3><p>비동기 파일 작업을 활용하여 특히 I/O 바인딩 애플리케이션에서 성능을 향상시킬 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">ReadFileAsync</span>(<span class="params"><span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> reader.ReadToEndAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>.NET C#에서 <code>async</code> 및 <code>await</code>을 사용한 비동기 프로그래밍은 반응성이 뛰어난 고성능 애플리케이션을 구축하기 위한 강력한 프레임워크를 제공합니다. 개발자는 모범 사례를 준수하고 고급 기술을 사용하여 효율적이고 유지 관리가 쉬운 비동기 코드를 작성할 수 있습니다. 이러한 개념을 도입하여 애플리케이션의 확장성과 성능을 향상시키고 .NET의 강력한 비동기 기능을 최대한 활용하세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/14/csharp-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>.NET Core로 고성능 API 빌드하기</title>
      <link>http://hgko1207.github.io/2024/10/10/netcore-1/</link>
      <guid>http://hgko1207.github.io/2024/10/10/netcore-1/</guid>
      <pubDate>Thu, 10 Oct 2024 04:11:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/netcore-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;디지털 환경에서 API는 최신 웹 애플리케이션의 중추로, 서로 다른 소프트웨어 시스템 간의 원활한 통신을 가능하게 합니다. &lt;strong&gt;.NET 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/netcore-1.png" alt=""></p><p>디지털 환경에서 API는 최신 웹 애플리케이션의 중추로, 서로 다른 소프트웨어 시스템 간의 원활한 통신을 가능하게 합니다. <strong>.NET Web API</strong>는 개발자가 강력하고 확장 가능한 API를 구축할 수 있는 강력한 프레임워크입니다. 이 글에서는 효율적이고 안전하며 유지 관리가 용이한 API를 만들기 위해 .NET Web API를 마스터하기 위한 모범 사례를 살펴봅니다.</p><h2 id="1-RESTful-API-설계">1. RESTful API 설계</h2><h3 id="REST-원칙-준수">REST 원칙 준수</h3><p>Stateless, 확장성, 이해하기 쉽도록 REST 원칙을 준수하여 API를 설계하세요. 다양한 작업에 적절한 HTTP 메서드(GET, POST, PUT, DELETE)와 표준 상태 코드를 사용하여 API 호출의 결과를 표시하세요.</p><h3 id="API-버전-관리">API 버전 관리</h3><p>버전 관리를 구현하여 변경 사항을 관리하고 이전 버전과의 호환성을 보장하세요. URL, Query String 또는 헤더에 버전 번호를 포함할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiVersion(<span class="meta-string">"1.0"</span>)</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/v&#123;version:apiVersion&#125;/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-강력한-보안-구현">2. 강력한 보안 구현</h2><h3 id="HTTPS-사용">HTTPS 사용</h3><p>항상 HTTPS를 사용하여 클라이언트와 서버 간에 전송되는 데이터를 암호화하여 가로채기 및 변조로부터 데이터를 보호하세요.</p><h3 id="인증-및-권한-부여-구현">인증 및 권한 부여 구현</h3><p>Stateless(무상태) 인증 및 권한 부여를 위한 역할 기반 액세스 제어를 위해 JWT(JSON Web Token)를 사용하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer((options) =&gt; &#123;</span><br><span class="line">  options.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters();</span><br><span class="line">  &#123;</span><br><span class="line">      (ValidateIssuer = <span class="literal">true</span>),</span><br><span class="line">      (ValidateAudience = <span class="literal">true</span>),</span><br><span class="line">      (ValidateLifetime = <span class="literal">true</span>),</span><br><span class="line">      (ValidateIssuerSigningKey = <span class="literal">true</span>),</span><br><span class="line">      (ValidIssuer = Configuration[<span class="string">'Jwt:Issuer'</span>]),</span><br><span class="line">      (ValidAudience = Configuration[<span class="string">'Jwt:Issuer'</span>]),</span><br><span class="line">      (IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[<span class="string">'Jwt:Key'</span>])));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-성능-최적화">3. 성능 최적화</h2><h3 id="캐싱-구현">캐싱 구현</h3><p>자주 액세스하는 데이터에는 인메모리 캐싱을 사용하고 대규모 분산 시스템에는 분산 캐싱(예: Redis)을 사용합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache _cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductService</span>(<span class="params">IMemoryCache cache</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">GetProduct</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cache.GetOrCreate(id, entry =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> _context.Products.Find(id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="비동기-프로그래밍-사용">비동기 프로그래밍 사용</h3><p><code>async</code> 및 <code>await</code>을 활용하여 I/O 바인딩 연산을 효율적으로 처리하고 다른 요청을 처리할 수 있는 스레드를 확보하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProduct</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> product = <span class="keyword">await</span> _context.Products.FindAsync(id);</span><br><span class="line">    <span class="keyword">return</span> Ok(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-유지보수성-향상">4. 유지보수성 향상</h2><h3 id="종속성-주입-사용">종속성 주입 사용</h3><p>종속성 주입을 도입하여 종속성을 관리하고 코드를 보다 모듈화하고 테스트할 수 있도록 하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddScoped&lt;IProductService, ProductService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SOLID-원칙-준수">SOLID 원칙 준수</h3><p>SOLID 원칙(Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)을 준수하여 깔끔하고 유지 관리 가능한 코드를 작성하세요.</p><h2 id="5-모니터링-및-진단">5. 모니터링 및 진단</h2><h3 id="로깅-구현">로깅 구현</h3><p>Serilog 또는 NLog와 같은 로깅 프레임워크를 사용하여 모니터링 및 문제 해결을 위한 자세한 로그를 캡처하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddLogging(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.AddSerilog();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="애플리케이션-인사이트-Insights-사용">애플리케이션 인사이트(Insights) 사용</h3><p>애플리케이션 인사이트를 통합하여 API의 성능과 사용량에 대한 종합적인 모니터링 및 진단을 수행하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddApplicationInsightsTelemetry(Configuration[<span class="string">"ApplicationInsights:InstrumentationKey"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>.NET Web API를 마스터하려면 디자인, 보안, 성능, 유지 관리 및 모니터링에 대한 모범 사례를 조합해야 합니다. 이러한 전략을 구현하면 최신 웹 애플리케이션의 요구 사항을 충족하는 강력하고 확장 가능하며 안전한 API를 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/10/netcore-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>백엔드 개발자로서 ChatGPT를 사용하는 방법(5가지 방법)</title>
      <link>http://hgko1207.github.io/2024/10/10/chatgpt-31/</link>
      <guid>http://hgko1207.github.io/2024/10/10/chatgpt-31/</guid>
      <pubDate>Thu, 10 Oct 2024 03:54:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 생산성과 문제 해결 능력을 향상시키는 귀중한 도구입니다. 백엔드 개발을 할 때 ChatGPT를 활용
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-31.png" alt=""></p><p><strong>ChatGPT</strong>는 생산성과 문제 해결 능력을 향상시키는 귀중한 도구입니다. 백엔드 개발을 할 때 ChatGPT를 활용하는 5가지 방법을 소개합니다.</p><h2 id="1-API-문서-생성">1. API 문서 생성</h2><p>백엔드 개발자에게 가장 시간이 많이 걸리는 작업 중 하나는 포괄적인 API 문서를 작성하는 것입니다. ChatGPT는 이 작업에 탁월합니다,</p><ul><li><strong>엔드포인트 설명:</strong> 엔드포인트 세부 정보를 제공하면 ChatGPT가 명확하고 간결한 설명을 생성합니다.</li><li><strong>요청/응답 예제:</strong> 현실적인 페이로드와 응답 예제를 생성할 수 있습니다.</li><li><strong>오류 시나리오:</strong> ChatGPT는 잠재적인 오류 사례와 해당 상태 코드를 문서화하는 데 도움을 줍니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChatGPT로 생성된 API 문서 예시</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"endpoint"</span>: <span class="string">"/api/v1/users"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Creates a new user account"</span>,</span><br><span class="line">  <span class="attr">"request_body"</span>: &#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"string"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"response"</span>: &#123;</span><br><span class="line">    <span class="attr">"201"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"User successfully created"</span>,</span><br><span class="line">      <span class="attr">"content"</span>: &#123;</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="string">"uuid"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"400"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Invalid input"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-데이터베이스-쿼리-최적화">2. 데이터베이스 쿼리 최적화</h2><p>ChatGPT는 쿼리 최적화 전략을 브레인스토밍하는 데 탁월합니다.</p><ul><li><strong>쿼리 분석:</strong> 문제가 있는 쿼리를 붙여넣으면 ChatGPT가 개선점을 제안합니다.</li><li><strong>인덱스 추천:</strong> 쿼리 성능을 향상시킬 수 있는 잠재적인 인덱스를 제안할 수 있습니다.</li><li><strong>대체 접근 방식:</strong> 종종 더 효율적일 수 있는 다른 쿼리 구조를 제안합니다.</li></ul><h2 id="3-코드-리팩토링-도우미">3. 코드 리팩토링 도우미</h2><p>레거시 코드 또는 복잡한 리팩터링 작업에 직면했을 때 활동합니다.</p><ul><li><strong>코드 분석:</strong> ChatGPT는 코드 냄새와 잠재적인 개선 사항을 식별하는 데 도움을 줍니다.</li><li><strong>디자인 패턴:</strong> 특정 시나리오에 적합한 디자인 패턴을 제안합니다.</li><li><strong>현대화:</strong> 최신 언어 기능 및 모범 사례를 사용하도록 오래된 코드를 업데이트하는 데 도움을 줍니다.</li></ul><p>예를 들어, 아래 코드를 변환합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 수정 전</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserData</span>(<span class="params">$userId</span>) </span>&#123;</span><br><span class="line">    $data = array();</span><br><span class="line">    $result = mysql_query(<span class="string">"SELECT * FROM users WHERE id = "</span> . $userId);</span><br><span class="line">    <span class="keyword">while</span> ($row = mysql_fetch_assoc($result)) &#123;</span><br><span class="line">        $data[] = $row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 수정 후</span></span><br><span class="line">public <span class="function"><span class="keyword">function</span> <span class="title">getUserData</span>(<span class="params">int $userId</span>): <span class="title">array</span> </span>&#123;</span><br><span class="line">    $pdo = Database::getInstance()-&gt;getConnection();</span><br><span class="line">    $stmt = $pdo-&gt;prepare(<span class="string">"SELECT * FROM users WHERE id = :userId"</span>);</span><br><span class="line">    $stmt-&gt;execute([<span class="string">'userId'</span> =&gt; $userId]);</span><br><span class="line">    <span class="keyword">return</span> $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-테스트-시나리오-생성">4. 테스트 시나리오 생성</h2><p>ChatGPT는 다양한 테스트 시나리오를 생각하도록 도와주는 데 탁월합니다.</p><ul><li><strong>Edge 케이스:</strong> 제가 놓쳤을 수 있는 경계 조건을 식별합니다.</li><li><strong>테스트 데이터:</strong> 다양한 시나리오에 대한 현실적인 테스트 데이터를 생성합니다.</li><li><strong>테스트 구조:</strong> 테스트 사례를 명확하고 체계적으로 정리할 수 있도록 도와줍니다.</li></ul><p>ChatGPT가 생성한 테스트 시나리오 예시입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="keyword">function</span> <span class="title">testUserRegistration</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 등록 성공 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testSuccessfulRegistration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 중복 이메일 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testDuplicateEmailRegistration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 유효하지 않은 이메일 형식 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testInvalidEmailFormat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비밀번호 요구 사항 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testPasswordTooShort();</span><br><span class="line">    $<span class="keyword">this</span>-&gt;testPasswordRequiresSpecialChar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 사용자 이름 요구 사항 테스트</span></span><br><span class="line">    $<span class="keyword">this</span>-&gt;testUsernameTooLong();</span><br><span class="line">    $<span class="keyword">this</span>-&gt;testUsernameWithInvalidChars();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-디버깅-파트너">5. 디버깅 파트너</h2><p>까다로운 버그에 걸렸을 때 사용합니다.</p><ul><li><strong>오류 분석:</strong> 오류 메시지를 공유하면 ChatGPT가 해석을 도와줍니다.</li><li><strong>디버깅 단계:</strong> 문제를 격리하기 위한 체계적인 접근 방식을 제안합니다.</li><li><strong>솔루션 브레인스토밍:</strong> 잠재적인 수정 사항과 설명을 제공합니다.</li></ul><p>ChatGPT 사용 모범 사례</p><ol><li><strong>결과물 확인:</strong> 구현하기 전에 항상 ChatGPT의 제안을 검토하고 테스트하세요.</li><li><strong>컨텍스트 제공:</strong> 더 많은 컨텍스트를 제공할수록 더 나은 응답을 얻을 수 있습니다.</li><li><strong>반복하기:</strong> ChatGPT를 시작점으로 삼아 제안을 구체화하세요.</li><li><strong>보안 인식:</strong> 민감한 정보나 자격 증명을 절대 공유하지 마세요.</li></ol>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/10/chatgpt-31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>백엔드(Backend)를 무료로 호스팅할 수 있는 10가지 사이트</title>
      <link>http://hgko1207.github.io/2024/10/08/backend-1/</link>
      <guid>http://hgko1207.github.io/2024/10/08/backend-1/</guid>
      <pubDate>Tue, 08 Oct 2024 13:29:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;1-cloudflare-workers&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-cloudflare-workers&quot;&gt;&lt;/a&gt; 1) Cloudflare Workers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="1-cloudflare-workers"><a class="markdownIt-Anchor" href="#1-cloudflare-workers"></a> 1) Cloudflare Workers</h2><p><a href="https://workers.cloudflare.com/" target="_blank" rel="noopener">Cloudflare Workers</a>는 서버리스 컴퓨팅 플랫폼으로, 개발자가 Cloudflare의 글로벌 네트워크 edge에서 코드를 실행할 수 있게 해줍니다. 이를 통해 사용자에게 더 짧은 지연 시간과 더 빠른 응답 시간을 보장합니다. 무료 버전은 백엔드 코드를 호스팅하고 실행할 수 있는 넉넉한 용량을 제공합니다.</p><p><img src="/images/header/backend-1_1.png" alt="" /></p><h2 id="2-vercel"><a class="markdownIt-Anchor" href="#2-vercel"></a> 2) Vercel</h2><p><a href="https://vercel.com/" target="_blank" rel="noopener">Vercel</a>은 개발자를 위한 플랫폼으로, 추가 구성 없이 웹 앱을 더 빠르게 빌드하고 배포하는 데 필요한 도구, 워크플로우 및 인프라를 제공합니다.</p><p><img src="/images/header/backend-1_2.png" alt="" /></p><h2 id="3-google-cloud-functions"><a class="markdownIt-Anchor" href="#3-google-cloud-functions"></a> 3) Google Cloud Functions</h2><p>Cloud Functions는 Google Cloud Platform(GCP)에서 제공하는 서버리스 컴퓨팅 서비스입니다. 최소한의 구성과 유지 관리로 이벤트에 대한 응답으로 코드를 실행할 수 있는 간단한 방법을 제공합니다. Cloud Functions는 이벤트 기반이므로 데이터 변경, 새 메시지, 사용자 상호 작용 등의 이벤트에 의해 트리거될 수 있습니다.</p><p><img src="/images/header/backend-1_3.png" alt="" /></p><h2 id="4-aws-lambda"><a class="markdownIt-Anchor" href="#4-aws-lambda"></a> 4) AWS Lambda</h2><p><a href="">AWS Lambda</a>는 이벤트에 대한 응답으로 코드를 실행하고 컴퓨팅 리소스를 자동으로 관리하는 컴퓨팅 서비스로, 아이디어를 최신 프로덕션 서버리스 애플리케이션으로 가장 빠르게 전환할 수 있는 방법입니다.</p><p><img src="/images/header/backend-1_4.png" alt="" /></p><h2 id="5-planetscale"><a class="markdownIt-Anchor" href="#5-planetscale"></a> 5) PlanetScale</h2><p><a href="https://planetscale.com/" target="_blank" rel="noopener">PlanetScale</a>은 Vitess를 기반으로 구축되었으며 수평적 샤딩(Horizontal Sharding)을 통해 하이퍼스케일 데이터베이스의 성능, 확장성 및 비용 최적화를 실현합니다.</p><p><img src="/images/header/backend-1_5.png" alt="" /></p><h2 id="6-supabase"><a class="markdownIt-Anchor" href="#6-supabase"></a> 6) Supabase</h2><p><a href="https://supabase.com/" target="_blank" rel="noopener">Supabase</a>는 오픈 소스 Firebase의 대안입니다. Postgres 데이터베이스, 인증, 인스턴트 API, Edge Functions, 실시간 구독, 저장소 및 벡터 임베딩으로 프로젝트를 시작하세요.</p><p><img src="/images/header/backend-1_6.png" alt="" /></p><h2 id="7-appwrite"><a class="markdownIt-Anchor" href="#7-appwrite"></a> 7) Appwrite</h2><p><a href="https://appwrite.io/" target="_blank" rel="noopener">Appwrite</a>는 선호하는 프로그래밍 언어와 도구를 사용하여 모든 규모의 애플리케이션을 구축할 수 있는 오픈 소스 플랫폼입니다.</p><p><img src="/images/header/backend-1_7.png" alt="" /></p><h2 id="8-railwayapp"><a class="markdownIt-Anchor" href="#8-railwayapp"></a> 8) Railway.app</h2><p><a href="https://railway.app/" target="_blank" rel="noopener">Railway</a>는 애플리케이션 구축 및 모니터링을 위한 클라우드입니다. 플랫폼 엔지니어가 필요하지 않습니다.</p><p><img src="/images/header/backend-1_8.png" alt="" /></p><h2 id="9-netlify-functions"><a class="markdownIt-Anchor" href="#9-netlify-functions"></a> 9) Netlify Functions</h2><p><a href="https://www.netlify.com/platform/core/functions/" target="_blank" rel="noopener">Netlify</a>는 사용자가 작성한 함수를 전체 API 엔드포인트로 배포합니다. 함수는 요청 컨텍스트 또는 이벤트 데이터를 수신하고 데이터를 프론트엔드로 다시 반환합니다.</p><p><img src="/images/header/backend-1_9.png" alt="" /></p><h2 id="10-sanityio"><a class="markdownIt-Anchor" href="#10-sanityio"></a> 10) <a href="http://Sanity.io" target="_blank" rel="noopener">Sanity.io</a></h2><p><a href="https://www.sanity.io/" target="_blank" rel="noopener">Sanity.io</a>는 개발자가 유연하고 확장 가능한 방식으로 콘텐츠를 호스팅하고 관리할 수 있는 헤드리스 콘텐츠 관리 시스템입니다. 무료 버전을 통해 개발자는 백엔드 코드를 호스팅하고 콘텐츠를 쉽게 관리할 수 있습니다.</p><p><img src="/images/header/backend-1_10.png" alt="" /></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/10/08/backend-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IP 주소란 무엇인가요?</title>
      <link>http://hgko1207.github.io/2024/09/24/info-27/</link>
      <guid>http://hgko1207.github.io/2024/09/24/info-27/</guid>
      <pubDate>Tue, 24 Sep 2024 03:31:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 주소&lt;/strong&gt;는 네트워크에 연결된 각 장치에 할당된 고유한 숫자 식별자로, 장치가 효과적으로 통신할 수 있도록 해줍니다.
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-27.png" alt="" /></p><p><strong>IP 주소</strong>는 네트워크에 연결된 각 장치에 할당된 고유한 숫자 식별자로, 장치가 효과적으로 통신할 수 있도록 해줍니다. 디바이스의 도로명 주소라고 생각하면 디바이스가 서로 통신할 수 있게 해줍니다.</p><h2 id="ipv4-주소란-무엇인가요"><a class="markdownIt-Anchor" href="#ipv4-주소란-무엇인가요"></a> IPv4 주소란 무엇인가요?</h2><p>IPv4 주소는 네트워크에 연결된 장치에 할당된 32비트 숫자 레이블입니다. 네트워크에서 디바이스를 식별하는 데 도움이 되는 고유 ID라고 생각하면 됩니다. IPv4 주소는 일반적으로 <code>192.168.1.10</code>과 같이 점으로 구분된 10진수 4자리로 작성됩니다.</p><h3 id="ipv4-주소의-구성-요소"><a class="markdownIt-Anchor" href="#ipv4-주소의-구성-요소"></a> IPv4 주소의 구성 요소</h3><ul><li><strong>Network ID:</strong> 이 부분은 디바이스가 속한 특정 네트워크를 지정합니다.</li><li><strong>Host ID:</strong> 네트워크 내의 특정 디바이스를 식별합니다.</li></ul><p>예를 들어 설명해 드리겠습니다.</p><p><strong>IP Address:</strong> <code>192.168.1.10</code>, 이 IP 주소에서 Network ID와 Host ID는 다음과 같습니다.</p><ul><li><strong>Network ID:</strong> 192.168.1</li><li><strong>Host ID:</strong> 10</li></ul><p>즉, 기본적으로 장치가 네트워크 <code>192.168.1.0</code>의 일부이며 장치 번호는 <code>10</code>입니다.</p><h2 id="ipv4-주소-클래스"><a class="markdownIt-Anchor" href="#ipv4-주소-클래스"></a> IPv4 주소 클래스</h2><p>IPv4 주소는 다양한 크기의 네트워크에 맞게 설계된 여러 클래스로 나뉩니다.</p><h3 id="1-class-a"><a class="markdownIt-Anchor" href="#1-class-a"></a> 1. Class A</h3><ul><li>매우 큰 규모의 네트워크(예: 대규모 조직)에 적합합니다.</li><li>첫 번째 octet(첫 번째 숫자)은 네트워크를 나타냅니다.</li><li>예: <code>10.0.0.0</code></li></ul><h3 id="2-class-b"><a class="markdownIt-Anchor" href="#2-class-b"></a> 2. Class B</h3><ul><li>중간 규모의 네트워크(예: 대학)의 경우.</li><li>처음 두 octet은 네트워크를 나타냅니다.</li><li>예: <code>172.16.0.0</code></li></ul><h3 id="3-class-c"><a class="markdownIt-Anchor" href="#3-class-c"></a> 3 Class C</h3><ul><li>소규모 네트워크(예: 소규모 기업)의 경우.</li><li>처음 세 octet은 네트워크를 나타냅니다.</li><li>예: <code>192.168.0.0</code></li></ul><h3 id="class-d"><a class="markdownIt-Anchor" href="#class-d"></a> Class D</h3><ul><li>멀티캐스트 그룹을 위해 예약되어 있으며, 한 번에 여러 대상에 데이터를 전송하는 데 사용됩니다.</li><li>범위: 224.0.0.0 ~ 239.255.255.255</li></ul><h3 id="class-e"><a class="markdownIt-Anchor" href="#class-e"></a> Class E</h3><ul><li>실험용으로 예약되어 있습니다.</li><li>범위: 240.0.0.0 ~ 255.255.255.255</li></ul><h2 id="사설private-및-공인public-ipv4-주소"><a class="markdownIt-Anchor" href="#사설private-및-공인public-ipv4-주소"></a> 사설(Private) 및 공인(Public) IPv4 주소</h2><p>IPv4 주소에는 두 가지 유형이 있습니다.</p><h3 id="사설-ip-주소"><a class="markdownIt-Anchor" href="#사설-ip-주소"></a> 사설 IP 주소</h3><p>로컬 네트워크 내에서 사용되며 인터넷에서 직접 액세스할 수 없습니다.</p><ul><li><strong>Class A:</strong> 10.0.0.0 ~ 10.255.255.255</li><li><strong>Class B:</strong> 172.16.0.0 ~ 172.31.255.255</li><li><strong>Class C:</strong> 192.168.0.0 ~ 192.168.255.255</li></ul><h3 id="공인-ip-주소"><a class="markdownIt-Anchor" href="#공인-ip-주소"></a> 공인 IP 주소</h3><p>인터넷을 통한 통신을 위해 전 세계적으로 고유하며 인터넷주소관리기관(IANA)에서 할당하는 주소입니다.</p><h2 id="ipv6-주소란-무엇인가요"><a class="markdownIt-Anchor" href="#ipv6-주소란-무엇인가요"></a> IPv6 주소란 무엇인가요?</h2><p>인터넷에 연결된 디바이스의 수가 증가함에 따라 IPv4 주소가 부족해지기 시작했습니다. 그래서 IPv6가 개발되었습니다. 128비트 시스템을 사용하므로 더 많은 주소를 사용할 수 있습니다.</p><p>IPv6 주소는 IPv4 주소와 다르게 생겼습니다. 다음과 같이 콜론으로 구분된 16진수 4자리로 구성된 8그룹으로 작성됩니다:</p><p>Example: <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></p><p>주소를 단순화하기 위해 선행 0은 생략하고 연속되는 0 그룹은 다음과 같이 이중 콜론(::)으로 대체할 수 있습니다:</p><p>Example: <code>2001:db8:85a3::8a2e:370:7334</code></p><h3 id="ipv6-주소-유형"><a class="markdownIt-Anchor" href="#ipv6-주소-유형"></a> IPv6 주소 유형</h3><ul><li><strong>Unicast:</strong> IPv4 주소와 마찬가지로 단일 장치를 식별합니다.</li><li><strong>Multicast:</strong> 한 번에 여러 장치에 데이터를 전송하는 데 사용됩니다.</li><li><strong>Anycast</strong>: 여러 디바이스 그룹에서 가장 가까운 디바이스로 데이터를 전송합니다.</li></ul><h2 id="서브넷팅subnetting-네트워크-구성"><a class="markdownIt-Anchor" href="#서브넷팅subnetting-네트워크-구성"></a> 서브넷팅(Subnetting): 네트워크 구성</h2><p>서브넷팅은 대규모 네트워크를 더 작고 관리하기 쉬운 하위 네트워크 또는 서브넷(Subnet)으로 나누는 프로세스입니다. 이를 통해 네트워크 효율성과 보안이 향상됩니다.</p><h2 id="왜-서브넷인가"><a class="markdownIt-Anchor" href="#왜-서브넷인가"></a> 왜 서브넷인가?</h2><ul><li><strong>효율적인 IP 사용:</strong> 필요하지 않은 네트워크에서 IP 주소 낭비 방지</li><li><strong>성능 향상:</strong> 네트워크 혼잡 감소</li><li><strong>보안 강화:</strong> 네트워크 세그먼트 분리</li><li><strong>더 쉬운 관리:</strong> 소규모 네트워크는 관리 및 문제 해결이 더 간단합니다.</li></ul><h2 id="서브넷팅-작동-방식"><a class="markdownIt-Anchor" href="#서브넷팅-작동-방식"></a> 서브넷팅 작동 방식</h2><p>서브넷 설정에는 IP 주소와 관련 서브넷 마스크(subnet mask)를 수정하는 작업이 포함됩니다. 서브넷 마스크는 IP 주소의 어느 부분이 네트워크에 속하고 어느 부분이 호스트에 속하는지를 식별하는 32비트 숫자입니다.</p><h3 id="서브넷-설정의-예"><a class="markdownIt-Anchor" href="#서브넷-설정의-예"></a> 서브넷 설정의 예</h3><p>네트워크 192.168.1.0/24를 두 개의 동일한 서브넷으로 서브넷화해 보겠습니다.</p><ol><li>원래 서브넷 마스크: 255.255.255.0 (/24)</li><li>새 서브넷 마스크: 255.255.255.128 (/25)</li></ol><p>이렇게 하면 두 개의 서브넷이 생성됩니다.</p><ol><li>Subnet 1: 192.168.1.0-192.168.1.127</li><li>Subnet 2: 192.168.1.128-192.168.1.255</li></ol><p>이제 각 서브넷은 최대 126개의 디바이스(2⁷ - 2, 네트워크 및 브로드캐스트 주소의 경우 2를 빼기)를 호스팅할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/24/info-27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>꼭 알아야 할 21가지 HTML 팁</title>
      <link>http://hgko1207.github.io/2024/09/24/web-20/</link>
      <guid>http://hgko1207.github.io/2024/09/24/web-20/</guid>
      <pubDate>Tue, 24 Sep 2024 01:21:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글에서는 코딩 실력을 향상시킬 수 있는 코드 스니펫(Code Snipet)이 포함된 21가지 HTML 팁을 공유하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;연락처-링크-만들기&quot;&gt;연락처 링크 만들기&lt;/h2&gt;
&lt;p&gt;HTML을 사용하여 클릭 가능한 이메일, 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글에서는 코딩 실력을 향상시킬 수 있는 코드 스니펫(Code Snipet)이 포함된 21가지 HTML 팁을 공유하겠습니다.</p><h2 id="연락처-링크-만들기">연락처 링크 만들기</h2><p>HTML을 사용하여 클릭 가능한 이메일, 전화 및 SMS 링크를 만듭니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Email link --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:name@example.com"</span>&gt;</span> Send Email <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Phone call link --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:+1234567890"</span>&gt;</span> Call Us <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SMS link --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"sms:+1234567890"</span>&gt;</span> Send SMS <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="접을-수-있는-콘텐츠-만들기">접을 수 있는 콘텐츠 만들기</h2><p>웹 페이지에 접을 수 있는 콘텐츠를 포함하려는 경우 <code>&lt;details&gt;</code> 및 <code>&lt;summary&gt;</code> 태그를 사용할 수 있습니다.</p><p><code>&lt;details&gt;</code> 태그는 숨겨진 콘텐츠를 위한 컨테이너를 생성하고, <code>&lt;summary&gt;</code> 태그는 클릭 가능한 레이블을 제공하여 해당 콘텐츠의 표시 여부를 전환할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Click to expand<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This content can be expanded or collapsed.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="시맨틱-요소-활용하기">시맨틱 요소 활용하기</h2><p>웹사이트에 non-semantic 요소보다 시맨틱(semantic) 요소를 선택하세요. 시맨틱 요소는 코드를 의미 있게 만들고 구조, 접근성 및 SEO를 개선합니다.</p><p><img src="/images/header/web-20_1.png" alt=""></p><h2 id="Form-요소-그룹화">Form 요소 그룹화</h2><p><code>&lt;fieldset&gt;</code> 태그를 사용하여 Form의 관련 요소를 그룹화하고 <code>&lt;legend&gt;</code> 태그를 <code>&lt;fieldset&gt;</code>와 함께 사용하여 <code>&lt;fieldset&gt;</code> 태그의 제목을 정의할 수 있습니다.</p><p>이는 보다 효율적이고 접근하기 쉬운 Form을 만드는 데 유용합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Personal details<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstname"</span>&gt;</span>First name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"firstname"</span> <span class="attr">name</span>=<span class="string">"firstname"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"contact"</span>&gt;</span>Contact:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"contact"</span> <span class="attr">name</span>=<span class="string">"contact"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Dropdown-메뉴-개선">Dropdown 메뉴 개선</h2><p><code>&lt;optgroup&gt;</code> 태그를 사용하여 <code>&lt;select&gt;</code> HTML 태그에서 관련 옵션을 그룹화할 수 있습니다. 큰 드롭다운 메뉴나 긴 옵션 목록으로 작업할 때 이 태그를 사용할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"Fruits"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Mango<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"Vegetables"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Tomato<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Broccoli<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Carrot<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="동영상-프레젠테이션-개선하기">동영상 프레젠테이션 개선하기</h2><p><code>&lt;video&gt;</code> 태그의 <code>poster</code> 속성을 사용하여 사용자가 비디오를 재생할 때까지 이미지를 표시할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"image.png"</span> <span class="attr">width</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4 /&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/video&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="다중-선택-지원">다중 선택 지원</h2><p><code>&lt;input&gt;</code> 및 <code>&lt;select&gt; </code>요소와 함께 <code>multiple</code> 속성을 사용하여 사용자가 한 번에 여러 값을 선택/입력할 수 있도록 할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"typescript"</span>&gt;</span>TypeScript<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"rust"</span>&gt;</span>Rust<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="텍스트를-아래-첨자-및-위-첨자로-표시하기">텍스트를 아래 첨자 및 위 첨자로 표시하기</h2><p><code>&lt;sub&gt;</code> 및 <code>&lt;sup&gt;</code> 요소를 사용하여 텍스트를 각각 아래 첨자와 위 첨자로 표시할 수 있습니다.</p><p><img src="/images/header/web-20_2.png" alt=""></p><h2 id="다운로드-링크-만들기">다운로드 링크 만들기</h2><p><code>&lt;a&gt;</code> 요소와 함께 <code>download</code> 속성을 사용하여 사용자가 링크를 클릭할 때 링크된 리소스를 탐색하는 대신 다운로드하도록 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">download</span>=<span class="string">"document.pdf"</span>&gt;</span> Download PDF <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="상대-링크에-대한-기본-URL-정의하기">상대 링크에 대한 기본 URL 정의하기</h2><p><code>&lt;base&gt;</code> 태그를 사용하여 웹 페이지의 모든 상대 URL에 대한 기준 URL을 정의할 수 있습니다.</p><p>이 태그는 웹 페이지의 모든 상대 URL에 대한 공유 시작점을 만들어 리소스를 쉽게 탐색하고 로드할 수 있도록 하려는 경우에 유용합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog"</span>&gt;</span>Blogs<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/get-in-touch"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="이미지-로딩-제어">이미지 로딩 제어</h2><p><code>&lt;img&gt;</code> 요소가 포함된 <code>loading</code> 속성을 사용하여 브라우저에서 이미지를 로드하는 방법을 제어할 수 있습니다. 세 가지 값이 있습니다: “eager”, “lazy”, &quot;auto&quot;의 세 가지 값이 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"picture.jpg"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="번역-기능-관리">번역 기능 관리</h2><p><code>translate</code> 속성을 사용하여 요소의 콘텐츠를 브라우저의 번역 기능으로 번역할지 여부를 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">translate</span>=<span class="string">"no"</span>&gt;</span>This text should not be translated.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="최대-입력-길이-설정하기">최대 입력 길이 설정하기</h2><p><code>maxlength</code> 속성을 사용하여 사용자가 입력 필드에 입력할 수 있는 최대 글자 수를 설정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">maxlength</span>=<span class="string">"4"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="최소-입력-길이-설정하기">최소 입력 길이 설정하기</h2><p><code>minlength</code> 속성을 사용하여 사용자가 입력 필드에 입력하는 최소 글자 수를 설정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">minlength</span>=<span class="string">"3"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="콘텐츠-편집-활성화">콘텐츠 편집 활성화</h2><p><code>contenteditable</code> 속성을 사용하여 요소의 콘텐츠를 편집할 수 있는지 여부를 지정합니다. 이를 통해 사용자는 요소 내의 콘텐츠를 수정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span>You can edit this content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="맞춤법-검사-제어">맞춤법 검사 제어</h2><p><code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, 콘텐츠 편집 가능 요소와 함께 <code>spellcheck</code> 속성을 사용하여 브라우저에서 맞춤법 검사를 활성화 또는 비활성화할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="접근성-보장하기">접근성 보장하기</h2><p><code>alt</code> 속성은 이미지를 표시할 수 없는 경우 이미지의 대체 텍스트를 지정합니다. 접근성과 SEO를 개선하려면 항상 이미지에 설명이 포함된 <code>alt</code> 속성을 포함하세요.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"picture.jpg"</span> <span class="attr">alt</span>=<span class="string">"Description for the image"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Link에-대한-타깃-동작-정의하기">Link에 대한 타깃 동작 정의하기</h2><p><code>target</code> 속성을 사용하여 링크된 리소스를 클릭할 때 표시할 위치를 지정할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 같은 프레임에서 열림 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 새 창 또는 탭에서 열기 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 상위 프레임에서 열림 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"_parent"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 창 전체 본문에서 열림 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"_top"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 명명된 프레임에서 열림 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.dev"</span> <span class="attr">target</span>=<span class="string">"framename"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="추가-정보-제공">추가 정보 제공</h2><p><code>title</code> 속성은 사용자가 요소 위로 마우스를 가져갈 때 요소에 대한 추가 정보를 제공하는 데 사용할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">"World Health Organization"</span>&gt;</span>WHO<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="특정-파일-형식-허용">특정 파일 형식 허용</h2><p>서버에서 수용할 파일 유형을 지정하기 위해 <code>accept</code> 속성을 사용할 수 있습니다(파일 유형에만 해당). 이는 <code>&lt;input&gt;</code> 요소와 함께 사용됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/png, image/jpeg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="동영상-로딩-최적화">동영상 로딩 최적화</h2><p><code>&lt;video&gt;</code> 요소와 함께 <code>preload</code> 속성을 사용하면 비디오 파일을 더 빠르게 로드하여 더 원활하게 재생할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"video.mp4"</span> <span class="attr">preload</span>=<span class="string">"auto"</span>&gt;</span></span><br><span class="line">   Your browser does not support the video tag.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/24/web-20/#disqus_thread</comments>
    </item>
    
    <item>
      <title>시간을 절약할 수 있는 6가지 CSS Cheat Sheet</title>
      <link>http://hgko1207.github.io/2024/09/24/web-19/</link>
      <guid>http://hgko1207.github.io/2024/09/24/web-19/</guid>
      <pubDate>Tue, 24 Sep 2024 01:14:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;매우 유용한 6가지 CSS Cheat Sheet를 알려드리겠습니다. 참고하세요!&lt;/p&gt;
&lt;h2 id=&quot;CSS-Flexbox&quot;&gt;CSS Flexbox&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/header/web-19_1.png&quot; alt=&quot;&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>매우 유용한 6가지 CSS Cheat Sheet를 알려드리겠습니다. 참고하세요!</p><h2 id="CSS-Flexbox">CSS Flexbox</h2><p><img src="/images/header/web-19_1.png" alt=""></p><h2 id="CSS-Grid">CSS Grid</h2><p><img src="/images/header/web-19_2.png" alt=""></p><h2 id="CSS-Positions">CSS Positions</h2><p><img src="/images/header/web-19_3.png" alt=""></p><h2 id="CSS-Display-Values">CSS Display Values</h2><p><img src="/images/header/web-19_4.png" alt=""></p><h2 id="CSS-Selectors">CSS Selectors</h2><p><img src="/images/header/web-19_5.png" alt=""></p><h2 id="CSS-nth-child-Selectors">CSS :nth-child Selectors</h2><p><img src="/images/header/web-19_6.png" alt=""></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/24/web-19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모든 개발자가 알아야 할 25가지 자바스크립트 기초</title>
      <link>http://hgko1207.github.io/2024/09/23/js-dev-26/</link>
      <guid>http://hgko1207.github.io/2024/09/23/js-dev-26/</guid>
      <pubDate>Mon, 23 Sep 2024 01:13:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/js-dev-24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트는 최신 웹 개발에 필수적인 다재다능하고 강력한 언어입니다. 다음은 더 효율적이고 효과적인 자바스크립트 개발자가 될 수 있는 25가지 기
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/js-dev-24.png" alt=""></p><p>자바스크립트는 최신 웹 개발에 필수적인 다재다능하고 강력한 언어입니다. 다음은 더 효율적이고 효과적인 자바스크립트 개발자가 될 수 있는 25가지 기초 문법에 대한 자세한 설명 및 예제입니다.</p><h2 id="1-var-대신-let과-const-사용">1. <code>var</code> 대신 <code>let</code>과 <code>const</code> 사용</h2><p><code>let</code>과 <code>const</code>를 사용하면 변수가 정의된 블록 내에서만 액세스할 수 있도록 하여 범위 관련 버그를 방지할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h2 id="2-Default-Parameters">2. Default Parameters</h2><p>Default Parameter는 함수에 합리적인 기본값을 설정하여 오류를 방지하고 코드를 더욱 견고하게 만듭니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name = <span class="string">'Guest'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greet()); <span class="comment">// "Hello, Guest!"</span></span><br></pre></td></tr></table></figure><h2 id="3-Template-Literals">3. Template Literals</h2><p>Template Literal을 사용하면 임베디드 표현식과 여러 줄 문자열을 포함하는 문자열을 더 쉽게 만들 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'John'</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// "Hello, John!"</span></span><br></pre></td></tr></table></figure><h2 id="4-구조-분해-할당-Destructuring-Assignment">4. 구조 분해 할당(Destructuring Assignment)</h2><p>구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 별개의 변수로 쉽게 추출할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Jane'</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = user;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">// "Jane" 25</span></span><br></pre></td></tr></table></figure><h2 id="5-Arrow-Functions">5. Arrow Functions</h2><p>Arrow Function는 함수 표현식에 간결한 구문을 제공하고 <code>this</code>이 어휘적으로 바인딩되도록 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="6-Spread-Operator">6. Spread Operator</h2><p>배열이나 객체를 결합하는 것이 번거로울 수 있습니다. Spread Operator를 사용하면 배열과 객체를 쉽게 결합할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combined = [...arr1, ...arr2];</span><br><span class="line"><span class="built_in">console</span>.log(combined); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="7-Rest-Parameters">7. Rest Parameters</h2><p>다양한 수의 함수 인수를 처리하는 것은 까다로울 수 있습니다. Rest Parameter를 사용하면 무한한 수의 인수를 배열로 처리할 수 있으므로 함수를 더욱 유연하게 만들 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="8-단략-평가-Short-Circuit-Evaluation">8. 단략 평가(Short-Circuit Evaluation)</h2><p>조건문을 작성하는 것은 장황할 수 있습니다. 단략 평가는 논리 <code>&amp;&amp;</code> 및 <code>||</code> 연산자를 사용하여 조건 표현식을 단순화합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isLoggedIn = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> user = isLoggedIn &amp;&amp; &#123; <span class="attr">name</span>: <span class="string">'Jane'</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; name: 'Jane', age: 25 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="9-옵셔널-체이닝-Optional-Chaining">9. 옵셔널 체이닝(Optional Chaining)</h2><p>체인의 각 레벨에서 <code>null</code> 또는 <code>undefined</code>을 명시적으로 확인하지 않고도 중첩된 프로퍼티에 안전하게 액세스할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">profile</span>: &#123; <span class="attr">name</span>: <span class="string">'Jane'</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> userName = user?.profile?.name;</span><br><span class="line"><span class="built_in">console</span>.log(userName); <span class="comment">// "Jane"</span></span><br></pre></td></tr></table></figure><h2 id="10-Nullish-Coalescing">10. Nullish Coalescing</h2><p><code>||</code>를 사용하여 기본값을 제공하면 값이 <code>0</code> 또는 <code>&quot;&quot;</code>인 경우 예기치 않은 결과가 발생할 수 있습니다. Nullish Coalescing(<code>??</code>)을 사용하여 <code>null</code> 또는 <code>undefined</code> 경우에만 기본값을 제공하세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">''</span>, <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> userName = user.name ?? <span class="string">'Anonymous'</span>;</span><br><span class="line"><span class="keyword">const</span> userAge = user.age ?? <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(userName); <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log(userAge); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="11-Property-Shorthand">11. Property Shorthand</h2><p>변수 이름과 일치하는 경우 속성 이름을 생략할 수 있어 코드가 더 깔끔해집니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'Jane'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> user = &#123; name, age &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; name: 'Jane', age: 25 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="12-Dynamic-Property-Names">12. Dynamic Property Names</h2><p>표현식 값을 속성 이름으로 사용하여 객체 속성을 동적으로 생성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propName = <span class="string">'age'</span>;</span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Jane'</span>, [propName]: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; name: 'Jane', age: 25 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="13-map-filter-reduce-사용하기">13. <code>map()</code>, <code>filter()</code>, <code>reduce()</code> 사용하기</h2><p>일반적인 배열 연산에는 <code>map()</code>, <code>filter()</code>, <code>reduce()</code>를 사용하세요. 이러한 배열 메서드는 배열을 변환, 필터링 및 축소하는 기능적 접근 방식을 제공하여 코드를 보다 표현력 있고 간결하게 만듭니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function">(<span class="params">num</span>) =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evens = numbers.filter(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(evens); <span class="comment">// [2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h2 id="14-문자열-includes-startsWith-및-endsWith">14. 문자열 <code>includes()</code>, <code>startsWith()</code> 및 <code>endsWith()</code></h2><p>더 간단한 문자열 검사를 위해 <code>includes()</code>, <code>startsWith()</code> 및 <code>endsWith()</code>를 사용하세요. 이러한 문자열 메서드는 하위 문자열의 존재, 시작 또는 끝을 간단하고 읽기 쉽게 확인할 수 있는 방법을 제공합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Hello, world!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'world'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">'Hello'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'!'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="15-함수-매개변수에서-배열-및-객체-구조-분해">15. 함수 매개변수에서 배열 및 객체 구조 분해</h2><p>함수 매개변수로 전달된 배열이나 객체에서 값을 추출하는 것은 장황할 수 있습니다. 함수 매개변수에서 구조조정을 사용하여 값을 직접 추출하세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Jane'</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>! You are <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greet(user)); <span class="comment">// "Hello, Jane! You are 25 years old."</span></span><br></pre></td></tr></table></figure><h2 id="16-Destructuring의-기본값">16. Destructuring의 기본값</h2><p>누락될 수 있는 속성에 대한 대체 값을 제공하여 코드를 더욱 견고하게 만들 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Jane'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age = <span class="number">18</span> &#125; = user;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "Jane"</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h2 id="17-Object-assign">17. Object <code>assign()</code></h2><p>객체 복제 또는 병합은 장황하고 오류가 발생하기 쉽습니다. <code>Object.assign()</code>을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있으므로 수동 복사의 필요성을 줄일 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> merged = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(merged); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="18-find-및-findIndex">18. <code>find()</code> 및 <code>findIndex()</code></h2><p>배열에서 요소나 그 인덱스를 찾는 것이 번거로울 수 있습니다. <code>find()</code> 및 <code>findIndex()</code> 메서드는 조건에 따라 요소 또는 그 인덱스를 찾는 간단한 방법을 제공하여 코드 가독성을 향상시킵니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Jane'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = users.find(<span class="function">(<span class="params">u</span>) =&gt;</span> u.id === <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; id: 1, name: 'Jane' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = users.findIndex(<span class="function">(<span class="params">u</span>) =&gt;</span> u.id === <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="19-some-및-every">19. <code>some()</code> 및 <code>every()</code></h2><p><code>some()</code> 및 <code>every()</code> 메서드를 사용하면 배열의 일부 또는 모든 요소가 조건을 충족하는지 간결한 방식으로 확인할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> hasEven = numbers.some(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hasEven); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> allEven = numbers.every(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(allEven); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="20-flat-및-flatMap">20. <code>flat()</code> 및 <code>flatMap()</code></h2><p><code>flat()</code> 및 <code>flatMap()</code> 메서드는 중첩 배열을 평평하게 만들고 한 단계로 매핑 및 평평하게 만드는 간단한 방법을 제공합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nested = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]];</span><br><span class="line"><span class="keyword">const</span> flat = nested.flat(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flat); <span class="comment">// [1, 2, 3, [4]]</span></span><br><span class="line"><span class="keyword">const</span> mapped = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(mapped); <span class="comment">// [1, 2, 2, 4, 3, 6]</span></span><br></pre></td></tr></table></figure><h2 id="21-from-및-of">21. <code>from()</code> 및 <code>of()</code></h2><p><code>Array.from()</code>을 사용하면 iterable 객체에서 배열을 만들 수 있고, <code>Array.of()</code>을 사용하면 인자 목록에서 배열을 만들 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">const arrFromSet = Array.from(<span class="keyword">set</span>);</span><br><span class="line">console.log(arrFromSet); // [1, 2, 3]</span><br><span class="line">const arrOfNumbers = Array.of(1, 2, 3);</span><br><span class="line">console.log(arrOfNumbers); // [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="22-콜백의-매개변수-구조-분해">22. 콜백의 매개변수 구조 분해</h2><p>콜백 매개변수에서 구조 분해를하면 콜백에 전달된 객체의 속성에 직접 액세스할 수 있으므로 코드를 더욱 간결하게 만들 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Jane'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">];</span><br><span class="line">users.forEach(<span class="function">(<span class="params">&#123; id, name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`User ID: <span class="subst">$&#123;id&#125;</span>, User Name: <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="23-선택적-콜백-함수">23. 선택적 콜백 함수</h2><p>Short-circuit evaluation를 사용하면 선택적 콜백 함수가 제공된 경우에만 호출할 수 있으므로 코드가 더욱 견고해집니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  fetch(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      callback &amp;&amp; callback(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-Promisify-Callbacks">24. Promisify Callbacks</h2><p><code>promisify</code> 유틸리티 함수를 사용하여 콜백 기반 함수를 Promise으로 변환할 수 있으므로 async/await 구문으로 작업하기가 더 쉬워집니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fn(...args, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">        <span class="keyword">else</span> resolve(result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(<span class="built_in">require</span>(<span class="string">'fs'</span>).readFile);</span><br><span class="line">readFile(<span class="string">'path/to/file.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><h2 id="25-동시-실행을-위한-Promise-all">25. 동시 실행을 위한 Promise.all</h2><p>여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다. <code>Promise.all</code>을 사용하면 여러 비동기 작업을 동시에 처리하고 모든 작업이 완료되면 계속 진행할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData1 = fetch(<span class="string">'https://api.example.com/data1'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json());</span><br><span class="line"><span class="keyword">const</span> fetchData2 = fetch(<span class="string">'https://api.example.com/data2'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json());</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([fetchData1, fetchData2])</span><br><span class="line">  .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Data 1:'</span>, data1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Data 2:'</span>, data2);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/23/js-dev-26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Node.js] Winston 사용하여 로깅하기</title>
      <link>http://hgko1207.github.io/2024/09/20/nodejs-8/</link>
      <guid>http://hgko1207.github.io/2024/09/20/nodejs-8/</guid>
      <pubDate>Fri, 20 Sep 2024 04:41:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;로깅&lt;/strong&gt;(Logging)은 모든 애플리케이션에서 중요한 부분입니다. 로깅은 코드 디버깅, 모니터링 및 유지 관리에 도움이 됩니다. &lt;strong&gt;Winston&lt;/strong&gt;은 유연성과 풍부한 기능으로 인해 Node.j
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>로깅</strong>(Logging)은 모든 애플리케이션에서 중요한 부분입니다. 로깅은 코드 디버깅, 모니터링 및 유지 관리에 도움이 됩니다. <strong>Winston</strong>은 유연성과 풍부한 기능으로 인해 Node.js에서 가장 인기 있는 로깅 라이브러리 중 하나입니다. 이 글에서는 Winston을 Node.js 애플리케이션에 통합하고 그 기능을 최대한 활용하는 방법을 살펴봅니다.</p><p><img src="/images/header/nodejs-8.png" alt=""></p><h2 id="개요">개요</h2><p>이 튜토리얼에서는 다음을 다룹니다:</p><ul><li>Node.js 프로젝트에서 Winston 설정하기</li><li>다양한 로깅 수준 구성하기</li><li>사용자 정의 로그 형식 만들기</li><li>여러 전송(콘솔, 파일 등)에 로깅하기</li><li>사용자 지정 로그 수준 만들기</li><li>일일 로그 파일에 로깅하기</li><li>Express 애플리케이션에서 Winston 사용하기</li></ul><h2 id="전제-조건">전제 조건</h2><ul><li>JavaScript 및 Node.js에 대한 기본 지식</li><li>npm 및 Express에 익숙함(선택 사항이지만 마지막 단계에 권장됨).</li></ul><h2 id="설정">설정</h2><p>Node.js 프로젝트를 초기화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir winston-logger-example</span><br><span class="line"><span class="built_in">cd</span> winston-logger-example</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>Winston를 설치합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express winston winston-daily-rotate-file</span><br></pre></td></tr></table></figure><h2 id="기본-설정">기본 설정</h2><p>Winston을 설정하기 위한 <code>logger.js</code> 파일을 생성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  level: <span class="string">'info'</span>,</span><br><span class="line">  format: format.combine(</span><br><span class="line">    format.colorize(),</span><br><span class="line">    format.timestamp(),</span><br><span class="line">    format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  ),</span><br><span class="line">  transports: [<span class="keyword">new</span> transports.Console(), <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'app.log'</span> &#125;)],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>createLogger:</strong> 새 로거 인스턴스를 초기화합니다.</li><li><strong>format.combine:</strong> 여러 형식을 결합합니다. 여기서는 <code>colorize</code>, <code>timestamp</code>, <code>printf</code>를 사용하고 있습니다.</li><li><strong>transports:</strong> 로그를 전송할 위치를 지정합니다. 이 예에서는 콘솔과 파일(<code>app.log</code>)에 로깅합니다.</li></ul><h2 id="로깅-레벨-구성하기">로깅 레벨 구성하기</h2><p>Winston은 <code>error</code>, <code>warn</code>, <code>info</code>, <code>http</code>, <code>verbose</code>, <code>debug</code>, <code>silly</code> 등 여러 로깅 레벨을 지원합니다. 캡처할 로그의 최소 레벨을 구성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  levels: &#123;</span><br><span class="line">    error: <span class="number">0</span>,</span><br><span class="line">    warn: <span class="number">1</span>,</span><br><span class="line">    info: <span class="number">2</span>,</span><br><span class="line">    http: <span class="number">3</span>,</span><br><span class="line">    verbose: <span class="number">4</span>,</span><br><span class="line">    debug: <span class="number">5</span>,</span><br><span class="line">    silly: <span class="number">6</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  level: <span class="string">'info'</span>, <span class="comment">// Set the default log level</span></span><br><span class="line">  format: format.combine(</span><br><span class="line">    format.colorize(),</span><br><span class="line">    format.timestamp(),</span><br><span class="line">    format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  ),</span><br><span class="line">  transports: [<span class="keyword">new</span> transports.Console(), <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'app.log'</span> &#125;)],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>levels:</strong> 사용자 정의 로깅 레벨을 정의합니다.</li><li><strong>level:</strong> 캡처할 로그의 최소 레벨을 설정합니다(여기서는 <code>info</code>로 설정되어 있음).</li></ul><h2 id="로그-레벨-이해하기">로그 레벨 이해하기</h2><p>로그 레벨은 기록되는 메시지의 심각도를 결정합니다. Winston은 가장 심각한 것부터 가장 덜 심각한 것까지 우선순위가 지정된 npm 스타일 로깅 레벨을 사용합니다.</p><ul><li><strong>error: (0)</strong> 즉각적인 주의가 필요할 수 있는 오류를 로깅합니다.</li><li><strong>warn: (1)</strong> 잠재적 문제를 나타내는 경고를 로깅합니다.</li><li><strong>info: (2)</strong> 애플리케이션의 진행 상황을 강조하는 정보 메시지를 로깅합니다.</li><li><strong>http: (3)</strong> HTTP 요청을 로깅합니다.</li><li><strong>verbose: (4)</strong> 디버깅 중 유용한 상세 정보를 로깅합니다.</li><li><strong>debug: (5)</strong> 디버깅 정보를 기록합니다.</li><li><strong>silly: (6)</strong> 가장 자세한 정보, 종종 필요 이상으로 많은 정보를 로깅합니다.</li></ul><p>최소 로그 레벨을 설정하여 덜 심각한 메시지를 필터링할 수 있습니다. 예를 들어 로그 레벨을 <code>info</code>로 설정하면 <code>info</code>, <code>warn</code> 및 <code>error</code> 메시지만 기록됩니다.</p><h2 id="사용자-지정-로그-형식-만들기">사용자 지정 로그 형식 만들기</h2><p>필요에 따라 사용자 지정 로그 형식을 만들 수 있습니다. 예를 들어 메타데이터를 추가하거나 로그 메시지 구조를 변경할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customFormat = format.combine(</span><br><span class="line">  format.colorize(),</span><br><span class="line">  format.timestamp(),</span><br><span class="line">  format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message, ...meta &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span> <span class="subst">$&#123;<span class="built_in">Object</span>.keys(meta).length ? <span class="built_in">JSON</span>.stringify(meta, <span class="literal">null</span>, <span class="number">2</span>) : <span class="string">''</span>&#125;</span>`</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  level: <span class="string">'info'</span>,</span><br><span class="line">  format: customFormat,</span><br><span class="line">  transports: [<span class="keyword">new</span> transports.Console(), <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'app.log'</span> &#125;)],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>customFormat:</strong> timestamp, log level, message 및 optional metadata를 구조화된 로그 형식으로 결합합니다.</li></ul><h2 id="여러-전송에-로깅">여러 전송에 로깅</h2><p>Winston은 다양한 파일, 외부 로깅 서비스 또는 콘솔과 같은 여러 대상에 로깅할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  level: <span class="string">'info'</span>,</span><br><span class="line">  format: format.combine(</span><br><span class="line">    format.timestamp(),</span><br><span class="line">    format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  ),</span><br><span class="line">  transports: [</span><br><span class="line">    <span class="keyword">new</span> transports.Console(),</span><br><span class="line">    <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'app.log'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'error.log'</span>, <span class="attr">level</span>: <span class="string">'error'</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>transports.File({ filename: ‘error.log’, level: ‘error’ }):</strong> 오류 메시지를 별도의 파일에 기록합니다.</li></ul><h2 id="사용자-정의-로그-레벨-생성">사용자 정의 로그 레벨 생성</h2><p>Winston에서 사용자 지정 로그 레벨을 직접 정의할 수 있습니다. 이 기능은 기본 레벨에서 다루지 않는 특정 요구 사항이 있는 경우에 유용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports, config &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customLevels = &#123;</span><br><span class="line">  levels: &#123;</span><br><span class="line">    critical: <span class="number">0</span>,</span><br><span class="line">    error: <span class="number">1</span>,</span><br><span class="line">    warn: <span class="number">2</span>,</span><br><span class="line">    info: <span class="number">3</span>,</span><br><span class="line">    debug: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  colors: &#123;</span><br><span class="line">    critical: <span class="string">'red'</span>,</span><br><span class="line">    error: <span class="string">'red'</span>,</span><br><span class="line">    warn: <span class="string">'yellow'</span>,</span><br><span class="line">    info: <span class="string">'green'</span>,</span><br><span class="line">    debug: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  levels: customLevels.levels,</span><br><span class="line">  level: <span class="string">'info'</span>, <span class="comment">// Set the default log level</span></span><br><span class="line">  format: format.combine(</span><br><span class="line">    format.colorize(&#123; <span class="attr">all</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    format.timestamp(),</span><br><span class="line">    format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  ),</span><br><span class="line">  transports: [<span class="keyword">new</span> transports.Console(), <span class="keyword">new</span> transports.File(&#123; <span class="attr">filename</span>: <span class="string">'app.log'</span> &#125;)],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">winston.addColors(customLevels.colors);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>customLevels:</strong> 사용자 지정 로깅 레벨과 해당 색상을 정의합니다.</li><li><strong>winston.addColors:</strong> 로깅 레벨에 사용자 지정 색상을 적용합니다.</li></ul><h2 id="일일-로그-파일에-로깅하기">일일 로그 파일에 로깅하기</h2><p><code>winston-daily-rotate-file</code> 전송을 사용하여 매일 새 로그 파일을 만들 수 있습니다.</p><p><code>winston-daily-rotate-file</code>을 설치합니다:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install winston-daily-rotate-file</span><br></pre></td></tr></table></figure><p>매일 로테이션 파일 전송을 구성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createLogger, format, transports &#125; = <span class="built_in">require</span>(<span class="string">'winston'</span>);</span><br><span class="line"><span class="keyword">const</span> DailyRotateFile = <span class="built_in">require</span>(<span class="string">'winston-daily-rotate-file'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(&#123;</span><br><span class="line">  level: <span class="string">'info'</span>,</span><br><span class="line">  format: format.combine(</span><br><span class="line">    format.timestamp(),</span><br><span class="line">    format.printf(<span class="function">(<span class="params">&#123; timestamp, level, message &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;timestamp&#125;</span> <span class="subst">$&#123;level&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  ),</span><br><span class="line">  transports: [</span><br><span class="line">    <span class="keyword">new</span> transports.Console(),</span><br><span class="line">    <span class="keyword">new</span> DailyRotateFile(&#123;</span><br><span class="line">      filename: <span class="string">'application-%DATE%.log'</span>,</span><br><span class="line">      datePattern: <span class="string">'YYYY-MM-DD'</span>,</span><br><span class="line">      zippedArchive: <span class="literal">true</span>,</span><br><span class="line">      maxSize: <span class="string">'20m'</span>,</span><br><span class="line">      maxFiles: <span class="string">'14d'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logger;</span><br></pre></td></tr></table></figure><ul><li><strong>DailyRotateFile:</strong> 지정된 날짜 패턴으로 매일 새 로그 파일을 만듭니다.</li><li><strong>zippedArchive:</strong> 이전 로그 파일을 압축합니다.</li><li><strong>maxSize:</strong> 회전하기 전 로그 파일의 최대 크기입니다.</li><li><strong>maxFiles:</strong> 로그 파일을 보관할 수 있는 최대 일수입니다.</li></ul><h2 id="Express-애플리케이션에서-Winston-사용">Express 애플리케이션에서 Winston 사용</h2><p>Winston을 Express 애플리케이션에 통합하여 HTTP 요청 및 오류에 대한 로깅을 처리합니다.</p><p>Express를 설치합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>Winston으로 Express 서버를 설정합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 요청 로깅</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  logger.http(<span class="string">`<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 오류 처리 미들웨어</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  logger.error(err.message);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Internal Server Error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, () =&gt; &#123;</span><br><span class="line">  logger.info(<span class="string">`Server is running on http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>HTTP 요청 로깅:</strong> 미들웨어는 <code>logger.http</code>를 사용하여 들어오는 모든 HTTP 요청을 기록합니다.</li><li><strong>오류 처리 미들웨어:</strong> <code>logger.error</code>를 사용하여 오류를 기록합니다.</li></ul><h2 id="결론">결론</h2><p>Winston을 Node.js 애플리케이션에 통합하면 코드를 보다 효과적으로 디버그, 모니터링 및 유지 관리하는 데 도움이 되는 강력하고 유연한 로깅 시스템을 만들 수 있습니다. 콘솔, 파일 또는 외부 서비스에 로깅해야 하는 경우 Winston의 풍부한 기능 세트는 Node.js 로깅을 위한 탁월한 선택입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/20/nodejs-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>꼭 사용해봐야 할 11가지 VS Code 테마</title>
      <link>http://hgko1207.github.io/2024/09/20/info-26/</link>
      <guid>http://hgko1207.github.io/2024/09/20/info-26/</guid>
      <pubDate>Fri, 20 Sep 2024 03:54:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;VS Code는 개발자들 사이에서 가장 인기 있는 코드 편집기 중 하나입니다. VS Code의 가장 매력적인 측면 중 하나는 테마를 통해 개인화할 수 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-26.png" alt=""></p><p>VS Code는 개발자들 사이에서 가장 인기 있는 코드 편집기 중 하나입니다. VS Code의 가장 매력적인 측면 중 하나는 테마를 통해 개인화할 수 있다는 점입니다. 테마는 코딩을 더 즐겁게 만들고, 눈의 피로를 줄여주며, 집중력을 향상시킬 수 있습니다.</p><p>이 글에서는 여러분이 꼭 사용해 보아야 할 11가지 VS Code 테마를 소개합니다.</p><h2 id="Tokyo-Night"><a href="https://marketplace.visualstudio.com/items?itemName=enkia.tokyo-night" target="_blank" rel="noopener">Tokyo Night</a></h2><p><img src="/images/header/info-26_1.png" alt=""></p><p><strong>설치:</strong> 1,678,000+<br><strong>특징:</strong></p><ul><li>어둡고 밝은 테마</li><li>눈의 피로를 줄이기 위한 색상 디자인</li><li>가독성 향상을 위한 뛰어난 구문 강조 표시</li></ul><h2 id="Dracula"><a href="https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula" target="_blank" rel="noopener">Dracula</a></h2><p><img src="/images/header/info-26_2.png" alt=""></p><p><strong>설치:</strong> 7,662,000+<br><strong>특징:</strong></p><ul><li>밝은 색상의 어두운 테마</li><li>가독성 향상을 위한 생생한 색상</li><li>멋진 스타일로 많은 개발자에게 사랑받는 테마</li></ul><h2 id="Synthwave-84"><a href="https://marketplace.visualstudio.com/items?itemName=RobbOwen.synthwave-vscode" target="_blank" rel="noopener">Synthwave '84</a></h2><p><img src="/images/header/info-26_3.png" alt=""></p><p><strong>설치:</strong> 1,978,100+<br><strong>특징</strong></p><ul><li>1980년대에서 영감을 받은 레트로한 미래지향적 네온 컬러</li><li>진정한 Synthwave 경험을 위한 독특한 글로우 효과 제공</li><li>재미있고 화려한 테마를 원한다면 완벽함</li></ul><h2 id="One-Dark-Pro-Darker"><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme" target="_blank" rel="noopener">One Dark Pro Darker</a></h2><p><img src="/images/header/info-26_4.png" alt=""></p><p><strong>설치:</strong> 9,830,100+<br><strong>특징:</strong></p><ul><li>Atom의 One Dark 테마 기반</li><li>더 깊은 대비와 눈의 피로를 줄여주는 더 어두운 테마</li><li>깔끔하고 전문적인 외관</li></ul><h2 id="Monokai-Pro"><a href="https://marketplace.visualstudio.com/items?itemName=monokai.theme-monokai-pro-vscode" target="_blank" rel="noopener">Monokai Pro</a></h2><p><img src="/images/header/info-26_5.png" alt=""></p><p><strong>설치:</strong> 3,077,300+<br><strong>특징:</strong></p><ul><li>클래식 Monokai 테마 기반</li><li>하나의 패키지에 다양한 색상 구성</li><li>부드러운 색상과 가독성</li></ul><h2 id="Catppuccin"><a href="https://marketplace.visualstudio.com/items?itemName=Catppuccin.catppuccin-vsc" target="_blank" rel="noopener">Catppuccin</a></h2><p><img src="/images/header/info-26_6.png" alt=""></p><p><strong>설치:</strong> 438,360+<br><strong>특징:</strong></p><ul><li>부드러운 파스텔 색상 팔레트</li><li>라떼, 프라페, 마끼아또, 모카와 같은 다양한 버전</li><li>눈이 편하고 보기 좋은 디자인</li></ul><h2 id="GitHub-Dark-Default-Theme"><a href="https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme" target="_blank" rel="noopener">GitHub Dark Default Theme</a></h2><p><img src="/images/header/info-26_7.png" alt=""></p><p><strong>설치:</strong> 14,301,800+<br><strong>특징:</strong></p><ul><li>GitHub의 공식 다크 테마</li><li>GitHub의 다크 모드를 사용하는 경우 일관된 모양을 제공합니다.</li><li>깔끔하고 미니멀하며 눈이 편함</li></ul><h2 id="Night-Owl"><a href="https://marketplace.visualstudio.com/items?itemName=sdras.night-owl" target="_blank" rel="noopener">Night Owl</a></h2><p><img src="/images/header/info-26_8.png" alt=""></p><p><strong>설치:</strong> 2,693,100+<br><strong>특징:</strong></p><ul><li>야간 코딩을 위해 특별히 설계</li><li>저조도 환경에서도 눈이 편안한 고대비 색상</li><li>심야 코딩 세션에 탁월</li></ul><h2 id="Relaxed"><a href="https://marketplace.visualstudio.com/items?itemName=mischah.relaxed-theme" target="_blank" rel="noopener">Relaxed</a></h2><p><img src="/images/header/info-26_9.png" alt=""></p><p><strong>설치:</strong> 28,680+<br><strong>특징:</strong></p><ul><li>부드럽고 차분한 색상</li><li>장시간 코딩 세션 시 눈의 피로를 줄여줍니다.</li><li>스트레스 없는 코딩 경험을 위한 차분하고 편안한 테마</li></ul><h2 id="Winter-Is-Coming"><a href="https://marketplace.visualstudio.com/items?itemName=johnpapa.winteriscoming" target="_blank" rel="noopener">Winter Is Coming</a></h2><p><img src="/images/header/info-26_10.png" alt=""></p><p><strong>설치:</strong> 3,014,600+<br><strong>특징:</strong></p><ul><li>다크, 라이트, 블루 버전 제공</li><li>“왕좌의 게임” 시리즈에서 영감을 얻음</li><li>다양한 취향에 맞는 다양한 옵션 제공</li></ul><h2 id="Nord"><a href="https://marketplace.visualstudio.com/items?itemName=arcticicestudio.nord-visual-studio-code" target="_blank" rel="noopener">Nord</a></h2><p><img src="/images/header/info-26_11.png" alt=""></p><p><strong>설치:</strong> 998,830+<br><strong>특징:</strong></p><ul><li>시원하고 icy 색상 구성</li><li>미니멀하고 깔끔한 디자인에 집중</li><li>시원하고 차분한 색상과 프로페셔널한 룩으로 인기</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/20/info-26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>고급 자바스크립트 트릭 10가지 소개</title>
      <link>http://hgko1207.github.io/2024/09/20/js-dev-25/</link>
      <guid>http://hgko1207.github.io/2024/09/20/js-dev-25/</guid>
      <pubDate>Fri, 20 Sep 2024 02:07:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/js-dev-24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트는 개발 프로세스를 더 효율적으로 만들고 코드를 더 깔끔하게 만들 수 있는 많은 숨겨진 기능을 갖춘 다목적 언어입니다. 여러분이 잘 모르
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/js-dev-24.png" alt=""></p><p>자바스크립트는 개발 프로세스를 더 효율적으로 만들고 코드를 더 깔끔하게 만들 수 있는 많은 숨겨진 기능을 갖춘 다목적 언어입니다. 여러분이 잘 모르지만 코딩 실력을 크게 향상시킬 수 있는 고급 자바스크립트 트릭 10가지를 소개합니다.</p><h2 id="1-Aliasing을-사용한-구조-분해">1. Aliasing을 사용한 구조 분해</h2><p>구조조정을 사용하면 배열의 값이나 객체의 속성을 별개의 변수로 압축을 풀 수 있습니다. 에일리어싱(Aliasing)을 사용하면 이 과정에서 변수 이름을 변경할 수 있으므로 API와 같은 외부 소스의 데이터를 다룰 때 특히 유용합니다.</p><ul><li><strong>사용 사례:</strong> API에서 데이터를 가져올 경우 코드 가독성과 유지보수성을 높이기 위해 프로퍼티에 더 의미 있는 이름을 부여하고 싶을 때.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apiResponse = &#123; <span class="attr">first_name</span>: <span class="string">'John'</span>, <span class="attr">user_age</span>: <span class="number">30</span>, <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">'New York'</span>, <span class="attr">zip</span>: <span class="string">'10001'</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  first_name: firstName,</span><br><span class="line">  user_age: age,</span><br><span class="line">  address: &#123; <span class="attr">city</span>: hometown, <span class="attr">zip</span>: postalCode &#125;,</span><br><span class="line">&#125; = apiResponse;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// John</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(hometown); <span class="comment">// New York</span></span><br><span class="line"><span class="built_in">console</span>.log(postalCode); <span class="comment">// 10001</span></span><br></pre></td></tr></table></figure><p>왜 사용하는가? 변수 이름을 보다 명확하고 직관적으로 만들어 코드 가독성과 유지보수를 개선하는 데 도움이 됩니다. 에일리어싱을 사용하면 이름 충돌을 피하고 코드의 명확성을 높여 복잡한 데이터 구조로 작업하기가 더 쉬워집니다.</p><h2 id="2-Currying">2. Currying</h2><p>커링(Currying)은 여러 인수를 받는 함수를 각각 하나의 인수를 받는 일련의 함수로 변환하는 프로세스입니다. 이 기술을 사용하면 보다 유연하고 재사용 가능한 함수를 만들 수 있어 함수형 프로그래밍에 특히 유용할 수 있습니다.</p><ul><li><strong>사용 사례:</strong> 할인 적용을 위해 재사용 가능하고 구성 가능한 함수를 만듭니다. 서로 다른 할인율에 대해 별도의 함수를 작성하는 대신 하나의 커리 함수를 만들 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applyDiscount = <span class="function">(<span class="params">discount</span>) =&gt;</span> <span class="function">(<span class="params">price</span>) =&gt;</span> price - (price * discount) / <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> tenPercentOff = applyDiscount(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> twentyPercentOff = applyDiscount(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tenPercentOff(<span class="number">100</span>)); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(twentyPercentOff(<span class="number">100</span>)); <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> applyTax = <span class="function">(<span class="params">taxRate</span>) =&gt;</span> <span class="function">(<span class="params">price</span>) =&gt;</span> price + (price * taxRate) / <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> applyTenPercentTax = applyTax(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(applyTenPercentTax(<span class="number">100</span>)); <span class="comment">// 110</span></span><br><span class="line"><span class="built_in">console</span>.log(applyTenPercentTax(twentyPercentOff(<span class="number">100</span>))); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure><p>왜 사용하는가? 함수에 인수를 미리 설정할 수 있어 보다 모듈화되고 컴포저블한 코드를 만들 수 있습니다. 재사용 가능성이 높은 유틸리티 함수의 생성을 크게 간소화하여 코드베이스를 더 깔끔하고 유지 관리하기 쉽게 만들 수 있습니다. 커링은 함수를 부분적으로 적용하거나 다른 구성으로 재사용해야 하는 시나리오에서 특히 유용합니다.</p><h2 id="3-Debouncing-및-Throttling">3. Debouncing 및 Throttling</h2><p>디바운싱(Debouncing)과 쓰로틀링(Throttling)은 함수가 실행되는 빈도를 제어하는 기술입니다. 특히 성능을 저하시킬 수 있는 과도한 함수 호출을 방지하기 위해 이벤트 핸들러를 최적화하는 데 유용합니다.</p><h3 id="Debouncing">Debouncing</h3><p>디바운싱은 마지막 호출 이후 일정 시간이 경과할 때까지 함수가 다시 호출되지 않도록 합니다. 이는 검색 입력 필드와 같이 사용자가 입력을 멈출 때까지 기다렸다가 API 호출을 하고자 하는 시나리오에 유용합니다.</p><ul><li><strong>사용 사례:</strong> 검색 입력 필드를 최적화하여 API 호출 횟수를 줄입니다. 이렇게 하면 사용자가 입력을 마친 후에만 검색을 시작하여 서버 과부하를 방지하고 사용자 환경을 개선할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeoutId);</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> func.apply(<span class="keyword">this</span>, args), delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> search = debounce(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Searching for <span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// Imagine an API call here</span></span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'searchInput'</span>).addEventListener(<span class="string">'input'</span>, (event) =&gt; &#123;</span><br><span class="line">  search(event.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>사용자가 트리거 동작을 중단한 후에만 함수가 호출되도록 함으로써 불필요한 함수 호출 횟수를 줄여 성능과 사용자 경험을 개선합니다. 네트워크 요청이나 무거운 계산이 수반되는 작업에 특히 유용합니다.</p><h3 id="Throttling">Throttling</h3><p>쓰로틀링은 함수가 지정된 기간에 최대 한 번만 호출되도록 합니다. 이는 함수 호출 빈도를 제한하려는 스크롤 이벤트와 같은 시나리오에 유용합니다.</p><ul><li><strong>사용 사례:</strong> 스크롤 이벤트 처리를 최적화하여 성능을 개선합니다. 이를 통해 브라우저가 너무 많은 이벤트 호출에 압도되는 것을 방지하여 보다 원활하고 반응이 빠른 상호작용을 보장할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - lastCall &gt;= interval) &#123;</span><br><span class="line">      lastCall = now;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleScroll = throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Scrolled'</span>);</span><br><span class="line">  <span class="comment">// Imagine complex calculations or DOM updates here</span></span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, handleScroll);</span><br></pre></td></tr></table></figure><p>함수가 제어된 간격으로 호출되도록 하여 성능 문제를 방지하고 브라우저의 부하를 줄이며 더 나은 사용자 경험을 제공합니다. 쓰로틀링은 스크롤 또는 크기 조정 이벤트와 같이 자주 트리거될 수 있는 이벤트 리스너에 특히 유용합니다.</p><h2 id="4-Memoization">4. Memoization</h2><p>Memoization은 비용이 많이 드는 함수 호출의 결과를 캐시하고 동일한 입력이 다시 발생할 때 캐시된 결과를 반환하는 최적화 기법입니다. 이를 통해 연산량이 많은 함수, 특히 동일한 인수로 자주 호출되는 함수의 성능을 크게 향상시킬 수 있습니다.</p><ul><li><strong>사용 사례:</strong> 피보나치 계산과 같은 재귀 함수의 성능을 개선합니다. Memoization 기능이 없으면 피보나치 함수를 호출할 때마다 같은 값을 여러 번 중복 계산하게 되어 시간이 기하급수적으로 복잡해집니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">    <span class="keyword">if</span> (!cache[key]) &#123;</span><br><span class="line">      cache[key] = fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fibonacci = memoize(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">40</span>)); <span class="comment">// 102334155</span></span><br></pre></td></tr></table></figure><p>중복 계산을 방지하여 입력이 반복되는 함수의 성능을 크게 향상시킵니다. Memoization은 비효율적이고 반복적인 계산을 관리 가능한 선형 시간 연산으로 전환할 수 있으므로 성능 집약적인 작업을 최적화하는 데 필수적인 기술입니다.</p><h2 id="5-Proxy">5. Proxy</h2><p>프록시 객체를 사용하면 다른 객체에 대한 프록시를 생성하여 속성 조회, 할당, 열거, 함수 호출 등과 같은 기본 연산을 가로채고 재정의할 수 있습니다. 이를 통해 객체에 사용자 지정 동작을 추가할 수 있는 강력한 방법을 제공합니다.</p><ul><li><strong>사용 사례:</strong> 객체 속성 액세스 및 할당에 대한 유효성 검사 및 로깅. 예를 들어, 유형 제약 조건을 적용하고 액세스 시도를 기록하여 더 나은 제어 및 디버깅 기능을 제공할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: (target, prop) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Getting <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: (target, prop, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span> &amp;&amp; <span class="keyword">typeof</span> value !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Age must be a number'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Setting <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxyUser.name); <span class="comment">// Getting name, John</span></span><br><span class="line">proxyUser.age = <span class="number">35</span>; <span class="comment">// Setting age to 35</span></span><br><span class="line"><span class="comment">// proxyUser.age = '35'; // Throws TypeError</span></span><br></pre></td></tr></table></figure><p>유효성 검사, 로깅 등과 같은 객체 작업에 대한 사용자 정의 동작을 허용하여 객체 조작에 대한 제어를 강화합니다. 프록시는 액세스 제어 및 데이터 바인딩과 같은 복잡한 로직을 구현하는 데에도 사용할 수 있습니다. 따라서 프록시는 객체의 동작을 관리하고 확장하기 위한 다용도 도구입니다.</p><h2 id="6-Generators">6. Generators</h2><p>제너레이터는 종료했다가 나중에 다시 입력할 수 있는 함수로, 재입력 시에도 컨텍스트와 변수 바인딩을 유지합니다. 제너레이터는 반복기를 구현하고 비동기 작업을 동기식처럼 처리하는 데 유용합니다.</p><ul><li><strong>사용 사례:</strong> 사용자 지정 객체 탐색을 위한 iterator 구현. 제너레이터는 사용자 정의 반복 동작을 정의하는 간단한 방법을 제공하여 복잡한 데이터 구조를 쉽게 순회할 수 있도록 해줍니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">city</span>: <span class="string">'New York'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name: John</span></span><br><span class="line"><span class="comment">// age: 30</span></span><br><span class="line"><span class="comment">// city: New York</span></span><br></pre></td></tr></table></figure><p>제너레이터를 사용하면 복잡한 반복 로직과 비동기 프로세스를 보다 쉽게 처리할 수 있어 코드 가독성과 유지 관리가 용이해집니다. 또한 <code>co</code>와 같은 라이브러리를 사용하여 보다 간단하고 선형적인 방식으로 비동기 작업을 관리하는 등의 작업에도 사용할 수 있습니다.</p><h2 id="7-Console-활용하기">7. Console 활용하기</h2><ul><li><strong>사용 사례:</strong> 복잡한 객체 디버깅을 위한 로깅 개선. <code>console.table</code>, <code>console.group</code>, <code>console.time</code>과 같은 콘솔 메서드는 보다 체계적이고 유익한 디버그 정보를 제공할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic logging</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Simple log'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'This is an error'</span>);</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'This is a warning'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logging tabular data</span></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">city</span>: <span class="string">'New York'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Jane'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">city</span>: <span class="string">'San Francisco'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.table(users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grouping logs</span></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">'User Details'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'User 1: John'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'User 2: Jane'</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timing code execution</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'Timer'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// Some heavy computation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'Timer'</span>);</span><br></pre></td></tr></table></figure><p>디버깅 정보의 가시성과 정리가 향상되어 문제를 더 쉽게 진단하고 해결할 수 있습니다. 콘솔 방법을 올바르게 사용하면 명확하고 체계적이며 상세한 로그를 제공함으로써 디버깅 프로세스의 효율성을 크게 향상시킬 수 있습니다.</p><h2 id="8-structuredClone을-사용한-구조화된-복제">8. <code>structuredClone</code>을 사용한 구조화된 복제</h2><p>새로운 <code>structuredClone</code>을 사용하여 오브젝트를 Deep Clone합니다. 기존의 얕은 복사본과 달리 구조화된 복제는 개체의 깊은 복사본을 만들어 중첩된 개체도 복사되도록 합니다. 이 방법은 함수, 정의되지 않은 참조, 순환 참조와 같은 특정 데이터 유형을 처리할 수 없는 <code>JSON.parse(JSON.stringify(obj))</code>의 한계를 피할 수 있습니다.</p><ul><li><strong>사용 사례:</strong> 복잡한 객체의 심층 사본 생성. 원본 데이터를 변경해서는 안 되는 작업을 위해 객체를 복제해야 할 때 유용합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  nestedArr: [&#123; <span class="attr">d</span>: <span class="number">4</span> &#125;],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> clonedObj = structuredClone(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj);</span><br><span class="line"><span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125;, date: 2024-09-20T00:00:00.000Z, arr: [1, 2, 3], nestedArr: [&#123; d: 4 &#125;] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj === obj); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj.b === obj.b); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj.date === obj.date); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj.arr === obj.arr); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedObj.nestedArr[<span class="number">0</span>] === obj.nestedArr[<span class="number">0</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>이 메서드는 <code>JSON.parse(JSON.stringify(obj))</code>와 같은 대안보다 더 안정적이며 복잡한 데이터 구조를 더 잘 처리합니다.</p><h2 id="9-자체-호출-Self-Invoking-함수">9. 자체 호출(Self-Invoking) 함수</h2><p>즉시 호출 함수 표현식(Immediately Invoked Function Expressions, IIFE)이라고도 하는 자체 호출(Self-Invoking) 함수는 생성된 후 자동으로 실행됩니다. 코드를 캡슐화하여 전역 범위를 오염시키지 않도록 하는 데 유용하며, 이는 깔끔하고 모듈화된 코드를 유지하는 데 필수적입니다.</p><ul><li><strong>사용 사례:</strong> 코드를 캡슐화하여 전역 범위의 오염을 방지합니다. 이 기술은 블록 범위(let 및 const)를 사용할 수 없는 구형 JavaScript 환경이나 초기화 로직에 즉각적인 실행이 필요한 시나리오에서 특히 유용합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> privateVar = <span class="string">'This is private'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Self-invoking function runs immediately'</span>);</span><br><span class="line">  <span class="comment">// Initialization code here</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Private variables are not accessible from outside</span></span><br><span class="line"><span class="comment">// console.log(privateVar); // ReferenceError: privateVar is not defined</span></span><br></pre></td></tr></table></figure><p>전역 변수를 피하고 전역 범위에 흔적을 남기지 않고 초기화 코드를 실행하여 깔끔한 코드를 유지하는 데 도움이 됩니다. 이 접근 방식은 대규모 코드베이스에서 충돌을 방지하고 기능을 더 잘 캡슐화하여 코드 유지보수성을 개선하고 부작용을 방지할 수 있습니다.</p><h2 id="10-Tagged-Template-Literals">10. Tagged Template Literals</h2><p>국제화, HTML 위생 처리 또는 동적 SQL 쿼리 생성 등 특수 템플릿을 만들 때 유용합니다.</p><ul><li><strong>사용 사례:</strong> HTML 템플릿에서 사용자 입력을 위생 처리하여 XSS 공격을 방지합니다. 이 기술을 사용하면 악성 스크립트를 실행하지 않고도 사용자가 생성한 콘텐츠를 DOM에 안전하게 삽입할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitize</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strings.reduce(<span class="function">(<span class="params">result, string, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = values[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">      value = value</span><br><span class="line">        .replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result + value + string;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInput = <span class="string">'&lt;script&gt;alert("xss")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> message = sanitize<span class="string">`User input: <span class="subst">$&#123;userInput&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// User input: &amp;lt;script&amp;gt;alert("xss")&amp;lt;/script&amp;gt;</span></span><br></pre></td></tr></table></figure><p>Template Literal의 출력을 제어하고 사용자 정의할 수 있는 강력한 메커니즘을 제공하여 보다 안전하고 유연한 템플릿 생성을 가능하게 합니다. 보안을 강화하고, 문자열 형식을 지정하고, 동적 콘텐츠를 생성하여 코드의 견고성과 다양성을 향상시킬 수 있습니다.</p><h2 id="결론">결론</h2><p>자바스크립트는 더 깔끔하고 효율적인 코드를 작성하는 데 도움이 되는 기능이 풍부한 언어입니다. 이러한 고급 트릭을 코딩 작업에 통합하면 생산성을 향상하고 코드의 가독성을 높일 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/20/js-dev-25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[자바스크립트] 자주 사용하는 한 줄 코드 11가지</title>
      <link>http://hgko1207.github.io/2024/09/20/js-dev-24/</link>
      <guid>http://hgko1207.github.io/2024/09/20/js-dev-24/</guid>
      <pubDate>Fri, 20 Sep 2024 01:38:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/js-dev-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;프로젝트를 만드는 데 많은 도움이 되었던 가장 유용하고 간단한 JavaScript 한 줄짜리 코드를 공유하고자 합니다.&lt;/p&gt;
&lt;p&gt;워크플로우를
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/js-dev-24.png" alt="" /></p><p>프로젝트를 만드는 데 많은 도움이 되었던 가장 유용하고 간단한 JavaScript 한 줄짜리 코드를 공유하고자 합니다.</p><p>워크플로우를 간소화하기 위해 매일 사용하는 자바스크립트 one-liners 10가지를 소개합니다. 이 코드은 간단하지만 강력하며 최소한의 노력으로 앱의 성능과 기능을 향상시킵니다.</p><h2 id="1-배열이-비어-있는지-확인"><a class="markdownIt-Anchor" href="#1-배열이-비어-있는지-확인"></a> 1. 배열이 비어 있는지 확인</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmpty = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.length === <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>배열에 요소가 없는지 확인합니다.</p><h2 id="2-현재-타임스탬프-가져오기"><a class="markdownIt-Anchor" href="#2-현재-타임스탬프-가져오기"></a> 2. 현재 타임스탬프 가져오기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now();</span><br></pre></td></tr></table></figure><p>1970년 1월 1일 이후의 밀리초 수를 반환합니다. 이를 사용 가능한 날짜로 변환하려면 다음 코드를 적용하면 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>(timestamp).toLocaleString();</span><br></pre></td></tr></table></figure><h2 id="3-배열-복제하기"><a class="markdownIt-Anchor" href="#3-배열-복제하기"></a> 3. 배열 복제하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloneArray = <span class="function">(<span class="params">arr</span>) =&gt;</span> [...arr];</span><br></pre></td></tr></table></figure><p>배열의 얕은 복사본을 생성합니다.</p><h2 id="4-배열에서-잘못된-값-제거하기"><a class="markdownIt-Anchor" href="#4-배열에서-잘못된-값-제거하기"></a> 4. 배열에서 잘못된 값 제거하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeFalsy = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.filter(<span class="built_in">Boolean</span>);</span><br></pre></td></tr></table></figure><p>배열에서 <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, <code>NaN</code>과 같은 값을 제거합니다.</p><h2 id="5-문자열-배열을-대문자로-변환하기"><a class="markdownIt-Anchor" href="#5-문자열-배열을-대문자로-변환하기"></a> 5. 문자열 배열을 대문자로 변환하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toUpperCaseArray = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.toUpperCase());</span><br></pre></td></tr></table></figure><p>배열의 모든 문자열 요소를 대문자로 변환합니다.</p><h2 id="6-배열의-모든-숫자-합하기"><a class="markdownIt-Anchor" href="#6-배열의-모든-숫자-합하기"></a> 6. 배열의 모든 숫자 합하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>배열에 있는 숫자의 총합을 계산합니다.</p><h2 id="7-배열에서-임의의-요소-가져오기"><a class="markdownIt-Anchor" href="#7-배열에서-임의의-요소-가져오기"></a> 7. 배열에서 임의의 요소 가져오기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomElement = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br></pre></td></tr></table></figure><p>배열에서 임의의(random) 요소를 반환합니다.</p><h2 id="8-임의의-16진수-색상-생성하기"><a class="markdownIt-Anchor" href="#8-임의의-16진수-색상-생성하기"></a> 8. 임의의 16진수 색상 생성하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomHexColor = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>)</span></span></span><br><span class="line"><span class="string"><span class="subst">    .toString(<span class="number">16</span>)</span></span></span><br><span class="line"><span class="string"><span class="subst">    .padStart(<span class="number">6</span>, <span class="string">'0'</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>임의의(random) 16진수 색상 코드를 생성합니다.</p><h2 id="9-함수-디바운스debounce하기"><a class="markdownIt-Anchor" href="#9-함수-디바운스debounce하기"></a> 9. 함수 디바운스(Debounce)하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> fn(...args), delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>실행을 지연시켜 함수가 실행될 수 있는 속도를 제한합니다.</p><h2 id="10-함수-제한"><a class="markdownIt-Anchor" href="#10-함수-제한"></a> 10. 함수 제한</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, limit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lastFunc;</span><br><span class="line">  <span class="keyword">let</span> lastRan;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lastRan) &#123;</span><br><span class="line">      fn(...args);</span><br><span class="line">      lastRan = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(lastFunc);</span><br><span class="line">      lastFunc = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - lastRan &gt;= limit) &#123;</span><br><span class="line">          fn(...args);</span><br><span class="line">          lastRan = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, limit - (<span class="built_in">Date</span>.now() - lastRan));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>함수가 실행될 수 있는 속도를 지정된 시간 간격당 한 번으로 제한합니다.</p><h2 id="11-문자열에서-html-이스케이프"><a class="markdownIt-Anchor" href="#11-문자열에서-html-이스케이프"></a> 11. 문자열에서 HTML 이스케이프</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> escapeHTML = <span class="function">(<span class="params">str</span>) =&gt;</span></span><br><span class="line">  str.replace(<span class="regexp">/[&amp;&lt;&gt;"']/g</span>, (match) =&gt; (&#123; <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>, <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>, <span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span>, <span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>, <span class="string">"'"</span>: <span class="string">'&amp;#39;'</span> &#125;[match]));</span><br></pre></td></tr></table></figure><p>특수 HTML 문자를 이스케이프(Escape) 처리하여 XSS 공격을 방지합니다.</p><h2 id="마무리"><a class="markdownIt-Anchor" href="#마무리"></a> 마무리</h2><p>이러한 코드를 일상적으로 사용하면 프로젝트의 보안과 기능을 효율적이고 효과적으로 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/09/20/js-dev-24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Node.js] 필수 NPM 패키지 알아보기</title>
      <link>http://hgko1207.github.io/2024/08/20/nodejs-7/</link>
      <guid>http://hgko1207.github.io/2024/08/20/nodejs-7/</guid>
      <pubDate>Tue, 20 Aug 2024 05:55:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/nodejs-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;속도와 확장성, 활발한 패키지 및 도구 에코시스템으로 인해 &lt;strong&gt;Node.js&lt;/strong&gt;는 백엔드 개발에서 가장 많이 선택되는 언어가 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/nodejs-7.png" alt=""></p><p>속도와 확장성, 활발한 패키지 및 도구 에코시스템으로 인해 <strong>Node.js</strong>는 백엔드 개발에서 가장 많이 선택되는 언어가 되었습니다. 이 에코시스템의 중심에는 NPM(Node Package Manager)이 있으며, 수천 개의 패키지를 제공하여 Node.js 프로젝트를 향상시킵니다. 이 글에서는 Node.js 백엔드 개발을 강화하여 보다 효율적이고 안전하며 풍부한 기능을 제공하는 필수 NPM 패키지를 살펴보겠습니다.</p><h2 id="Node-js-및-NPM-시작하기">Node.js 및 NPM 시작하기</h2><p>필수 패키지를 살펴보기 전에 시스템에 Node.js와 NPM이 설치되어 있는지 확인하세요. Node.js는 공식 웹사이트(<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a>)에서 다운로드하여 설치할 수 있으며, NPM은 번들로 제공됩니다. 터미널에서 다음 명령을 실행하여 Node.js와 NPM이 올바르게 설치되었는지 확인합니다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>두 명령 모두 버전 번호를 반환하면 시작할 준비가 된 것입니다.</p><h2 id="1-Express-js">1. Express.js</h2><p>Express.js는 웹 애플리케이션과 API를 구축하는 데 가장 인기 있고 널리 사용되는 Node.js 프레임워크입니다. 라우팅, 미들웨어 관리, HTTP 요청 처리를 간소화하여 효율적인 백엔드 개발을 위한 필수 패키지입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><h2 id="2-Mongoose">2. Mongoose</h2><p>Mongoose는 MongoDB 데이터베이스와의 상호 작용을 간소화하는 우아한 MongoDB 객체 모델링 패키지입니다. 스키마와 모델을 정의하는 구조화된 방법을 제공하여 데이터베이스 운영을 보다 효율적이고 오류에 강하도록 만들어 줍니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose --save</span><br></pre></td></tr></table></figure><h2 id="3-Body-parser">3. Body-parser</h2><p>HTTP 요청 본문 구문 분석은 백엔드 개발의 일반적인 작업입니다. body-parser 패키지는 JSON, URL 인코딩 및 기타 요청 본문을 구문 분석하여 이 프로세스를 간소화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install body-parser --save</span><br></pre></td></tr></table></figure><h2 id="4-Helmet">4. Helmet</h2><p>웹 개발에서 보안은 최우선 순위입니다. Helmet은 HTTP 헤더를 올바르게 설정하고 일반적인 보안 취약성을 완화하여 Express.js 애플리케이션을 보호하는 데 도움이 되는 미들웨어 함수 모음입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install helmet --save</span><br></pre></td></tr></table></figure><h2 id="5-dotenv">5. dotenv</h2><p>환경 파일에 구성 변수를 저장하는 것은 API 키 및 데이터베이스 URI와 같은 민감한 정보를 안전하게 유지하기 위한 모범 사례입니다. dotenv를 사용하면 <code>.env</code> 파일에서 Node.js 애플리케이션으로 환경 변수를 쉽게 로드할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dotenv --save</span><br></pre></td></tr></table></figure><h2 id="6-Winston">6. Winston</h2><p>로깅은 애플리케이션을 디버깅하고 모니터링하는 데 매우 중요합니다. Winston은 파일, 콘솔, 외부 서비스 등 다양한 대상에 메시지를 로깅할 수 있는 다목적 로깅 라이브러리입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install winston --save</span><br></pre></td></tr></table></figure><h2 id="7-Express-validator">7. Express-validator</h2><p>데이터 유효성 검사는 애플리케이션이 유효한 입력을 받도록 보장하는 데 필수적입니다. express-validator는 Express.js 경로 내에서 요청 데이터 유효성 검사 및 정리를 간소화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-validator --save</span><br></pre></td></tr></table></figure><h2 id="8-jsonwebtoken">8. jsonwebtoken</h2><p>Node.js 애플리케이션의 인증 및 권한 부여를 위해 JWT(JSON Web Token)이 널리 사용됩니다. jsonwebtoken 패키지는 JWT 생성 및 확인을 간소화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken --save</span><br></pre></td></tr></table></figure><h2 id="9-Passport-js">9. Passport.js</h2><p>보다 포괄적인 인증 솔루션이 필요하다면 OAuth, 로컬 등과 같은 다양한 인증 전략을 지원하는 다목적 미들웨어인 Passport.js를 사용하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install passport --save</span><br></pre></td></tr></table></figure><h2 id="10-Nodemon">10. Nodemon</h2><p>Nodemon은 개발자 친화적인 유틸리티로, Node.js 애플리케이션의 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하여 개발 중에 앱을 수동으로 중지하고 다시 시작하는 수고를 덜어줍니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemon --save-dev</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>효율적인 Node.js 백엔드 개발은 NPM 패키지의 풍부한 에코시스템을 활용하는 데 달려 있습니다. 위에서 언급한 패키지는 HTTP 요청 처리, 애플리케이션 보안, 데이터베이스 관리 및 로깅에 이르기까지 백엔드 개발의 필수적인 측면을 다룹니다. 이러한 패키지를 Node.js 프로젝트에 통합하면 시간을 절약할 수 있을 뿐만 아니라 더욱 강력하고 안전하며 풍부한 기능을 갖춘 백엔드 시스템을 구축할 수 있습니다. 개발을 계속 진행하면서 NPM 레지스트리를 탐색하여 특정 프로젝트 요구 사항을 간소화할 수 있는 더 많은 패키지를 찾아보세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/08/20/nodejs-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Swagger vs. Postman</title>
      <link>http://hgko1207.github.io/2024/08/20/info-25/</link>
      <guid>http://hgko1207.github.io/2024/08/20/info-25/</guid>
      <pubDate>Tue, 20 Aug 2024 05:35:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-25.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;역동적인 API 개발 영역에서 도구는 프로세스를 간소화하고 협업을 강화하며 애플리케이션의 원활한 작동을 보장하는 데 중추적인 역할을 합니다. 이 영역의
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-25.png" alt=""></p><p>역동적인 API 개발 영역에서 도구는 프로세스를 간소화하고 협업을 강화하며 애플리케이션의 원활한 작동을 보장하는 데 중추적인 역할을 합니다. 이 영역의 대표적인 두 가지 도구는 각각 고유한 기능과 사용 사례를 제공하는 <strong>Swagger</strong>와 <strong>Postman</strong>입니다. 이 글에서는 Swagger와 Postman의 강점과 활용 사례를 자세히 살펴보고, 특정 요구사항에 따라 정보에 입각한 결정을 내릴 수 있도록 도와드립니다.</p><h2 id="Swagger란-무엇인가요">Swagger란 무엇인가요?</h2><p>현재 OpenAPI 사양으로 알려진 Swagger는 개발자가 RESTful API를 설계, 문서화 및 테스트할 수 있는 오픈 소스 프레임워크입니다. REST API를 설명하는 표준화된 방법을 제공하여 사람과 컴퓨터 모두 소스 코드에 액세스하지 않고도 서비스의 기능을 이해할 수 있도록 해줍니다.</p><h2 id="Swagger의-사용-사례">Swagger의 사용 사례</h2><ul><li><strong>API 문서:</strong> Swagger는 포괄적인 대화형 API 문서를 생성하는 데 탁월합니다. 기계가 읽을 수 있는 형식으로 API를 설명함으로써 개발자가 API를 보다 효율적으로 이해하고 사용할 수 있도록 지원합니다.</li><li><strong>API 디자인:</strong> Swagger를 사용하면 Swagger 에디터를 사용하여 시각적으로 API를 디자인할 수 있습니다. 이러한 시각적 접근 방식은 팀원 간의 협업을 촉진하고 표준화된 API 설계 프로세스를 보장합니다.</li><li><strong>코드 생성:</strong> Swagger는 다양한 프로그래밍 언어로 서버 Stub과 클라이언트 SDK를 생성할 수 있어 API 기능을 구현하는 데 필요한 수작업을 줄여줍니다.</li><li><strong>테스트:</strong> Swagger는 Swagger UI와 같은 도구와의 통합을 통해 API 테스트를 용이하게 합니다. 개발자는 문서에서 직접 API 요청을 실행할 수 있으므로 테스트 및 디버깅에 유용한 도구입니다.</li></ul><h2 id="Postman이란-무엇인가요">Postman이란 무엇인가요?</h2><p>Postman은 API를 설계, 테스트 및 관리하는 과정을 간소화하는 API 개발용 협업 플랫폼으로 널리 사용되고 있습니다. HTTP 요청을 생성하고 전송할 수 있는 사용자 친화적인 인터페이스를 제공할 뿐만 아니라 API의 테스트 및 모니터링을 자동화합니다.</p><h2 id="Postman-사용-사례">Postman 사용 사례</h2><ul><li><strong>API 테스트:</strong> Postman은 다목적 API 테스트 도구로서 빛을 발합니다. 개발자는 API 요청을 생성 및 실행하고, 자동화된 테스트 스위트를 설정하고, 회귀 테스트를 수행하여 API의 안정성을 보장할 수 있습니다.</li><li><strong>API 설계 및 프로토타이핑:</strong> Postman을 사용하면 플랫폼 내에서 직접 API를 설계하고 프로토타이핑할 수 있습니다. 이 기능은 빠른 반복과 피드백 루프를 가능하게 하여 개발 프로세스를 가속화합니다.</li><li><strong>협업:</strong> Postman은 공유 작업 공간, API 버전 관리, 요청 및 컬렉션에 댓글을 달 수 있는 기능을 제공하여 팀원 간의 협업을 촉진합니다.</li><li><strong>모니터링 및 자동화:</strong> Postman을 사용하면 API 테스트 컬렉션을 자동으로 실행하고 예약하는 모니터를 만들 수 있습니다. 이는 지속적인 통합과 API의 상태를 모니터링하는 데 유용합니다.</li></ul><h2 id="Swagger와-Postman-올바른-도구-선택하기">Swagger와 Postman: 올바른 도구 선택하기</h2><h3 id="Swagger를-선택해야-하는-경우">Swagger를 선택해야 하는 경우</h3><ul><li><strong>API 설계 우선 접근 방식:</strong> 개발 프로세스가 구현 전에 API 사양을 정의하는 API 설계 우선 접근 방식을 따르는 경우 Swagger가 탁월한 선택입니다.</li><li><strong>포괄적인 문서:</strong> 상세한 대화형 API 문서를 작성하는 것이 우선순위라면 Swagger의 광범위한 문서 생성 기능이 유용한 도구가 될 수 있습니다.</li><li><strong>코드 생성:</strong> API 사양에 따라 서버 Stub이나 클라이언트 SDK를 자동으로 생성해야 하는 경우 Swagger는 강력한 코드 생성 기능을 제공합니다.</li></ul><h3 id="Postman을-선택해야-하는-경우">Postman을 선택해야 하는 경우</h3><ul><li><strong>API 테스트 중심:</strong> 특히 자동화된 테스트, 테스트 스위트 생성, 모니터링과 같은 기능을 통해 API 테스트에 중점을 두는 경우, Postman은 이러한 작업에 맞춤화된 서비스입니다.</li><li><strong>프로토타이핑 및 반복:</strong> 도구 내에서 직접 API를 빠르게 프로토타이핑하고 반복할 수 있는 플랫폼을 선호한다면 Postman은 이러한 활동을 위한 직관적인 환경을 제공합니다.</li><li><strong>협업 개발:</strong> API 개발 작업 공간의 협업과 공유가 팀에 매우 중요하다면 Postman의 협업 기능이 원활한 환경을 제공합니다.</li></ul><h2 id="결론">결론</h2><p>API 개발의 역동적인 환경에서 Swagger와 Postman은 모두 개발 수명 주기 전반에 걸쳐 특정 요구 사항을 해결하면서 독특한 틈새 시장을 개척해 왔습니다. Swagger는 API 디자인, 문서화 및 코드 생성에 탁월하지만 Postman은 API 테스트, 협업 및 프로토타이핑 영역에서 빛을 발합니다. Swagger와 Postman 중 어떤 것을 선택할지는 궁극적으로 프로젝트 요구 사항, 팀 선호도, 향상된 효율성과 기능을 원하는 API 개발 프로세스의 특정 단계에 따라 달라집니다.</p><p>Swagger와 Postman의 강점을 활용하여 API 개발 도구 키트에 통합하여 포괄적이고 간소화된 개발 환경을 구축하세요. API를 설계하거나 문서화하거나 기능을 엄격하게 테스트할 때 Swagger와 Postman의 시너지 효과로 개발자는 최신 API 개발의 복잡한 환경을 자신 있게 탐색할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/08/20/info-25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring Boot] JUnit과 Mockito</title>
      <link>http://hgko1207.github.io/2024/08/20/spring-5/</link>
      <guid>http://hgko1207.github.io/2024/08/20/spring-5/</guid>
      <pubDate>Tue, 20 Aug 2024 04:57:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/spring-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;우리 모두 알다시피, 단위 테스트는 애플리케이션 개발에서 유지해야 할 주요한 중요한 관행 중 하나입니다. 이 글에서는 Java 애플리케이션의 단위 테
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/spring-5.png" alt=""></p><p>우리 모두 알다시피, 단위 테스트는 애플리케이션 개발에서 유지해야 할 주요한 중요한 관행 중 하나입니다. 이 글에서는 Java 애플리케이션의 단위 테스트 프레임워크인 <strong>Junit</strong>과 <strong>Mockito</strong>의 Rest apis에 대해 살펴보겠습니다.</p><h2 id="단위-테스트란-무엇인가요">단위 테스트란 무엇인가요?</h2><p>단위 테스트(Unit Testing)는 애자일 방법론의 연속 프로세스 중 하나로 알려져 있습니다. 단위 테스트는 개발자 수준에서 시작됩니다. 단위 테스트는 소프트웨어 애플리케이션의 개별 구성 요소를 테스트하는 소프트웨어 테스트의 한 유형입니다.</p><p>Rest API를 작성한다고 가정하면 각 API에 대해 테스트 케이스를 작성하고 메인 API에 커밋하기 전에 애플리케이션에서 테스트할 수 있습니다. 단위 테스트에서는 서비스를 모의 테스트하므로 매번 데이터베이스를 호출하지 않고 모의 데이터를 사용합니다.</p><h2 id="JUnit이란-무엇인가요">JUnit이란 무엇인가요?</h2><p>JUnit은 Java 프로그래밍 언어의 단위 테스트 프레임워크입니다. 테스트 중심 개발에서 중요한 역할을 하며 xUnit으로 알려진 단위 테스트 프레임워크 제품군으로 알려져 있습니다.</p><p>JUnit은 개발자에게 먼저 테스트한 다음 코딩하는 아이디어를 제공하므로 실제 API를 구현하기 전에 어떤 유형의 데이터가 필요한지 확인할 수 있습니다.</p><p>JUnit을 사용하면 프로그래머의 생산성이 향상되고 애플리케이션의 안정성이 유지됩니다.</p><p>JUnit은 테스트 케이스 작성을 위한 프레임워크이므로 테스트 방법을 식별하는 어노테이션을 제공하고 예상 결과를 테스트하기 위한 어설션을 제공합니다.</p><h2 id="Mockito-프레임워크란-무엇인가요">Mockito 프레임워크란 무엇인가요?</h2><p>Mockito는 Java 애플리케이션의 단위 테스트에 사용되는 Java 기반 Mocking 프레임워크입니다. Mockito는 MIT 라이선스에 따라 오픈 소스 테스트 프레임워크로 출시되었습니다.</p><p>Mockito는 내부적으로 Java 리플렉션 API를 사용하여 모의 객체를 생성합니다. Mockito 프레임워크 사용의 주된 목적은 외부 종속성을 모의하고 테스트 코드에서 이를 사용하여 개발을 간소화하는 것입니다. 또한 JUnit 및 TestNG와 같은 다른 테스트 프레임워크와 함께 Mockito를 사용할 수도 있습니다.</p><h2 id="Mocking-이란-무엇인가요">Mocking 이란 무엇인가요?</h2><p>Mocking은 객체의 모의 또는 복제 역할을 하는 객체를 개발하는 프로세스입니다. 즉, 실제 객체를 사용하는 대신 Mocking된 객체를 사용하게 됩니다. 모의 객체는 특정 또는 더미 입력과 출력을 제공합니다.</p><h2 id="단계별-구현">단계별 구현</h2><h3 id="Step-1">Step 1</h3><p><a href="https://start.spring.io/" target="_blank" rel="noopener">Spring initialize</a>를 사용하여 Spring Boot 애플리케이션을 만들고 다음 종속성을 추가합니다.</p><ul><li>Spring Web</li><li>Spring Data JPA</li><li>Lombok</li></ul><p>Spring 부팅 프로젝트를 zip 파일로 생성하고 압축을 푼 다음 IDE로 가져옵니다.</p><h3 id="Step-2">Step 2</h3><p>Spring 부팅 프로젝트에 아래 종속성을 추가했는지 확인합니다</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Step-3-JPA-엔티티-생성">Step 3: JPA 엔티티 생성</h3><p>이제 다음 내용으로 Employee JPA 엔티티를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"employees"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"first_name"</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상용구 코드를 줄이기 위해 Lombok 어노테이션을 사용하고 있다는 점에 유의하세요.</p><h3 id="Step-4-Repository-Layer-생성">Step 4: Repository Layer 생성</h3><p>이제 JpaRepository 인터페이스를 확장하는 EmployeeRepository를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.model.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Employee</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-5-Service-Layer-생성">Step 5: Service Layer 생성</h3><p>CRUD 메서드를 사용하여 EmployeeService 인터페이스를 만듭니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.model.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">saveEmployee</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Employee&gt; <span class="title">getAllEmployees</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Optional&lt;Employee&gt; <span class="title">getEmployeeById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function">Employee <span class="title">updateEmployee</span><span class="params">(Employee updatedEmployee)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 EmployeeService 인터페이스를 구현하는 EmployeeServiceImpl 클래스를 생성합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.exception.ResourceNotFoundException;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.model.Employee;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.repository.EmployeeRepository;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.service.EmployeeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmployeeServiceImpl</span><span class="params">(EmployeeRepository employeeRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.employeeRepository = employeeRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;Employee&gt; savedEmployee = employeeRepository.findByEmail(employee.getEmail());</span><br><span class="line">        <span class="keyword">if</span>(savedEmployee.isPresent())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ResourceNotFoundException(<span class="string">"Employee already exist with given email:"</span> + employee.getEmail());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> employeeRepository.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Employee&gt; <span class="title">getEmployeeById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">updateEmployee</span><span class="params">(Employee updatedEmployee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeRepository.save(updatedEmployee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        employeeRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-6-JUnit-5와-Mockito를-사용하여-Service-Layer-단위-테스트하기">Step 6: JUnit 5와 Mockito를 사용하여 Service Layer 단위 테스트하기</h3><p>EmployeeService에 대한 단위 테스트 케이스를 작성해 보겠습니다. Spring 기능을 사용하지 않고도 EmployeeService에 대한 단위 테스트를 작성할 수 있어야 합니다.</p><p>Mock을 사용하여 EmployeeRepository의 모의 인스턴스를 생성하고 모의 EmployeeRepository 인스턴스를 사용하여 EmployeeServiceImpl 인스턴스를 생성하겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.exception.ResourceNotFoundException;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.model.Employee;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.repository.EmployeeRepository;</span><br><span class="line"><span class="keyword">import</span> net.jUnitApplication.springboot.service.impl.EmployeeServiceImpl;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.ArgumentMatchers.any;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.given;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.willDoNothing;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mockito.InjectMocks;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mock;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.jupiter.MockitoExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EmployeeServiceTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeServiceImpl employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Employee employee;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        employee = Employee.builder()</span><br><span class="line">                .id(<span class="number">1L</span>)</span><br><span class="line">                .firstName(<span class="string">"ko"</span>)</span><br><span class="line">                .lastName(<span class="string">"su"</span>)</span><br><span class="line">                .email(<span class="string">"hgko@gmail.com"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JUnit test for saveEmployee method</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"JUnit test for saveEmployee method"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmployeeObject_whenSaveEmployee_thenReturnEmployeeObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// given - precondition or setup</span></span><br><span class="line">        when(employeeRepository.findByEmail(employee.getEmail()))</span><br><span class="line">                .thenReturn(Optional.empty());</span><br><span class="line"></span><br><span class="line">        when(employeeRepository.save(employee)).thenReturn(employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(employeeRepository);</span><br><span class="line">        System.out.println(employeeService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when -  action or the behaviour that we are going test</span></span><br><span class="line">        Employee savedEmployee = employeeService.saveEmployee(employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(savedEmployee);</span><br><span class="line">        <span class="comment">// then - verify the output</span></span><br><span class="line">        assertThat(savedEmployee).isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAllEmployees</code> 메서드에 대한 JUnit 테스트</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"JUnit test for getAllEmployees method"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmployeesList_whenGetAllEmployees_thenReturnEmployeesList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// given - precondition or setup</span></span><br><span class="line">    Employee employee1 = Employee.builder()</span><br><span class="line">            .id(<span class="number">2L</span>)</span><br><span class="line">            .firstName(<span class="string">"ko"</span>)</span><br><span class="line">            .lastName(<span class="string">"test"</span>)</span><br><span class="line">            .email(<span class="string">"test@gmail.com"</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    when(employeeRepository.findAll()).thenReturn(List.of(employee,employee1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when -  action or the behaviour that we are going test</span></span><br><span class="line">    List&lt;Employee&gt; employeeList = employeeService.getAllEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then - verify the output</span></span><br><span class="line">    assertThat(employeeList).isNotNull();</span><br><span class="line">    assertThat(employeeList.size()).isEqualTo(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getEmployeeById</code> 메서드에 대한 JUnit 테스트</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"JUnit test for getEmployeeById method"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmployeeId_whenGetEmployeeById_thenReturnEmployeeObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// given</span></span><br><span class="line">    when(employeeRepository.findById(<span class="number">1L</span>)).thenReturn(Optional.of(employee));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    Employee savedEmployee = employeeService.getEmployeeById(employee.getId()).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    assertThat(savedEmployee).isNotNull();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateEmployee</code> 메서드에 대한 JUnit 테스트</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"JUnit test for updateEmployee method"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmployeeObject_whenUpdateEmployee_thenReturnUpdatedEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// given - precondition or setup</span></span><br><span class="line">    when(employeeRepository.save(employee)).thenReturn(employee);</span><br><span class="line">    employee.setEmail(<span class="string">"lee@gmail.com"</span>);</span><br><span class="line">    employee.setFirstName(<span class="string">"Lee"</span>);</span><br><span class="line">    <span class="comment">// when -  action or the behaviour that we are going test</span></span><br><span class="line">    Employee updatedEmployee = employeeService.updateEmployee(employee);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then - verify the output</span></span><br><span class="line">    assertThat(updatedEmployee.getEmail()).isEqualTo(<span class="string">"lee@gmail.com"</span>);</span><br><span class="line">    assertThat(updatedEmployee.getFirstName()).isEqualTo(<span class="string">"Lee"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deleteEmployee</code> 메서드에 대한 JUnit 테스트</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"JUnit test for deleteEmployee method"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmployeeId_whenDeleteEmployee_thenNothing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// given - precondition or setup</span></span><br><span class="line">    <span class="keyword">long</span> employeeId = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    doNothing().when(employeeRepository).deleteById(employeeId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when -  action or the behaviour that we are going test</span></span><br><span class="line">    employeeService.deleteEmployee(employeeId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then - verify the output</span></span><br><span class="line">    verify(employeeRepository, times(<span class="number">1</span>)).deleteById(employeeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제 코드는 Junit과 Mockito를 사용하여 REST API의 CRUD 동작 테스트를 제공합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/08/20/spring-5/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
