<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>규니의 블로그</title>
    <link>http://hgko1207.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Information related to IT</description>
    <pubDate>Thu, 04 Jan 2024 07:58:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>WinUI vs WPF, WinForms, UWP, MFC</title>
      <link>http://hgko1207.github.io/2024/01/04/window-1/</link>
      <guid>http://hgko1207.github.io/2024/01/04/window-1/</guid>
      <pubDate>Thu, 04 Jan 2024 06:16:49 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/window-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;**Windows UI 라이브러리(WinUI)**는 Windows의 기본 레이어입니다. 여기에는 디자이너와 개발자가 Windows 애플리케이션을 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/window-1.png" alt="" /></p><p>**Windows UI 라이브러리(WinUI)**는 Windows의 기본 레이어입니다. 여기에는 디자이너와 개발자가 Windows 애플리케이션을 구축하는 데 필요한 컨트롤과 유연한 디자인 시스템이 포함되어 있습니다.</p><p>WinUI는 MFC(Microsoft Foundation Class Library) 프레임워크, WinForms, WPF(Windows Presentation Foundation) 및 UWP(Universal Windows Platform)와 같은 다양한 그래픽 사용자 인터페이스(GUI) 프레임워크의 최신 버전입니다.</p><p>Microsoft는 데스크톱 앱(MFC, WinForms, WPF) 및 UWP 앱을 위한 포괄적인 최신 UI 프레임워크를 만들었으며, 새로운 Windows 애플리케이션 및 이전 애플리케이션에서 작동하도록 설계했습니다. 향상된 직관적인 기능을 통해 기본 애플리케이션을 빠르게 실행하거나 앱을 처음부터 새로 빌드할 수 있습니다.</p><p>WinUI는 수년에 걸쳐 개선되었습니다. WinUI 2와 WinUI 3의 두 가지 버전이 있습니다.</p><p>WinUI 2 라이브러리에는 UWP XAML 애플리케이션을 위한 UI 컨트롤과 스타일이 포함되어 있습니다. 이는 Windows 10 운영 체제에 내장된 XAML 및 시각적 계층과 운영 체제 위에 구축된 컨트롤 라이브러리로 구성됩니다.</p><p>WinUI 3에는 전체 UWP XAML 코드베이스와 WinUI 2의 모든 컨트롤 및 스타일이 포함되어 있습니다. 또한 Windows 10 시각적 계층 내에 다른 강력한 Windows 기술 계층이 있으며, 이 모든 것이 단일 UI 프레임워크로 통합되어 있습니다.</p><p>이전 Windows 인터페이스를 좀 더 자세히 살펴보고 WinUI가 이전 버전과 어떻게 비교되는지 살펴보겠습니다.</p><h2 id="winui와-이전-프레임워크의-기능-비교하기"><a class="markdownIt-Anchor" href="#winui와-이전-프레임워크의-기능-비교하기"></a> WinUI와 이전 프레임워크의 기능 비교하기</h2><p>WinUI와 이전 프레임워크 간에는 몇 가지 차이점이 있습니다.</p><p><img src="/images/header/window-1_1.png" alt="" /></p><h2 id="mfc"><a class="markdownIt-Anchor" href="#mfc"></a> MFC</h2><p>1992년에는 최첨단 MFC(Microsoft Foundation Class Library)가 있었습니다. 이 라이브러리는 네이티브 C++ 및 객체 지향 UI 프레임워크로 구성되어 Windows 앱을 만들 수 있었습니다. 이 시기는 Windows의 기본 UI 계층에 Windows 애플리케이션 빌드하기 위한 스타일 및 컨트롤과 같은 기능이 포함되기 전이었습니다.</p><p>MFC는 클래스 인스턴스화를 제공하고 데이터 구조나 객체를 동적으로 변환하여 나중에 저장, 전송 또는 재구성하는 방식으로 작동합니다. 또한 기본적인 입력 및 출력, 창 관리, 메뉴 및 대화 상자 컬렉션 저장을 위한 코드도 제공합니다.</p><p>MFC 프레임워크는 재사용 가능한 클래스 세트를 통해 Windows 프로그래밍을 간소화하여 프로그래밍을 쉽게 만듭니다. 이 프레임워크는 문자열, 파일, 표준 Windows API 및 데이터 구조(예: Windows 및 Controls)와 같은 기본 프로그래밍에 사용되는 객체에 대한 클래스를 제공합니다.</p><p>오늘날 MFC 애플리케이션을 구축하는 개발자는 VSFlexGrid 및 True DBGrid와 같은 레거시 ActiveX 컨트롤을 사용할 수 있습니다.</p><h2 id="winforms"><a class="markdownIt-Anchor" href="#winforms"></a> WinForms</h2><p>2002년에 Microsoft는 .NET Framework와 함께 WinForms라는 또 다른 GUI를 출시했습니다. MFC와 마찬가지로 WinForms는 생산성을 크게 향상시켰지만 개발자가 .NET 애플리케이션에서만 사용할 수 있기 때문에 MFC를 대체하기에는 부족했습니다.</p><p>WinForms는 .NET Framework 래퍼를 사용하며 Windows Forms에 고유한 컨트롤과 기능을 제공합니다. WinForms는 비주얼 디자이너 기반의 Visual Studio를 사용하여 데스크톱 또는 Win32 애플리케이션을 만듭니다. 또한 Visual Studio와 같은 끌어서 놓기 기능을 지원하므로 데스크톱 응용 프로그램 구축을 간소화할 수 있습니다.</p><p>WinForms는 HTML 텍스트 형식을 지원하며 사용 가능한 HTML 서식 태그를 설명합니다. 이 기능 하나로 데이터를 필터링하는 UI를 구축할 수 있습니다.</p><p>거의 20년이 지난 지금, WinForms 개발은 ComponentOne의 .NET WinForms 컨트롤을 통해 더욱 강력해졌습니다.</p><h2 id="wpf"><a class="markdownIt-Anchor" href="#wpf"></a> WPF</h2><p>2006년에 Microsoft는 다양한 기능을 갖춘 개선된 WPF(Windows Presentation Foundation)를 출시했습니다. .NET 개발자를 대상으로 하는 WPF를 사용하면 Windows에서 Direct3D 렌더링을 사용하여 일부 그래픽 작업을 GPU로 오프로드할 수 있습니다. 이러한 오프로드는 컴퓨터 CPU의 작업 부하를 줄이는 데 도움이 됩니다.</p><p>WPF는 최신 2D 및 3D 그래픽 하드웨어, 애니메이션, 스타일 및 미디어를 활용합니다. 마크업과 Code-behind를 모두 사용하여 애플리케이션을 개발할 수 있습니다.</p><p>마크업은 애플리케이션의 모양을 선언적으로 구현합니다. 예를 들어 대화 상자(Dialog box), 페이지 및 사용자 컨트롤의 모양을 디자인하고 도형과 그래픽으로 채웁니다. 반면, Code-behind는 애플리케이션의 동작을 구현하는 데 사용할 수 있는 관리되는 프로그래밍 언어입니다.</p><p>WPF를 사용하면 XAML을 사용하여 UI를 만들 수 있습니다. 그래픽은 벡터 기반이므로 확장성이 뛰어나고 래스터 이미지에 비해 저장 용량을 덜 필요로 합니다.</p><p>WPF는 데스크톱 애플리케이션을 쉽게 개발할 수 있는 최첨단 .NET 개발자 프레임워크였지만, UI에 초점을 맞추지 않았기 때문에 WinForms GUI 프레임워크를 대체하지는 못했습니다.</p><p>WinForms 외에도 ComponentOne은 스타일과 현대화에 더 초점을 맞춘 유사한 WPF 컨트롤을 지원합니다.</p><h2 id="uwp"><a class="markdownIt-Anchor" href="#uwp"></a> UWP</h2><p>2006년 당시에는 서로 다른 선호도와 목표를 가진 Windows 개발자에게 적합한 클라이언트 애플리케이션 구축을 위한 세 가지 훌륭한 UI 프레임워크를 보유하고 있습니다. 그러다가 2012년에 Microsoft는 또 다른 GUI 프레임워크인 UWP XAML(Universal Windows Platform Extensible Application Markup Language)이 포함된 Windows 8을 출시했습니다. 이 프레임워크는 개발자가 Metro 또는 Store 앱이라고도 하는 모든 종류의 앱을 제작하는 데 도움이 됩니다.</p><p>Microsoft는 최신 그래픽 엔진을 기반으로 UWP를 구축했으며, 개발자는 이를 C++ 및 .NET에서 사용할 수 있지만 제한 사항이 있습니다. 우선, UWP XAML은 UWP 앱에서만 작동하며, 이는 MFC, WinForms, WPF와 같은 프레임워크로 제작된 앱과는 다릅니다.</p><p>MFC, WinForms 및 WPF로 빌드된 앱은 데스크톱 또는 Win32 앱이라고 하는 반면, UWP로 빌드된 앱은 UWP 앱이라고 합니다. 이들은 서로 다른 API 세트와 서로 다른 라이브러리 생태계를 가지고 있습니다. 예를 들어 MFC, WinForms 또는 WPF를 사용하는 Windows 개발자는 UWP XAML을 사용하기로 결정할 수 있습니다. 이 경우 UWP XAML은 UWP 앱에서만 작동하므로 엄격하게 UWP 앱을 빌드해야 합니다. 결과적으로 일부 개발자는 이를 꺼리게 됩니다.</p><p>UWP 프레임워크는 WinRT(Windows Runtime) API를 사용하여 강력한 UI 기능을 제공하며, Windows 업데이트와 함께 배포되어 애플리케이션 수준을 한 단계 끌어올릴 수 있습니다. UWP는 가상 레지스트리와 시스템 파일을 사용하여 다른 앱과 충돌하지 않도록 작동합니다.</p><p>또한 Appx 패키지의 앱을 더 쉽게 제거하고 원활하게 업데이트하여 이미 설치된 앱에 새로운 기능을 추가할 수 있습니다. UWP가 마이크, 웹캠 또는 전체 파일 시스템과 같은 하드웨어에 액세스하려면 먼저 사용자가 액세스 권한을 부여해야 하므로 악성 앱이 손상을 입히는 것을 방지할 수 있습니다.</p><p>인기 있는 WPF 컨트롤을 기반으로 UWP 플랫폼용을 위한 유사한 컨트롤을 개발했으며, 여기에서 확인할 수 있습니다 .</p><h2 id="winui"><a class="markdownIt-Anchor" href="#winui"></a> WinUI</h2><p>이제 WinUI의 작동 방식을 살펴보겠습니다. WinUI와 이전 GUI 프레임워크 간의 중요한 차별화 요소 중 하나는 새로운 기능에 대한 이전 버전과의 호환성을 제공한다는 점입니다.</p><p>Windows 10 장치하고만 호환되는 UWP와 달리 WinUI는 이전 버전의 Windows 10 및 11과도 호환됩니다. 예를 들어 WinUI 3을 사용하면 사용자가 최신 Windows 업데이트를 실행할 때까지 기다릴 필요 없이 새로운 기능이 포함된 앱을 빌드하고 출시할 수 있습니다.</p><p>또한 WinUI는 고도로 최적화되고 철저한 테스트를 거친 기본 Windows UI 플랫폼이며 개발자가 광범위하게 사용할 수 있습니다. 또한 사용자의 운영 체제 버전에 맞게 자동으로 조정되므로 앱을 더 쉽게 빌드할 수 있습니다.</p><h2 id="maui"><a class="markdownIt-Anchor" href="#maui"></a> MAUI</h2><p>MAUI는 Google, Apple 및 Microsoft 기술을 하나로 통합하는 Xamarin과 유사한 최신 .NET 플랫폼입니다. MAUI는 다른 플랫폼에서 실행되는 앱이 공통된 비즈니스 로직을 공유할 수 있도록 Android, iOS, macOS 및 Windows API(WinUI)를 단일 API로 출력합니다.</p><p>MAUI는 .NET 6 이상에서 지원되며, 지원되는 각 프레임워크에서 동일한 .NET Base Class Library(BCL)에 대한 액세스를 허용합니다. BCL은 기본 프레임워크의 세부 사항을 추상화하여 C# 코드를 한 번만 작성하면 여러 모바일 및 데스크톱 환경에서 애플리케이션을 출력할 수 있습니다.</p><h2 id="winui와-uwp-결합"><a class="markdownIt-Anchor" href="#winui와-uwp-결합"></a> WinUI와 UWP 결합</h2><p>기본적으로 WinUI 프레임워크로 구축된 대부분의 앱은 핵심이 UWP 앱입니다. 두 프레임워크는 동일한 기본 시각적 개체, 동일한 기본 Windows API 및 동일한 XAML 모델을 공유합니다.</p><p>WinUI와 UWP의 기본 API 로직은 C<ins>이지만 이러한 프레임워크를 사용하는 개발자는 Windows 앱을 빌드할 때 C#, C</ins>, F#, Visual Basic .NET(<a href="http://VB.NET" target="_blank" rel="noopener">VB.NET</a>), JavaScript 등 다양한 프로그래밍 언어 중에서 선택할 수 있습니다.</p><p>WinUI와 UWP의 이러한 모든 유사점에도 불구하고 차이점이 있습니다. 예를 들어 UWP는 Windows와 함께 배포되므로 사용자가 수정 사항, 개선 사항 및 새로운 UI 컨트롤에 액세스하려면 최신 Windows 버전으로 업데이트해야 합니다.</p><p>이러한 업데이트 필요성은 최신 버전의 Windows로 지속적으로 업데이트할 수 없는 사용자에게는 약간의 병목 현상이 될 수 있습니다. Microsoft는 이 문제를 해결하기 위해 WinUI를 설계했습니다. Windows와 분리되어 있고 UWP에서 추출된 API를 사용하므로 업데이트가 더 쉽습니다.</p><p>이 두 프레임워크를 결합하여 멋진 앱을 만들 수 있습니다. 개발자는 WinUI 2.x를 사용하여 UWP 애플리케이션을 만들 수 있습니다. UWP는 Windows에 배포되므로 WinUI와 UWP가 함께 작동하여 XAML Islands와 같은 기능을 기존 데스크톱 애플리케이션에 추가할 수 있습니다.</p><h2 id="winui-기능"><a class="markdownIt-Anchor" href="#winui-기능"></a> WinUI 기능</h2><p>WinUI의 많은 기능 중 하나는 이전 버전과 호환되는 Windows Creators Update입니다. WinUI에는 Windows용 React Native도 포함되어 있습니다. React와 비슷하지만 웹 구성 요소 대신 기본 구성 요소를 빌딩 블록으로 사용한다는 점이 다릅니다.</p><p>WinUI의 새로운 기능인 React Native를 사용하면 새로운 코드를 배우거나 사용하지 않고도 새 앱을 만들거나 기존 앱을 업그레이드할 수 있습니다. Windows 스토어를 통해 이러한 JavaScript 앱을 패키징하고 배포할 수 있습니다. 그 기능에는 기본 모듈 자동 연결, 더 나은 테마 지원 및 탐색 메뉴가 포함됩니다.</p><p>React Native는 Windows 10 SDK와 macOS 10.13 SDK를 모두 지원합니다. 개발자는 JavaScript를 사용하여 Windows 10과 macOS 데스크톱 및 노트북 생태계에서 지원되는 장치용 기본 Windows 앱을 구축할 수 있습니다.</p><h2 id="winui를-사용한-개발의-이점"><a class="markdownIt-Anchor" href="#winui를-사용한-개발의-이점"></a> WinUI를 사용한 개발의 이점</h2><p>다른 프레임워크와 비교하여 WinUI를 사용하여 앱을 빌드할 때 얻을 수 있는 몇 가지 이점을 살펴보겠습니다.</p><ul><li><strong>지속적인 업데이트:</strong> 다른 프레임워크와 비교하여 WinUI를 사용하면 Windows SDK를 업데이트할 필요 없이 최신 버전의 Fluent 디자인, 컨트롤 및 시각적 요소로 앱을 최신 상태로 유지할 수 있다는 이점이 있습니다.<br /><br/></li><li><strong>뛰어난 유연성:</strong> 개발자들은 모든 버전의 운영 체제에 유연하게 적응할 수 있는 WinUI를 높이 평가합니다. 또한 네이티브 개발도 지원합니다. 예를 들어 100% C++이더라도 .NET 앱에서 사용할 수 있습니다.<br /><br/></li><li><strong>이전 버전과의 호환성:</strong> WinUI는 다양한 Windows 10 버전과의 하위 호환성을 제공합니다. 예를 들어 최신 버전의 Windows 10을 사용하지 않는 사용자도 새로운 XAML 기능이 포함된 앱을 출시 직후에 빌드하여 출시할 수 있습니다.<br /><br/></li><li><strong>버전 확인이 필요하지 않습니다:</strong> WinUI로 빌드된 애플리케이션은 UWP XAML의 주요 컨트롤이나 기능을 사용하기 위해 버전 확인이 필요하지 않습니다.<br /><br/></li><li><strong>사용성:</strong> UWP와 달리 WinUI를 사용하면 개발자는 Windows를 업데이트하지 않고도 최신 UI 컨트롤을 사용할 수 있습니다.<br /><br/></li><li><strong>확장성:</strong> MAUI로 개발하면 Android, iOS, macOS용 모바일 버전으로 즉시 확장할 수 있는 WinUI 애플리케이션을 만들 수 있습니다.</li></ul><h2 id="winui-단점"><a class="markdownIt-Anchor" href="#winui-단점"></a> WinUI 단점</h2><p>WinUI는 이전 프레임워크에 비해 개선되었지만 몇 가지 단점이 있습니다. 우선, WinUI는 WPF 앱과 달리 Uno 플랫폼 없이 Windows 7에서 실행하거나 배포할 수 없습니다.</p><p>또한 WinForms와 비교할 때 WinUI는 빠른 UI 개발에 대한 평판이 좋지 않습니다. 예를 들어, 많은 Windows 개발자는 .NET 라이브러리에 대한 간단한 유틸리티 또는 UI Test harness를 만들 때 여전히 WinForms로 되돌아갑니다.</p><blockquote><p>Test harness<br />시스템 및 시스템 컴포넌트를 시험하는 환경의 일부분으로 시험을 지원하는 목적 하에 생성된 코드와 데이터. 시험 드라이버 (test driver)라고도 하며 일반적으로 단위 시험이나 모듈 시험에 사용하기 위해 코드 개발자가 만든다.</p></blockquote><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p><img src="/images/header/window-1_2.png" alt="" /></p><p>WinUI는 다양한 GUI 프레임워크 중 최신 버전입니다. WinUI와 이전 프레임워크의 핵심 차이점은 SDK를 업데이트할 필요 없이 유연한 디자인과 업데이트된 컨트롤에 액세스할 수 있다는 점입니다. 이전 프레임워크에 비해 몇 가지 단점이 있지만 유연성, 이전 버전과의 호환성 및 범용성 때문에 많은 개발자가 WinUI로 전환했습니다.</p><p>WinUI로 전환하는 경우에도 GrapeCity ComponentOne의 .NET 구성 요소 제품군(2021년 중반부터 WinUI에서 사용 가능)을 사용하여 개발 시간을 절약할 수 있습니다. 작고 유연한 데이터 그리드, 차트, 보고서, 달력, 입력, 비즈니스 인텔리전스 대시보드 및 기타 UI 요소를 WinUI 애플리케이션에 빠르게 추가하여 익숙한 컨트롤로 사용자 경험을 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/01/04/window-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트 프레임워크 소개</title>
      <link>http://hgko1207.github.io/2024/01/03/js-dev-12/</link>
      <guid>http://hgko1207.github.io/2024/01/03/js-dev-12/</guid>
      <pubDate>Wed, 03 Jan 2024 01:36:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/thumbnail/javascript.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;자바스크립트(Java
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/thumbnail/javascript.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>자바스크립트(JavaScript)는 현대 웹 개발의 필수 구성 요소가 되었으며, 그 인기로 인해 복잡한 애플리케이션을 구축하는 과정을 간소화하는 많은 프레임워크가 만들어졌습니다. 이러한 프레임워크는 개발자가 웹 애플리케이션을 빠르고 효율적으로 제작하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서는 가장 인기 있는 자바스크립트 프레임워크 중 일부를 살펴보고 고유한 기능을 살펴보겠습니다.</p><h2 id="vue"><a class="markdownIt-Anchor" href="#vue"></a> Vue</h2><p>Vue는 개발자들 사이에서 인기를 얻고 있는 경량 자바스크립트 프레임워크입니다. 쉽게 배우고 사용할 수 있도록 설계되었으며 다양한 기능을 제공하여 중소규모 애플리케이션을 구축하는 데 탁월한 선택입니다. Vue는 사용자 인터페이스 구축에 반응형 접근 방식을 사용합니다. 즉, 사용자 인터페이스의 변경 사항이 실시간으로 자동 업데이트됩니다. 또한 복잡한 애플리케이션 구축하는 과정을 간소화하는 다양한 내장 지시어와 플러그인을 제공합니다.</p><h2 id="react"><a class="markdownIt-Anchor" href="#react"></a> React</h2><p>React는 Facebook에서 개발하여 널리 사용되는 자바스크립트 라이브러리입니다. 개발자가 크고 복잡한 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다. React는 사용자 인터페이스를 더 작은 컴포넌트로 나누어 애플리케이션 전체에서 쉽게 재사용할 수 있도록 하는 방식으로 작동합니다. 이러한 모듈식 접근 방식을 사용하면 복잡한 사용자 인터페이스를 쉽게 관리할 수 있으며 개발자는 사용자 인터페이스가 아닌 애플리케이션의 로직에 집중할 수 있습니다. 또한 React는 속도와 성능이 뛰어나 실시간 업데이트가 필요한 웹 애플리케이션을 구축하는 데 탁월한 선택입니다.</p><h2 id="angular"><a class="markdownIt-Anchor" href="#angular"></a> Angular</h2><p>Angular는 Google에서 개발한 또 다른 인기 있는 자바스크립트 프레임워크입니다. 개발자가 동적이고 확장 가능한 웹 애플리케이션을 구축할 수 있도록 설계되었습니다. Angular는 사용자 인터페이스 구축하는 데 선언적 접근 방식을 사용하므로 복잡한 사용자 인터페이스를 쉽게 관리할 수 있습니다. 또한 종속성 주입, 양방향 데이터 바인딩, 내장 지시어 등 다양한 기능을 제공하므로 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Angular는 성능도 뛰어나 고성능 웹 애플리케이션을 구축하는 데 널리 사용됩니다.</p><h2 id="ember"><a class="markdownIt-Anchor" href="#ember"></a> Ember</h2><p>Ember는 개발자가 야심 찬 웹 애플리케이션을 구축할 수 있도록설계된 강력한 자바스크립트 프레임워크입니다. 강력한 라우터, 데이터 레이어, 내장된 테스트 프레임워크 등 다양한 기능을 제공하므로 크고 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Ember는 개발자가 모범 사례를 쉽게 따르고 시간이 지나도 쉽게 유지 관리할 수 있는 애플리케이션을 쉽게 구축할 수 있도록 하는 일련의 규칙을 제공합니다.</p><h2 id="backbone"><a class="markdownIt-Anchor" href="#backbone"></a> Backbone</h2><p>Backbone은 개발자가 중소규모 웹 애플리케이션을 구축할 수 있도록 설계된 경량 자바스크립트 프레임워크입니다. 간단한 이벤트 시스템, 모델 및 컬렉션, 강력한 라우터 등 다양한 기능을 제공합니다. Backbone은 단순하고 사용하기 쉬운 것으로 유명하여 간단한 애플리케이션을 빠르게 구축하는 데 탁월한 선택입니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>자바스크립트 프레임워크는 최신 웹 개발의 필수 구성 요소가 되었습니다. 개발자가 복잡한 애플리케이션을 빠르고 효율적으로 구축하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서 논의한 프레임워크는 개발자가 사용할 수 있는 다양한 옵션 중 일부에 불과합니다. 프레임워크를 선택할 때 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다. 올바른 프레임워크와 숙련된 개발 팀이 있으면 복잡한 웹 애플리케이션을 구축하는 것이 그 어느 때보다 쉬워졌습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/01/03/js-dev-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>예측 분석을 통한 인공지능(AI) 기반 상호 작용</title>
      <link>http://hgko1207.github.io/2024/01/02/ai-4/</link>
      <guid>http://hgko1207.github.io/2024/01/02/ai-4/</guid>
      <pubDate>Tue, 02 Jan 2024 06:19:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;인공 지능(AI)은 다양한 산업 분야에서 강력한 도구로 부상하여 기술과 상호 작용하는 방식에 혁명을 일으켰습니다. AI가 크게 발전한 분야 중 하나는 예
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-4.png" alt="" /></p><p>인공 지능(AI)은 다양한 산업 분야에서 강력한 도구로 부상하여 기술과 상호 작용하는 방식에 혁명을 일으켰습니다. AI가 크게 발전한 분야 중 하나는 예측 분석 분야로, 기업이 데이터 기반 인사이트를 바탕으로 정보에 입각한 의사결정을 내릴 수 있도록 지원합니다. 이 글에서는 AI 기반 상호작용과 예측 분석이 어떻게 산업을 변화시키고 비즈니스의 미래를 만들어가는지 살펴봅니다.</p><blockquote><p>인사이트는 통찰력이나 깊은 이해를 의미하는 단어로, 특히 비즈니스나 마케팅 분야에서는 데이터를 분석하여 얻은 유용한 정보나 통찰력을 의미하기도 합니다.</p></blockquote><h2 id="예측-분석의-힘"><a class="markdownIt-Anchor" href="#예측-분석의-힘"></a> 예측 분석의 힘</h2><p>예측 분석은 기존 데이터 세트에서 정보를 추출하여 패턴을 파악하고 미래의 결과나 추세를 예측하는 작업입니다. 기업은 과거 데이터를 분석하여 고객 행동, 시장 동향, 운영 효율성에 대한 귀중한 인사이트를 얻을 수 있습니다. 데이터의 양이 방대하고 복잡하기 때문에 사람이 데이터를 효율적으로 처리하고 의미 있는 인사이트를 도출하기란 쉽지 않습니다. 바로 이 점이 인공지능이 필요한 이유입니다.</p><h2 id="예측-분석에서-ai의-역할"><a class="markdownIt-Anchor" href="#예측-분석에서-ai의-역할"></a> 예측 분석에서 AI의 역할</h2><p>AI 알고리즘은 방대한 양의 데이터를 매우 빠른 속도로 처리하여 인간이 놓칠 수 있는 패턴과 추세를 파악할 수 있습니다. AI의 하위 집합인 머신러닝 알고리즘은 과거 데이터를 통해 학습하고 패턴과 상관관계를 기반으로 예측할 수 있습니다. 기업은 AI 기반 예측 분석을 통해 이러한 알고리즘을 활용하여 데이터 기반 의사결정을 내리고 해당 산업에서 경쟁 우위를 확보할 수 있습니다.</p><h2 id="고객-상호-작용-향상"><a class="markdownIt-Anchor" href="#고객-상호-작용-향상"></a> 고객 상호 작용 향상</h2><p>예측 분석을 통한 AI 기반 상호 작용은 기업이 고객과 소통하는 방식을 변화시켰습니다. AI 알고리즘은 구매 내역, 검색 행동, 소셜 미디어 상호 작용 상호 작용과 같은 고객 데이터를 분석하여 고객 경험을 개인화할 수 있습니다. 예를 들어, 전자상거래 플랫폼은 개인별 선호도에 따라 제품을 추천하여 고객 만족도를 높이고 판매를 촉진할 수 있습니다. 또한 AI 기반의 챗봇은 실시간 고객 지원을 제공하여 문의에 답변하고 문제를 신속하게 해결할 수 있습니다.</p><h2 id="공급망-관리-최적화"><a class="markdownIt-Anchor" href="#공급망-관리-최적화"></a> 공급망 관리 최적화</h2><p>AI와 결합된 예측 분석은 수요를 예측하고 재고 관리를 개선하며 물류를 간소화하여 공급망 관리를 최적화할 수 있습니다. AI 알고리즘은 과거 판매 데이터를 분석하여 미래 수요 패턴을 예측함으로써 기업이 생산 수준을 조정하고 품절이나 과잉 재고를 방지할 수 있도록 지원합니다. 또한 AI 기반 알고리즘은 운송 경로를 최적화하여 운송 비용을 절감하고 배송 효율성을 개선할 수 있습니다.</p><h2 id="사기-탐지-및-위험-완화"><a class="markdownIt-Anchor" href="#사기-탐지-및-위험-완화"></a> 사기 탐지 및 위험 완화</h2><p>AI 기반 예측 분석은 사기 탐지 및 위험 완화에 있어 매우 유용하다는 것이 입증되었습니다. AI 알고리즘은 대량의 금융 데이터를 분석하여 사기 행위를 나타내는 의심스러운 패턴과 이상 징후를 식별할 수 있습니다. 이러한 사전 예방적 접근 방식을 통해 기업은 심각한 재정적 손실을 초래하기 전에 사기를 탐지하고 예방할 수 있습니다. 또한 AI는 여러 소스의 데이터를 분석하여 잠재적인 위험을 식별하고 완화 전략을 개발하여 잠재적인 위협으로부터 비즈니스를 보호할 수 있습니다.</p><h2 id="의료-및-예측-분석"><a class="markdownIt-Anchor" href="#의료-및-예측-분석"></a> 의료 및 예측 분석</h2><p>의료 업계에서는 AI 기반 상호 작용과 예측 분석이 환자 치료에 혁신을 일으키고 있습니다. AI 알고리즘은 환자 기록을 분석하여 질병 진행을 예측하고, 개인 맞춤형 치료 계획을 추천하며, 환자 치료 결과를 개선할 수 있습니다. 또한 AI는 잠재적인 건강 위험을 식별하여 조기 개입 및 예방 조치를 가능하게 합니다. AI 기반 챗봇과 가상 비서는 24시간 지원을 제공하여 환자의 질문에 답하고 의료 조언을 제공할 수 있습니다.</p><h2 id="재무-예측-및-투자-결정"><a class="markdownIt-Anchor" href="#재무-예측-및-투자-결정"></a> 재무 예측 및 투자 결정</h2><p>AI 기반 예측 분석은 정확한 예측과 투자 결정을 지원함으로써 금융 산업을 재편하고 있습니다. AI 알고리즘은 시장 동향, 경제 지표 및 과거 데이터를 분석하여 주식 시장 움직임을 예측하여 거래자가 정보에 입각한 결정을 내릴 수 있도록 돕습니다. 또한 AI 기반 로보 어드바이저는 개인의 위험 프로필을 기반으로 개인화된 투자 추천을 제공하여 금융 서비스의 효율성과 접근성을 향상시킬 수 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결‍론</h2><p>AI와 예측 분석의 결합은 다양한 산업 분야에서 엄청난 잠재력을 발휘하고 있습니다. 고객과의 상호작용을 강화하고 공급망 관리를 최적화하는 것부터 사기를 탐지하고 의료 결과를 개선하는 것까지, AI 기반 상호작용과 예측 분석의 결합은 비즈니스를 변화시키고 미래를 만들어가고 있습니다. 기술이 계속 발전함에 따라 전 세계 비즈니스에서 데이터 기반 의사결정을 내리고 새로운 기회를 창출하는 데 AI의 역할이 점점 더 중요해질 것으로 예상됩니다. 이러한 혁신적인 기술을 수용하는 것은 끊임없이 진화하는 디지털 환경에서 경쟁력을 유지하는 데 핵심이 될 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/01/02/ai-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>블록체인, 영향력 있는 새로운 트렌드</title>
      <link>http://hgko1207.github.io/2024/01/02/blockchain-3/</link>
      <guid>http://hgko1207.github.io/2024/01/02/blockchain-3/</guid>
      <pubDate>Tue, 02 Jan 2024 01:52:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/blockchain-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;블록체인 기술은 전 세계적으로 다양한 산업에 혁명을 일으키고 있는 획기적인 혁신으로 등장했습니다. 처음에는 비트코인과 같은 암호화폐와의 연관성
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/blockchain-3.png" alt=""></p><p>블록체인 기술은 전 세계적으로 다양한 산업에 혁명을 일으키고 있는 획기적인 혁신으로 등장했습니다. 처음에는 비트코인과 같은 암호화폐와의 연관성으로 알려졌던 블록체인은 이제 소프트웨어 개발에 광범위한 영향을 미치는 파괴적인 힘으로 인식되고 있습니다. 이 글에서는 블록체인이 어떻게 소프트웨어 개발에 영향력 있는 트렌드가 되어 다양한 애플리케이션 전반에 걸쳐 보안, 투명성 및 효율성을 향상시키는지 살펴봅니다.</p><h2 id="보안-강화">보안 강화</h2><p>블록체인 기술의 가장 중요한 장점 중 하나는 강력한 보안 기능입니다. 기존 소프트웨어 시스템은 중앙화된 기관이나 서버에 의존하는 경우가 많아 해킹과 데이터 침해에 취약합니다. 반면 블록체인은 데이터가 여러 노드에 분산되고 저장되는 탈중앙화 네트워크를 사용합니다. 이러한 고유한 탈중앙화와 암호화 알고리즘이 결합되어 블록체인에 저장된 데이터는 안전하고 위변조가 불가능합니다. 그 결과, 안전한 애플리케이션을 구축하고 민감한 정보를 보호하며, 사용자 신뢰를 높이기 위해 소프트웨어 개발에 블록체인 기술이 점점 더 많이 채택되고 있습니다.</p><h2 id="투명성과-책임성">투명성과 책임성</h2><p>블록체인의 투명성과 불변성은 신뢰와 책임이 필요한 산업을 변화시키고 있습니다. 블록체인을 사용하면 모든 거래나 데이터 입력이 투명하고 영구적인 방식으로 기록되어 네트워크의 모든 참가자가 볼 수 있습니다. 이러한 투명성 덕분에 관련된 모든 당사자가 거래를 독립적으로 검증하고 감사할 수 있으므로 중개자가 필요하지 않습니다. 소프트웨어 개발에서 블록체인 기반 솔루션을 활용하여 감사 가능한 시스템을 만들고, 공급망을 간소화하며, 투표 시스템, 부동산 거래 및 지적 재산 관리의 투명성을 보장합니다.</p><h2 id="분산형-애플리케이션-Decentralized-Applications-DApps">분산형 애플리케이션(Decentralized Applications, DApps)</h2><p>블록체인이 소프트웨어 개발에 미치는 영향은 보안과 투명성 그 이상입니다. 이는 탈중앙화 애플리케이션(DApps) 개발의 길을 열었습니다. DApps는 블록체인의 탈중앙화 아키텍처, 스마트 계약 및 분산 합의 메커니즘을 활용하여 단일 개체에 의해 제어되지 않고 자율적으로 운영되는 애플리케이션을 만듭니다. DApps는 중개자가 필요 없기 때문에 사용자가 자신의 데이터와 상호 작용을 더 잘 제어할 수 있는 P2P 생태계를 만듭니다. 소프트웨어 개발자들은 금융, 게임, 공급망 관리, 신원 확인과 같은 분야에서 DApps의 잠재력을 점점 더 많이 탐색하고 있습니다.</p><h2 id="스마트-컨트랙트">스마트 컨트랙트</h2><p>스마트 컨트랙트는 특정 조건이 충족되면 미리 정의된 작업을 자동으로 실행하는 코드로 작성된 자체 실행 계약입니다. 블록체인의 스마트 컨트랙트 기능은 소프트웨어 개발자에게 새로운 길을 열어주었습니다. 개발자는 스마트 컨트랙트를 활용하여 복잡한 비즈니스 프로세스를 자동화하고, 중개자의 필요성을 줄이며, 투명하고 감사 가능한 계약의 실행을 보장할 수 있습니다. 이 기술은 신뢰, 투명성, 효율성이 가장 중요한 보험금 청구, 공급망 관리, 금융 거래와 같은 분야에서 특히 유용합니다.</p><h2 id="토큰화-및-디지털-자산">토큰화 및 디지털 자산</h2><p>블록체인 기술은 자산의 토큰화를 가능하게 하여 블록체인 상에서 실물 또는 디지털 아이템을 디지털 토큰으로 표현합니다. 이러한 토큰화는 안전하게 거래, 저장 및 검증할 수 있는 디지털 자산을 생성함으로써 소프트웨어 개발에 새로운 가능성을 열어줍니다. 예를 들어, 예술품, 수집품, 가상 부동산과 같은 고유한 디지털 자산을 소유하고 검증할 수 있는 대체 불가능한 토큰(NFT)이 큰 주목을 받고 있습니다. 소프트웨어 개발자들은 디지털 신원 확인, 디지털 투표, 탈중앙화 금융(DeFi)과 같은 분야에서 혁신적인 애플리케이션을 개발하기 위해 토큰화를 모색하고 있습니다.</p><h2 id="상호운용성-및-확장성">상호운용성 및 확장성</h2><p>블록체인 기술이 계속 발전함에 따라 블록체인 고유의 문제인 확장성과 상호운용성을 해결하기 위한 노력도 계속되고 있습니다. 다양한 프로젝트에서 서로 다른 블록체인이 원활하게 통신할 수 있도록 지원하여 협업과 데이터 교환을 향상시키는 솔루션을 개발하고 있습니다. 상호운용성을 통해 소프트웨어 개발자는 여러 블록체인 플랫폼의 강점을 활용하고 다양한 사용 사례에 맞는 애플리케이션을 구축할 수 있습니다. 블록체인의 트랜잭션 처리 기능의 한계를 극복하기 위해 레이어 2 프로토콜 및 샤딩과 같은 확장성 솔루션도 개발되고 있습니다.</p><h2 id="결론">결론</h2><p>블록체인 기술은 소프트웨어 개발의 강력한 힘으로 부상하여 다양한 애플리케이션에 향상된 보안, 투명성 및 효율성을 제공합니다. 스마트 컨트랙트, 토큰화, 상호운용성과 같은 기능과 함께 탈중앙화된 특성은 산업을 재편하고 혁신적인 솔루션을 위한 길을 열어주고 있습니다. 소프트웨어 개발자들이 블록체인의 잠재력을 수용함에 따라 기존 비즈니스 프로세스를 재정의하고 사용자가 데이터와 디지털 자산을 더 잘 제어할 수 있도록 지원하는 파괴적인 애플리케이션이 등장할 것으로 예상됩니다. 소프트웨어 개발의 미래는 의심할 여지 없이 블록체인 기술의 영향력 있는 트렌드와 얽혀 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2024/01/02/blockchain-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML과 CSS 기술을 향상시킬 수 있는 10가지 소규모 프로젝트 아이디어</title>
      <link>http://hgko1207.github.io/2023/12/30/web-design-4/</link>
      <guid>http://hgko1207.github.io/2023/12/30/web-design-4/</guid>
      <pubDate>Fri, 29 Dec 2023 15:13:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-design-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;소개&lt;/h2&gt;
&lt;p&gt;HTML과 CSS를 배우는 것은 웹 개발에 관심이 있는 모든 사람에게 필수적인 단계입니다. 이러한 기본 기
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-design-4.png" alt=""></p><h2 id="소개">소개</h2><p>HTML과 CSS를 배우는 것은 웹 개발에 관심이 있는 모든 사람에게 필수적인 단계입니다. 이러한 기본 기술은 인터넷에 있는 모든 웹사이트의 구성 요소입니다. 이를 익히려면 연습이 필요한데, 소규모 프로젝트에 참여하는 것보다 더 좋은 방법이 있을까요? 이 글에서는 HTML 및 CSS 기술을 연마하는 데 도움이 되는 10가지 소규모 프로젝트 아이디어를 살펴보겠습니다.</p><h2 id="개인-포트폴리오-웹사이트">개인 포트폴리오 웹사이트</h2><p>개인 포트폴리오 웹사이트를 만들어 자신의 기술, 프로젝트, 경험을 보여주세요. 이 프로젝트를 통해 콘텐츠 구조화를 위한 HTML과 레이아웃 및 디자인을 위한 CSS를 연습하면서 웹사이트를 디자인하고 스타일을 지정할 수 있습니다.</p><h2 id="레시피-북">레시피 북</h2><p>HTML과 CSS를 사용하여 디지털 요리책을 디자인하세요. 좋아하는 요리법을 나열하고, 이미지를 추가하고, 시각적으로 매력적으로 보이도록 레이아웃을 스타일링할 수 있습니다.</p><h2 id="제품-랜딩-페이지">제품 랜딩 페이지</h2><p>마음에 드는 제품을 선택하고 해당 제품의 랜딩 페이지를 디자인하세요. 제품 설명, 이미지, 클릭 유도 버튼을 포함하여 실제 전자상거래 페이지를 모방할 수 있습니다.</p><h2 id="블로그-페이지">블로그 페이지</h2><p>HTML과 CSS로 간단한 블로그 페이지를 만들어보세요. 블로그 게시물을 표시하고, 탐색을 위한 사이드바를 포함하며, 원하는 대로 스타일을 지정할 수 있습니다. 이 프로젝트는 레이아웃 및 반응형 디자인 작업에 도움이 됩니다.</p><h2 id="헌정-페이지">헌정 페이지</h2><p>존경하는 역사적인 인물이나 유명인을 선택하여 해당 인물에 대한 헌정 페이지를 만드세요. 이미지, 인용문, 간략한 소개를 포함하세요. HTML로 콘텐츠를 구조화하고 CSS로 스타일을 지정하는 연습을 할 수 있는 좋은 프로젝트입니다.</p><h2 id="로그인-등록-양식">로그인/등록 양식</h2><p>유효성 검사가 포함된 로그인 및 등록 양식을 작성하세요. 이 프로젝트는 양식 작성 및 사용자 입력 작업에 대한 인사이트를 얻을 수 있습니다.</p><h2 id="이미지-갤러리">이미지 갤러리</h2><p>HTML과 CSS로 간단한 이미지 갤러리를 개발해 보세요. 이미지 썸네일을 추가하고, 라이트박스를 만들고, 부드러운 전환을 구현할 수 있습니다. 레이아웃과 인터랙션 디자인을 연습하기에 좋은 프로젝트입니다.</p><h2 id="할-일-목록">할 일 목록</h2><p>할 일 목록 앱을 만들어 보세요. 기본 기능으로 작업을 추가, 편집, 제거할 수 있습니다. 이 프로젝트는 HTML과 CSS를 사용하여 DOM을 조작하는 방법을 이해하는 데 도움이 됩니다.</p><h2 id="날씨-앱">날씨 앱</h2><p>API에서 날씨 데이터를 가져와 사용자 친화적인 인터페이스에 표시하는 날씨 앱을 만드세요. 이 프로젝트를 통해 외부 데이터 소스 및 동적 콘텐츠 작업에 대한 인사이트를 얻을 수 있습니다.</p><h2 id="CSS-애니메이션">CSS 애니메이션</h2><p>로딩되는 스피너, 튀어 오르는 공 또는 슬라이딩 탐색 메뉴를 만들어 CSS 애니메이션을 실험해 보세요. 애니메이션은 CSS의 창의적인 측면을 탐색할 수 있는 재미있는 방법입니다.</p><h2 id="결론">결론</h2><p>소규모 프로젝트 작업은 HTML과 CSS 기술을 향상시키는 훌륭한 방법입니다. 이러한 프로젝트는 실무 경험을 쌓는 데 도움이 될 뿐만 아니라 잠재적인 고용주나 고객에게 선보일 작업 포트폴리오를 구축하는 데도 도움이 됩니다. 이러한 프로젝트를 완료하면서 지속적으로 도전하고 HTML 및 CSS의 새로운 기술과 기능을 탐색하는 것을 잊지 마세요. 연습을 많이 할수록 웹 개발에 대한 자신감과 숙련도가 높아집니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/30/web-design-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>사용자 인터페이스 디자인의 기초: 종합 가이드</title>
      <link>http://hgko1207.github.io/2023/12/27/web-5/</link>
      <guid>http://hgko1207.github.io/2023/12/27/web-5/</guid>
      <pubDate>Wed, 27 Dec 2023 13:36:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;사용자 인터페이스(UI) 디자인은 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-5.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>사용자 인터페이스(UI) 디자인은 사용자 친화적이고 시각적으로 매력적인 소프트웨어, 웹 사이트, 모바일 애플리케이션을 만드는 데 중요한 측면입니다. 잘 디자인된 UI는 성공적이고 직관적인 제품과 실망스러운 제품 사이의 차이를 만들 수 있습니다. 이 글에서는 사용자 인터페이스 디자인의 기본 사항을 살펴보고, 주요 원칙을 세분화하고, 이러한 개념을 설명하기 위한 실제 사례를 제공합니다.</p><h2 id="사용자-이해"><a class="markdownIt-Anchor" href="#사용자-이해"></a> 사용자 이해</h2><p>UI 디자인의 첫 번째 단계는 타겟 고객을 이해하는 것입니다. 효과적인 디자인은 사용자의 요구, 선호도, 기대치를 충족시켜야 합니다. 이 점을 설명하기 위해 Facebook의 예를 살펴보겠습니다. Facebook의 UI 디자인은 기술에 능숙한 밀레니얼 세대부터 노년층에 이르기까지 다양한 사용자층에 맞춰져 있습니다. 깔끔하고 탐색하기 쉬운 인터페이스로 모든 연령대의 사람들이 쉽게 접근할 수 있어 폭넓은 사용자층을 확보할 수 있습니다.</p><p><img src="/images/header/web-5_1.png" alt="" /></p><h2 id="일관성과-단순성"><a class="markdownIt-Anchor" href="#일관성과-단순성"></a> 일관성과 단순성</h2><p>UI 디자인의 일관성은 매우 중요합니다. 사용자가 시스템의 작동 방식을 쉽게 예측할 수 있기 때문입니다. 탐색 메뉴의 배치, 버튼 스타일, 색 구성표 등 모든 면에서 일관성을 유지하면 편안한 사용자 환경을 만들 수 있습니다. Google의 검색 엔진을 예로 들어 보겠습니다. 수년 동안 Google의 UI는 비교적 일관성을 유지해 왔습니다. 사용자는 무엇을 기대해야 할지 알고 있으며, 이러한 친숙함은 널리 사용되는 데 기여합니다.</p><p><img src="/images/header/web-5_2.png" alt="" /></p><p>단순성은 또 다른 핵심 요소입니다. 어수선하거나 지나치게 복잡한 UI는 사용자를 압도할 수 있습니다. Apple의 iPhone은 단순함의 힘을 보여주는 대표적인 예입니다. 깔끔하고 직관적인 인터페이스를 통해 사용자는 학습 곡선을 거의 또는 전혀 거치지 않고도 기기를 집어 들고 사용할 수 있습니다.</p><h2 id="시각적-계층"><a class="markdownIt-Anchor" href="#시각적-계층"></a> 시각적 계층</h2><p>UI 디자인에서 시각적 계층 구조는 화면에서 요소의 배열과 우선순위를 의미합니다. 시각적 계층 구조는 사용자의 주의를 유도하고 인터페이스를 효과적으로 탐색할 수 있도록 도와줍니다. 에어비앤비(Airbnb) 웹사이트를 생각해 보세요. 검색창과 클릭 유도 버튼은 페이지 상단에 눈에 잘 띄게 배치되어 가장 중요한 작업으로 사용자의 주의를 집중시킵니다.</p><p><img src="/images/header/web-5_3.png" alt="" /></p><h2 id="피드백과-응답성"><a class="markdownIt-Anchor" href="#피드백과-응답성"></a> 피드백과 응답성</h2><p>사용자는 UI와 상호작용할 때 피드백을 받아야 합니다. 버튼에 마우스를 갖다 대면 색이 바뀌거나 작업이 로드 중일 때 진행률 표시줄이 표시되는 등 간단한 방법으로도 피드백을 받을 수 있습니다. 인기 있는 팀 커뮤니케이션 플랫폼인 Slack은 실시간 입력 표시, 메시지 전송 확인 및 읽음 확인을 통해 뛰어난 피드백을 제공합니다. 이를 통해 사용자는 플랫폼 내에서 진행 중인 작업과 상호 작용에 대한 정보를 계속 확인할 수 있습니다.</p><p><img src="/images/header/web-5_4.png" alt="" /></p><h2 id="접근성"><a class="markdownIt-Anchor" href="#접근성"></a> 접근성</h2><p>UI 디자인은 장애인을 포함한 모든 사람이 애플리케이션을 사용할 수 있도록 접근성을 우선적으로 고려해야 합니다. Microsoft의 Windows 운영 체제는 접근성 기능을 개선하는 데 상당한 진전을 이루었습니다. 모든 사용자가 UI에 액세스할 수 있도록 화면 판독기 및 음성 명령과 같은 다양한 보조 기술을 제공합니다.</p><p><img src="/images/header/web-5_5.png" alt="" /></p><h2 id="타이포그래피와-가독성"><a class="markdownIt-Anchor" href="#타이포그래피와-가독성"></a> 타이포그래피와 가독성</h2><p>올바른 글꼴과 타이포그래피를 선택하는 것은 UI 디자인에 매우 중요합니다. 텍스트는 가독성이 뛰어나고 심미적으로도 아름다워야 합니다. 예를 들어 트위터의 UI는 트윗에 간단하고 가독성이 좋은 글꼴을 사용하여 사용자가 콘텐츠에 쉽게 참여할 수 있도록 합니다.</p><p><img src="/images/header/web-5_6.png" alt="" /></p><h2 id="사용자-테스트"><a class="markdownIt-Anchor" href="#사용자-테스트"></a> 사용자 테스트</h2><p>사용자 테스트에는 디자인 과정에서 실제 사용자로부터 피드백을 받는 과정이 포함됩니다. 이러한 피드백은 문제를 파악하고 UI를 개선하는 데 매우 중요합니다. 클라우드 스토리지 플랫폼인 Dropbox는 사용자 경험을 개선하기 위해 정기적으로 사용자 테스트를 실시합니다. 실제 사용자의 참여를 통해 인터페이스를 지속적으로 개선하고 사용자 친화적인 인터페이스를 만듭니다.</p><p><img src="/images/header/web-5_7.png" alt="" /></p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>사용자 인터페이스 디자인은 예술과 과학을 결합하여 사용자에게 매력적이고 직관적인 경험을 제공하는 종합 분야입니다. 사용자를 이해하고, 일관성을 유지하고, 단순성을 우선시하고, 시각적 계층 구조를 설정하고, 피드백을 제공하고, 접근성을 보장하고, 적절한 타이포그래피를 선택하고, 사용자 테스트를 수행하는 것은 모두 UI 디자인의 필수 요소입니다. Facebook, Google, Apple, Airbnb, Slack, Microsoft 및 Twitter와 같은 회사의 실제 사례를 통해 확인할 수 있습니다. 이러한 기본 원칙을 준수하면 원활한 사용자 경험을 제공하면서 잠재 고객의 마음을 사로잡고 참여를 유도하는 사용자 인터페이스를 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/27/web-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML, CSS, JavaScript 숙달하기</title>
      <link>http://hgko1207.github.io/2023/12/24/web-4/</link>
      <guid>http://hgko1207.github.io/2023/12/24/web-4/</guid>
      <pubDate>Sat, 23 Dec 2023 15:14:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;능숙한 웹 개발자가 되기 위해서는 HTML, CSS, JavaScript와 같은 핵심 웹 기술을 마스터하는 것이 필수적입니다. 다음은 이러한 각 기술을
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-4.png" alt="" /></p><p>능숙한 웹 개발자가 되기 위해서는 HTML, CSS, JavaScript와 같은 핵심 웹 기술을 마스터하는 것이 필수적입니다. 다음은 이러한 각 기술을 숙달하는 방법에 대한 분석입니다.</p><h2 id="1-html-hypertext-markup-language"><a class="markdownIt-Anchor" href="#1-html-hypertext-markup-language"></a> 1. HTML (Hypertext Markup Language)</h2><ul><li><strong>기본 사항 알아보기:</strong> 제목(h1, h2, …), 단락§, 목록(ul, li), 링크(a) 및 이미지(image)와 같은 기본적인 HTML 요소와 태그를 이해하는 것부터 시작하세요.<br /><br/></li><li><strong>시맨틱 HTML:</strong> 콘텐츠에 의미와 구조를 부여하기 위해 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;footer&gt;</code>와 같은 시맨틱 HTML 태그를 사용하는 데 집중하세요.<br /><br/></li><li><strong>양식(Forms):</strong> 입력 필드, 텍스트 영역, 라디오 버튼, 체크박스, submit 버튼 등 HTML을 사용하여 양식을 만드는 방법을 알아보세요.<br /><br/></li><li><strong>HTML5 기능:</strong> 비디오 및 오디오 요소, 그래픽을 위한 canvas, 클라이언트 측 데이터 저장을 위한 로컬 스토리지 API와 같은 HTML5 기능에 익숙해집니다.<br /><br/></li><li><strong>유효성 검사:</strong> 온라인 유효성 검사기 또는 통합 개발 환경(IDE) 도구를 사용하여 HTML 코드의 유효성을 검사하는 방법을 이해합니다.</li></ul><h2 id="2-css-cascading-style-sheets"><a class="markdownIt-Anchor" href="#2-css-cascading-style-sheets"></a> 2. CSS (Cascading Style Sheets)</h2><ul><li><strong>박스 모델:</strong> 요소의 크기(size)와 여백(margin), 테두리(border), 패딩(padding), 콘텐츠가 상호 작용하는 방식을 이해하는 등 CSS 박스 모델에 대해 알아보세요.<br /><br/></li><li><strong>선택기(Selectors):</strong> 스타일 지정을 위해 특정 HTML 요소를 지정하는 CSS 선택기를 마스터하세요.<br /><br/></li><li><strong>레이아웃 기법:</strong> 반응형 디자인을 만들기 위한 Flexbox 및 CSS 그리드와 같은 다양한 레이아웃 기법을 살펴보세요.<br /><br/></li><li><strong>반응형 디자인:</strong> 미디어 쿼리와 반응형 디자인 원칙을 이해하여 다양한 기기와 화면 크기에서 웹 페이지가 멋지게 보이도록 만드세요.<br /><br/></li><li><strong>전환(Transitions) and 애니메이션(Animations):</strong> 더 나은 사용자 경험을 위해 CSS를 사용하여 부드러운 전환과 애니메이션을 만드는 방법을 알아보세요.<br /><br/></li><li><strong>전처리기:</strong> CSS 워크플로우와 유지보수성을 향상시키기 위해 SASS 또는 LESS와 같은 CSS 전처리기를 학습하는 것도 고려해 보세요.</li></ul><h2 id="3-javascript"><a class="markdownIt-Anchor" href="#3-javascript"></a> 3. JavaScript</h2><ul><li><strong>구문과 기초:</strong> 변수, 데이터 유형, 연산자, 제어 구조(if 문, 루프) 등 JavaScript의 기초부터 시작하세요.<br /><br/></li><li><strong>DOM 조작:</strong> DOM(Document Object Model )과 상호 작용하여 HTML 콘텐츠와 스타일을 동적으로 변경하는 방법을 이해합니다.<br /><br/></li><li><strong>이벤트 처리:</strong> 클릭, 키 누름, 양식(form) 제출과 같은 사용자 상호작용과 이벤트를 처리하는 방법을 알아보세요.<br /><br/></li><li><strong>함수 및 범위:</strong> JavaScript의 기본 개념인 함수(function), 범위(scope), 클로저(closure)에 대해 자세히 알아보세요.<br /><br/></li><li><strong>AJAX와 Fetch:</strong> 서버에 요청하기 위한 AJAX 또는 최신 Fetch API를 사용한 비동기 프로그래밍을 살펴보세요.<br /><br/></li><li><strong>프레임워크와 라이브러리:</strong> 대화형 웹 애플리케이션을 구축하기 위해 React, Angular 또는 Vue.js와 같은 인기 있는 JavaScript 프레임워크와 라이브러리를 학습해 보세요.<br /><br/></li><li><strong>ES6 이상:</strong> ES6(ECMAScript 2015)를 비롯한 최신 JavaScript 기능 및 표준에 대해 알아보세요.<br /><br/></li><li><strong>테스트:</strong> 단위 테스트를 작성하고 Jest와 같은 테스트 프레임워크를 사용하여 JavaScript 코드의 안정성을 보장하는 방법을 알아보세요.<br /><br/></li><li><strong>디버깅:</strong> 브라우저 개발자 도구와 디버깅 기술을 사용하여 JavaScript 오류를 해결하고 수정하세요.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>숙달하려면 시간과 연습이 필요하다는 것을 기억하세요. 작은 프로젝트부터 시작하여 점차 더 복잡한 프로젝트로 나아가세요. 온라인 튜토리얼, 강좌, 코딩 연습은 HTML, CSS, JavaScript 기술을 배우고 향상하는 데 유용한 자료가 될 수 있습니다. 정기적으로 연습하고, 피드백을 구하고, 웹 개발의 최신 동향을 파악하여 능숙한 웹 개발자가 되세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/24/web-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 기술 디코딩: HTML, XML, JSON, AJAX에 대한 종합 가이드</title>
      <link>http://hgko1207.github.io/2023/12/23/web-3/</link>
      <guid>http://hgko1207.github.io/2023/12/23/web-3/</guid>
      <pubDate>Sat, 23 Dec 2023 14:45:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;빠르게 발전하는 웹 개발 분야에서는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-3.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>빠르게 발전하는 웹 개발 분야에서는 인터넷을 주도하는 핵심 기술에 대한 기초적인 이해가 가장 중요합니다. 이 블로그 게시물은 최신 웹 애플리케이션의 동적 기능에 기여하는 필수 구성 요소인 HTML, XML, JSON 및 AJAX의 복잡한 내용을 풀어내는 것을 목표로 합니다.</p><h2 id="html-웹-페이지의-구성-요소"><a class="markdownIt-Anchor" href="#html-웹-페이지의-구성-요소"></a> HTML: 웹 페이지의 구성 요소</h2><p><img src="/images/header/web-3_1.png" alt="" /></p><p>HTML(Hypertext Markup Language)은 웹 페이지 구성의 초석입니다. 표준화된 프레임워크 역할을 하는 HTML은 태그를 사용하여 제목, 단락§, 이미지 및 링크와 같은 다양한 요소를 정의합니다. 웹 브라우저는 HTML을 해석하여 다양한 기기에서 일관된 디스플레이를 보장합니다. 기본적인 HTML 구조를 살펴보겠습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Web Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a simple web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">alt</span>=<span class="string">"An example image"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>Visit Example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xml-유연한-데이터-표현"><a class="markdownIt-Anchor" href="#xml-유연한-데이터-표현"></a> XML: 유연한 데이터 표현</h2><p><img src="/images/header/web-3_2.png" alt="" /></p><p>XML(eXtensible Markup Language)은 데이터 전송 및 저장에 맞게 조정되었습니다. XML은 사용자 정의 태그를 사용하여 정보를 계층적으로 구성하여 사람과 기계의 가독성을 높입니다. XML은 서로 다른 시스템 간의 데이터 교환에서 빛을 발하며 원활한 커뮤니케이션을 촉진합니다. 다음은 XML의 구조입니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">city</span>&gt;</span>New York<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="json-경량-데이터-교환"><a class="markdownIt-Anchor" href="#json-경량-데이터-교환"></a> JSON: 경량 데이터 교환</h2><p><img src="/images/header/web-3_3.png" alt="" /></p><p>민첩한 데이터 교환 형식인 JSON(JavaScript Object Notation)은 사람이 읽을 수 있고 기계 친화적입니다. 비동기식 브라우저/서버 통신에 널리 사용되며 API(Application Programming Interfaces)에서 널리 사용되는 JSON은 데이터 표현을 간소화합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hg Ko"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">35</span>,</span><br><span class="line">  <span class="attr">"city"</span>: <span class="string">"Daejeon"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ajax-동적-웹-상호-작용"><a class="markdownIt-Anchor" href="#ajax-동적-웹-상호-작용"></a> AJAX: 동적 웹 상호 작용</h2><p><img src="/images/header/web-3_4.png" alt="" /></p><p>AJAX(Asynchronous JavaScript and XML)는 HTML, CSS, JavaScript, XML 및 JSON을 통합하는 기술입니다. 브라우저와 서버 간의 비동기식 데이터 교환을 용이하게 하여 전체 재로드 없이 동적 웹 페이지 업데이트를 가능하게 합니다. 다음은 AJAX가 실제로 작동하는 모습을 보여줍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example AJAX request using JavaScript</span></span><br><span class="line"><span class="keyword">var</span> xhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).innerHTML = <span class="keyword">this</span>.responseText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhttp.open(<span class="string">'GET'</span>, <span class="string">'ajax-example.txt'</span>, <span class="literal">true</span>);</span><br><span class="line">xhttp.send();</span><br></pre></td></tr></table></figure><h2 id="모든-것-종합하기"><a class="markdownIt-Anchor" href="#모든-것-종합하기"></a> 모든 것 종합하기</h2><p>개발자는 구조를 위한 HTML, 데이터 표현을 위한 XML, 가벼운 데이터 교환을 위한 JSON을 결합하여 강력하고 동적인 웹 애플리케이션을 만들 수 있습니다. 비동기 통신을 통해 AJAX는 원활한 상호 작용을 보장하여 사용자 경험을 향상시킵니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>HTML, XML, JSON, AJAX는 웹 개발에서 각각 고유한 역할을 수행합니다. HTML은 콘텐츠를 구조화하고, XML은 데이터를 표현하며, JSON은 상호 교환을 용이하게 하며, AJAX는 역동성을 구현합니다. 웹 개발 여정을 시작할 때 이러한 기술을 숙지하는 것은 필수적입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/23/web-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>인공 지능(AI)과 머신 러닝(ML) 활용하기</title>
      <link>http://hgko1207.github.io/2023/12/22/ai-3/</link>
      <guid>http://hgko1207.github.io/2023/12/22/ai-3/</guid>
      <pubDate>Fri, 22 Dec 2023 14:03:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;빠르게 발전하는 기술 환경에서 인공 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-3.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>빠르게 발전하는 기술 환경에서 인공 지능(AI)과 머신 러닝(ML)은 게임 체인저로 등장하여 우리가 세상과 상호 작용하고 인식하는 방식에 혁명을 일으켰습니다. 효율성 향상부터 복잡한 문제 해결까지 AI와 ML의 융합은 산업을 재편하고 전례 없는 속도로 혁신을 주도하고 있습니다.</p><h2 id="인공지능과-머신러닝의-이해"><a class="markdownIt-Anchor" href="#인공지능과-머신러닝의-이해"></a> 인공지능과 머신러닝의 이해</h2><p>인공 지능은 우리가 &quot;스마트&quot;하다고 생각하는 방식으로 작업을 수행할 수 있는 기계의 광범위한 개념입니다. 반면 머신러닝은 명시적으로 프로그래밍하지 않고도 기계가 데이터를 통해 학습할 수 있도록 하는 AI의 하위 집합입니다.이 두 가지를 함께 사용하면 시간이 지남에 따라 성능을 향상할 수 있는 지능형 시스템을 만들 수 있습니다.</p><h3 id="정의"><a class="markdownIt-Anchor" href="#정의"></a> 정의</h3><ul><li><strong>인공 지능(AI):</strong> AI는 일반적으로 인간의 지능이 필요한 작업을 수행할 수 있는 기계나 시스템을 만드는 것을 목표로 하는 컴퓨터 과학의 광범위한 분야입니다. 여기에는 문제 해결, 학습, 지각, 언어 이해 등 기계가 인간의 지능을 시뮬레이션할 수 있도록 설계된 다양한 기법, 접근 방식, 기술이 포함됩니다.<br /><br/></li><li><strong>머신 러닝(ML):</strong> 머신 러닝은 컴퓨터가 명시적인 프로그래밍 없이 작업을 수행할 수 있도록 하는 알고리즘 및 통계 모델 개발에 중점을 두는 AI의 하위 집합입니다. 즉, 머신러닝을 통해 기계는 특정 작업에 대해 명시적으로 프로그래밍하지 않고도 데이터를 통해 학습하고 시간이 지남에 따라 성능을 향상시킬 수 있습니다.</li></ul><h2 id="산업-전반에-걸친-응용-분야"><a class="markdownIt-Anchor" href="#산업-전반에-걸친-응용-분야"></a> 산업 전반에 걸친 응용 분야</h2><ol><li><strong>의료:</strong> AI와 ML은 개인 맞춤형 치료 계획부터 질병 조기 발견에 이르기까지 의료 분야에 큰 변화를 일으키고 있습니다. 머신러닝 알고리즘으로 구동되는 예측 분석은 의사가 정보에 입각한 의사 결정을 내리는 데 도움을 주어 생명과 자원을 절약합니다.<br /><br/></li><li><strong>금융:</strong> 금융 부문에서는 AI와 ML이 리스크 관리, 사기 탐지, 고객 서비스를 최적화하고 있습니다. 머신러닝 모델을 기반으로 하는 알고리즘 트레이딩은 방대한 데이터 세트를 분석하여 순식간에 결정을 내리고 수익을 극대화합니다.<br /><br/></li><li><strong>소매업:</strong> 맞춤형 추천, 공급망 최적화, 수요 예측이 소매업 환경을 변화시키고 있습니다. AI 기반 챗봇과 가상 비서는 고객 경험을 향상시켜 실시간 지원을 제공합니다.<br /><br/></li><li><strong>자율주행차:</strong> 자동차 산업은 AI와 ML로 인해 패러다임 전환을 겪고 있습니다. 자율주행차는 이러한 기술을 활용하여 실시간 데이터를 해석하고 대응함으로써 보다 안전하고 효율적인 운송을 보장합니다.<br /><br/></li><li><strong>교육:</strong> AI 기반의 적응형 학습 플랫폼은 학생 개개인의 요구를 충족하여 맞춤형 학습 경험을 제공합니다. 머신러닝 알고리즘은 학생 성과 데이터를 분석하여 개선이 필요한 영역을 파악하고 그에 따라 교육 콘텐츠를 맞춤화합니다.</li></ol><h2 id="새로운-트렌드와-기술"><a class="markdownIt-Anchor" href="#새로운-트렌드와-기술"></a> 새로운 트렌드와 기술</h2><ol><li><strong>설명 가능한 AI(XAI):</strong> AI 시스템이 점점 복잡해짐에 따라 의사 결정 과정을 투명하고 이해하기 쉽게 만드는 것이 점점 더 강조되고 있습니다. XAI는 AI 알고리즘을 해석하고 신뢰할 수 있도록 보장하는 중요한 트렌드입니다<br /><br/></li><li><strong>엣지 컴퓨팅:</strong> AI 및 ML을 엣지 컴퓨팅과 통합하면 데이터 소스에 더 가까운 곳에서 처리가 수행하여 대기 시간을 줄이고 실시간 의사 결정을 향상시킬 수 있습니다. 이는 IoT 장치 및 자율주행차와 같은 애플리케이션에 특히 중요합니다.<br /><br/></li><li><strong>자연어 처리(NLP):</strong> NLP의 발전으로 기계는 인간과 유사한 언어를 이해하고 해석하며 생성할 수 있게 되었습니다. 이는 챗봇, 가상 비서 및 언어 번역 서비스의 혁신을 주도하고 있습니다.<br /><br/></li><li><strong>AI 윤리 및 편향성 완화:</strong> AI 시스템이 더욱 널리 보급됨에 따라 윤리적 문제를 해결하고 알고리즘의 편견을 완화하는 것이 무엇보다 중요해졌습니다. 책임감 있는 AI 개발 및 배포에 초점을 맞춘 이니셔티브가 주목을 받고 있습니다.</li></ol><p>인공 지능(AI)과 머신 러닝(ML)은 밀접하게 관련된 개념이지만 컴퓨터 과학과 기술의 서로 다른 측면을 나타냅니다.</p><h2 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h2><ul><li><strong>인공 지능(AI):</strong> 가상 개인 비서(예: Siri 또는 Alexa), 게임 플레이 알고리즘(예: 체스나 바둑에 사용되는 알고리즘) 및 전문가 시스템이 AI 애플리케이션의 예입니다.<br /><br/></li><li><strong>기계 학습(ML):</strong> 넷플릭스나 아마존에서 사용하는 것과 같은 추천 시스템, 이미지 및 음성 인식, 예측 분석은 머신 러닝 기술을 많이 사용하는 애플리케이션의 예입니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>인공 지능과 기계 학습은 지능형 시스템이 인간의 능력을 보조할 뿐만 아니라 증강하는 미래로 우리를 이끌고 있습니다. 혁신의 잠재력은 무한해 보이며, 이러한 기술이 달성할 수 있는 한계를 뛰어넘는 혁신이 끊임없이 이루어지고 있습니다. 이러한 기술적 한계를 탐색할 때 윤리적 고려 사항을 항상 경계하고 모든 사람이 AI 및 ML의 이점에 접근할 수 있도록 하는 것이 중요합니다. 혁신적인 기술의 잠재력을 최대한 활용하면서 다음 발전의 물결을 계속 지켜봐 주시기 바랍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/22/ai-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>최고의 무료 AI 이미지 생성기 살펴보기</title>
      <link>http://hgko1207.github.io/2023/12/21/ai-2/</link>
      <guid>http://hgko1207.github.io/2023/12/21/ai-2/</guid>
      <pubDate>Thu, 21 Dec 2023 13:10:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;디지털 콘텐츠 제작의 역동적인 영역에
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-2.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>디지털 콘텐츠 제작의 역동적인 영역에서 인공지능(AI) 이미지 생성기는 새로운 차원의 창의성을 발휘할 수 있는 강력한 도구로 부상했습니다. 그래픽 디자이너, 소셜 미디어 애호가 또는 시각적 콘텐츠를 향상시키고자 하는 사람 모두에게 AI 이미지 생성기의 세계는 흥미로운 가능성으로 가득합니다. 이 글에서는 아이디어를 멋진 비주얼로 손쉽게 변환할 수 있도록 도와주는 최고의 무료 AI 이미지 생성기 몇 가지를 소개합니다.</p><h2 id="deep-dream-generator"><a class="markdownIt-Anchor" href="#deep-dream-generator"></a> Deep Dream Generator</h2><p>Deep Dream Generator로 초현실적인 여행을 떠나보세요. Google의 신경망으로 구동되는 이 도구는 평범한 이미지를 꿈같은 사이키델릭한 작품으로 바꿔줍니다. 다양한 필터와 스타일로 실험하면서 상상력을 발휘하여 독특하고 이색적인 비주얼을 만들어 보세요.</p><blockquote><p>Psychedelic은 주로 환각적인 경험을 일으키는 약물이나 물질을 가리키며, 이로 인해 감각이 왜곡되고 정신적으로 변화되는 경험을 의미합니다. 이러한 경험은 종종 색채, 모양, 패턴 등의 시각적 변화와 함께 음악이나 감각적인 자극에 대한 강한 반응을 포함합니다.</p></blockquote><p><a href="https://deepdreamgenerator.com/" target="_blank" rel="noopener">https://deepdreamgenerator.com/</a></p><p><img src="/images/header/ai-2_1.png" alt="" /></p><h2 id="dall-e-by-openai"><a class="markdownIt-Anchor" href="#dall-e-by-openai"></a> DALL-E by OpenAI</h2><p>OpenAI에서 개발한 AI 모델인 DALL-E와 함께 무한한 상상의 영역으로 들어가 보세요. 이 획기적인 이미지 생성기는 텍스트 설명을 기반으로 이미지를 생성하여 AI가 구현할 수 있는 한계를 뛰어넘습니다. 몇 가지 간단한 프롬프트만으로 신화 속 생물부터 미래 풍경까지 무엇이든 생성할 수 있습니다.</p><p><a href="https://openai.com/dall-e-2" target="_blank" rel="noopener">https://openai.com/dall-e-2</a></p><p><img src="/images/header/ai-2_2.png" alt="" /></p><h2 id="artbreeder"><a class="markdownIt-Anchor" href="#artbreeder"></a> Artbreeder</h2><p>Artbreeder를 사용하면 이미지를 혼합하고 변형하여 완전히 새로운 구성을 만들어 디지털 아티스트의 역할을 수행할 수 있습니다. 이 직관적인 플랫폼을 사용하면 색 구성표부터 얼굴 특징까지 작품의 모든 측면을 세밀하게 조정하여 시각적으로 멋지고 고도로 맞춤화된 이미지를 만들 수 있습니다.</p><p><a href="https://www.artbreeder.com/" target="_blank" rel="noopener">https://www.artbreeder.com/</a></p><p><img src="/images/header/ai-2_3.png" alt="" /></p><h2 id="runwayml"><a class="markdownIt-Anchor" href="#runwayml"></a> RunwayML</h2><p>다양한 AI 모델을 찾는 사람들에게 RunwayML은 보물창고와도 같습니다. 이 플랫폼은 다양한 크리에이티브 작업에 특화된 사전 학습된 모델을 호스팅합니다. 예술, 음악, 동영상 조작 등 어떤 작업을 하든 RunwayML은 최첨단 AI를 실험할 수 있는 사용자 친화적인 인터페이스를 제공합니다.</p><p><a href="https://runwayml.com/?ref=zguyun.com" target="_blank" rel="noopener">https://runwayml.com/?ref=zguyun.com</a></p><p><img src="/images/header/ai-2_4.png" alt="" /></p><h2 id="this-person-does-not-exist"><a class="markdownIt-Anchor" href="#this-person-does-not-exist"></a> This Person Does Not Exist</h2><p>&quot;이 사람은 존재하지 않습니다.&quot;로 사실적이지만 완전히 가상의 얼굴을 만들어 보세요. GAN(Generative Adversarial Network)으로 구동되는 이 AI 이미지 생성기는 실존하지 않는 인물의 초상화를 제작합니다. 캐릭터 디자인부터 프로젝트에 미스터리한 느낌을 더하는 것까지 다양한 용도로 이 이미지를 사용하세요.</p><p><a href="https://this-person-does-not-exist.com/en" target="_blank" rel="noopener">https://this-person-does-not-exist.com/en</a></p><p><img src="/images/header/ai-2_5.png" alt="" /></p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>AI 이미지 생성기의 시대가 열리면서 디지털 크리에이티브의 혁명이 시작되었고, 그 어느 때보다 더 쉽게 접근하고 흥미롭게 만들 수 있게 되었습니다. 아티스트, 디자이너, 콘텐츠 제작자 모두에게 이 무료 AI 이미지 생성기는 상상력을 발휘할 수 있는 놀이터를 제공합니다. 이러한 도구로 실험하고, 현실과 환상을 혼합하고, 디지털 영역에서 창의력을 마음껏 발휘하세요. 가능성은 무궁무진하며, 유일한 한계는 여러분의 창의력뿐입니다. 지금 바로 AI 기반 이미지 생성의 매혹적인 세계에 빠져보세요!</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/21/ai-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>거절을 마스터하기: 좌절을 성공으로 바꾸는 가이드</title>
      <link>http://hgko1207.github.io/2023/12/21/etc-1/</link>
      <guid>http://hgko1207.github.io/2023/12/21/etc-1/</guid>
      <pubDate>Thu, 21 Dec 2023 06:09:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/etc-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;거절은 직장이나 개인적인 영역 모두에서 피할 수 없는 삶의 일부입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 어떤 상황에서든 거절을 당하면 감
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/etc-1.png" alt="" /></p><p>거절은 직장이나 개인적인 영역 모두에서 피할 수 없는 삶의 일부입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 어떤 상황에서든 거절을 당하면 감당하기 어려울 수 있습니다. 하지만 거절에 어떻게 대응하느냐에 따라 미래의 성공과 행복에 큰 영향을 미칠 수 있습니다. 다음은 전문성과 회복탄력성을 가지고 거절을 처리하는 방법에 대한 가이드입니다.</p><h2 id="감정-수용하기"><a class="markdownIt-Anchor" href="#감정-수용하기"></a> 감정 수용하기</h2><p>감정을 수용한다는 것은 거절에 대한 반응으로 발생하는 감정을 인정하고 받아들이는 것을 포함합니다. 감정을 억누르거나 피하지 말고 스스로 감정을 느끼고 처리할 수 있도록 하세요. 이 단계는 진정성과 자기 인식을 바탕으로 어려움을 헤쳐 나갈 수 있는 기반을 마련하기 때문에 감성 지능, 회복탄력성, 개인적 성장을 촉진하는 데 매우 중요합니다.</p><h2 id="건설적인-피드백-구하기"><a class="markdownIt-Anchor" href="#건설적인-피드백-구하기"></a> 건설적인 피드백 구하기</h2><p>건설적인 피드백을 구하는 것은 개인적, 직업적 발전을 위한 적극적인 접근 방식입니다. 여기에는 특히 거절을 당했을 때 귀중한 통찰력을 얻기 위해 다른 사람의 의견을 적극적으로 구하는 것이 포함됩니다. 피드백을 수용함으로써 개선이 필요한 부분을 파악하고, 기술을 연마하며, 궁극적으로 좌절을 성장의 기회로 바꿀 수 있습니다.</p><h2 id="전문성-유지"><a class="markdownIt-Anchor" href="#전문성-유지"></a> 전문성 유지</h2><p>전문성을 유지하는 것은 거절을 우아하게 처리하는 데 있어 핵심적인 요소입니다. 여기에는 부정적인 반응을 자제하고 침착하고 정중한 태도로 좌절에 대응하는 것이 포함됩니다. 전문적 기준을 유지함으로써 자신의 평판을 유지하고, 회복력을 키우며, 미래의 기회에 기여할 수 있는 긍정적인 인상을 남길 수 있습니다.</p><h2 id="목표에-대한-성찰"><a class="markdownIt-Anchor" href="#목표에-대한-성찰"></a> 목표에 대한 성찰</h2><p>목표를 되돌아보는 것은 거절을 극복하는 데 있어 중요한 단계입니다. 여기에는 좌절에 직면했을 때 목표를 재평가하고 재조정하기 위해 잠시 멈추는 것이 포함됩니다. 이러한 성찰적 과정은 자기 인식을 향상시킬 뿐만 아니라 전략적인 조정을 가능하게 하여 개인 및 직업적 성장의 진화하는 여정에서 목표가 탄력적으로 유지되고 적응할 수 있도록 해줍니다.</p><h2 id="성장-마인드-기르기"><a class="markdownIt-Anchor" href="#성장-마인드-기르기"></a> 성장 마인드 기르기</h2><p>성장 마인드를 키우는 것은 거절에 직면했을 때 회복력을 키우는 데 필수적입니다. 여기에는 도전이 학습과 발전의 기회라는 믿음을 키우는 것이 포함됩니다. 성장 마인드로 도전을 받아들임으로써 좌절을 학습 과정의 자연스러운 일부로 간주하여 더 강하게 회복하고 적응하며 개인 및 직업적 성공을 향한 여정에서 지속적으로 발전할 수 있습니다.</p><h2 id="지원-시스템과-연결하기"><a class="markdownIt-Anchor" href="#지원-시스템과-연결하기"></a> 지원 시스템과 연결하기</h2><p>지원 시스템과 연결하는 것은 거절을 극복하는 데 있어 중요한 전략입니다. 여기에는 격려와 조언, 가치 있는 관점을 제공할 수 있는 친구, 멘토, 동료에게 연락하는 것이 포함됩니다. 강력한 지원 네트워크를 구축함으로써 어려운 시기에 다른 사람들로부터 힘을 얻고 회복력을 키우며 개인 및 직업적 성장을 향한 여정을 더욱 원활하게 진행할 수 있습니다.</p><h2 id="자기-관리에-집중하기"><a class="markdownIt-Anchor" href="#자기-관리에-집중하기"></a> 자기 관리에 집중하기</h2><p>자기 관리에 집중하는 것은 거절에 대처하는 데 있어 가장 중요한 측면입니다. 여기에는 휴식과 원기 회복을 촉진하는 활동에 참여하여 정신적, 정서적 웰빙을 우선시하는 것이 포함됩니다. 좌절 속에서도 자신을 돌봄으로써 회복력을 유지하고, 관점을 되찾고, 새로운 균형 감각과 긍정성을 가지고 도전에 접근할 수 있습니다.</p><h2 id="새로운-목표-설정"><a class="markdownIt-Anchor" href="#새로운-목표-설정"></a> 새로운 목표 설정</h2><p>새로운 목표를 설정하는 것은 거절에 대한 능동적인 대응으로, 적응력과 앞으로의 추진력을 의미합니다. 여기에는 열망을 재평가하고, 목표를 구체화하며, 미래의 성공을 위한 과정을 계획하는 것이 포함됩니다. 새로운 목표를 향해 집중력과 에너지를 재분배함으로써 개인은 좌절을 성장과 회복력, 지속적인 개인 및 전문성 개발의 기회로 전환할 수 있습니다.</p><h2 id="작은-승리-축하하기"><a class="markdownIt-Anchor" href="#작은-승리-축하하기"></a> 작은 승리 축하하기</h2><p>작은 승리를 축하하는 것은 거절에 직면한 후 회복의 여정에서 중요한 요소입니다. 여기에는 그 과정에서 작은 성과라도 인정하고 감사하는 것이 포함됩니다. 이러한 점진적인 승리를 인정함으로써 사기를 높이고 동기를 유지하며 긍정적인 사고방식을 함양하여 지속적인 개인 및 직업적 성장을 위한 기반을 마련할 수 있습니다.</p><h2 id="끈기-유지"><a class="markdownIt-Anchor" href="#끈기-유지"></a> 끈기 유지</h2><p>끈기를 유지하는 것이 거절에 맞서 승리하는 열쇠입니다. 여기에는 좌절에도 불구하고 흔들리지 않는 결단력과 회복력을 유지하는 것이 포함됩니다. 확고한 사고방식을 수용함으로써 도전을 헤쳐나가고, 경험을 통해 배우고, 목표를 끈질기게 추구할 수 있습니다. 끈기는 개인을 궁극적인 성공의 길로 나아가게 하는 원동력이며, 좌절을 지속적인 성취를 위한 디딤돌로 바꿔줍니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>거절은 업무적 영역과 개인적 영역을 모두 아우르는 우리의 여정에서 피할 수 없는 측면입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 그 어떤 것이든, 문제는 거절을 피할 수 없는 상황에서 어떻게 대응하느냐에 달려 있습니다. 이 글은 거절에 직면했을 때 전문성과 회복력을 키우고 좌절을 미래의 성공으로 가는 디딤돌로 삼을 수 있는 실행 가능한 단계를 제시합니다. 거절의 복잡한 지형을 헤쳐 나가면서 감정을 수용하고, 피드백을 구하고, 전문성을 유지하고, 성장 마인드를 키우는 방법을 배워보세요. 거절은 끝이 아니라 지속적인 성장과 성취를 향한 변화의 단계임을 기억하세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/21/etc-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[React vs Vue.js] Vue.js가 React보다 좋을까?</title>
      <link>http://hgko1207.github.io/2023/12/20/web-2/</link>
      <guid>http://hgko1207.github.io/2023/12/20/web-2/</guid>
      <pubDate>Wed, 20 Dec 2023 14:05:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;끊임없이 진화하는 웹 개발 환경에서
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-2.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>끊임없이 진화하는 웹 개발 환경에서 올바른 프런트엔드 프레임워크를 선택하는 것은 때로는 혼란스러울 수 있습니다. 특히 선택할 수 있는 js 프레임워크가 많은 경우에는 더욱 그렇습니다.</p><p>가장 유명한 js 프론트엔드 프레임워크는 다음과 같습니다.</p><h3 id="1-react"><a class="markdownIt-Anchor" href="#1-react"></a> 1. React</h3><p><img src="/images/header/web-2_1.png" alt="" /></p><ul><li>Facebook에서 개발하고 유지 관리합니다.</li><li>Virtual DOM, 컴포넌트 기반 아키텍처 및 성능으로 유명합니다.</li><li>광범위하게 채택되어 방대한 커뮤니티와 생태계를 보유하고 있습니다.</li><li>많은 기업이 대규모 애플리케이션을 위해 선택했습니다.</li></ul><h3 id="2-angular"><a class="markdownIt-Anchor" href="#2-angular"></a> 2. Angular</h3><p><img src="/images/header/web-2_2.png" alt="" /></p><ul><li>Google에서 개발하고 유지관리합니다.</li><li>양방향 데이터 바인딩, 종속성 주입 및 대규모 애플리케이션 기능으로 잘 알려진 포괄적인 프런트엔드 프레임워크입니다.</li><li>동적 웹 애플리케이션 구축을 위한 완벽한 솔루션을 제공합니다.</li></ul><h3 id="3-vuejs"><a class="markdownIt-Anchor" href="#3-vuejs"></a> 3. Vue.js</h3><p><img src="/images/header/web-2_3.png" alt="" /></p><ul><li>커뮤니티에서 유지 관리하는 오픈 소스 프레임워크입니다.</li><li>단순성, 통합 용이성, 완만한 학습 곡선으로 잘 알려져 있습니다.</li><li>React 및 Angular와 유사한 기능을 제공하지만 보다 접근하기 쉬운 방식으로 제공됩니다.</li><li>고성능(React 보다 빠름)</li><li>개발 속도가 빠릅니다.</li></ul><h3 id="4-svelte"><a class="markdownIt-Anchor" href="#4-svelte"></a> 4. Svelte</h3><p><img src="/images/header/web-2_4.png" alt="" /></p><ul><li>오픈 소스 프런트엔드 프레임워크입니다.</li><li>DOM을 직접 조작하는 매우 효율적인 명령형 코드로 컴포넌트를 컴파일하여 차별화됩니다.</li><li>간단한 구문을 제공하고 더 나은 성능을 목표로 합니다.</li></ul><h3 id="5-emberjs"><a class="markdownIt-Anchor" href="#5-emberjs"></a> 5. Ember.js</h3><p><img src="/images/header/web-2_5.png" alt="" /></p><ul><li>오픈 소스 프런트엔드 프레임워크입니다.</li><li>구성 원칙에 대한 규칙을 따르기 때문에 크고 복잡한 애플리케이션에 적합한 강력한 선택입니다.</li><li>강력한 템플릿 엔진과 데이터 레이어를 제공합니다.</li></ul><h3 id="6-backbonejs"><a class="markdownIt-Anchor" href="#6-backbonejs"></a> 6. Backbone.js</h3><p><img src="/images/header/web-2_6.png" alt="" /></p><ul><li>오픈 소스 JavaScript 프레임워크입니다.</li><li>Model, View, Collection, Router에 중점을 두고 웹 애플리케이션을 구축하는 데 필요한 최소한의 구조를 제공합니다.</li><li>다른 라이브러리와 함께 사용하여 더 복잡한 애플리케이션을 만드는 데 자주 사용됩니다.</li></ul><h3 id="7-meteor"><a class="markdownIt-Anchor" href="#7-meteor"></a> 7. Meteor</h3><p><img src="/images/header/web-2_7.png" alt="" /></p><ul><li>웹 및 모바일 애플리케이션 구축을 위한 오픈 소스 플랫폼입니다.</li><li>React, Angular, Vue.js와 같은 프론트엔드 프레임워크와 통합되어 풀스택 솔루션을 제공합니다.</li><li>실시간 데이터 업데이트와 개발 용이성으로 잘 알려져 있습니다.</li></ul><p>자바스크립트 프레임워크 영역에서 가장 눈에 띄는 두 경쟁자는 React와 Vue.js입니다. 각각 고유한 장점과 단점이 있으며 이를 뒷받침하는 대규모 커뮤니티가 있습니다.</p><p>이 글에서는 개발자의 관점으로 React와 Vue.js 차이점, 인기, 성능을 분석하고 비교할 것입니다.</p><h2 id="react와-vuejs의-차이점"><a class="markdownIt-Anchor" href="#react와-vuejs의-차이점"></a> React와 Vue.js의 차이점</h2><p>React와 Vue.js는 모두 널리 사용되는 자바스크립트 프레임워크이지만 구문, 학습 곡선, 생태계, 상태 관리 등여러 측면에서 차이가 있습니다. 현명한 선택을 위해서는 이러한 차이점을 이해하는 것이 필수적입니다.</p><h2 id="react-vs-vuejs-인기-콘테스트"><a class="markdownIt-Anchor" href="#react-vs-vuejs-인기-콘테스트"></a> React vs Vue.js: 인기 콘테스트</h2><p>인기도는 기술 채택에 중요한 역할을 하는 경우가 많습니다. 현재 트렌드와 사용 통계를 살펴보고 이 경쟁 구도에서 React와 Vue.js가 어떻게 경쟁하고 있는지에 대한 인사이트를 제공하겠습니다.</p><h3 id="vuejs"><a class="markdownIt-Anchor" href="#vuejs"></a> Vue.js</h3><ul><li>GitHub Stars: 204k</li><li>GitHub Commits: 3.2k</li><li>GitHub 기여자: 404</li><li>스택 오버플로에 대한 질문: 91.9k</li><li>Live Websites: 2071k</li></ul><h3 id="react"><a class="markdownIt-Anchor" href="#react"></a> React</h3><ul><li>GitHub Stars: 208k</li><li>GitHub Commits: 14.8k</li><li>GitHub 기여자: 1.5k</li><li>스택 오버플로에 대한 질문: 376.4k</li><li>Live Websites: 2609k</li></ul><p>여기서 React가 Vue.js보다 더 인기가 있다는 것을 분명히 알 수 있지만, 그렇다고 해서 Vue.js를 사용하는 사람이 전혀 없다는 것을 의미하지는 않습니다. Vue.js는 React보다는 조금 적지만 자체적으로 많은 팔로워와 프로젝트에서 채택되고 있습니다.</p><h2 id="사용-방법-비교"><a class="markdownIt-Anchor" href="#사용-방법-비교"></a> 사용 방법 비교</h2><h3 id="vuejs-디렉티브directive를-사용한-html-템플릿"><a class="markdownIt-Anchor" href="#vuejs-디렉티브directive를-사용한-html-템플릿"></a> Vue.js: 디렉티브(Directive)를 사용한 HTML 템플릿</h3><p>Vue.js를 사용하면 개발자가 템플릿에서 HTML 구문을 사용할 수 있으므로 HTML에 익숙한 사람들이 쉽게 시작할 수 있습니다. 또한 Vue.js는 HTML 요소의 렌더링 및 동작을 조건부로 제어하기 위해 <code>v-if</code>, <code>v-else</code>, <code>v-show</code> 등과 같은 강력한 디렉티브를 제공합니다. 이 접근 방식은 프로세스를 단순화하며 특히 초보자에게 친숙합니다.</p><p>다음은 Vue.js 템플릿에서 <code>v-if</code> 사용법을 보여주는 간단한 예입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello, Vue.js!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p v-if="showMessage"&gt;This message will be shown if showMessage is true.&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      showMessage: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="react-javascript-통합이-포함된-html과-유사한-구조를-위한-jsx"><a class="markdownIt-Anchor" href="#react-javascript-통합이-포함된-html과-유사한-구조를-위한-jsx"></a> React: JavaScript 통합이 포함된 HTML과 유사한 구조를 위한 JSX</h3><p>React는 개발자가 JavaScript 파일 내에서 HTML과 유사한 코드를 작성할 수 있게 해주는 구문 확장인 JSX를 활용합니다. 처음에는 기존 HTML과 다르게 보일 수 있지만 JSX는 HTML 구조와 매우 유사하며 JavaScript 표현식 및 로직과의 완벽한 통합이라는 이점을 제공합니다.</p><p>다음은 JSX와 함께 React를 사용하는 유사한 예입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showMessage, setShowMessage] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, React!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;showMessage &amp;&amp; &lt;p&gt;This message will be shown if showMessage is true.&lt;/</span>p&gt;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>이 예제에서 단락(<code>&lt;p&gt;</code>) 요소는 <code>showMessage</code> 상태가 <code>true</code>인 경우에만 렌더링됩니다. JSX는 JavaScript 표현식(예: <code>{showMessage &amp;&amp; ...}</code>)을 통합하여 조건부로 렌더링을 제어합니다.</p><h2 id="react와-vuejs-성능-비교"><a class="markdownIt-Anchor" href="#react와-vuejs-성능-비교"></a> React와 Vue.js 성능 비교</h2><p>성능은 프런트엔드 프레임워크를 선택할 때 중요한 요소입니다. 렌더링 속도, 번들 크기, 최적화 기술 등 두 프레임워크의 성능 측면을 자세히 살펴보겠습니다.</p><h3 id="렌더링-속도"><a class="markdownIt-Anchor" href="#렌더링-속도"></a> 렌더링 속도</h3><ol><li><strong>Vue.js</strong><br />Vue.js는 무언가 변경될 때 화면을 빠르게 업데이트하는 데 능숙합니다. 마치 필요한 것만 업데이트하는 가장 효율적인 방법을 알아내는 스마트 시스템을 갖춘 것과 같습니다.<br /><br/></li><li><strong>React</strong><br />React는 또한 화면을 효율적으로 업데이트합니다. 가장 좋은 방법으로 업데이트하는 방법을 계획하는 스마트 비서와 같아서 모든 일이 원활하게 진행됩니다.</li></ol><h3 id="번들-크기"><a class="markdownIt-Anchor" href="#번들-크기"></a> 번들 크기</h3><ol><li><strong>Vue.js</strong><br />Vue.js는 특히 &quot;<a href="https://vuejs.org/guide/components/slots.html#scoped-slots" target="_blank" rel="noopener">범위가 지정된 슬롯(Scoped Slots)</a>&quot;이라는 기능을 사용하여 파일 크기를 작게 유지하는 데 도움이 됩니다. 공간을 덜 차지하는 방식으로 물건을 정리하는 것과 같습니다.<br /><br/></li><li><strong>React</strong><br />React는 필요한 것을 골라서 사용할 수 있는 툴킷과 같습니다. 하지만 어떻게 사용하느냐에 따라 추가 도구를 추가할 수 있기 때문에 툴킷이 조금 더 커질 수 있습니다.</li></ol><h3 id="최적화-기술"><a class="markdownIt-Anchor" href="#최적화-기술"></a> 최적화 기술</h3><ol><li><strong>Vue.js</strong><br />Vue.js에는 캐싱 및 효율적인 데이터 처리와 같이 작업 속도를 높일 수 있는 기본 제공 방법이 있습니다. 단축키를 사용하여 작업을 빠르게 완료하는 것과 같습니다.<br /><br/></li><li><strong>React</strong><br />React에는 암기 및 지연 로딩과 같이 더 빠르게 작동하도록 하는 트릭도 있습니다. 게임에서 필살기를 사용하여 진행 속도를 높이는 것과 같습니다.</li></ol><p>간단히 말해서 Vue.js와 React는 모두 작업을 빠르고 효율적으로 수행하는 데 도움이 되는 스마트 비서와 같습니다. Vue.js는 번들 크기가 더 작고 조금 더 빠르며, React는 더 유연한 툴킷이며 대규모 프로젝트에 본질적으로 사용되는 확장성이 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>프리랜서이거나 소규모 스타트업을 운영하고 있다면 개발 속도가 빠르고, 성능이 뛰어나며, 상용구 코드가 훨씬 적은 Vue.js가 최선의 선택입니다.</p><p>대규모 프로젝트를 수행하는 대기업이라면 상용구 코드가 더 많지만 코드베이스가 커짐에 따라 프로젝트를 더 쉽게 처리할 수 있는 JSX를 사용하는 것이 좋습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/20/web-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>열정 없이 돈만을 위해 프로그래밍에 입문하면 안되는 5가지 이유</title>
      <link>http://hgko1207.github.io/2023/12/19/info-7/</link>
      <guid>http://hgko1207.github.io/2023/12/19/info-7/</guid>
      <pubDate>Tue, 19 Dec 2023 12:58:52 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;바보라도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있습니다. 훌륭한 프로그래머는 인간이 이해할 수 있는 코드를 작성합니다. — 마틴 파울러&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/header
        
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>바보라도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있습니다. 훌륭한 프로그래머는 인간이 이해할 수 있는 코드를 작성합니다. — 마틴 파울러</p></blockquote><p><img src="/images/header/info-7.png" alt="" /></p><p>프로그래밍은 열정과 헌신이 필요한 분야입니다. 높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍을 할 충분한 이유가 될 수는 없습니다. 열정 없이 돈만 보고 프로그래밍에 뛰어들면 안 되는 5가지 이유는 다음과 같습니다.</p><ol><li>프로그래밍은 끊임없는 학습과 개선이 필요한 도전적인 분야입니다. 열정이 없으면 동기를 유지하고 최신 기술과 트렌드를 따라가는 것이 어려울 수 있습니다.<br /><br/></li><li>프로그래밍은 문제 해결 능력과 고정 관념에서 벗어나는 능력을 요구하는 창의적인 분야입니다. 열정이 없으면 복잡한 문제에 대한 혁신적인 솔루션을 찾기가 어려울 수 있습니다.<br /><br/></li><li>프로그래밍은 팀워크와 의사소통 능력이 필요한 협업 분야입니다. 열정이 없으면 다른 사람들과 함께 일하고 팀에 기여하기가 어려울 수 있습니다.<br /><br/></li><li>프로그래밍은 세심한 주의와 높은 수준의 정확성이 요구되는 분야입니다. 열정이 없으면 집중력을 유지하고 실수를 피하는 것이 어려울 수 있습니다.<br /><br/></li><li>프로그래밍은 스트레스가 많고 까다로울 수 있는 분야입니다. 열정이 없으면 압박감을 견디고 일과 삶의 균형을 유지하기 어려울 수 있습니다.</li></ol><p>열정이 없으면 기능적일 뿐만 아니라 이해하고 유지 관리하기 쉬운 코드를 작성하기 어려울 수 있으며, 반면에 열정이 부족한 프로그래머는 경력이 단절될 수 있습니다. 최신 기술과 트렌드를 따라잡는 데 어려움을 겪을 수 있으며, 이로 인해 경력 성장과 기회가 제한될 수 있습니다. 또한 다른 사람들과 협업하는 데 어려움을 겪을 수 있으며, 이로 인해 팀에 기여하는 능력이 저하될 수 있습니다. 또한 열정이 부족한 프로그래머는 업무의 스트레스와 요구를 감당하기 어려워 번아웃과 일과 삶의 균형이 깨질 수 있습니다.</p><p>스티브 잡스는 이렇게 말했습니다.</p><p><img src="/images/header/info-7_1.png" alt="" /></p><blockquote><p>일이 인생의 많은 부분을 차지하게 될 것이며, 진정으로 만족할 수 있는 유일한 방법은 자신이 훌륭한 일이라고 믿는 일을 하는 것입니다. 그리고 훌륭한 일을 할 수 있는 유일한 방법은 자신이 하는 일을 사랑하는 것입니다.</p></blockquote><p>이 인용문은 프로그래밍에서 열정의 중요성과 그것이 어떻게 만족스럽고 성공적인 커리어로 이어질 수 있는지를 강조합니다.</p><p>결론적으로, 열정은 프로그래밍에서 중요한 요소이며 프로그래머의 경력에 큰 차이를 만들 수 있습니다. 열정적인 프로그래머는 항상 자신의 기술을 배우고 향상시키기 위해 노력하며, 이는 끊임없이 진화하는 분야에서 필수적인 요소입니다. 또한 복잡한 문제에 대한 혁신적인 솔루션을 개발하는 데 필요한 창의적이고 틀에 박힌 사고방식을 벗어날 수 있는 능력을 갖추고 있습니다. 따라서 사람들의 삶을 변화시킬 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다.</p><p>높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍에 도전할 충분한 이유가 될 수는 없습니다. 프로그래밍에는 창의력, 문제 해결 능력, 팀워크, 세부 사항에 대한 주의력, 스트레스 처리 능력이 필요합니다.</p><p>유명한 프로그래머 도널드 어빈 크누스(Donald Ervin Knuth)는 이렇게 말했습니다.</p><blockquote><p>프로그래밍은 컴퓨터가 무엇을 하길 원하는지 다른 사람에게 알려주는 기술이다.</p></blockquote><p>따라서 사람들의 삶에 변화를 가져올 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/19/info-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MVC, MVVM, MVP 이해 및 비교</title>
      <link>http://hgko1207.github.io/2023/12/18/web-1/</link>
      <guid>http://hgko1207.github.io/2023/12/18/web-1/</guid>
      <pubDate>Mon, 18 Dec 2023 13:53:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;소프트웨어 개발 세계에는 개발자가 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-1.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>소프트웨어 개발 세계에는 개발자가 모듈성, 유지 관리성 및 확장성을 촉진하는 방식으로 코드를 설계하고 구성하는 데 도움이 되는 다양한 아키텍처 패턴이 있습니다. 이러한 인기 있는 세 가지 패턴은 <strong>MVC</strong>(Model-View-Controller), <strong>MVVM</strong>(Model-View-ViewModel) 및 <strong>MVP</strong>(Model-View-Presenter)입니다.</p><p>이 글에서는 이러한 아키텍처 패턴의 세부 사항을 자세히 살펴보고 주요 원칙, 장점 및 사용 사례를 알아보겠습니다.</p><h2 id="model-view-controllermvc"><a class="markdownIt-Anchor" href="#model-view-controllermvc"></a> Model-View-Controller(MVC)</h2><p>MVC는 소프트웨어 개발에서 가장 오래되고 가장 널리 사용되는 아키텍처 패턴 중 하나입니다. 다음 구성 요소로 구성됩니다.</p><ul><li><strong>Model:</strong> 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 데이터 조작, 저장 및 검색을 관리합니다.</li><li><strong>View:</strong> 사용자에게 데이터를 표시하는 역할을 담당합니다. Model의 정보를 표시하고 사용자 입력을 처리합니다.</li><li><strong>Controller:</strong> Model과 View 사이의 중개자 역할을 합니다. View 로부터 사용자 입력을 받아 이를 처리하고, Model을 업데이트하고 그에 따라 View를 새로 고칩니다.</li></ul><h3 id="mvc의-장점"><a class="markdownIt-Anchor" href="#mvc의-장점"></a> MVC의 장점</h3><ul><li>관심사를 명확하게 분리하여 코드를 더욱 유지 관리하고 테스트할 수 있게 만듭니다.</li><li>서로 다른 View가 동일한 Model 과 Controller를 사용할 수 있으므로 코드 재사용성이 향상됩니다.</li><li>병렬 개발을 지원하여 UI 디자이너와 개발자가 독립적으로 작업할 수 있습니다.</li></ul><h3 id="사용-사례"><a class="markdownIt-Anchor" href="#사용-사례"></a> 사용 사례</h3><p>MVC는 Spring Framework, Ruby on Rails, Django 및 ASP.NET과 같은 웹 개발 프레임워크에서 일반적으로 사용됩니다.</p><h2 id="model-view-viewmodelmvvm"><a class="markdownIt-Anchor" href="#model-view-viewmodelmvvm"></a> Model-View-ViewModel(MVVM)</h2><p>MVVM은 특히 복잡하고 데이터가 풍부한 애플리케이션의 맥락에서 MVC의 일부 제한 사항에 대한 대응으로 등장한 디자인 패턴입니다. MVVM은 다음 구성 요소로 구성됩니다.</p><ul><li><strong>Model:</strong> MVC 모델과 유사하게 애플리케이션의 데이터와 비즈니스 로직를 나타냅니다.</li><li><strong>View:</strong> 사용자 인터페이스를 나타내지만 MVC보다 더 수동적입니다. ViewModel에 의해 노출된 속성 및 명령에 바인딩됩니다.</li><li><strong>ViewModel:</strong> View의 상태와 동작을 추상화하는 역할을 합니다. Model과 View 간의 통신을 중재하고 View가 바인딩하는 데이터와 명령을 노출합니다.</li></ul><h3 id="mvvm의-장점"><a class="markdownIt-Anchor" href="#mvvm의-장점"></a> MVVM의 장점</h3><ul><li>View 와 Model 간의 결합을 줄여 MVC보다 더 나은 관심사 분리를 촉진합니다.</li><li>데이터 바인딩을 촉진하여 기본 데이터가 변경될 때 UI 업데이트를 단순화합니다.</li><li>ViewModel을 UI와 독립적으로 테스트할 수 있으므로 테스트 가능성이 향상됩니다.</li></ul><h3 id="사용-사례-2"><a class="markdownIt-Anchor" href="#사용-사례-2"></a> 사용 사례</h3><p>MVVM은 클라이언트 측 애플리케이션, 특히 Angular, React, Vue.js 및 Xamarin과 같은 프레임워크에서 널리 사용됩니다.</p><h2 id="model-view-presentermvp"><a class="markdownIt-Anchor" href="#model-view-presentermvp"></a> Model-View-Presenter(MVP)</h2><p>MVP는 관심사 분리에 초점을 맞추지만 MVC 및 MVVM과는 다른 방식으로 수행되는 또 다른 아키텍처 패턴입니다. 다음 구성 요소로 구성됩니다.</p><ul><li><strong>Model:</strong> MVC 및 MVVM과 유사하며 애플리케이션의 데이터와 비지니스 로직을 캡슐화합니다.</li><li><strong>View:</strong> 사용자 인터페이스를 나타내지만 MVVM의 View에 비해 더 활동적입니다. View는 사용자 입력을 Presenter에게 직접 전달합니다.</li><li><strong>Presenter:</strong> MVC의 Controller와 유사하게 Model과 View 사이의 중개자 역할을 합니다. 그러나 MVP에서는 View가 일반적으로 더 수동적입니다.</li></ul><h3 id="mvp의-장점"><a class="markdownIt-Anchor" href="#mvp의-장점"></a> MVP의 장점</h3><ul><li>Presenter는 UI 없이 쉽게 단위 테스트할 수 있으므로 높은 수준의 테스트 가능성을 제공합니다.</li><li>관심사를 명확하게 분리하고 UI와 애플리케이션 로직을 강력하게 구분하도록 권장합니다.</li><li>개발자가 Presenter 및 Model에서 작업하는 동안 UI 디자이너가 View에서 작업할 수 있으므로 병렬 개발이 용이합니다.</li></ul><h3 id="사용-사례-3"><a class="markdownIt-Anchor" href="#사용-사례-3"></a> 사용 사례</h3><p>MVP는 특히 WinForms, WPF 및 GWT와 같은 기술을 사용하여 데스크톱 애플리케이션 개발에 일반적으로 사용됩니다.</p><h2 id="mvc-mvvm-mvp-비교"><a class="markdownIt-Anchor" href="#mvc-mvvm-mvp-비교"></a> MVC, MVVM, MVP 비교</h2><ul><li><strong>데이터 바인딩:</strong> MVVM은 데이터 바인딩에 탁월하므로 UI와 기본 데이터의 동기화를 더 쉽게 유지할 수 있습니다. MVC와 MVP는 수동 동기화가 필요합니다.</li><li><strong>테스트 가능성:</strong> MVP와 MVVM은 애플리케이션의 로직을 별도로 테스트할 수 있기 때문에 MVC에 비해 더 나은 테스트 가능성을 제공합니다.</li><li><strong>복잡성:</strong> MVC는 더 간단하고 소규모에서 중간 정도 복잡한 애플리케이션에 더 적합할 수 있는 반면, MVVM과 MVP는 더 크고 복잡한 프로젝트에서 빛을 발합니다.</li><li><strong>학습 곡선:</strong> MVVM 및 MVP는 추가 구성 요소 및 개념으로 인해 학습 곡선이 더 가파르게 느껴질 수 있습니다.</li><li><strong>플랫폼:</strong> 이러한 패턴 간의 선택은 플랫폼에 따라 달라질 수도 있습니다. MVC는 웹 개발과 관련되는 경우가 많고, MVVM은 클라이언트 측 애플리케이션에 널리 사용되고 MVP는 데스크톱 애플리케이션에 일반적으로 사용됩니다.</li></ul><blockquote><p>테스트 가능성(Testability)은 과학과 과학적 방법의 주요 측면입니다. 테스트 가능성에는 반증 가능성 또는 실현 불가능성 두 가지 구성 요소가 있습니다. 이는 가설에 대한 반례가 논리적으로 가능함을 의미합니다. <a href="https://en.wikipedia.org/wiki/Testability" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>결론적으로 MVC, MVVM, MVP 중에서 선택하는 것은 특정 프로젝트 요구 사항, 팀 전문 지식, 개발 대상 플랫폼에 따라 달라집니다. 각 패턴은 강력하고 유지보수가 가능한 소프트웨어를 구축하는 데 필요한 관심사 분리(Separation of concerns), 모듈성(Modularity) 및 테스트 가능성(Testability)을 달성하기 위한 다양한 접근 방식을 제공합니다. 각 패턴의 원리와 장점을 이해하면 다음 소프트웨어 애플리케이션을 설계할 때 정보에 입각한 결정을 내리는 데 도움이 될 수 있습니다.</p><blockquote><p>컴퓨터 과학에서 관심사 분리(Separation of concerns)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙으로, 각 부문은 개개의 관심사를 해결한다. 관심사란 컴퓨터 프로그램 코드에 영향을 미치는 정보의 집합이다. <a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC" target="_blank" rel="noopener">위키백과</a></p></blockquote>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/18/web-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[ChatGPT] 코딩에서 활용하기 위한 5가지 팁</title>
      <link>http://hgko1207.github.io/2023/12/16/chatgpt-3/</link>
      <guid>http://hgko1207.github.io/2023/12/16/chatgpt-3/</guid>
      <pubDate>Sat, 16 Dec 2023 05:49:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/chatgpt-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 매우 빠르게 개발자들의 필수 도구가 되었습니다. 우리 모두는 이 도구가 루프 생성이나 if 조건 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/chatgpt-3.png" alt="" /></p><p><strong>ChatGPT</strong>는 매우 빠르게 개발자들의 필수 도구가 되었습니다. 우리 모두는 이 도구가 루프 생성이나 if 조건 등을 사용하는 작은 알고리즘 등 코딩의 사소한 작업을 잘 처리한다는 것을 알고 있습니다.</p><p>또한 최근 또는 새로운 주요 변경 사항이 있는 라이브러리에 대한 코드를 생성하거나 적절하게 설명되지 않은 복잡한 대규모 작업의 경우 약점이 있다는 것을 알 수 있습니다.</p><h2 id="팁"><a class="markdownIt-Anchor" href="#팁"></a> 팁</h2><p>코딩에서 ChatGPT를 더 잘 사용하기 위한 5가지 팁에 대해 알아보겠습니다.</p><ol><li><strong>질문을 작은 작업으로 나누고 한 번에 한 단계씩 점진적으로 추가하여 코드를 생성하도록 요청하세요.</strong> 이 접근 방식은 복잡한 코드 블록과 관련하여 더 나은 코딩 결과를 제공하고 오류를 줄이는 것으로 나타났습니다. 외부 라이브러리 등이 포함된 복잡한 작업에 특히 유용합니다.<br /><br/></li><li><strong>가능한 한 구체적인 용어와 전문 용어를 사용하여 명확하고 상세하게 프롬프트를 작성하세요.</strong> 지식이 풍부한 웹 개발자와 대화하는 것처럼 ChatGPT와 대화하고 아이디어를 전달하는 데 사용할 모든 용어를 사용하세요. 프롬프트를 단순화하기 위해 기술 용어를 사용하는 것을 주저하지 마십시오.<br /><br/></li><li><strong>외부 라이브러리의 경우 ChatGPT에 의해 생성되는 오래된 구문에 주의하세요.</strong> ChatGPT에 의해 생성된 외부 라이브러리 사용 코드에 이상한 오류가 표시되면 항상 이를 의심해 보세요. 이 경우 해당 라이브러리의 설명서를 확인하는 것이 좋습니다.<br /><br/></li><li><strong>대규모 작업을 구현하기 위한 계획을 찾을 때는 ChatGPT에 코딩 문제와 프로젝트에 대한 개요를 제공하고 여러 가지 방법과 제안을 요청하는 것이 좋습니다.</strong> 이렇게 하면 머릿속에 떠오르지 않았던 아이디어를 떠올릴 수 있습니다.<br /><br/></li><li><strong>생성된 코드에 대한 설명을 ChatGPT에 묻는 것을 게을리하지 마십시오.</strong> Chatgpt는 생성된 코드를 매우 잘 설명 할 수 있으며 코드가 무엇을하고 있는지 명확하게 알려줌으로써 생성된 코드의 버그를 더 빨리 해결하는 데 도움이 됩니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>ChatGPT가 개발자를 그렇게 빨리 대체할 수 있다고 믿지 않습니다. 그러나 프로그래밍의 낮은 수준 작업을 자동화하여 개발자가 단조롭고 지루한 부분을 맡길 수 있습니다. ChatGPT를 잘 활용하면 개발자의 업무 효율을 최소 2배 향상시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/16/chatgpt-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>생성형 AI(Generative AI)의 미래</title>
      <link>http://hgko1207.github.io/2023/12/15/ai-1/</link>
      <guid>http://hgko1207.github.io/2023/12/15/ai-1/</guid>
      <pubDate>Fri, 15 Dec 2023 01:41:28 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/ai-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;인공지능의 세계는 변혁의 시대를 맞이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/ai-1.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>인공지능의 세계는 변혁의 시대를 맞이하고 있으며, 이 혁명의 중심에는 생성형 AI(Generative AI)가 있습니다. 이 고급 모델은 콘텐츠를 제작하고 복잡한 문제를 해결할 수 있는 힘을 가지고 있으며, 우리가 기술과 상호작용하는 방식과 그 가능성을 재정의하고 있습니다.</p><p>이 글에서는 생성형 AI의 현실감과 창의성 향상부터 윤리적, 환경적 영향에 이르기까지 생성형 AI의 미래에 대해 살펴볼 것입니다. 앞으로 펼쳐질 흥미진진한 여정에 대해 자세히 알아봅시다.</p><blockquote><p>생성형 인공지능(generative artificial intelligence) 또는 생성형 AI(generative AI)는 프롬프트에 대응하여 텍스트, 이미지, 기타 미디어를 생성할 수 있는 일종의 인공지능(AI) 시스템이다. 생성형 AI는 입력 트레이닝 데이터의 패턴과 구조를 학습한 다음 유사 특징이 있는 새로운 데이터를 만들어낸다. <a href="https://ko.wikipedia.org/wiki/%EC%83%9D%EC%84%B1%ED%98%95_%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="현실감과-창의성-향상"><a class="markdownIt-Anchor" href="#현실감과-창의성-향상"></a> 현실감과 창의성 향상</h2><p>생성형 AI는 많은 발전을 이루었지만 아직 시작에 불과합니다. 미래의 모델은 사실주의와 창의성의 경계를 넓혀 사실상 인간의 창조물과 구별할 수 없는 콘텐츠를 제작할 것입니다. 실제과 같은 텍스트, 이미지, 음악, 심지어 동영상을 생성하는 이러한 모델은 사람과 AI가 생성한 콘텐츠 사이의 경계를 계속해서 허물어뜨릴 것입니다.</p><h2 id="다중-모드-기능"><a class="markdownIt-Anchor" href="#다중-모드-기능"></a> 다중 모드 기능</h2><p>텍스트, 이미지, 오디오 등 다양한 데이터 유형을 동시에 원활하게 작업할 수 있는 AI 모델을 상상해 보세요. 이러한 다중 모드 기능은 이전에는 불가능하다고 여겨졌던 방식으로 내러티브에 생동감을 불어넣는 새로운 형태의 몰입형 스토리텔링을 가능하게 할 것입니다.</p><blockquote><p>이야기 또는 '내러티브’란 어떤 사물이나 사실, 현상에 대하여 일정한 줄거리를 가지고 하는 말이나 글을 말한다. 문학에서 이야기는 배경, 인물, 구성, 이야기를 이루는 분위기인 톤으로 이루어진다. <a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%95%BC%EA%B8%B0" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="대규모-개인화"><a class="markdownIt-Anchor" href="#대규모-개인화"></a> 대규모 개인화</h2><p>생성형 AI의 가장 유망한 측면 중 하나는 고도로 개인화된 경험을 대규모로 제공할 수 있는 잠재력입니다. 개별 학습 스타일에 맞춘 교육부터 개인 취향에 맞는 제품 추천에 이르기까지, 생성형 AI는 각 사용자의 고유한 요구 사항을 충족할 수 있습니다.</p><h2 id="산업별-솔루션"><a class="markdownIt-Anchor" href="#산업별-솔루션"></a> 산업별 솔루션</h2><p>맞춤형 생성 AI 모델은 의료, 금융, 교육, 제조 등 특정 산업을 위해 개발될 것입니다. 이러한 모델은 산업별 과제를 해결하여 전문가가 작업하고 문제를 해결하는 방식을 혁신을 가져올 것입니다.</p><h2 id="인간과-기계의-협업-강화"><a class="markdownIt-Anchor" href="#인간과-기계의-협업-강화"></a> 인간과 기계의 협업 강화</h2><p>생성형 AI는 인간을 대체하는 것이 아니라 오히려 인간의 능력을 보완할 것입니다. 인간과 AI 간의 효과적인 협업은 다양한 직업에서 표준이 되어 업무의 효율성을 높이고 새로운 가능성의 문을 열 것입니다.</p><h2 id="콘텐츠-조정content-moderation-및-검증"><a class="markdownIt-Anchor" href="#콘텐츠-조정content-moderation-및-검증"></a> 콘텐츠 조정(Content Moderation) 및 검증</h2><p>디지털 정보 시대에는 허위 정보와의 전쟁과 콘텐츠 무결성 유지가 매우 중요합니다. 생성형 AI는 콘텐츠 조정 및 사실 확인을 자동화하여 정확하고 신뢰할 수 있는 정보만 대중에게 전달되도록 하는 데 중요한 역할을 할 것입니다.</p><blockquote><p>사용자에게 댓글을 게시하도록 요청하는 인터넷 웹사이트에서 콘텐츠 조정은 유용하거나 유익한 게시물과는 대조적으로 관련성이 없거나 외설적이거나 불법적이거나 유해하거나 공격적인 게시물을 감지하는 프로세스이며, 종종 반대 관점을 검열하거나 억제합니다. <a href="https://en.wikipedia.org/wiki/Content_moderation" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="자연어-인터페이스"><a class="markdownIt-Anchor" href="#자연어-인터페이스"></a> 자연어 인터페이스</h2><p>생성형 AI로 구동되는 고급 챗봇과 가상 비서는 보다 자연스럽고 인간과 유사한 대화 상호 작용을 제공할 것입니다. 사용자 경험과 고객 지원이 개선되면서 우리가 기술과 상호 작용하는 방식을 재정의할 것입니다.</p><h2 id="예술과-디자인의-혁신"><a class="markdownIt-Anchor" href="#예술과-디자인의-혁신"></a> 예술과 디자인의 혁신</h2><p>생성형 AI가 예술, 디자인, 건축의 경계를 허물면서 창조 산업에 혁명이 일어날 것입니다. 그리고 새로운 형태의 표현을 가능하게 하여 혁신과 창의성을 촉진할 것입니다.</p><h2 id="음악-및-엔터테인먼트"><a class="markdownIt-Anchor" href="#음악-및-엔터테인먼트"></a> 음악 및 엔터테인먼트</h2><p>생성형 AI로 생성된 음악, 영화 및 기타 형태의 엔터테인먼트가 더욱 보편화될 것입니다. 이는 완전히 새로운 장르와 경험의 출현으로 이어져 엔터테인먼트 세계에서 가능한 일의 지평을 넓힐 것입니다.</p><h2 id="지속적인-학습과-자기계발"><a class="markdownIt-Anchor" href="#지속적인-학습과-자기계발"></a> 지속적인 학습과 자기계발</h2><p>미래의 생성형 AI 모델은 사람의 개입 없이도 새로운 데이터와 진화하는 트렌드에 적응하면서 지속적으로 학습할 수 있게 될 것입니다. 이를 통해 빠르게 변화하는 세계에서 관련성과 최신성을 유지할 수 있습니다.</p><h2 id="책임감-있는-ai-개발"><a class="markdownIt-Anchor" href="#책임감-있는-ai-개발"></a> 책임감 있는 AI 개발</h2><p>생성형 AI가 널리 보급됨에 따라 윤리적이고 책임감 있는 AI 개발에 대한 강조가 커질 것입니다. 회사와 연구자들은 AI가 사회 전체에 혜택을 줄 수 있도록 편견, 공정성, 투명성과 같은 문제를 해결하기 위한 보호 장치를 구현할 것입니다.</p><h2 id="환경-고려-사항"><a class="markdownIt-Anchor" href="#환경-고려-사항"></a> 환경 고려 사항</h2><p>AI의 에너지 소비는 우려의 대상이었지만 미래의 생성형 AI 모델은 환경의 지속 가능성을 염두에 두고 설계될 가능성이 높습니다. 탄소 배출량과 에너지 소비를 최소화하는 것이 최우선 과제가 될 것입니다.</p><h2 id="법률-및-규제-프레임워크"><a class="markdownIt-Anchor" href="#법률-및-규제-프레임워크"></a> 법률 및 규제 프레임워크</h2><p>생성형 AI가 우리 삶에 더욱 필수적인 요소가 되면서 지적 재산권, 개인정보 보호, 안전 문제를 해결하기 위한 법률 및 규제 프레임워크가 발전할 것입니다. 이러한 프레임워크는 AI가 책임감 있고 윤리적으로 사용되도록 보장할 것입니다.</p><h2 id="과학적-발견"><a class="markdownIt-Anchor" href="#과학적-발견"></a> 과학적 발견</h2><p>생성형 AI는 과학 연구에서 중추적인 역할을 하며 신약 개발, 재료 과학, 기후 모델링과 같은 분야의 발견을 가속화할 것입니다. 이는 연구자들이 방대한 양의 데이터를 처리하고 이전에 숨겨져 있던 패턴을 찾는 데 도움이 될 것입니다.</p><h2 id="맞춤화-및-개인-비서"><a class="markdownIt-Anchor" href="#맞춤화-및-개인-비서"></a> 맞춤화 및 개인 비서</h2><p>AI 개인 비서는 개별 사용자에게 더욱 맞춤화되어 지원뿐만 아니라 동반자 역할과 정서적 지원까지 제공할 것입니다. 이러한 개인적인 접촉은 인간과 AI 관계를 강화할 것입니다.</p><h2 id="교육"><a class="markdownIt-Anchor" href="#교육"></a> 교육</h2><p>생성형 AI는 개인화된 학습 경험을 제공하고, 교육 콘텐츠를 제작하고, 적응형 학습을 제공함으로써 교육에 혁명을 일으킬 것입니다. 이를 통해 학습의 몰입도와 효과를 높여 학생들이 필요한 교육을 받을 수 있게 될 것입니다.</p><h2 id="ai가-만들어낸-혁신"><a class="markdownIt-Anchor" href="#ai가-만들어낸-혁신"></a> AI가 만들어낸 혁신</h2><p>생성형 AI는 기술과 비즈니스의 경계를 허무는 새로운 아이디어, 발명품, 프로토타입을 생성하는 혁신의 원동력이 될 것입니다. 이는 오늘날 우리가 상상조차 할 수 없는 발전을 가져올 것입니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>생성형 AI의 미래는 엄청난 가능성을 갖고 있습니다. 이는 우리의 삶을 개선하고, 경제 성장을 촉진하며, 시급한 글로벌 과제를 해결할 수 있는 잠재력을 가지고 있습니다. 그러나 이는 생성형 AI가 계속 발전함에 따라 신중하게 고려하고 해결해야 할 윤리적, 사회적 문제도 제기되고 있습니다. 앞으로의 여정은 무한한 가능성으로 가득 차 있으며, 빠르게 변화하는 세상에서 생성형 AI가 선한 역할을 할 수 있도록 하는 것은 우리에게 달려 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/15/ai-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[ChatGPT] 대화형 AI 활용</title>
      <link>http://hgko1207.github.io/2023/12/15/chatgpt-2/</link>
      <guid>http://hgko1207.github.io/2023/12/15/chatgpt-2/</guid>
      <pubDate>Thu, 14 Dec 2023 15:00:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;기술이 디지털 세계와 상호 작용하는 방식을 지속적으로 변화시키는 시대에 챗봇과 가상 비서는 인간과 컴퓨터의 상호 작용을 위한 강력한 도구로 등장했습니다. 이 분야의 최신 혁신 중에는 OpenAI가 개발한 최첨단 AI 모델인 ChatGPT가 있습니
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>기술이 디지털 세계와 상호 작용하는 방식을 지속적으로 변화시키는 시대에 챗봇과 가상 비서는 인간과 컴퓨터의 상호 작용을 위한 강력한 도구로 등장했습니다. 이 분야의 최신 혁신 중에는 OpenAI가 개발한 최첨단 AI 모델인 ChatGPT가 있습니다.</p><p>이 글에서는 ChatGPT의 매혹적인 세계와 그 기능, 대화형 AI의 미래에 미치는 영향을 살펴봅니다.</p><h2 id="챗봇과-가상-비서의-등장"><a class="markdownIt-Anchor" href="#챗봇과-가상-비서의-등장"></a> 챗봇과 가상 비서의 등장</h2><p>챗봇(Chatbot)과 가상 비서(Virtual Assistant)는 처음부터 많은 발전을 이루었습니다. 처음에는 간단한 작업과 반복적인 쿼리를 위해 설계되었으나 인간과 유사한 텍스트를 이해하고 생성할 수 있는 매우 정교한 대화 에이전트로 발전했습니다. 오늘날 챗봇은 고객 서비스, 의료, 전자상거래, 엔터테인먼트 등 다양한 산업 분야에서 사용되고 있습니다.</p><h2 id="chatgpt-소개"><a class="markdownIt-Anchor" href="#chatgpt-소개"></a> ChatGPT 소개</h2><p>ChatGPT는 대화형 AI 세계에 탁월한 추가 기능을 제공합니다. GPT(Generative Pre-trained Transformer) 제품군의 일부로 개발된 이 제품은 이전 제품의 놀라운 자연어 이해 및 생성 기능을 물려받았습니다. ChatGPT는 의미 있는 대화에 사용자를 참여시키도록 설계되었으므로 다음을 포함한 광범위한 애플리케이션에 이상적인 후보입니다.</p><ol><li><strong>고객 지원:</strong> ChatGPT는 고객 문의 처리, 문제 해결, 지원을 연중무휴 24시간 제공하여 고객 만족도를 높일 수 있습니다.<br /><br/></li><li><strong>콘텐츠 생성:</strong> 기사 초안 작성부터 마케팅 자료 작성까지 콘텐츠 생성을 지원하여 시간과 노력을 절약할 수 있습니다.<br /><br/></li><li><strong>언어 번역:</strong> ChatGPT는 언어 간 텍스트를 번역하고 문화 간 의사소통을 촉진함으로써 언어 장벽을 허물 수 있습니다.<br /><br/></li><li><strong>가상 교사:</strong> 맞춤형 학습 경험과 교육 지원을 제공하는 가상 교사 역할을 할 수 있는 잠재력이 있습니다.<br /><br/></li><li><strong>대화형 캐릭터:</strong> 게임 개발자는 ChatGPT를 활용하여 역동적인 대화와 개성을 지닌 실물 같은 캐릭터를 만들 수 있습니다.</li></ol><h2 id="chatgpt-작동-방식"><a class="markdownIt-Anchor" href="#chatgpt-작동-방식"></a> ChatGPT 작동 방식</h2><p>ChatGPT의 핵심은 딥 러닝 아키텍처입니다. 이 모델은 인터넷의 광범위한 텍스트 데이터세트를 통해 훈련되어 언어 패턴과 맥락을 학습할 수 있습니다. 사용자의 입력이 제공되면 ChatGPT는 입력과 해당 지식을 기반으로 가장 가능성이 높은 다음 단어를 예측하여 응답을 생성합니다.</p><p>맥락을 이해하고, 대화를 유지하며, 일관성 있고 맥락에 맞는 응답을 제공하는 모델의 능력이 ChatGPT를 차별화하는 요소입니다. 다양한 입력을 처리하고 다양한 대화 상황에 적응할 수 있어 다재다능하고 적응력이 뛰어납니다.</p><h2 id="chatgpt를-통한-대화형-ai의-미래"><a class="markdownIt-Anchor" href="#chatgpt를-통한-대화형-ai의-미래"></a> ChatGPT를 통한 대화형 AI의 미래</h2><p>ChatGPT는 대화형 AI 개발에 있어 중요한 도약을 의미합니다. 계속해서 개선되고 확장됨에 따라 우리는 예상할 수 있습니다.</p><ol><li><strong>향상된 고객 경험:</strong> ChatGPT가 제공하는 향상된 챗봇은 보다 효과적이고 개인화된 고객 상호 작용을 제공하여 고객 만족도와 충성도를 높입니다.<br /><br/></li><li><strong>생산성 향상:</strong> 기업과 개인은 AI 기반 콘텐츠 생성, 자동화된 응답, 더 많은 작업을 수행할 수 있는 가상 비서의 이점을 누릴 수 있습니다.<br /><br/></li><li><strong>원활한 다문화 커뮤니케이션:</strong> ChatGPT가 번역 및 언어 지원에 더욱 능숙해짐에 따라 언어 장벽이 더욱 낮아질 것입니다.<br /><br/></li><li><strong>고급 교육 도구:</strong> 가상 교사와 맞춤형 학습 경험은 우리가 지식과 기술을 습득하는 방식에 혁명을 일으킬 것입니다.<br /><br/></li><li><strong>몰입형 가상 세계:</strong> 게임 개발자는 ChatGPT 기반 캐릭터를 통해 더욱 몰입감 있고 대화형인 게임 경험을 만들 수 있습니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>ChatGPT는 대화형 AI 세계의 획기적인 발전입니다. 놀라운 기능, 다용성 및 적응성은 인간과 컴퓨터의 상호 작용이 더욱 자연스럽고 매력적인 미래를 위한 큰 가능성을 제시합니다. 고객 서비스를 개선하려는 기업, 지원이 필요한 콘텐츠 제작자, 사용자 경험을 향상시키려는 게이머 등 ChatGPT는 기술과 커뮤니케이션의 미래를 형성하는 데 중추적인 역할을 할 준비가 되어 있습니다. ChatGPT와 대화형 AI의 세계에서 앞으로 펼쳐질 흥미로운 발전에 계속 관심을 가져주세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/15/chatgpt-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>다중 장치(Multi-Device)를 위한 반응형 디자인</title>
      <link>http://hgko1207.github.io/2023/12/13/web-design-3/</link>
      <guid>http://hgko1207.github.io/2023/12/13/web-design-3/</guid>
      <pubDate>Wed, 13 Dec 2023 02:39:42 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/web-design-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;오늘날의 디지털 환경에서 웹 페이지는 대형 데스크톱 모니터부터 소형 스마트폰에 이르기까지 다양한 장치에서 액세스됩니다. 웹 사이트가 이러한
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/web-design-3.png" alt="" /></p><p>오늘날의 디지털 환경에서 웹 페이지는 대형 데스크톱 모니터부터 소형 스마트폰에 이르기까지 다양한 장치에서 액세스됩니다. 웹 사이트가 이러한 모든 장치에서 멋지게 보이고 원활하게 작동하는지 확인하는 것은 현대 웹 디자인의 기본 측면입니다. 반응형 디자인이 중요한 역할을 하는 곳이 바로 여기입니다.</p><h2 id="반응형-디자인이란-무엇입니까"><a class="markdownIt-Anchor" href="#반응형-디자인이란-무엇입니까"></a> 반응형 디자인이란 무엇입니까?</h2><p>반응형 디자인은 웹 페이지를 다양한 화면 크기와 장치에 맞게 적절하게 적용하는 것을 목표로 하는 웹 디자인 접근 방식입니다. 이는 웹 사이트가 데스크톱 컴퓨터, 태블릿, 휴대폰 중 어느 기기에서 보이든 상관없이 원활한 사용자에 보여지는 것입니다. 반응형 디자인을 사용하면 모든 기기에서 콘텐츠에 액세스할 수 있을 뿐만 아니라 사용자 친화적이기도 합니다.</p><h2 id="미디어-쿼리media-query의-역할"><a class="markdownIt-Anchor" href="#미디어-쿼리media-query의-역할"></a> 미디어 쿼리(Media Query)의 역할</h2><p>미디어 쿼리는 반응형 디자인의 초석입니다. 이는 화면 너비나 높이와 같은 특정 조건에서 웹 페이지가 표시되는 방법을 지정하는 CSS 규칙입니다. 미디어 쿼리를 사용하면 사용 중인 장치의 특성에 따라 다양한 스타일을 적용하거나 레이아웃을 조정할 수 있습니다.</p><h2 id="미디어-쿼리-이해"><a class="markdownIt-Anchor" href="#미디어-쿼리-이해"></a> 미디어 쿼리 이해</h2><p>미디어 쿼리의 작동 방식과 미디어 쿼리를 사용하여 반응형 웹 페이지를 만드는 방법을 분석해 보겠습니다.</p><h3 id="1미디어-쿼리-정의"><a class="markdownIt-Anchor" href="#1미디어-쿼리-정의"></a> 1.미디어 쿼리 정의</h3><p>미디어 쿼리는 CSS 파일의 <code>@media</code> 규칙을 사용하여 정의됩니다. 기본 구조는 다음과 같습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="comment">/* 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 미디어 쿼리는 최대 너비가 768픽셀인 화면을 대상으로 합니다.</p><h3 id="2-조건-설정"><a class="markdownIt-Anchor" href="#2-조건-설정"></a> 2. 조건 설정</h3><p>미디어 쿼리 내에서 <code>and</code>, <code>or</code>, <code>not</code>과 같은 논리 연산자를 사용하여 조건을 지정합니다. 화면 너비, 높이, 방향 등 다양한 측면을 타겟팅할 수 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span><br><span class="line">  <span class="comment">/* 세로 모드에서 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-css-규칙-적용"><a class="markdownIt-Anchor" href="#3-css-규칙-적용"></a> 3. CSS 규칙 적용</h3><p>미디어 쿼리 블록 내에서 조건이 충족될 때 적용되는 특정 CSS 규칙을 적용할 수 있습니다. 예를 들어 글꼴 크기를 변경하고, margin 과 padding 을 조정하고, 요소(element)를 숨기거나 표시하고, 레이아웃을 재구성할 수도 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="comment">/* 작은 화면에 맞게 글꼴 크기 조정 */</span></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="반응형-디자인-원칙"><a class="markdownIt-Anchor" href="#반응형-디자인-원칙"></a> 반응형 디자인 원칙</h2><p>미디어 쿼리 외에도 반응형 웹 페이지를 디자인할 때 명심해야 할 몇 가지 기본 원칙이 있습니다.</p><ol><li><strong>모바일 우선 접근 방식:</strong> 가장 작은 화면 크기를 염두에 두고 디자인을 시작한 다음 점차적으로 더 큰 화면에 맞게 향상시키세요. 이를 통해 사이트는 모바일 사용자에게 최적화됩니다.<br /><br/></li><li><strong>유연한 그리드:</strong> 콘텐츠가 다양한 화면 크기에 맞게 조정되도록 하려면 백분율 기반 또는 유연한 그리드를 사용하세요. CSS Grid와 Flexbox는 이러한 목적을 위한 강력한 도구입니다.<br /><br/></li><li><strong>이미지 최적화:</strong> 화면 크기에 맞게 조정되는 반응형 이미지를 사용하고 지연 로딩을 고려하여 모바일 장치의 페이지 로드 시간을 개선합니다.<br /><br/></li><li><strong>콘텐츠 우선순위 지정:</strong> 작은 화면에 맞춰 콘텐츠의 우선순위를 지정하고 재구성하세요. 중요한 정보는 쉽게 접근할 수 있어야 하며, 필수적이지 않은 요소는 숨기거나 압축할 수 있어야 합니다.<br /><br/></li><li><strong>테스트:</strong> 다양한 장치와 브라우저에서 웹사이트를 정기적으로 테스트하여 의도한 대로 모양과 기능이 작동하는지 확인합니다. 에뮬레이터와 브라우저 개발자 도구는 테스트에 매우 유용할 수 있습니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>반응형 디자인은 더 이상 있으면 좋은 기능이 아니라 오늘날의 다중 장치(Multi-Device) 세계에서 필수적인 기능입니다. 미디어 쿼리를 이해하고 반응형 디자인 원칙을 따르면 다양한 장치와 화면 크기에 맞게 최적의 사용자 경험을 제공하는 웹 페이지를 만들 수 있습니다. 사용자는 스마트폰, 태블릿, 노트북, 데스크탑 등 무엇을 사용하든 웹사이트를 접근성 있고 사용자 친화적으로 만들기 위해 기울이는 노력에 감사할 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/13/web-design-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 개발자를 위한 CSS Flexbox 기술</title>
      <link>http://hgko1207.github.io/2023/12/12/web-design-2/</link>
      <guid>http://hgko1207.github.io/2023/12/12/web-design-2/</guid>
      <pubDate>Tue, 12 Dec 2023 05:07:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;CSS Flexbox&lt;/strong&gt;에 대해 자세히 알아보고 개념을 설명하는 몇 가지 코드 예제를 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;css-flexbox란-무엇입니까&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>CSS Flexbox</strong>에 대해 자세히 알아보고 개념을 설명하는 몇 가지 코드 예제를 살펴보겠습니다.</p><h2 id="css-flexbox란-무엇입니까"><a class="markdownIt-Anchor" href="#css-flexbox란-무엇입니까"></a> CSS Flexbox란 무엇입니까?</h2><p>CSS Flexbox(Flexible Box Layout)는 크기를 알 수 없거나 동적인 경우에도 컨테이너 내의 공간을 분배하고 항목을 정렬하여 복잡한 레이아웃의 디자인을 단순화하는 1차원 레이아웃 모델입니다. Flexbox는 내비게이션 메뉴(Navigation Menu), 카드 레이아웃(Card Layout), 콘텐츠 배포(Content Distribution) 등 반응성이 뛰어나고 유연한 디자인을 만드는 데 특히 유용합니다.</p><h2 id="css-flexbox의-기본-개념"><a class="markdownIt-Anchor" href="#css-flexbox의-기본-개념"></a> CSS Flexbox의 기본 개념</h2><ol><li><strong>Flex Container:</strong> Flex 항목을 포함하는 요소를 “Flex Container”라고 합니다. Flex 컨테이너(Container)를 만들려면 <code>display: flex;</code> HTML 요소에 속성을 적용합니다.</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Flex Items:</strong> Flex Container의 직계 하위 항목을 &quot;Flex Items&quot;이라고 합니다. 이러한 항목은 div, text, image 또는 기타 컨테이너와 같은 모든 HTML 요소가 될 수 있습니다.</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="flex-container-속성"><a class="markdownIt-Anchor" href="#flex-container-속성"></a> Flex Container 속성</h2><p>Flex 컨테이너의 동작을 제어하기 위한 몇 가지 필수 속성은 다음과 같습니다.</p><ul><li><code>flex-direction</code>: 주축(행 또는 열)의 방향을 지정합니다.</li><li><code>justify-content</code>: 주축을 따라 항목이 배포되는 방식을 결정합니다.</li><li><code>align-items</code>: 항목이 교차축을 따라 정렬되는 방식을 정의합니다.</li><li><code>flex-wrap</code>: 플렉스 항목이 여러 줄로 줄바꿈되어야 하는지 여부를 지정합니다.</li><li><code>align-content</code>: 컨테이너 내에서 여러 줄의 정렬을 제어합니다( <code>flex-wrap</code> 활성화된 경우).</li></ul><h2 id="예제-코드"><a class="markdownIt-Anchor" href="#예제-코드"></a> 예제 코드</h2><p>이러한 개념 중 일부를 설명하기 위해 간단한 예제를 만들어 보겠습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">/* 행에 배치된 항목(기본값) */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 항목이 고르게 분포됨 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 항목을 수직으로 중앙에 배치 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 각 항목은 동일한 공간을 차지합니다. */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#007bff</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드에서는</p><ul><li><code>flex-container</code>는 세 개의 Flex 항목이 있는 Flex 컨테이너를 정의합니다.</li><li><code>flex-direction: row;</code>는 항목을 일렬로 정렬합니다.</li><li><code>justify-content: space-between;</code> 주축을 따라 항목을 균등하게 분배합니다.</li><li><code>align-items: center;</code> 교차축을 따라 항목을 수직으로 중앙에 배치합니다.</li></ul><h2 id="css-flexbox의-이점"><a class="markdownIt-Anchor" href="#css-flexbox의-이점"></a> CSS Flexbox의 이점</h2><ul><li>복잡한 레이아웃을 단순화합니다.</li><li>알 수 없거나 동적 콘텐츠 크기를 적절하게 처리합니다.</li><li>float 및 위치 지정의 필요성이 줄어듭니다.</li><li>정렬 및 분포 제어가 향상됩니다.</li><li>반응형 웹 디자인을 지원합니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>CSS Flexbox는 유연하고 반응이 빠른 웹 레이아웃을 간단하게 만들 수 있는 강력한 레이아웃 모델입니다. 웹 개발자는 개념을 이해하고 CSS를 통해 적용함으로써 컨테이너 내 요소의 배열과 정렬을 정밀하게 제어할 수 있습니다. Flexbox는 웹 레이아웃 코드의 효율성과 가독성을 향상시켜 최신 웹 개발에서 매우 유용한 도구입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/12/web-design-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트 성능 최적화 기술 익히기</title>
      <link>http://hgko1207.github.io/2023/12/12/js-dev-11/</link>
      <guid>http://hgko1207.github.io/2023/12/12/js-dev-11/</guid>
      <pubDate>Tue, 12 Dec 2023 02:20:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/js-dev-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;빠르고 반응이 빠른 웹 애플리케이션을 만들려면 자바스크립트 실행 시간을 줄이는 것이 중요합니다. 자바스크립트는 강력하고 다재다능한 프로그래밍 언
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/js-dev-11.png" alt="" /></p><p>빠르고 반응이 빠른 웹 애플리케이션을 만들려면 자바스크립트 실행 시간을 줄이는 것이 중요합니다. 자바스크립트는 강력하고 다재다능한 프로그래밍 언어이지만 제대로 최적화되지 않으면 웹 페이지 속도가 느려질 수 있습니다.</p><p>자바스크립트 코드를 실행하는 데 시간이 너무 오래 걸리면 사용자 경험이 느려지고 페이지 렌더링이 지연되며 이탈률이 증가할 수 있습니다. 따라서 원활한 사용자 경험을 보장하기 위해서는 자바스크립트 실행 시간을 최적화하는 것이 중요합니다.</p><h2 id="전략"><a class="markdownIt-Anchor" href="#전략"></a> 전략</h2><p>다음은 이를 달성하기 위한 몇 가지 전략입니다</p><ol><li><strong>자바스크립트 최소화 및 압축:</strong> 불필요한 코드를 제거하고 축소 및 압축 도구를 사용하여 웹페이지가 로드되는 자바스크립트 양을 줄입니다. 축소 및 압축된 자바스크립트 파일은 크기가 더 작으므로 다운로드가 더 빠르고 실행 시간이 단축됩니다.<br /><br/></li><li><strong>비동기 로딩:</strong> 가능하면 자바스크립트 파일을 비동기식으로 로드하세요. 이렇게 하면 웹페이지의 다른 요소들이 자바스크립트와 동시에 로드되어 장기 실행 스크립트에 의해 차단되는 것을 방지할 수 있습니다.<br /><br/></li><li><strong>로딩 연기:</strong> 중요한 렌더링 경로가 완료될 때까지 필수적이지 않은 자바스크립트 로딩을 연기합니다. 이렇게 하면 웹페이지가 처음에 더 빠르게 로드되고 브라우저가 덜 바쁠 때 자바스크립트를 실행할 수 있습니다.<br /><br/></li><li><strong>지연 로딩:</strong> 페이지 로드 시 즉시 필요하지 않은 자바스크립트 모듈에 대한 지연 로딩(Lazy Loading)을 구현합니다. 이는 대용량 자바스크립트 파일이나 특정 사용자 상호 작용에만 필요한 파일에 특히 유용합니다.<br /><br/></li><li><strong>코드 분할:</strong> 자바스크립트 코드를 더 작고 관리하기 쉬운 모듈로 분할하세요. 현재 사용자 경험에 필요한 모듈만 로드합니다. 이렇게 하면 초기 실행 시간이 줄어들고 시스템 리소스 사용이 최소화됩니다.<br /><br/></li><li><strong>루프 및 반복 최적화:</strong> 자바스크립트 코드 내의 루프(Loop) 및 반복(Iteration)에 주의를 기울이십시오. 비효율적인 루프는 실행 시간을 크게 늘릴 수 있습니다. 특정 사용 사례에 최적화된 알고리즘과 데이터 구조를 사용하세요.<br /><br/></li><li><strong>DOM 조작을 줄이세요:</strong> DOM(Document Object Model)을 과도하게 조작하면 심각한 병목 현상을 일으킬 수 있습니다. DOM에 대한 불필요한 업데이트를 최소화하고 일괄 처리 및 <code>requestAnimationFrame</code>과 같은 기술을 사용하여 애니메이션과 Transition을 원활하게 하세요.<br /><br/></li><li><strong>캐싱:</strong> 자주 변경되지 않는 데이터와 계산을 저장하는 캐싱 메커니즘을 구현하세요. 캐싱은 반복적인 자바스크립트 실행의 필요성을 줄여 성능을 향상시킬 수 있습니다.<br /><br/></li><li><strong>Web Worker 사용:</strong> 계산 집약적인 작업을 Web Worker에게 오프로드합니다. Web Worker를 사용하면 메인 스레드를 차단하지 않고 백그라운드에서 스크립트를 실행할 수 있으므로 자바스크립트가 사용자 상호 작용에 영향을 미치는 것을 방지할 수 있습니다.<br /><br/></li><li><strong>프로파일링 및 최적화:</strong> 브라우저 개발자 도구를 활용하여 자바스크립트 코드를 프로파일링하고 성능 병목현상을 파악하세요. Chrome 개발자도구와 같은 도구는 코드 실행 시간과 메모리 사용량을 분석하는 기능을 제공하므로 개선이 필요한 부분을 정확히 찾아내는 데 도움이 됩니다.<br /><br/></li><li><strong>CDN 호스팅:</strong> CDN(Content Delivery Network)을 사용하여 널리 사용되는 라이브러리 및 프레임워크를 호스팅하세요. CDN은 이러한 리소스를 보다 효율적으로 제공하여 다운로드 및 실행에 필요한 시간을 단축할 수 있습니다.<br /><br/></li><li><strong>ES6 이상 사용:</strong> 최신 ECMAScript 기능과 최적화를 활용하세요. 최신 자바스크립트 버전에는 성능이 향상되고 코드를 간소화하는 데 도움이 되는 새로운 기능이 포함되는 경우가 많습니다.<br /><br/></li><li><strong>테스트 및 벤치마킹:</strong> 정기적으로 웹 애플리케이션의 성능을 테스트하고 벤치마킹 도구를 사용하여 실행 시간을 측정하세요. 이를 통해 회귀를 감지하고 변경 사항이 자바스크립트 실행에 미치는 영향을 모니터링할 수 있습니다.<br /><br/></li><li><strong>이미지(Image) 및 자산(Asset) 최적화:</strong> 웹 애플리케이션에 사용되는 이미지 및 자산의 크기를 줄이면 전체 로딩 프로세스의 속도를 높여 자바스크립트 실행 시간을 간접적으로 개선할 수 있습니다.<br /><br/></li><li><strong>콘텐츠 전달 전략:</strong> 장치 및 네트워크 상태에 따라 사용자에게 다양한 자바스크립트 번들을 제공하는 등 스마트한 콘텐츠 전달 전략을 구현하세요. 이를 통해 사용자는 자신의 상황에 가장 최적화된 코드를 받을 수 있습니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>자바스크립트 실행 시간 최적화는 지속적으로 해야하며 높은 수준의 성능을 유지하려면 전략 실행, 도구(Tool) 사용 및 지속적인 관심이 필요합니다. 이러한 기술을 사용하고 웹 애플리케이션의 성능을 지속적으로 모니터링하면 자바스크립트 코드가 효율적으로 실행되어 더 나은 사용자 경험을 제공할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/12/js-dev-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>반응형 웹 디자인을 사용해야 하는 10가지 이유</title>
      <link>http://hgko1207.github.io/2023/12/11/info-6/</link>
      <guid>http://hgko1207.github.io/2023/12/11/info-6/</guid>
      <pubDate>Mon, 11 Dec 2023 05:28:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;전 세계가 점점 더 모바일화됨에 따라 반응형 웹 디자인의 중요성은 아무리 강조해도 지나치지 않습니다. 반응형 디자인은 웹 사이트를 보는 데 사용되는 기기의 화면 크기에 맞게 웹 사이트가 조정되도록 하는 웹 디자인 접근 방식입니다. 즉, 데스크톱 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>전 세계가 점점 더 모바일화됨에 따라 반응형 웹 디자인의 중요성은 아무리 강조해도 지나치지 않습니다. 반응형 디자인은 웹 사이트를 보는 데 사용되는 기기의 화면 크기에 맞게 웹 사이트가 조정되도록 하는 웹 디자인 접근 방식입니다. 즉, 데스크톱 컴퓨터, 태블릿, 스마트폰 등 어떤 기기에서 사이트를 탐색하든 최적의 보기 환경을 제공합니다.</p><p>이 글에서는 반응형 웹 디자인 사용을 고려해야 하는 10가지 이유를 살펴봅니다.</p><h2 id="1-사용자-경험-개선"><a class="markdownIt-Anchor" href="#1-사용자-경험-개선"></a> 1. 사용자 경험 개선</h2><p>반응형 웹 디자인은 사용자가 웹사이트에 액세스하는 기기에 관계없이 일관된 경험을 할 수 있도록 합니다. 따라서 사용자가 사이트를 더 쉽게 탐색하고 원하는 정보를 쉽게 찾을 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 사이트에 더 오래 머무르고 콘텐츠에 더 많이 참여할 가능성이 높아집니다.</p><h2 id="2-모바일-트래픽-증가"><a class="markdownIt-Anchor" href="#2-모바일-트래픽-증가"></a> 2. 모바일 트래픽 증가</h2><p>점점 더 많은 사람들이 스마트폰을 사용하여 인터넷에 접속하기 때문에 모바일 기기에 최적화된 웹사이트를 만드는 것이 중요합니다. 반응형 디자인은 모든 화면 크기에서 웹사이트가 멋지게 보이도록 하여 모바일 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성을 높입니다.</p><h2 id="3-더-나은-seo"><a class="markdownIt-Anchor" href="#3-더-나은-seo"></a> 3. 더 나은 SEO</h2><p>Google 및 기타 검색 엔진은 반응형 디자인이 적용된 웹사이트가 더 나은 사용자 경험을 제공하기 때문에 우선순위를 둡니다. 즉, 웹사이트가 반응형이면 검색 엔진 결과 페이지(Search Engine Results Pages, SERPs)에서 더 높은 순위를 차지할 가능성이 높아져 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도할 수 있습니다.</p><h2 id="4-이탈률-감소"><a class="markdownIt-Anchor" href="#4-이탈률-감소"></a> 4. 이탈률 감소</h2><p>이탈률은 한 페이지만 보고 웹사이트를 떠나는 방문자의 비율을 말합니다. 반응형 웹 디자인은 더 나은 사용자 경험을 제공하여 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성이 높아지므로 이탈률을 낮추는 데 도움이 될 수 있습니다.</p><h2 id="5-더-빠른-웹사이트-로딩-시간"><a class="markdownIt-Anchor" href="#5-더-빠른-웹사이트-로딩-시간"></a> 5. 더 빠른 웹사이트 로딩 시간</h2><p>반응형 웹사이트는 동일한 콘텐츠의 여러 버전을 로드할 필요가 없기 때문에 일반적으로 비반응형 웹사이트보다 로딩 속도가 빠릅니다. 즉, 사용자가 느린 로딩 시간에 불만을 품고 사이트를 떠날 가능성이 줄어듭니다.</p><h2 id="6-손쉬운-유지-관리"><a class="markdownIt-Anchor" href="#6-손쉬운-유지-관리"></a> 6. 손쉬운 유지 관리</h2><p>반응형 웹사이트를 사용하면 사이트의 한 버전만 유지 관리하면 됩니다. 따라서 여러 버전의 사이트를 변경할 필요가 없으므로 콘텐츠를 업데이트하고 사이트를 변경하기가 더 쉬워집니다.</p><h2 id="7-비용-효율적"><a class="markdownIt-Anchor" href="#7-비용-효율적"></a> 7. 비용 효율적</h2><p>반응형 웹 디자인은 모든 기기에서 작동하는 하나의 버전의 웹 사이트만 만들면 되기 때문에 비용 효율적입니다. 즉, 여러 버전의 사이트를 만들거나 별도의 사이트 버전을 유지 관리하는 데 비용을 들일 필요가 없습니다.</p><h2 id="8-미래-보장"><a class="markdownIt-Anchor" href="#8-미래-보장"></a> 8. 미래 보장</h2><p>반응형 웹 디자인을 사용하면 웹 사이트는 시장에 출시되는 모든 새로운 장치에 대비할 수 있습니다. 즉, 새로운 기기가 대중화되어 사이트가 구식이 될까 봐 걱정할 필요가 없습니다.</p><h2 id="9-더-나은-분석"><a class="markdownIt-Anchor" href="#9-더-나은-분석"></a> 9. 더 나은 분석</h2><p>반응형 웹사이트를 사용하면 모든 기기에서 사용자 행동을 추적할 수 있습니다. 즉, 사용자가 사이트와 상호 작용하는 방식을 더 잘 이해하고 데이터에 기반한 의사 결정을 통해 사용자 경험을 개선할 수 있습니다.</p><h2 id="10-경쟁-우위"><a class="markdownIt-Anchor" href="#10-경쟁-우위"></a> 10. 경쟁 우위</h2><p>마지막으로 반응형 웹사이트는 경쟁 우위를 확보할 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 다른 사람에게 사이트를 추천할 가능성이 높아집니다. 이는 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도하는 데 도움이 될 수 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>결론적으로 반응형 웹 디자인은 훌륭한 사용자 경험을 만들고 웹사이트의 가시성을 높이고자 하는 모든 사람에게 필수적입니다. 웹사이트가 모든 기기에서 멋지게 보이도록 하면 더 많은 방문자를 유치하고 참여도를 높이며 더 많은 전환을 유도할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/11/info-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ChatGPT란 무엇인가요? ChatGPT로 어떻게 돈을 벌까?</title>
      <link>http://hgko1207.github.io/2023/12/06/chatgpt-1/</link>
      <guid>http://hgko1207.github.io/2023/12/06/chatgpt-1/</guid>
      <pubDate>Wed, 06 Dec 2023 13:52:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;는 다양한 질문에 답하고 사람들과 대화할 수 있도록 설계된 AI 기반 언어 모델입니다. AI 언어 모델로서 ChatGPT는 돈을 벌거나 금융 거래에 참여할 수 있는 능력이 없습니다.&lt;/p&gt;
&lt;p&gt;하지만 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>ChatGPT</strong>는 다양한 질문에 답하고 사람들과 대화할 수 있도록 설계된 AI 기반 언어 모델입니다. AI 언어 모델로서 ChatGPT는 돈을 벌거나 금융 거래에 참여할 수 있는 능력이 없습니다.</p><p>하지만 ChatGPT를 사용하여 잠재적으로 수익을 창출할 수 있는 방법이 있습니다. 다음은 몇 가지 아이디어입니다.</p><h2 id="사업-아이디어-조사"><a class="markdownIt-Anchor" href="#사업-아이디어-조사"></a> 사업 아이디어 조사</h2><p>창업을 고려하고 있다면 ChatGPT를 사용하여 잠재적인 사업 아이디어를 조사할 수 있습니다. ChatGPT는 시장 동향, 소비자 행동 및 업계 모범 사례에 대한 통찰력을 제공할 수 있습니다. 잠재적인 사업 아이디어에 대해 ChatGPT에 질문을 하면 실행 가능하고 수익성 있는 옵션인지 더 잘 파악할 수 있습니다.</p><h2 id="비즈니스를-위한-챗봇-구축하기"><a class="markdownIt-Anchor" href="#비즈니스를-위한-챗봇-구축하기"></a> 비즈니스를 위한 챗봇 구축하기</h2><p>챗봇은 기업이 고객과 소통하고 고객 서비스 업무를 자동화하는 방법으로 점점 더 인기를 얻고 있습니다. 비즈니스에 챗봇을 구축하려는 경우 ChatGPT를 사용하여 매력적이고 유용한 대화형 인터페이스를 만들 수 있습니다. ChatGPT는 챗봇이 고객 문의에 응답하고 유용한 정보를 제공하도록 훈련시켜 고객 만족도를 높이고 판매를 촉진하는 데 도움이 될 수 있습니다.</p><h2 id="글쓰기-실력-향상하기"><a class="markdownIt-Anchor" href="#글쓰기-실력-향상하기"></a> 글쓰기 실력 향상하기</h2><p>작가나 콘텐츠 제작자라면 ChatGPT를 사용하여 글쓰기 실력을 향상시킬 수 있습니다. ChatGPT는 콘텐츠에 대한 아이디어를 생성하고, 글쓰기에 대한 피드백을 제공하며, 글쓰기 스타일을 개선할 수 있는 방법을 제안할 수 있습니다. ChatGPT를 사용하여 글쓰기 기술을 개선하면 잠재적으로 더 많은 고객을 유치하고 더 많은 수익을 올릴 수 있습니다.</p><h2 id="새로운-기술-배우기"><a class="markdownIt-Anchor" href="#새로운-기술-배우기"></a> 새로운 기술 배우기</h2><p>ChatGPT는 새로운 기술을 배우기 위한 도구로도 사용할 수 있습니다. 특정 주제나 관심 분야에 대해 ChatGPT에 질문할 수 있으며 관련 정보와 리소스를 제공받을 수 있습니다. ChatGPT를 통해 새로운 기술을 배우면 잠재적으로 취업 가능성을 높이거나 현재 직업에서 더 많은 돈을 벌 수 있습니다.</p><h2 id="시간-절약하기"><a class="markdownIt-Anchor" href="#시간-절약하기"></a> 시간 절약하기</h2><p>마지막으로, 많은 조사나 수작업이 필요한 작업의 시간을 절약하기 위해 ChatGPT를 사용할 수 있습니다. 예를 들어, 특정 주제에 대한 정보를 찾아야 하는 경우 인터넷 검색에 시간을 소비하는 대신 ChatGPT에 물어볼 수 있습니다. ChatGPT를 사용하여 워크플로우를 간소화하면 잠재적으로 수입을 창출하는 작업에 집중할 수 있는 시간을 더 많이 확보할 수 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>결론적으로, ChatGPT 자체는 돈을 벌 수 있는 기능이 없지만, 잠재적으로 더 많은 돈을 벌 수 있는 방법이 있습니다. 연구, 글쓰기, 학습 및 자동화를 위한 기능을 활용하여 비즈니스 또는 경력 전망을 개선하고 재정적 목표를 달성할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/06/chatgpt-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>차세대 웹 앱을 위한 인기있는 상위 10개 Angular 라이브러리</title>
      <link>http://hgko1207.github.io/2023/12/04/angular-32/</link>
      <guid>http://hgko1207.github.io/2023/12/04/angular-32/</guid>
      <pubDate>Mon, 04 Dec 2023 02:44:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것은 어려운 작업일 수 있습니다. 사용 가능한 옵션이 너무 많기 때문에 프로젝트에 가장 적합한 라이브러리를 결정하기가 어려울 수 있습니다. 하지만 프로젝트의 규모, 앱의 복잡성, 필요한 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것은 어려운 작업일 수 있습니다. 사용 가능한 옵션이 너무 많기 때문에 프로젝트에 가장 적합한 라이브러리를 결정하기가 어려울 수 있습니다. 하지만 프로젝트의 규모, 앱의 복잡성, 필요한 기능 등의 요소를 고려하면 선택의 폭을 좁히고 정보에 입각한 결정을 내릴 수 있습니다. 또한 라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려하는 것도 중요합니다. 이 글에서는 사용 가능한 라이브러리에 대한 개요와 프로젝트에 적합한 라이브러리를 선택할 때 고려해야 할 요소에 대해 설명합니다.</p><h2 id="angular-무엇입니까"><a class="markdownIt-Anchor" href="#angular-무엇입니까"></a> Angular 무엇입니까?</h2><p>Angular는 Google에서 개발하고 유지 관리하는 오픈 소스 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션에서 자주 사용되는 구성 요소와 함께 클라이언트 측 MVC(Model-View-Controller) 및 MVVM(Model-View-View Model) 아키텍처를 위한 프레임워크를 제공함으로써 단일 페이지 애플리케이션을 구성하는 데도 사용되며 개발 및 테스트를 보다 쉽게 수행할 수 있도록 설계되었습니다.<br/></p><p>Angular 애플리케이션을 빌드할 때는 프로젝트의 성공을 보장하기 위해 올바른 라이브러리와 프레임워크를 선택하는 것이 중요합니다. 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하려면 필요한 기능, 프로젝트의 규모와 복잡성, 학습 및 구현에 투자해야 하는 시간 등을 신중하게 고려해야 합니다. 신뢰할 수 있고, 지원이 잘 제공되며, 정기적으로 업데이트되는 라이브러리를 선택하는 것이 중요합니다. 또한 서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택하는 것도 중요합니다. 시간을 들여 사용 가능한 라이브러리를 조사하고 비교하면 프로젝트에 적합한 라이브러리를 선택할 수 있습니다.</p><h2 id="올바른-angular-라이브러리를-선택하는-방법은-무엇입니까"><a class="markdownIt-Anchor" href="#올바른-angular-라이브러리를-선택하는-방법은-무엇입니까"></a> 올바른 Angular 라이브러리를 선택하는 방법은 무엇입니까?</h2><p>라이브러리를 선택할 때 고려해야 할 몇 가지 중요한 요소가 있습니다.</p><ul><li>웹 앱에 필요한 기능을 고려합니다.</li><li>프로젝트의 규모와 복잡성을 평가합니다.</li><li>라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려합니다.</li><li>신뢰할 수 있고, 지원이 잘 되며, 정기적으로 업데이트되는 라이브러리를 선택합니다.</li><li>서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택합니다.</li><li>사용 가능한 라이브러리를 조사하고 비교하여 프로젝트에 적합한 라이브러리를 선택해야 합니다.</li></ul><p>Angular 웹 애플리케이션을 개발할 때 사용할 수 있는 몇 가지 인기 있는 라이브러리가 있습니다. 각 라이브러리에는 고유한 기능과 장점이 있으므로 프로젝트에 가장 적합한 라이브러리를 선택하는 것이 중요합니다. 다음은 가장 인기 있는 Angular 라이브러리 중 일부입니다.</p><h2 id="angular-material"><a class="markdownIt-Anchor" href="#angular-material"></a> Angular Material</h2><p><a href="https://material.angular.io/" target="_blank" rel="noopener"><img src="/images/angular/angular-1.png" alt="Angular Material" /></a></p><p><strong><a href="https://github.com/angular/components" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 23.2k<br/><br /><strong>License:</strong> MIT</p><p>Angular Material은 사용자 인터페이스 디자인을 위한 다양한 컴포넌트를 제공하는 Angular 애플리케이션용 UI 컴포넌트 라이브러리입니다. Google의 Material Design 언어를 기반으로 하며 반응형 및 접근성 높은 웹 애플리케이션을 만드는 데 사용됩니다. Material Design 시스템을 기반으로 재사용 가능하고 충분한 테스트를 거친 접근 가능한 UI 컴포넌트 세트를 제공합니다. 또한 Angular Material은 광범위한 테마 시스템을 제공하여 개발자가 웹 애플리케이션의 모양과 느낌을 쉽게 커스터마이징할 수 있습니다.</p><p>Angular Material 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Material 디자인 시스템을 기반으로 재사용 가능하고 잘 테스트되었으며 액세스 가능한 UI 컴포넌트 세트입니다.</li><li>직관적이고 효율적인 방법으로 현대적인 대화형 웹 앱을 제작할 수 있습니다.</li><li>웹 앱의 모양과 느낌을 쉽게 커스터마이징 할 수 있는 광범위한 테마 시스템입니다.</li><li>완벽하게 반응하는 디자인으로 웹 앱이 모든 기기에서 멋지게 보입니다.</li><li>방대한 문서화 및 지원을 통해 필요한 경우 쉽게 도움을 받을 수 있습니다.</li><li>button, card, input field, slider 등과 같은 구현하기 쉬운 컴포넌트입니다.</li></ul><h2 id="angularfire"><a class="markdownIt-Anchor" href="#angularfire"></a> AngularFire</h2><p><img src="/images/angular/angular-2.png" alt="AngularFire" /></p><p><strong><a href="https://github.com/angular/angularfire" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 7.5k<br/><br /><strong>License:</strong> MIT</p><p>AngularFire는 Firebase 실시간 데이터베이스와 상호 작용하기 위한 사용하기 쉬운 API를 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 데이터 동기화, 인증 등과 같은 실시간 기능을 웹 앱에 더 쉽게 추가할 수 있도록 설계되었습니다. 또한 개발자가 Cloud Storage, Cloud Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스할 수 있는 인터페이스를 제공합니다.</p><p>AngularFire는 개발자가 실시간 기능을 갖춘 웹 앱을 보다 쉽게 ​​구축할 수 있도록 하는 다양한 기능을 제공합니다.</p><ul><li>Firebase 실시간 데이터베이스와 상호작용하기 위한 사용하기 쉬운 API입니다.</li><li>여러 클라이언트에서 데이터의 실시간 동기화를 지원합니다.</li><li>사용자가 앱에 쉽게 가입하고 로그인할 수 있는 인증 시스템을 제공합니다.</li><li>Cloud Storage, Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스합니다.</li><li>개발자가 프로젝트를 빠르게 시작하고 실행할 수 있는 간단하고 직관적인 인터페이스입니다.</li><li>Angular, React, Vue 등 다양한 플랫폼을 지원합니다.</li></ul><h2 id="angular-cli"><a class="markdownIt-Anchor" href="#angular-cli"></a> Angular CLI</h2><p><a href="https://angular.io/cli" target="_blank" rel="noopener"><img src="/images/angular/angular-3.png" alt="Angular CLI" /></a></p><p><strong><a href="https://github.com/angular/angular-cli" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 26.4k<br/><br /><strong>License:</strong> MIT</p><p>Angular CLI는 Angular 애플리케이션을 생성, 구축 및 배포하기 위한 명령줄(Command line) 인터페이스입니다. 개발자가 앱을 빠르게 생성, 빌드 및 배포할 수 있도록 설계되었습니다. 새 프로젝트를 빠르게 설정할 수 있는 직관적인 스캐폴딩 시스템을 제공하며 라우팅, 테스트 및 컴포넌트와 같은 일반적인 작업을 위한 코드를 생성합니다. 또한 개발자는 한 번의 명령으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다.</p><p>Angular CLI 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Angular 애플리케이션을 생성, 구축, 배포하기 위한 명령줄 인터페이스입니다.</li><li>새로운 프로젝트를 빠르게 설정하기 위한 직관적인 스캐폴딩 시스템을 제공합니다.</li><li>라우팅, 테스트, 컴포넌트 등 일반적인 작업을 위한 코드를 생성합니다.</li><li>명령 한 번으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다.</li><li>다양한 타사 라이브러리를 지원하여 다른 도구와 프레임워크를 쉽게 통합할 수 있습니다.</li><li>개발자가 프로젝트를 빠르게 설정하는 데 도움이 되는 다양한 도구와 명령을 제공합니다.</li></ul><h2 id="angular-ui-bootstrap"><a class="markdownIt-Anchor" href="#angular-ui-bootstrap"></a> Angular UI Bootstrap</h2><p><a href="https://angular-ui.github.io/bootstrap/versioned-docs/1.3.1/" target="_blank" rel="noopener"><img src="/images/angular/angular-4.png" alt="Angular UI Bootstrap" /></a></p><p><strong><a href="https://github.com/angular-ui/bootstrap" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 14.3k<br/><br /><strong>License:</strong> MIT</p><p>Angular UI Bootstrap은 Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트를 제공하는 라이브러리입니다. 개발자가 반응형 모바일 친화적인 웹 애플리케이션을 더 쉽게 만들 수 있도록 설계되었습니다</p><p>Angular UI Bootstrap 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트입니다.</li><li>반응성이 뛰어나고 모바일 친화적인 웹 애플리케이션을 만들 수 있습니다.</li><li>alert, button, carousel 등과 같은 다양한 컴포넌트를 사용하여 시각적으로 매력적인 대화형 사용자 인터페이스를 만들 수 있습니다.</li><li>웹 애플리케이션에 쉽게 통합할 수 있는 사전 구축된 컴포넌트입니다.</li><li>문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다.</li><li>시각적으로 매력적인 대화형 사용자 인터페이스를 만드는 직관적이고 효율적인 방법입니다.</li></ul><h2 id="angular-flex-layout"><a class="markdownIt-Anchor" href="#angular-flex-layout"></a> Angular Flex Layout</h2><p><img src="/images/angular/angular-5.png" alt="Angular Flex Layout" /></p><p><strong><a href="https://github.com/angular/flex-layout" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 5.9k<br/><br /><strong>License:</strong> MIT</p><p>Angular Flex-Layout은 Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공하는 라이브러리입니다. 개발자가 기기나 화면 크기에 관계없이 유연하고 반응이 빠른 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다.</p><p>Angular Flex-Layout 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공합니다.</li><li>fxLayout 및 fxFlex와 같은 다양한 Directive를 사용하여 유연하고 반응이 빠른 레이아웃을 만들 수 있습니다.</li><li>맞춤형 반응형 레이아웃 및 컴포넌트를 생성하기 위한 API입니다.</li><li>레이아웃 크기와 중단점을 쉽게 관리하는 기능을 제공합니다.</li><li>문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다.</li><li>개발자가 유연하고 반응이 빠른 사용자 인터페이스를 만들 수 있습니다.</li></ul><h2 id="ngrx"><a class="markdownIt-Anchor" href="#ngrx"></a> NgRx</h2><p><a href="https://ngrx.io/" target="_blank" rel="noopener"><img src="/images/angular/angular-6.png" alt="NgRx" /></a></p><p><strong><a href="https://github.com/ngrx/platform" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 7.8k<br/><br /><strong>License:</strong> MIT</p><p>NgRx는 복잡한 애플리케이션에서 데이터를 관리하기 위한 상태 관리 시스템을 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 애플리케이션을 보다 쉽게 ​​생성, 유지 관리 및 테스트할 수 있도록 설계되었습니다.</p><p>NgRx 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>복잡한 애플리케이션의 데이터를 관리하기 위한 상태 관리 시스템을 제공합니다.</li><li>예측 가능하고 일관되게 데이터를 관리하기 위한 API 및 도구 세트입니다.</li><li>애플리케이션 상태 업데이트를 쉽게 관리하기 위한 직관적인 인터페이스입니다.</li><li>상태 변경을 추적하고 추적하기 위한 강력한 디버깅 도구입니다.</li><li>문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다.</li><li>애플리케이션을 더욱 쉽게 생성, 유지 관리 및 테스트할 수 있습니다.</li></ul><h2 id="angular-charts"><a class="markdownIt-Anchor" href="#angular-charts"></a> Angular Charts</h2><p><strong><a href="https://github.com/valor-software/ng2-charts" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 2.3k<br/><br /><strong>License:</strong> MIT</p><p>Angular Charts 라이브러리는 Angular 팀에서 만든 오픈 소스 라이브러리로, Angular 애플리케이션에서 대화형 차트를 만들기 위한 선언형 API를 제공합니다. 선형, 막대형, 영역형, 원형, 도넛형, 분산형 차트를 포함한 다양한 차트 유형을 지원합니다. 또한 스타일과 애니메이션에 대한 다양한 커스터마이징 옵션도 제공합니다.</p><p>Angular Charts 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Angular 애플리케이션에서 차트를 생성하기 위한 선언형 API<ul><li>line, bar, area, pie, doughnut 및 scatter 차트를 포함한 다양한 차트 유형 지원</li></ul></li><li>차트의 스타일, 애니메이션 및 기타 속성을 사용자에 맞게 설정하는 옵션 제공</li><li>확대/축소 및 hovering 과 같은 대화형 기능 지원</li><li>고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능</li><li>정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원</li><li>Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원</li></ul><h2 id="angular2-google-maps"><a class="markdownIt-Anchor" href="#angular2-google-maps"></a> Angular2-Google-Maps</h2><p><a href="https://angular-maps.com/" target="_blank" rel="noopener"><img src="/images/angular/angular-7.png" alt="Angular2-Google-Maps" /></a></p><p><strong><a href="https://github.com/sebholstein/angular-google-maps" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 2k<br/><br /><strong>License:</strong> MIT</p><p>Angular2-Google-Maps는 Angular 팀에서 만든 오픈 소스 라이브러리로, Google 지도를 Angular 애플리케이션에 통합하기 위한 사용하기 쉬운 인터페이스를 제공합니다.</p><p>Angular2-Google-Maps 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li>Google 지도 컴포넌트 생성을 위한 선언형 API</li><li>center, zoom level, marker 등과 같은 다양한 속성을 지정하는 기능</li><li>스타일링, 애니메이션 등 다양한 커스터마이징 옵션 지원</li><li>고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능</li><li>정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원</li><li>Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원</li></ul><h2 id="angular-draggable"><a class="markdownIt-Anchor" href="#angular-draggable"></a> Angular-Draggable</h2><p><strong><a href="https://github.com/mattlewis92/angular-draggable-droppable" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 132<br/><br /><strong>License:</strong> MIT</p><p>Angular-Draggable 라이브러리는 널리 사용되는 JavaScript 프레임워크인 Angular를 사용하여 드래그(draggable) 및 크기 조정(resizable)이 가능한 사용자 인터페이스를 만들기 위한 오픈 소스 라이브러리입니다.</p><p>Angular-Draggable의 주요 기능 중 일부는 다음과 같습니다.</p><ul><li>사용자 맞춤형 옵션이 포함된 드래그 앤 드롭 기능</li><li>스냅 옵션으로 크기 조정 가능한 요소</li><li>사용자 맞춤형 드래그 handle</li><li>Placeholder 지원</li><li>맞춤형 스타일</li><li>다른 Angular 컴포넌트와 쉽게 통합</li></ul><h2 id="ngx-datatable"><a class="markdownIt-Anchor" href="#ngx-datatable"></a> Ngx-datatable</h2><p><strong><a href="https://github.com/swimlane/ngx-datatable" target="_blank" rel="noopener">GitHub</a> Stars:</strong> 4.6k<br/><br /><strong>License:</strong> MIT</p><p>Ngx-datatable은 개발자가 Sorting, Filtering, Pagination과 같은 고급 기능을 사용하여 동적이고 반응이 빠른 테이블을 쉽게 만들 수 있는 오픈 소스 라이브러리입니다. 또한 성능에 최적화되어 개발자가 성능 저하 없이 대규모 데이터 세트를 신속하게 렌더링할 수 있습니다. Ngx-datatable은 JSON, CSV, OData를 포함한 광범위한 데이터 소스를 지원합니다. 또한 클라이언트 또는 서버 측 데이터 처리를 지원하며 사용자에 맞는 템플릿 및 스타일을 설정할 수 있습니다.</p><p>Ngx-datatable 라이브러리의 주요 기능은 다음과 같습니다.</p><ul><li><strong>유연한 데이터 바인딩:</strong> Ngx-datatable은 로컬 및 원격 데이터 바인딩을 모두 지원하므로 다양한 데이터 소스의 데이터를 쉽게 바인딩할 수 있습니다.</li><li><strong>고급 필터링 및 정렬:</strong> Ngx-datatable을 사용하면 데이터를 빠르게 필터링하고 정렬하여 필요한 정보를 더 쉽게 찾을 수 있습니다.</li><li><strong>열 크기 조정:</strong> 테이블 너비에 맞게 열 크기를 조정하거나 다양한 데이터 유형을 수용할 수 있습니다.</li><li><strong>행 가상화(Virtualization):</strong> Ngx-datatable은 행이 표시되는 경우에만 행을 렌더링하므로 성능 문제 없이 대규모 데이터 세트를 스크롤할 수 있습니다.</li><li><strong>열 재정렬:</strong> 열을 재정렬하여 테이블 레이아웃을 커스터마이징 할 수 있습니다.</li><li><strong>편집 가능한 cell:</strong> 테이블의 특정 셀을 편집 가능하게 만들어 사용자가 데이터를 빠르게 업데이트할 수 있습니다.</li></ul><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>성공적인 웹 애플리케이션을 제작하려면 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것이 필수적입니다. 올바른 라이브러리를 사용하면 개발에 많은 시간과 노력을 들이지 않고도 앱을 빠르게 구축할 수 있습니다. 라이브러리를 선택할 때는 라이브러리가 제공하는 기능뿐만 아니라 라이브러리의 성능과 확장성을 고려하는 것이 중요합니다. 또또한 라이브러리의 비용과 라이브러리가 제공하는 지원 수준도 고려하세요. 요구 사항을 평가하고 사용 가능한 Angular 라이브러리를 조사하여 정보에 입각한 결정을 내리고 웹 애플리케이션에 가장 적합한 라이브러리를 선택할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/04/angular-32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 2와 Vue 3의 차이점</title>
      <link>http://hgko1207.github.io/2023/12/01/vue-3/</link>
      <guid>http://hgko1207.github.io/2023/12/01/vue-3/</guid>
      <pubDate>Fri, 01 Dec 2023 06:15:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/vue-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;프런트엔드 개발 세계에서는 Vue.js가 인기 있는 선택이 되었습니다. Vue.js는 최신 웹 애플리케이션 개발에 널리 사용되는 사용자 친화적인 JavaS
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/vue-3.png" alt=""></p><p>프런트엔드 개발 세계에서는 Vue.js가 인기 있는 선택이 되었습니다. Vue.js는 최신 웹 애플리케이션 개발에 널리 사용되는 사용자 친화적인 JavaScript 프레임워크입니다. 그러나 Vue.js의 최신 버전인 Vue 3은 중요한 업데이트와 개선 사항을 도입한다는 점에서 Vue 2와 다릅니다. 이 글에서는 Vue 2와 Vue 3의 주요 차이점을 자세히 살펴보겠습니다.</p><h2 id="Virtual-DOM">Virtual DOM</h2><p>Vue.js의 기초는 Virtual DOM(Document Object Model) 기술에 있습니다. Vue 2에서는 Virtual DOM이 Vue.js의 이벤트 루프에 완벽하게 통합됩니다. 그러나 Vue 3에서는 Virtual DOM이 재설계되어 더욱 효율적으로 만들어졌습니다. Vue 3에서는 Virtual DOM이 더 빠르게 처리되고 더 적은 메모리를 사용합니다. 이는 성능과 애플리케이션 응답 시간을 크게 향상시킵니다.</p><h2 id="Composition-API">Composition API</h2><p>Vue 3에서는 가장 주목할만한 기능 중 하나인 Composition API를 도입했습니다. Composition API는 Vue 2의 Options API와 다르며 코드를 더욱 체계화하고 유지 관리 및 재사용 가능하게 만듭니다. Vue 2에서 컴포넌트는 data, methods, computed 및 watch와 같은 옵션을 사용하여 정의됩니다. Vue 3에서는 코드를 보다 기능적으로 구성할 수 있습니다. Composition API를 사용하면 더 작고 재사용이 가능하며 사용자 맞춤형 기능을 만들 수 있습니다.</p><h2 id="TypeScript-Integration">TypeScript Integration</h2><p>Vue.js는 TypeScript와 같은 정적 유형 검사 도구를 사용하는 프로젝트에 널리 사용됩니다. Vue 2에서는 TypeScript 통합이 가능했지만 개발자는 몇 가지 어려움과 문제에 직면했을 수 있습니다. Vue 3에서는 TypeScript 통합이 크게 향상되었습니다. Vue 3에서 TypeScript를 사용하면 더 나은 정적 유형 제어와 더 부드러운 TypeScript 경험을 얻을 수 있습니다.</p><h2 id="Bundle-Size">Bundle Size</h2><p>번들 크기는 대규모 프런트엔드 프로젝트에서 중요한 요소입니다. Vue 2에서는 번들 크기를 줄이기 위해 다양한 최적화 기술과 플러그인이 필요할 수 있습니다. 그러나 Vue 3에서는 최적화된 매칭 알고리즘 및 소스 코드 압축과 같은 개선으로 번들 크기가 크게 줄었습니다. 그 결과 번들 크기가 작아지고 로딩 시간이 빨라지며 성능이 향상됩니다.</p><h2 id="Compatibility">Compatibility</h2><p>Vue 3은 Vue 2 프로젝트에서 전환하는 개발자에게 호환성 문제를 일으킬 수 있습니다. Vue 3는 일부 API 또는 컴포넌트를 삭제하거나 다른 이름을 바꾸거나 변경할 수 있습니다. 따라서 기존 Vue 2 프로젝트를 Vue 3으로 업그레이드하려는 경우 몇 가지 호환성 문제가 발생할 수 있습니다. Vue 3에 대한 자세한 마이그레이션 가이드가 있으며, 이 가이드를 참조하면 전환 과정에서 지침을 얻을 수 있습니다.</p><h2 id="결론">결론</h2><p>Vue 2와 Vue 3의 주요 차이점을 검토하는 이 글에서는 재설계된 Virtual DOM, Composition API 도입, 향상된 TypeScript 통합 및 더 작은 번들 크기와 같은 요소를 다루었습니다. 이러한 요소로 인해 Vue 3는 프런트엔드 개발을 위한 강력한 선택이 되었습니다.<br/><br>새로운 기능과 개선 사항에도 불구하고 기존 프로젝트를 Vue 2에서 Vue 3으로 전환하면 호환성 문제가 발생할 수 있습니다. 따라서 Vue 3으로의 전환을 고려하고 있다면 신중한 계획과 호환성 문제에 대한 주의가 중요합니다.<br/><br>Vue.js는 빠르고 강력하며 사용자 친화적인 프레임워크로서 인기를 계속 유지하고 있으며 Vue 3을 사용하면 더 많은 유연성을 도입할 수 있습니다. 개발 프로세스에 성능을 추가합니다. 자세한 내용은 <a href="https://vuejs.org/" target="_blank" rel="noopener">공식 Vue.js 설명서</a>를 참조하세요.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/01/vue-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>버전 관리 이해하기</title>
      <link>http://hgko1207.github.io/2023/12/01/info-5/</link>
      <guid>http://hgko1207.github.io/2023/12/01/info-5/</guid>
      <pubDate>Fri, 01 Dec 2023 05:41:14 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/header/info-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;소개&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소개&quot;&gt;&lt;/a&gt; 소개&lt;/h2&gt;
&lt;p&gt;끊임없이 진화하는 소프트웨어 개발
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/header/info-5.png" alt="" /></p><h2 id="소개"><a class="markdownIt-Anchor" href="#소개"></a> 소개</h2><p>끊임없이 진화하는 소프트웨어 개발 환경에서 버전 제어 개념은 초석이 됩니다. 단독 프로젝트를 진행하든 팀과 협업하든 관계없이 버전 제어 시스템(Version Control System, VCS)은 코드 변경을 관리하고 프로젝트 무결성을 유지하며 원활한 협업을 촉진하는 데 중요한 역할을 합니다.</p><p>이 글에서는 버전 제어의 세계에 대해 자세히 알아보고 버전 제어의 이점, 유형, 널리 사용되는 도구 및 모범 사례를 살펴보겠습니다.</p><h2 id="버전-관리-이해"><a class="markdownIt-Anchor" href="#버전-관리-이해"></a> 버전 관리 이해</h2><p>버전 제어는 시간이 지남에 따라 프로젝트(일반적으로 소스 코드)의 변경 사항을 관리하기 위한 체계적인 접근 방식입니다. 이는 개발자에게 수정 사항을 추적하고 효과적으로 협업하며 필요한 경우 이전 상태로 되돌릴 수 있는 기능을 제공합니다. 이 프로세스를 통해 프로젝트는 체계적으로 정리되고 기록이 보존되며 팀 구성원은 충돌 없이 동시에 작업할 수 있습니다.</p><h2 id="버전-관리의-이점"><a class="markdownIt-Anchor" href="#버전-관리의-이점"></a> 버전 관리의 이점</h2><ol><li><strong>변경 사항 추적(Change Tracking)</strong>: 버전 제어 시스템은 코드베이스에 적용된 모든 변경 사항을 꼼꼼하게 기록합니다. 이 감사 추적을 통해 변경이 발생했을 때 변경한 사람과 변경 이유를 쉽게 식별할 수 있습니다.<br /><br/></li><li><strong>협업(Collaboration)</strong>: 개발자 팀은 프로젝트의 여러 부분에서 동시에 작업할 수 있습니다. 버전 제어 시스템을 사용하면 변경 사항을 원활하게 병합하고 충돌을 방지하며 효율적인 협업을 촉진할 수 있습니다.<br /><br/></li><li><strong>롤백 및 복구(Rollback and Recovery)</strong>: 실수는 발생하지만 버전 제어를 통해 코드베이스의 이전 상태로 되돌릴 수 있습니다. 이 기능은 위험을 완화하고 오류의 영향을 줄입니다.<br /><br/></li><li><strong>분기 및 병합(Branching and Merging)</strong>: 버전 제어 시스템은 개발의 병렬 라인인 분기를 생성하는 기능을 제공하므로 팀은 기본 코드베이스에 영향을 주지 않고 새로운 기능을 실험할 수 있습니다. 이러한 분기를 기본 코드베이스에 다시 병합하는 것은 원활한 프로세스입니다.<br /><br/></li><li><strong>문서화 및 통신(Documentation and Communication)</strong>: 버전 제어의 커밋 메시지는 문서 형식으로 작동하여 특정 변경 사항이 적용된 이유에 대한 통찰력을 제공합니다. 이는 팀 의사소통과 지식 공유에 도움이 됩니다.</li></ol><h2 id="버전-관리-시스템의-유형"><a class="markdownIt-Anchor" href="#버전-관리-시스템의-유형"></a> 버전 관리 시스템의 유형</h2><ol><li><strong>중앙 버전 제어 시스템(Centralized Version Control System, CVCS)</strong>: CVCS에는 전체 프로젝트 기록을 보관하는 중앙 저장소가 있습니다. 개발자는 이 저장소에서 코드를 체크아웃하고 작업한 다음 변경 사항을 다시 커밋합니다. 예로는 CVS 및 Subversion(SVN)이 있습니다.<br /><br/></li><li><strong>분산 버전 제어 시스템(Distributed Version Control System, DVCS)</strong>: Git 및 Mercurial과 같은 DVCS는 각 개발자의 컴퓨터에 저장소의 전체 복사본(클론)을 생성합니다. 이러한 중복성은 협업을 강화하고 변경 사항을 중앙 저장소에 동기화하기 전에 로컬 커밋을 허용합니다.</li></ol><h2 id="인기-있는-버전-관리-도구"><a class="markdownIt-Anchor" href="#인기-있는-버전-관리-도구"></a> 인기 있는 버전 관리 도구</h2><ol><li><strong>Git</strong>: 가장 널리 사용되는 DVCS인 Git은 속도, 유연성 및 분기 기능으로 잘 알려져 있습니다. 개인 개발자부터 Linux와 같은 대규모 오픈 소스 프로젝트에 이르기까지 모든 규모의 프로젝트에서 사용됩니다.<br /><br/></li><li><strong>Subversion(SVN)</strong>: SVN은 비교적 사용자 친화적인 중앙 집중식 버전 제어 시스템입니다. 단순성과 기존 인프라와의 원활한 통합으로 인해 종종 선택됩니다.<br /><br/></li><li><strong>Mercurial</strong>: Git과 유사하게 Mercurial은 또 다른 분산 버전 제어 시스템입니다. 사용하기 쉽고 학습 곡선이 간단한 것으로 알려져 있습니다.</li></ol><h2 id="버전-제어-모범-사례"><a class="markdownIt-Anchor" href="#버전-제어-모범-사례"></a> 버전 제어 모범 사례</h2><ol><li><strong>설명이 포함된 커밋 메시지 사용</strong>: 커밋 메시지는 변경 목적을 간결하게 설명해야 합니다. 잘 작성된 커밋 메시지는 협업과 이해를 돕는 데 큰 도움이 됩니다.<br /><br/></li><li><strong>빈번한 커밋(Commit)</strong>: 특정 변경 사항에 초점을 맞춘 작고 논리적인 커밋을 만듭니다. 이렇게 하면 기록을 더 쉽게 이해하고 문제를 격리할 수 있습니다.<br /><br/></li><li><strong>전략적으로 분기(Branch)</strong>: 새로운 개발을 위한 기능 분기와 문제 해결을 위한 버그 수정 분기를 만듭니다. 이는 메인 브랜치를 안정적으로 유지합니다.<br /><br/></li><li><strong>정기적으로 끌어오기(Pull) 및 푸시(Push)</strong>: 로컬 저장소를 원격 저장소와 동기화하여 최신 변경 사항이 있는지 확인하고 차이를 방지합니다.<br /><br/></li><li><strong>신중한 검토(Review) 및 병합(Merge)</strong>: 분기를 병합하기 전에 코드 변경 사항을 철저히 검토하고 잠재적인 충돌이 있는지 테스트하십시오.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>버전 제어 시스템은 소프트웨어 개발 프로세스를 혁신하여 효율적인 협업, 변경 관리 및 프로젝트 구성을 가능하게 했습니다. 숙련된 개발자이든 이제 막 시작하는 개발자이든 버전 제어 방식을 수용하고 Git과 같은 도구를 활용하면 개발 워크플로우를 크게 향상시킬 수 있습니다. 프로젝트 발전에 대한 체계적인 기록을 유지함으로써 문제를 해결하고 진행 상황을 추적하며 고품질 소프트웨어를 제공할 수 있는 능력을 더 잘 갖추게 됩니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/12/01/info-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue JS 기본 설명</title>
      <link>http://hgko1207.github.io/2023/11/30/vue-2/</link>
      <guid>http://hgko1207.github.io/2023/11/30/vue-2/</guid>
      <pubDate>Thu, 30 Nov 2023 01:27:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/images/thumbnail/vue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Vue 애플리케이션을 시작하려면 명령어을 사용하세요.&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/images/thumbnail/vue.png" alt="" /></p><p>Vue 애플리케이션을 시작하려면 명령어을 사용하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure><p>공식 Vue 프로젝트 스캐폴딩 도구인 <code>create-vue</code>를 설치하고 실행합니다. 설치 시 프로젝트 이름, TypeScript 설정, JSX 및 테스트 지원과 같은 몇 가지 선택적 기능에 대한 프롬프트가 표시됩니다:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">✔ Project name: … &lt;your-project-name&gt;</span><br><span class="line">✔ Add TypeScript? … No / Yes</span><br><span class="line">✔ Add JSX Support? … No / Yes</span><br><span class="line">✔ Add Vue Router <span class="keyword">for</span> Single Page Application development? … No / Yes</span><br><span class="line">✔ Add Pinia <span class="keyword">for</span> state management? … No / Yes</span><br><span class="line">✔ Add Vitest <span class="keyword">for</span> Unit testing? … No / Yes</span><br><span class="line">✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright</span><br><span class="line">✔ Add ESLint <span class="keyword">for</span> code quality? … No / Yes</span><br><span class="line">✔ Add Prettier <span class="keyword">for</span> code formatting? … No / Yes</span><br><span class="line"></span><br><span class="line">Scaffolding project <span class="keyword">in</span> ./&lt;your-project-name&gt;...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>SPA(단일 페이지 애플리케이션)의 경우 Vue 라우터를 포함해야 합니다. SPA를 생성하라는 메시지가 표시되면 긍정적으로 응답합니다.</p><p>옵션에 대해 확신이 서지 않는다면 일단 엔터키를 눌러 <code>No</code>를 선택하면 됩니다.</p><p>프로젝트가 생성되면 지침에 따라 종속 패키지를 설치하고 개발 서버를 시작합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;your-project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="single-page-applicationspa-폴더-구조"><a class="markdownIt-Anchor" href="#single-page-applicationspa-폴더-구조"></a> Single-Page Application(SPA) 폴더 구조</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my-vue-app&#x2F;</span><br><span class="line">|-- public&#x2F;</span><br><span class="line">|   |-- index.html</span><br><span class="line">|</span><br><span class="line">|-- src&#x2F;</span><br><span class="line">|   |-- assets&#x2F;</span><br><span class="line">|   |   |-- logo.png</span><br><span class="line">|</span><br><span class="line">|   |-- components&#x2F;</span><br><span class="line">|   |   |-- HelloWorld.vue</span><br><span class="line">|</span><br><span class="line">|   |-- views&#x2F;</span><br><span class="line">|   |   |-- Home.vue</span><br><span class="line">|   |   |-- About.vue</span><br><span class="line">|</span><br><span class="line">|   |-- App.vue</span><br><span class="line">|   |-- main.js</span><br><span class="line">|</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- babel.config.js</span><br><span class="line">|-- package.json</span><br><span class="line">|-- README.md</span><br><span class="line">|-- vue.config.js</span><br></pre></td></tr></table></figure><p>일반적인 Vue SPA 구조에는 다음이 포함됩니다.</p><ul><li><strong>public/:</strong> 웹 서버에서 직접 제공하는 index.html 및 기타 assets을 포함합니다.</li><li><strong>src/:</strong> assets, components, views, router, App.vue 및 main.js를 포함하여 Vue 애플리케이션의 소스 코드를 보유합니다.</li><li><strong>assets/:</strong> 이미지 및 글꼴과 같은 정적 리소스를 포함합니다.</li><li><strong>components/:</strong> 재사용 가능한 Vue 컴포넌트를 포함합니다.</li><li><strong>views/:</strong> 다양한 views 나 pages 를 나타내는 다양한 컴포넌트가 포함되어 있습니다.</li><li><strong>router/:</strong> Vue Router 관련 파일 및 경로 정의를 포함합니다.</li><li><strong>store/:</strong> 상태 관리를 위해 Vuex를 사용하는 경우 이 폴더에는 Vuex 스토어 관련 파일이 저장됩니다.</li><li><strong>App.vue:</strong> 전체 애플리케이션의 루트 Vue 컴포넌트 및 진입점 역할을 합니다.</li><li><strong>main.js:</strong> Vue 앱을 초기화하고, 라우터를 구성하고, 앱을 DOM에 마운트합니다.</li></ul><p><code>main.js</code> 파일은 애플리케이션을 설정합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.use(router);</span><br><span class="line">app.mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p><code>App.vue</code> 파일</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="script"><a class="markdownIt-Anchor" href="#script"></a> Script</h2><p>기본 포트를 변경하려면 <code>package.json</code>의 <code>script</code> 태그를 사용자 정의 스크립트로 수정하세요.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev-local": "vite --port 3000 --host 0.0.0.0"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>업데이트된 포트에서 애플리케이션을 시작하려면 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev-local</span><br></pre></td></tr></table></figure><h2 id="navigation"><a class="markdownIt-Anchor" href="#navigation"></a> Navigation</h2><p>MPA(Multi-Page Application)와 SPA(Single Page Application)는 웹 애플리케이션 구축을 위한 두 가지 서로 다른 아키텍처 접근 방식입니다. 주요 차이점은 콘텐츠 탐색 및 렌더링을 처리하는 방법에 있습니다.</p><p><strong>MPA</strong></p><ul><li>MPA에서 각 페이지는 일반적으로 별도의 HTML 파일에 해당합니다.</li><li>각 링크나 상호 작용이 서버에 대한 요청을 트리거하고 전체 페이지가 대체되므로 페이지 간 탐색에는 전체 페이지 다시 로드가 포함됩니다.</li><li>서버는 각 페이지의 HTML을 렌더링하고 제공하는 일을 담당합니다.</li></ul><p><strong>SPA</strong></p><ul><li>SPA에는 애플리케이션의 진입점 역할을 하는 단일 HTML 파일이 있습니다.</li><li>애플리케이션 내 탐색은 일반적으로 Vue Router와 같은 클라이언트 측 라우터를 사용하여 JavaScript로 처리됩니다.</li><li>사용자가 애플리케이션과 상호 작용할 때 필요한 구성 요소만 DOM 안팎으로 동적으로 로드되고 교체됩니다.</li></ul><h3 id="performance"><a class="markdownIt-Anchor" href="#performance"></a> Performance</h3><p><strong>MPA</strong></p><ul><li>전체 페이지를 다시 로드하면 특히 콘텐츠가 많은 페이지에서 성능이 느려질 수 있습니다.</li><li>CSS 및 JavaScript와 같은 리소스는 각 페이지 요청마다 새로 로드됩니다.</li></ul><p><strong>SPA</strong></p><ul><li>SPA는 필요한 데이터만 서버에서 가져오고 전체 페이지를 다시 로드하지 않고도 페이지 전환이 더 원활해지기 때문에 더 빠르고 원활한 사용자 환경을 제공할 수 있습니다.</li><li>초기 페이지와 자산이 로드되면 후속 상호 작용에 추가 서버 요청이 필요하지 않으므로 사용자 경험이 더 빨라질 수 있습니다.</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/30/vue-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 컴포넌트 데코레이터(Component Decorator) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/11/28/angular-31/</link>
      <guid>http://hgko1207.github.io/2023/11/28/angular-31/</guid>
      <pubDate>Tue, 28 Nov 2023 01:59:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;에서 &lt;code&gt;@Component&lt;/code&gt; 데코레이터는 재사용 가능한 UI 컴포넌트(Component)를 구축하는 초석입니다. Angular 애플리케이션 내에서 컴포넌트를 처리하고, 인스턴스화하고,
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>에서 <code>@Component</code> 데코레이터는 재사용 가능한 UI 컴포넌트(Component)를 구축하는 초석입니다. Angular 애플리케이션 내에서 컴포넌트를 처리하고, 인스턴스화하고, 사용하는 방법을 정의하는 메타데이터를 제공합니다.</p><p>이 글에서는 <code>@Component</code> 데코레이터를 심층적으로 살펴보고, 다양한 속성에 대해 논의하고, 이러한 속성을 사용하여 코드 복잡성을 관리하는 방법을 설명합니다.</p><h2 id="기본-사항">기본 사항</h2><p><code>@Component</code> 데코레이터는 구성 개체를 인수로 사용하는 함수입니다. 메타데이터를 컴포넌트 클래스와 연결하는 데 사용되므로 Angular가 컴포넌트를 생성하고 렌더링하는 방법을 이해할 수 있습니다.</p><p><code>@Component</code> 데코레이터를 사용하는 간단한 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-example'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./example.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./example.component.scss'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent &#123;</span><br><span class="line">  <span class="comment">// Component logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="속성">속성</h2><p><code>@Component</code> 데코레이터는 컴포넌트의 다양한 측면을 정의하는 다양한 속성을 허용합니다. 가장 일반적으로 사용되는 속성 중 일부를 살펴보겠습니다.</p><ul><li><code>selector</code>: 템플릿에서 이 컴포넌트를 식별하는 CSS 선택자(selector)입니다. Angular는 템플릿에서 해당 선택자를 찾을 때마다 컴포넌트의 인스턴스를 생성하고 삽입합니다.</li><li><code>templateUrl</code>: 컴포넌트의 템플릿이 포함된 외부 HTML 파일의 URL입니다.</li><li><code>template</code>: 컴포넌트의 인라인 HTML 템플릿입니다. <code>templateUrl</code> 또는 <code>template</code> 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다.</li><li><code>styleUrls</code>: 컴포넌트의 템플릿에 적용할 외부 CSS 파일의 배열입니다.</li><li><code>styles</code>: 컴포넌트의 템플릿에 적용할 인라인 CSS 스타일의 배열입니다. <code>styleUrls</code> 또는 <code>styles</code> 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다.</li><li><code>providers</code>: 이 컴포넌트와 해당 하위 컴포넌트에 대한 종속성 주입 공급자의 배열입니다.</li><li><code>encapsulation</code>: 컴포넌트의 템플릿에 스타일이 적용되는 방식을 결정하는 속성입니다. ViewEncapsulation.None, ViewEncapsulation.Emulated 또는 ViewEncapsulation.ShadowDom 으로 설정할 수 있습니다.</li><li><code>changeDetection</code>: 컴포넌트의 변경 감지 전략을 결정하는 속성입니다. ChangeDetectionStrategy.Default 또는 ChangeDetectionStrategy.OnPush 로 설정할 수 있습니다.</li></ul><h2 id="코드-복잡성-관리">코드 복잡성 관리</h2><p><code>@Component</code> 데코레이터에서 사용할 수 있는 다양한 속성을 사용하면 문제를 명확하게 분리하고 컴포넌트의 리소스를 구성하여 코드 복잡성을 관리할 수 있습니다. 다음은 코드 복잡성 관리에 대한 몇 가지 팁입니다.</p><ul><li><p>템플릿(templateUrl)과 스타일(styleUrls)에 별도의 파일 사용: HTML 템플릿과 CSS 스타일을 별도의 파일에 배치하면 컴포넌트 클래스를 로직에 집중하고 유지 관리하기 쉽게 할 수 있습니다.</p></li><li><p>캡슐화(encapsulation) 활용: <code>ViewEncapsulation</code>을 활용하면 컴포넌트 스타일의 범위를 제어하여 원치 않는 부작용을 방지하고 스타일을 더욱 모듈화할 수 있습니다.</p></li><li><p>변경 감지 최적화: 적절한 <code>changeDetection</code> 전략을 선택하면 특히 크고 복잡한 애플리케이션에서 컴포넌트의 성능을 향상시킬 수 있습니다.</p></li></ul><p>예:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewEncapsulation, ChangeDetectionStrategy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-complex'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./complex.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./complex.component.scss'</span>],</span><br><span class="line">  encapsulation: ViewEncapsulation.Emulated,</span><br><span class="line">  changeDetection: ChangeDetectionStrategy.OnPush,</span><br><span class="line">  providers: [CustomService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ComplexComponent &#123;</span><br><span class="line">  <span class="comment">// Component logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론">결론</h2><p>강력하고 효율적인 Angular 컴포넌트를 생성하려면 <code>@Component</code> 데코레이터와 해당 속성을 이해하는 것이 필수적입니다. 다양한 속성을 활용하여 코드 복잡성을 관리하고, 성능을 개선하고, 유지 관리 가능한 모듈식 애플리케이션을 만들 수 있습니다. 계속해서 Angular를 탐색하고 컴포넌트로 작업하면서 코드를 최적화하고 원활한 사용자 경험을 만드는 새로운 방법을 발견하게 될 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/28/angular-31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular CLI] 명령어 사용 및 활용 방법</title>
      <link>http://hgko1207.github.io/2023/11/23/angular-30/</link>
      <guid>http://hgko1207.github.io/2023/11/23/angular-30/</guid>
      <pubDate>Thu, 23 Nov 2023 05:40:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular CLI&lt;/strong&gt;는 개발자가 Angular 애플리케이션을 쉽게 생성, 유지 및 관리하는 데 도움이 되는 강력한 명령줄 인터페이스입니다. 개발 워크플로우를 간소화하고 생산성을 향상시키는 다양한 기능을 제공합니다.&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular CLI</strong>는 개발자가 Angular 애플리케이션을 쉽게 생성, 유지 및 관리하는 데 도움이 되는 강력한 명령줄 인터페이스입니다. 개발 워크플로우를 간소화하고 생산성을 향상시키는 다양한 기능을 제공합니다.</p><p>이 글에서는 필수 Angular CLI 명령어와 이 명령어가 복잡하고 정교한 Angular 애플리케이션을 개발하는 데 어떻게 도움이 되는지 살펴보겠습니다.</p><h2 id="angular-cli-설치"><a class="markdownIt-Anchor" href="#angular-cli-설치"></a> Angular CLI 설치</h2><p>Angular CLI를 사용하려면 시스템에 전역적으로 설치해야 합니다. Node.js와 npm이 설치되어 있는지 확인한 후 다음 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure><h2 id="새로운-angular-애플리케이션-생성"><a class="markdownIt-Anchor" href="#새로운-angular-애플리케이션-생성"></a> 새로운 Angular 애플리케이션 생성</h2><p>새로운 Angular 애플리케이션을 만들려면 <code>ng new</code> 명령어 뒤에 프로젝트 이름을 사용하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-app</span><br></pre></td></tr></table></figure><p>이 명령어는 Angular 애플리케이션에 필요한 파일과 폴더를 포함하여 새 프로젝트 디렉터리를 생성합니다. 또한 필요한 종속성을 설치하고 로컬 개발 서버를 설정합니다.</p><h2 id="실행"><a class="markdownIt-Anchor" href="#실행"></a> 실행</h2><p>라이브 리로딩(live reloading)으로 로컬 개발 서버를 시작하려면 프로젝트의 루트 디렉터리로 이동하여 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng serve</span><br></pre></td></tr></table></figure><p>기본적으로 <code>http://localhost:4200/</code> 주소로 애플리케이션이 실행됩니다.</p><h2 id="component-directive-service-생성"><a class="markdownIt-Anchor" href="#component-directive-service-생성"></a> Component, Directive, Service 생성</h2><p>Angular CLI를 사용하면 Component, Directive, Service, Pipe 및 Guard 와 같은 Angular 애플리케이션의 다양한 파일을 빠르게 생성할 수 있습니다.</p><ul><li>Component 생성</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng generate component my-component</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ng g c my-component</span><br></pre></td></tr></table></figure><ul><li>Directive 생성</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng generate directive my-directive</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ng g d my-directive</span><br></pre></td></tr></table></figure><ul><li>Service 생성</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng generate service my-service</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ng g s my-service</span><br></pre></td></tr></table></figure><ul><li>Module 생성</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng generate module my-module</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ng g m my-module</span><br></pre></td></tr></table></figure><p>이 명령어는 필요한 파일을 생성하고 해당 NgModule을 업데이트하여 새 요소를 등록합니다.</p><h2 id="빌드"><a class="markdownIt-Anchor" href="#빌드"></a> 빌드</h2><p>Angular 애플리케이션의 프로덕션 모드로 빌드를 하려면 다음 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build --prod</span><br></pre></td></tr></table></figure><p>이 명령어는 <code>dist/</code> 폴더에 최적화된 빌드를 생성합니다.</p><h2 id="테스트-실행-및-linting"><a class="markdownIt-Anchor" href="#테스트-실행-및-linting"></a> 테스트 실행 및 Linting</h2><p>Angular CLI에는 테스트 실행 및 코드 Linting에 대한 지원이 내장되어 있습니다. 다음 명령어를 실행하세요.</p><ul><li>Karma로 단위 테스트 실행</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng <span class="built_in">test</span></span><br></pre></td></tr></table></figure><ul><li>Protractor를 사용하여 end-to-end 테스트 실행</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng e2e</span><br></pre></td></tr></table></figure><ul><li>TSLint로 코드 Lint</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng lint</span><br></pre></td></tr></table></figure><h2 id="custom-빌드-구성"><a class="markdownIt-Anchor" href="#custom-빌드-구성"></a> Custom 빌드 구성</h2><p>Angular CLI는 <code>angular.json</code> 파일을 사용하여 프로젝트 구성을 관리합니다. 이 파일을 수정하여 출력 경로, 파일 이름, 최적화 옵션과 같은 빌드 설정을 사용자에 맞게 설정할 수 있습니다.</p><p>예를 들어, <code>outputPath</code> 속성을 업데이트하여 프로덕션 모드 빌드의 출력 경로를 변경할 수 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"configurations": &#123;</span><br><span class="line">  "production": &#123;</span><br><span class="line">    "outputPath": "custom-output-folder",</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="코드-복잡성-및-테마"><a class="markdownIt-Anchor" href="#코드-복잡성-및-테마"></a> 코드 복잡성 및 테마</h2><p>Angular CLI를 사용하면 코드를 Component, Directive, Service로 모듈화하여 애플리케이션의 복잡성을 관리할 수 있습니다. 이는 깨끗하고 체계적인 코드베이스를 유지하는 데 도움이 되므로 애플리케이션을 더 쉽게 확장하고 수정할 수 있습니다.</p><p>테마 설정과 관련하여 Angular CLI는 테마를 직접 처리하지 않지만 CSS나 SCSS 또는 LESS와 같은 전처리기를 사용하여 테마를 프로젝트에 통합할 수 있습니다. Bootstrap, Bulma 또는 Angular Material과 같은 널리 사용되는 CSS 프레임워크를 사용하여 일관되고 시각적으로 매력적인 사용자 인터페이스를 만들 수도 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Angular CLI는 복잡하고 정교한 Angular 애플리케이션을 쉽게 개발하는 데 도움이 되는 강력한 도구입니다. 프로젝트 생성, 유지 관리를 위한 필수 명령어로 워크플로우를 간소화함으로써 고품질 코드를 작성하고 최고의 사용자 경험을 제공하는 데 집중할 수 있습니다.</p><p>Angular CLI와 그 기능을 계속 탐색하면서 생산성을 향상하고 강력하고 확장 가능한 애플리케이션을 구축할 수 있는 더 많은 방법을 찾을 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/23/angular-30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 프레임워크 비교: Angular, React, Vue.js</title>
      <link>http://hgko1207.github.io/2023/11/17/js-dev-10/</link>
      <guid>http://hgko1207.github.io/2023/11/17/js-dev-10/</guid>
      <pubDate>Fri, 17 Nov 2023 06:32:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;웹 개발 세계에서 Angular, React 및 Vue.js와 같은 JavaScript 프레임워크는 개발자가 웹 애플리케이션을 구축할 수 있는 다양한 도구를 제공합니다.&lt;/p&gt;
&lt;p&gt;그러나 각각은 서로 다른 디자인 철학, 학습 곡선(learnin
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>웹 개발 세계에서 Angular, React 및 Vue.js와 같은 JavaScript 프레임워크는 개발자가 웹 애플리케이션을 구축할 수 있는 다양한 도구를 제공합니다.</p><p>그러나 각각은 서로 다른 디자인 철학, 학습 곡선(learning curve) 및 사용 사례를 가지고 있습니다. 다음은 이 세 가지 프레임워크를 비교한 것입니다.</p><h2 id="angular"><a class="markdownIt-Anchor" href="#angular"></a> Angular</h2><h3 id="장점"><a class="markdownIt-Anchor" href="#장점"></a> 장점</h3><ol><li><strong>모든 기능을 갖춘 프레임워크</strong><br />Angular는 광범위한 기능들을 자랑하며 필요한 모든 도구를 포함합니다. 따라서 크고 복잡한 애플리케이션에 적합합니다.<br /><br/></li><li><strong>Type Safety</strong><br />TypeScript 사용 덕분에 컴파일 타임(compile-time) 오류 감지 기능을 제공하여 보다 안전한 코드를 보장합니다.<br /><br/></li><li><strong>강력한 데이터 바인딩</strong><br />Angular의 강력한 기능인 양방향 데이터 바인딩은 원활한 데이터 동기화를 촉진합니다.</li></ol><h3 id="단점"><a class="markdownIt-Anchor" href="#단점"></a> 단점</h3><ol><li><strong>학습 곡선</strong>(Learning Curve)<br />Angular는 학습 곡선이 더 가파르기 때문에 즉 초기에 습득해야 하는 기술 양이 많기 때문에 초보자에게는 다소 어려울 수 있습니다.<br /><br/></li><li><strong>무게</strong><br />Angular는 어떤 경우에는 다른 프레임워크에 비해 무거워서 성능 제한이 발생할 수 있습니다.</li></ol><h2 id="react"><a class="markdownIt-Anchor" href="#react"></a> React</h2><h3 id="장점-2"><a class="markdownIt-Anchor" href="#장점-2"></a> 장점</h3><ol><li><strong>속도와 성능</strong><br />React는 가상 DOM을 사용하여 신속하고 효율적으로 작동하여 애플리케이션 성능을 향상시킵니다.<br /><br/></li><li><strong>모듈성</strong><br />컴포넌트 기반 아키텍처를 통해 React는 모듈식 애플리케이션 구조를 허용합니다.<br /><br/></li><li><strong>광범위한 생태계</strong><br />React는 대규모 커뮤니티를 자랑하며 광범위한 도구 및 라이브러리 생태계의 지원을 받습니다.</li></ol><h3 id="단점-2"><a class="markdownIt-Anchor" href="#단점-2"></a> 단점</h3><ol><li><strong>완전한 프레임워크가 아님</strong><br />React는 오로지 사용자 인터페이스 라이브러리이므로 완전한 프레임워크를 형성하기 위해 다른 라이브러리나 도구와 함께 사용해야 합니다.<br /><br/></li><li><strong>학습 곡선</strong>(Learning Curve)<br />JSX 및 Virtual DOM과 같은 개념은 일부 개발자의 학습 곡선을 약간 증가시킬 수 있습니다.</li></ol><h2 id="vuejs"><a class="markdownIt-Anchor" href="#vuejs"></a> Vue.js</h2><h3 id="장점-3"><a class="markdownIt-Anchor" href="#장점-3"></a> 장점</h3><ol><li><strong>경량</strong><br />Vue.js는 가벼운 성능을 갖춘 작은 크기의 라이브러리입니다.<br /><br/></li><li><strong>쉬운 통합</strong><br />Vue.js는 기존 프로젝트에 쉽게 통합되고 점진적으로 채택될 수 있습니다.<br /><br/></li><li><strong>문서</strong><br />Vue.js는 사용자 친화적인 문서를 제공하여 학습 과정을 촉진합니다.</li></ol><h3 id="단점-3"><a class="markdownIt-Anchor" href="#단점-3"></a> 단점</h3><ol><li><strong>소규모 커뮤니티</strong><br />다른 두 프레임워크에 비해 커뮤니티가 더 작기 때문에 특정 영역에서는 리소스가 더 제한될 수 있습니다.<br /><br/></li><li><strong>엔터프라이즈 수준 애플리케이션에는 적합하지 않습니다.</strong><br />Vue.js는 대규모의 복잡한 프로젝트에서 Angular 및 React에 비해 몇 가지 단점이 있을 수 있습니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 글에서는 각 프레임워크의 기능을 정리했습니다. 어떤 프레임워크를 사용할지는 프로젝트 요구 사항, 팀의 전문 지식, 선호도에 따라 선택됩니다. Angular, React 및 Vue.js는 모두 강력하고 효과적인 도구이므로 선택 시 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://angular.io/" target="_blank" rel="noopener">https://angular.io/</a></li><li><a href="https://react.dev/" target="_blank" rel="noopener">https://react.dev/</a></li><li><a href="https://vuejs.org/" target="_blank" rel="noopener">https://vuejs.org/</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/17/js-dev-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Visual Studio Code] 생산성 향상을 위한 팁</title>
      <link>http://hgko1207.github.io/2023/11/03/info-4/</link>
      <guid>http://hgko1207.github.io/2023/11/03/info-4/</guid>
      <pubDate>Fri, 03 Nov 2023 06:54:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Visual Studio Code&lt;/strong&gt;(VS Code)는 개발 세계를 강타한 인기 있고 강력한 소스 코드 편집기입니다. 유연성, 확장성 및 풍부한 생태계 덕분에 많은 개발자가 선택합니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 코딩 경
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Visual Studio Code</strong>(VS Code)는 개발 세계를 강타한 인기 있고 강력한 소스 코드 편집기입니다. 유연성, 확장성 및 풍부한 생태계 덕분에 많은 개발자가 선택합니다.</p><p>이 글에서는 코딩 경험을 향상하고 생산성을 높이는 데 도움이 되는 몇 가지 유용한 팁과 테마를 공유하겠습니다.</p><h2 id="키보드-단축키-익히기">키보드 단축키 익히기</h2><p>키보드 단축키를 사용하면 시간과 노력을 절약하여 효율성을 높일 수 있습니다. 시작하는 데 도움이 되는 몇 가지 필수 단축키는 다음과 같습니다.</p><ul><li><code>Ctrl+P</code> 또는<code> Cmd+P</code>: 작업 공간에서 파일을 빠르게 엽니다.</li><li><code>Ctrl+Shift+F</code> 또는 <code>Cmd+Shift+F</code>: 전체 프로젝트에서 검색합니다.</li><li><code>Alt+Up</code> 또는 <code>Alt+Down</code>: 현재 줄을 위나 아래로 이동합니다.</li><li><code>Ctrl+D</code> 또는 <code>Cmd+D</code>: 현재 단어의 다음 항목을 선택합니다.</li><li><code>Ctrl+Shift+L</code> 또는 <code>Cmd+Shift+L</code>: 현재 단어와 일치하는 항목을 모두 선택합니다.</li></ul><p><strong>File &gt; Preferences &gt; Keyboard Shortcuts</strong> 로 이동하여 커스텀 키보드 단축키를 만들 수도 있습니다.</p><h2 id="통합-터미널-활용">통합 터미널 활용</h2><p>VS Code에는 워크플로우를 간소화하는 데 도움이 되는 통합 터미널이 함께 제공됩니다. 몇 가지 편리한 단축키가 포함되어 있습니다.</p><ul><li><code>Ctrl+</code> 또는 <code>Cmd+</code>: 터미널을 열거나 닫습니다.</li><li><code>Ctrl+Shift+5</code> 또는 <code>Cmd+Shift+5</code>: 터미널을 분할합니다.</li></ul><p><strong>File &gt; Preferences &gt; Settings</strong> 으로 이동하여 &quot;terminal&quot;을 검색하여 터미널을 커스터 마이징할 수도 있습니다.</p><h2 id="방해-없는-코딩을-위한-Zen-모드">방해 없는 코딩을 위한 Zen 모드</h2><p>Zen 모드는 모든 UI(상태 표시줄, 활동 표시줄, 패널 및 사이드바)를 숨기고 전체 화면에 편집기만 표시하는 VS Code의 기능입니다. <code>Ctrl+K Z</code> 또는 <code>Cmd+K Z</code>로 활성화하세요. Zen 모드를 종료하려면 Esc를 두 번 누릅니다.</p><h2 id="더-빠른-개발을-위한-코드-조각-Snippets">더 빠른 개발을 위한 코드 조각(Snippets)</h2><p>코드 조각(Snippets)은 자동으로 코드를 삽입하는 템플릿입니다. VS Code에는 널리 사용되는 언어에 대한 코드 조각이 내장되어 있으며 <strong>File &gt; Preferences &gt; Configure User Snippets</strong> 으로 이동하여 자신만의 코드 조각을 만들 수 있습니다. 다양한 언어 및 프레임워크에 대해 미리 만들어진 코드 조각을 사용하여 확장 프로그램을 설치할 수도 있습니다.</p><h2 id="편안한-코딩-환경을-위한-테마-Theme">편안한 코딩 환경을 위한 테마(Theme)</h2><p>VS Code는 코딩 환경을 커스터 마이징 할 수 있는 다양한 테마를 제공합니다. 다음은 인기 있는 것들입니다.</p><ul><li>Dark+ (default dark theme)</li><li>Light+ (default light theme)</li><li>Monokai</li><li>Solarized Dark</li><li>Dracula</li></ul><p><strong>File &gt; Preferences &gt; Theme &gt; Color Theme</strong> 로 이동하여 테마를 변경할 수 있습니다. 더 많은 테마를 탐색하려면 Visual Studio Code Marketplace를 방문하여 &quot;theme&quot;를 검색하세요.</p><h2 id="향상된-기능을-위한-확장-Extension">향상된 기능을 위한 확장(Extension)</h2><p>Extension 은 VS Code의 기능을 크게 확장할 수 있습니다. 일부 인기 있는 확장 기능은 다음과 같습니다.</p><ul><li>Prettier: 일련의 규칙에 따라 코드 형식을 자동으로 지정하는 코드 포맷터입니다.</li><li>ESLint: 코드 일관성을 유지하고 버그를 조기에 발견하는 데 도움이 되는 린터(linter)입니다.</li><li>Live Server: 정적 및 동적 페이지에 대한 라이브 다시 로드를 통해 로컬 개발 서버를 시작합니다.</li><li>GitLens: VS Code 내에서 Git 기능을 강화하세요.</li></ul><p>확장 프로그램을 관리하려면 활동 표시줄에서 확장 프로그램(Extensions) 아이콘을 클릭하거나 <code>Ctrl+Shift+X</code> 또는 <code>Cmd+Shift+X</code>를 누르세요.</p><h2 id="결론">결론</h2><p>Visual Studio Code는 생산성을 높이고 코딩 환경을 향상할 수 있는 수많은 방법을 제공합니다. 키보드 단축키를 익히고, 통합 터미널을 활용하고, Zen 모드를 사용하고, 코드 조각을 만들고, 테마를 커스터 마이징하고, 강력한 확장 기능을 설치함으로써 이 다재다능한 편집기의 잠재력을 진정으로 활용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/03/info-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] ChangeDetectorRef: 수동 변경 감지에 대해 자세히 알아보기</title>
      <link>http://hgko1207.github.io/2023/11/02/angular-29/</link>
      <guid>http://hgko1207.github.io/2023/11/02/angular-29/</guid>
      <pubDate>Thu, 02 Nov 2023 00:54:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;변경 감지&lt;/strong&gt;(Change Detection)는 Angular 애플리케이션의 중요한 측면으로, UI가 애플리케이션 상태와 동기화된 상태를 유지하도록 보장합니다. Angular는 효율적인 기본(default) 변경 감지 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>변경 감지</strong>(Change Detection)는 Angular 애플리케이션의 중요한 측면으로, UI가 애플리케이션 상태와 동기화된 상태를 유지하도록 보장합니다. Angular는 효율적인 기본(default) 변경 감지 전략을 제공하지만 성능 최적화나 복잡한 사용 사례에는 보다 세부적인 접근 방식이 필요한 경우가 있습니다.</p><p>이 글에서는 <strong>ChangeDetectorRef</strong>의 강력한 기능을 심층적으로 살펴보고 해당 방법을 검토하고 잠재력을 최대한 보여주는 예를 보여 드리겠습니다.</p><h2 id="ChangeDetectorRef-이해">ChangeDetectorRef 이해</h2><p><code>ChangeDetectorRef</code>는 변경 감지 메커니즘에 대한 직접적인 인터페이스를 제공하는 Angular 클래스입니다. 이를 통해 개발자는 변경 감지를 수동으로 트리거(trigger)하고, 변경 감지 트리에서 컴포넌트를 분리하거나 다시 연결하고, 향후 변경 감지를 위해 컴포넌트를 표시할 수 있습니다. <code>ChangeDetectorRef</code>를 사용하면 개발자는 변경 감지 프로세스를 더 효과적으로 제어할 수 있어 애플리케이션의 성능과 유연성이 향상됩니다.</p><p><code>ChangeDetectorRef</code>가 제공하는 주요 메소드는 다음과 같습니다.</p><ul><li><code>detectorChanges()</code>: 현재 컴포넌트와 해당 하위 컴포넌트에 대한 변경 감지를 수동으로 트리거합니다.</li><li><code>markForCheck()</code>: 다음 변경 감지 주기 동안 현재 컴포넌트와 해당 상위 컴포넌트에 변경 감지가 필요한 것으로 표시합니다.</li><li><code>detach()</code>: 변경 감지 트리에서 현재 컴포넌트를 분리하여 이 컴포넌트와 해당 하위 컴포넌트에 대한 자동 변경 감지를 효과적으로 중지합니다.</li><li><code>reattach()</code>: 현재 컴포넌트를 변경 감지 트리에 다시 연결하여 자동 변경 감지를 다시 한 번 활성화합니다.</li></ul><h2 id="예제-1-동적-컴포넌트-로딩-및-변경-감지">예제 1: 동적 컴포넌트 로딩 및 변경 감지</h2><p>사용자 상호 작용에 따라 컴포넌트가 동적으로 로드되는 애플리케이션을 상상해 보세요. 이러한 시나리오에서는 <code>ChangeDetectorRef</code>를 사용하여 변경 감지를 최적화하고 필요한 경우에만 UI가 업데이트되도록 할 수 있습니다.</p><p>먼저 컴포넌트를 동적으로 로드하는 디렉티브을 만들어 보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ComponentFactoryResolver, Directive, Input, OnInit, ViewContainerRef &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appDynamicComponentLoader]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicComponentLoaderDirective <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">'appDynamicComponentLoader'</span>) component: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> viewContainerRef: ViewContainerRef, <span class="keyword">private</span> componentFactoryResolver: ComponentFactoryResolver</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = <span class="keyword">this</span>.componentFactoryResolver.resolveComponentFactory(<span class="keyword">this</span>.component);</span><br><span class="line">    <span class="keyword">this</span>.viewContainerRef.createComponent(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 사용자 입력에 따라 동적으로 다양한 컴포넌트를 로드하는 컨테이너 컴포넌트를 만들어 보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ComponentRef, ViewChild &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DynamicComponentLoaderDirective &#125; <span class="keyword">from</span> <span class="string">'./dynamic-component-loader.directive'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-container'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ng-container *appDynamicComponentLoader="selectedComponent"&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)="loadComponent('A')"&gt;Load Component A&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)="loadComponent('B')"&gt;Load Component B&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ContainerComponent &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(DynamicComponentLoaderDirective, &#123; <span class="keyword">static</span>: <span class="literal">true</span> &#125;) dynamicComponentLoader: DynamicComponentLoaderDirective;</span><br><span class="line"></span><br><span class="line">  selectedComponent: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  loadComponent(<span class="keyword">type</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selectedComponent = <span class="keyword">type</span> === <span class="string">'A'</span> ? ComponentA : ComponentB;</span><br><span class="line">    <span class="keyword">this</span>.dynamicComponentLoader.detectChanges();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 새 컴포넌트가 로드될 때 변경 감지를 수동으로 트리거하기 위해 <code>discoverChanges()</code> 메서드를 사용하고 있습니다.</p><h2 id="예제-2-Observable을-사용한-고급-변경-감지">예제 2: Observable을 사용한 고급 변경 감지</h2><p>다양한 컴포넌트가 Observable을 통해 데이터 업데이트를 받는 애플리케이션을 생각해 보세요. 우리는 특정 컴포넌트가 새 데이터를 수신할 때만 발생하도록 변경 감지를 최적화하려고 합니다.</p><p>먼저 데이터 서비스를 만듭니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BehaviorSubject &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DataService &#123;</span><br><span class="line">  <span class="keyword">private</span> dataSubject = <span class="keyword">new</span> BehaviorSubject&lt;<span class="built_in">any</span>[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  data$ = <span class="keyword">this</span>.dataSubject.asObservable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 데이터 서비스를 사용하고 여러 하위 컴포넌트가 있는 상위 컴포넌트를 만들어 보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'./data.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-parent'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Parent Component&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;app-child *ngFor="let item of items; index as i" [data]="item" [index]="i"&gt;&lt;/app-child&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParentComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  items: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> dataService: DataService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataService.data$.subscribe(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 데이터 업데이트를 수신하고 <code>ChangeDetectorRef</code>를 사용하는 하위 컴포넌트를 만듭니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input, OnInit, ChangeDetectorRef &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'./data.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-child'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div *ngIf="data"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;Child Component &#123;&#123; index &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; data &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ChildComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>() data: <span class="built_in">any</span>;</span><br><span class="line">  <span class="meta">@Input</span>() index: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cdr: ChangeDetectorRef, <span class="keyword">private</span> dataService: DataService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cdr.detach();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dataService.data$.subscribe(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newData = data[<span class="keyword">this</span>.index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newData !== <span class="keyword">this</span>.data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = newData;</span><br><span class="line">        <span class="keyword">this</span>.cdr.markForCheck();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>detach()</code>를 사용하여 변경 감지 트리에서 하위 컴포넌트를 분리했습니다. 그런 다음 <code>markForCheck()</code>를 사용하여 새 데이터가 수신될 때 변경 사항 감지를 위한 컴포넌트를 표시했습니다.</p><h2 id="결론">결론</h2><p><code>ChangeDetectorRef</code>는 개발자에게 Angular의 변경 감지 프로세스를 수동으로 제어할 수 있는 강력한 방법을 제공합니다. 기능을 이해하고 방법을 활용하면 성능을 위해 애플리케이션을 최적화하고 복잡한 사용 사례를 쉽게 처리할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/02/angular-29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] Pipe 소개 및 사용방법</title>
      <link>http://hgko1207.github.io/2023/11/01/angular-28/</link>
      <guid>http://hgko1207.github.io/2023/11/01/angular-28/</guid>
      <pubDate>Wed, 01 Nov 2023 06:33:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular 파이프&lt;/strong&gt;(Pipe)는 Angular 애플리케이션의 필수 부분으로, 데이터를 변환하고 형식을 지정하는 간단한 방법을 제공합니다. 파이프를 사용하면 필요에 맞게 데이터를 쉽게 조작하고 이해하기 쉬운 형식으로
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular 파이프</strong>(Pipe)는 Angular 애플리케이션의 필수 부분으로, 데이터를 변환하고 형식을 지정하는 간단한 방법을 제공합니다. 파이프를 사용하면 필요에 맞게 데이터를 쉽게 조작하고 이해하기 쉬운 형식으로 표시할 수 있습니다.</p><p>이 글에서는 <strong>AsyncPipe, CurrentPipe, DatePipe, DecimalPipe, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe 및 UpperCasePipe</strong>를 포함한 다양한 유형의 Angular 파이프를 살펴보겠습니다. 또한 Angular 파이프를 효과적으로 사용하기 위한 모범 사례에 대해서도 알아보겠습니다.</p><h2 id="asyncpipe"><a class="markdownIt-Anchor" href="#asyncpipe"></a> AsyncPipe</h2><p>AsyncPipe는 Angular에서 비동기 데이터를 처리하는 데 사용됩니다. 이를 통해 HTTP 요청 또는 Promise와 같은 비동기 작업에서 반환된 데이터를 표시할 수 있습니다. AsyncPipe는 Observable 또는 Promise를 구독(subscribe)하고 데이터가 변경되면 자동으로 뷰를 업데이트합니다. 다음은 AsyncPipe를 사용하여 비동기 데이터를 처리하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; (data$ | async)?.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="currencypipe"><a class="markdownIt-Anchor" href="#currencypipe"></a> CurrencyPipe</h2><p>CurrencyPipe는 Angular에서 통화(currency) 값의 형식을 지정하는 데 사용됩니다. 통화 기호, 천 단위 및 소수 구분 기호를 사용하여 특정 통화 형식으로 숫자를 표시할 수 있습니다. 다음은 통화 값 형식을 지정하기 위해 CurrencyPipe를 사용하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 10000 | currency:'USD':'symbol':'1.2-2' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Output: '$10,000.00' --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="datepipe"><a class="markdownIt-Anchor" href="#datepipe"></a> DatePipe</h2><p>DatePipe는 Angular에서 날짜 형식을 지정하는 데 사용됩니다. ‘short’, ‘medium’, ‘long’ 등 특정 형식으로 날짜를 표시할 수 있습니다. 커스텀(custom) 날짜 형식을 지정할 수도 있습니다. 다음은 DatePipe를 사용하여 날짜 형식을 지정하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; today | date:'shortDate' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Output: '11/1/23' --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="decimalpipe"><a class="markdownIt-Anchor" href="#decimalpipe"></a> DecimalPipe</h2><p>DecimalPipe는 Angular에서 십진수 값의 형식을 지정하는 데 사용됩니다. 소수 구분 기호와 천 단위 구분 기호를 사용하여 특정 소수 형식으로 숫자를 표시할 수 있습니다. 다음은 DecimalPipe를 사용하여 10진수 값의 형식을 지정하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 1000.5 | number:'1.2-2' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Output: '1,000.50' --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="i18npluralpipe"><a class="markdownIt-Anchor" href="#i18npluralpipe"></a> I18nPluralPipe</h2><p>I18nPluralPipe는 Angular에서 복수형을 처리하는 데 사용됩니다. 항목 수에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nPluralPipe를 사용하여 복수화를 처리하는 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="string">'Message 1'</span>];</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; items.length &#125;&#125; / &#123;&#123; items.length | i18nPlural : &#123; '=0': 'No items', '=1': '1 item', other: '# items' &#125; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Output: '1 / 1 item' --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="i18nselectpipe"><a class="markdownIt-Anchor" href="#i18nselectpipe"></a> I18nSelectPipe</h2><p>I18nSelectPipe는 Angular에서 select 문을 처리하는 데 사용됩니다. 조건에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nSelectPipe를 사용하여 select 문을 처리하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; gender | select: &#123; 'male': 'He', 'female': 'She', 'other': 'They' &#125; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="jsonpipe"><a class="markdownIt-Anchor" href="#jsonpipe"></a> JsonPipe</h2><p>JsonPipe는 Angular에서 JSON 데이터를 표시하는 데 사용됩니다. JSON 데이터를 읽을 수 있는 형식으로 표시할 수 있습니다. 다음은 JsonPipe를 사용하여 JSON 데이터를 표시하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; data | json &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="lowercasepipe"><a class="markdownIt-Anchor" href="#lowercasepipe"></a> LowerCasePipe</h2><p>LowerCasePipe는 문자열을 소문자로 변환하는 데 사용됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 'HELLO WORLD' | lowercase &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- Output: hello world --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="percentpipe"><a class="markdownIt-Anchor" href="#percentpipe"></a> PercentPipe</h2><p>PercentPipe는 숫자를 백분율로 형식화하는 데 사용됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 0.25 | percent &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- Output: 25% --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="slicepipe"><a class="markdownIt-Anchor" href="#slicepipe"></a> SlicePipe</h2><p>SlicePipe는 배열 또는 문자열의 조각을 추출하는 데 사용됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 'abcdefghijk' | slice:0:5 &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- Output: abcde --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="titlecasepipe"><a class="markdownIt-Anchor" href="#titlecasepipe"></a> TitleCasePipe</h2><p>TitleCasePipe는 문자열을 title 케이스로 변환하는 데 사용됩니다(각 단어의 첫 글자를 대문자로 표시).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 'hello world' | titlecase &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- Output: Hello World --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="uppercasepipe"><a class="markdownIt-Anchor" href="#uppercasepipe"></a> UpperCasePipe</h2><p>UpperCasePipe는 문자열을 대문자로 변환하는 데 사용됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 'hello world' | uppercase &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- Output: HELLO WORLD --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 글에서는 다양한 Angular 파이프와 그 기능을 살펴보았습니다. 파이프는 애플리케이션에서 데이터를 쉽게 변환하고 형식을 지정할 수 있게 해주는 Angular의 중요한 기능입니다.</p><p>이러한 파이프를 이해하고 활용함으로써 Angular 애플리케이션을 보다 효율적이고 동적이고 사용자 친화적으로 만들 수 있습니다.</p><p>특정 사용 사례에 적합한 파이프를 사용하고 파이프를 철저히 테스트하는 것을 잊지 마세요.</p><p>이 글를 통해 Angular 파이프에 대한 더 나은 이해와 응용 프로그램에서 이를 효과적으로 사용하는 방법을 얻을 수 있기를 바랍니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/11/01/angular-28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 데코레이터(Decorator) 소개 및 사용방법(2)</title>
      <link>http://hgko1207.github.io/2023/10/31/angular-27/</link>
      <guid>http://hgko1207.github.io/2023/10/31/angular-27/</guid>
      <pubDate>Tue, 31 Oct 2023 02:32:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular Decorator&lt;/strong&gt;는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular Decorator</strong>는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다.</p><p>이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다.</p><h2 id="ngmodule"><a class="markdownIt-Anchor" href="#ngmodule"></a> @NgModule</h2><p><code>@NgModule</code>은 Angular 모듈을 생성하고 구성하는 데 사용되는 데코레이터입니다. Angular 모듈은 components, services, directives, pipes 등과 같은 애플리케이션의 다양한 부분을 위한 컨테이너입니다. 이는 애플리케이션의 여러 부분 간의 종속성을 구성하고 관리하는 데 사용됩니다.</p><p><code>@NgModule</code> 데코레이터를 사용하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [BrowserModule],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 BrowserModule과 AppComponent를 가져오고 declarations 배열에서 AppComponent를 선언합니다. 또한 bootstrap 컴포넌트를 AppComponent로 지정합니다.</p><p>@NgModule 데코레이터에는 구성할 수 있는 여러 속성이 있습니다.</p><ul><li>declarations: 이 모듈에 속하는 components, directives 및 pipes의 배열입니다.</li><li>imports: 이 모듈이 의존하는 모듈의 배열입니다.</li><li>exports: 다른 모듈에서 사용할 수 있는 components, directives 및 pipes의 배열입니다.</li><li>providers: 이 모듈에서 제공하는 서비스 배열입니다.</li><li>bootstrap: 이 모듈에 의해 부트스트랩되어야 하는 주요 컴포넌트입니다.</li></ul><p>@NgModule 데코레이터를 사용하면 Angular 애플리케이션에서 모듈을 쉽게 만들고 관리할 수 있습니다.</p><h2 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> @Optional</h2><p><code>@Optional</code> 데코레이터는 종속성을 컴포넌트나 서비스에 주입할 때 종속성을 선택적으로 허용하는 데 사용됩니다. 종속성을 찾을 수 없는 경우 injector 는 오류를 발생시키지 않고 대신 종속성에 대해 <code>null</code> 값을 제공합니다.</p><p>예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Optional &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MyService &#125; <span class="keyword">from</span> <span class="string">'./my.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Optional</span>() <span class="keyword">private</span> myService: MyService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> message(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.myService) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.myService.getMessage();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'MyService not available.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>MyService</code> 종속성은 <code>@Optional</code> 데코레이터를 사용하여 선택 사항으로 표시됩니다. 서비스를 찾을 수 없으면 <code>message()</code> 메서드는 오류를 발생시키는 대신 기본 문자열을 반환합니다.</p><p>선택 사항으로 표시된 종속성이 실제로 컴포넌트나 서비스의 올바른 작동을 위해 필요한 경우 <code>@Optional</code> 데코레이터를 사용해서는 안 된다는 점에 유의하는 것이 중요합니다. 대신 종속성을 필수로 표시하고 적절한 오류 처리를 구현해야 합니다.</p><h2 id="self"><a class="markdownIt-Anchor" href="#self"></a> @Self</h2><p><code>@Self</code> 데코레이터는 종속성 해결 범위를 현재 컴포넌트 또는 디렉티브 인스턴스로 제한하는 데 사용됩니다. 즉, Angular는 컴포넌트나 디렉티브의 자체 인젝터에서만 종속성을 찾고 상위 인젝터에서는 찾지 않습니다.</p><p><code>@Self</code>를 사용하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Self &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MyService &#125; <span class="keyword">from</span> <span class="string">'./my-service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">  providers: [MyService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  message: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Self</span>() <span class="keyword">private</span> myService: MyService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="keyword">this</span>.myService.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>@Self</code> 데코레이터를 사용하여 <code>MyService</code> 종속성을 <code>MyComponent</code> 컴포넌트에 주입합니다. <code>MyService</code> 종속성은 컴포넌트 수준에서 정의됩니다. 즉, 현재 컴포넌트에만 사용할 수 있고 상위 컴포넌트에는 사용할 수 없습니다.</p><p><code>MyService</code> 종속성이 <code>AppModule</code> 또는 상위 컴포넌트와 같이 더 높은 수준에서 정의된 경우 Angular는 이를 찾을 때까지 현재 컴포넌트의 인젝터, 그 다음 상위 인젝터 등에서 이를 찾습니다. 그러나 <code>@Self</code>데코레이터를 사용하면 종속성 해결 범위를 현재 컴포넌트로만 제한합니다.</p><p>요약하자면, <code>@Self</code> 데코레이터는 상위 컴포넌트나 디렉티브가 아닌 현재 컴포넌트나 디렉티브의 컨텍스트 내에서만 종속성을 확인하는 데 사용됩니다.</p><h2 id="skipself"><a class="markdownIt-Anchor" href="#skipself"></a> @SkipSelf</h2><p><code>@SkipSelf</code> 데코레이터는 Angular에서 컴포넌트 계층 내 서비스의 가시성과 주입을 제어하는 데 사용됩니다. 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 이를 찾기 시작하고 요청된 서비스를 찾거나 트리 상단에 도달할 때까지 인젝터 트리를 탐색합니다.</p><p>기본적으로 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 해당 서비스를 찾습니다. 즉, 컴포넌트와 모든 하위 컴포넌트에서 서비스를 사용할 수 있다는 뜻입니다. 그러나 어떤 경우에는 현재 인젝터를 건너뛰고 상위 인젝터에서 서비스를 찾을 수 있습니다. 이는 서비스가 동일한 상위를 가진 여러 컴포넌트 간에 공유된다는 의미입니다.</p><p><code>@SkipSelf</code> 데코레이터는 Angular에게 현재 인젝터를 건너뛰고 상위 인젝터에서 요청된 서비스를 찾도록 지시하는 데 사용됩니다. 이는 상위가 동일하지만 서로 직접적으로 관련되지 않은 여러 컴포넌트 간에 서비스를 공유하려는 경우에 유용합니다.</p><p><code>@SkipSelf</code> 데코레이터를 사용하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Inject, SkipSelf &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MyService &#125; <span class="keyword">from</span> <span class="string">'./my.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-child-component'</span>,</span><br><span class="line">  template: <span class="string">` &lt;p&gt;My Child Component&lt;/p&gt; `</span>,</span><br><span class="line">  providers: [&#123; provide: MyService, useValue: &#123; message: <span class="string">'Hello from child component!'</span> &#125; &#125;],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyChildComponent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@SkipSelf</span>() <span class="keyword">private</span> myService: MyService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.myService.message); <span class="comment">// Output: "Hello from parent component!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>MyChildComponent</code>는 <code>@SkipSelf</code> 데코레이터를 사용하여 상위 인젝터에서 <code>MyService</code>를 요청합니다. 상위 컴포넌트는 providers 배열을 사용하여 <code>MyService</code>를 제공합니다. 이는 모든 하위 컴포넌트에서 서비스를 사용할 수 있음을 의미합니다. <code>MyChildComponent</code>가 초기화되면 상위 컴포넌트의 메시지를 기록합니다.</p><p>전반적으로 <code>@SkipSelf</code> 데코레이터는 동일한 부모를 가진 여러 컴포넌트 간에 서비스를 공유하고 동일한 컴포넌트 계층 내에서 동일한 서비스를 여러 번 주입하지 않으려는 경우에 유용합니다.</p><h2 id="viewchild"><a class="markdownIt-Anchor" href="#viewchild"></a> @ViewChild</h2><p><code>@ViewChild</code> 데코레이터는 컴포넌트의 템플릿 보기에서 element 또는 컴포넌트의 참조를 가져오는 데 사용됩니다. 하위 컴포넌트 또는 상위 컴포넌트에 있는 element의 속성 및 메서드에 액세스하는 데 사용할 수 있습니다.</p><p><code>@ViewChild</code>와 함께 사용할 수 있는 selectors에는 두 가지 유형이 있습니다.</p><ol><li>Component Selector가 사용되면 <code>@ViewChild</code>는 컴포넌트 인스턴스에 대한 참조를 반환합니다.</li></ol><p>다음은 Component Selector와 함께 <code>@ViewChild</code>를 사용하는 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ChildComponent &#125; <span class="keyword">from</span> <span class="string">'./child.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'parent-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;child-component&gt;&lt;/child-component&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParentComponent &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(ChildComponent) childComponentRef: ChildComponent;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.childComponentRef.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>@ViewChild</code>를 사용하여 <code>ChildComponent</code> 인스턴스에 대한 참조를 가져온 다음 <code>doSomething</code> 메서드를 호출하는 데 사용합니다.</p><ol start="2"><li>템플릿 참조 변수(Template Reference Variable): 템플릿 참조 변수가 사용되면 <code>@ViewChild</code>는 해당 변수와 연결된 요소 또는 컴포넌트에 대한 참조를 반환합니다.</li></ol><p>다음은 템플릿 참조 변수와 함께 <code>@ViewChild</code>를 사용하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span> #<span class="attr">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ChildComponent &#125; <span class="keyword">from</span> <span class="string">'./child.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'parent-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;child-component #child&gt;&lt;/child-component&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParentComponent &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">'child'</span>) childComponentRef: ChildComponent;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.childComponentRef.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>@ViewChild</code>는 템플릿 참조 변수 <code>#child</code>를 사용하여 <code>ChildComponent</code> 인스턴스에 대한 참조를 가져오는 데 사용됩니다.</p><p><code>@ViewChild</code>는 하위 컴포넌트가 상위 컴포넌트보다 먼저 렌더링되는 경우에만 작동한다는 점에 유의하는 것이 중요합니다. 상위 컴포넌트가 렌더링되기 전에 하위 컴포넌트에 액세스하려고 하면 결과가 정의되지 않습니다. 이를 방지하려면 <code>ngAfterViewInit()</code> 생명주기 훅 메소드를 사용하여 <code>@ViewChild</code>로 액세스를 시도하기 전에 하위 컴포넌트가 렌더링되었는지 확인할 수 있습니다.</p><h2 id="viewchildren"><a class="markdownIt-Anchor" href="#viewchildren"></a> @ViewChildren</h2><p><code>@ViewChildren</code> 데코레이터는 컴포넌트 또는 디렉티브의 템플릿에서 selector 와 일치하는 요소의 <code>QueryList</code>를 가져오는 데 사용됩니다.</p><p>다음은 <code>@ViewChildren</code>을 사용하여 특정 디렉티브가 있는 하위 요소의 <code>QueryList</code>를 가져오는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Directive, ViewChildren &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[myDirective]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyDirective &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-component'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div myDirective&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div myDirective&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="meta">@ViewChildren</span>(MyDirective) myDirectives: QueryList&lt;MyDirective&gt;;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="comment">// Access the elements with MyDirective</span></span><br><span class="line">    <span class="keyword">this</span>.myDirectives.forEach(<span class="function">(<span class="params">directive</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(directive);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>@ViewChildren</code>을 사용하여 <code>MyComponent</code> 템플릿의 <code>MyDirective</code> 디렉티브가 있는 요소의 <code>QueryList</code>를 가져옵니다. <code>ngAfterViewInit</code> 생명주기 훅 메소드는 요소에 액세스하고 이를 콘솔에 기록하는 데 사용됩니다.</p><p><code>@ViewChildren</code> 데코레이터는 템플릿의 요소와 일치하도록 디렉티브 유형 대신 문자열 selector를 사용할 수도 있습니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이러한 데코레이터를 적절하게 사용하면 Angular 컴포넌트, 디렉티브 및 서비스의 기능을 향상하고 필요한 상용구 코드의 양을 줄일 수 있습니다. 각 데코레이터는 고유한 목적을 수행하며 사용법을 익히면 강력하고 효율적인 Angular 애플리케이션을 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/31/angular-27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 데코레이터(Decorator) 소개 및 사용방법(1)</title>
      <link>http://hgko1207.github.io/2023/10/30/angular-26/</link>
      <guid>http://hgko1207.github.io/2023/10/30/angular-26/</guid>
      <pubDate>Mon, 30 Oct 2023 03:24:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular Decorator&lt;/strong&gt;는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular Decorator</strong>는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다.</p><p>이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다.</p><h2 id="component"><a class="markdownIt-Anchor" href="#component"></a> @Component</h2><p><code>@Component</code> 데코레이터는 Angular에서 새 컴포넌트(Component)를 정의하는 데 사용됩니다. selector, template, styles 등과 같은 컴포넌트에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="directive"><a class="markdownIt-Anchor" href="#directive"></a> @Directive</h2><p><code>@Directive</code> 데코레이터는 Angular에서 새로운 디렉티브(Directive)을 만드는 데 사용됩니다. selector, inputs, outputs 등과 같은 지시어에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appMyDirective]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyDirective &#123;</span><br><span class="line">  <span class="meta">@Input</span>() appMyDirective: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="injectable"><a class="markdownIt-Anchor" href="#injectable"></a> @Injectable</h2><p><code>@Injectable</code> 데코레이터는 Angular에서 새로운 서비스를 정의하는 데 사용됩니다. dependencies, scope 등과 같은 서비스에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyService &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="pipe"><a class="markdownIt-Anchor" href="#pipe"></a> @Pipe</h2><p><code>@Pipe</code> 데코레이터는 Angular에서 새 파이프를 만드는 데 사용됩니다. name, pureness 등과 같은 파이프에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pipe</span>(&#123;</span><br><span class="line">  name: <span class="string">'myPipe'</span>,</span><br><span class="line">  pure: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyPipe <span class="keyword">implements</span> PipeTransform &#123;</span><br><span class="line">  transform(value: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> @Input</h2><p><code>@Input</code> 데코레이터는 컴포넌트나 디렉티브에서 입력 속성을 정의하는 데 사용됩니다. name, type 등 입력에 대한 메타데이터를 제공하는 데 사용됩니다. 입력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;&#123;&#123;myInput&#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() myInput: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> @Output</h2><p><code>@Output</code> 데코레이터는 컴포넌트나 디렉티브에서 출력 속성을 정의하는 데 사용됩니다. name, type 등 출력에 대한 메타데이터를 제공하는 데 사용됩니다. 출력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;button (click)="onClick()"&gt;Click Me&lt;/button&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="meta">@Output</span>() myOutput: EventEmitter&lt;<span class="built_in">any</span>&gt; = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">  onClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.myOutput.emit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hostbinding"><a class="markdownIt-Anchor" href="#hostbinding"></a> @HostBinding</h2><p><code>@HostBinding</code> 데코레이터는 디렉티브이나 컴포넌트의 host element 속성을 디렉티브이나 컴포넌트 클래스의 속성에 바인딩하는 데 사용됩니다. 바인딩할 host 속성의 이름을 지정하는 매개변수를 받는 속성 데코레이터입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appHighlight]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HighlightDirective &#123;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">'appHighlight'</span>) isHighlighted: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HostBinding</span>(<span class="string">'style.backgroundColor'</span>) backgroundColor: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnChanges() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isHighlighted) &#123;</span><br><span class="line">      <span class="keyword">this</span>.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.backgroundColor = <span class="string">'transparent'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 @HostBinding 데코레이터는 디렉티브의 <code>backgroundColor</code> 속성을 호스트 요소의 <code>style.BackgroundColor</code> 속성에 바인딩하는 데 사용됩니다. 이는 <code>isHighlighted</code> 입력이 변경되면 그에 따라 <code>backgroundColor</code> 속성이 업데이트된다는 의미입니다.</p><p>@HostBinding 데코레이터를 사용하여 클래스 이름과 같은 호스트 요소의 다른 속성을 바인딩할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appButton]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ButtonDirective &#123;</span><br><span class="line">  <span class="meta">@HostBinding</span>(<span class="string">'class.btn'</span>) isButton = <span class="literal">true</span>;</span><br><span class="line">  <span class="meta">@HostBinding</span>(<span class="string">'class.btn-primary'</span>) isPrimary = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 @HostBinding 데코레이터는 <code>isButton</code> 속성을 호스트 요소의 <code>btn</code> 클래스에 바인딩하고 <code>isPrimary</code> 속성을 호스트 요소의 <code>btn-primary</code> 클래스에 바인딩하는 데 사용됩니다. 이 지시어는 모든 요소에 사용되어 부트스트랩 스타일 버튼 모양을 제공할 수 있습니다.</p><p>@HostBinding을 다른 지시어 및 서비스와 함께 사용하면 Angular 애플리케이션에서 복잡하고 동적인 UI 요소를 쉽게 생성할 수 있습니다.</p><h2 id="attribute"><a class="markdownIt-Anchor" href="#attribute"></a> @Attribute</h2><p><code>@Attribute</code> 데코레이터는 호스트 요소의 속성 값을 디렉티브에 삽입하는 데 사용됩니다. 이 데코레이터는 HTML 요소에서 값을 가져와 디렉티브에 사용해야 할 때 사용됩니다.</p><p><code>@Attribute</code>를 사용하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Directive, Input, Attribute &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[myDirective]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyDirective &#123;</span><br><span class="line">  <span class="meta">@Input</span>() myInput: <span class="built_in">string</span>;</span><br><span class="line">  myAttribute: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Attribute</span>(<span class="string">'my-attribute'</span>) myAttribute: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myAttribute = myAttribute;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 @Attribute 데코레이터는 호스트 요소의 <code>my-attribute</code> 속성 값을 디렉티브의 myAttribute 속성에 삽입하는 데 사용됩니다.</p><p>속성 값은 문자열로 삽입되므로 다른 형식의 값이 필요한 경우 추가 구문 분석이나 유형 변환을 수행해야 할 수도 있습니다.</p><p>@Attribute 데코레이터는 HTML 요소에서 값을 가져와 디렉티브 로직에 사용해야 할 때 유용할 수 있습니다. 그러나 이 접근 방식은 앱의 HTML 구조가 변경되면 취약한 코드로 이어질 수 있다는 점을 명심하는 것이 중요합니다.</p><h2 id="contentchild"><a class="markdownIt-Anchor" href="#contentchild"></a> @ContentChild</h2><p><code>@ContentChild</code> 데코레이터를 사용하면 컴포넌트가 해당 콘텐츠에 투영되는 디렉티브 또는 컴포넌트의 단일 인스턴스를 쿼리할 수 있습니다.</p><h3 id="사용"><a class="markdownIt-Anchor" href="#사용"></a> 사용</h3><p><code>@ContentChild</code> 데코레이터는 두 가지 방법으로 사용할 수 있습니다.</p><ol><li>유형별로 디렉티브나 컴포넌트를 쿼리합니다.</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContentChild</span>(MyDirective) myDirective!: MyDirective;</span><br><span class="line"><span class="meta">@ContentChild</span>(MyComponent) myComponent!: MyComponent;</span><br></pre></td></tr></table></figure><ol start="2"><li>템플릿 참조 변수로 디렉티브나 컴포넌트를 쿼리합니다.</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> #<span class="attr">myComponentRef</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContentChild</span>(<span class="string">'myComponentRef'</span>, &#123; <span class="keyword">static</span>: <span class="literal">true</span> &#125;) myComponent!: MyComponent;</span><br></pre></td></tr></table></figure><h3 id="options"><a class="markdownIt-Anchor" href="#options"></a> Options</h3><p><code>@ContentChild</code> 데코레이터는 다음 속성을 가진 옵션 개체를 사용할 수 있습니다.</p><ul><li><code>static</code> (boolean): 변경 감지가 실행되기 전에 쿼리를 해결할지 여부(기본값은 <code>false</code>).</li></ul><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p>다음은 <code>@ContentChild</code> 데코레이터를 사용하여 투영된 컴포넌트를 쿼리하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-child-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-component'</span>,</span><br><span class="line">  template: <span class="string">` &lt;ng-content&gt;&lt;/ng-content&gt; `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="meta">@ContentChild</span>(MyChildComponent) myChildComponent!: MyChildComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>MyComponent</code> 컴포넌트는 해당 콘텐츠에 투영되는 <code>MyChildComponent</code> 인스턴스를 쿼리합니다.</p><h3 id="사용-시기"><a class="markdownIt-Anchor" href="#사용-시기"></a> 사용 시기</h3><p>컴포넌트의 콘텐츠에 프로젝션되는 디렉티브나 컴포넌트의 단일 인스턴스를 쿼리해야 하는 경우 <code>@ContentChild</code> 데코레이터를 사용하세요.</p><h3 id="notes"><a class="markdownIt-Anchor" href="#notes"></a> Notes</h3><ul><li>쿼리된 디렉티브 또는 컴포넌트의 여러 인스턴스가 콘텐츠에 프로젝션되는 경우 발견된 첫 번째 인스턴스가 반환됩니다.</li><li>쿼리된 디렉티브나 컴포넌트의 인스턴스가 콘텐츠에 프로젝션되지 않으면 쿼리는 <code>undefined</code>를 반환합니다.</li><li>정적 옵션이 <code>true</code>로 설정된 경우 변경 감지가 실행되기 전에 쿼리가 해결됩니다. 이는 <code>ngOnInit()</code> 또는 <code>ngAfterViewInit()</code>에서 쿼리된 인스턴스에 액세스해야 하는 경우 유용할 수 있습니다.</li></ul><h2 id="contentchildren"><a class="markdownIt-Anchor" href="#contentchildren"></a> @ContentChildren</h2><p><code>@ContentChildren</code> 데코레이터는 컴포넌트 또는 디렉티브의 하위 콘텐츠를 쿼리하고 액세스하는 데 사용됩니다. 이를 통해 컴포넌트는 콘텐츠 영역에 프로젝션된 하위 컴포넌트 및 디렉티브에 액세스할 수 있습니다.</p><p>데코레이터는 두 가지 인수를 사용합니다.</p><ul><li>삽입할 디렉티브를 식별하는 selector 문자열입니다.</li><li>injection 에 대한 추가 옵션을 지정하는 선택적 구성 개체입니다.</li></ul><p>다음은 <code>@ContentChildren</code> 데코레이터를 사용하여 투영된 하위 컴포넌트를 쿼리하고 액세스하는 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ContentChildren, QueryList &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TabComponent &#125; <span class="keyword">from</span> <span class="string">'./tab.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-tabs'</span>,</span><br><span class="line">  template: <span class="string">` &lt;ng-content&gt;&lt;/ng-content&gt; `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TabsComponent &#123;</span><br><span class="line">  <span class="meta">@ContentChildren</span>(TabComponent) tabs: QueryList&lt;TabComponent&gt;;</span><br><span class="line"></span><br><span class="line">  ngAfterContentInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.tabs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>TabsComponent</code>는 <code>@ContentChildren</code> 데코레이터를 사용하여 예상되는 모든 <code>TabComponent</code> 하위 항목을 쿼리합니다. 결과 <code>QueryList</code>는 컴포넌트의 <code>tabs</code> 속성에서 사용할 수 있습니다.</p><p><code>ngAfterContentInit</code> 생명주기 훅 메소드는 프로젝션된 콘텐츠가 초기화된 후 <code>tabs</code> 속성에 액세스하는 데 사용됩니다.</p><p>기본적으로 <code>@ContentChildren</code> 데코레이터는 요청된 하위 컴포넌트 또는 디렉티브가 처음으로 나타나는 경우만 반환합니다. 모든 항목을 얻으려면 <code>read</code> 옵션을 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContentChildren</span>(TabComponent, &#123; read: ElementRef &#125;) tabs: QueryList&lt;ElementRef&gt;;</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>ElementRef</code>가 읽기 토큰으로 지정되어 <code>@ContentChildren</code> 데코레이터가 <code>TabComponent</code> 대신 <code>ElementRef</code>를 반환하게 됩니다.</p><p>전반적으로 <code>@ContentChildren</code> 데코레이터는 Angular 컴포넌트 및 디렉티브의 하위 콘텐츠에 액세스하고 상호 작용하기 위한 강력한 도구입니다.</p><h2 id="host"><a class="markdownIt-Anchor" href="#host"></a> @Host</h2><p><code>@Host</code> 데코레이터는 주어진 토큰과 일치하는 가장 가까운 호스트 요소의 종속성을 주입하는 데 사용됩니다. 이는 하위 요소에 디렉티브를 적용했지만 상위 요소의 속성이나 서비스에 액세스하려는 경우에 특히 유용합니다.</p><p><code>@Host</code> 데코레이터의 사용 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Directive, Host, Optional &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ParentDirective &#125; <span class="keyword">from</span> <span class="string">'./parent.directive'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[child]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ChildDirective &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Host</span>() <span class="meta">@Optional</span>() <span class="keyword">private</span> parentDirective?: ParentDirective</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parentDirective) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parentDirective.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에는 <code>ParentDirective</code>가 적용된 요소의 하위 요소에 적용되는 child 디렉티브가 있습니다. <code>@Host</code> 데코레이터는 <code>ParentDirective</code>가 적용된 가장 가까운 호스트 요소에서 <code>ParentDirective</code> 인스턴스를 주입하는 데 사용됩니다. <code>@Optional</code> 데코레이터는 <code>ParentDirective</code>가 포함된 호스트 요소가 없는 경우 생성자가 오류를 발생시키지 않도록 하는 데 사용됩니다.</p><h2 id="hostlistener"><a class="markdownIt-Anchor" href="#hostlistener"></a> @HostListener</h2><p><code>@HostListener</code> 데코레이터는 디렉티브의 호스트 요소에 이벤트 리스너를 등록하는 데 사용됩니다. 이 데코레이터는 <code>@Directive</code> 데코레이터의 <code>host</code> 속성과 함께 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Directive, HostListener &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appMyDirective]'</span>,</span><br><span class="line">  host: &#123;</span><br><span class="line">    <span class="string">'(click)'</span>: <span class="string">'onClick($event)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyDirective &#123;</span><br><span class="line">  onClick(event: MouseEvent) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Clicked!'</span>, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>@HostListener</code> 데코레이터가 명시적으로 사용되지 않지만 <code>host</code> 속성에 암시되어 있습니다. <code>'click'</code> 이벤트는 <code>(click)</code> 구문을 사용하여 <code>onClick()</code> 메서드에 등록됩니다.</p><p><code>@HostListener</code> 데코레이터를 명시적으로 사용할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Directive, HostListener &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[appMyDirective]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyDirective &#123;</span><br><span class="line">  <span class="meta">@HostListener</span>(<span class="string">'click'</span>, [<span class="string">'$event'</span>])</span><br><span class="line">  onClick(event: MouseEvent) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Clicked!'</span>, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>@HostListener</code> 데코레이터를 명시적으로 사용하여 <code>onClick()</code> 메서드에 <code>'click'</code> 이벤트를 등록합니다. <code>'$event'</code> 인수는 이벤트 객체를 메소드에 전달하는 데 사용됩니다.</p><p><code>@HostListener</code> 데코레이터는 클릭 이벤트뿐만 아니라 모든 호스트 요소 이벤트와 함께 사용할 수 있습니다.</p><h2 id="inject"><a class="markdownIt-Anchor" href="#inject"></a> @Inject</h2><p><code>@Inject</code> 데코레이터를 사용하면 클래스의 종속성을 해결하는 데 사용할 토큰을 지정할 수 있습니다.<code>@Injectable</code> 및 <code>@InjectableProvider</code>와 함께 사용하여 종속성에 대한 custom provider를 제공할 수 있습니다.</p><p>예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'./config.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppConfig &#125; <span class="keyword">from</span> <span class="string">'./app.config'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Inject</span>(ConfigService) <span class="keyword">private</span> config: AppConfig</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>ConfigService</code> 토큰과 함께 <code>@Inject</code> 데코레이터를 사용하여 <code>ConfigService</code> 인스턴스를 <code>MyService</code>에 주입합니다. 이는 Angular가 <code>ConfigService</code> 공급자를 사용하여 종속성을 해결하도록 지시합니다.</p><p>다음과 같이 문자열 토큰과 함께 <code>@Inject</code> 데코레이터를 사용할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Inject</span>(<span class="string">'MY_CONFIG'</span>) <span class="keyword">private</span> config: <span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>'MY_CONFIG'</code> 토큰과 함께 값을 주입합니다. 원하는 문자열 토큰을 사용할 수 있지만 오타를 방지하려면 상수 값을 사용하는 것이 가장 좋습니다.</p><p>전반적으로 <code>@Inject</code> 데코레이터는 애플리케이션의 종속성 주입 동작을 커스터 마이징할 수 있는 강력한 도구입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/30/angular-26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] ViewRef: 뷰(View) 변경 감지 및 업데이트 알아보기</title>
      <link>http://hgko1207.github.io/2023/10/26/angular-25/</link>
      <guid>http://hgko1207.github.io/2023/10/26/angular-25/</guid>
      <pubDate>Thu, 26 Oct 2023 02:43:28 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 개발자가 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있는 강력한 프런트 엔드 프레임워크입니다. Angular의 주요 기능 중 하나는 데이터가 변경될 때마다 뷰를 자동으로 업데이트하는 변경 감지
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 개발자가 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있는 강력한 프런트 엔드 프레임워크입니다. Angular의 주요 기능 중 하나는 데이터가 변경될 때마다 뷰를 자동으로 업데이트하는 변경 감지 시스템입니다.</p><p>이 글에서는 Angular의 <strong>ViewRef</strong> 클래스에 대해 자세히 알아보고 이 클래스를 사용하여 변경 감지 프로세스 및 뷰 업데이트를 제어하는 방법을 살펴보겠습니다.</p><h2 id="angular의-변경-감지-이해"><a class="markdownIt-Anchor" href="#angular의-변경-감지-이해"></a> Angular의 변경 감지 이해</h2><p>변경 감지는 뷰가 항상 데이터와 함께 최신 상태를 유지하도록 보장하므로 Angular 프레임워크의 중요한 부분입니다. Angular는 데이터 변경 사항을 자동으로 추적하고 그에 따라 뷰를 업데이트하는 영역 기반 변경 감지 시스템을 사용합니다. 이 변경 감지 프로세스는 사용자 입력이나 데이터 업데이트 등 애플리케이션에서 이벤트가 발생할 때마다 트리거됩니다.</p><p>자동 변경 감지 프로세스 외에도 Angular는 개발자에게 ViewRef 클래스를 사용하여 수동 변경 감지를 트리거하는 기능도 제공합니다. ViewRef 클래스는 컴포넌트의 뷰에 대한 참조이며 보기와 상호 작용하고 변경 감지 프로세스를 제어하는 데 사용할 수 있습니다.</p><h2 id="viewref-클래스-이해"><a class="markdownIt-Anchor" href="#viewref-클래스-이해"></a> ViewRef 클래스 이해</h2><p>ViewRef 클래스는 Angular 변경 감지 시스템의 핵심 컴포넌트입니다. 이는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공합니다. ViewRef 클래스에는 개발자가 뷰를 관리하는 데 사용할 수 있는 몇 가지 주요 메서드와 속성이 있습니다.</p><ul><li><code>discoverChanges()</code>: 이 메소드는 뷰에 대한 변경 감지 프로세스를 트리거합니다. 이는 Angular에게 데이터 변경 사항을 확인하고 그에 따라 뷰를 업데이트하도록 지시합니다.</li><li><code>markForCheck()</code>: 이 메소드는 Angular가 다음 변경 감지 주기 동안 변경 사항을 확인하도록 뷰에 표시합니다.</li><li><code>detach()</code>: 이 메소드는 변경 감지 시스템에서 뷰를 분리합니다. 이는 변경 감지를 트리거하지 않고 뷰를 수동으로 업데이트하려는 상황에서 유용할 수 있습니다.</li><li><code>destroy()</code>: 이 메소드는 뷰를 파괴하고 DOM에서 제거합니다.</li></ul><h2 id="viewref를-사용하여-변경-감지-제어"><a class="markdownIt-Anchor" href="#viewref를-사용하여-변경-감지-제어"></a> ViewRef를 사용하여 변경 감지 제어</h2><p>ViewRef 클래스는 개발자에게 Angular의 변경 감지 프로세스를 제어하는 방법을 제공합니다. <code>detectorChanges()</code> 메서드를 사용하면 개발자가 수동으로 변경 감지를 트리거하고 뷰를 업데이트할 수 있습니다. 이는 사용자 입력을 기반으로 뷰를 업데이트하는 경우와 같이 자동 변경 감지 시스템이 충분하지 않은 상황에서 유용할 수 있습니다.</p><p>변경 감지를 수동으로 트리거하는 것 외에도 개발자는 <code>markForCheck()</code> 메서드를 사용하여 변경 감지 프로세스를 최적화할 수도 있습니다. 이 메서드가 호출되면 Angular는 전체 컴포넌트 트리를 확인하는 대신 뷰와 해당 하위 항목의 변경 사항만 확인합니다. 이는 대규모 애플리케이션의 성능을 크게 향상시킬 수 있습니다.</p><h2 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h2><p>다음은 Angular에서 <code>ViewRef</code>를 사용하기 위한 몇 가지 코드 예제입니다.</p><p>예 1) 현재 컴포넌트의 뷰에 대한 참조 가져오기</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  template: <span class="string">` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> AfterViewInit &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">'header'</span>, &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="keyword">const</span> viewRef = <span class="keyword">this</span>.headerRef[<span class="string">'_view'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(viewRef);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예 2) 동적으로 뷰를 생성하고 컴포넌트에 연결</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, ViewContainerRef, ViewChild, ComponentFactoryResolver &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ViewRef &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; CustomComponent &#125; <span class="keyword">from</span> <span class="string">'./custom.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  template: <span class="string">` &lt;div #container&gt;&lt;/div&gt; `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">'container'</span>, &#123; read: ViewContainerRef &#125;) containerRef: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> componentFactoryResolver: ComponentFactoryResolver</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">// Create a reference to the custom component factory</span></span><br><span class="line">    <span class="keyword">const</span> customComponentFactory = <span class="keyword">this</span>.componentFactoryResolver.resolveComponentFactory(CustomComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new instance of the custom component and attach it to the view</span></span><br><span class="line">    <span class="keyword">const</span> customComponentRef = customComponentFactory.create(<span class="keyword">this</span>.containerRef.injector);</span><br><span class="line">    <span class="keyword">this</span>.containerRef.insert(customComponentRef.hostView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a reference to the newly created view</span></span><br><span class="line">    <span class="keyword">const</span> viewRef = customComponentRef.hostView <span class="keyword">as</span> ViewRef;</span><br><span class="line">    <span class="built_in">console</span>.log(viewRef);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예 3) 컴포넌트에서 뷰 분리</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ViewRef &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  template: <span class="string">` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> AfterViewInit &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">'header'</span>, &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="keyword">const</span> viewRef = <span class="keyword">this</span>.headerRef[<span class="string">'_view'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(viewRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detach the view from the component</span></span><br><span class="line">    viewRef.detach();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the view is still attached to the component</span></span><br><span class="line">    <span class="built_in">console</span>.log(viewRef[<span class="string">'_attached'</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>결론적으로 ViewRef 클래스는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공하는 Angular 프레임워크의 강력한 도구입니다. ViewRef 클래스를 사용하여 개발자는 수동으로 변경 감지를 트리거하고, 변경 감지 프로세스를 최적화하고, View 생명 주기를 제어할 수 있습니다. ViewRef 클래스를 사용하는 방법을 이해하는 것은 복잡하고 반응성이 뛰어난 Angular 애플리케이션을 개발하는 데 필수적인 부분입니다.</p><p>이 글에 설명된 모범 사례를 따르면 ViewRef 클래스를 사용하여 변경 감지 프로세스를 최적화하고 뷰를 최신 데이터로 최신 상태로 유지할 수 있습니다. Angular의 변경 감지 시스템을 손쉽게 활용하면 원활한 사용자 경험을 제공하는 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/26/angular-25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] ViewEncapsulation: 다양한 모드 및 사용 방법 알아보기</title>
      <link>http://hgko1207.github.io/2023/10/25/angular-24/</link>
      <guid>http://hgko1207.github.io/2023/10/25/angular-24/</guid>
      <pubDate>Wed, 25 Oct 2023 05:35:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 개발자에게 &lt;strong&gt;ViewEncapsulation&lt;/strong&gt;을 포함하여 컴포넌트를 빌드하고 스타일을 지정할 수 있는 여러 도구를 제공합니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 ViewEncapsu
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 개발자에게 <strong>ViewEncapsulation</strong>을 포함하여 컴포넌트를 빌드하고 스타일을 지정할 수 있는 여러 도구를 제공합니다.</p><p>이 글에서는 ViewEncapsulation이 무엇인지, ViewEncapsulation이 제공하는 다양한 모드와 각 모드를 언제 사용하는지 살펴보겠습니다.</p><h2 id="viewencapsulation-이란"><a class="markdownIt-Anchor" href="#viewencapsulation-이란"></a> ViewEncapsulation 이란</h2><p>ViewEncapsulation은 컴포넌트의 스타일을 캡슐화하는 Angular 기능입니다. 즉, 원치 않는 스타일 충돌을 방지하기 위해 컴포넌트의 스타일을 애플리케이션의 다른 부분과 분리합니다. 또한 ViewEncapsulation을 사용하면 컴포넌트가 다른 컴포넌트에 영향을 주지 않는 자체 비공개 스타일을 가질 수 있습니다.</p><p>Angular는 Emulated, None 및 Shadow DOM의 세 가지 ViewEncapsulation 모드를 제공합니다. 각 모드를 자세히 살펴보고 각 모드를 언제 사용해야 하는지 알아보겠습니다.</p><h2 id="emulated"><a class="markdownIt-Anchor" href="#emulated"></a> Emulated</h2><p>Emulated는 Angular의 기본 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 스타일 범위를 해당 요소에만 적용하기 위해 컴포넌트의 HTML 요소에 고유한 속성을 추가합니다.</p><p>예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-example'</span>,</span><br><span class="line">  template: <span class="string">` &lt;h1&gt;Hello World!&lt;/h1&gt; `</span>,</span><br><span class="line">  styles: [</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      h1 &#123;</span></span><br><span class="line"><span class="string">        color: red;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>Emulated 모드에서 Angular는 위 컴포넌트의 HTML과 CSS를 다음과 같이 변환합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-example</span> <span class="attr">_ngcontent-abc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">_ngcontent-abc</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-example</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-attr">[_ngcontent-abc]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h1 요소의 스타일 범위를 해당 컴포넌트로만 지정하는 <code>_ngcontent-abc</code> 속성이 추가되었습니다.</p><p>컴포넌트의 스타일을 캡슐화하고 원치 않는 스타일 충돌을 방지하려면 Emulated 모드를 사용하십시오.</p><h2 id="none"><a class="markdownIt-Anchor" href="#none"></a> None</h2><p>None은 캡슐화를 완전히 제거하는 Angular의 또 다른 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 HTML 요소에 속성을 추가하지 않으므로 스타일이 컴포넌트 밖으로 누출되어 애플리케이션의 다른 부분에 영향을 미칠 수 있습니다.</p><p>예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-example'</span>,</span><br><span class="line">  template: <span class="string">` &lt;h1&gt;Hello World!&lt;/h1&gt; `</span>,</span><br><span class="line">  styles: [</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      h1 &#123;</span></span><br><span class="line"><span class="string">        color: red;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  ],</span><br><span class="line">  encapsulation: ViewEncapsulation.None,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>None 모드에서 Angular는 컴포넌트의 HTML과 CSS를 어떤 방식으로든 변환하지 않습니다.</p><p>전역 스타일을 적용해야 하거나 다른 컴포넌트의 스타일을 재정의하려는 경우 None 모드를 사용하세요.</p><h2 id="shadow-dom"><a class="markdownIt-Anchor" href="#shadow-dom"></a> Shadow DOM</h2><p>Shadow DOM은 Angular의 최종 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 스타일을 캡슐화합니다. Shadow DOM은 컴포넌트의 HTML 및 CSS에 대해 별도의 DOM 트리를 생성하여 컴포넌트의 스타일을 애플리케이션의 다른 부분과 격리합니다.</p><p>예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-example'</span>,</span><br><span class="line">  template: <span class="string">` &lt;h1&gt;Hello World!&lt;/h1&gt; `</span>,</span><br><span class="line">  styles: [</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      h1 &#123;</span></span><br><span class="line"><span class="string">        color: red;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  ],</span><br><span class="line">  encapsulation: ViewEncapsulation.ShadowDom,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>Shadow DOM 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 HTML 및 CSS에 대한 별도의 DOM 트리를 생성합니다.</p><p>최고 수준의 캡슐화를 원하고 컴포넌트 스타일이 애플리케이션의 나머지 부분에 영향을 받는 것을 원하지 않을 때 Shadow DOM 모드를 사용하세요.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Angular의 ViewEncapsulation을 이해하면 재사용 및 유지 관리가 가능한 컴포넌트를 만드는 능력이 크게 향상될 수 있습니다. ViewEncapsulation을 적절하게 사용하면 컴포넌트 간의 스타일 및 레이아웃 충돌을 방지하고 일관된 사용자 인터페이스를 유지할 수 있습니다.</p><p>Emulated, Native 또는 None ViewEncapsulation 중 무엇을 사용하든 각 옵션과 관련된 장단점을 염두에 두고 프로젝트 요구 사항에 가장 적합한 옵션을 선택하는 것이 중요합니다.</p><p>전반적으로 ViewEncapsulation은 간과해서는 안 되는 Angular 개발의 중요한 측면입니다. 모범 사례를 따르고 정보에 입각한 결정을 내리면 확장 가능하고 유지 관리 가능한 고품질 Angular 애플리케이션을 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/25/angular-24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 생명주기(Lifecycle) 와 훅(Hook) 메소드 이해</title>
      <link>http://hgko1207.github.io/2023/10/24/angular-23/</link>
      <guid>http://hgko1207.github.io/2023/10/24/angular-23/</guid>
      <pubDate>Tue, 24 Oct 2023 02:00:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 개발자가 동적이고 반응성이 뛰어난 웹 애플리케이션을 구축할 수 있는 강력한 프레임워크입니다. Angular의 주요 기능 중 하나는 각 컴포넌트가 고유한 생명주기(Lifecycle)를 갖는 컴포넌트 기
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 개발자가 동적이고 반응성이 뛰어난 웹 애플리케이션을 구축할 수 있는 강력한 프레임워크입니다. Angular의 주요 기능 중 하나는 각 컴포넌트가 고유한 생명주기(Lifecycle)를 갖는 컴포넌트 기반 아키텍처입니다. 이러한 생명주기를 이해하는 것은 효율적이고 성능이 뛰어난 애플리케이션을 구축하는 데 중요합니다.</p><p>이 글에서는 Angular에서 사용할 수 있는 다양한 생명주기 훅(Hook) 메소드와 차이점, 그리고 이를 사용하는 모범 사례를 살펴보겠습니다.</p><h2 id="생명주기-훅-메소드이란-무엇입니까">생명주기 훅 메소드이란 무엇입니까?</h2><p>Angular 생명주기 훅 메소드는 컴포넌트 생명 주기 중 특정 지점에서 호출되는 메서드입니다. 이러한 훅 메소드를 사용하면 컴포넌트(component)의 초기화, 생성 및 삭제와 같은 특정 시점에 작업을 수행할 수 있습니다.</p><p>Angular에는 8개의 생명주기 메소드가 있습니다.</p><ol><li><code>ngOnChanges()</code>: 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다.</li><li><code>ngOnInit()</code>: 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다.</li><li><code>ngDoCheck()</code>: 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다.</li><li><code>ngAfterContentInit()</code>: 컴포넌트의 콘텐츠가 해당 뷰에 투영된 후에 호출됩니다.</li><li><code>ngAfterContentChecked()</code>: 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다.</li><li><code>ngAfterViewInit()</code>: 컴포넌트의 뷰가 초기화된 후에 호출됩니다.</li><li><code>ngAfterViewChecked()</code>: 컴포넌트 뷰를 확인할 때마다 호출됩니다.</li><li><code>ngOnDestroy()</code>: 컴포넌트가 파괴되기 직전에 호출됩니다.</li></ol><p>이러한 각 메소드는 컴포넌트 생명 주기에서 특정 목적을 수행하므로 특정 시점에 작업을 수행할 수 있습니다.</p><h2 id="차이점">차이점</h2><p>이러한 생명 주기 훅 메소드 간의 몇 가지 차이점을 자세히 살펴보겠습니다.</p><h3 id="ngOnChanges-vs-ngOnInit"><code>ngOnChanges()</code> vs <code>ngOnInit()</code></h3><p><code>ngOnChanges()</code> 메소드는 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다. 컴포넌트 입력 데이터의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다.</p><p>반면에 <code>ngOnInit()</code>은 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다. 초기화 작업을 수행하거나 서비스에서 데이터를 검색해야 할 때 유용합니다.</p><h3 id="ngDoCheck-vs-ngAfterContentChecked"><code>ngDoCheck()</code> vs <code>ngAfterContentChecked()</code></h3><p><code>ngDoCheck()</code> 메소드는 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다. 사용자 정의(Custom) 변경 감지를 수행해야 하거나 사용자 정의 변경 감지 전략을 구현해야 할 때 유용합니다.</p><p>반면에 <code>ngAfterContentChecked()</code>는 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 콘텐츠의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다.</p><h3 id="ngAfterViewInit-vs-ngAfterViewChecked"><code>ngAfterViewInit()</code> vs <code>ngAfterViewChecked()</code></h3><p><code>ngAfterViewInit()</code> 메소드는 컴포넌트의 뷰가 초기화된 후에 호출됩니다. 컴포넌트의 뷰에 액세스해야 하는 초기화 작업을 수행해야 할 때 유용합니다.</p><p>반면에 <code>ngAfterViewChecked()</code>는 컴포넌트 뷰를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 뷰의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다.</p><h2 id="사례">사례</h2><ol><li><p><code>ngOnInit()</code> 메소드에서 복잡한 논리를 피하십시오. 컴포넌트 속성을 초기화하고 기본 설정 작업을 수행하는 데에만 사용해야 합니다. 더 복잡한 로직을 수행해야 하는 경우 별도의 서비스나 기능으로 이동하는 것을 고려해보세요.</p></li><li><p>반응형 입력 처리를 위해 <code>ngOnChanges()</code>를 사용하세요. 입력 속성에 대한 변경 사항을 처리하기 위해 특별히 설계되었습니다. 이를 사용하여 컴포넌트 상태를 업데이트하거나 입력 값의 변경 사항에 따라 다른 작업을 수행합니다.</p></li><li><p>DOM 조작을 위해 <code>ngAfterViewInit()</code> 메소드를 사용하세요. 뷰가 초기화된 후에 호출되며 DOM을 조작하기에 적합한 위치입니다. 이를 사용하여 이벤트 리스너를 설정하고 요소를 추가 또는 제거하거나 기타 DOM 관련 작업을 수행합니다.</p></li><li><p>정리를 위해 <code>ngOnDestroy()</code>를 사용하지 마세요. 컴포넌트 리소스를 정리하도록 설계되었지만 항상 신뢰할 수 있는 것은 아닙니다. 대신 서비스를 사용하거나 컴포넌트의 ngOnDestroy 이벤트를 구독하여 정리 작업을 수행하는 것을 고려해 보세요.</p></li></ol><p>다음은 <code>ngOnDestroy()</code>에만 의존하는 대신 서비스를 사용하여 정리 작업을 수행하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Subscription &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CleanupService &#123;</span><br><span class="line">  <span class="keyword">private</span> subscriptions: Subscription[] = [];</span><br><span class="line"></span><br><span class="line">  addSubscription(subscription: Subscription): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriptions.push(subscription);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cleanup(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriptions.forEach(<span class="function">(<span class="params">subscription</span>) =&gt;</span> subscription.unsubscribe());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런 다음 컴포넌트에 <code>CleanupService</code>를 삽입하고 이를 사용하여 Subscription(구독)을 관리할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, OnDestroy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; interval, Subscription &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CleanupService &#125; <span class="keyword">from</span> <span class="string">'./cleanup.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-example'</span>,</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</span><br><span class="line">  message: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> subscription: Subscription;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cleanupService: CleanupService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscription = interval(<span class="number">1000</span>).subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'Hello, world!'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.cleanupService.addSubscription(<span class="keyword">this</span>.subscription);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// Don't use ngOnDestroy for cleanup!</span></span><br><span class="line">    <span class="comment">// Instead, use the CleanupService to perform cleanup tasks.</span></span><br><span class="line">    <span class="keyword">this</span>.cleanupService.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>CleanupService</code>를 사용하여 컴포넌트의 Subscription을 관리합니다. <code>addSubscription()</code> 메서드는 Subscription 배열에 추가하고 <code>cleanup()</code> 메서드는 배열의 각 Subscription에 대해 <code>unsubscribe()</code>를 호출합니다. 그런 다음 컴포넌트의 <code>ngOnDestroy()</code> 메서드에서 <code>ngOnDestroy()</code>에만 의존하는 대신 <code>CleanupService</code>를 사용하여 정리 작업을 수행합니다. 이렇게 하면 어떤 이유로 <code>ngOnDestroy()</code>가 호출되지 않더라도 컴포넌트의 리소스가 적절하게 정리됩니다.</p><p>이러한 사례를 따르면 일반적인 함정을 피하고 성능을 향상시키면서 컴포넌트가 현재 작업에 적합한 생명 주기를 사용하고 있는지 확인할 수 있습니다.</p><p>결론적으로, 고품질의 고성능 Angular 애플리케이션을 구축하려면 Angular 생명 주기를 이해하는 것이 중요합니다. 각 훅 메소드 간의 차이점을 살펴보고 사례를 따르면 Angular 프레임워크를 최대한 활용하고 강력하고 유지 관리가 가능한 애플리케이션을 구축할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/24/angular-23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[.NET Core] 코드 예제를 통해 멀티스레딩 마스터하기</title>
      <link>http://hgko1207.github.io/2023/10/23/csharp-6/</link>
      <guid>http://hgko1207.github.io/2023/10/23/csharp-6/</guid>
      <pubDate>Mon, 23 Oct 2023 01:09:59 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;C# .NET Core의 멀티스레딩과 관련하여 최적의 성능을 달성하고 일반적인 함정을 피하기 위해 명심해야 할 몇 가지 모범 사례가 있습니다.&lt;/p&gt;
&lt;p&gt;몇 가지 코드 예제를 통해 각각에 대해 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;과도한
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>C# .NET Core의 멀티스레딩과 관련하여 최적의 성능을 달성하고 일반적인 함정을 피하기 위해 명심해야 할 몇 가지 모범 사례가 있습니다.</p><p>몇 가지 코드 예제를 통해 각각에 대해 자세히 살펴보겠습니다.</p><h2 id="과도한-잠금-방지"><a class="markdownIt-Anchor" href="#과도한-잠금-방지"></a> 과도한 잠금 방지</h2><p>다중 스레드 코드로 작업할 때 흔히 저지르는 실수 중 하나는 너무 많은 잠금을 사용하는 것입니다. 여러 스레드가 동시에 액세스하지 못하도록 공유 리소스를 보호하려면 잠금이 필요하지만 과도한 잠금은 스레드 경합 및 성능 저하를 초래할 수 있습니다. 대신 필요한 경우에만 잠금을 사용하고 적절한 경우 <code>Interlocked</code> 작업 또는 <code>Concurrent</code> 컬렉션 클래스와 같은 다른 동기화 메커니즘을 사용하는 것을 고려하십시오.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> _count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IncrementCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lock)</span><br><span class="line">    &#123;</span><br><span class="line">        _count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="thread-safe-데이터-구조-사용"><a class="markdownIt-Anchor" href="#thread-safe-데이터-구조-사용"></a> Thread-Safe 데이터 구조 사용</h2><p>공유 데이터 구조로 작업할 때 데이터 손상이나 경합 조건을 방지하기 위해 thread-safe 컬렉션을 사용하는 것이 중요합니다. .NET Core 라이브러리는 스레드 간에 데이터를 안전하게 공유하는 데 사용할 수 있는 <code>ConcurrentDictionary</code> 및 <code>ConcurrentQueue</code> 와 같은 여러 스레드로부터 안전한 컬렉션을 제공합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; _dict = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddOrUpdateDict</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dict.AddOrUpdate(key, <span class="keyword">value</span>, (k, v) =&gt; v + <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="threadpool-사용"><a class="markdownIt-Anchor" href="#threadpool-사용"></a> ThreadPool 사용</h2><p>스레드를 만들고 관리하는 작업은 비용이 많이 들 수 있으므로 가능하면 .NET Core ThreadPool을 사용하는 것이 가장 좋습니다. ThreadPool은 재사용할 수 있는 스레드 풀을 관리하므로 스레드 생성 및 삭제에 따른 오버헤드를 줄여 성능을 향상시킬 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem((state) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Do some work on a background thread</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="교착상태-주의"><a class="markdownIt-Anchor" href="#교착상태-주의"></a> 교착상태 주의</h2><p>교착 상태는 두 개 이상의 스레드가 서로 리소스를 해제할 때까지 기다리면서 차단되어 더 이상 진행이 불가능한 상황이 발생하는 경우에 발생합니다. 교착 상태를 방지하려면 잠금을 올바른 순서로 획득 및 해제하고 장기간 잠금을 유지하지 않는 것이 중요합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock1 = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock2 = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lock1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do some work</span></span><br><span class="line">        <span class="keyword">lock</span> (_lock2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Do some more work</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="비동기-프로그래밍-사용"><a class="markdownIt-Anchor" href="#비동기-프로그래밍-사용"></a> 비동기 프로그래밍 사용</h2><p>비동기 프로그래밍은 다중 스레드 코드로 작업할 때 호출 스레드를 차단하지 않고 여러 작업을 동시에 수행할 수 있는 강력한 도구가 될 수 있습니다. <code>async</code> 및 <code>await</code> 키워드를 사용하면 동기적인 것처럼 보이지만 실제로는 별도의 스레드에서 비동기적으로 실행되는 코드를 작성할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">DownloadAsync</span>(<span class="params"><span class="keyword">string</span> url</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="모범-사례"><a class="markdownIt-Anchor" href="#모범-사례"></a> 모범 사례</h2><p>이러한 모범 사례를 따르면 C# .NET Core에서 확장 가능한 고성능 다중 스레드 코드를 작성할 수 있습니다.</p><p>다음은 .NET Core의 다중 스레딩에 대한 모범 사례를 사용하는 몇 가지 실제 예입니다.</p><h3 id="비동기식-http-요청"><a class="markdownIt-Anchor" href="#비동기식-http-요청"></a> 비동기식 HTTP 요청</h3><p>웹 애플리케이션에서는 다른 서비스에 HTTP 요청을 보내는 것이 일반적입니다. 기본 스레드를 차단하지 않으려면 이러한 요청은 <code>HttpClient</code>를 사용하여 비동기적으로 이루어져야 합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetApiDataAsync</span>(<span class="params"><span class="keyword">string</span> apiUrl</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(apiUrl);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cpu-바인딩된-작업-병렬화"><a class="markdownIt-Anchor" href="#cpu-바인딩된-작업-병렬화"></a> CPU 바인딩된 작업 병렬화</h3><p>CPU 바인딩된(CPU-bound) 작업을 수행할 때 여러 스레드에 걸쳐 작업을 병렬화하여 성능을 향상시키는 것이 유용한 경우가 많습니다. .NET Core의 Parallel 클래스는 루프를 병렬화하는 쉬운 방법을 제공합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">100000</span>, (i) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Perform CPU-bound work here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="경쟁-조건을-피하기-위해-잠금-사용"><a class="markdownIt-Anchor" href="#경쟁-조건을-피하기-위해-잠금-사용"></a> 경쟁 조건을 피하기 위해 잠금 사용</h3><p>여러 스레드가 공유 리소스에 액세스하면 한 스레드가 리소스를 읽거나 수정하는 동안 다른 스레드도 리소스에 액세스하는 경쟁 조건이 발생할 위험이 있습니다. 이를 방지하기 위해 잠금을 사용하여 한 번에 하나의 스레드만 공유 리소스에 액세스할 수 있도록 할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> _sharedResource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IncrementSharedResource</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sharedResource++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="메인-스레드에서-blocking-방지"><a class="markdownIt-Anchor" href="#메인-스레드에서-blocking-방지"></a> 메인 스레드에서 blocking 방지</h3><p>UI 애플리케이션에서는 기본 스레드를 blocking하고 애플리케이션이 응답하지 않게 만드는 것을 방지하기 위해 파일 I/O 또는 데이터베이스 쿼리와 같은 blocking 작업을 백그라운드 스레드에서 수행해야 합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">LoadDataAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">await</span> GetDataFromDatabaseAsync();</span><br><span class="line">    <span class="comment">// Update UI with data on the main thread</span></span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Perform file I/O or other blocking operation on a background thread</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Continue updating UI with more data on the main thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h2><p>제품 정보, 가격 및 가용성에 대한 대량의 동시 요청을 처리하는 대규모 전자 상거래 웹 사이트용 애플리케이션을 구축한다고 가정해 보겠습니다. 웹사이트는 각 제품 카테고리에 대해 별도의 서비스를 제공하는 마이크로서비스 아키텍처를 사용하며, 각 서비스는 여러 클라이언트의 요청을 처리합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ReaderWriterLockSlim _lock = <span class="keyword">new</span> ReaderWriterLockSlim();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="keyword">int</span>, Product&gt; _products = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="keyword">int</span>, Product&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Product&gt; <span class="title">GetProductAsync</span>(<span class="params"><span class="keyword">int</span> productId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Use a read lock to allow multiple threads to read from the dictionary simultaneously</span></span><br><span class="line">        _lock.EnterReadLock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_products.TryGetValue(productId, <span class="keyword">out</span> Product product))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If the product is not found in the dictionary, use a write lock to add it</span></span><br><span class="line">                _lock.ExitReadLock();</span><br><span class="line">                _lock.EnterWriteLock();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    product = <span class="keyword">await</span> GetProductFromServiceAsync(productId);</span><br><span class="line">                    _products.TryAdd(productId, product);</span><br><span class="line">                    <span class="keyword">return</span> product;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _lock.ExitWriteLock();</span><br><span class="line">                    _lock.EnterReadLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _lock.ExitReadLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;Product&gt; <span class="title">GetProductFromServiceAsync</span>(<span class="params"><span class="keyword">int</span> productId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Use async/await to make an asynchronous API call</span></span><br><span class="line">        <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> url = <span class="string">$"https://api.example.com/products/<span class="subst">&#123;productId&#125;</span>"</span>;</span><br><span class="line">            HttpResponseMessage response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">            <span class="keyword">string</span> json = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">            <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;Product&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 여러 스레드가 <code>_products</code>에서 동시에 읽을 수 있도록 <code>ReaderWriterLockSlim</code>을 사용하고 있습니다. Dictionary에 없는 제품이 요청되면 write lock을 사용하여 추가합니다. 또한 제품 데이터를 검색하기 위해 비동기 API 호출을 만들기 위해 async/await를 사용하고 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/23/csharp-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node.js, Express를 사용하여 간단한 웹 크롤러 만들기</title>
      <link>http://hgko1207.github.io/2023/10/19/nodejs-6/</link>
      <guid>http://hgko1207.github.io/2023/10/19/nodejs-6/</guid>
      <pubDate>Thu, 19 Oct 2023 02:49:28 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;스파이더라고도 알려진 &lt;strong&gt;웹 크롤러&lt;/strong&gt;(Web crawler)는 인터넷을 탐색하고, 웹사이트를 방문하고, 다양한 목적으로 데이터를 추출하는 자동화된 프로그램입니다. 웹 크롤러를 구축하는 것은 복잡한 작업일 수 있지만 올바른
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>스파이더라고도 알려진 <strong>웹 크롤러</strong>(Web crawler)는 인터넷을 탐색하고, 웹사이트를 방문하고, 다양한 목적으로 데이터를 추출하는 자동화된 프로그램입니다. 웹 크롤러를 구축하는 것은 복잡한 작업일 수 있지만 올바른 도구와 지침을 사용하면 보람 있는 경험이 될 수 있습니다.</p><p>이 글에서는 Node.js, Express 및 TypeScript를 사용하여 간단한 웹 크롤러를 구축하는 방법을 살펴보겠습니다.</p><h2 id="1-프로젝트-설정">1. 프로젝트 설정</h2><p>시작하려면 새 Node.js 프로젝트를 만들고 필요한 종속성을 설치해야 합니다. 우리는 다음 패키지를 사용할 것입니다.</p><ol><li><code>Express</code> — 쉽게 서버를 생성하고 HTTP 요청을 처리할 수 있게 해주는 인기 있는 Node.js 웹 프레임워크입니다.</li><li><code>Cheerio</code> — HTML 및 XML 문서를 탐색하고 조작할 수 있게 해주는 jQuery와 유사한 Node.js용 라이브러리입니다.</li><li><code>Request</code> — HTTP 요청을 쉽게 보내고 응답을 처리할 수 있게 해주는 간단한 Node.js용 HTTP 클라이언트입니다.</li></ol><p>새 Node.js 프로젝트를 생성한 후 다음 명령을 사용하여 패키지를 설치할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express cheerio request</span><br></pre></td></tr></table></figure><p>다음을 실행하여 TypeScript를 dev 종속성(devDependencies)으로 설치할 수도 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D typescript @types/node @types/express @types/cheerio @types/request</span><br></pre></td></tr></table></figure><h2 id="2-서버-설정">2. 서버 설정</h2><p>이 섹션에서는 HTTP 요청을 수신하고 응답을 반환하는 간단한 Express 서버를 만듭니다. 또한 웹 크롤러가 크롤링을 시작할 수 있는 경로를 추가할 것입니다.</p><p>먼저 <code>server.ts</code>라는 새 파일을 만들고 다음 코드를 추가하겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express, &#123; Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'Welcome to the Web Crawler'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/crawl'</span>, <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Add code for crawling here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 코드는 새로운 Express 애플리케이션을 생성하고 <code>/</code> 및 <code>/crawl</code>이라는 두 가지 경로를 정의합니다. <code>/</code> 경로는 단순히 사용자에게 환영 메시지를 반환하는 반면 <code>/crawl</code> 경로는 크롤링 프로세스를 시작하는 데 사용됩니다.</p><h2 id="3-웹사이트-크롤링">3. 웹사이트 크롤링</h2><p>이제 서버를 설정했으므로 웹사이트 크롤링을 시작할 수 있습니다. 이 예에서는 Google 홈페이지를 크롤링하고 페이지 제목을 추출합니다.</p><p><code>/crawl</code> 경로 내에 다음 코드를 추가합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'request'</span>;</span><br><span class="line"><span class="keyword">import</span> cheerio <span class="keyword">from</span> <span class="string">'cheerio'</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/crawl'</span>, <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'https://www.google.com'</span>;</span><br><span class="line"></span><br><span class="line">  request(url, <span class="function">(<span class="params">error, response, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> $ = cheerio.load(html);</span><br><span class="line">      <span class="keyword">const</span> title = $(<span class="string">'title'</span>).text();</span><br><span class="line">      res.send(<span class="string">`The title of <span class="subst">$&#123;url&#125;</span> is: <span class="subst">$&#123;title&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(<span class="string">`Error crawling <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 코드는 HTTP GET 요청을 지정된 URL로 보내고 HTML 응답을 Cheerio 개체에 로드합니다. 그런 다음 Cheerio를 사용하여 페이지 제목을 추출하고 이를 사용자에게 응답으로 다시 보낼 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/19/nodejs-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] Tree Shaking: 애플리케이션 크기 최적화</title>
      <link>http://hgko1207.github.io/2023/10/16/angular-22/</link>
      <guid>http://hgko1207.github.io/2023/10/16/angular-22/</guid>
      <pubDate>Mon, 16 Oct 2023 07:03:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 단일 페이지 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 애플리케이션이 복잡해지면 크기도 커지며 이로 인해 로드 시간이 느려지고 성능이 저하될 수 있습니다. Angular 애플리케이션
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 단일 페이지 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 애플리케이션이 복잡해지면 크기도 커지며 이로 인해 로드 시간이 느려지고 성능이 저하될 수 있습니다. Angular 애플리케이션의 크기를 최적화하는 한 가지 기술은 <strong>트리 쉐이킹</strong>(Tree Shaking)을 이용하는 것입니다.</p><p>이 글에서는 트리 쉐이킹이 무엇인지, 어떻게 작동하는지, Angular 프로젝트에서 구현하는 방법을 살펴보겠습니다.</p><h2 id="트리-쉐이킹-Tree-Shaking-이란-무엇입니까">트리 쉐이킹(Tree Shaking)이란 무엇입니까?</h2><p>트리 쉐이킹은 애플리케이션에서 사용되지 않는 코드를 제거하는 프로세스입니다. 코드와 해당 종속성을 분석하고 사용되지 않는 부분을 식별한 다음 안전하게 제거할 수 있는 방식으로 작동합니다. 트리 쉐이킹은 모듈과 종속성이 많은 대규모 애플리케이션에 특히 유용합니다.</p><h2 id="트리-쉐이킹은-어떻게-작동하나요">트리 쉐이킹은 어떻게 작동하나요?</h2><p>트리 쉐이킹은 JavaScript 모듈의 정적 특성에 의존합니다. 모듈을 임포트하면 모듈 전체가 로드되지만 실제로 사용되는 부분만 실행됩니다. 사용되지 않은 코드는 실행되지 않으므로 최종 번들에 포함되지 않습니다. 이렇게 하면 애플리케이션의 크기가 크게 줄어들고 성능이 향상될 수 있습니다.</p><h2 id="Angular에서-트리-쉐이킹-구현">Angular에서 트리 쉐이킹 구현</h2><p>Angular 애플리케이션에서 트리 쉐이킹을 구현하려면 Webpack과 같은 이를 지원하는 빌드 도구를 사용해야 합니다. 애플리케이션을 빌드할 때 Webpack은 코드를 분석하고 사용되지 않는 코드를 제거하여 번들 크기를 더 작게 만듭니다.</p><p>지연 로딩을 사용하여 필요한 모듈만 로드하고, 전역 변수를 피하고, 실제로 사용되는 모듈 부분만 가져오는 등 Angular 개발에 대한 모범 사례를 따르면 트리 쉐이킹 프로세스에 도움이 될 수도 있습니다.</p><h2 id="트리-쉐이킹-검증">트리 쉐이킹 검증</h2><p>응용 프로그램에서 트리 쉐이킹이 실제로 작동하는지 확인하는 것이 중요합니다. 트리 쉐이킹을 구현하기 전과 후에 번들로 제공되는 JavaScript 파일의 크기를 분석하여 이를 수행할 수 있습니다. 또한 사용되지 않더라도 여전히 포함되어 있는 애플리케이션 부분을 식별하려면 Webpack Bundle Analyser와 같은 도구를 사용해야 합니다.</p><h2 id="일반적인-함정-및-팁">일반적인 함정 및 팁</h2><p>트리 쉐이킹을 구현할 때 흔히 발생하는 함정 중 하나는 트리 쉐이킹에 최적화되지 않은 타사 라이브러리에 너무 많이 의존한다는 것입니다. 트리 쉐이킹을 지원하는 라이브러리를 사용하거나 이 기술에 최적화된 대체 라이브러리를 사용하십시오.</p><p>또 다른 팁은 Webpack이 코드를 분석하고 트리 쉐이킹을 적절하게 적용하기 어렵게 만들 수 있는 동적 가져오기를 사용하지 않는 것입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/16/angular-22/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] Zone.js 파일: 성능 향상을 위해 이해하고 사용하기</title>
      <link>http://hgko1207.github.io/2023/10/08/angular-21/</link>
      <guid>http://hgko1207.github.io/2023/10/08/angular-21/</guid>
      <pubDate>Sun, 08 Oct 2023 14:01:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 가장 널리 사용되는 JavaScript 프레임워크 중 하나이며 개발을 보다 효율적으로 만들어주는 많은 도구와 기능을 갖추고 있습니다. 그러한 도구 중 하나가 개발자가 애플리케이션의 변경 사항을 추적하
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 가장 널리 사용되는 JavaScript 프레임워크 중 하나이며 개발을 보다 효율적으로 만들어주는 많은 도구와 기능을 갖추고 있습니다. 그러한 도구 중 하나가 개발자가 애플리케이션의 변경 사항을 추적하고 성능을 향상시키는 데 도움이 되는 라이브러리인 <strong>Zone.js</strong>입니다.</p><p>이 글에서는 Zone.js가 무엇인지, 어떻게 작동하는지, 그리고 이를 사용하여 Angular 애플리케이션을 최적화할 수 있는 방법에 대해 자세히 살펴보겠습니다.</p><h2 id="Zone-js-란-무엇입니까">Zone.js 란 무엇입니까?</h2><p>Zone.js는 개발자가 애플리케이션의 변경 사항을 추적하는 데 도움이 되는 JavaScript 라이브러리입니다. 타이머, 이벤트, XHR 요청과 같은 브라우저의 API에 연결하여 이를 수행합니다. Zone.js가 설치되면 추적하려는 코드 주위에 “zone” 이 생성됩니다. 이 영역은 그 안에서 발생하는 모든 변경 사항을 추적하며 성능을 최적화하는 데 사용될 수 있습니다.</p><h2 id="Zone-js는-어떻게-작동하나요">Zone.js는 어떻게 작동하나요?</h2><p>Zone.js는 코드 주위에 &quot;zone&quot;이라고 하는 wrapper를 생성하여 작동합니다. 이 영역에는 변경 사항을 포함하여 애플리케이션 상태에 대한 정보가 포함되어 있습니다. 영역 내에서 변경 사항이 발생할 때마다 Zone.js는 이를 기록하고 그에 따라 애플리케이션을 업데이트합니다.</p><p>예를 들어, HTTP 요청을 하는 Angular 컴포넌트가 있는 경우 Zone.js는 컴포넌트의 코드 주위에 영역을 만듭니다. HTTP 요청이 이루어지면 Zone.js는 이를 추적하고 그에 따라 컴포넌트의 상태를 업데이트합니다.</p><h2 id="성능-최적화를-위해-Zone-js-사용">성능 최적화를 위해 Zone.js 사용</h2><p>Zone.js는 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키는 등 다양한 성능 최적화 작업에 사용할 수 있습니다. Zone.js를 사용하는 한 가지 방법은 HTTP 요청을 그룹화하여 HTTP 요청 수를 줄이는 것입니다.</p><p>예를 들어 <code>zone.runOutsideAngular()</code> 메서드를 사용하여 Angular 영역 외부에서 HTTP 요청을 실행할 수 있습니다. 이렇게 하면 요청이 Zone.js에 의해 추적되지 않고 성능 향상을 위해 다른 요청과 함께 그룹화될 수 있습니다.</p><p>성능 최적화를 위해 Zone.js를 사용하는 또 다른 방법은 애플리케이션의 응답성을 향상시키는 것입니다. <code>zone.run()</code> 메서드를 사용하여 영역 내에서 애플리케이션의 상태를 업데이트할 수 있습니다. 이렇게 하면 다음 변경 감지 주기를 기다리지 않고 즉시 변경이 이루어집니다.</p><h2 id="고급-Zone-js-기술">고급 Zone.js 기술</h2><p>Zone.js에는 보다 복잡한 성능 최적화 작업에 사용할 수 있는 몇 가지 고급 기능이 있습니다. 그러한 기능 중 하나는 사용자 정의 영역(custom zone)을 생성하는 기능입니다. 사용자 정의 영역을 사용하면 전체 애플리케이션이 아닌 애플리케이션의 특정 부분의 변경 사항을 추적할 수 있습니다.</p><p>또 다른 고급 기술은 Zone.js를 사용하여 변경 감지를 제어하는 ​​기능입니다. 기본적으로 Angular는 NgZone 클래스를 사용하여 변경 감지를 처리합니다. 그러나 Zone.js를 사용하여 변경 감지를 제어하고 특정 애플리케이션에 맞게 최적화할 수 있습니다.</p><h2 id="결론">결론</h2><p>결론적으로 Zone.js는 Angular 애플리케이션의 성능 최적화를 위한 강력한 도구입니다. 코드 주위에 영역을 생성하여 변경 사항을 추적하고 그에 따라 애플리케이션을 업데이트하는 방식으로 작동합니다. Zone.js를 사용하면 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키며 성능 향상을 위해 변경 감지를 제어할 수 있습니다.</p><p>이 글에서 다루는 기술을 사용하면 Zone.js를 사용하여 더 나은 성능을 위해 Angular 애플리케이션을 최적화할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/10/08/angular-21/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[.NET Core] RabbitMQ 사용 가이드</title>
      <link>http://hgko1207.github.io/2023/09/13/csharp-5/</link>
      <guid>http://hgko1207.github.io/2023/09/13/csharp-5/</guid>
      <pubDate>Wed, 13 Sep 2023 01:06:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;는 안정적이고 확장 가능한 메시징을 위해 최신 분산 시스템에서 널리 사용되는 오픈 소스 메시지 브로커 소프트웨어입니다. Erlang으로 작성되었으며 AMQP, MQTT, STOMP와 같은 여러 프로토콜
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>RabbitMQ</strong>는 안정적이고 확장 가능한 메시징을 위해 최신 분산 시스템에서 널리 사용되는 오픈 소스 메시지 브로커 소프트웨어입니다. Erlang으로 작성되었으며 AMQP, MQTT, STOMP와 같은 여러 프로토콜을 지원합니다. RabbitMQ는 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다.</p><p>이 글에서는 크로스 플랫폼 웹 애플리케이션 구축을 위한 인기 있고 강력한 프레임워크인 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보겠습니다. RabbitMQ의 기본 사항, 아키텍처 및 개념, .NET Core 애플리케이션과 통합하는 방법을 다룹니다.</p><h2 id="1-rabbitmq란-무엇입니까"><a class="markdownIt-Anchor" href="#1-rabbitmq란-무엇입니까"></a> 1. RabbitMQ란 무엇입니까?</h2><p>RabbitMQ는 다양한 소프트웨어 애플리케이션 간의 통신을 가능하게 하는 메시지 브로커 소프트웨어입니다. 이는 AMQP(Advanced Message Queuing Protocol)를 기반으로 하며 최신 분산 시스템을 위한 안정적이고 확장 가능한 메시징 솔루션을 제공합니다.</p><p>RabbitMQ는 다양한 애플리케이션과 서비스 간의 비동기 통신을 허용합니다. 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다.</p><h2 id="2-rabbitmq-아키텍처-및-개념"><a class="markdownIt-Anchor" href="#2-rabbitmq-아키텍처-및-개념"></a> 2. RabbitMQ 아키텍처 및 개념</h2><p>RabbitMQ는 서버가 메시지 저장 및 전달을 담당하고 클라이언트가 메시지 생성 및 소비를 담당하는 client-server 모델을 따릅니다. 이는 메시지가 대기열에 배치된 다음 클라이언트에서 사용되는 대기열 기반 모델을 사용합니다.</p><p>RabbitMQ는 AMQP, MQTT, STOMP와 같은 여러 메시징 프로토콜을 지원합니다. 또한 메시지 라우팅, 메시지 확인, 메시지 지속성과 같은 고급 기능도 지원합니다.</p><h2 id="3-rabbitmq-서버-설치"><a class="markdownIt-Anchor" href="#3-rabbitmq-서버-설치"></a> 3. RabbitMQ 서버 설치</h2><p>.NET Core에서 RabbitMQ를 사용하려면 먼저 RabbitMQ 서버를 설치해야 합니다. RabbitMQ는 Windows, macOS, Linux 등 다양한 플랫폼에서 사용할 수 있습니다.</p><p>Windows에 RabbitMQ를 설치하려면 <a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">공식 웹사이트</a>에서 설치 프로그램을 다운로드하고 실행합니다. Linux에서는 패키지 관리자를 사용하여 RabbitMQ를 설치할 수 있습니다.</p><h2 id="4-net-core에서-rabbitmq-설정"><a class="markdownIt-Anchor" href="#4-net-core에서-rabbitmq-설정"></a> 4. .NET Core에서 RabbitMQ 설정</h2><p>.NET Core에서 RabbitMQ를 사용하려면 <code>RabbitMQ.Client</code> NuGet 패키지를 설치해야 합니다. 이 패키지에는 RabbitMQ와 상호 작용하는 데 필요한 클래스와 메서드가 포함되어 있습니다.</p><p>또한 RabbitMQ에 대한 연결 설정을 구성해야 합니다. 연결 설정에는 RabbitMQ 서버의 호스트 이름(hostname), 포트(port), 사용자 이름(username) 및 비밀번호(password)가 포함됩니다.</p><h2 id="5-메시지-publishing-및-consuming"><a class="markdownIt-Anchor" href="#5-메시지-publishing-및-consuming"></a> 5. 메시지 Publishing 및 Consuming</h2><p>.NET Core 애플리케이션에서 RabbitMQ를 설정하고 나면 메시지 게시(Publishing) 및 소비(Consuming)를 시작할 수 있습니다. 메시지를 게시하려면 RabbitMQ에 대한 연결을 만든 다음 채널을 만들어야 합니다. 그런 다음 채널을 사용하여 메시지를 대기열에 게시할 수 있습니다.</p><p>메시지를 소비하려면 대기열을 수신하고 메시지를 처리하는 소비자(Consumers)를 생성해야 합니다. <code>BasicConsume</code> 메서드 또는 <code>EventingBasicConsumer</code> 클래스와 같은 다양한 메시지 소비 전략을 사용할 수 있습니다.</p><h2 id="6-net-core와-함께-rabbitmq를-사용하는-모범-사례"><a class="markdownIt-Anchor" href="#6-net-core와-함께-rabbitmq를-사용하는-모범-사례"></a> 6. .NET Core와 함께 RabbitMQ를 사용하는 모범 사례</h2><p>.NET Core와 함께 RabbitMQ를 사용할 때 최고의 성능과 안정성을 보장하려면 몇 가지 모범 사례를 따라야 합니다. 여기에는 연결 풀링 설정, 메시지 승인 사용, 메시지 재시도 구성이 포함됩니다.</p><p>또한 오류나 문제가 있는지 RabbitMQ 서버를 모니터링하고 적절한 로깅 및 오류 처리를 구성해야 합니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>RabbitMQ는 최신 분산 시스템을 위한 강력하고 안정적인 메시징 솔루션입니다. 이 글에서는 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보았습니다.</p><p>다음은 .NET Core에서 RabbitMQ를 사용하기 위한 몇 가지 코드 예제입니다.</p><p>RabbitMQ 클라이언트 라이브러리 설치</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package RabbitMQ.Client</span><br></pre></td></tr></table></figure><p>RabbitMQ에 연결</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory() &#123; HostName = <span class="string">"localhost"</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do something with the channel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대기열 선언</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queueName = <span class="string">"my-queue"</span>;</span><br><span class="line">channel.QueueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>메시지 게시</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queueName = <span class="string">"my-queue"</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello, World!"</span>;</span><br><span class="line"><span class="keyword">var</span> body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">channel.BasicPublish(<span class="string">""</span>, queueName, <span class="literal">null</span>, body);</span><br></pre></td></tr></table></figure><p>메시지 소비</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queueName = <span class="string">"my-queue"</span>;</span><br><span class="line"><span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> body = ea.Body.ToArray();</span><br><span class="line">    <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something with the message</span></span><br><span class="line"></span><br><span class="line">    channel.BasicAck(ea.DeliveryTag, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queueName, <span class="literal">false</span>, consumer);</span><br></pre></td></tr></table></figure><p>참고: 이러한 코드 예제는 시작점일 뿐이며 특정 사용 사례에 맞게 조정해야 할 수도 있습니다. .NET Core에서 RabbitMQ를 사용하는 방법에 대한 자세한 내용은 공식 RabbitMQ 설명서를 참조하는 것이 좋습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/13/csharp-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OAuth와 JWT 차이점 및 사용 사례</title>
      <link>http://hgko1207.github.io/2023/09/10/backend-1/</link>
      <guid>http://hgko1207.github.io/2023/09/10/backend-1/</guid>
      <pubDate>Sun, 10 Sep 2023 12:33:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;OAuth&lt;/strong&gt;와 &lt;strong&gt;JWT&lt;/strong&gt;는 웹 애플리케이션에서 일반적으로 사용되는 두 가지 보안 메커니즘입니다. 둘 다 인증 기능을 제공하지만 접근 방식과 사용 사례가 다릅니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 O
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>OAuth</strong>와 <strong>JWT</strong>는 웹 애플리케이션에서 일반적으로 사용되는 두 가지 보안 메커니즘입니다. 둘 다 인증 기능을 제공하지만 접근 방식과 사용 사례가 다릅니다.</p><p>이 글에서는 OAuth와 JWT의 차이점과 각각을 언제 사용하는지 살펴보겠습니다.</p><h2 id="Section-1-OAuth">Section 1: OAuth</h2><p>OAuth는 자격 증명을 노출하지 않고 타사 애플리케이션이 사용자의 리소스에 액세스할 수 있도록 하는 개방형 인증 표준입니다. OAuth 흐름에는 리소스 소유자(사용자), 클라이언트(애플리케이션) 및 권한 부여 서버 이 세 가지가 관련됩니다. 클라이언트는 Authorization Server를 통해 리소스 소유자에게 Authorization(권한부여)을 요청하고, 승인이 나면 클라이언트는 리소스에 접근하기 위한 Access Token을 받습니다.<br>OAuth는 일반적으로 사용자가 Facebook 또는 Google 자격 증명을 사용하여 애플리케이션에 로그인할 수 있는 소셜 미디어 로그인에 사용됩니다.</p><h2 id="Section-2-JWT">Section 2: JWT</h2><p>JWT(JSON Web Token)는 두 당사자 간에 전송될 클레임(claim)을 표현하는 URL 안전의 컴팩트한 수단입니다. 헤더(header), 페이로드(payload), 서명(signature)의 세 부분으로 구성됩니다. 헤더는 토큰 유형과 서명 알고리즘을 지정하고, 페이로드에는 클레임이 포함되며, 서명은 토큰의 무결성을 확인하는 데 사용됩니다.<br>JWT는 일반적으로 사용자가 애플리케이션에 로그인하고 JWT를 응답으로 받는 인증에 사용됩니다. 그런 다음 JWT를 사용하여 애플리케이션 내의 보호된 리소스에 액세스할 수 있습니다.</p><h2 id="Section-3-OAuth와-JWT의-차이점">Section 3: OAuth와 JWT의 차이점</h2><p>OAuth와 JWT는 서로 다른 목적으로 사용되며 사용 사례도 다릅니다. OAuth는 권한부여(authorization)에 사용되고 JWT는 인증(authentication)에 사용됩니다. OAuth는 타사 애플리케이션에 리소스에 대한 액세스 권한을 부여하는 데 사용되는 반면, JWT는 애플리케이션 내의 보호된 리소스에 액세스하는 데 사용됩니다.<br>OAuth에는 인증 서버가 필요하지만 JWT에는 그렇지 않습니다. OAuth 흐름에는 여러 단계와 당사자가 포함되는 반면, JWT 흐름은 더 간단하고 두 당사자만 포함합니다.</p><h2 id="Section-4-OAuth를-사용해야-하는-경우">Section 4: OAuth를 사용해야 하는 경우</h2><p>OAuth는 자격 증명을 노출하지 않고 사용자 리소스에 대한 액세스 권한을 타사 애플리케이션에 부여해야 할 때 유용합니다.<br>예를 들어 소셜 미디어 앱을 구축하는 경우 사용자가 Facebook 또는 Google 계정으로 로그인하도록 허용할 수 있습니다. 이 경우 OAuth를 사용하면 자격 증명을 입력하지 않고도 사용자를 인증할 수 있습니다.</p><h2 id="Section-5-JWT를-사용해야-하는-경우">Section 5: JWT를 사용해야 하는 경우</h2><p>JWT는 사용자를 인증하고 애플리케이션 내의 보호된 리소스에 대한 액세스 권한을 부여해야 할 때 유용합니다.<br>예를 들어 사용자가 로그인해야 하는 웹 애플리케이션을 구축하는 경우 JWT를 사용하여 사용자를 인증하고 애플리케이션의 특정 부분에 대한 액세스를 보호할 수 있습니다. JWT를 사용하여 당사자 간에 데이터를 안전하게 전송할 수도 있습니다.</p><h2 id="결론">결론</h2><p>OAuth와 JWT는 모두 웹 애플리케이션 보안을 위한 강력한 도구입니다. 유사해 보일 수도 있지만 용도가 다르며 사용 사례도 다릅니다. OAuth와 JWT의 차이점을 이해하면 특정 사용 사례에 적합한 도구를 선택하고 애플리케이션의 보안을 보장할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/10/backend-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>.NET Core에서 Swagger를 사용하는 방법</title>
      <link>http://hgko1207.github.io/2023/09/07/csharp-4/</link>
      <guid>http://hgko1207.github.io/2023/09/07/csharp-4/</guid>
      <pubDate>Thu, 07 Sep 2023 02:41:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Swagger&lt;/strong&gt;는 RESTful API를 문서화하고 테스트하는 데 널리 사용되는 오픈 소스 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다.&lt;/p&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Swagger</strong>는 RESTful API를 문서화하고 테스트하는 데 널리 사용되는 오픈 소스 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다.</p><p>이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보겠습니다.</p><blockquote><p>Endpoint는 API가 RESTful API를 인터페이스를 통해 서버의 리소스에 액세스 할 수 있도록 해주는 URL입니다.</p></blockquote><h2 id="전제-조건-🛠️">전제 조건 🛠️</h2><ul><li>컴퓨터에 .NET Core 3.1 이상이 설치되어 있어야 함</li><li>RESTful API 아키텍처에 대한 기본 이해</li><li>Visual Studio Code 또는 Visual Studio 2019 이상</li></ul><h2 id="시작하기-🚀">시작하기 🚀</h2><h3 id="1단계-NET-Core-웹-API-프로젝트-만들기">1단계: .NET Core 웹 API 프로젝트 만들기</h3><p>첫 번째 단계는 새 .NET Core Web API 프로젝트를 만드는 것입니다. Visual Studio 또는 Visual Studio Code를 열고 새 .NET Core Web API 프로젝트를 만듭니다.</p><h3 id="2단계-Swashbuckle-AspNetCore-NuGet-패키지-설치">2단계: Swashbuckle.AspNetCore NuGet 패키지 설치</h3><p>Swagger는 .NET Core용 NuGet 패키지로 제공됩니다. 설치하려면 IDE에서 NuGet 패키지 관리자를 열고 Swashbuckle.AspNetCore를 검색하세요. 최신 버전의 패키지를 설치하십시오.</p><h3 id="3단계-애플리케이션-파이프라인에-Swagger-미들웨어-추가">3단계: 애플리케이션 파이프라인에 Swagger 미들웨어 추가</h3><p><code>Startup.cs</code> 파일의 구성 메서드에 다음 코드를 추가하여 Swagger 미들웨어를 애플리케이션 파이프라인에 추가합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger();</span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint( <span class="string">"/swagger/v1/swagger.json"</span> , <span class="string">"My API V1"</span> );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>그러면 미들웨어 파이프라인에 Swagger가 추가되고 개발자가 API를 테스트할 수 있는 UI가 생성됩니다.</p><h3 id="4단계-Swagger-구성">4단계: Swagger 구성</h3><p><code>SwaggerGenOptions</code> 클래스를 사용하여 Swagger를 구성할 수 있습니다. 이 클래스는 Swagger에서 생성된 문서를 커스터마이징 하는 메소드를 제공합니다. Swagger를 구성하려면 <code>Startup.cs</code> 파일의 <code>ConfigureServices</code> 메서드에 다음 코드를 추가하세요.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc( <span class="string">"v1"</span> , <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">"My API"</span> , Version = <span class="string">"v1"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>그러면 SwaggerGen 미들웨어가 애플리케이션 파이프라인에 추가되고 Swagger UI가 구성됩니다.</p><h3 id="5단계-API-Endpoint-문서-생성">5단계: API Endpoint 문서 생성</h3><p>Swagger는 XML 문서 주석을 사용하여 API Endpoint에 대한 문서를 생성합니다. API Endpoint에 XML 주석을 추가하여 문서화하세요. 다음은 GET 엔드포인트에 XML 문서 주석을 추가하는 방법의 예입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Gets all items.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>All items.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;Item&gt; <span class="title">GetAll</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repository.GetAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6단계-Swagger-UI를-사용하여-API-Endpoint-테스트">6단계: Swagger UI를 사용하여 API Endpoint 테스트</h3><p>애플리케이션을 실행하고 Swagger UI Endpoint로 이동합니다. 그러면 개발자가 API Endpoint를 테스트할 수 있는 사용자 친화적인 인터페이스를 제공하는 Swagger UI가 열립니다.</p><h2 id="결론">결론</h2><p>Swagger는 RESTful API를 문서화하고 테스트하기 위한 강력한 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다. 이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보았습니다. Swagger를 사용하면 API가 잘 문서화되고 테스트되어 개발자가 더 쉽게 API를 사용할 수 있도록 보장할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/07/csharp-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 개발자를 위한 AWS 소개 🚀</title>
      <link>http://hgko1207.github.io/2023/09/06/aws-1/</link>
      <guid>http://hgko1207.github.io/2023/09/06/aws-1/</guid>
      <pubDate>Wed, 06 Sep 2023 14:28:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Amazon Web Services&lt;/strong&gt;(AWS)는 웹 애플리케이션 구축, 배포 및 관리를 위한 다양한 서비스를 제공하는 클라우드 기반 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 네트워킹 기능을 포함한 다양한 서비스를 제
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Amazon Web Services</strong>(AWS)는 웹 애플리케이션 구축, 배포 및 관리를 위한 다양한 서비스를 제공하는 클라우드 기반 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 네트워킹 기능을 포함한 다양한 서비스를 제공합니다.</p><p>이 글에서는 AWS의 기본 사항과 AWS가 웹 개발자에게 어떤 이점을 줄 수 있는지 살펴보겠습니다.</p><h2 id="AWS-서비스-📦">AWS 서비스 📦</h2><p>AWS는 웹 애플리케이션을 구축하는 데 사용할 수 있는 다양한 서비스를 제공합니다. 가장 인기 있는 서비스 중 일부는 다음과 같습니다.</p><ol><li><strong>EC2</strong>(Elastic Compute Cloud): 클라우드에서 크기 조정 가능한 컴퓨팅 용량을 제공하는 서비스입니다.</li><li><strong>S3</strong>(Simple Storage Service): 안전하고 내구성이 뛰어나며 확장성이 뛰어난 객체 스토리지를 제공하는 서비스입니다.</li><li><strong>RDS</strong>(관계형 데이터베이스 서비스): MySQL, PostgreSQL, Oracle 및 Microsoft SQL Server에 관리형 데이터베이스 서비스를 제공하는 서비스입니다.</li><li><strong>Lambda</strong>: 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다.</li><li><strong>API 게이트웨이</strong>: API를 쉽게 생성, 게시, 관리할 수 있게 해주는 서비스입니다.</li><li><strong>CloudFront</strong>: 웹 콘텐츠를 사용자에게 빠르게 전달하는 콘텐츠 전달 네트워크(CDN)입니다.</li></ol><h2 id="AWS-배포-🚀">AWS 배포 🚀</h2><p>AWS는 웹 애플리케이션을 클라우드에 배포하기 위한 다양한 도구를 제공합니다. 가장 널리 사용되는 도구는 다음과 같습니다.</p><ol><li>Elastic Beanstalk: 웹 애플리케이션 배포 및 확장을 위한 완전관리형 서비스입니다.</li><li>CodeDeploy: Amazon EC2 인스턴스 및 온프레미스에서 실행되는 인스턴스를 포함하여 모든 인스턴스에 대한 코드 배포를 자동화하는 서비스입니다.</li><li>CloudFormation: Amazon Web Services 리소스를 모델링하고 설정하여 해당 리소스를 관리하는 데 드는 시간을 줄이고 AWS에서 실행되는 애플리케이션에 더 많은 시간을 집중할 수 있도록 도와주는 서비스입니다.</li><li>OpsWorks: 애플리케이션 배포, 확장 및 관리 자동화를 위해 Chef 및 Puppet의 관리형 인스턴스를 제공하는 서비스입니다.</li></ol><h2 id="AWS-보안-🔒">AWS 보안 🔒</h2><p>AWS는 웹 애플리케이션을 보호하는 데 도움이 되는 다양한 보안 서비스와 기능을 제공합니다. 가장 중요한 보안 기능 중 일부는 다음과 같습니다.</p><ol><li><strong>IAM</strong>(Identity and Access Management): AWS 리소스에 대한 액세스를 안전하게 제어하는 ​​데 도움이 되는 서비스입니다.</li><li><strong>WAF</strong>(웹 애플리케이션 방화벽): 일반적인 웹 공격으로부터 웹 애플리케이션을 보호하는 데 도움이 되는 웹 애플리케이션 방화벽입니다.</li><li><strong>키 관리 서비스</strong>(KMS): 데이터를 암호화하는 데 사용되는 암호화 키를 쉽게 생성하고 제어할 수 있게 해주는 서비스입니다.</li></ol><h2 id="결론🔑">결론🔑</h2><p>AWS는 웹 애플리케이션을 구축, 배포 및 관리하기 위한 강력한 플랫폼을 제공합니다. 다양한 서비스와 기능을 통해 애플리케이션을 빠르고 쉽게 구축하고 확장할 수 있습니다. 이 글에서는 AWS 서비스, 배포 도구 및 보안 기능에 대한 개요를 제공했습니다. 이러한 지식을 바탕으로 AWS를 시작하고 강력한 클라우드 기반 플랫폼을 활용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/06/aws-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>효율적인 버전 제어를 위한 Git 명령</title>
      <link>http://hgko1207.github.io/2023/09/05/git-2/</link>
      <guid>http://hgko1207.github.io/2023/09/05/git-2/</guid>
      <pubDate>Tue, 05 Sep 2023 08:21:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;은 코드베이스를 효율적으로 관리할 수 있는 강력한 버전 제어 시스템입니다. 이는 협업, 디버깅 및 깔끔한 코드베이스 유지에 필수적입니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 효율적인 버전 관리를 위해 알아야 할 몇 가지 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Git</strong>은 코드베이스를 효율적으로 관리할 수 있는 강력한 버전 제어 시스템입니다. 이는 협업, 디버깅 및 깔끔한 코드베이스 유지에 필수적입니다.</p><p>이 글에서는 효율적인 버전 관리를 위해 알아야 할 몇 가지 필수 Git 명령을 다룰 것입니다.</p><h2 id="🚀-1-Git-시작하기"><a class="header-anchor" href="#🚀-1-Git-시작하기">¶</a>🚀 1. Git 시작하기</h2><p>Git은 일반적으로 대부분의 시스템에 사전 설치되어 있지만, 그렇지 않은 경우 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">공식 웹사이트</a>에서 다운로드할 수 있습니다. 설치가 완료되면 다음 명령을 사용하여 사용자 이름과 이메일을 구성해야 합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail@domain.com"</span></span><br></pre></td></tr></table></figure><p>Git이 올바르게 설치 및 구성되었는지 확인하려면 다음 명령을 실행하십시오.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>그러면 시스템에 설치된 Git의 현재 버전이 반환됩니다.</p><h2 id="🚀-2-Git-저장소-만들기"><a class="header-anchor" href="#🚀-2-Git-저장소-만들기">¶</a>🚀 2. Git 저장소 만들기</h2><p>새 Git 리포지토리를 생성하려면 코드가 포함된 디렉터리로 이동하여 다음 명령을 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>그러면 현재 디렉터리에 새 Git 저장소가 생성됩니다. 이제 코드 변경 사항 추적을 시작할 수 있습니다.</p><h2 id="🚀-3-코드-변경"><a class="header-anchor" href="#🚀-3-코드-변경">¶</a>🚀 3. 코드 변경</h2><p>Git 리포지토리를 생성한 후에는 코드 변경을 시작할 수 있습니다. 준비 영역에 변경 사항을 추가하려면 다음 명령을 실행하십시오.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>그러면 지정된 파일이 준비 영역에 추가됩니다. 다음 명령을 사용하여 모든 변경 사항을 추가할 수도 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>변경 사항을 저장소에 커밋하려면 다음 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"Commit message"</span></span><br></pre></td></tr></table></figure><p>그러면 지정된 커밋 메시지를 사용하여 저장소에 대한 변경 사항이 커밋됩니다.</p><h2 id="🚀-4-분기-및-병합"><a class="header-anchor" href="#🚀-4-분기-및-병합">¶</a>🚀 4. 분기 및 병합</h2><p>분기(Branch) 및 병합(Merge)은 코드베이스의 다양한 기능을 동시에 작업할 수 있게 해주는 Git의 필수 기능입니다. 새 분기를 만들려면 다음 명령을 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch명&gt;</span><br></pre></td></tr></table></figure><p>그러면 지정된 이름을 가진 새 분기가 생성됩니다. 새 분기로 전환하려면 다음 명령을 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch명&gt;</span><br></pre></td></tr></table></figure><p>한 분기의 변경 사항을 다른 분기에 병합하려면 다음 명령을 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch명&gt;</span><br></pre></td></tr></table></figure><p>그러면 지정된 분기의 변경 사항이 현재 분기에 병합됩니다.</p><h2 id="🚀-5-원격으로-작업하기"><a class="header-anchor" href="#🚀-5-원격으로-작업하기">¶</a>🚀 5. 원격으로 작업하기</h2><p>원격 저장소는 협업에 필수적이며 코드베이스를 다른 사람과 공유할 수 있게 해줍니다. 원격 저장소를 추가하려면 다음 명령을 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;원격 저장소 URL&gt;</span><br></pre></td></tr></table></figure><p>그러면 지정된 이름과 URL을 가진 새 원격 저장소가 추가됩니다. 변경 사항을 원격 저장소에 푸시하려면 다음 명령어를 실행하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch명&gt;</span><br></pre></td></tr></table></figure><p>그러면 지정된 분기의 변경 사항이 지정된 원격 저장소로 푸시됩니다.</p><h2 id="🚀-6-고급-Git-명령"><a class="header-anchor" href="#🚀-6-고급-Git-명령">¶</a>🚀 6. 고급 Git 명령</h2><p>Git에는 코드베이스를 효율적으로 관리할 수 있는 다양한 고급 명령이 있습니다. 가장 유용한 명령 중 일부는 다음과 같습니다.</p><ul><li><code>git log</code>: 저장소의 모든 커밋 목록을 표시합니다.</li><li><code>git reset</code>: 스테이징 영역에서 변경 사항을 제거합니다.</li><li><code>git stash</code>: 커밋할 준비가 되지 않은 변경 사항을 임시로 저장합니다.</li></ul><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>Git은 코드베이스를 효율적으로 관리하는 데 도움이 되는 강력한 버전 제어 시스템입니다. 이러한 필수 Git 명령을 익히면 효과적으로 협업하고 효율적으로 디버그하며 깔끔한 코드베이스를 유지할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/05/git-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>소프트웨어 개발에서 테스트의 중요성</title>
      <link>http://hgko1207.github.io/2023/09/04/info-3/</link>
      <guid>http://hgko1207.github.io/2023/09/04/info-3/</guid>
      <pubDate>Mon, 04 Sep 2023 01:49:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;테스트는 소프트웨어 개발의 필수적인 부분으로, 개발자가 오류를 파악하고 코드 품질을 보장할 수 있도록 해줍니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 테스트의 중요성을 살펴보고 다양한 테스트 유형의 예를 제공합니다.&lt;/p&gt;
&lt;h2 id=&quot;테스트가-중요한-이유
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>테스트는 소프트웨어 개발의 필수적인 부분으로, 개발자가 오류를 파악하고 코드 품질을 보장할 수 있도록 해줍니다.</p><p>이 글에서는 테스트의 중요성을 살펴보고 다양한 테스트 유형의 예를 제공합니다.</p><h2 id="테스트가-중요한-이유"><a class="header-anchor" href="#테스트가-중요한-이유">¶</a>테스트가 중요한 이유</h2><p>테스트를 통해 코드가 의도한 대로 작동하고 이해관계자가 설정한 요구 사항을 충족하는지 확인합니다. 테스트하지 않으면 오류와 버그가 쉽게 빠져나가 사용자에게 문제를 일으키고 소프트웨어의 평판을 손상시킬 수 있습니다. 또한 테스트를 통해 개발 초기에 문제를 파악하고 장기적으로 시간과 리소스를 절약할 수 있습니다.</p><h2 id="테스트-유형"><a class="header-anchor" href="#테스트-유형">¶</a>테스트 유형</h2><h3 id="단위-테스트"><a class="header-anchor" href="#단위-테스트">¶</a>단위 테스트</h3><p>단위 테스트는 메서드나 함수와 같은 단일 코드 단위의 기능을 확인하는 자동화된 테스트입니다. 이는 일반적으로 개발자가 작성하며 개발 프로세스 초기에 오류를 포착할 수 있습니다.</p><h3 id="통합-테스트"><a class="header-anchor" href="#통합-테스트">¶</a>통합 테스트</h3><p>통합 테스트는 서로 다른 코드 단위 또는 시스템 간의 상호 작용을 확인합니다. 이는 다양한 구성 요소의 통합으로 인해 발생할 수 있는 문제를 파악하는 데 유용합니다.</p><h3 id="승인-테스트"><a class="header-anchor" href="#승인-테스트">¶</a>승인 테스트</h3><p>end-to-end 테스트라고도 알려진 승인 테스트는 전체 시스템이 사용자 관점에서 예상대로 작동하는지 확인합니다. 일반적으로 테스터나 품질 보증 전문가가 작성합니다.</p><h3 id="Test-Driven-Development-TDD"><a class="header-anchor" href="#Test-Driven-Development-TDD">¶</a>Test-Driven Development(TDD)</h3><p>TDD(테스트 중심 개발)는 코드를 작성하기 전에 테스트 작성을 강조하는 소프트웨어 개발 방식입니다. 이 접근 방식을 사용하면 모든 기능에 대한 테스트가 작성되고 개발 프로세스 초기에 오류를 포착할 수 있습니다.</p><h3 id="지속적인-통합-및-제공"><a class="header-anchor" href="#지속적인-통합-및-제공">¶</a>지속적인 통합 및 제공</h3><p>CI(지속적 통합) 및 CD(지속적 전달)는 코드 변경 사항이 의도한 대로 작동하는지 확인하기 위해 정기적으로 코드 변경 사항을 구축하고 테스트하는 방식입니다. CI/CD 파이프라인은 코드 변경 사항을 빌드, 테스트 및 배포하는 프로세스를 자동화하여 더 빠르고 빈번한 릴리스를 가능하게 합니다.</p><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>테스트는 소프트웨어 개발의 중요한 부분이므로 처음부터 개발 프로세스에 통합되어야 합니다. 자동화된 테스트를 작성하고 이를 CI/CD 파이프라인에 통합함으로써 개발자는 오류를 조기에 포착하고 코드 변경 사항이 사용자에게 빠르고 안전하게 전달되도록 할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/04/info-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[HTTP] POST와 GET 차이점 및 사용 시기</title>
      <link>http://hgko1207.github.io/2023/09/03/info-2/</link>
      <guid>http://hgko1207.github.io/2023/09/03/info-2/</guid>
      <pubDate>Sun, 03 Sep 2023 13:37:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;(Hypertext Transfer Protocol)는 인터넷을 통해 데이터를 전송하는 데 사용되는 프로토콜입니다. 다양한 HTTP 방법이 있지만 가장 일반적으로 사용되는 두 가지 방법은 HTTP POST와 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>HTTP</strong>(Hypertext Transfer Protocol)는 인터넷을 통해 데이터를 전송하는 데 사용되는 프로토콜입니다. 다양한 HTTP 방법이 있지만 가장 일반적으로 사용되는 두 가지 방법은 HTTP POST와 HTTP GET입니다. 이러한 방법에는 서로 다른 목적이 있으므로 효과적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 필수적입니다.</p><p>이 글에서는 HTTP POST와 HTTP GET의 차이점을 살펴보고 각 방법을 사용하는 경우의 예를 제공합니다. 또한 웹 애플리케이션에서 이러한 방법을 사용하는 몇 가지 모범 사례에 대해서도 알아보겠습니다.</p><h2 id="http-post와-get이란-무엇입니까"><a class="markdownIt-Anchor" href="#http-post와-get이란-무엇입니까"></a> HTTP POST와 GET이란 무엇입니까?</h2><p>HTTP POST 및 HTTP GET은 웹 서버에 데이터를 보내는 데 사용되는 두 가지 방법입니다. 두 방법의 주요 차이점은 데이터가 전송되는 방식입니다.</p><p>HTTP GET은 URL의 일부로 데이터를 보내는 반면, HTTP POST는 HTTP 요청 본문의 일부로 데이터를 보냅니다. 다음은 HTTP GET 요청의 예입니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com?param1=value1&amp;param2=value2</span><br></pre></td></tr></table></figure><p>다음은 HTTP POST 요청의 예입니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit-form</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 33</span><br><span class="line"></span><br><span class="line">param1=value1&amp;param2=value2&amp;param3=value3</span><br></pre></td></tr></table></figure><p>HTTP GET 요청에서 데이터는 URL의 일부로 전송됩니다. HTTP POST 요청에서 데이터는 요청 본문에 key-value 쌍 집합으로 전송됩니다.</p><h2 id="http-get을-사용하는-경우"><a class="markdownIt-Anchor" href="#http-get을-사용하는-경우"></a> HTTP GET을 사용하는 경우</h2><p>HTTP GET은 일반적으로 서버가 데이터 검색만 예상하고 서버에 데이터를 보낼 필요가 없을 때 사용됩니다. 요청된 데이터가 민감하지 않거나 비공개인 경우에도 유용합니다. 다음은 HTTP GET을 사용하는 경우에 대한 몇 가지 예입니다.</p><ul><li>서버에서 데이터 검색</li><li>데이터 필터링</li><li>데이터 페이지 매기기</li><li>데이터 검색 중</li><li>정적 리소스 가져오기(예: 이미지, CSS)</li></ul><h2 id="http-post를-사용하는-경우"><a class="markdownIt-Anchor" href="#http-post를-사용하는-경우"></a> HTTP POST를 사용하는 경우</h2><p>HTTP POST는 일반적으로 서버가 데이터를 생성, 업데이트 또는 삭제해야 할 때 사용됩니다. URL에 표시되어서는 안 되는 대량의 데이터나 민감한 정보를 보낼 때도 유용합니다. 다음은 HTTP POST를 사용하는 경우에 대한 몇 가지 예입니다.</p><ul><li>서버에 새 리소스 생성</li><li>서버의 기존 리소스 업데이트</li><li>서버에서 리소스 삭제</li><li>많은 양의 데이터가 포함된 양식 제출</li><li>파일 업로드</li></ul><h2 id="모범-사례"><a class="markdownIt-Anchor" href="#모범-사례"></a> 모범 사례</h2><p>HTTP GET 또는 HTTP POST를 사용할 때 웹 애플리케이션이 안전하고 효율적인지 확인하기 위해 몇 가지 모범 사례를 따르는 것이 중요합니다. 따라야 할 몇 가지 모범 사례는 다음과 같습니다.</p><ul><li>안전한 멱등성 작업을 위해 HTTP GET을 사용하세요.</li><li>서버의 데이터를 수정하는 안전하지 않은 작업에는 HTTP POST를 사용합니다.</li><li>HTTPS를 사용하여 인터넷을 통해 전송되는 데이터를 암호화합니다.</li><li>단일 요청으로 전송되는 데이터의 양을 제한합니다.</li><li>주입 공격을 방지하기 위해 모든 사용자 입력을 검증합니다.</li><li>SQL 삽입 공격을 방지하려면 매개변수화된 쿼리를 사용하세요.</li></ul><blockquote><p>멱등법칙 또는 멱등성은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. <a href="https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>HTTP POST 및 HTTP GET은 웹 애플리케이션에서 사용되는 두 가지 중요한 HTTP 방법입니다. 안전하고 효율적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 중요합니다. 모범 사례를 따르고 이러한 방법을 적절하게 사용하면 안정적이고 확장 가능하며 안전한 웹 애플리케이션을 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/03/info-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Angular 패키지 생성 및 NPM에 게시</title>
      <link>http://hgko1207.github.io/2023/09/02/angular-20/</link>
      <guid>http://hgko1207.github.io/2023/09/02/angular-20/</guid>
      <pubDate>Sat, 02 Sep 2023 05:13:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular 패키지&lt;/strong&gt;를 만드는 것은 여러 프로젝트에서 코드를 재사용하는 효율적인 방법이므로 시간과 노력을 절약할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular 패키지</strong>를 만드는 것은 여러 프로젝트에서 코드를 재사용하는 효율적인 방법이므로 시간과 노력을 절약할 수 있습니다.</p><p>이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명합니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 진행하겠습니다.</p><h2 id="1단계-프로젝트-설정"><a class="header-anchor" href="#1단계-프로젝트-설정">¶</a>1단계: 프로젝트 설정</h2><p>첫 번째 단계는 프로젝트를 설정하는 것입니다. Angular CLI를 사용하여 새 프로젝트를 생성하겠습니다. 터미널을 열고 다음 명령을 실행하십시오.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-package --create-application=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>그러면 애플리케이션 없이 새로운 Angular 프로젝트가 생성됩니다. 이제 다음 명령을 사용하여 프로젝트 폴더로 이동할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-package</span><br></pre></td></tr></table></figure><h2 id="2단계-새-모듈-만들기"><a class="header-anchor" href="#2단계-새-모듈-만들기">¶</a>2단계: 새 모듈 만들기</h2><p>다음 단계는 패키지에 대한 새 모듈을 만드는 것입니다. 다음 명령을 실행하여 새 모듈을 만듭니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g module my-module</span><br></pre></td></tr></table></figure><p>그러면 프로젝트에 새 모듈이 생성됩니다. 이제 모듈에 코드를 추가할 수 있습니다.</p><h2 id="3단계-모듈에-코드-추가"><a class="header-anchor" href="#3단계-모듈에-코드-추가">¶</a>3단계: 모듈에 코드 추가</h2><p>이제 모듈에 코드를 추가할 수 있습니다. 다음 명령을 사용하여 새 컴포넌트를 만듭니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g component my-component</span><br></pre></td></tr></table></figure><p>그러면 모듈에 새 컴포넌트가 생성됩니다. 이제 컴포넌트에 코드를 추가할 수 있습니다.</p><h2 id="4단계-패키지-빌드-Build"><a class="header-anchor" href="#4단계-패키지-빌드-Build">¶</a>4단계: 패키지 빌드(Build)</h2><p>다음 단계는 패키지를 빌드하는 것입니다. 다음 명령을 실행하여 패키지를 빌드합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build my-package</span><br></pre></td></tr></table></figure><p>그러면 프로젝트 디렉터리에 <code>dist</code> 라는 새 폴더가 생성됩니다.</p><h2 id="5단계-패키지-게시-Publish"><a class="header-anchor" href="#5단계-패키지-게시-Publish">¶</a>5단계: 패키지 게시(Publish)</h2><p>마지막 단계는 NPM에 패키지를 게시하는 것입니다. NPM 계정이 없다면 무료로 만들 수 있습니다. 다음 명령을 실행하여 NPM 계정에 로그인하세요.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>NPM 사용자 이름, 비밀번호, 이메일 주소를 입력하세요. 로그인한 후 다음 명령을 실행하여 패키지를 게시합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish dist/my-package-0.0.1.tgz</span><br></pre></td></tr></table></figure><p>그러면 NPM 레지스트리에 패키지가 게시됩니다.</p><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명했습니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 거쳤습니다. NPM에 패키지를 게시한 후에는 여러 프로젝트에서 코드를 재사용하여 시간과 노력을 절약할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/02/angular-20/#disqus_thread</comments>
    </item>
    
    <item>
      <title>사용자 정의 스크립트로 Angular 워크플로우(Workflow) 자동화</title>
      <link>http://hgko1207.github.io/2023/09/01/angular-19/</link>
      <guid>http://hgko1207.github.io/2023/09/01/angular-19/</guid>
      <pubDate>Fri, 01 Sep 2023 02:27:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 확장 가능한 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 이를 사용하는 것은 때로는 시간이 많이 걸리고 지루할 수 있습니다. 특히 반복적인 작업의 경우 더욱 그렇습니다. 다행히 약
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 확장 가능한 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 이를 사용하는 것은 때로는 시간이 많이 걸리고 지루할 수 있습니다. 특히 반복적인 작업의 경우 더욱 그렇습니다. 다행히 약간의 자동화를 통해 작업 흐름을 간소화하고 일반적인 작업에 소요되는 시간을 절약할 수 있습니다.</p><p>이 글에서는 사용자 정의 스크립트(Custom Scripts)를 사용하여 Angular 워크플로를 자동화하는 방법을 살펴보겠습니다. 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 알아보겠습니다.</p><h2 id="환경-설정"><a class="markdownIt-Anchor" href="#환경-설정"></a> 환경 설정</h2><p>사용자 정의 스크립트를 시작하기 전에 환경을 설정해야 합니다. 먼저 시스템에 Node.js와 NPM이 설치되어 있는지 확인하세요. 공식 웹사이트에서 최신 버전의 Node.js를 다운로드할 수 있습니다.</p><p>다음으로 Angular 프로젝트를 생성해야 합니다. 아직 수행하지 않은 경우 터미널에서 다음 명령을 실행하여 새 프로젝트를 생성할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-app</span><br></pre></td></tr></table></figure><p>프로젝트를 설정한 후에는 사용자 정의 스크립트를 생성하여 작업 흐름을 자동화할 수 있습니다.</p><h2 id="일반적인-사용-사례"><a class="markdownIt-Anchor" href="#일반적인-사용-사례"></a> 일반적인 사용 사례</h2><p>다음은 Angular 프로젝트의 사용자 정의 스크립트에 대한 몇 가지 일반적인 사용 사례입니다.</p><h3 id="1-애플리케이션-구축-및-배포"><a class="markdownIt-Anchor" href="#1-애플리케이션-구축-및-배포"></a> 1. 애플리케이션 구축 및 배포</h3><p>애플리케이션을 구축하고 배포하는 것은 시간이 많이 걸리는 프로세스일 수 있으며, 특히 수동으로 수행하는 경우 더욱 그렇습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 시간을 절약할 수 있습니다.</p><p>다음은 애플리케이션을 빌드하고 원격 서버에 배포하는 예제 스크립트입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ng build --prod</span><br><span class="line">scp -r dist/my-app/* user@remote-server:/usr/share/nginx/html</span><br></pre></td></tr></table></figure><p>이 스크립트는 production 모드에서 Angular 애플리케이션을 구축한 다음 **SCP(Secure Copy)**를 사용하여 원격 서버에 배포합니다.</p><blockquote><p>시큐어 카피(Secure copy) 또는 SCP는 로컬 호스트와 원격 호스트 간 또는 두 개의 원격 호스트 간에 컴퓨터 파일을 안전하게 전송하는 수단이다. 시큐어 셸 프로토콜 기반이다. SCP라는 용어는 SCP 프로토콜 또는 SCP 프로그램 중 하나를 가리킬 수 있다. <a href="https://ko.wikipedia.org/wiki/%EC%8B%9C%ED%81%90%EC%96%B4_%EC%B9%B4%ED%94%BC" target="_blank" rel="noopener">위키백과</a></p></blockquote><h3 id="2-linters-and-code-formatters-실행"><a class="markdownIt-Anchor" href="#2-linters-and-code-formatters-실행"></a> 2. Linters and Code Formatters 실행</h3><p>린터와 코드 포맷터는 코드 품질과 일관성을 유지하는 데 필수적인 도구입니다. 그러나 수동으로 실행하는 것은 번거로울 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 코드가 항상 올바른 형식으로 지정되고 린트되도록 할 수 있습니다.</p><p>다음은 프로젝트에서 Prettier 코드 포맷터와 ESLint 린터를 실행하는 예제 스크립트입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">npm run format</span><br><span class="line">npm run lint</span><br></pre></td></tr></table></figure><p>이 스크립트는 <code>npm run format</code> 및 <code>npm run lint</code> 명령을 실행합니다. 이 명령은 각각 Prettier로 코드 형식을 지정하고 ESLint로 lint합니다.</p><h3 id="3테스트-실행"><a class="markdownIt-Anchor" href="#3테스트-실행"></a> 3.테스트 실행</h3><p>테스트 실행은 개발 프로세스에서 중요한 부분이지만 수동으로 수행해야 하는 경우 시간이 많이 걸릴 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 단일 명령으로 테스트를 실행할 수 있습니다.</p><p>다음은 테스트를 실행하고 결과를 콘솔에 출력하는 예제 스크립트입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ng <span class="built_in">test</span> --watch=<span class="literal">false</span> --code-coverage=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>이 스크립트는 <code>ng test</code> 명령을 사용하여 테스트를 실행하고 결과를 콘솔에 출력합니다. 또한 프로젝트에 대한 코드 적용 범위 보고서도 생성됩니다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>사용자 정의 스크립트를 사용하면 Angular 프로젝트의 일반적인 작업을 자동화하고 많은 시간과 번거로움을 줄일 수 있습니다. 이 문서에서는 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 제공했습니다.</p><p>항상 스크립트를 철저히 테스트하고 주의해서 사용하세요. 약간의 자동화를 통해 Angular 워크플로를 한 단계 더 발전시킬 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/09/01/angular-19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] Http Client 사용 방법</title>
      <link>http://hgko1207.github.io/2023/08/31/angular-18/</link>
      <guid>http://hgko1207.github.io/2023/08/31/angular-18/</guid>
      <pubDate>Thu, 31 Aug 2023 08:06:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Angular의 &lt;code&gt;HttpClient&lt;/code&gt; 모듈은 HTTP 요청을 만들고 응답을 처리하는 간단한 방법을 제공합니다. &lt;code&gt;@angular/common/http&lt;/code&gt; 패키지의 일부이며 &lt;code&gt;XMLHttpReques
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Angular의 <code>HttpClient</code> 모듈은 HTTP 요청을 만들고 응답을 처리하는 간단한 방법을 제공합니다. <code>@angular/common/http</code> 패키지의 일부이며 <code>XMLHttpRequest</code> API 위에 구축되었습니다.</p><p>이 글에서는 <code>HttpClient</code> 모듈의 다양한 기능을 자세히 살펴보고 이를 사용하여 Angular에서 HTTP 요청을 만드는 방법을 알아봅니다.</p><h2 id="Getting-started"><a class="header-anchor" href="#Getting-started">¶</a>Getting started</h2><p>Angular 애플리케이션에서 <code>HttpClient</code> 모듈을 사용하려면 루트 모듈(일반적으로 <code>app.module.ts</code>)에서 <code>HttpClientModule</code> 을 가져와야 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [HttpClientModule],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>HttpClientModule</code> 을 가져오면 이제 <code>HttpClient</code> 서비스를 사용하여 HTTP 요청을 할 수 있습니다.</p><h2 id="HTTP-요청하기"><a class="header-anchor" href="#HTTP-요청하기">¶</a>HTTP 요청하기</h2><p><code>HttpClient</code> 서비스를 사용하여 HTTP 요청을 만들려면 <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>delete()</code> 및 <code>patch()</code> 메서드 중 하나를 호출하면 됩니다. 이 메소드는 요청 완료 시 응답을 내보내는 <code>Observable</code> 을 반환합니다.</p><p>다음은 <code>HttpClient</code> 서비스를 사용하여 <code>GET</code> 요청을 만드는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  getData(): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;<span class="built_in">any</span>&gt;(<span class="string">'https://api.example.com/data'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>HttpClient</code> 서비스를 <code>ApiService</code> 라는 서비스에 주입합니다. 그런 다음 <code>any</code> 유형의 <code>Observable</code> 을 반환하는 <code>getData()</code> 라는 메서드를 정의합니다. <code>HttpClient</code> 서비스의 <code>get()</code> 메서드는 지정된 URL에 대한 <code>GET</code> 요청을 만드는 데 사용됩니다.</p><p>마찬가지로, 다른 HTTP 메소드를 사용하여 요청을 수행하고 적절한 데이터를 메소드의 두 번째 인수로 전달할 수 있습니다.</p><h2 id="HTTP-응답-처리"><a class="header-anchor" href="#HTTP-응답-처리">¶</a>HTTP 응답 처리</h2><p><code>HttpClient</code> 서비스는 도착 시 응답을 내보내는 <code>Observable</code> 을 반환합니다. 응답을 처리하기 위해 <code>Observable</code> 의 <code>subscribe()</code> 메소드를 사용할 수 있습니다.</p><p>다음은 <code>getData()</code> 메서드의 응답을 처리하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.apiService.getData().subscribe(</span><br><span class="line">  (response) =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle the response here</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle the error here</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>ApiService</code> 서비스의 <code>getData()</code> 메소드를 호출하고 <code>Observable</code> 의 <code>subscribe()</code> 메소드를 사용하여 응답을 구독합니다. <code>subscribe()</code> 메서드의 첫 번째 콜백은 응답이 도착할 때 호출되고, 두 번째 콜백은 오류가 있을 때 호출됩니다.</p><h2 id="HTTP-헤더"><a class="header-anchor" href="#HTTP-헤더">¶</a>HTTP 헤더</h2><p><code>HttpHeaders</code> 클래스의 <code>set()</code> 메서드를 사용하여 요청에 대한 HTTP 헤더를 설정할 수도 있습니다. <code>Authorization</code> 헤더를 설정하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpHeaders &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  getData(): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> headers = <span class="keyword">new</span> HttpHeaders(&#123;</span><br><span class="line">      Authorization: <span class="string">'Bearer my-token'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;<span class="built_in">any</span>&gt;(<span class="string">'https://api.example.com/data'</span>, &#123; headers &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>HttpHeaders</code> 클래스의 새 인스턴스를 생성하고 <code>Authorization</code> 헤더를 <code>Bearer my-token</code> 으로 설정합니다. 그런 다음 헤더 개체를 <code>HttpClient</code> 서비스의 <code>get()</code> 메서드에 대한 두 번째 인수로 전달합니다.</p><h2 id="Query-parameters"><a class="header-anchor" href="#Query-parameters">¶</a>Query parameters</h2><p><code>HttpParams</code> 클래스를 사용하여 HTTP 요청에 쿼리 매개변수를 전달할 수도 있습니다. 쿼리 매개변수를 전달하는 방법의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpParams &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  getData(page: <span class="built_in">number</span>, limit: <span class="built_in">number</span>): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> params = <span class="keyword">new</span> HttpParams();</span><br><span class="line">    params = params.append(<span class="string">'page'</span>, page.toString());</span><br><span class="line">    params = params.append(<span class="string">'limit'</span>, limit.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;<span class="built_in">any</span>&gt;(<span class="string">'https://api.example.com/data'</span>, &#123; params &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>HttpParams</code> 클래스의 새 인스턴스를 만들고 <code>append()</code> 메서드를 사용하여 <code>page</code> 및 <code>limit</code> 매개변수를 여기에 추가합니다. 그런 다음 <code>params</code> 개체를 <code>HttpClient</code> 서비스의 <code>get()</code> 메서드에 대한 두 번째 인수로 전달합니다.</p><h2 id="오류-처리"><a class="header-anchor" href="#오류-처리">¶</a>오류 처리</h2><p>HTTP 요청을 할 때 오류를 적절하게 처리하는 것이 중요합니다. <code>HttpClient</code> 서비스는 <code>rxjs</code> 라이브러리의 <code>catchError()</code> 연산자를 사용하여 오류를 처리하는 방법을 제공합니다.</p><p>다음은 <code>getData()</code> 메서드에서 오류를 처리하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpErrorResponse &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throwError &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  getData(): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;<span class="built_in">any</span>&gt;(<span class="string">'https://api.example.com/data'</span>).pipe(</span><br><span class="line">      catchError(<span class="function">(<span class="params">error: HttpErrorResponse</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> errorMessage = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error.error <span class="keyword">instanceof</span> ErrorEvent) &#123;</span><br><span class="line">          <span class="comment">// client-side error</span></span><br><span class="line">          errorMessage = <span class="string">`Error: <span class="subst">$&#123;error.error.message&#125;</span>`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// server-side error</span></span><br><span class="line">          errorMessage = <span class="string">`Error Code: <span class="subst">$&#123;error.status&#125;</span>\nMessage: <span class="subst">$&#123;error.message&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.error(errorMessage);</span><br><span class="line">        <span class="keyword">return</span> throwError(errorMessage);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>rxjs</code> 라이브러리의 <code>catchError()</code> 연산자를 사용하여 오류를 처리합니다. 오류가 발생하면 <code>catchError()</code> 연산자는 오류를 발생시키고 Observable 체인을 중지합니다. 그런 다음 <code>rxjs</code> 라이브러리의 <code>throwError()</code> 함수를 사용하여 오류를 내보내고 Observable 체인을 계속합니다.</p><p>다음은 <code>HttpClient</code> 모듈의 많은 기능을 사용하는 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpHeaders, HttpErrorResponse &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable, throwError &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">private</span> baseUrl = <span class="string">'https://example.com/api'</span>;</span><br><span class="line">  <span class="keyword">private</span> headers = <span class="keyword">new</span> HttpHeaders(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> handleError(error: HttpErrorResponse) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.error <span class="keyword">instanceof</span> ErrorEvent) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'An error occurred:'</span>, error.error.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`Backend returned code <span class="subst">$&#123;error.status&#125;</span>, `</span> + <span class="string">`body was: <span class="subst">$&#123;error.error&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throwError(<span class="string">'Something bad happened; please try again later.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> getAuthHeaders() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpHeaders(&#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      Authorization: <span class="string">`Bearer <span class="subst">$&#123;localStorage.getItem(<span class="string">'access_token'</span>)&#125;</span>`</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span>&lt;T&gt;(path: <span class="built_in">string</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">      .get&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.baseUrl&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>, &#123;</span><br><span class="line">        headers: <span class="keyword">this</span>.getAuthHeaders(),</span><br><span class="line">      &#125;)</span><br><span class="line">      .pipe(catchError(<span class="keyword">this</span>.handleError));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> post&lt;T&gt;(path: <span class="built_in">string</span>, data: <span class="built_in">any</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">      .post&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.baseUrl&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>, data, &#123;</span><br><span class="line">        headers: <span class="keyword">this</span>.getAuthHeaders(),</span><br><span class="line">      &#125;)</span><br><span class="line">      .pipe(catchError(<span class="keyword">this</span>.handleError));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> put&lt;T&gt;(path: <span class="built_in">string</span>, data: <span class="built_in">any</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">      .put&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.baseUrl&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>, data, &#123;</span><br><span class="line">        headers: <span class="keyword">this</span>.getAuthHeaders(),</span><br><span class="line">      &#125;)</span><br><span class="line">      .pipe(catchError(<span class="keyword">this</span>.handleError));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">delete</span>&lt;T&gt;(path: <span class="built_in">string</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">      .delete&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.baseUrl&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>, &#123;</span><br><span class="line">        headers: <span class="keyword">this</span>.getAuthHeaders(),</span><br><span class="line">      &#125;)</span><br><span class="line">      .pipe(catchError(<span class="keyword">this</span>.handleError));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-요청-테스트"><a class="header-anchor" href="#HTTP-요청-테스트">¶</a>HTTP 요청 테스트</h2><p><code>@angular/common/http/testing</code> 모듈은 <code>HttpClient</code> 서비스로 생성된 HTTP 요청을 테스트하기 위한 유틸리티 세트를 제공합니다.</p><p>이 모듈에서 제공하는 주요 클래스는 <code>HttpTestingController</code> 입니다. 이 클래스를 사용하여 HTTP 요청 및 응답을 모의하고 테스트 중인 애플리케이션에서 올바른 요청이 이루어졌는지 확인할 수 있습니다.</p><p><code>HttpTestingController</code> 를 사용하려면 먼저 테스트 케이스에 삽입해야 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientTestingModule, HttpTestingController &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http/testing'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'MyComponent'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> httpTestingController: HttpTestingController;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      imports: [HttpClientTestingModule],</span><br><span class="line">      providers: [MyComponent],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    httpTestingController = TestBed.inject(HttpTestingController);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Mocking-HTTP-Requests"><a class="header-anchor" href="#Mocking-HTTP-Requests">¶</a>Mocking HTTP Requests</h3><p>HTTP 요청을 모의하려면 <code>HttpTestingController</code> 인스턴스에서 <code>ExpectOne()</code> 메서드를 호출하여 URL 또는 <code>HttpRequest</code> 객체를 전달할 수 있습니다. 이 메소드는 요청에 대한 응답을 제어하는 데 사용할 수 있는 <code>TestRequest</code> 객체를 반환합니다.</p><p>다음은 <code>ExpectOne()</code> 을 사용하여 HTTP GET 요청을 모의하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should make an HTTP GET request'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> expectedData = &#123; id: <span class="number">1</span>, name: <span class="string">'John Doe'</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'/api/user/1'</span>;</span><br><span class="line"></span><br><span class="line">  myComponent.getUser(<span class="number">1</span>).subscribe(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(expectedData);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> req = httpTestingController.expectOne(url);</span><br><span class="line">  expect(req.request.method).toEqual(<span class="string">'GET'</span>);</span><br><span class="line">  req.flush(expectedData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>MyComponent</code> 인스턴스에서 <code>getUser()</code> 메서드를 테스트하고 있습니다. 이 메서드는 <code>/api/user/1</code> 에 대한 HTTP GET 요청을 만들고 응답 데이터를 내보내는 <code>Observable</code> 을 반환합니다.</p><p>이 메소드를 테스트하기 위해 <code>getUser()</code> 를 호출하고 그것이 반환하는 <code>Observable</code> 을 구독합니다. 그런 다음 요청과 동일한 URL을 사용하여 <code>httpTestingController.expectOne()</code> 을 호출하고 반환된 <code>TestRequest</code> 객체를 사용하여 예상 데이터가 포함된 응답을 flush 합니다.</p><h3 id="HTTP-요청-확인"><a class="header-anchor" href="#HTTP-요청-확인">¶</a>HTTP 요청 확인</h3><p><code>HttpTestingController</code> 를 사용하여 HTTP 요청을 모의한 후 해당 메서드를 사용하여 예상되는 요청이 테스트 중인 애플리케이션에서 이루어졌는지 확인할 수 있습니다.</p><p>예를 들어, <code>verify()</code> 메서드를 사용하여 예기치 않은 요청이 발생하지 않았는지 확인할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should make an HTTP GET request'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  myComponent.getUser(<span class="number">1</span>).subscribe(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(expectedData);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> req = httpTestingController.expectOne(<span class="string">'/api/user/1'</span>);</span><br><span class="line">  req.flush(expectedData);</span><br><span class="line"></span><br><span class="line">  httpTestingController.verify();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>httpTestingController.verify()</code> 를 사용하여 테스트 중인 애플리케이션에서 다른 요청이 이루어지지 않았는지 확인합니다. 다른 요청이 이루어진 경우 이 메서드는 오류를 발생시킵니다.</p><p><code>expectNone()</code> 메서드를 사용하여 요청이 이루어지지 않았는지 확인할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should not make an HTTP GET request with incorrect ID'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  myComponent.getUser(<span class="number">2</span>).subscribe(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(data).toBeUndefined();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  httpTestingController.expectNone(<span class="string">'/api/user/2'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>getUser()</code> 메서드가 <code>/api/user/2</code> 에 HTTP 요청을 하지 않는지 테스트하고 있습니다. 요청과 동일한 URL로 <code>httpTestingController.expectNone()</code> 을 호출하고 요청이 없으므로 테스트가 통과됩니다.</p><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>Angular의 <code>HttpClient</code> 모듈의 다양한 기능을 살펴보았습니다. HTTP 요청을 작성하고 응답을 처리하고, HTTP 헤더 및 쿼리 매개변수를 설정하고, 오류를 처리하는 방법을 배웠습니다. <code>HttpClient</code> 모듈은 Angular 애플리케이션에서 HTTP 요청을 만들기 위한 강력하고 사용하기 쉬운 API를 제공합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/31/angular-18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JavaScript] Array Methods</title>
      <link>http://hgko1207.github.io/2023/08/30/js-dev-9/</link>
      <guid>http://hgko1207.github.io/2023/08/30/js-dev-9/</guid>
      <pubDate>Wed, 30 Aug 2023 04:43:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;는 배열 작업을 위한 많은 강력한 도구를 제공하는 다용도 언어입니다. 가장 일반적으로 사용되는 도구 중 하나는 배열을 조작하고 변환하기 위한 다양한 메서드를 제공하는 Array 개체입니다. 이 글에
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>JavaScript</strong>는 배열 작업을 위한 많은 강력한 도구를 제공하는 다용도 언어입니다. 가장 일반적으로 사용되는 도구 중 하나는 배열을 조작하고 변환하기 위한 다양한 메서드를 제공하는 Array 개체입니다. 이 글에서는 JavaScript에서 가장 중요하고 유용한 배열 메서드 중 일부를 자세히 살펴보겠습니다.</p><h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> forEach()</h2><p><code>forEach()</code> 메서드는 배열을 반복하고 각 요소에 대해 콜백 함수를 실행합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">number</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> map()</h2><p><code>map()</code> 메서드는 배열의 각 요소에 콜백 함수를 적용하여 새 배열을 만듭니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.map(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubledNumbers);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure><h2 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter()</h2><p><code>filter()</code> 메서드는 특정 테스트를 통과한 모든 요소가 포함된 새 배열을 만듭니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.filter(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(evenNumbers);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4]</span><br></pre></td></tr></table></figure><h2 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce()</h2><p><code>reduce()</code> 메서드는 배열의 각 요소에 콜백 함수를 적용하여 배열을 단일 값으로 줄입니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="find"><a class="markdownIt-Anchor" href="#find"></a> find()</h2><p><code>find()</code> 메소드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 값을 반환합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstEvenNumber = numbers.find(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstEvenNumber);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="findindex"><a class="markdownIt-Anchor" href="#findindex"></a> findIndex()</h2><p><code>findIndex()</code> 메소드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstEvenNumberIndex = numbers.findIndex(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstEvenNumberIndex);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="some"><a class="markdownIt-Anchor" href="#some"></a> some()</h2><p><code>some()</code> 메서드는 배열의 요소 중 하나 이상이 특정 조건을 만족하는지 확인합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasEvenNumbers = numbers.some(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasEvenNumbers);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="every"><a class="markdownIt-Anchor" href="#every"></a> every()</h2><p><code>every()</code> 메소드는 배열의 모든 요소가 특정 기준을 충족하는지 확인합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allEven = numbers.every(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(allEven);</span><br></pre></td></tr></table></figure><h2 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort()</h2><p><code>sort()</code> 메서드는 배열의 요소를 정렬합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sortedFruits = fruits.sort();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sortedFruits);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>]</span><br></pre></td></tr></table></figure><h2 id="includes"><a class="markdownIt-Anchor" href="#includes"></a> includes()</h2><p><code>include()</code> 메소드는 배열에 특정 값이 포함되어 있는지 확인합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasNumberThree = numbers.includes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasNumberThree);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="flat"><a class="markdownIt-Anchor" href="#flat"></a> flat()</h2><p><code>flat()</code> 메서드는 모든 하위 배열 요소가 지정된 깊이까지 반복적으로 연결되어 있는 새 배열을 만듭니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flattenedNumbers = numbers.flat(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flattenedNumbers);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h2 id="flatmap"><a class="markdownIt-Anchor" href="#flatmap"></a> flatMap()</h2><p><code>flatMap()</code> 메서드는 먼저 매핑 함수를 사용하여 각 요소를 매핑한 다음 결과를 새 배열로 평면화합니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubledAndFlattenedNumbers = numbers.flatMap(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">number</span> * <span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubledAndFlattenedNumbers);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure><h2 id="from"><a class="markdownIt-Anchor" href="#from"></a> from()</h2><p><code>from()</code> 메서드는 배열 유사 객체 또는 반복 가능 객체에서 새 배열을 만듭니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span>, length: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>.from(arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArray);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><h2 id="array-destructuring"><a class="markdownIt-Anchor" href="#array-destructuring"></a> Array Destructuring</h2><p>Array Destructuring 를 사용하면 배열에서 값을 추출하여 변수에 할당할 수 있습니다. 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure><p>그러면 다음이 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>이 글에서는 JavaScript 에서 가장 중요하고 유용한 Array 메소드 중 일부를 살펴보았습니다. 이러한 메서드는 배열 작업을 위한 강력한 도구를 제공하며 코드를 더욱 간결하고 표현력있게 만들 수 있습니다. 이러한 방법을 익히면 더욱 효율적이고 효과적인 JavaScript 개발자가 될 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/30/js-dev-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] Error Handling</title>
      <link>http://hgko1207.github.io/2023/08/29/angular-17/</link>
      <guid>http://hgko1207.github.io/2023/08/29/angular-17/</guid>
      <pubDate>Tue, 29 Aug 2023 00:42:08 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Error Handling&lt;/strong&gt; 는 모든 애플리케이션의 필수적인 부분이며 Angular도 예외는 아닙니다. Angular 프레임워크는 다양한 시나리오에서 오류를 처리할 수 있는 강력한 도구 세트를 제공합니다.&lt;/p&gt;
&lt;p
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Error Handling</strong> 는 모든 애플리케이션의 필수적인 부분이며 Angular도 예외는 아닙니다. Angular 프레임워크는 다양한 시나리오에서 오류를 처리할 수 있는 강력한 도구 세트를 제공합니다.</p><p>이번 글에서는 Angular의 다양한 오류 유형과 이를 효과적으로 처리하는 방법을 살펴보겠습니다.</p><h2 id="Types-of-Errors-in-Angular">Types of Errors in Angular</h2><p>Angular 애플리케이션에서 발생할 수 있는 오류에는 주로 두 가지 유형이 있습니다.</p><ol><li>컴파일 시간 오류: 이러한 오류는 Angular 애플리케이션이 빌드되는 컴파일 단계에서 발생합니다. 컴파일 시간 오류는 일반적으로 코드의 구문 또는 논리적 오류를 나타내며 애플리케이션이 실행되지 못하게 합니다.</li><li>런타임 오류: 이러한 오류는 Angular 애플리케이션을 실행하는 동안 발생합니다. 런타임 오류는 네트워크 문제, 서버 오류, 코드의 논리적 오류 등 다양한 원인으로 인해 발생할 수 있습니다.</li></ol><h2 id="Handling-Compile-time-Errors">Handling Compile-time Errors</h2><p>컴파일 시간 오류는 일반적으로 쉽게 수정할 수 있으며 Angular CLI는 개발자가 문제를 신속하게 식별하는 데 도움이 되는 자세한 오류 메시지를 제공합니다. 오류 메시지에는 오류가 발생한 줄 번호와 파일 이름이 포함됩니다. 개발자는 오류 메시지를 사용하여 문제를 해결하고 애플리케이션을 다시 빌드할 수 있습니다.</p><h2 id="Handling-Runtime-Errors">Handling Runtime Errors</h2><p>런타임 오류는 컴파일 타임 오류보다 처리하기가 더 복잡합니다. 이러한 오류는 네트워크 문제나 서버 오류 등 다양한 이유로 인해 발생할 수 있습니다. 이러한 시나리오에서 애플리케이션은 오류를 적절하게 처리하고 사용자에게 유용한 피드백을 제공해야 합니다.</p><p>Angular는 <code>ErrorHandler</code> 클래스와 같은 런타임 오류를 처리하기 위한 내장 오류 처리기 세트를 제공합니다. <code>ErrorHandler</code> 클래스는 오류 처리를 위한 기본 구현을 제공하는 추상 클래스입니다. 개발자는 <code>ErrorHandler</code> 클래스를 확장하고 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다.</p><h2 id="Custom-Error-Handling">Custom Error Handling</h2><p>개발자는 <code>ErrorHandler</code> 클래스를 사용하여 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다. <code>ErrorHandler</code> 클래스에는 응용 프로그램에서 오류가 발생할 때 호출되는 <code>handlerError(error: any)</code> 라는 단일 메서드가 있습니다. 이 메서드는 오류 개체를 매개 변수로 사용하고 개발자에게 오류를 처리할 수 있는 기회를 제공합니다.</p><p>다음은 커스텀 오류 처리기 구현의 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ErrorHandler &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomErrorHandler <span class="keyword">implements</span> ErrorHandler &#123;</span><br><span class="line">  handleError(error: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="comment">// Implement custom error handling logic here</span></span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서는 <code>ErrorHandler</code> 클래스를 implements 하고 <code>handlerError()</code> 메서드를 재정의하는 <code>CustomErrorHandler</code> 클래스를 만들었습니다. 이 예에서는 단순히 오류를 콘솔에 기록하지만 개발자는 사용자에게 친숙한 오류 메시지를 표시하는 등 사용자 지정 오류 처리 로직을 구현할 수 있습니다.</p><h2 id="Error-Interceptors">Error Interceptors</h2><p>Angular는 인터셉터를 사용하여 HTTP 응답을 가로채고 전역적으로 오류를 처리하는 메커니즘을 제공합니다. 인터셉터를 사용하면 개발자는 HTTP 응답이 호출 컴포넌트에 반환되기 전에 이를 가로챌 수 있습니다. 개발자는 인터셉터를 사용하여 오류를 전체적으로 처리하고 일관된 사용자 경험을 제공할 수 있습니다.</p><p>다음은 HTTP 오류 인터셉터의 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throwError &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HttpErrorInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</span><br><span class="line">  intercept(request: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler) &#123;</span><br><span class="line">    <span class="keyword">return</span> next.handle(request).pipe(</span><br><span class="line">      catchError(<span class="function">(<span class="params">error: HttpErrorResponse</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> errorMessage = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (error.error <span class="keyword">instanceof</span> ErrorEvent) &#123;</span><br><span class="line">          <span class="comment">// client-side error</span></span><br><span class="line">          errorMessage = <span class="string">`Error: <span class="subst">$&#123;error.error.message&#125;</span>`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// server-side error</span></span><br><span class="line">          errorMessage = <span class="string">`Error Code: <span class="subst">$&#123;error.status&#125;</span>\nMessage: <span class="subst">$&#123;error.message&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.error(errorMessage);</span><br><span class="line">        <span class="keyword">return</span> throwError(errorMessage);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule, HTTP_INTERCEPTORS &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpErrorInterceptor &#125; <span class="keyword">from</span> <span class="string">'./http-error.interceptor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [BrowserModule, HttpClientModule],</span><br><span class="line">  providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: <span class="literal">true</span> &#125;],</span><br><span class="line">  bootstrap: [AppComponent],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button (click)="makeRequest()"&gt;Make Request&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;div *ngIf="error"&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</span><br><span class="line">  error: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  makeRequest() &#123;</span><br><span class="line">    <span class="keyword">this</span>.http.get(<span class="string">'https://someURL.con/posts/1'</span>).subscribe(</span><br><span class="line">      (data) =&gt; <span class="built_in">console</span>.log(data),</span><br><span class="line">      (error) =&gt; (<span class="keyword">this</span>.error = error)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서는 HttpClient 서비스를 사용하여 API 에 GET 요청을 보냅니다. 요청이 성공하면 응답 데이터가 콘솔에 기록됩니다. 오류가 있는 경우 템플릿에 오류 메시지가 표시됩니다.</p><p><code>HttpErrorInterceptor</code> 를 사용하면 요청 중에 발생하는 모든 오류가 인터셉터에 의해 차단되어 처리됩니다. 오류 메시지는 콘솔에 기록되고 관찰 가능한 오류로 발생하며 컴포넌트에서 이를 포착하고 처리할 수 있습니다.</p><p>Angular 앱에서 오류 인터셉터를 사용하면 오류 처리 로직을 중앙 집중화하고 모든 HTTP 요청에서 오류를 처리하는 일관된 방법을 제공할 수 있습니다. 이를 통해 코드 유지 관리가 더 용이해지고 앱에 대한 사용자 경험이 더 좋아질 수 있습니다.</p><h2 id="결론">결론</h2><p>오류 처리는 강력하고 안정적인 애플리케이션을 구축하는 데 필수적인 부분입니다. Angular에는 <code>try/catch</code> 블록 사용, 컴포넌트 수준에서 오류 처리, 오류 인터셉터 사용 등 오류를 처리하는 다양한 방법이 있습니다. 포괄적인 오류 처리 전략을 구현하면 애플리케이션이 사용자에게 원활하고 오류 없는 환경을 제공하도록 할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/29/angular-17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node.js 와 TypeScript 콜백(callback) 지옥 피하는 방법</title>
      <link>http://hgko1207.github.io/2023/08/28/nodejs-5/</link>
      <guid>http://hgko1207.github.io/2023/08/28/nodejs-5/</guid>
      <pubDate>Mon, 28 Aug 2023 04:16:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt;는 Chrome의 V8 JavaScript 엔진을 기반으로 구축된 이벤트 중심의 non-blocking I/O 플랫폼입니다. 웹 서버를 포함하여 확장 가능한 네트워크 애플리케이션을 구축하는 데 널리 사용
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Node.js</strong>는 Chrome의 V8 JavaScript 엔진을 기반으로 구축된 이벤트 중심의 non-blocking I/O 플랫폼입니다. 웹 서버를 포함하여 확장 가능한 네트워크 애플리케이션을 구축하는 데 널리 사용됩니다.</p><p>이러한 애플리케이션을 구축할 때 콜백 지옥(callback hell) 문제가 발생할 수 있습니다. 이는 여러 개의 중첩된 콜백이 있어 코드를 읽고 유지 관리하기 어렵게 만드는 문제를 의미합니다.</p><p>이 글에서는 Express 웹 프레임워크와 TypeScript를 사용하여 Node.js 애플리케이션을 구축할 때 콜백 지옥을 피하는 방법에 대해 설명합니다.</p><h2 id="Promises"><a class="header-anchor" href="#Promises">¶</a>Promises</h2><p>Promises 은 보다 읽기 쉽고 관리하기 쉬운 방식으로 비동기 작업을 처리하는 방법입니다. 이는 아직 사용할 수 없지만 미래에는 사용할 수 있는 값을 나타냅니다. Promise를 서로 연결하면 여러 비동기 작업을 순차적으로 처리할 수 있습니다.</p><p>Node.js에서 Promise를 사용하는 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'Data received!'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData()</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>이 예에서 <code>getData</code> 는 1초 후에 해결되는 약속을 반환합니다. 그런 다음 <code>.then</code> 메서드를 사용하여 확인된 값을 처리하고 <code>.catch</code> 메서드를 사용하여 오류를 처리할 수 있습니다.</p><h2 id="Async-Await"><a class="header-anchor" href="#Async-Await">¶</a>Async/Await</h2><p>Async/await 는 Promise 위에 추가되는 Syntatic Sugar(문법 설탕) 으로, 비동기 작업 작업을 더 쉽게 만듭니다. 이를 통해 동기적으로 보이는 비동기 코드를 작성할 수 있으므로 읽고 유지하기가 더 쉬워집니다.</p><blockquote><p>컴퓨터 과학에서 Syntactic sugar(구문 설탕)은 더 쉽게 읽거나 표현하도록 설계된 프로그래밍 언어 내의 구문입니다. 그것은 인간이 사용하기에 언어를 &quot;더 달콤&quot;하게 만듭니다. 사물을 더 명확하고 간결하게 표현하거나 일부 사람들이 선호하는 대체 스타일로 표현할 수 있습니다. <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">위키백과</a></p></blockquote><p>Node.js에서 async/await를 사용하는 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'Data received!'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> getData();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>이 예에서 <code>main</code> 은 <code>wait</code> 키워드를 사용하여 <code>getData</code> 함수의 확인된 값을 기다리는 비동기 함수입니다. <code>try/catch</code> 블록을 사용하여 오류를 처리할 수 있습니다.</p><h2 id="Promisify"><a class="header-anchor" href="#Promisify">¶</a>Promisify</h2><p>Promisify는 callback-based 함수를 promise-based 함수로 변환할 수 있도록 Node.js에서 제공하는 유틸리티 함수입니다. 이는 Promise를 사용하지 않는 오래된 라이브러리나 모듈로 작업할 때 유용할 수 있습니다.</p><p>Node.js에서 promisify를 사용하는 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> readFile(<span class="string">'file.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>예에서는 <code>util.promisify</code> 를 사용하여 Node.js의 <code>fs.readFile</code> 함수를 promise-based 함수로 변환합니다. 그런 다음 Promise 기반 함수를 사용하여 <code>file.txt</code> 파일의 내용을 읽습니다.</p><h2 id="Use-Control-Flow-Libraries"><a class="header-anchor" href="#Use-Control-Flow-Libraries">¶</a>Use Control Flow Libraries</h2><p>복잡한 비동기 코드로 작업하는 경우 Promise 와 async/await 만으로는 코드를 깔끔하고 유지 관리하기 쉽도록 유지하는 데 충분하지 않다는 것을 알 수 있습니다. 이 경우 제어 흐름(flow library) 라이브러리를 사용하여 비동기 코드를 관리하는 데 도움을 받을 수 있습니다.</p><p>제어 흐름 라이브러리는 비동기 작업의 흐름을 관리하는 방법을 제공하여 해당 작업이 올바른 순서로 실행되고 오류가 적절하게 처리되도록 합니다. Node.js의 인기 있는 제어 흐름 라이브러리로는 Async, Bluebird 및 Q가 있습니다.</p><p>다음은 Async 라이브러리를 사용하여 일련의 비동기 작업을 관리하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.series(</span><br><span class="line">  [</span><br><span class="line">    (callback) =&gt; &#123;</span><br><span class="line">      fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf8'</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    (callback) =&gt; &#123;</span><br><span class="line">      fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf8'</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    (callback) =&gt; &#123;</span><br><span class="line">      fs.readFile(<span class="string">'file3.txt'</span>, <span class="string">'utf8'</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  (error, results) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(results);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>async.series</code> 메서드를 사용하여 일련의 비동기 작업(이 경우 세 파일의 내용 읽기)을 순서대로 실행합니다. 모든 작업이 완료되면 최종 콜백이 호출되고 결과 배열을 받습니다.</p><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>콜백 지옥은 Node.js에서 비동기 코드 작업을 어렵고 실망스럽게 만들 수 있지만, 이를 방지하기 위해 사용할 수 있는 많은 전략은 위과 같습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/28/nodejs-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C# and .NET Core 멀티스레딩(multithreading)</title>
      <link>http://hgko1207.github.io/2023/08/27/csharp-3/</link>
      <guid>http://hgko1207.github.io/2023/08/27/csharp-3/</guid>
      <pubDate>Sun, 27 Aug 2023 12:44:48 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;멀티스레딩&lt;/strong&gt;은 프로그램을 여러 스레드로 나누는 방식을 의미하며, 각 스레드는 독립적으로 동시에 실행될 수 있습니다. 이로 인해 특히 I/O 또는 네트워크 통신과 같은 작업의 경우 성능과 응답성이 향상될 수 있습니다. 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>멀티스레딩</strong>은 프로그램을 여러 스레드로 나누는 방식을 의미하며, 각 스레드는 독립적으로 동시에 실행될 수 있습니다. 이로 인해 특히 I/O 또는 네트워크 통신과 같은 작업의 경우 성능과 응답성이 향상될 수 있습니다. C# 및 .NET Core에서는 System.Threading 네임스페이스를 사용하여 스레드를 만들고 관리할 수 있습니다.</p><p>다음은 Thread 클래스를 사용하여 C#에서 새 스레드를 만드는 예입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Worker));</span><br><span class="line">        thread.Start();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Main thread is running."</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Worker thread is running."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>Thread</code> 클래스를 사용하여 새 스레드를 만들고 <code>Worker</code> 메서드에 대리자를 전달합니다. 그런 다음 <code>Start</code> 메서드를 사용하여 스레드를 시작하고 <code>Worker</code> 메서드는 <code>Main</code> 메서드와 동시에 실행됩니다. 이 프로그램을 실행하면 다음과 같은 출력이 표시됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread <span class="keyword">is</span> running.</span><br><span class="line">Worker thread <span class="keyword">is</span> running.</span><br></pre></td></tr></table></figure><p>.NET Core는 다중 스레드 코드 작업을 위한 다양한 클래스와 구문도 제공합니다. 그 중 하나는 병렬 작업을 실행하는 간단한 방법을 제공하는 TPL(작업 병렬 라이브러리)입니다. 다음은 TPL 을 사용하여 병렬 루프를 실행하는 예입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt; &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Processing item &#123;0&#125; on thread &#123;1&#125;"</span>, i, Task.CurrentId);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>Parallel.For</code> 메서드를 사용하여 루프를 병렬로 실행하며 각 반복은 별도의 스레드에서 실행됩니다. <code>Task.CurrentId</code> 속성을 사용하여 현재 반복을 실행하는 스레드의 ID를 표시합니다. 이 프로그램을 실행하면 다음과 유사한 출력이 표시됩니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Processing item <span class="number">0</span> <span class="keyword">on</span> thread <span class="number">4</span></span><br><span class="line">Processing item <span class="number">1</span> <span class="keyword">on</span> thread <span class="number">6</span></span><br><span class="line">Processing item <span class="number">2</span> <span class="keyword">on</span> thread <span class="number">5</span></span><br><span class="line">Processing item <span class="number">3</span> <span class="keyword">on</span> thread <span class="number">7</span></span><br><span class="line">Processing item <span class="number">4</span> <span class="keyword">on</span> thread <span class="number">8</span></span><br><span class="line">Processing item <span class="number">5</span> <span class="keyword">on</span> thread <span class="number">4</span></span><br><span class="line">Processing item <span class="number">6</span> <span class="keyword">on</span> thread <span class="number">6</span></span><br><span class="line">Processing item <span class="number">7</span> <span class="keyword">on</span> thread <span class="number">5</span></span><br><span class="line">Processing item <span class="number">8</span> <span class="keyword">on</span> thread <span class="number">7</span></span><br><span class="line">Processing item <span class="number">9</span> <span class="keyword">on</span> thread <span class="number">8</span></span><br></pre></td></tr></table></figure><p>이는 C# 및 .NET Core가 다중 스레드 프로그래밍을 지원하는 다양한 방식 중 작은 예일 뿐입니다.</p><p>이미지 처리 또는 비디오 트랜스코딩과 같이 CPU를 많이 사용하는 장기 실행 작업을 수행해야 하는 웹 API가 있는 시나리오를 생각해 보세요. 메인 스레드에서 이 작업을 수행하면 다른 수신 요청이 차단되고 API의 응답 속도가 느려집니다. 이 문제를 해결하려면 멀티스레딩을 사용하여 별도의 스레드에서 작업을 수행하고 기본 스레드가 들어오는 요청을 처리할 수 있도록 남겨둘 수 있습니다.</p><p>다음은 작업 병렬 라이브러리를 사용하여 .NET Core 웹 API에서 이를 달성할 수 있는 방법의 예입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageController</span> : <span class="title">ControllerBase</span> &#123;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">ProcessImage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Parse incoming request and extract image data</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start processing on a separate thread</span></span><br><span class="line">        Task&lt;<span class="keyword">byte</span>[]&gt; task = Task.Run(() =&gt; &#123;</span><br><span class="line">            <span class="comment">// Perform CPU-intensive image processing</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> processedImageData;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return a response immediately, while the image is being processed</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 이미지 데이터가 포함된 수신 HTTP POST 요청을 처리하는 웹 API 컨트롤러에 <code>ProcessImage</code> 작업 메서드를 정의합니다. 그런 다음 별도의 스레드에서 지정된 대리자를 실행하는 새 <code>Task </code>을 만드는 <code>Task.Run</code> 메서드를 사용하여 별도의 스레드에서 이미지 처리를 시작합니다. 처리가 완료될 때까지 기다리고 처리된 이미지 데이터를 반환하기 위해 <code>wait</code> 키워드를 사용하여 <code>Task</code>를 응답으로 즉시 반환합니다.</p><p>이 방식을 사용하면 웹 API의 기본 스레드가 들어오는 요청에 계속 응답하는 동시에 이미지 처리가 별도의 스레드에서 수행됩니다. 이는 API의 전반적인 성능과 확장성을 향상시키는 데 도움이 될 수 있습니다.</p><p>첫 번째 예에서는 <code>System.Threading</code> 네임스페이스를 사용하여 C# 및 .NET Core에서 스레드를 만들고 관리하는 방법을 살펴보았습니다. 우리는 새로운 스레드를 생성하고 해당 스레드에서 별도의 메서드를 실행하는 간단한 프로그램을 만들었습니다. 이를 통해 두 개의 별도 코드 조각을 동시에 실행할 수 있어 특정 시나리오에서 성능과 응답성을 향상시킬 수 있습니다.</p><p>두 번째 예에서는 .NET Core 웹 API에서 고급 멀티스레딩 기술을 사용하는 방법을 살펴보았습니다. 우리는 Task Parallel 라이브러리를 사용하여 별도의 스레드에서 long-running, CPU-intensive 작업을 시작하는 동시에 기본 스레드는 들어오는 요청을 처리할 수 있도록 자유롭게 유지했습니다. 이는 특히 long-running 작업으로 인해 들어오는 요청이 차단될 수 있는 시나리오에서 API의 전반적인 성능과 확장성을 개선하는 데 도움이 될 수 있습니다.</p><p>전반적으로 멀티스레딩은 C# 및 .NET Core 애플리케이션의 성능과 응답성을 향상시키는 강력한 도구가 될 수 있습니다. 그러나 이를 현명하게 사용하고 복잡성 증가, 잠재적 경합 조건 또는 동기화 문제, 리소스 사용량 증가와 같은 잠재적인 절충안을 이해하는 것이 중요합니다. 특정 시나리오에 적합한 스레딩 구성 및 기술을 사용하면 이러한 잠재적 위험을 피하면서 멀티스레딩의 이점을 활용할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/27/csharp-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 재사용 가능한 컴포넌트(Component)</title>
      <link>http://hgko1207.github.io/2023/08/26/angular-16/</link>
      <guid>http://hgko1207.github.io/2023/08/26/angular-16/</guid>
      <pubDate>Sat, 26 Aug 2023 06:33:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;웹 애플리케이션 구축에 &lt;strong&gt;Angular&lt;/strong&gt; 를 사용하는 주요 이점 중 하나는 재사용 가능한 컴포넌트를 생성할 수 있다는 것입니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>웹 애플리케이션 구축에 <strong>Angular</strong> 를 사용하는 주요 이점 중 하나는 재사용 가능한 컴포넌트를 생성할 수 있다는 것입니다.</p><p>이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보겠습니다.</p><h2 id="1-Component-Structure"><a class="header-anchor" href="#1-Component-Structure">¶</a>1. Component Structure</h2><p>Angular에서 재사용 가능한 컴포넌트를 만들려면 다양한 상황에서 쉽게 사용할 수 있는 방식으로 컴포넌트를 구성하는 것이 중요합니다. 컴포넌트에는 입력 및 출력 속성이 잘 정의된 명확한 API가 있어야 하며 다양한 사용 사례를 처리할 수 있을 만큼 유연해야 합니다.</p><p>다음은 항목 목록을 표시하는 재사용 가능한 간단한 컴포넌트의 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-item-list'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor="let item of items"&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ItemListComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() items: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>ItemListComponent</code> 에는 문자열 배열인 항목이라는 Single Input 속성이 있습니다. 컴포넌트는 <code>*ngFor</code> 지시문을 사용하여 <code>items</code> 배열을 반복하고 목록의 각 항목을 표시합니다.</p><h2 id="2-Input-and-Output-Properties"><a class="header-anchor" href="#2-Input-and-Output-Properties">¶</a>2. Input and Output Properties</h2><p>입력 및 출력 속성은 Angular에서 재사용 가능한 컴포넌트를 만드는 데 중요한 부분입니다. Input 속성을 사용하면 상위 컴포넌트에서 데이터를 컴포넌트로 전달할 수 있고, Output 속성을 사용하면 컴포넌트에서 상위 컴포넌트로 이벤트를 내보낼 수 있습니다.</p><p>다음은 사용자가 목록에서 값을 선택할 수 있도록 하는 재사용 가능한 컴포넌트의 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input, Output, EventEmitter &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-select'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;select [ngModel]="selectedValue" (ngModelChange)="selectValue.emit($event)"&gt;</span></span><br><span class="line"><span class="string">      &lt;option *ngFor="let option of options" [value]="option"&gt;&#123;&#123; option &#125;&#125;&lt;/option&gt;</span></span><br><span class="line"><span class="string">    &lt;/select&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SelectComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() options: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="meta">@Input</span>() selectedValue: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Output</span>() selectValue = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 <code>SelectComponent</code> 에는 두 개의 입력 속성인 <code>options</code> 와 <code>selectedValue</code> 와 하나의 출력 속성인 <code>selectValue</code> 가 있습니다. 컴포넌트는 <code>ngModel</code> 지시문을 사용하여 선택한 값을 <code>selectedValue</code> 속성에 바인딩하고 사용자가 목록에서 새 값을 선택할 때 <code>selectValue</code> 이벤트를 발생시킵니다.</p><h2 id="3-Content-Projection"><a class="header-anchor" href="#3-Content-Projection">¶</a>3. Content Projection</h2><p>콘텐츠 프로젝션은 Angular에서 재사용 가능한 컴포넌트를 구축하는 또 다른 주요 기능입니다. 콘텐츠 프로젝션을 통해 컴포넌트는 상위 항목의 임의 콘텐츠를 허용할 수 있으며, 이는 컴포넌트의 모양이나 동작을 사용자 지정하는 데 사용할 수 있습니다.</p><p>콘텐츠 프로젝션의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-section'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="section"&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-content&gt;&lt;/ng-content&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  styles: [</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      .section &#123;</span></span><br><span class="line"><span class="string">        border: 1px solid black;</span></span><br><span class="line"><span class="string">        padding: 10px;</span></span><br><span class="line"><span class="string">        margin-bottom: 20px;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      h2 &#123;</span></span><br><span class="line"><span class="string">        margin-bottom: 10px;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SectionComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-parent'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;app-section title="Section 1"&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;Content for section 1 goes here.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-section&gt;</span></span><br><span class="line"><span class="string">    &lt;app-section title="Section 2"&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;Item 1&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;Item 2&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;Item 3&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-section&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParentComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>title 이 상위 컴포넌트에서 전달될 수 있도록 <code>title</code> 속성에 <code>@Input</code> 데코레이터를 추가했습니다. <code>SectionComponent</code> 템플릿은 보간을 사용하여 제목을 표시하고 <code>ng-content</code> 지시문은 상위 컴포넌트의 임의 콘텐츠를 투영하는 데 사용됩니다.</p><p>각 <code>SectionComponent</code> 인스턴스에 대한 입력으로 제목을 전달하고 있으며, 각 섹션의 콘텐츠는 <code>ng-content</code> 지시어를 사용하여 상위 컴포넌트에서 투영됩니다.</p><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보았습니다.</p><p>또한 이러한 기능을 사용하여 다양한 상황에서 사용할 수 있는 간단한 재사용 가능한 컴포넌트를 만드는 방법에 대한 몇 가지 예도 살펴보았습니다. 이러한 사례를 따르면 사용 및 유지 관리가 쉽고 Angular 애플리케이션의 전반적인 품질을 향상시키는 데 도움이 되는 컴포넌트를 만들 수 있습니다.</p><p>Angular 에서 재사용 가능한 컴포넌트를 사용하는 주요 이점 중 하나는 코드 중복을 줄이고 코드 유지 관리성을 높이는 기능입니다. 잘 설계되고 잘 문서화된 컴포넌트 세트를 만들면 다른 개발자가 우리 애플리케이션에서 더 쉽게 작업할 수 있을 뿐만 아니라 시간이 지남에 따라 코드를 더 쉽게 유지 관리하고 업데이트할 수도 있습니다.</p><p>전반적으로 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하는 것은 웹 애플리케이션의 품질과 유지 관리성을 향상시키는 강력한 기술입니다. 이러한 사례를 따르고 다양한 컴포넌트 디자인을 실험함으로써 다양한 웹 애플리케이션을 구축하는 데 사용할 수 있는 강력하고 유연한 컴포넌트 세트를 만들 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/26/angular-16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 애니메이션(Animation) 설명</title>
      <link>http://hgko1207.github.io/2023/08/25/angular-15/</link>
      <guid>http://hgko1207.github.io/2023/08/25/angular-15/</guid>
      <pubDate>Fri, 25 Aug 2023 13:36:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 동적 웹 애플리케이션을 생성하기 위한 다양한 도구와 기능을 제공하는 강력한 JavaScript 프레임워크입니다. Angular의 주요 기능 중 하나는 애니메이션을 만드는 기능입니다. Angular 애
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 동적 웹 애플리케이션을 생성하기 위한 다양한 도구와 기능을 제공하는 강력한 JavaScript 프레임워크입니다. Angular의 주요 기능 중 하나는 애니메이션을 만드는 기능입니다. Angular 애니메이션은 움직임, 전환 및 기타 시각 효과를 추가하여 웹 애플리케이션에 생기를 불어넣는 방법을 제공합니다.</p><p>이 글에서는 interfaces, functions, classes, type aliases 및 lifecycle hooks 등을 포함하여 Angular 애니메이션의 다양한 측면을 다룰 것입니다.</p><h2 id="Animations-Module">Animations Module</h2><p>Angular 애니메이션 모듈은 Angular 애플리케이션에서 애니메이션을 정의하고 관리하는 기본 모듈입니다. 복잡하고 아름다운 애니메이션을 만드는 데 사용할 수 있는 다양한 인터페이스, 클래스 및 기능을 제공합니다.</p><h3 id="Animation-Metadata">Animation Metadata</h3><p>AnimationMetadata 인터페이스는 애니메이션 메타데이터를 정의하는 데 사용되는 기본 인터페이스입니다. <code>AnimationStyleMetadata</code>, <code>AnimationKeyframesSequenceMetadata</code> 및 <code>AnimationAnimateMetadata</code>를 포함한 여러 하위 인터페이스가 있습니다. 이러한 인터페이스는 생성할 수 있는 다양한 유형의 애니메이션을 정의하는 데 사용됩니다.</p><h4 id="AnimationStyleMetadata">AnimationStyleMetadata</h4><p>AnimationStyleMetadata 인터페이스는 애니메이션 스타일을 정의하는 데 사용됩니다. 여기에는 애니메이션의 타이밍과 모양을 정의하는 데 사용할 수 있는 <code>offset</code>, <code>style</code> 및 <code>animateChild</code> 와 같은 속성이 있습니다.</p><h4 id="AnimationKeyframesSequenceMetadata">AnimationKeyframesSequenceMetadata</h4><p>AnimationKeyframesSequenceMetadata 인터페이스는 애니메이션 키프레임 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 키프레임과 옵션을 정의하는 데 사용할 수 있는 <code>steps</code> 및 <code>options</code> 과 같은 속성이 있습니다.</p><h4 id="AnimationAnimateMetadata">AnimationAnimateMetadata</h4><p>AnimationAnimateMetadata 인터페이스는 애니메이션 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 스타일, 키프레임 및 옵션을 정의하는 데 사용할 수 있는 <code>style</code>, <code>keyframes</code> 및 <code>options</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationTriggerMetadata">AnimationTriggerMetadata</h3><p>AnimationTriggerMetadata 인터페이스는 애니메이션 트리거를 정의하는 데 사용됩니다. 여기에는 트리거 이름, 애니메이션 정의 및 트리거 옵션을 정의하는 데 사용할 수 있는 <code>name</code>, <code>definitions</code> 및 <code>options</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationBuilder">AnimationBuilder</h3><p>AnimationBuilder 클래스는 애니메이션을 생성하고 구성하는 데 사용됩니다. 여기에는 애니메이션 시퀀스를 사용자에 맞게 사용할 수 있는 <code>build</code>, <code>before</code>, <code>after</code> 및 <code>delay</code> 과 같은 메서드가 있습니다.</p><h3 id="AnimationFactory">AnimationFactory</h3><p>AnimationFactory 클래스는 애니메이션 팩토리를 만드는 데 사용됩니다. 여기에는 새 애니메이션 팩토리를 만드는 데 사용할 수 있는 <code>create</code> 와 같은 메서드가 있습니다.</p><h3 id="AnimationPlayer">AnimationPlayer</h3><p>AnimationPlayer 클래스는 애니메이션을 관리하는 데 사용됩니다. 여기에는 애니메이션 수명주기를 관리하는 데 사용할 수 있는 <code>play</code>, <code>pause</code>, <code>reset</code>, <code>finish</code> 와 같은 메서드가 있습니다.</p><h3 id="AnimationEvent">AnimationEvent</h3><p>AnimationEvent 클래스는 애니메이션 이벤트를 나타내는 데 사용됩니다. 여기에는 애니메이션 이벤트에 대한 정보를 검색하는 데 사용할 수 있는 <code>fromState</code>, <code>toState</code> 및 <code>totalTime</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationDriver">AnimationDriver</h3><p>AnimationDriver 인터페이스는 애니메이션 드라이버를 정의하는 데 사용됩니다. 여기에는 애니메이션을 생성하고 관리하는 데 사용할 수 있는 <code>animate</code>, <code>Listen</code> 및 <code>Flush</code> 와 같은 메서드가 있습니다.</p><h2 id="Animation-Types">Animation Types</h2><p>Angular는 역동적이고 매력적인 웹 애플리케이션을 만드는 데 사용할 수 있는 다양한 유형의 애니메이션을 제공합니다. 이러한 애니메이션 유형은 다음과 같습니다.</p><h3 id="Transition-Animation">Transition Animation</h3><p>Transition Animation은 상태나 뷰 간의 원활한 전환을 만드는 데 사용됩니다. fades, slides, rotations 과 같은 애니메이션을 만드는 데 사용할 수 있습니다.</p><h3 id="Animation-Sequencing">Animation Sequencing</h3><p>Animation Sequencing은 특정 순서로 발생하는 애니메이션을 만드는 데 사용됩니다. 여러 단계나 시퀀스가 포함된 복잡한 애니메이션을 만드는 데 사용할 수 있습니다.</p><h3 id="Keyframe-Animation">Keyframe Animation</h3><p>Keyframe Animation은 특정 키프레임이나 시점에 발생하는 애니메이션을 만드는 데 사용됩니다. 진동하는 버튼이나 깜박이는 배너와 같은 애니메이션을 만드는 데 사용할 수 있습니다.</p><h3 id="State-Change-Animation">State Change Animation</h3><p>상태 변경 애니메이션은 상태가 변경될 때 발생하는 애니메이션을 만드는 데 사용됩니다. 확인란을 전환하거나 패널을 확장하는 등의 애니메이션을 만드는 데 사용할 수 있습니다.</p><h2 id="Animations-Interfaces">Animations Interfaces</h2><p>앞서 설명한 AnimationMetadata 및 AnimationTriggerMetadata 인터페이스 외에도 Angular에서 애니메이션을 만드는 데 사용할 수 있는 다른 인터페이스가 몇 가지 있습니다. 이러한 인터페이스에는 다음이 포함됩니다.</p><h3 id="AnimationStateMetadata">AnimationStateMetadata</h3><p>AnimationStateMetadata 인터페이스는 애니메이션 상태를 정의하는 데 사용됩니다. 여기에는 상태 이름과 스타일을 정의하는 데 사용할 수 있는 <code>name</code> 및 <code>style</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationTransitionMetadata">AnimationTransitionMetadata</h3><p>AnimationTransitionMetadata 인터페이스는 애니메이션 전환을 정의하는 데 사용됩니다. 여기에는 한 상태에서 다른 상태로의 전환을 정의하는 데 사용할 수 있는 <code>fromState</code>, <code>toState</code> 및 <code>animation</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationQueryMetadata">AnimationQueryMetadata</h3><p>AnimationQueryMetadata 인터페이스는 애니메이션 쿼리를 정의하는 데 사용됩니다. 여기에는 쿼리에 대한 선택기, 애니메이션 및 제한을 정의하는 데 사용할 수 있는 <code>selector</code>, <code>animation</code> 및 <code>limit</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationStaggerMetadata">AnimationStaggerMetadata</h3><p>AnimationStaggerMetadata 인터페이스는 애니메이션 스태거를 정의하는 데 사용됩니다. 여기에는 애니메이션 순서와 타이밍을 정의하는 데 사용할 수 있는 <code>animate</code>, <code>start</code>, <code>interval</code> 및 <code>by</code> 과 같은 속성이 있습니다.</p><h3 id="AnimationGroupMetadata">AnimationGroupMetadata</h3><p>AnimationGroupMetadata 인터페이스는 애니메이션 그룹을 정의하는 데 사용됩니다. 여기에는 애니메이션 그룹의 단계를 정의하는 데 사용할 수 있는 <code>steps</code> 와 같은 속성이 있습니다.</p><h2 id="Animation-Functions">Animation Functions</h2><p>Angular는 애니메이션을 만드는 데 사용할 수 있는 여러 내장 함수를 제공합니다. 이러한 기능에는 다음이 포함됩니다.</p><h3 id="animate">animate()</h3><p>animate() 함수는 키프레임 애니메이션을 만드는 데 사용됩니다. 지속 시간과 일련의 키프레임을 매개변수로 사용합니다.</p><h3 id="transition">transition()</h3><p>transition() 함수는 전환 애니메이션을 생성하는 데 사용됩니다. 두 가지 상태, 스타일 세트, 선택적 타이밍 기능을 매개변수로 사용합니다.</p><h3 id="trigger">trigger()</h3><p>trigger() 함수는 애니메이션 트리거를 정의하는 데 사용됩니다. 이름과 일련의 애니메이션 정의를 매개변수로 사용합니다.</p><h2 id="Animation-Enums">Animation Enums</h2><p>Angular는 애니메이션을 구성하는 데 사용할 수 있는 여러 열거형도 제공합니다. 이러한 열거형에는 다음이 포함됩니다.</p><h3 id="AnimationStyleMetadata-2">AnimationStyleMetadata</h3><p>AnimationStyleMetadata 열거형은 애니메이션의 타이밍과 모양을 정의하는 데 사용됩니다. 여기에는 애니메이션의 모양과 타이밍을 정의하는 데 사용할 수 있는 <code>opacity</code>, <code>transform</code> 및 <code>display</code> 와 같은 속성이 있습니다.</p><h3 id="AnimationMetadataType">AnimationMetadataType</h3><p>AnimationMetadataType 열거형은 애니메이션 메타데이터 유형을 정의하는 데 사용됩니다. 여기에는 다양한 유형의 애니메이션 메타데이터에 해당하는 <code>Style</code>, <code>Keyframes</code>, <code>Animate</code> 과 같은 값이 있습니다.</p><h2 id="Animation-Consts">Animation Consts</h2><p>마지막으로 Angular는 애니메이션을 구성하는 데 사용할 수 있는 몇 가지 내장 상수를 제공합니다. 이러한 상수에는 다음이 포함됩니다.</p><h3 id="AUTO-STYLE">AUTO_STYLE</h3><p>AUTO_STYLE 상수는 요소의 스타일을 자동 스타일로 설정하는 데 사용됩니다. 요소의 자연 상태에 적응하는 동적 애니메이션을 만드는 데 사용할 수 있습니다.</p><h3 id="TIME">TIME</h3><p>TIME 상수는 애니메이션의 타이밍을 설정하는 데 사용됩니다. 특정 기간 동안 발생하는 애니메이션을 만드는 데 사용할 수 있습니다.</p><h2 id="Animation-Lifecycle-Hooks">Animation Lifecycle Hooks</h2><p>Angular는 애니메이션을 제어하는 데 사용할 수 있는 여러 수명 주기 후크를 제공합니다. 이러한 후크에는 다음이 포함됩니다.</p><h3 id="AnimationStart">AnimationStart</h3><p>AnimationStart Hook 는 애니메이션 재생이 시작될 때 호출됩니다.</p><h3 id="AnimationDone">AnimationDone</h3><p>AnimationDone Hook 는 애니메이션이 완료되면 호출됩니다.</p><h3 id="AnimationDestroy">AnimationDestroy</h3><p>AnimationDestroy Hook 는 애니메이션이 삭제될 때 호출됩니다.</p><p>이러한 Hook 를 사용하면 애니메이션이 완료될 때 다른 애니메이션을 시작하거나 중지하는 등의 추가 작업을 수행할 수 있습니다.</p><h2 id="Animation-Testing">Animation Testing</h2><p>Angular는 단위 및 통합 테스트에서 애니메이션을 테스트하기 위한 여러 도구를 제공합니다. 이러한 도구에는 다음이 포함됩니다.</p><h3 id="MockAnimationPlayer">MockAnimationPlayer</h3><p>MockAnimationPlayer 클래스는 테스트에 사용할 수 있는 모의 애니메이션 플레이어를 만드는 데 사용됩니다. 애니메이션 재생, 일시정지, 완료 등 애니메이션을 시뮬레이션하는 방법을 제공합니다.</p><h3 id="NoopAnimationsModule">NoopAnimationsModule</h3><p>NoopAnimationsModule은 테스트에서 애니메이션을 비활성화하는 데 사용됩니다. 실제로 애니메이션을 실행하지 않고 애니메이션을 사용하는 컴포넌트를 테스트하는 데 사용할 수 있습니다.</p><p>다음은 Angular 애니메이션의 사용을 보여주는 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  trigger,</span><br><span class="line">  state,</span><br><span class="line">  style,</span><br><span class="line">  transition,</span><br><span class="line">  animate,</span><br><span class="line">  AnimationEvent,</span><br><span class="line">  AnimationBuilder,</span><br><span class="line">  AnimationFactory,</span><br><span class="line">  AnimationPlayer,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@angular/animations'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-animation-example'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div (click)="toggleState()" [@myTrigger]="currentState"&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; currentState &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  animations: [</span><br><span class="line">    trigger(<span class="string">'myTrigger'</span>, [</span><br><span class="line">      state(<span class="string">'one'</span>, style(&#123; transform: <span class="string">'translateX(0)'</span> &#125;)),</span><br><span class="line">      state(<span class="string">'two'</span>, style(&#123; transform: <span class="string">'translateX(100%)'</span> &#125;)),</span><br><span class="line">      transition(<span class="string">'one =&gt; two'</span>, animate(<span class="string">'500ms ease-in'</span>)),</span><br><span class="line">      transition(<span class="string">'two =&gt; one'</span>, animate(<span class="string">'500ms ease-out'</span>)),</span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AnimationExampleComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  currentState = <span class="string">'one'</span>;</span><br><span class="line">  <span class="keyword">private</span> player: AnimationPlayer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> builder: AnimationBuilder</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.createPlayer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toggleState(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.currentState === <span class="string">'one'</span> ? <span class="string">'two'</span> : <span class="string">'one'</span>;</span><br><span class="line">    <span class="keyword">this</span>.player.play();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> createPlayer(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> factory: AnimationFactory = <span class="keyword">this</span>.builder.build([style(&#123; opacity: <span class="number">0</span> &#125;), animate(<span class="string">'1s'</span>, style(&#123; opacity: <span class="number">1</span> &#125;))]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.player = factory.create(<span class="built_in">document</span>.querySelector(<span class="string">'div'</span>));</span><br><span class="line">    <span class="keyword">this</span>.player.play();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onAnimationStart(event: AnimationEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Animation started: <span class="subst">$&#123;event.triggerName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onAnimationDone(event: AnimationEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Animation ended: <span class="subst">$&#123;event.triggerName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에는 <code>[@myTrigger]</code> 애니메이션 트리거를 사용하여 두 상태 간을 전환하는 간단한 컴포넌트가 있습니다. 트리거 이름과 상태 및 전환 배열을 사용하는 <code>trigger()</code> 함수를 사용하여 트리거를 정의합니다. 또한 컴포넌트에 대한 페이드인 애니메이션을 생성하는 <code>AnimationBuilder</code> 클래스를 사용하여 두 번째 애니메이션을 정의합니다.</p><p>컴포넌트가 초기화되면 <code>AnimationFactory</code> 클래스와 <code>AnimationBuilder</code> 를 사용하여 <code>AnimationPlayer</code> 클래스의 인스턴스를 만듭니다. 이 플레이어를 사용하여 컴포넌트가 로드될 때 페이드인 애니메이션을 재생합니다.</p><p>사용자가 컴포넌트를 클릭하면 현재 상태를 전환하고 <code>AnimationPlayer</code> 를 사용하여 전환 애니메이션을 재생합니다.</p><p>마지막으로 애니메이션이 시작되고 끝날 때 각각 호출되는 <code>onAnimationStart</code> 및 <code>onAnimationDone</code> 이라는 두 개의 수명 주기 Hook 를 정의합니다. 이 예에서는 이러한 Hook 가 호출될 때 콘솔에 메시지를 기록합니다.</p><p>다음은 Angular 애니메이션을 사용하여 커스터마이징 애니메이션 로딩 스피너를 만드는 방법을 보여주는 좀 더 복잡한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  trigger,</span><br><span class="line">  style,</span><br><span class="line">  animate,</span><br><span class="line">  transition,</span><br><span class="line">  keyframes,</span><br><span class="line">  AnimationBuilder,</span><br><span class="line">  AnimationFactory,</span><br><span class="line">  AnimationPlayer,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@angular/animations'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-spinner'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="spinner" *ngIf="show"&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="bar" *ngFor="let bar of bars; let i = index" [@loadingState]="i + 1"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  styles: [</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      .spinner &#123;</span></span><br><span class="line"><span class="string">        display: flex;</span></span><br><span class="line"><span class="string">        justify-content: center;</span></span><br><span class="line"><span class="string">        align-items: center;</span></span><br><span class="line"><span class="string">        height: 100%;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      .bar &#123;</span></span><br><span class="line"><span class="string">        width: 5px;</span></span><br><span class="line"><span class="string">        height: 20px;</span></span><br><span class="line"><span class="string">        margin: 0 5px;</span></span><br><span class="line"><span class="string">        border-radius: 2px;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  ],</span><br><span class="line">  animations: [</span><br><span class="line">    trigger(<span class="string">'loadingState'</span>, [</span><br><span class="line">      transition(</span><br><span class="line">        <span class="string">'* =&gt; 1'</span>,</span><br><span class="line">        animate(</span><br><span class="line">          <span class="string">'&#123;&#123;duration&#125;&#125;'</span>,</span><br><span class="line">          keyframes([</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">0</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(1)'</span>, offset: <span class="number">0.5</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">1</span> &#125;),</span><br><span class="line">          ])</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      transition(</span><br><span class="line">        <span class="string">'* =&gt; 2'</span>,</span><br><span class="line">        animate(</span><br><span class="line">          <span class="string">'&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;'</span>,</span><br><span class="line">          keyframes([</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">0</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(1)'</span>, offset: <span class="number">0.5</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">1</span> &#125;),</span><br><span class="line">          ])</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      transition(</span><br><span class="line">        <span class="string">'* =&gt; 3'</span>,</span><br><span class="line">        animate(</span><br><span class="line">          <span class="string">'&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;'</span>,</span><br><span class="line">          keyframes([</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">0</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(1)'</span>, offset: <span class="number">0.5</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">1</span> &#125;),</span><br><span class="line">          ])</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      transition(</span><br><span class="line">        <span class="string">'* =&gt; 4'</span>,</span><br><span class="line">        animate(</span><br><span class="line">          <span class="string">'&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;'</span>,</span><br><span class="line">          keyframes([</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">0</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(1)'</span>, offset: <span class="number">0.5</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">1</span> &#125;),</span><br><span class="line">          ])</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      transition(</span><br><span class="line">        <span class="string">'* =&gt; 5'</span>,</span><br><span class="line">        animate(</span><br><span class="line">          <span class="string">'&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;'</span>,</span><br><span class="line">          keyframes([</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">0</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(1)'</span>, offset: <span class="number">0.5</span> &#125;),</span><br><span class="line">            style(&#123; transform: <span class="string">'scaleY(0)'</span>, offset: <span class="number">1</span> &#125;),</span><br><span class="line">          ])</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SpinnerComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>() duration = <span class="string">'500ms'</span>;</span><br><span class="line">  <span class="meta">@Input</span>() delay = <span class="string">'100ms'</span>;</span><br><span class="line">  <span class="meta">@Input</span>() count = <span class="number">5</span>;</span><br><span class="line">  show = <span class="literal">false</span>;</span><br><span class="line">  bars: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> builder: AnimationBuilder</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.bars = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.count).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.show = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.createPlayer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> createPlayer(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> factory: AnimationFactory = <span class="keyword">this</span>.builder.build([</span><br><span class="line">      style(&#123; opacity: <span class="number">0</span> &#125;),</span><br><span class="line">      animate(<span class="string">'1s'</span>, style(&#123; opacity: <span class="number">1</span> &#125;)),</span><br><span class="line">      animate(<span class="string">'1s'</span>, style(&#123; opacity: <span class="number">0</span> &#125;)),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.player = factory.create(<span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>));</span><br><span class="line">    <span class="keyword">this</span>.player.onDone(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="keyword">this</span>.show = <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">this</span>.player.play();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에는 사용자에 맞게 애니메이션 로딩 스피너를 표시하는 컴포넌트가 있습니다. 스피너는 순차적으로 펄스 및 크기 증가 및 감소하는 5개의 수직 막대로 구성됩니다. 애니메이션 키프레임을 지정하기 위해 <code>trigger()</code> 함수와 <code>keyframes()</code> 함수를 사용하여 애니메이션을 정의합니다.</p><h2 id="결론">결론</h2><p>요약하면 Angular는 웹 애플리케이션에서 애니메이션을 생성, 제어 및 테스트하기 위한 포괄적인 도구 세트를 제공합니다. 이러한 도구에는 사용자 경험을 향상하고 애플리케이션에 생명을 불어넣는 복잡하고 매력적인 애니메이션을 만드는 데 사용할 수 있는 interfaces, functions, classes, type aliases 및 lifecycle hooks 가 포함됩니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/25/angular-15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] 성능 최적화(Performance optimization)</title>
      <link>http://hgko1207.github.io/2023/08/25/angular-14/</link>
      <guid>http://hgko1207.github.io/2023/08/25/angular-14/</guid>
      <pubDate>Fri, 25 Aug 2023 05:31:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt;는 개발자가 고성능 웹 애플리케이션을 구축하는 데 도움을 줄 수 있는 강력한 프론트 엔드 프레임워크입니다. 그러나 애플리케이션이 복잡해짐에 따라 원하는 수준의 성능을 유지하는 것이 더욱 어려워질 수 있습
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong>는 개발자가 고성능 웹 애플리케이션을 구축하는 데 도움을 줄 수 있는 강력한 프론트 엔드 프레임워크입니다. 그러나 애플리케이션이 복잡해짐에 따라 원하는 수준의 성능을 유지하는 것이 더욱 어려워질 수 있습니다.</p><p>이 글에서는 Angular 성능을 최적화하는 몇 가지 기술을 살펴보겠습니다.</p><h2 id="1-지연-로딩-모듈-Lazy-Loading-Modules"><a class="header-anchor" href="#1-지연-로딩-모듈-Lazy-Loading-Modules">¶</a>1. 지연 로딩 모듈(Lazy Loading Modules)</h2><p>애플리케이션 성능이 저하되는 주요 이유 중 하나는 애플리케이션을 로드하는 데 걸리는 시간입니다. 이 문제를 해결하는 한 가지 방법은 지연 로딩을 사용하는 것입니다. 지연 로딩은 특정 경로에 필요한 모듈만 로드하는 기술입니다. 즉, 초기 로드 시간이 줄어들고 애플리케이션의 응답 속도가 빨라집니다.</p><p>다음은 Angular 애플리케이션에서 지연 로딩을 구현하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'admin'</span>,</span><br><span class="line">    loadChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./admin/admin.module'</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.AdminModule),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>admin</code> 경로에 액세스할 때 <code>AdminModule</code> 모듈을 지연 로딩합니다. 이 모듈은 필요할 때만 로드되므로 애플리케이션의 초기 로드 시간을 줄이는 데 도움이 됩니다.</p><h2 id="2-변화-감지-전략-Change-Detection-Strategies"><a class="header-anchor" href="#2-변화-감지-전략-Change-Detection-Strategies">¶</a>2. 변화 감지 전략(Change Detection Strategies)</h2><p>Angular는 변경 감지를 사용하여 데이터 변경 사항을 추적하고 그에 따라 뷰를 업데이트합니다. 기본적으로 Angular는 모든 변경 감지 주기에서 모든 컴포넌트를 확인하는 <code>Default</code> 라는 전략을 사용합니다. 특히 컴포넌트가 많은 대규모 애플리케이션의 경우 비용이 매우 많이 들 수 있습니다.</p><p>이 문제를 해결하기 위해 Angular는 몇 가지 변경 감지 전략을 제공합니다. 가장 일반적으로 사용되는 전략은 <code>OnPush</code> 입니다. 이 전략을 사용하면 컴포넌트의 입력 속성이 변경되거나 이벤트가 트리거될 때만 변경 감지가 실행됩니다. 이를 통해 불필요한 변경 감지 주기 수를 크게 줄일 수 있습니다.</p><p>다음은 <code>OnPush</code> 변경 감지 전략을 사용하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./my-component.component.html'</span>,</span><br><span class="line">  changeDetection: ChangeDetectionStrategy.OnPush,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponentComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>() myData: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>MyComponentComponent</code> 에 대한 <code>OnPush</code> 변경 감지 전략을 사용하고 있습니다. 즉, 변경 감지는 <code>myData</code> 입력 속성이 변경되거나 이벤트가 트리거될 때만 실행됩니다.</p><h2 id="3-변경-감지-최적화-Change-Detection-Optimization"><a class="header-anchor" href="#3-변경-감지-최적화-Change-Detection-Optimization">¶</a>3. 변경 감지 최적화(Change Detection Optimization)</h2><p><code>OnPush</code> 변경 감지 전략을 사용하더라도 불필요한 변경 감지 주기로 인해 성능 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해 여러 가지 최적화 기술을 사용할 수 있습니다.</p><h3 id="a-Immutable-Objects"><a class="header-anchor" href="#a-Immutable-Objects">¶</a>a. Immutable Objects</h3><p>불변 객체(Immutable Objects)는 생성된 후에는 변경할 수 없는 객체입니다. 애플리케이션에서 불변 객체를 사용함으로써 불필요한 변경 감지 주기 수를 줄일 수 있습니다. 변경 감지는 기존 객체가 업데이트될 때가 아니라 새 객체가 생성될 때만 실행되어야 하기 때문입니다.</p><p>다음은 Angular 애플리케이션에서 불변 객체를 사용하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly email: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>readonly</code> 키워드를 사용하여 <code>User</code> 인터페이스의 속성을 변경할 수 없게 만듭니다.</p><h3 id="b-TrackBy-Function"><a class="header-anchor" href="#b-TrackBy-Function">¶</a>b. TrackBy Function</h3><p><code>trackBy</code> 함수는 Angular에 내장된 최적화 기술입니다. 항목 목록의 변경 사항을 추적하는 방법을 Angular에 알려주는 데 사용됩니다. 기본적으로 Angular는 목록에 있는 각 항목의 ID를 비교하여 변경 사항을 추적합니다. 그러나 이는 특히 큰 목록의 경우 비용이 매우 많이 들 수 있습니다.</p><p>다음은 Angular 애플리케이션에서 <code>trackBy</code> 함수를 사용하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li *ngFor=<span class="string">"let user of users; trackBy: trackByUserId"</span>&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>trackBy</code> 함수를 사용하여 Angular 에 <code>id</code> 속성으로 <code>users</code> 목록의 변경 사항을 추적하도록 지시합니다. 이는 목록에 있는 항목의 <code>id</code> 속성이 변경될 때만 변경 감지가 실행되어야 함을 의미합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trackByUserId(index: <span class="built_in">number</span>, user: User): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> user.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제에서는 인덱스와 사용자 개체를 가져와 사용자 개체의 <code>id</code> 속성을 반환하는 <code>trackByUserId</code> 함수를 구현합니다.</p><h2 id="4-NgZone"><a class="header-anchor" href="#4-NgZone">¶</a>4. NgZone</h2><p><strong>NgZone</strong> 은 Angular 영역 외부에서 코드를 실행하는 방법을 제공하는 Angular 에 내장된 서비스입니다. Angular 영역은 변경 감지 및 기타 Angular 관련 작업을 담당하는 실행 컨텍스트입니다. Angular 영역 외부에서 코드를 실행하면 애플리케이션 성능을 향상시킬 수 있습니다.</p><p>다음은 Angular 애플리케이션에서 NgZone을 사용하는 방법에 대한 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, NgZone &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./my-component.component.html'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponentComponent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> ngZone: NgZone</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  runOutsideAngular(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.ngZone.runOutsideAngular(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Code to run outside of the Angular zone</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>NgZone</code> 서비스를 사용하여 Angular 영역 외부에서 코드를 실행합니다. <code>runOutsideAngular</code> 메서드를 호출하고 Angular 영역 외부에서 실행되는 코드가 포함된 콜백 함수를 전달하여 이를 수행합니다.</p><p>외부 API 에서 일부 데이터를 가져와서 화면에 표시하는 컴포넌트가 있다고 가정해 보겠습니다. API 호출을 완료하는 데 오랜 시간이 걸릴 수 있으며, 이로 인해 애플리케이션이 정지되고 응답하지 않게 될 수 있습니다. 이러한 일이 발생하지 않도록 하려면 NgZone을 사용하여 Angular 영역 외부에서 API 호출을 실행하면 애플리케이션이 계속해서 원활하게 실행될 수 있습니다.</p><p>컴포넌트의 코드는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, NgZone &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-component'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./my-component.component.html'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponentComponent &#123;</span><br><span class="line">  data: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient, <span class="keyword">private</span> ngZone: NgZone</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  fetchData(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// Run the API call outside of the Angular zone</span></span><br><span class="line">    <span class="keyword">this</span>.ngZone.runOutsideAngular(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Make the API call</span></span><br><span class="line">      <span class="keyword">this</span>.http.get(<span class="string">'https://api.example.com/data'</span>).subscribe(</span><br><span class="line">        (data) =&gt; &#123;</span><br><span class="line">          <span class="comment">// Update the data property with the fetched data</span></span><br><span class="line">          <span class="keyword">this</span>.ngZone.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        (error) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(error);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서는 <code>HttpClient</code> 서비스를 사용하여 <code>https://api.example.com/data</code>에 대한 API 호출을 만듭니다. 또한 <code>NgZone</code> 서비스를 사용하여 Angular 영역 외부에서 API 호출을 실행한 다음 Angular 영역 내부에서 가져온 데이터로 <code>data</code> 속성을 업데이트합니다. 이렇게 하면 API 호출이 진행되는 동안 애플리케이션의 응답성이 유지됩니다.</p><p>또한 API 호출 중에 발생할 수 있는 모든 오류를 콘솔에 기록하여 처리하고 있습니다.</p><p>템플릿에서 이 컴포넌트를 사용하려면 다음과 같이 할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button (click)=<span class="string">"fetchData()"</span>&gt;Fetch Data&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div *ngIf="data"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li *ngFor="let item of data"&gt;</span></span><br><span class="line"><span class="regexp">      &#123;&#123; item.name &#125;&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h2 id="결론"><a class="header-anchor" href="#결론">¶</a>결론</h2><p>Angular 성능을 최적화하기 위한 몇 가지 기술을 살펴보았습니다. 지연 로딩, 변경 감지 전략, 변경 감지 최적화 기술 및 NgZone을 사용하여 애플리케이션 성능을 향상하고 더 나은 사용자 경험을 제공할 수 있습니다. 성능 최적화는 지속적인 프로세스라는 점을 명심하는 것이 중요하며 잠재적인 개선 영역이 있는지 애플리케이션을 지속적으로 평가해야 합니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/08/25/angular-14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] 콘솔 프로그램 백그라운드(창 없이) 실행 방법</title>
      <link>http://hgko1207.github.io/2023/07/31/csharp-2/</link>
      <guid>http://hgko1207.github.io/2023/07/31/csharp-2/</guid>
      <pubDate>Mon, 31 Jul 2023 13:25:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;일반적으로 C# 에서 외부 프로그램(.exe 등)을 실행시킬 때 &lt;code&gt;Process&lt;/code&gt; 를 많이 사용합니다.&lt;/p&gt;
&lt;p&gt;콘솔(Console; 도스 커맨드 창)로 실행되는 프로그램을 실행하는 경우 콘솔 창이 화면에 나타나서 UI 상
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>일반적으로 C# 에서 외부 프로그램(.exe 등)을 실행시킬 때 <code>Process</code> 를 많이 사용합니다.</p><p>콘솔(Console; 도스 커맨드 창)로 실행되는 프로그램을 실행하는 경우 콘솔 창이 화면에 나타나서 UI 상으로 불편한 경우가 있습니다.</p><p><code>Process</code> 로 콘솔 창을 띄우는 외부 프로그램을 실행 시 콘솔 창을 백그라운드로 실행해 안보이도록 하려면 아래와 같이 합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test.Utils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> arg = <span class="string">"..."</span>;</span><br><span class="line"></span><br><span class="line">            Process process = <span class="keyword">new</span> Process();</span><br><span class="line">            process.StartInfo.FileName = <span class="string">@".\ffmpeg.exe"</span>;</span><br><span class="line">            process.StartInfo.Arguments = arg;</span><br><span class="line"></span><br><span class="line">            process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;  <span class="comment">// 윈도우 속성을 windows hidden 으로 지정</span></span><br><span class="line">            process.StartInfo.CreateNoWindow = <span class="literal">true</span>;                    <span class="comment">// hidden 을 시키기 위해서 이 속성도 true 로 체크해야 함</span></span><br><span class="line"></span><br><span class="line">            process.Start();</span><br><span class="line">            process.WaitForExit(); <span class="comment">// 종료시까지 대기</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>추가로 외부 프로그램에서 출력한 값을 읽어와서 출력하는 방법은 아래와 같습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test.Utils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> arg = <span class="string">"..."</span>;</span><br><span class="line"></span><br><span class="line">            Process process = <span class="keyword">new</span> Process();</span><br><span class="line">            process.StartInfo.FileName = <span class="string">@".\ffmpeg.exe"</span>;</span><br><span class="line">            process.StartInfo.Arguments = arg;</span><br><span class="line"></span><br><span class="line">            process.StartInfo.UseShellExecute = <span class="literal">false</span>;       <span class="comment">// 스트림을 읽는데 필요</span></span><br><span class="line">            process.StartInfo.CreateNoWindow = <span class="literal">false</span>;</span><br><span class="line">            process.StartInfo.RedirectStandardOutput = <span class="literal">true</span>; <span class="comment">// 실행한 프로그램의 출력을 얻는다.</span></span><br><span class="line"></span><br><span class="line">            process.Start();</span><br><span class="line">            process.WaitForExit(); <span class="comment">// 종료시까지 대기</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> result = process.StandardOutput.ReadToEnd(); <span class="comment">// 실행한 프로그램의 출력을 읽는다.</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"result =&gt; "</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/31/csharp-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Eclipse] 프로젝트에 jar 파일 추가하는 방법</title>
      <link>http://hgko1207.github.io/2023/07/29/eclipse-1/</link>
      <guid>http://hgko1207.github.io/2023/07/29/eclipse-1/</guid>
      <pubDate>Sat, 29 Jul 2023 04:48:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이클립스에서 라이브러리(jar 파일)를 추가하는 방법입니다.&lt;br /&gt;
일반적인 자바 프로젝트와 웹 프로젝트일 경우 두 가지로 방법으로 나눠집니다.&lt;/p&gt;
&lt;h2 id=&quot;자바-프로젝트&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이클립스에서 라이브러리(jar 파일)를 추가하는 방법입니다.<br />일반적인 자바 프로젝트와 웹 프로젝트일 경우 두 가지로 방법으로 나눠집니다.</p><h2 id="자바-프로젝트"><a class="markdownIt-Anchor" href="#자바-프로젝트"></a> 자바 프로젝트</h2><p><strong>1. 프로젝트 우클릭 &gt; properties</strong></p><img width="50%" src="/images/eclipse/1.png" alt="다운로드" title="" ><p><strong>2. Java Build Path &gt; Libraries &gt; Add External JARs</strong></p><p><img src="/images/eclipse/2.png" alt="Add External JARs" /></p><p><strong>3. 폴더에서 jar 파일 선택</strong></p><p><img src="/images/eclipse/3.png" alt="jar 파일 선택" /></p><p><strong>4. 라이브러리 추가 후 [Apply and Close] 클릭</strong></p><p><img src="/images/eclipse/4.png" alt="Apply and Close" /></p><h2 id="웹-프로젝트maven"><a class="markdownIt-Anchor" href="#웹-프로젝트maven"></a> 웹 프로젝트(Maven)</h2><p><strong>1. 아래와 같이 <code>src/main/web/WEB-INF/lib</code> 폴더를 생성하고 lib 폴더에 라이브러리 파일을 넣어준다.</strong></p><p><img src="/images/eclipse/5.png" alt="폴더" /></p><p><strong>2. 프로젝트 우클릭 &gt; properties</strong></p><img width="50%" src="/images/eclipse/1.png" alt="properties" title="properties" ><p><strong>3. Java Build Path &gt; Libraries &gt; Add Library</strong></p><p><img src="/images/eclipse/6.png" alt="Add Library" /></p><p><strong>4. Web App Libraries 선택 후 [Next] 클릭</strong></p><p><img src="/images/eclipse/7.png" alt="Web App Libraries" /></p><p><strong>5. 프로젝트 선택 후 [Finish] 클릭</strong></p><img width="70%" src="/images/eclipse/8.png" alt="Finish" title="Finish" ><p><strong>6. Web App Libraries 추가 확인 후 [Apply and Close] 클릭</strong></p><p><img src="/images/eclipse/9.png" alt="Apply and Close" /></p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>라이브러리(jar 파일) 추가 후 코드에서 import해서 사용하시면 됩니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/29/eclipse-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자동가입 방지문자(SimpleCaptcha) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/07/29/web-1/</link>
      <guid>http://hgko1207.github.io/2023/07/29/web-1/</guid>
      <pubDate>Sat, 29 Jul 2023 04:25:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;로그인 또는 회원가입 시 자동 등록 방지가 필요할 경우가 있다.&lt;br /&gt;
이를 구현하기 위해 여러가지가 있는데 CATPCHA를 사용하는 방법을 사용하였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CAPTCHA는 HIP 기술의 일종으로, 어떠한 사용
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>로그인 또는 회원가입 시 자동 등록 방지가 필요할 경우가 있다.<br />이를 구현하기 위해 여러가지가 있는데 CATPCHA를 사용하는 방법을 사용하였다.</p><blockquote><p>CAPTCHA는 HIP 기술의 일종으로, 어떠한 사용자가 실제 사람인지 컴퓨터 프로그램인지를 구별하기 위해 사용되는 방법이다. 사람은 구별할 수 있지만 컴퓨터는 구별하기 힘들게 의도적으로 비틀거나 덧칠한 그림을 주고 그 그림에 쓰여 있는 내용을 물어보는 방법이 자주 사용된다. <a href="https://ko.wikipedia.org/wiki/CAPTCHA" target="_blank" rel="noopener">위키백과</a></p></blockquote><h2 id="다운로드"><a class="markdownIt-Anchor" href="#다운로드"></a> 다운로드</h2><p>CATPCHA를 사용하기 위해선 <a href="https://sourceforge.net/projects/simplecaptcha/" target="_blank" rel="noopener">https://sourceforge.net/projects/simplecaptcha/</a> 사이트로 이동해서 jar 파일을 다운로드 받는다.</p><p><img src="/images/web/1.png" alt="다운로드" /></p><h2 id="jar-파일-추가"><a class="markdownIt-Anchor" href="#jar-파일-추가"></a> jar 파일 추가</h2><p>사용하는 툴이 이클립스 일 경우 jar 파일을 프로젝트에 포함시켜야 한다.</p><p><a href="https://hgko1207.github.io/2023/07/29/eclipse-1/">[Eclipse] 프로젝트에 jar 파일 추가하는 방법</a> 사이트를 참고해서 추가합니다.</p><h2 id="사용"><a class="markdownIt-Anchor" href="#사용"></a> 사용</h2><h3 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h3><p>먼저 자동입력 방지 기능을 넣기 위한 화면 코드다. CATPCHA 이미지를 보여주고 이미지 안의 숫자들을 새로고침 할 수 있는 버튼을 만들었다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mt-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-label fw-bold"</span>&gt;</span>자동입력 방지문자<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"d-flex"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"captchaImg"</span> <span class="attr">src</span>=<span class="string">"captchaImg"</span> <span class="attr">title</span>=<span class="string">"캡차 이미지"</span> <span class="attr">alt</span>=<span class="string">"캡차 이미지"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"refresh_btn"</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-gray w-50 ms-2"</span>&gt;</span>새로고침<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"d-flex mt-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"captcha"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control input-control"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="controller-부분"><a class="markdownIt-Anchor" href="#controller-부분"></a> Controller 부분</h3><p>html 에서 <code>/captchaImg</code> 경로를 호출하면 아래 컨트롤러가 호출된다. Captcha 이미지 설정을 한 후 세션에 값을 저장하고 이미지를 그려준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * captchaImg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"captchaImg"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captchaImg</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 폰트 설정 =========================================================</span></span><br><span class="line">    List&lt;Font&gt; fontList = <span class="keyword">new</span> ArrayList&lt;Font&gt;();</span><br><span class="line">    fontList.add(<span class="keyword">new</span> Font(<span class="string">""</span>, Font.HANGING_BASELINE, <span class="number">28</span>));</span><br><span class="line">    fontList.add(<span class="keyword">new</span> Font(<span class="string">"Courier"</span>, Font.ITALIC, <span class="number">28</span>));</span><br><span class="line">    fontList.add(<span class="keyword">new</span> Font(<span class="string">""</span>, Font.PLAIN, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;Color&gt; colorList = <span class="keyword">new</span> ArrayList&lt;Color&gt;();</span><br><span class="line">    colorList.add(Color.black);</span><br><span class="line"></span><br><span class="line">    Captcha captcha = <span class="keyword">new</span> Captcha.Builder(<span class="number">200</span>, <span class="number">36</span>) <span class="comment">// 이미지 크기 설정</span></span><br><span class="line">        .addText(<span class="keyword">new</span> NumbersAnswerProducer(<span class="number">6</span>), <span class="keyword">new</span> DefaultWordRenderer(colorList, fontList))</span><br><span class="line">        <span class="comment">//.gimp(new DropShadowGimpyRenderer()).gimp() // 그림자 효과 추가</span></span><br><span class="line">        .addNoise().addNoise() <span class="comment">// 한번 호출할 떄마다 하나의 라인이 추가된다</span></span><br><span class="line">        .addBackground(<span class="keyword">new</span> GradiatedBackgroundProducer())  <span class="comment">// Gradiated백그라운드 효과 추가</span></span><br><span class="line">        .addBorder() <span class="comment">// 검정 테두리 선 생성</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 캐쉬를 지우기 위해 헤더값을 설정</span></span><br><span class="line">    response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">"Max-Age"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 리턴값을 image형태로 설정</span></span><br><span class="line">    response.setContentType(<span class="string">"image/png"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 세션에 자동가입방지 문자를 저장한다.</span></span><br><span class="line">    request.getSession().setAttribute(Captcha.NAME, captcha);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image를 write 한다</span></span><br><span class="line">    CaptchaServletUtil.writeImage(response, captcha.getImage());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 현재 보여지는 자동입력 방지문자와 입력한 문자가 일치하는 하는지 확인하는 코드다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 자동입력 방지문자 확인</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"isCorrect"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; isCorrect(HttpServletRequest request, String answer) &#123;</span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Captcha captcha = (Captcha) request.getSession().getAttribute(Captcha.NAME);</span><br><span class="line">  <span class="keyword">if</span> (captcha.isCorrect(answer)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(result, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h3><p>화면단에서 자등입력 방지문자를 잘 입력했는지 확인하는 코드다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자동입력 방지문자가 일치하는지 확인</span></span><br><span class="line"><span class="keyword">const</span> isCaptCha = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = $(<span class="string">'#captcha'</span>).val();</span><br><span class="line">  <span class="keyword">if</span> (answer == <span class="string">''</span>) &#123;</span><br><span class="line">    alert(<span class="string">'자동입력 방지문자를 입력해주세요.'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;contextPath&#125;</span>/signup/isCorrect`</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    data: &#123; <span class="attr">answer</span>: answer &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      result = response;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isCaptCha()) &#123;</span><br><span class="line">  alert(<span class="string">'자동입력 방지문자가 일치하지 않습니다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#captcha'</span>).focus();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'자동입력 방지문자가 일치합니다.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>새로고침 버튼을 누를 경우 자동입력 방지문자 이미지 안의 숫자가 바뀐다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 자동입력 방지문자 새로고침</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">'#refresh_btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#captchaImg'</span>).attr(<span class="string">'src'</span>, <span class="string">'captchaImg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="화면"><a class="markdownIt-Anchor" href="#화면"></a> 화면</h2><p>성공적으로 자동입력 방지문자 이미지를 가져왔다! 위의 방법처럼 쉽게 구현할 수 있다.</p><p><img src="/images/web/2.png" alt="방지문자" /></p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/29/web-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] DI 수명(lifetime)</title>
      <link>http://hgko1207.github.io/2023/07/21/angular-13/</link>
      <guid>http://hgko1207.github.io/2023/07/21/angular-13/</guid>
      <pubDate>Fri, 21 Jul 2023 12:07:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;transient&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#transient&quot;&gt;&lt;/a&gt; Transient&lt;/h2&gt;
&lt;p&gt;Transient 서비스는 주입될 때마다 생성됩니다. 즉, 컴포넌트(component)가 서
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="transient"><a class="markdownIt-Anchor" href="#transient"></a> Transient</h2><p>Transient 서비스는 주입될 때마다 생성됩니다. 즉, 컴포넌트(component)가 서비스를 주입할 때마다 서비스의 새 인스턴스가 생성됩니다. Transient 서비스의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TransientService &#123;</span><br><span class="line">  <span class="keyword">private</span> data: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트가 <code>TransientService</code> 를 주입하면 매번 서비스의 새 인스턴스가 생성됩니다.</p><h2 id="scoped"><a class="markdownIt-Anchor" href="#scoped"></a> Scoped</h2><p>Scoped 서비스는 Angular 모듈당 한 번 생성됩니다. 이는 동일한 모듈 내의 컴포넌트(component)가 서비스를 주입할 때마다 동일한 서비스 인스턴스가 사용됨을 의미합니다. Scoped 서비스의 예는 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'my-module'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ScopedService &#123;</span><br><span class="line">  <span class="keyword">private</span> data: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동일한 모듈 내의 컴포넌트가 <code>ScopedService</code> 를 주입하면 동일한 서비스 인스턴스가 사용됩니다.</p><h2 id="singleton"><a class="markdownIt-Anchor" href="#singleton"></a> Singleton</h2><p>Singleton 서비스는 한 번 생성되고 동일한 인스턴스가 애플리케이션 전체에서 사용됩니다. 다음은 Singleton 서비스의 예입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SingletonService &#123;</span><br><span class="line">  <span class="keyword">private</span> data: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트가 <code>SingletonService</code> 를 주입하면 애플리케이션 전체에서 동일한 서비스 인스턴스가 사용됩니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/21/angular-13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] OpenLayers로 지도 생성</title>
      <link>http://hgko1207.github.io/2023/07/18/angular-12/</link>
      <guid>http://hgko1207.github.io/2023/07/18/angular-12/</guid>
      <pubDate>Tue, 18 Jul 2023 05:05:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://openlayers.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenLayers&lt;/a&gt; 는 개인 또는 상업 프로젝트에 지도를 추가해야 하는 경우 광범위한 사용 사례에 적합한 오픈 소스 라이브
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://openlayers.org/" target="_blank" rel="noopener">OpenLayers</a> 는 개인 또는 상업 프로젝트에 지도를 추가해야 하는 경우 광범위한 사용 사례에 적합한 오픈 소스 라이브러리입니다. 아래 단계를 따라하면 몇 분 안에 빠르게 실행할 수 있습니다.</p><p>Angular 프로젝트를 한 번도 해본 적이 없는 경우 새 프로젝트를 만드는 방법을 보여 드리겠습니다. 하지만 해당 부분을 건너뛰고 OpenLayers를 기존 프로젝트에 추가 할 수 있습니다.</p><h2 id="새-Angular-프로젝트-만들기"><a class="header-anchor" href="#새-Angular-프로젝트-만들기">¶</a>새 Angular 프로젝트 만들기</h2><p>이 시점에서 첫 번째 Angular 프로젝트를 설정하는 방법을 보여 드리겠습니다. 모든 컴퓨터 운영 체제를 사용할 수 있으며 Angular는 macOS, Linux 및 Windows에서 작동합니다. 이것은 지금 사용하는 설정입니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Angular</span> <span class="string">CLI: 16.1.0</span></span><br><span class="line"><span class="attr">Node</span>: <span class="string">18.15.0</span></span><br><span class="line"><span class="attr">Package</span> <span class="string">Manager: npm 9.5.0</span></span><br><span class="line"><span class="attr">OS</span>: <span class="string">win32 x64</span></span><br></pre></td></tr></table></figure><p>먼저 Angular를 처음 사용하는 경우 로컬 환경을 설정해야 합니다. <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> 와 <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" target="_blank" rel="noopener">npm</a>이 필요합니다.</p><p>설치된 버전을 확인하려면 다음 명령을 실행하십시오.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node</span> <span class="string">-v</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure><p>자, 새 프로젝트를 만들어 봅시다.</p><p>command line interface(터미널, 명령 프롬프트)를 열고 새 Angular 프로젝트에 사용하려는 디렉토리로 이동합니다. Angular CLI를 설치하려면 다음을 실행합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">install -g @angular/cli</span></span><br></pre></td></tr></table></figure><p>이제 작업 공간을 만듭니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ng</span> <span class="string">new openlayers-demo</span></span><br></pre></td></tr></table></figure><p>그리고 앱을 실행할 수 있는지 확인하십시오.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">openlayers-demo</span></span><br><span class="line"><span class="attr">ng</span> <span class="string">serve — open</span></span><br></pre></td></tr></table></figure><p>잘하셨습니다. 이제 OpenLayers 설정을 시작할 준비가 되었습니다.</p><h2 id="Angular-프로젝트에-OpenLayers-추가"><a class="header-anchor" href="#Angular-프로젝트에-OpenLayers-추가">¶</a>Angular 프로젝트에 OpenLayers 추가</h2><p>최신 버전의 OpenLayers를 설치합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">install --save ol</span></span><br></pre></td></tr></table></figure><p>이 시점에서 앱을 제공하려고 하면 앱이 컴파일되지 않는 것을 알 수 있습니다. 이 문제는 Openlayers 6.6 이상 버전에 존재하므로 위의 명령에 @6.5를 추가하여 Openlayers 6.5 버전을 사용하도록 결정할 수도 있습니다.</p><p>그러나 이후 버전에 존재하는 문제를 해결하는 방법을 살펴보겠습니다. 아래와 같이 ol 라이브러리와 관련된 오류가 표시됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: node_modules/ol/<span class="built_in">source</span>/Cluster.d.ts:136:31 - error TS2314: Generic <span class="built_in">type</span> <span class="string">'Feature&lt;Geometry&gt;'</span> requires 1 <span class="built_in">type</span> argument(s).</span><br><span class="line">136     protected features: Array&lt;Feature&gt;;</span><br><span class="line">Error: node_modules/ol/<span class="built_in">source</span>/Cluster.d.ts:152:23 - error TS2314: Generic <span class="built_in">type</span> <span class="string">'VectorSource&lt;Geometry&gt;'</span> requires 1 <span class="built_in">type</span> argument(s).</span><br><span class="line">152     protected <span class="built_in">source</span>: VectorSource;</span><br></pre></td></tr></table></figure><p>오류를 해결하려면 <code>tsconfig.json</code> 파일을 열고 compilerOptions 안에 <code>&quot;skipLibCheck&quot;:true</code> 옵션을 추가합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compileOnSave"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>,</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist/out-tsc"</span>,</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"es2020"</span>,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"importHelpers"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es2020"</span>,</span><br><span class="line">    <span class="attr">"typeRoots"</span>: [<span class="string">"node_modules/@types"</span>],</span><br><span class="line">    <span class="attr">"lib"</span>: [<span class="string">"es2018"</span>, <span class="string">"dom"</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"@core"</span>: [<span class="string">"@core/"</span>],</span><br><span class="line">      <span class="attr">"environments"</span>: [<span class="string">"environments/"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"resolveJsonModule"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"angularCompilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"fullTemplateTypeCheck"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"strictInjectionParameters"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 OpenLayers CSS Style을 프로젝트에 추가하십시오. <code>angular.json</code> 파일을 열고 기존 CSS Style 옆에 <code>&quot;node_modules/ol/ol.css&quot;</code> 를 추가합니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"./node_modules/@angular/cli/lib/config/schema.json"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"newProjectRoot"</span>: <span class="string">"projects"</span>,</span><br><span class="line">  <span class="attr">"projects"</span>: &#123;</span><br><span class="line">    <span class="attr">"openlayers-demo"</span>: &#123;</span><br><span class="line">      <span class="attr">"projectType"</span>: <span class="string">"application"</span>,</span><br><span class="line">      <span class="attr">"schematics"</span>: &#123;</span><br><span class="line">        <span class="attr">"@schematics/angular:component"</span>: &#123;</span><br><span class="line">          <span class="attr">"style"</span>: <span class="string">"scss"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"root"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"sourceRoot"</span>: <span class="string">"src"</span>,</span><br><span class="line">      <span class="attr">"prefix"</span>: <span class="string">"app"</span>,</span><br><span class="line">      <span class="attr">"architect"</span>: &#123;</span><br><span class="line">        <span class="attr">"build"</span>: &#123;</span><br><span class="line">          <span class="attr">"builder"</span>: <span class="string">"@angular-devkit/build-angular:browser"</span>,</span><br><span class="line">          <span class="attr">"options"</span>: &#123;</span><br><span class="line">              ...</span><br><span class="line">              "styles": [</span><br><span class="line">                "src/styles.scss",</span><br><span class="line">                <span class="string">"node_modules/ol/ol.css"</span></span><br><span class="line">              ],</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 지도를 넣을 수 있는 컴포넌트를 만들 차례입니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ng</span> <span class="string">generate component map</span></span><br></pre></td></tr></table></figure><p>컴포넌트의 콘텐츠를 추가합니다.</p><p><code>map.component.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"map"</span> <span class="attr">class</span>=<span class="string">"map"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>map.component.scss</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.map</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map.component.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'ol/ol.css'</span>;</span><br><span class="line"><span class="keyword">import</span> Map <span class="keyword">from</span> <span class="string">'ol/Map'</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'ol/View'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; OSM &#125; <span class="keyword">from</span> <span class="string">'ol/source'</span>;</span><br><span class="line"><span class="keyword">import</span> TileLayer <span class="keyword">from</span> <span class="string">'ol/layer/Tile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-map'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./map.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./map.component.scss'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MapComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="keyword">public</span> map!: Map;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> Map(&#123;</span><br><span class="line">      layers: [</span><br><span class="line">        <span class="keyword">new</span> TileLayer(&#123;</span><br><span class="line">          source: <span class="keyword">new</span> OSM(),</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">      target: <span class="string">'map'</span>,</span><br><span class="line">      view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">        center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        zoom: <span class="number">2</span>,</span><br><span class="line">        maxZoom: <span class="number">18</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSM 은 OpenStreetMaps를 의미하며 여기서는 표준 지도를 사용하지만 OpenLayers는 다양한 지도 Tile Servers, 이미지 등과 함께 작동하며 사용자 고유의 레이어를 만들고 사용자 지정할 수도 있습니다.</p><p>마지막 단계는 지도 컴포넌트의 내용을 포함하도록 루트 html 파일 <code>app.component.html</code>의 내용을 바꾸는 것입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-map</span>&gt;</span><span class="tag">&lt;/<span class="name">app-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제 작동하는 웹사이트를 확인할 시간입니다!</p><p><img src="/images/angular/openlayers.png" alt="openlayers"></p><p>이 글에서는 OpenLayers 라이브러리로 Angular 프로젝트를 설정하여 웹사이트에서 지도를 사용하는 방법을 배웠습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/18/angular-12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C#] FileSystemWatcher 파일 감시 모니터링</title>
      <link>http://hgko1207.github.io/2023/07/18/csharp-1/</link>
      <guid>http://hgko1207.github.io/2023/07/18/csharp-1/</guid>
      <pubDate>Tue, 18 Jul 2023 04:49:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;FileSystemWatcher&lt;/strong&gt; 는 특정 폴더 경로(디렉토리)의 모든 파일이 생성되거나 변경되면 함수 호출을 해줍니다.&lt;/p&gt;
&lt;h2 id=&quot;사용-방법&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>FileSystemWatcher</strong> 는 특정 폴더 경로(디렉토리)의 모든 파일이 생성되거나 변경되면 함수 호출을 해줍니다.</p><h2 id="사용-방법"><a class="markdownIt-Anchor" href="#사용-방법"></a> 사용 방법</h2><p>사용 방법 순서입니다.</p><ol><li><code>FileSystemWatcher</code> 생성자 호출</li><li>감시할 폴더 설정(디렉토리)</li><li>감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등)</li><li>감시할 이벤트 설정 (생성, 변경, 삭제 등)</li><li>FIleSystemWatcher 감시 모니터링 활성화</li><li>감시할 폴더 내부 변경 시 event 호출</li></ol><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test.Utils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileWatcher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWatcher</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> filePath = <span class="string">$"D:\\files\\"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. FileSystemWatcher 생성자 호출</span></span><br><span class="line">            FileSystemWatcher watcher = <span class="keyword">new</span> FileSystemWatcher();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 감시할 폴더 설정(디렉토리)</span></span><br><span class="line">            watcher.Path = filePath;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등)</span></span><br><span class="line">            watcher.NotifyFilter = NotifyFilters.FileName |</span><br><span class="line">                                    NotifyFilters.DirectoryName |</span><br><span class="line">                                    NotifyFilters.Size |</span><br><span class="line">                                    NotifyFilters.LastAccess |</span><br><span class="line">                                    NotifyFilters.CreationTime |</span><br><span class="line">                                    NotifyFilters.LastWrite;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//감시할 파일 유형 선택 예) *.* 모든 파일</span></span><br><span class="line">            watcher.Filter = <span class="string">"*.*"</span>;</span><br><span class="line"></span><br><span class="line">            watcher.IncludeSubdirectories = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 감시할 이벤트 설정 (생성, 변경..)</span></span><br><span class="line">            watcher.Created += <span class="keyword">new</span> FileSystemEventHandler(Changed);</span><br><span class="line">            watcher.Changed += <span class="keyword">new</span> FileSystemEventHandler(Changed);</span><br><span class="line">            watcher.Renamed += <span class="keyword">new</span> RenamedEventHandler(Renamed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. FIleSystemWatcher 감시 모니터링 활성화</span></span><br><span class="line">            watcher.EnableRaisingEvents = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 감시할 폴더 내부 변경 시 event 호출</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Changed</span>(<span class="params"><span class="keyword">object</span> source, FileSystemEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.Write(e.FullPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 이름 변경 시 event 호출</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Renamed</span>(<span class="params"><span class="keyword">object</span> source, RenamedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            MessageBox.Show(e.FullPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileSystemWatcher</code> 은 <code>using System.IO</code> 를 선언해 주어야 합니다.</p><p><code>initWatcher()</code> 함수를 실행시키면 <strong>D:\files\</strong> 해당 경로에 파일이 생기면 바로 <code>Changed()</code> 이벤트가 호출됩니다.</p><p>호출 될 때 담겨지는 파라미터 <code>FileSystemEventArgs e</code> 에서 e.Fullpath 를 통해 생성된 파일의 전체 경로를 가져옵니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예)</span></span><br><span class="line">D:\files\새 텍스트 문서.txt</span><br></pre></td></tr></table></figure><p>이렇게 FileSystemWatcher 를 사용해서 해당 폴더를 실시간으로 감지 모니터링하는 기능을 구현했습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/18/csharp-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] cross-fetch 사용 방법</title>
      <link>http://hgko1207.github.io/2023/07/11/angular-11/</link>
      <guid>http://hgko1207.github.io/2023/07/11/angular-11/</guid>
      <pubDate>Tue, 11 Jul 2023 02:48:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt; 개발 시 api 통신을 하기 위해 Fetch API 사용해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;fetch-api-란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fetch-api-란&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong> 개발 시 api 통신을 하기 위해 Fetch API 사용해 보았다.</p><h2 id="fetch-api-란"><a class="markdownIt-Anchor" href="#fetch-api-란"></a> Fetch API 란</h2><blockquote><p>Fetch API는 HTTP 파이프라인을 구성하는 요청과 응답 등의 요소를 JavaScript에서 접근하고 조작할 수 있는 인터페이스를 제공합니다. Fetch API가 제공하는 전역 fetch() 메서드로 네트워크의 리소스를 쉽게 비동기적으로 취득할 수도 있습니다.</p></blockquote><h2 id="설치"><a class="markdownIt-Anchor" href="#설치"></a> 설치</h2><p>Fetch API를 사용하기 위해 <code>cross-fetch</code> 패키지를 설치한다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 을 사용하여 설치하는 경우</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install --save cross-fetch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn 을 사용하여 설치하는 경우</span></span><br><span class="line"><span class="attr">yarn</span> <span class="string">add cross-fetch</span></span><br></pre></td></tr></table></figure><h2 id="apiservice-구축"><a class="markdownIt-Anchor" href="#apiservice-구축"></a> ApiService 구축</h2><p>api는 전역에서 사용하는 것이기 때문에 service로 만든다.<br /><code>src/app/services</code> 폴더 아래에 <code>api.service.ts</code> 파일을 만들었다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/services/api.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-메서드-설정"><a class="markdownIt-Anchor" href="#http-메서드-설정"></a> http 메서드 설정</h2><p>HTTP 요청 메소드에서 자주 사용하는 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 를 사용하는 함수를 생성한다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'cross-fetch'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span>(url: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fetch(url, &#123;</span><br><span class="line">      method: <span class="string">'GET'</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> post(url: <span class="built_in">string</span>, payload: BodyInit): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fetch(url, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: payload,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> put(url: <span class="built_in">string</span>, payload: BodyInit): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fetch(url, &#123;</span><br><span class="line">      method: <span class="string">'PUT'</span>,</span><br><span class="line">      body: payload,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">delete</span>(url: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fetch(url, &#123;</span><br><span class="line">      method: <span class="string">'DELETE'</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fetch 의 return 타입은 Promise 이기 때문에 <code>then</code> 함수를 사용하거나 <code>async</code> <code>await</code> 를 사용한다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.components.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApiService &#125; <span class="keyword">from</span> <span class="string">'app/services/api.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="keyword">private</span> BASE_URL = <span class="string">'https://webtoon-crawler.nomadcoders.workers.dev'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> api: ApiService</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.api.get(<span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>/today`</span>).then(<span class="function">(<span class="params">response: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.json());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">Fetch API 사용하기</a></li><li><a href="https://github.com/lquixada/cross-fetch" target="_blank" rel="noopener">https://github.com/lquixada/cross-fetch</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/11/angular-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] HttpClient 사용 방법</title>
      <link>http://hgko1207.github.io/2023/07/11/angular-10/</link>
      <guid>http://hgko1207.github.io/2023/07/11/angular-10/</guid>
      <pubDate>Tue, 11 Jul 2023 02:13:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt; 개발 시 프로젝트 초기에 api 통신에 대해 설정 파일을 생성하고 설정해두면 작업하기가 편합니다.&lt;br&gt;
Angluar는 &lt;code&gt;@angular/common&lt;/code&gt; 안에 존재하는 http 패키
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong> 개발 시 프로젝트 초기에 api 통신에 대해 설정 파일을 생성하고 설정해두면 작업하기가 편합니다.<br>Angluar는 <code>@angular/common</code> 안에 존재하는 http 패키지를 사용하면 됩니다.</p><h2 id="import"><a class="header-anchor" href="#import">¶</a>import</h2><p>http 작업을 하기 위해 <code>src/app.module.ts</code> 파일에 HttpClientModule을 import 해야 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  <span class="comment">// BrowserModule 다음에 HttpClientModule를 작성해야 한다</span></span><br><span class="line">  imports: [BrowserModule, HttpClientModule, AppRoutingModule],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="ApiService-구축"><a class="header-anchor" href="#ApiService-구축">¶</a>ApiService 구축</h2><p>api는 전역에서 사용하는 것이기 때문에 service로 만든다.<br><code>src/app/services</code> 폴더 아래에 <code>api.service.ts</code> 파일을 만들었다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/services/api.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Injectable 이기 때문에 다른 module 에서 import 하지 않아도 바로 사용할 수 있다.</p></blockquote><h2 id="baseUrl-설정"><a class="header-anchor" href="#baseUrl-설정">¶</a>baseUrl 설정</h2><p>이제 불러 올 api의 baseUrl을 설정해준다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123; providedIn: <span class="string">'root'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">public</span> BASE_URL = <span class="string">'https://webtoon-crawler.nomadcoders.workers.dev'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보통 <code>BASE_URL</code>은 각 프로젝트의 환경 별로 다르게 설정 가능하다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/environments/environments.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> environment = &#123;</span><br><span class="line">  production: <span class="literal">false</span>,</span><br><span class="line">  baseUrl: <span class="string">'https://test.api.example.com'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/environments/environment.prod.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> environment = &#123;</span><br><span class="line">  production: <span class="literal">true</span>,</span><br><span class="line">  baseUrl: <span class="string">'https://api.example.com'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위의 처럼 설정한 후 <code>src/api/api.service.ts</code>에 다음과 같이 불러와 사용하면 된다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; environment &#125; <span class="keyword">from</span> <span class="string">'environments/environment'</span>;</span><br><span class="line"><span class="comment">// ...생략</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">public</span> BASE_URL = environment.baseUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-메서드-설정"><a class="header-anchor" href="#http-메서드-설정">¶</a>http 메서드 설정</h2><p>HTTP 요청 메소드에서 자주 사용하는 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 를 사용하는 함수를 생성한다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/api/api.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123; providedIn: <span class="string">'root'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="keyword">public</span> BASE_URL = <span class="string">'https://webtoon-crawler.nomadcoders.workers.dev'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>&lt;T&gt;(endPoint: <span class="built_in">string</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.BASE_URL&#125;</span><span class="subst">$&#123;endPoint&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  post&lt;T&gt;(endPoint: <span class="built_in">string</span>, body: <span class="built_in">any</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.BASE_URL&#125;</span><span class="subst">$&#123;endPoint&#125;</span>`</span>, body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  put&lt;T&gt;(endPoint: <span class="built_in">string</span>, body: <span class="built_in">any</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.put&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.BASE_URL&#125;</span><span class="subst">$&#123;endPoint&#125;</span>`</span>, body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>&lt;T&gt;(endPoint: <span class="built_in">string</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.delete&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.BASE_URL&#125;</span><span class="subst">$&#123;endPoint&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular의 http의 return 타입은 모두 Observable 이기 때문에, 할당할 변수의 타입도 Observable로 지정해야 한다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.components.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApiService &#125; <span class="keyword">from</span> <span class="string">'app/services/api.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WebToonInfo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  thumb: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  webToons$: Observable&lt;WebToonInfo[]&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> api: ApiService</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.webToons$ = <span class="keyword">this</span>.api.get(<span class="string">'/today'</span>);</span><br><span class="line">    <span class="keyword">this</span>.webToons$.subscribe(<span class="built_in">console</span>.log); <span class="comment">// console 확인</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-처리"><a class="header-anchor" href="#Error-처리">¶</a>Error 처리</h2><p>만약 에러를 처리하고 싶다면, 각 api 요청마다 설정할 수도 있지만 <code>api.service.ts</code> 에서 설정 해줘도 된다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/services/api.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpErrorResponse &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable, throwError &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123; providedIn: <span class="string">'root'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApiService &#123;</span><br><span class="line">  <span class="comment">// ... 생략</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> handleError(error: HttpErrorResponse) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.status === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error.error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`Backend error <span class="subst">$&#123;error.status&#125;</span>, <span class="subst">$&#123;error.error&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throwError(<span class="string">'예기치 못한 에러가 발생했습니다. 다시 시도해주세요.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>&lt;T&gt;(endPoint: <span class="built_in">string</span>): Observable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;T&gt;(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.BASE_URL&#125;</span><span class="subst">$&#123;endPoint&#125;</span>`</span>).pipe(catchError(<span class="keyword">this</span>.handleError));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="header-anchor" href="#참고">¶</a>참고</h2><ul><li><a href="https://angular.io/guide/understanding-communicating-with-http#requesting-data-from-a-server" target="_blank" rel="noopener">Understanding communicating with backend services using HTTP</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/07/11/angular-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flutter 업그레이드</title>
      <link>http://hgko1207.github.io/2023/05/30/flutter-2/</link>
      <guid>http://hgko1207.github.io/2023/05/30/flutter-2/</guid>
      <pubDate>Tue, 30 May 2023 05:14:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;flutter-버전-오류&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#flutter-버전-오류&quot;&gt;&lt;/a&gt; Flutter 버전 오류&lt;/h2&gt;
&lt;p&gt;Flutter 프로젝트를 진행하면서 http 패키지를 설치하려고 &lt;co
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="flutter-버전-오류"><a class="markdownIt-Anchor" href="#flutter-버전-오류"></a> Flutter 버전 오류</h2><p>Flutter 프로젝트를 진행하면서 http 패키지를 설치하려고 <code>flutter pub get</code> 명령어를 실행했을때 다음과 같은 오류가 발생했습니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[flutter\example] flutter pub get</span><br><span class="line">Resolving dependencies...</span><br><span class="line">The current Dart SDK version is 3.0.0-431.0.dev</span><br><span class="line"></span><br><span class="line">Because example depends on http &gt;=1.0.0 which requires SDK version ^3.0.0, version solving failed.</span><br><span class="line">exit code 1</span><br></pre></td></tr></table></figure><p>http 패키지의 <code>1.0.0</code> 버전을 설치하는데 현재 Dart SDK 버전이 <code>&gt;=3.0.0 &lt;4.0.0</code> 범위에 포함되지 않아 발생한 오류였습니다.</p><p>현재 Dart SDK 버전 <code>3.0.0-431.0.dev</code> 이 <code>&gt;=3.0.0 &lt;4.0.0</code> 범위에 포함되는 것 같지만 실제로는 조건에 충족하지 않습니다.</p><h2 id="오류-해결"><a class="markdownIt-Anchor" href="#오류-해결"></a> 오류 해결</h2><p>Dart SDK 버전을 올려주면 해결됩니다. 버전을 올리기 위해 Dart 를 새로 설치를 해도 되지만 번거롭습니다.</p><p>flutter 명령어로 Flutter 와 Dart 의 버전을 올릴 수 있기 때문에 flutter CLI 명령어로 버전을 변경합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter</span> <span class="string">upgrade</span></span><br></pre></td></tr></table></figure><p>위의 명령어를 실행하면 다음와 같이 업그레이드를 진행합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Upgrading</span> <span class="string">engine...</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm-profile/windows-x64 tools...               387ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm-release/windows-x64 tools...               101ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm64-profile/windows-x64 tools...             132ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm64-release/windows-x64 tools...              97ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x64-profile/windows-x64 tools...               101ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x64-release/windows-x64 tools...               103ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x86 tools...                                   639ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x64 tools...                                   628ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm tools...                                   521ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm-profile tools...                           216ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm-release tools...                           142ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm64 tools...                                 526ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm64-profile tools...                         261ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-arm64-release tools...                         201ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x64-profile tools...                           258ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x64-release tools...                           214ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">android-x86-jit-release tools...                       337ms</span></span><br><span class="line"><span class="attr">Downloading</span> <span class="string">Web SDK...                                           1,662ms</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Flutter</span> <span class="string">3.11.0-15.0.pre.48 • channel master • https://github.com/flutter/flutter.git</span></span><br><span class="line"><span class="attr">Framework</span> <span class="string">• revision c5f45d7121 (54 minutes ago) • 2023-05-30 00:15:34 -0400</span></span><br><span class="line"><span class="attr">Engine</span> <span class="string">• revision b5f60d2b33</span></span><br><span class="line"><span class="attr">Tools</span> <span class="string">• Dart 3.1.0 (build 3.1.0-155.0.dev) • DevTools 2.23.1</span></span><br></pre></td></tr></table></figure><p>flutter 업그레이드가 끝나고 다시 <code>flutter pub get</code> 명령어를 실행하면 정상적으로 dependency 를 가지고 오는 것을 확인 할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[flutter\example] flutter pub get</span><br><span class="line">Resolving dependencies...</span><br><span class="line">&gt; collection 1.17.2 (was 1.17.1)</span><br><span class="line">+ http 1.0.0</span><br><span class="line">+ http_parser 4.0.2</span><br><span class="line">  matcher 0.12.15 (0.12.16 available)</span><br><span class="line">&gt; material_color_utilities 0.5.0 (was 0.3.0)</span><br><span class="line">&gt; test_api 0.5.2 (was 0.5.1) (0.6.0 available)</span><br><span class="line">+ typed_data 1.3.2</span><br><span class="line">Changed 6 dependencies!</span><br><span class="line"><span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/30/flutter-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] End-to-end 테스트</title>
      <link>http://hgko1207.github.io/2023/05/15/nest-7/</link>
      <guid>http://hgko1207.github.io/2023/05/15/nest-7/</guid>
      <pubDate>Mon, 15 May 2023 07:11:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;end-to-end-테스트&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#end-to-end-테스트&quot;&gt;&lt;/a&gt; End-to-end 테스트&lt;/h2&gt;
&lt;p&gt;개별 모듈과 클래스에 중점을 두는 &lt;strong&gt;Unit 테스트&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="end-to-end-테스트"><a class="markdownIt-Anchor" href="#end-to-end-테스트"></a> End-to-end 테스트</h2><p>개별 모듈과 클래스에 중점을 두는 <strong>Unit 테스트</strong>와 달리 <strong>end-to-end(e2e) 테스트</strong>는 보다 종합적인 수준에서 클래스와 모듈의 상호 작용을 다룹니다.</p><p>애플리케이션이 성장함에 따라 각 API endpoint 의 E2E 동작을 수동으로 테스트하기가 어려워집니다. 자동화된 E2E 테스트는 시스템의 전반적인 동작이 정확하고 프로젝트 요구 사항을 충족하는지 확인하는 데 도움이 됩니다.</p><p><strong>Nest</strong> 를 사용하면 SuperTest 라이브러리를 사용하여 HTTP request 를 쉽게 시뮬레이션할 수 있습니다. SuperTest 는 superagent 를 기반으로 하는 HTTP 검증 라이브러리입니다.</p><h3 id="request"><a class="markdownIt-Anchor" href="#request"></a> request()</h3><p>SuperTest 의 <code>request(app.getHttpServer())</code> 함수를 사용하여 HTTP 테스트를 시뮬레이션합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localhost:3000/ 으로 라우팅될 때 Hello World!가 출력되는지 확인</span></span><br><span class="line">it(<span class="string">'/ (GET)'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">'/'</span>).expect(<span class="number">200</span>).expect(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이러한 HTTP request 가 실행 중인 Nest 앱으로 라우팅되기를 원하므로 <code>request()</code> 함수에 Nest 의 기반이 되는 HTTP 리스너에 대한 참조를 전달합니다.</p><h2 id="사용-예시"><a class="markdownIt-Anchor" href="#사용-예시"></a> 사용 예시</h2><p>기본적인 <strong>CRUD</strong> (Create/Read/Update/Delete) 에 대한 테스트를 하기 위해 다음과 같이 작성할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'/users'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'GET'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer()).get(<span class="string">'/users'</span>).expect(<span class="number">200</span>).expect([]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'POST'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer())</span><br><span class="line">      .post(<span class="string">'/users'</span>)</span><br><span class="line">      .send(&#123;</span><br><span class="line">        name: <span class="string">'hgko'</span>,</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">        hobbies: [<span class="string">'soccer'</span>],</span><br><span class="line">      &#125;)</span><br><span class="line">      .expect(<span class="number">201</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'PATCH'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer())</span><br><span class="line">      .patch(<span class="string">'/users/1'</span>)</span><br><span class="line">      .send(&#123;</span><br><span class="line">        age: <span class="number">35</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .expect(<span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'DELETE'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(app.getHttpServer()).delete(<span class="string">'/users/1'</span>).expect(<span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/fundamentals/testing#end-to-end-testing" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/testing#end-to-end-testing</a></li><li><a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">https://github.com/visionmedia/supertest</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/15/nest-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] Jest 사용 방법</title>
      <link>http://hgko1207.github.io/2023/05/15/nest-6/</link>
      <guid>http://hgko1207.github.io/2023/05/15/nest-6/</guid>
      <pubDate>Mon, 15 May 2023 01:55:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;NestJS&lt;/strong&gt; 에서 &lt;strong&gt;Jest&lt;/strong&gt; 를 사용하는 방법에 대해 간략하게 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;jest&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jest&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>NestJS</strong> 에서 <strong>Jest</strong> 를 사용하는 방법에 대해 간략하게 알아보겠습니다.</p><h2 id="jest"><a class="markdownIt-Anchor" href="#jest"></a> Jest</h2><p><strong>Jest</strong> 는 단순함에 초점을 맞춘 유쾌한 JavaScript 테스팅 프레임워크입니다.<br />Babel, TypeScript, Node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동합니다.</p><h2 id="시작하기"><a class="markdownIt-Anchor" href="#시작하기"></a> 시작하기</h2><h3 id="describe"><a class="markdownIt-Anchor" href="#describe"></a> describe()</h3><p><code>describe()</code> 함수를 사용하면 작은 단위의 테스트 코드를 그룹화할 수 있습니다. 작성하는 테스트 코드가 특정 component 에 속하는 테스트 코드라면 다음과 같이 <code>describe()</code> 함수를 사용해서 해당 테스트 코드들을 그룹화하는 것이 좋습니다. 테스트 결과를 확인할 때 가시적으로 보기 편하게 테스트 케이스들을 확인할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'StudentService'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">'getAll'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'getOne'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'create'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="it-test"><a class="markdownIt-Anchor" href="#it-test"></a> it(), test()</h3><p>테스트 케이스를 생성합니다. <code>it()</code> 함수 대신 <code>test()</code>도 사용 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should be 4'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'should be 4'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect"><a class="markdownIt-Anchor" href="#expect"></a> expect()</h3><p>값을 테스트할 때마다 <code>expect()</code> 함수가 사용됩니다. 테스트할 때 <code>expect()</code> 함수를 여러개 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bestJuiceFlavor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'apple'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the best flavor is apple'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  expect(bestJuiceFlavor()).toBe(<span class="string">'apple'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="using-matchers"><a class="markdownIt-Anchor" href="#using-matchers"></a> Using Matchers</h2><h3 id="common-matchers"><a class="markdownIt-Anchor" href="#common-matchers"></a> Common Matchers</h3><p><code>toBe()</code> 함수는 <code>Object.is</code> 를 사용하여 정확한 동등성을 테스트합니다. 객체의 값을 확인하려면 대신 <code>toEqual()</code> 함수를 사용하세요.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'two plus two is four'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'object assignment'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123; one: <span class="number">1</span> &#125;;</span><br><span class="line">  data[<span class="string">'two'</span>] = <span class="number">2</span>;</span><br><span class="line">  expect(data).toEqual(&#123; one: <span class="number">1</span>, two: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="strings"><a class="markdownIt-Anchor" href="#strings"></a> Strings</h3><p><code>toMatch()</code> 함수를 사용하여 정규 표현식에 대해 문자열을 확인할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'but there is a "ko" in hgko'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="string">'hgko'</span>).toMatch(<span class="regexp">/ko/</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="arrays-and-iterables"><a class="markdownIt-Anchor" href="#arrays-and-iterables"></a> Arrays and iterables</h3><p><code>toContain()</code> 함수를 사용하여 배열 또는 iterable 에 특정 항목이 포함되어 있는지 확인할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shoppingList = [<span class="string">'egg'</span>, <span class="string">'coffee'</span>, <span class="string">'tissue'</span>, <span class="string">'milk'</span>];</span><br><span class="line"></span><br><span class="line">it(<span class="string">'the shopping list has milk on it'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// array</span></span><br><span class="line">  expect(shoppingList).toContain(<span class="string">'milk'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterable</span></span><br><span class="line">  expect(<span class="keyword">new</span> Set(shoppingList)).toContain(<span class="string">'milk'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="exceptions"><a class="markdownIt-Anchor" href="#exceptions"></a> Exceptions</h3><p>특정 함수가 호출될 때 오류가 발생하는지 테스트하려면 <code>toThrow()</code> 함수를 사용합니다.<br />예외를 발생시키는 함수는 래핑 함수 내에서 호출해야 합니다. 그렇지 않으면 <code>toThrow</code> assertion 이 실패합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'getOne'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'shoule find a student'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> student = service.getOne(<span class="number">1</span>);</span><br><span class="line">    expect(student).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should throw 404 error'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      service.getOne(<span class="number">999</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e).toBeInstanceOf(NotFoundException);</span><br><span class="line">      expect(e.message).toEqual(<span class="string">`Student with ID: 999 not found.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>toBeInstanceOf(Class)</code> 함수를 사용하여 객체가 클래스의 인스턴스인지 확인 할 수 있습니다.</p><h2 id="테스트-전후-처리"><a class="markdownIt-Anchor" href="#테스트-전후-처리"></a> 테스트 전/후 처리</h2><h3 id="beforeeach"><a class="markdownIt-Anchor" href="#beforeeach"></a> beforeEach</h3><p>각각의 테스트가 실행되기 전에 매번 함수를 실행합니다.<br />각각의 테스트 전에 각 테스트에서 사용할 전역 상태를 재설정하려는 경우에 유용합니다.<br />함수가 promise 을 반환하거나 generator 인 경우 Jest 는 테스트를 실행하기 전에 해당 promise 가 해결될 때까지 기다립니다.<br />밀리초로 대기할 시간을 지정할 수 있습니다. (기본 시간 5초)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users: User[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// test() 함수들이 실행될때마다 beforeEach()에서 설정한, users 데이터를 사용하게 된다.</span></span><br><span class="line">beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  users.push(&#123; id: <span class="number">1</span>, name: <span class="string">'hgko'</span> &#125;, &#123; id: <span class="number">2</span>, name: <span class="string">'eden'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'find all users'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 테스트하면서 users의 데이터들을 가져와 사용한다.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'create a user'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 테스트하면서 users의 데이터들을 가져와 사용한다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="aftereach"><a class="markdownIt-Anchor" href="#aftereach"></a> afterEach</h3><p>각각의 테스트가 완료된 후 함수를 실행합니다.</p><h3 id="beforeall"><a class="markdownIt-Anchor" href="#beforeall"></a> beforeAll</h3><p>모든 테스트가 실행되기 전에 딱 한 번 함수를 실행합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> connection;</span><br><span class="line"></span><br><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 테스트 실행하기전에 데이터베이스에 접속할 연결(Connection) 개체를 만든다.</span></span><br><span class="line">  conection = openConnection(&#123; host: <span class="string">'...'</span>, port: <span class="string">'...'</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="afterall"><a class="markdownIt-Anchor" href="#afterall"></a> afterAll</h3><p>모든 테스트가 완료된 후 함수를 실행합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 데이터베이스 Connection을 종료한다.</span></span><br><span class="line">  conection.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="실행"><a class="markdownIt-Anchor" href="#실행"></a> 실행</h2><p>NestJS 개발환경에서 <code>package.json</code> 파일에 Testing 하는 명령어가 정의되어 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    ...</span><br><span class="line">    "test": "jest",</span><br><span class="line">    "test:watch": "jest --watch",</span><br><span class="line">    "test:cov": "jest --coverage",</span><br><span class="line">    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",</span><br><span class="line">    "test:e2e": "jest --config ./test/jest-e2e.json"</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 테스트 하려는 방식에 따라 명령어를 실행해서 테스트합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Unit 테스트</span></span><br><span class="line">npm run test</span><br><span class="line">npm run test:watch</span><br><span class="line">npm run test:cov</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> E2E 테스트</span></span><br><span class="line">npm rum test:e2e</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://jestjs.io/" target="_blank" rel="noopener">https://jestjs.io/</a></li><li><a href="https://jestjs.io/docs/getting-started" target="_blank" rel="noopener">https://jestjs.io/docs/getting-started</a></li><li><a href="https://jestjs.io/docs/expect" target="_blank" rel="noopener">https://jestjs.io/docs/expect</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/15/nest-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] Mapped types의 Partial 사용 방법</title>
      <link>http://hgko1207.github.io/2023/05/13/nest-5/</link>
      <guid>http://hgko1207.github.io/2023/05/13/nest-5/</guid>
      <pubDate>Sat, 13 May 2023 12:46:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;mapped-types&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mapped-types&quot;&gt;&lt;/a&gt; Mapped types&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CRUD&lt;/strong&gt; (Create/Read/Update/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="mapped-types"><a class="markdownIt-Anchor" href="#mapped-types"></a> Mapped types</h2><p><strong>CRUD</strong> (Create/Read/Update/Delete) 와 같은 기능을 구축할 때 기본 엔터티 클래스를 기능에 맞게 변형하는 것이 필요한 경우가 많습니다. Nest 는 이 작업을 보다 편리하게 만들기 위해 클래스 변환을 수행하는 여러 유틸리티 기능을 제공합니다.</p><h2 id="partial"><a class="markdownIt-Anchor" href="#partial"></a> Partial</h2><p>input validation types(DTO라고도 함)을 빌드할 때 동일한 클래스에 대한 <strong>create</strong> 및 <strong>update</strong> 클래스로 변형하는 것이 필요한 경우가 많습니다. 예를 들어, <strong>create</strong> 에는 모든 필드가 필요할 수 있지만 <strong>update</strong> 는 모든 필드를 선택 사항으로 만들 수 있습니다. Nest 는 이 작업을 더 쉽게 만들고 보일러플레이트(Boilerplate) 코드를 최소화하기 위해 <code>PartialType()</code> 유틸리티 함수를 제공합니다. <code>PartialType()</code> 함수는 입력 클래스의 모든 속성이 선택 사항으로 설정된 클래스를 반환합니다.</p><h2 id="설치"><a class="markdownIt-Anchor" href="#설치"></a> 설치</h2><p>Mapped types 설치를 통해 PartialType 을 가져올 수 있습니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">i @nestjs/mapped-types</span></span><br></pre></td></tr></table></figure><h2 id="사용-예시"><a class="markdownIt-Anchor" href="#사용-예시"></a> 사용 예시</h2><p>이전 글 <a href="https://hgko1207.github.io/2023/05/11/nest-4/">[NestJS] ValidationPipe 사용 방법</a> 에서 생성한 사용자 등록 DTO 클래스를 이용합니다. 사용자 등록 DTO 클래스의 필드들은 모두 필수 항목입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create-user.dto.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; IsString, IsNumber &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreateUserDto &#123;</span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IsNumber</span>()</span><br><span class="line">  readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IsString</span>(&#123; each: <span class="literal">true</span> &#125;)</span><br><span class="line">  readonly hobbies: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 등록 DTO 클래스와 동일한 필드를 가지지만 각 필드가 선택 사항인 사용자 수정 DTO 클래스를 생성하려면 <code>PartialType()</code> 함수를 상속 받고 사용자 등록 DTO 클래스인 <code>CreateUserDto</code> 를 인수로 전달합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update-user.dto.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; PartialType &#125; <span class="keyword">from</span> <span class="string">'@nestjs/mapped-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./create-user.dto'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UpdateUserDto <span class="keyword">extends</span> PartialType(CreateUserDto) &#123;&#125;</span><br></pre></td></tr></table></figure><p>사용자 수정 요청을 받기 위해 컨트롤러 클래스를 생성합니다. <code>update</code> 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Body, Controller, Patch &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/update-user.dto'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'users'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 사용자 수정</span></span><br><span class="line"><span class="comment">   * @param userData</span></span><br><span class="line"><span class="comment">   * @returns</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Patch</span>()</span><br><span class="line">  update(<span class="meta">@Body</span>() userData: UpdateUserDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'사용자 수정 성공'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 수정 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다.<br /><a href="http://localhost:3000/student/" target="_blank" rel="noopener">http://localhost:3000/student/</a> 주소를 PATCH 방식으로 요청합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 서버에서 응답</span></span><br><span class="line">사용자 수정 성공</span><br></pre></td></tr></table></figure><p>사용자 등록과 달리 모든 필드가 선택 사항으로 설정되어 있어 요청할 때 속성들을 입력하지 않아도 잘 동작하는 것을 확인할 수 있습니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/openapi/mapped-types#partial" target="_blank" rel="noopener">https://docs.nestjs.com/openapi/mapped-types#partial</a></li><li><a href="https://www.npmjs.com/package/class-validator" target="_blank" rel="noopener">https://www.npmjs.com/package/class-validator</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/13/nest-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] ValidationPipe 사용 방법</title>
      <link>http://hgko1207.github.io/2023/05/11/nest-4/</link>
      <guid>http://hgko1207.github.io/2023/05/11/nest-4/</guid>
      <pubDate>Thu, 11 May 2023 03:10:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;validation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#validation&quot;&gt;&lt;/a&gt; Validation&lt;/h2&gt;
&lt;p&gt;웹 애플리케이션으로 전송되는 데이터의 검증을 도와줍니다.&lt;br /&gt;
들어오는 요청을 자
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="validation"><a class="markdownIt-Anchor" href="#validation"></a> Validation</h2><p>웹 애플리케이션으로 전송되는 데이터의 검증을 도와줍니다.<br />들어오는 요청을 자동으로 검증하기 위해 Nest 는 즉시 사용할 수 있는 여러 파이프를 제공합니다.</p><h2 id="validationpipe"><a class="markdownIt-Anchor" href="#validationpipe"></a> ValidationPipe</h2><p><strong>ValidationPipe</strong>는 강력한 클래스 유효성 검사기 패키지와 선언적 유효성 검사 데코레이터를 사용합니다. <strong>ValidationPipe</strong>는 들어오는 모든 클라이언트 페이로드에 대해 유효성 검사 규칙을 적용하는 편리한 접근 방식을 제공합니다.</p><p>ValidationPipe 사용을 위한 <code>class-validator</code>, <code>class-transformer</code> 패키지를 설치합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">i --save class-validator class-transformer</span></span><br></pre></td></tr></table></figure><h3 id="사용-예시"><a class="markdownIt-Anchor" href="#사용-예시"></a> 사용 예시</h3><p>ValidationPipe 를 사용하기 위해 <code>main.ts</code> 파일에 다음과 같이 추가합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ValidationPipe &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  <span class="comment">// ValidationPipe 추가</span></span><br><span class="line">  app.useGlobalPipes(<span class="keyword">new</span> ValidationPipe());</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>유효성 검사를 위해 사용자 등록을 예시로 작성했습니다.</p><p>먼저 사용자 등록을 위한 DTO(Data Transfer Object) 클래스를 생성합니다. 그리고 validation decorator(IsString, IsNumber 등)를 유효성 검사하기 위한 필드에 추가합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create-user.dto.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; IsString, IsNumber &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreateUserDto &#123;</span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IsNumber</span>()</span><br><span class="line">  readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IsString</span>(&#123; each: <span class="literal">true</span> &#125;)</span><br><span class="line">  readonly hobbies: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 등록 요청을 받기 위해 컨트롤러 클래스를 생성합니다. <code>create</code> 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Body, Controller, Post &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-user.dto'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'users'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 사용자 등록</span></span><br><span class="line"><span class="comment">   * @param userData</span></span><br><span class="line"><span class="comment">   * @returns</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Post</span>()</span><br><span class="line">  create(<span class="meta">@Body</span>() userData: CreateUserDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'사용자 등록 성공!!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 등록 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다.<br /><a href="http://localhost:3000/student/" target="_blank" rel="noopener">http://localhost:3000/student/</a> 주소를 POST 방식으로 요청합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 서버에서 응답</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"statusCode"</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="attr">"message"</span>: [</span><br><span class="line">    <span class="string">"name must be a string"</span>,</span><br><span class="line">    <span class="string">"age must be a number conforming to the specified constraints"</span>,</span><br><span class="line">    <span class="string">"each value in hobbies must be a string"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"Bad Request"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요청 하는 데이터가 “name”, “age”, “hobbies” 필드가 존재하지 않으므로 예외를 응답합니다. 즉, ValidationPipe 를 사용하면 모든 엔드포인트가 잘못된 데이터를 수신하지 못하도록 보호됩니다. 간단한 설정만으로 유효성 체크를 할 수 있습니다.</p><h2 id="옵션"><a class="markdownIt-Anchor" href="#옵션"></a> 옵션</h2><h3 id="whitelist"><a class="markdownIt-Anchor" href="#whitelist"></a> whitelist</h3><p><code>whitelist: true</code>로 설정하면 유효성 검사기는 class-validator의 유효성 검사 데코레이터를 적어도 하나라도 사용하지 않은 모든 속성 객체를 제거합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.useGlobalPipes(</span><br><span class="line">  <span class="keyword">new</span> ValidationPipe(&#123;</span><br><span class="line">    whitelist: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="forbidnonwhitelisted"><a class="markdownIt-Anchor" href="#forbidnonwhitelisted"></a> forbidNonWhitelisted</h3><p><code>forbidNonWhitelisted: true</code>로 설정하면 화이트리스트에 없는 속성을 제거하는 대신 유효성 검사기가 예외를 발생합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.useGlobalPipes(</span><br><span class="line">  <span class="keyword">new</span> ValidationPipe(&#123;</span><br><span class="line">    whitelist: <span class="literal">true</span>,</span><br><span class="line">    forbidNonWhitelisted: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>whitelist 와 forbidNonWhitelisted 옵션을 true 로 설정하면 “height” 이라는 속성은 화이트리스트에 존재하지 않으므로 HttpException 을 응답합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hgko"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">35</span>,</span><br><span class="line">  <span class="attr">"hobbies"</span>: [<span class="string">"soccer"</span>],</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 서버에서 응답</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"statusCode"</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="attr">"message"</span>: [<span class="string">"property height should not exist"</span>],</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"Bad Request"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform-자동-형변환"><a class="markdownIt-Anchor" href="#transform-자동-형변환"></a> transform (자동 형변환)</h3><p>네트워크를 통해 들어오는 payload 는 일반 JavaScript 객체입니다. ValidationPipe 는 payload 를 DTO 클래스에 따라 유형이 지정된 객체로 자동 변환할 수 있습니다. 자동 변환을 활성화하려면 transform 을 true 로 설정하십시오. 이 동작을 전역적으로 활성화하려면 전역 파이프에서 옵션을 설정합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.useGlobalPipes(</span><br><span class="line">  <span class="keyword">new</span> ValidationPipe(&#123;</span><br><span class="line">    transform: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/techniques/validation" target="_blank" rel="noopener">https://docs.nestjs.com/techniques/validation</a></li><li><a href="https://www.npmjs.com/package/class-validator" target="_blank" rel="noopener">https://www.npmjs.com/package/class-validator</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/11/nest-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] Param decorators</title>
      <link>http://hgko1207.github.io/2023/05/10/nest-3/</link>
      <guid>http://hgko1207.github.io/2023/05/10/nest-3/</guid>
      <pubDate>Wed, 10 May 2023 03:05:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;param-decorators&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#param-decorators&quot;&gt;&lt;/a&gt; Param decorators&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Nest&lt;/strong&gt; 는 HTTP 라
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="param-decorators"><a class="markdownIt-Anchor" href="#param-decorators"></a> Param decorators</h2><p><strong>Nest</strong> 는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 매개변수 데코레이터 세트를 제공합니다.<br />다음은 제공된 데코레이터와 이들이 나타내는 일반 Express(또는 Fastify) 객체의 목록과 사용 예시입니다.</p><h3 id="param"><a class="markdownIt-Anchor" href="#param"></a> @Param</h3><p>Param 은 Path Variable 을 받아올 때 사용합니다. (예, /users/123)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NestJS</span></span><br><span class="line"><span class="meta">@Param</span>(param?: <span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpressJS</span></span><br><span class="line">req.params / req.params[param]</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Param &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'users'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserController &#123;</span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'/:id'</span>)</span><br><span class="line">  getOne(<span class="meta">@Param</span>(<span class="string">'id'</span>) userId: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This will return one user with the id: <span class="subst">$&#123;userId&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="body"><a class="markdownIt-Anchor" href="#body"></a> @Body</h3><p>Body 는 JSON 형식으로 받아올 때 사용합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NestJS</span></span><br><span class="line"><span class="meta">@Body</span>(param?: <span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpressJS</span></span><br><span class="line">req.body / req.body[param]</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Body, Controller, Param, Patch, Post &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'users'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserController &#123;</span><br><span class="line">  <span class="meta">@Post</span>()</span><br><span class="line">  create(<span class="meta">@Body</span>() userData) &#123;</span><br><span class="line">    <span class="keyword">return</span> userData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Patch</span>(<span class="string">'/:id'</span>)</span><br><span class="line">  update(<span class="meta">@Param</span>(<span class="string">'id'</span>) userId: <span class="built_in">string</span>, <span class="meta">@Body</span>() updateData) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      updateData: userId,</span><br><span class="line">      ...updateData,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query"><a class="markdownIt-Anchor" href="#query"></a> @Query</h3><p>Query 는 Query Parameter 를 받아올 때 사용합니다. (예, /users?id=123)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NestJS</span></span><br><span class="line"><span class="meta">@Query</span>(param?: <span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpressJS</span></span><br><span class="line">req.query / req.query[param]</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Query &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'users'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserController &#123;</span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'search'</span>)</span><br><span class="line">  search(<span class="meta">@Query</span>(<span class="string">'id'</span>) userId: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`We are searching for a user made after: <span class="subst">$&#123;userId&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/custom-decorators#param-decorators" target="_blank" rel="noopener">https://docs.nestjs.com/custom-decorators#param-decorators</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/10/nest-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] Controller, Provider, Module 이란?</title>
      <link>http://hgko1207.github.io/2023/05/08/nest-2/</link>
      <guid>http://hgko1207.github.io/2023/05/08/nest-2/</guid>
      <pubDate>Mon, 08 May 2023 02:40:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;NestJS&lt;/strong&gt; 에서 사용하는 &lt;strong&gt;Controller, Provider, Module&lt;/strong&gt; 에 대한 간략한 내용을 정리하였습니다.&lt;/p&gt;
&lt;h2 id=&quot;controllers&quot;&gt;&lt;a class=&quot;ma
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>NestJS</strong> 에서 사용하는 <strong>Controller, Provider, Module</strong> 에 대한 간략한 내용을 정리하였습니다.</p><h2 id="controllers"><a class="markdownIt-Anchor" href="#controllers"></a> Controllers</h2><p>컨트롤러는 들어오는 요청을 처리하고 클라이언트에 응답을 반환하는 역할을 합니다. express 의 라우터 같은 역할을 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppService &#125; <span class="keyword">from</span> <span class="string">'./app.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly appService: AppService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  getHello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.appService.getHello();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'/hello'</span>)</span><br><span class="line">  sayHello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello everyone'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Controller()</code>: express 의 <code>app.use('/', router)</code> 에서 '/'와 같은 역할을 합니다. <code>@Controller('req')</code> 이렇게 인자로 string을 넘겨주면 express 에서 <code>app.use('/req', router)</code> 처럼 코드를 작성한 것과 같습니다.</li><li><code>@Get()</code>: Route 핸들러(메소드) 데코레이터입니다. HTTP GET 요청을 지정된 경로로 라우팅합니다. <code>@Get('hello')</code> 이렇게 인자로 string을 넘겨주면 express 에서 <code>router.get('/hello', sayHello)</code> 처럼 코드를 작성한 것과 같습니다.</li></ul><h2 id="providers"><a class="markdownIt-Anchor" href="#providers"></a> Providers</h2><p>Provider 는 Nest 의 기본 개념입니다. 대부분의 기본 Nest Class 인 services, repositories, factories, helpers 등은 provider 로 취급될 수 있습니다. provider 는 단순히 <code>@Injectable()</code> 데코레이터가 달린 클래스입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppService &#123;</span><br><span class="line">  getHello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider 의 주요 아이디어는 의존성을 <strong>주입</strong> 할 수 있다는 것입니다. 즉, 개체가 서로 다양한 관계를 만들 수 있으며 개체 인스턴스를 &quot;연결&quot;하는 기능은 대부분 Nest 런타임 시스템에 위임 할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppService &#125; <span class="keyword">from</span> <span class="string">'./app.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly appService: AppService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  getHello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.appService.getHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 <code>AppController</code> 생성자에 변수의 타입을 <code>AppService</code> 로 지정해줌으로써 Nest Injector 가 appService 변수를 <code>AppService</code>의 인스턴스로 만들어줍니다(인스턴스화한다).</p><h2 id="modules"><a class="markdownIt-Anchor" href="#modules"></a> Modules</h2><p>NestJS 에는 모듈이 있습니다. <code>@Module()</code> 데코레이터로 모듈을 만들 수 있습니다.<br />Nest 어플리케이션을 만들면 최소 하나의 모듈, 루트 모듈(<code>AppModule</code>)이 있습니다.<br />이 루트 모듈은 Nest가 Module 및 Provider 관계와 의존성을 해결하는 데 사용하는 내부 데이터 구조를 구축하는 시작점입니다. 모듈을 만들면 루트 모듈과 연결되어야합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppController &#125; <span class="keyword">from</span> <span class="string">'./app.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppService &#125; <span class="keyword">from</span> <span class="string">'./app.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [],</span><br><span class="line">  controllers: [AppController],</span><br><span class="line">  providers: [AppService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>@Module()</code> 데코레이터는 하나의 객체를 인자로 가지며, 객체가 가질 수 있는 프로퍼티는 다음과 같습니다.</p><ul><li><code>providers</code>: Nest injector에 의해 인스턴스화되고, 인스턴스들은 모듈 안에서 최소한으로 공유됩니다.</li><li><code>controllers</code>: 해당 모듈에서 정의된, 인스턴스화 되어야 하는 Controller 의 집합입니다.</li><li><code>imports</code>: 임포트된 모듈들의 리스트입니다. 이 리스트의 모듈들은 데코레이터에 사용 중인 모듈에서 필요한 <code>providers</code> 를 export 하고 있어야 합니다.</li><li><code>exports</code>: <code>providers</code> 의 하위 집합으로, 데코레이터를 사용 중인 모듈이 제공받은 Provider 의 일부를 내보낼 수 있습니다. 이는 다른 모듈에서 <code>import</code> 할 때 사용됩니다.</li></ul><h2 id="파일-생성"><a class="markdownIt-Anchor" href="#파일-생성"></a> 파일 생성</h2><h3 id="module-생성"><a class="markdownIt-Anchor" href="#module-생성"></a> Module 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nest g mo module-name</span><br></pre></td></tr></table></figure><h3 id="controller-생성"><a class="markdownIt-Anchor" href="#controller-생성"></a> Controller 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nest g co controller-name</span><br></pre></td></tr></table></figure><h3 id="service-생성"><a class="markdownIt-Anchor" href="#service-생성"></a> Service 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nest g s service-name</span><br></pre></td></tr></table></figure><h3 id="provider-생성"><a class="markdownIt-Anchor" href="#provider-생성"></a> Provider 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nest g pr provider-name</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/controllers#controllers" target="_blank" rel="noopener">https://docs.nestjs.com/controllers#controllers</a></li><li><a href="https://docs.nestjs.com/controllers#routing" target="_blank" rel="noopener">https://docs.nestjs.com/controllers#routing</a></li><li><a href="https://docs.nestjs.com/providers#providers" target="_blank" rel="noopener">https://docs.nestjs.com/providers#providers</a></li><li><a href="https://docs.nestjs.com/modules#modules" target="_blank" rel="noopener">https://docs.nestjs.com/modules#modules</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/08/nest-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NestJS] 설치 및 프로젝트 생성</title>
      <link>http://hgko1207.github.io/2023/05/08/nest-1/</link>
      <guid>http://hgko1207.github.io/2023/05/08/nest-1/</guid>
      <pubDate>Mon, 08 May 2023 02:22:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;설치&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#설치&quot;&gt;&lt;/a&gt; 설치&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Nest CLI&lt;/strong&gt; 를 사용하면 새 프로젝트를 설정하는 것이 매우 간단합니다.&lt;br /&gt;
npm 이 설
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="설치"><a class="markdownIt-Anchor" href="#설치"></a> 설치</h2><p><strong>Nest CLI</strong> 를 사용하면 새 프로젝트를 설정하는 것이 매우 간단합니다.<br />npm 이 설치된 상태에서 터미널에서 다음 명령을 사용하여 Nest CLI 를 설치합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">i -g @nestjs/cli</span></span><br></pre></td></tr></table></figure><h2 id="프로젝트-생성"><a class="markdownIt-Anchor" href="#프로젝트-생성"></a> 프로젝트 생성</h2><p><code>nest new</code> 명령어로 새 Nest 프로젝트를 만들 수 있습니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nest</span> <span class="string">new project-name</span></span><br></pre></td></tr></table></figure><p><code>nest new</code> 로 프로젝트 생성이 안된다면 <code>npx nest new</code> 로 진행합니다.</p><p>예시로 프로젝트를 생성해 보겠습니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study\nestjs&gt; nest new test-nestjs</span><br><span class="line">⚡  We will scaffold your app in a few seconds..</span><br><span class="line"></span><br><span class="line">? Which package manager would you ❤️  to use? (Use arrow keys)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> npm</span></span><br><span class="line">  yarn</span><br><span class="line">  pnpm</span><br></pre></td></tr></table></figure><p>기본적으로 npm 을 선택합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study\nestjs&gt; nest new test-nestjs</span><br><span class="line">⚡  We will scaffold your app in a few seconds..</span><br><span class="line"></span><br><span class="line">? Which package manager would you ❤️  to use? npm</span><br><span class="line">CREATE test-nestjs/.eslintrc.js (663 bytes)</span><br><span class="line">CREATE test-nestjs/.prettierrc (51 bytes)</span><br><span class="line">CREATE test-nestjs/nest-cli.json (171 bytes)</span><br><span class="line">CREATE test-nestjs/package.json (1942 bytes)</span><br><span class="line">CREATE test-nestjs/README.md (3340 bytes)</span><br><span class="line">CREATE test-nestjs/tsconfig.build.json (97 bytes)</span><br><span class="line">CREATE test-nestjs/tsconfig.json (546 bytes)</span><br><span class="line">CREATE test-nestjs/src/app.controller.spec.ts (617 bytes)</span><br><span class="line">CREATE test-nestjs/src/app.controller.ts (274 bytes)</span><br><span class="line">CREATE test-nestjs/src/app.module.ts (249 bytes)</span><br><span class="line">CREATE test-nestjs/src/app.service.ts (142 bytes)</span><br><span class="line">CREATE test-nestjs/src/main.ts (208 bytes)</span><br><span class="line">CREATE test-nestjs/test/app.e2e-spec.ts (630 bytes)</span><br><span class="line">CREATE test-nestjs/test/jest-e2e.json (183 bytes)</span><br><span class="line"></span><br><span class="line">✔ Installation in progress... ☕</span><br><span class="line"></span><br><span class="line">🚀  Successfully created project test-nestjs</span><br><span class="line">👉  Get started with the following commands:</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span>-nestjs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br><span class="line"></span><br><span class="line">                          Thanks for installing Nest 🙏</span><br><span class="line">                 Please consider donating to our open collective</span><br><span class="line">                        to help us maintain this package.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               🍷  Donate: https://opencollective.com/nest</span><br></pre></td></tr></table></figure><p>프로젝트에 필요한 파일과 폴더를 생성하고, 패키지들을 설치합니다. Nest CLI 를 사용하면 직접 파일을 만들 필요 없어 편리합니다.</p><h2 id="프로젝트-시작"><a class="markdownIt-Anchor" href="#프로젝트-시작"></a> 프로젝트 시작</h2><p>파일의 변경 사항을 감시하려면 다음 명령를 실행하여 프로젝트를 시작할 수 있습니다. 이 명령은 파일을 감시하여 자동으로 서버를 다시 컴파일하고 다시 로드합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start:dev</span><br></pre></td></tr></table></figure><p><code>http://localhost:3000/</code> 주소로 접속해서 정상적으로 시작됐는지 확인합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://docs.nestjs.com/first-steps" target="_blank" rel="noopener">https://docs.nestjs.com/first-steps</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/08/nest-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] detached HEAD 문제 해결 방법</title>
      <link>http://hgko1207.github.io/2023/05/04/git-1/</link>
      <guid>http://hgko1207.github.io/2023/05/04/git-1/</guid>
      <pubDate>Thu, 04 May 2023 06:22:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;git 을 사용할 때 add 와 commit 까진 실행이 잘 되는데 다음과 같이 &lt;strong&gt;detached HEAD&lt;/strong&gt; 문제로 push 가 안 될 때 해결 방법을 정리하였습니다.&lt;/p&gt;
&lt;figure class=&quot;highlight
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>git 을 사용할 때 add 와 commit 까진 실행이 잘 되는데 다음과 같이 <strong>detached HEAD</strong> 문제로 push 가 안 될 때 해결 방법을 정리하였습니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study\react&gt; git push</span><br><span class="line">fatal: You are not currently on a branch.</span><br><span class="line">To push the history leading to the current (detached HEAD)</span><br><span class="line">state now, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD:&lt;name-of-remote-branch&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Detached Head 란, 말 그대로 head가 (branch로부터) 떨어져있는 상태를 뜻한다.<br />즉, branch 를 통해서가 아니라 직접 다이렉트로 commit 을 참조하고 있는 상태를 뜻한다.</p></blockquote><p><code>git branch</code> 명령어를 사용하여 살펴보니 지금 현재 브랜치는 <strong>HEAD detached from bdcfe3d8</strong> 로 설정되어 있습니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study\react&gt; git branch -a</span><br><span class="line">* (HEAD detached from 537d4a3)</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h2 id="해결-방법"><a class="markdownIt-Anchor" href="#해결-방법"></a> 해결 방법</h2><p>임시로 새로운 브랜치를 만들어 main 브랜치와 병합하여 해결하는 방법입니다.</p><h3 id="브랜치-생성"><a class="markdownIt-Anchor" href="#브랜치-생성"></a> 브랜치 생성</h3><p>현재 Head 분기를 참조하게끔 임시 브랜치를 생성합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch temp</span><br><span class="line">git checkout temp</span><br></pre></td></tr></table></figure><p>또는</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -b 명령어 사용</span></span><br><span class="line">git checkout -b temp</span><br></pre></td></tr></table></figure><p>이렇게 하면 temp 라는 브랜치가 만들어지고, temp 로 checkout 을 하게 됩니다.</p><h3 id="master-브랜치로-이동"><a class="markdownIt-Anchor" href="#master-브랜치로-이동"></a> master 브랜치로 이동</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><h3 id="병합"><a class="markdownIt-Anchor" href="#병합"></a> 병합</h3><p>새로운 브랜치와 master 브랜치를 병합합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge temp</span><br></pre></td></tr></table></figure><h3 id="새로운-브랜치-삭제"><a class="markdownIt-Anchor" href="#새로운-브랜치-삭제"></a> 새로운 브랜치 삭제</h3><p>임시로 만든 temp 라는 브랜치를 삭제합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d temp</span><br></pre></td></tr></table></figure><h3 id="push"><a class="markdownIt-Anchor" href="#push"></a> push</h3><p>마지막으로 push 를 실행하면 됩니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>push 를 실행했을 때 다음과 같이 내용이 보이면 <code>git push --set-upstream origin master</code> 명령어를 사용해서 기본 브랜치를 설정합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study\react&gt; git push</span><br><span class="line">fatal: The current branch master has no upstream branch.</span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin master</span><br><span class="line"></span><br><span class="line">To have this happen automatically for branches without a tracking</span><br><span class="line">upstream, see 'push.autoSetupRemote' in 'git help config'.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/05/04/git-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Chocolatey를 이용한 Flutter 설치 방법</title>
      <link>http://hgko1207.github.io/2023/04/25/flutter-1/</link>
      <guid>http://hgko1207.github.io/2023/04/25/flutter-1/</guid>
      <pubDate>Tue, 25 Apr 2023 01:58:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;윈도우 환경에서 &lt;strong&gt;Chocolatey&lt;/strong&gt; 를 이용해서 &lt;strong&gt;Flutter&lt;/strong&gt; 를 설치하고 안드로이드 기기와 연결하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;1-chocolatey-설치&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>윈도우 환경에서 <strong>Chocolatey</strong> 를 이용해서 <strong>Flutter</strong> 를 설치하고 안드로이드 기기와 연결하는 방법에 대해 알아보겠습니다.</p><h2 id="1-chocolatey-설치"><a class="markdownIt-Anchor" href="#1-chocolatey-설치"></a> 1. Chocolatey 설치</h2><p>이전 글 <strong><a href="https://hgko1207.github.io/2021/07/21/chocolatey/">Chocolatey 설치</a></strong> 를 참고해서 Chocolatey 를 먼저 설치를 합니다.</p><h2 id="2-flutter-설치"><a class="markdownIt-Anchor" href="#2-flutter-설치"></a> 2. Flutter 설치</h2><p>관리자 권한으로 PowerShell 을 열고 다음 명령어를 실행하여 설치를 합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">choco</span> <span class="string">install flutter</span></span><br></pre></td></tr></table></figure><p>설치가 완료되면 <code>flutter</code> 명령어를 실행하였을 때 다음과 같이 메시지가 나옵니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; flutter</span><br><span class="line">Common commands:</span><br><span class="line"></span><br><span class="line">  flutter create &lt;output directory&gt;</span><br><span class="line">    Create a new Flutter project in the specified directory.</span><br><span class="line"></span><br><span class="line">  flutter run [options]</span><br><span class="line">    Run your Flutter application on an attached device or in an emulator.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Run "flutter help &lt;command&gt;" for more information about a command.</span><br><span class="line">Run "flutter help -v" for verbose help output, including less commonly used options.</span><br></pre></td></tr></table></figure><h2 id="3-안드로이드-연결"><a class="markdownIt-Anchor" href="#3-안드로이드-연결"></a> 3. 안드로이드 연결</h2><p>안드로이드 앱을 개발하려고 한다면 <a href="https://docs.flutter.dev/get-started/install/windows#android-setup" target="_blank" rel="noopener">Android setup</a> 사이트에 접속해서 가이드대로 Android 에뮬레이터를 설치하고 연결하면 됩니다.</p><p>설치 방법은 아래 기술하였습니다.</p><h3 id="1-android-studio-설치"><a class="markdownIt-Anchor" href="#1-android-studio-설치"></a> 1) Android Studio 설치</h3><p><a href="https://developer.android.com/studio" target="_blank" rel="noopener">https://developer.android.com/studio</a> 사이트에 접속해서 Android Studio 를 다운로드 합니다. 다운로드가 완료되면 설치를 진행합니다.</p><h3 id="2-android-sdk-빌드-도구-설치"><a class="markdownIt-Anchor" href="#2-android-sdk-빌드-도구-설치"></a> 2) Android SDK 빌드 도구 설치</h3><p>Android Studio 를 시작하고 <strong>‘Android Studio Setup Wizard’</strong> 를 진행합니다. 이렇게 하면 Android 용으로 개발할 때 Flutter 에 필요한 최신 <strong>Android SDK, Android SDK Command-line Tools</strong> 및 <strong>Android SDK Build-Tools</strong> 가 설치됩니다.</p><p>PowerShell 에서 <code>flutter doctor</code> 명령어를 실행해서 Flutter 가 설치된 Android Studio 를 찾았는지 확인합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt; flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)</span><br><span class="line">[√] Windows Version (Installed version of Windows is version 10 or higher)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK version 33.0.2)</span><br><span class="line">    X cmdline-tools component is missing</span><br><span class="line">      Run `path/to/sdkmanager --install "cmdline-tools;latest"`</span><br><span class="line">      See https://developer.android.com/studio/command-line for more details.</span><br><span class="line">    X Android license status unknown.</span><br><span class="line">      Run `flutter doctor --android-licenses` to accept the SDK licenses.</span><br><span class="line">      See https://flutter.dev/docs/get-started/install/windows#android-setup for more details.</span><br><span class="line">[√] Chrome - develop for the web</span><br><span class="line">[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)</span><br><span class="line">[√] Android Studio (version 2022.2)</span><br><span class="line">[√] VS Code (version 1.77.1)</span><br><span class="line">[√] Connected device (3 available)</span><br><span class="line">[√] Network resources</span><br></pre></td></tr></table></figure><h3 id="3-android-에뮬레이터-설정"><a class="markdownIt-Anchor" href="#3-android-에뮬레이터-설정"></a> 3) Android 에뮬레이터 설정</h3><p>Android 에뮬레이터에서 Flutter 앱을 실행하고 테스트할 준비를 하려면 다음 단계를 진행합니다.</p><ol><li>Machine 에서 <a href="https://developer.android.com/studio/run/emulator-acceleration?hl=ko#accel-vm" target="_blank" rel="noopener">VM acceleration</a> 를 활성화합니다.</li><li>Android Studio 를 실행하고 <strong>Tools &gt; Device Manager</strong> 메뉴를 클릭하거나 <strong>Device Manager 아이콘</strong>을 클릭한 다음 <strong>Virtual</strong> 탭 에서 <strong>Create Device</strong> 를 선택합니다.</li></ol><ul><li>이전 버전의 Android Studio 에서는 대신 <strong>Android Studio &gt; Tools &gt; Android &gt; AVD Manager</strong> 를 실행 하고 <strong>Create Virtual Device</strong> 를 선택해야 합니다. (Android 하위 메뉴는 Android 프로젝트 내부에만 있습니다.)</li><li>열려 있는 프로젝트가 없으면 <strong>점 3개 Menu / More Actions &gt; Virtual Device Manager</strong> 메뉴를 클릭한 다음 <strong>Create Device</strong> 를 선택할 수 있습니다.</li></ul><ol start="3"><li><strong>Visual Device Configuration</strong> 창에서 장치를 선택하고 <strong>Next</strong> 버튼을 클릭합니다. (저는 Pixel 3 XL 모델을 선택했습니다.)</li><li>에뮬레이션하려는 Android 버전의 시스템 이미지를 하나 이상 선택하고 <strong>Next</strong> 버튼을 클릭합니다. x86 또는 x86_64 이미지를 권장합니다.</li><li><strong>Verify Configuration</strong> 에서 하단에 Emulated Performance 에서 Graphics 를 <strong>Hardware-GLES 2.0</strong> 으로 선택 후 <strong>Finish</strong> 버튼을 클릭하여 하드웨어 가속을 활성화합니다.</li><li>Android Virtual Device Manager 의 도구 모음에서 실행(▶)을 클릭합니다. 에뮬레이터가 시작되고 선택한 OS 버전 및 장치에 대한 기본 캔버스를 표시합니다.</li></ol><img width="100%" src="/images/flutter/flutter_1.png" alt=""><h3 id="4-android-라이선스에-동의"><a class="markdownIt-Anchor" href="#4-android-라이선스에-동의"></a> 4) Android 라이선스에 동의</h3><p>Flutter 를 사용하려면 먼저 Android SDK 플랫폼의 라이선스에 동의해야 합니다. 이 단계는 위에 나열된 도구를 설치한 후에 수행해야 합니다.</p><ul><li>자바 8 버전 이상이 설치되어 있고 JDK 의 폴더가 환경 변수 설정되어 있는지 확인합니다.</li></ul><p>PowerShell 또는 명령 프롬프트에서 다음 명령어를 실행하여 라이언스 서명을 시작합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure><h4 id="에러-발생-해결-방법"><a class="markdownIt-Anchor" href="#에러-발생-해결-방법"></a> 에러 발생 해결 방법</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt; flutter doctor --android-licenses</span><br><span class="line">Android sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed to</span><br><span class="line">resolve this.</span><br></pre></td></tr></table></figure><p>만약 cmdline-tools 가 없으므로 설치하라는 빨간 메시지가 출력된다면 다음의 절차를 진행합니다.</p><ol><li>Android Studio 에서 <strong>SDK Manager</strong> 를 실행합니다.</li><li>좌측의 <strong>System Settings</strong> 에서 <strong>Android SDK</strong> 를 선택하고 우측 화면에서 <strong>SDK Tools</strong> 탭을 선택합니다.</li><li><strong>Android SDK Command-line Tools(latest)</strong> 를 체크한 후 <strong>OK</strong> 버튼을 클릭해 설치를 진행합니다.</li><li>설치가 완료되었다면 <strong>Finish</strong> 를 클릭하고 <code>flutter doctor --android-licenses</code> 명령어를 다시 입력합니다. 이때 동의에 대해 묻는데 y 입력해주시면 됩니다.</li><li><strong>All SDK package licenses accepted</strong> 메시지가 출력 되면 라이센스 동의가 끝났습니다.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt; flutter doctor --android-licenses</span><br><span class="line">...</span><br><span class="line">Accept? (y/N): y</span><br><span class="line">All SDK package licenses accepted</span><br></pre></td></tr></table></figure><h3 id="5-확인"><a class="markdownIt-Anchor" href="#5-확인"></a> 5) 확인</h3><p>라이선스 동의가 완료되면 <code>flutter doctor</code> 명령어를 다시 입력하여 Flutter 를 사용할 준비가 되었는지 확인합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt; flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)</span><br><span class="line">[√] Windows Version (Installed version of Windows is version 10 or higher)</span><br><span class="line">[√] Android toolchain - develop for Android devices (Android SDK version 33.0.2)</span><br><span class="line">[√] Chrome - develop for the web</span><br><span class="line">[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)</span><br><span class="line">[√] Android Studio (version 2022.2)</span><br><span class="line">[√] VS Code (version 1.77.1)</span><br><span class="line">[√] Connected device (4 available)</span><br><span class="line">[√] Network resources</span><br></pre></td></tr></table></figure><h4 id="에러-발생-해결-방법-2"><a class="markdownIt-Anchor" href="#에러-발생-해결-방법-2"></a> 에러 발생 해결 방법</h4><p><code>flutter doctor</code> 명령어를 실행하였을 때 Windows 10 SDK 이 없다고 하는 메시지가 출력될 경우 해결 방법입니다.</p><ol><li><a href="https://visualstudio.microsoft.com/ko/downloads/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/ko/downloads/</a> 사이트에서 Visual Studio 2022 버전의 <strong>무료 다운로드</strong>를 클릭하여 다운로드하고 설치해줍니다.</li><li>Visual Studio Installer 창이 열리면 데스크톱 및 모바일에서 <strong>C++를 이용한 데스크톱 개발</strong>을 선택 후 설치합니다.</li></ol><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>Chocolatey 를 사용해서 Flutter 를 설치하면 zip 파일을 다운받고, 열어서 설치하고, path 설정하고, 여러가지 설정하는 것보다 훨씬 쉬운 방법입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/25/flutter-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] 클래스(Class) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/04/18/dart-6/</link>
      <guid>http://hgko1207.github.io/2023/04/18/dart-6/</guid>
      <pubDate>Tue, 18 Apr 2023 04:55:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Dart&lt;/strong&gt; 에서 클래스(Class) 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;class&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#class&quot;&gt;&lt;/a&gt; Class&lt;/h2&gt;
&lt;p&gt;클
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Dart</strong> 에서 클래스(Class) 사용 방법에 대해 알아보겠습니다.</p><h2 id="class"><a class="markdownIt-Anchor" href="#class"></a> Class</h2><p>클래스 안에서 property 를 선언할 때는 타입을 사용해서 정의합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name = <span class="string">'eden'</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hi my name is <span class="subst">$name</span>"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// new 를 꼭 붙이지 않아도 됩니다.</span></span><br><span class="line">  <span class="keyword">var</span> player = Player();</span><br><span class="line">  player.sayName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 메서드 안에서는 this 를 붙이지 않는 것을 Dart 에서는 권장하나, 어쩔 수 없이 같은 변수명이 있을 때는 this 를 붙여서 사용해야 합니다.</p><h2 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> Constructor</h2><p>생성자(constructor) 함수는 클래스 이름과 같아야 합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="comment">// late 사용</span></span><br><span class="line">  late <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  late <span class="keyword">final</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Player(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// Player 클래스의 인스턴스 생성</span></span><br><span class="line">  <span class="keyword">var</span> player = Player(<span class="string">"eden"</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 생성자 함수는 다음과 같이 줄일 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="comment">// late 사용 안함</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Player(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 <code>late</code> 를 사용하였지만 아래 코드에서 사용하지 않은 이유는 생성자 함수를 만들 때 변수에 값을 할당하지 않았기 때문입니다.</p><p>이전 생성자 함수를 만들 때에는 <code>this.name = name;</code> 식으로 값을 할당했기 때문에 먼저 선언한 변수에 <code>late</code> 를 붙여야 오류가 발생하지 않습니다.</p><h2 id="named-constructor-parameters"><a class="markdownIt-Anchor" href="#named-constructor-parameters"></a> Named Constructor Parameters</h2><p>클래스가 거대해질 경우 다음과 같이 생성자 함수를 만드는 것은 비효율적일 것입니다. 많은 파라미터를 받아야 하고 각 파라미터의 의미를 알 수가 없습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> members;</span><br><span class="line">  <span class="built_in">int</span> ranking;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Team(<span class="keyword">this</span>.name, <span class="keyword">this</span>.members, <span class="keyword">this</span>.ranking, <span class="keyword">this</span>.description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> team = Team(<span class="string">"Tottenham"</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="string">"Tottenham Hotspur Football Club"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제를 해결할려면 너무 간단합니다. 생성자 함수 생성할 때 중괄호({})를 사용하는 것입니다. 그리고 클래스를 정의할 때 Named Paramaters 를 사용합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> members;</span><br><span class="line">  <span class="built_in">int</span> ranking;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Team(&#123;<span class="keyword">this</span>.name, <span class="keyword">this</span>.members, <span class="keyword">this</span>.ranking, <span class="keyword">this</span>.description&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> team = Team(</span><br><span class="line">      name: <span class="string">"Tottenham"</span>,</span><br><span class="line">      members: <span class="number">25</span>,</span><br><span class="line">      ranking: <span class="number">5</span>,</span><br><span class="line">      description: <span class="string">"Tottenham Hotspur Football Club"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 여기에는 큰 문제가 있습니다. 변수가 null 일 수도 있기 때문에 기본 값(default value)을 주거나 required 파라미터 앞에 붙여 사용합니다. 다음의 코드는 <code>required</code> 를 사용하였습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> members;</span><br><span class="line">  <span class="built_in">int</span> ranking;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Team(&#123;</span><br><span class="line">    required <span class="keyword">this</span>.name,</span><br><span class="line">    required <span class="keyword">this</span>.members,</span><br><span class="line">    required <span class="keyword">this</span>.ranking,</span><br><span class="line">    required <span class="keyword">this</span>.description</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> team = Team(</span><br><span class="line">      name: <span class="string">"Tottenham"</span>,</span><br><span class="line">      members: <span class="number">25</span>,</span><br><span class="line">      ranking: <span class="number">5</span>,</span><br><span class="line">      description: <span class="string">"Tottenham Hotspur Football Club"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="named-constructor"><a class="markdownIt-Anchor" href="#named-constructor"></a> Named Constructor</h2><p>콜론(:)을 사용하면 특별한 생성자 함수를 만들 수 있습니다.<br />콜론을 넣음으로써 dart 에게 객체를 초기화하라고 명령할 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> members;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Team(&#123;required <span class="keyword">this</span>.name, required <span class="keyword">this</span>.members, required <span class="keyword">this</span>.description&#125;);</span><br><span class="line"></span><br><span class="line">  Team.createTeam(&#123;required <span class="built_in">String</span> name, required <span class="built_in">int</span> members&#125;)</span><br><span class="line">      : <span class="keyword">this</span>.name = name,</span><br><span class="line">        <span class="keyword">this</span>.members = members,</span><br><span class="line">        <span class="keyword">this</span>.description = <span class="string">"<span class="subst">$name</span> team is good."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> team = Team.createTeam(</span><br><span class="line">    name: <span class="string">"Tottenham"</span>,</span><br><span class="line">    members: <span class="number">25</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enum"><a class="markdownIt-Anchor" href="#enum"></a> Enum</h2><p><strong>Enum</strong> 은 우리가 코드를 작성할 때 실수를 하지 않게 도와줍니다.<br />enum type 의 변수들은 해당 enum type 에 생성된 값들 중에서만 값이 할당될 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Team &#123; red, blue &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Team team;</span><br><span class="line"></span><br><span class="line">  Player(&#123;required <span class="keyword">this</span>.name, required <span class="keyword">this</span>.team&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> player = Player(name: <span class="string">'eden'</span>, team: Team.red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="abstract-class"><a class="markdownIt-Anchor" href="#abstract-class"></a> Abstract Class</h2><p><strong>추상 클래스</strong>는 다른 클래스들이 직접 구현해야 하는 필드와 메소드들을 모아놓은 클래스입니다.<br />추상 클래스는 아직 메소드와 내용이 추상적이므로 객체를 생성할 수 없습니다.<br />추상 클래스를 상속받는 클래스들은 추상 클래스의 메소드들을 구현해야 합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> team;</span><br><span class="line"></span><br><span class="line">  Player(&#123;required <span class="keyword">this</span>.name, required <span class="keyword">this</span>.team&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> walk() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Player is walking"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> player = Player(name: <span class="string">'eden'</span>, team: <span class="string">'red'</span>);</span><br><span class="line">  player.walk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mixin"><a class="markdownIt-Anchor" href="#mixin"></a> Mixin</h2><p><strong>Mixin</strong> 은 생성자가 없는 클래스를 의미합니다.<br />Mixin 은 클래스에 코드를 재사용하기 위해 사용되며, 다중 상속의 일부 단점을 보완합니다. Mixin 은 extends 가 아닌 with 키워드를 사용하여 클래스에 적용합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Strong &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> strengthLevel = <span class="number">100.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Tall &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height = <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> QuickRunner &#123;</span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"run!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="title">with</span> <span class="title">Strong</span>, <span class="title">Tall</span>, <span class="title">QuickRunner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Player(&#123;required <span class="keyword">this</span>.name&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> player = Player(</span><br><span class="line">    name: <span class="string">"eden"</span>,</span><br><span class="line">  );</span><br><span class="line">  player.run(); <span class="comment">// run!! 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="상속과-mixin-의-차이점"><a class="markdownIt-Anchor" href="#상속과-mixin-의-차이점"></a> 상속과 Mixin 의 차이점</h3><p>extends 를 사용하여 상속받은 클래스는 자식 클래스, 상속한 클래스는 부모클래스가 되는 것이고, 자식 클래스는 부모 클래스를 super 를 통해서 접근할 수 있습니다.</p><p>Mixin 은 with 라는 키워드를 통해서 단순히 Mixin 내부의 프로퍼티와 메소드들을 가져오는 것 뿐입니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/18/dart-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] 함수(Function) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/04/17/dart-5/</link>
      <guid>http://hgko1207.github.io/2023/04/17/dart-5/</guid>
      <pubDate>Mon, 17 Apr 2023 05:57:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Dart&lt;/strong&gt; 에서 함수(Function) 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;functions&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#functions&quot;&gt;&lt;/a&gt; Funct
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Dart</strong> 에서 함수(Function) 사용 방법에 대해 알아보겠습니다.</p><h2 id="functions"><a class="markdownIt-Anchor" href="#functions"></a> Functions</h2><p>Dart 는 진정한 객체 지향 언어이므로 함수도 객체이며 타입이 Function 입니다. 이는 함수를 변수에 할당하거나 다른 함수에 인수로 전달할 수 있음을 의미합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 하나의 표현식만 포함하는 함수의 경우 아래와 같이 단축 구문을 사용할 수 있습니다.</span></span><br><span class="line"><span class="built_in">String</span> sayHello(<span class="built_in">String</span> name) =&gt; <span class="string">"Hello <span class="subst">$&#123;name&#125;</span> nice to meet you!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">num</span> plus(<span class="built_in">num</span> a, <span class="built_in">num</span> b) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(sayHello(<span class="string">"eden"</span>)); <span class="comment">// Hello eden nice to meet you!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="positional-paramaters"><a class="markdownIt-Anchor" href="#positional-paramaters"></a> Positional Paramaters</h2><p>함수을 호출할 때 필요한 매개변수와 매개변수의 위치를 정확하게 알아야 합니다. 함수의 매개변수가 많아 질수록 함수 호출할 때 다 기억해야 하므로 사용하기 어렵습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sayHello(<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">String</span> country) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello <span class="subst">$name</span>, you are <span class="subst">$age</span>, and you come from <span class="subst">$country</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(sayHello(<span class="string">'eden'</span>, <span class="number">30</span>, <span class="string">'Korea'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="named-paramaters"><a class="markdownIt-Anchor" href="#named-paramaters"></a> Named Paramaters</h2><p>위의 <strong>Positional Paramaters</strong> 방식은 함수를 호출할 때 사용자가 요소들의 순서를 잊어버릴 수도 있고, 코드를 봤을 때 인자가 뜻하는 것이 무엇인지 바로 이해를 못할 수도 있습니다.<br />이 문제를 해결하기 위해 Dart 에서는 <strong>Named Paramaters</strong> 를 지원합니다.</p><p>다음과 같이 매개변수 앞뒤로 중괄호를 붙여주면 함수를 호출할 때 매개변수의 이름과 값을 함께 입력할 수 있어 사용자에게 훨씬 편리합니다. 이때 매개변수들의 순서는 지키지 않아도 됩니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sayHello(&#123;<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">String</span> country&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"<span class="subst">$&#123;name&#125;</span> / <span class="subst">$&#123;age&#125;</span> / <span class="subst">$&#123;country&#125;</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(sayHello(name: <span class="string">"eden"</span>, age: <span class="number">30</span>, country: <span class="string">"Korea"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 여기서 또 문제가 발생합니다. Dart 는 null safety 가 적용되는데, 매개변수 중 하나가 null 일 수도 있기 때문입니다. 다시 말해, 사용자가 name 과 age, country 3개의 매개변수 중 하나라도 빼고 보낼 수 있습니다.</p><p>이때는 두 가지 옵션이 있습니다.</p><h3 id="default-value"><a class="markdownIt-Anchor" href="#default-value"></a> default value</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sayHello(&#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">'ko'</span>,</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">99</span>,</span><br><span class="line">  <span class="built_in">String</span> country = <span class="string">'Italy'</span>,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello <span class="subst">$name</span>, you are <span class="subst">$age</span>, and you come from <span class="subst">$country</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(sayHello());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 호출할 때 아무것도 전달하지 않아도 default value 가 이미 있으므로 null safety 에 걸릴 일이 없습니다.</p><h3 id="required"><a class="markdownIt-Anchor" href="#required"></a> required</h3><p>다음과 같이 매개변수 앞에 <code>required</code> 를 적어주면, 함수가 호출될 때 반드시 <code>required</code> 가 적힌 매개변수가 포함되어야 한다는 것입니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sayHello(&#123;</span><br><span class="line">  required <span class="built_in">String</span> name,</span><br><span class="line">  required <span class="built_in">int</span> age,</span><br><span class="line">  required <span class="built_in">String</span> country</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello <span class="subst">$name</span>, you are <span class="subst">$age</span>, and you come from <span class="subst">$country</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(🚫sayHello());</span><br><span class="line">  <span class="comment">// name, country, age가 모두 포함되어야 하기 때문에 dart에서 컴파일하지 않음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="optional-positional-paramaters"><a class="markdownIt-Anchor" href="#optional-positional-paramaters"></a> Optional Positional Paramaters</h2><p>Dart 에서 <code>[]</code> 은 optional, positional parameter 를 명시할 때 사용됩니다.<br />name, age 는 필수값이고 []를 통해 country 를 optional 값으로 지정해줄 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sayHello(<span class="built_in">String</span> name, <span class="built_in">int</span> age, [<span class="built_in">String</span>? country = <span class="string">"Korea"</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello <span class="subst">$&#123;name&#125;</span>, You are <span class="subst">$&#123;age&#125;</span> from the <span class="subst">$&#123;country&#125;</span>'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> result = sayHello(<span class="string">"eden"</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(result); <span class="comment">// Hello eden, You are 3 from the Korea</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="qq-operator"><a class="markdownIt-Anchor" href="#qq-operator"></a> QQ Operator</h2><p><code>??</code> 연산자를 이용하면 왼쪽 값이 null 인지 체크해서 null 이 아니면 왼쪽 값을 리턴하고 null 이면 오른쪽 값을 리턴합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> capitalizeName(<span class="built_in">String</span>? name) &#123;</span><br><span class="line">  <span class="keyword">return</span> name?.toUpperCase() ?? <span class="string">"NONE"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(capitalizeName(<span class="string">"eden"</span>)); <span class="comment">// EDEN;</span></span><br><span class="line">  <span class="built_in">print</span>(capitalizeName(<span class="keyword">null</span>)); <span class="comment">// NONE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 더욱 간략하게 만들 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> capitalizeName(<span class="built_in">String</span>? name) =&gt; name?.toUpperCase() ?? <span class="string">"NONE"</span>;</span><br></pre></td></tr></table></figure><p><code>??=</code> 연산자를 이용하면 변수 안에 값이 null 일 때를 체크해서 값을 할당해줄 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span>? name;</span><br><span class="line">  name ??= <span class="string">"eden"</span>;</span><br><span class="line">  name = <span class="keyword">null</span>;</span><br><span class="line">  name ??= <span class="string">"ko"</span>;</span><br><span class="line">  <span class="built_in">print</span>(name); <span class="comment">// ko</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typedef"><a class="markdownIt-Anchor" href="#typedef"></a> TypeDef</h2><p>자료형에 사용자가 원하는 alias 를 붙일 수 있게 해줍니다. (자료형 이름의 별명을 만들 때 사용)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용 전</span></span><br><span class="line"><span class="built_in">List</span> reverseListOfNumbers(<span class="built_in">List</span> list) &#123;</span><br><span class="line">  <span class="keyword">var</span> reversed = list.reversed;</span><br><span class="line">  <span class="keyword">return</span> reversed.toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용 후</span></span><br><span class="line"><span class="keyword">typedef</span> ListOfInts = <span class="built_in">List</span>;</span><br><span class="line"></span><br><span class="line">ListOfInts reverseListOfNumbers(ListOfInts list) &#123;</span><br><span class="line">  <span class="keyword">var</span> reversedList = list.reversed.toList();</span><br><span class="line">  <span class="keyword">return</span> reversedList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(reverseListOfNumbers([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// [3, 2, 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://dart.dev/guides/language/language-tour#functions" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#functions</a></li><li><a href="https://dart.dev/guides/language/language-tour#parameters" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#parameters</a></li><li><a href="https://dart.dev/guides/language/language-tour#typedefs" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#typedefs</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/17/dart-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] Data Types</title>
      <link>http://hgko1207.github.io/2023/04/17/dart-4/</link>
      <guid>http://hgko1207.github.io/2023/04/17/dart-4/</guid>
      <pubDate>Mon, 17 Apr 2023 05:07:53 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Dart&lt;/strong&gt; 에서 데이터 타입 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;기본-데이터-타입&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#기본-데이터-타입&quot;&gt;&lt;/a&gt; 기본 데이터 타입&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Dart</strong> 에서 데이터 타입 사용 방법에 대해 알아보겠습니다.</p><h2 id="기본-데이터-타입"><a class="markdownIt-Anchor" href="#기본-데이터-타입"></a> 기본 데이터 타입</h2><p>Dart 에는 대표적으로 <code>String</code>, <code>bool</code>, <code>int</code>, <code>double</code>, <code>num</code> 타입이 있습니다. 중요한 점은 이 모든게 객체(object)라는 것 입니다.</p><p>Dart 가 진정한 객체 지향 언어로 불리는 이유입니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">"eden"</span>;</span><br><span class="line">  <span class="built_in">bool</span> isPlay = <span class="keyword">true</span>;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">double</span> money = <span class="number">59.99</span>;</span><br><span class="line">  <span class="built_in">num</span> x = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">num</span> y = <span class="number">1.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string-interpoldation"><a class="markdownIt-Anchor" href="#string-interpoldation"></a> String Interpoldation</h2><p><strong>String Interpoldation</strong> 은 텍스트에 변수를 추가하는 방법입니다.</p><p>단순히 변수의 값을 넣고 싶다면 <code>$</code>달러 기호 뒤에 사용할 변수를 적어주면 됩니다. 변수의 값을 계산하고 싶다면 <code>$</code>와 함께 중괄호(`${ })내에 계산할 내용을 적어주면 됩니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"eden"</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">"hello <span class="subst">$name</span>, I'm <span class="subst">$&#123;age + <span class="number">5</span>&#125;</span> years old."</span>;</span><br><span class="line">  <span class="built_in">print</span>(greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lists"><a class="markdownIt-Anchor" href="#lists"></a> Lists</h2><p>Dart 에서 <strong>List</strong> 를 선언하는 것은 두 가지 방법이 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  numbers.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> number2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 에서 List 의 유용한 점은 <code>collection if</code> 와 <code>collection for</code> 를 지원합니다.</p><h3 id="collection-if"><a class="markdownIt-Anchor" href="#collection-if"></a> collection if</h3><p>collection if 는 List 를 만들 때, if 를 통해 <strong>존재할 수도 안 할 수도 있는 요소</strong>를 가지고 만들 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> giveMeFive = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">var</span> item = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    <span class="keyword">if</span> (giveMeFive) <span class="number">5</span>, <span class="comment">// giveMeFive가 true이면 5가 추가됨</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">print</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="collection-for"><a class="markdownIt-Anchor" href="#collection-for"></a> Collection For</h3><p>Dart 에서는 반복(for)을 사용하여 컬렉션을 구축하는 데 사용할 수 있는 Collection for 를 제공합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> oldFriends = [<span class="string">"ko"</span>, <span class="string">"lee"</span>];</span><br><span class="line">    <span class="keyword">var</span> newFriends = [</span><br><span class="line">    <span class="string">"eden"</span>,</span><br><span class="line">    <span class="string">"woorim"</span>,</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> friend <span class="keyword">in</span> oldFriends) <span class="string">"🥰 <span class="subst">$friend</span>"</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(newFriends); <span class="comment">// [eden, woorim, 🥰 ko, 🥰 lee]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maps"><a class="markdownIt-Anchor" href="#maps"></a> Maps</h2><p>일반적으로 Map 은 key 와 value 를 연결하는 객체입니다. 키와 값 모두 모든 유형의 객체가 될 수 있습니다. 각 키는 한 번만 발생하지만 동일한 값을 여러 번 사용할 수 있습니다.</p><p>Map 을 정의하는 방법은 두 가지가 있습니다. 첫 번째는 <code>var</code> 를 이용한 방법입니다. 두 번째는 <code>var</code> 대신 <code>Map</code> 을 사용하고, 자료형을 명시하는 것입니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째</span></span><br><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="comment">// Key: Value</span></span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'smartphone'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'laptop'</span>,</span><br><span class="line">  <span class="string">'third'</span>: <span class="string">'bicycle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째</span></span><br><span class="line"><span class="built_in">Map</span> players = &#123;</span><br><span class="line">  <span class="number">1</span> : <span class="keyword">true</span>,</span><br><span class="line">  <span class="number">2</span> : <span class="keyword">false</span>,</span><br><span class="line">  <span class="number">3</span> : <span class="keyword">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 생성자를 사용하여 동일한 객체를 만들 수 있습니다.</span></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">'first'</span>] = <span class="string">'smartphone'</span>;</span><br><span class="line">gifts[<span class="string">'second'</span>] = <span class="string">'laptop'</span>;</span><br><span class="line">gifts[<span class="string">'third'</span>] = <span class="string">'bicycle'</span>;</span><br></pre></td></tr></table></figure><h2 id="sets"><a class="markdownIt-Anchor" href="#sets"></a> Sets</h2><p><strong>Set</strong> 에 속한 모든 아이템들이 유니크해야될 때 사용합니다. 유니크할 필요가 없다면 <code>List</code> 를 사용하면 됩니다.</p><p><code>Set</code> 도 두 가지 방법으로 정의할 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> numbers1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">Set</span> numbers2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; numbers3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  numbers3.add(<span class="number">1</span>);</span><br><span class="line">  numbers3.add(<span class="number">2</span>);</span><br><span class="line">  numbers3.add(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">print</span>(numbers3) <span class="comment">// &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List</code> 는 대괄호를 쓰며 <code>Set</code> 은 중괄호를 쓴다는 점이 다릅니다. <code>List</code> 는 같은 요소가 여러개 반복될 수 있지만, <code>Set</code> 은 중복이 허용되지 않습니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://dart.dev/guides/language/language-tour#collection-operators" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#collection-operators</a></li><li><a href="https://dart.dev/guides/language/language-tour#maps" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#maps</a></li><li><a href="https://dart.dev/guides/language/language-tour#sets" target="_blank" rel="noopener">https://dart.dev/guides/language/language-tour#sets</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/17/dart-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] Null Safety</title>
      <link>http://hgko1207.github.io/2023/04/14/dart-3/</link>
      <guid>http://hgko1207.github.io/2023/04/14/dart-3/</guid>
      <pubDate>Fri, 14 Apr 2023 05:10:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Null Safety&lt;/strong&gt; 는 개발자가 null 값을 참조할 수 없게 하는 것입니다.&lt;/p&gt;
&lt;p&gt;다음 코드를 봅시다.&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Null Safety</strong> 는 개발자가 null 값을 참조할 수 없게 하는 것입니다.</p><p>다음 코드를 봅시다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">String</span> string) =&gt; string.length == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="comment">// [오류]</span></span><br><span class="line">  isEmpty(🚫<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같은 코드는 어떻게 실행될까요?</p><p>정답은 <code>NoSuchMethodError</code> 를 실행합니다. 왜 이렇게 실행될까요?<br />바로 String 을 보내야 할 곳에 null 을 보냈기 때문입니다.<br />null 에는 length 라는 속성이 없기 때문이기도 합니다.</p><p>이와 같은 에러는 컴파일러에서 잡을 수 있는 에러가 아닙니다.<br />이런 상황이 발생하지 않도록 null 를 삭제하기에는 null 값은 유용합니다.</p><p>그럼 어떻게 null 값을 참조하는 것을 dart 는 어떻게 보호할까요?<br />dart 에서는 변수가 null 이 될 수 있음을 명확히 표시해야합니다.</p><p>다음 코드를 봅시다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">"eden"</span>;</span><br><span class="line">  🚫name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 에러가 납니다. name 이 null 값을 참조할 수 있다고 알려주지 않고 null 값을 참조하기 때문입니다.</p><p>그러면 다음 코드를 봅시다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span>? name = <span class="string">"eden"</span>;</span><br><span class="line">  name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 에러가 나지 않습니다. 차이점이 뭘까요? 바로 변수 뒤에 <code>?</code>를 사용해 이 변수에는 null 이 참조될 수 있음을 알려주는 것입니다.</p><p>만약 <code>?</code>를 붙인 변수는 이 변수가 null 인지 아닌지 확인해야 합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span>? name = <span class="string">"eden"</span>;</span><br><span class="line">  name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(name.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/14/dart-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] 변수(Variable) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/04/13/dart-2/</link>
      <guid>http://hgko1207.github.io/2023/04/13/dart-2/</guid>
      <pubDate>Thu, 13 Apr 2023 02:09:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Dart&lt;/strong&gt; 에서 변수 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;변수를-만드는-2가지-방법&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#변수를-만드는-2가지-방법&quot;&gt;&lt;/a&gt; 변수를 만
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Dart</strong> 에서 변수 사용 방법에 대해 알아보겠습니다.</p><h2 id="변수를-만드는-2가지-방법"><a class="markdownIt-Anchor" href="#변수를-만드는-2가지-방법"></a> 변수를 만드는 2가지 방법</h2><p>dart 에서는 변수를 var 키워드 또는 명시적으로 변수의 타입을 지정해서 사용합니다. 다른 타입의 변수는 서로 대입할 수 없습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 방법 1</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"car"</span>;</span><br><span class="line">  name = <span class="string">"bus"</span>;</span><br><span class="line">  <span class="comment">// [오류]</span></span><br><span class="line">  🚫 name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 방법 2</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">"car"</span>;</span><br><span class="line">  name = <span class="string">"bus"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var 를 사용하는게 dart 스타일가이드의 권장 방식입니다.</p><p>함수나 메소드 내부에 지역변수를 선언할 때는 var 를 사용하고 class 에서 변수나 property 를 선언할 때는 타입을 지정해줍니다.</p><h2 id="dynamic-타입"><a class="markdownIt-Anchor" href="#dynamic-타입"></a> Dynamic 타입</h2><p>여러가지 타입을 가질 수 있는 변수에 쓰는 키워드입니다. 변수를 선언할 때 dynamic 을 쓰거나 값을 지정하지 않으면 dynamic 타입을 가집니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">dynamic</span> name;</span><br><span class="line">  <span class="keyword">var</span> name2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  name = <span class="string">'car'</span>;</span><br><span class="line">  name = <span class="number">1</span>;</span><br><span class="line">  name = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dynamic 타입은 언제 사용될까?</p><ul><li>해당 변수의 타입을 알 수 없을 때 주로 사용합니다. 예를 들어 json 을 작업할 경우입니다.</li><li>하지만 dynamic 타입은 다양한 타입을 가질 수 있기 때문에 <strong>정말 필요할 때만</strong> 사용해야 합니다. (위험 방지)</li></ul><h2 id="null-safety"><a class="markdownIt-Anchor" href="#null-safety"></a> Null Safety</h2><p>null safety 는 개발자가 null 값을 참조할 수 없도록 하는 것입니다.<br />String 뒤에 ?를 붙여줌으로서 name 이 String 또는 null 이 될 수 있다고 명시해준 것입니다. 기본적으로 모든 변수는 non-nullable(null이 될 수 없음)입니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span>? name = <span class="string">"eden"</span>;</span><br><span class="line">  name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final-변수"><a class="markdownIt-Anchor" href="#final-변수"></a> final 변수</h2><p>var 대신 final 로 변수를 만들게 되면 이 변수는 수정할 수 없게 됩니다. (딱 한 번만 설절될 수 있음) 자바스크립트의 const 랑 비슷합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> name = <span class="string">"pizza"</span>;</span><br><span class="line">  🚫name = <span class="string">"ham"</span>; <span class="comment">// 수정 불가</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> username = <span class="string">"eden"</span>;</span><br><span class="line">  🚫name = <span class="string">"eden2"</span>; <span class="comment">// 수정 불가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="late-변수"><a class="markdownIt-Anchor" href="#late-변수"></a> late 변수</h2><p>초기 데이터 없이 먼저 변수를 생성하고 추후에 데이터를 넣을 때 주로 사용합니다. flutter 로 data fecthing 을 할 때 유용합니다.</p><p>late 변수를 만들고, API 에 요청을 보낸 뒤에 API 에서 값을 보내주면 그 응답 값을 late 변수에 넣어 사용할 수 있습니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  late <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  🚫<span class="built_in">print</span>(name); <span class="comment">// 값을 넣기 전에는 name 변수에 접근 불가</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something, go to api</span></span><br><span class="line">  name = <span class="string">'api'</span>;</span><br><span class="line">  <span class="comment">// 한번만 할당해 줄 수 있음</span></span><br><span class="line">  🚫name = <span class="string">'test'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-변수"><a class="markdownIt-Anchor" href="#const-변수"></a> const 변수</h2><p>dart 에서 const 는 compile-time constant 를 만들어줍니다. const 는 컴파일할 때 알고 있는 값을 사용해야 합니다.</p><p>만약 어떤 값인지 모르고, 그 값이 API 로부터 오거나 사용자가 화면에서 입력해야 하는 값이라면 그건 const 가 아닌 final 이나 var 가 되어야 합니다.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 컴파일 시점에 바뀌지 않는 값</span></span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">"********"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 컴파일 시점에 바뀌는 값</span></span><br><span class="line">  <span class="keyword">final</span> API = fetchAPI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>const</strong>: 컴파일 시점에 바뀌지 않는 값 (상수)</li><li><strong>final</strong>: 컴파일 시점에 바뀌는 값 (API 에서 받아온 값, 사용자 입력값)</li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/13/dart-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Dart] 시작하기</title>
      <link>http://hgko1207.github.io/2023/04/12/dart-1/</link>
      <guid>http://hgko1207.github.io/2023/04/12/dart-1/</guid>
      <pubDate>Wed, 12 Apr 2023 01:35:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;dart-란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#dart-란&quot;&gt;&lt;/a&gt; Dart 란&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Dart&lt;/strong&gt; 는 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다.&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="dart-란"><a class="markdownIt-Anchor" href="#dart-란"></a> Dart 란</h2><p><strong>Dart</strong> 는 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다.</p><ol><li><strong>UI 최적화용</strong><br />사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발합니다.<br /><br/></li><li><strong>생산적인 개발</strong><br />핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인 가능합니다.<br /><br/></li><li><strong>모든 플랫폼에서 빠름</strong><br />모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript 로 컴파일합니다.</li></ol><h2 id="why-dart"><a class="markdownIt-Anchor" href="#why-dart"></a> Why Dart</h2><p>Dart 의 컴파일러 기술을 사용하면 다양한 방식으로 코드를 실행할 수 있습니다.</p><ul><li><p><strong>기본 플랫폼(Dart Native)</strong>: 모바일 및 데스크톱 장치를 대상으로 하는 앱의 경우 Dart 에는 JIT(Just-In-Time) 컴파일 기능이 있는 Dart VM 과 기계 코드 생성을 위한 AOT(Ahead-of-Time) 컴파일러가 모두 포함되어 있습니다.</p></li><li><p><strong>웹 플랫폼(Dart Web)</strong>: 웹을 대상으로 하는 앱의 경우 Dart 는 개발 또는 프로덕션 목적으로 컴파일할 수 있습니다. 웹 컴파일러는 Dart 를 JavaScript 로 변환합니다.</p></li></ul><h2 id="또-다른-특징"><a class="markdownIt-Anchor" href="#또-다른-특징"></a> 또 다른 특징</h2><ul><li><strong>null safety</strong> 특성을 가집니다. c 또는 java 에서 null 참조하면 오류가 발생합니다.</li><li>flutter, dart 둘 다 구글에서 개발 한 것입니다. 즉 flutter 의 성능 향상을 위해 dart 를 최적화 할 수 있습니다.</li><li>flutter 가 dart 에 대해 뭔가 필요한 게 있으면, flutter 를 위해 dart 를 수정할 수 있습니다. react-native, django, flask 등 다른 프레임워크들은 사용하는 언어를 수정할 수 없다는 점이 다릅니다.</li></ul><h2 id="main-함수"><a class="markdownIt-Anchor" href="#main-함수"></a> main 함수</h2><p>main 함수는 모든 Dart 프로그램의 Entry point 입니다.<br />main 함수에서 쓴 코드가 호출됩니다. (만약 main 함수가 없다면 실행이 되지 않음)<br />dart 는 자동으로 세미콜론을 붙여주지 않기 때문에 직접 붙여야 합니다. (일부러 세미콜론을 안 쓸 때가 있기 때문입니다.)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flutter"><a class="markdownIt-Anchor" href="#flutter"></a> Flutter</h2><p><strong>Flutter</strong> 프레임워크는 인기 있는 다중 플랫폼 UI 툴킷으로 Dart 플랫폼으로 구동되며 iOS, Android, macOS, Windows, Linux 및 웹에서 실행되는 UI 경험을 빌드하기 위한 도구 및 UI 라이브러리를 제공합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://dart.dev/" target="_blank" rel="noopener">https://dart.dev/</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/12/dart-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] JSDoc Reference 사용 방법</title>
      <link>http://hgko1207.github.io/2023/04/11/typescript-7/</link>
      <guid>http://hgko1207.github.io/2023/04/11/typescript-7/</guid>
      <pubDate>Tue, 11 Apr 2023 05:53:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;JavaScript 파일에서 TypeScript 처럼 코드를 보호받을 수 있도록 하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;ts-check&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ts-check&quot;&gt;&lt;/a&gt; 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>JavaScript 파일에서 TypeScript 처럼 코드를 보호받을 수 있도록 하는 방법에 대해 알아보겠습니다.</p><h2 id="ts-check"><a class="markdownIt-Anchor" href="#ts-check"></a> @ts-check</h2><p>JavaScript 파일에서 오류를 활성화하려면 <code>// @ts-check</code>를 .js 파일의 첫 번째 줄에 추가하여 TypeScript 가 오류를 발생시키도록 합니다. TypeScript 는 여러 오류를 제공할 수 있습니다.</p><p>아래 코드는 TypeScript 와 같이 함수 파라미터에 정의가 되어 있지 않아 오류가 발생합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">🚫 config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exit</span>(<span class="params">🚫 code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> code + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 오류를 무시하고 싶다면 <code>// @ts-ignore</code> 또는 <code>// @ts-expect-error</code>를 추가하여 특정 줄의 오류를 무시할 수 있습니다.</p><h2 id="jsdoc-reference"><a class="markdownIt-Anchor" href="#jsdoc-reference"></a> JSDoc Reference</h2><p>JSDoc 주석을 사용하여 JavaScript 파일에 type 정보를 제공할 수 있습니다. (자바스크립트 파일에서 타입 정보를 제공할 수 있습니다.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes the project</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> <span class="variable">config</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> </span>config.debug</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>config.url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exits the program</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">code</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exit</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> code + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSDoc 주석을 통해 타입을 정의하고 TypeScript 파일에서 다음과 같이 함수를 사용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init(&#123;</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  url: <span class="string">'true'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">exit(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="주의-사항"><a class="markdownIt-Anchor" href="#주의-사항"></a> 주의 사항</h2><ul><li><code>@ts-check</code>를 사용하면 JavaScript 파일 내에서 타입 검사를 허용합니다.</li><li><code>@ts-check</code> 를 사용하지 않고 JSDoc 만 사용하면 TypeScript 파일에서는 JavaScript 의 타입을 검사 하지만, JavaScript 내에서는 단순 주석이나 타입을 명시하는 정도로만 사용할 수 있는 것 같습니다</li></ul><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/11/typescript-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 설치 및 설정 방법</title>
      <link>http://hgko1207.github.io/2023/04/11/typescript-6/</link>
      <guid>http://hgko1207.github.io/2023/04/11/typescript-6/</guid>
      <pubDate>Tue, 11 Apr 2023 02:10:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;NextJS, Create React App(CRA) 를 사용하지 않고 초기 프로젝트에 &lt;strong&gt;TypeScript&lt;/strong&gt; 를 설치하고 설정하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;프로젝트-시작&quot;&gt;&lt;a class=&quot;m
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>NextJS, Create React App(CRA) 를 사용하지 않고 초기 프로젝트에 <strong>TypeScript</strong> 를 설치하고 설정하는 방법에 대해 알아보겠습니다.</p><h2 id="프로젝트-시작"><a class="markdownIt-Anchor" href="#프로젝트-시작"></a> 프로젝트 시작</h2><p>프로젝트 디렉터리를 생성합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir typescripttest</span><br><span class="line">$ <span class="built_in">cd</span> typescripttest</span><br></pre></td></tr></table></figure><p>다음 명령어를 실행하여 <code>package.json</code> 을 초기화합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><h2 id="typescript-설치"><a class="markdownIt-Anchor" href="#typescript-설치"></a> TypeScript 설치</h2><p>다음 명령어를 실행하여 TypeScript 를 설치합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D typescript</span><br></pre></td></tr></table></figure><h2 id="tsconfigjson-설정"><a class="markdownIt-Anchor" href="#tsconfigjson-설정"></a> tsconfig.json 설정</h2><p>TypeScript 설정은 tsconfig.json 파일에서 합니다. 디렉터리에 tsconfig.json 파일이 있으면 해당 디렉터리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일과 컴파일러 옵션을 지정합니다.</p><p><code>tsconfig.json</code> 파일을 생성합니다. 다음과 같이 기본적인 설정을 작성합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>], <span class="comment">// 자바스크립트로 컴파일 하고 싶은 모든 디렉터리</span></span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"build"</span> <span class="comment">// 자바스크립트 파일로 생성될 디렉터리(빌드 디렉터리)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 명령어로도 기본적인 <code>tsconfig.json</code> 파일 생성이 가능합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g typescript</span><br><span class="line">$ tsc --init</span><br></pre></td></tr></table></figure><h3 id="target-기본값-es3"><a class="markdownIt-Anchor" href="#target-기본값-es3"></a> Target (기본값: ES3)</h3><p>최신 브라우저는 모든 ES6 기능을 지원하므로 ES6 는 좋은 선택입니다. 코드가 이전 환경에 배포된 경우 더 낮은 target 을 설정하거나 최신 환경에서 코드 실행이 보장되는 경우 더 높은 target 을 설정하도록 선택할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"build"</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lib라이브러리"><a class="markdownIt-Anchor" href="#lib라이브러리"></a> Lib(라이브러리)</h3><p>타입스크립트에게 어떤 API를 사용하고 어떤 환경에서 코드를 실행하는 지를 지정할 수 있습니다. (target 런타임 환경이 무엇인지를 지정합니다.)</p><p>프로그램이 브라우저에서 실행되면 lib에 “DOM” 유형 정의를 할 수 있습니다.</p><ul><li>DOM: window, document 등</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ex)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"lib"</span>: [<span class="string">"ES6"</span>, <span class="string">"DOM"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strict"><a class="markdownIt-Anchor" href="#strict"></a> strict</h3><p>모든 엄격한 타입 검사 옵션을 활성화합니다. <code>strict</code> 플래그는 프로그램 정확성을 더 강력하게 보장하는 광범위한 타입 검사 동작을 가능하게 합니다.</p><p>tsconfig.json 에서 <code>&quot;strict&quot;: true</code> 를 통해 strict mode 로 해주면, Declaration Files 가 없는 경우에 대해서도 에러를 띄워줍니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content</a></li><li><a href="https://www.typescriptlang.org/tsconfig#target" target="_blank" rel="noopener">https://www.typescriptlang.org/tsconfig#target</a></li><li><a href="https://www.typescriptlang.org/tsconfig#lib" target="_blank" rel="noopener">https://www.typescriptlang.org/tsconfig#lib</a></li><li><a href="https://www.typescriptlang.org/tsconfig#strict" target="_blank" rel="noopener">https://www.typescriptlang.org/tsconfig#strict</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/11/typescript-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 인터페이스(Interface) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/04/06/typescript-5/</link>
      <guid>http://hgko1207.github.io/2023/04/06/typescript-5/</guid>
      <pubDate>Thu, 06 Apr 2023 14:20:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;TypeScript&lt;/strong&gt; 에서 인터페이스(Interface)를 생성하고 사용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;interfaces&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#in
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>TypeScript</strong> 에서 인터페이스(Interface)를 생성하고 사용하는 방법에 대해 알아보겠습니다.</p><h2 id="interfaces"><a class="markdownIt-Anchor" href="#interfaces"></a> Interfaces</h2><p>객체의 모양을 특정해주기 위해 사용합니다. 여기서는 <code>firstName</code> 및 <code>lastName</code> 필드가 있는 객체를 설명하는 인터페이스를 사용합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 인터페이스를 상속 받아 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Player <span class="keyword">extends</span> User &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eden: Player = &#123;</span><br><span class="line">  name: <span class="string">'eden'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>인터페이스 이름이 같도록 3번 각각 만들어도 타입스크립트는 알아서 하나로 합쳐줍니다. Type 과 차이점입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  nickname: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eden: User = &#123;</span><br><span class="line">  name: <span class="string">'eden'</span>,</span><br><span class="line">  nickname: <span class="string">'ko'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="implements"><a class="markdownIt-Anchor" href="#implements"></a> implements</h2><p>implements 을 사용하여 클래스가 특정 인터페이스를 충족하는지 확인할 수 있습니다.<br />클래스를 올바르게 구현하지 못하면 오류가 발생합니다.</p><p>implements 절은 클래스가 인터페이스 유형으로 처리될 수 있는지 확인하는 것입니다. 클래스의 유형이나 메서드는 전혀 변경하지 않습니다.<br />또한 클래스는 여러 인터페이스를 구현할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ex) 클래스 C 는 A, B 를 구현합니다.</span></span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">implements</span> A, B &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Pingable &#123;</span><br><span class="line">  ping(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sonar 클래스는 Pingable 인터페이스를 implement 했기 때문에</span></span><br><span class="line"><span class="comment">// Pingable 가 가진 ping 메서드를 구현해줘야 합니다.</span></span><br><span class="line"><span class="keyword">class</span> Sonar <span class="keyword">implements</span> Pingable &#123;</span><br><span class="line">  ping() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ping!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 개의 인터페이스를 상속받아 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Human &#123;</span><br><span class="line">  health: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Player <span class="keyword">implements</span> User, Human &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> firstName: <span class="built_in">string</span>, <span class="keyword">public</span> lastName: <span class="built_in">string</span>, <span class="keyword">public</span> health: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="type-aliases-과-interfaces-의-차이점"><a class="markdownIt-Anchor" href="#type-aliases-과-interfaces-의-차이점"></a> Type Aliases 과 Interfaces 의 차이점</h2><p>Type Aliases 과 인터페이스는 매우 유사하며 많은 경우 자유롭게 선택할 수 있습니다. 인터페이스의 거의 모든 기능은 type 에서 사용할 수 있으며, 주요 차이점은 type 을 다시 열어 새 속성을 추가할 수 없는 것입니다. 반면 인터페이스는 항상 확장 가능합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/04/06/typescript-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 클래스(Class) 사용 방법</title>
      <link>http://hgko1207.github.io/2023/03/29/typescript-4/</link>
      <guid>http://hgko1207.github.io/2023/03/29/typescript-4/</guid>
      <pubDate>Wed, 29 Mar 2023 05:20:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;TypeScript&lt;/strong&gt; 에서 클래스(Class)를 생성하고 사용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;클래스class&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#클래스class&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>TypeScript</strong> 에서 클래스(Class)를 생성하고 사용하는 방법에 대해 알아보겠습니다.</p><h2 id="클래스class"><a class="markdownIt-Anchor" href="#클래스class"></a> 클래스(Class)</h2><p>가장 기본적인 클래스입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Player &#123;&#125;</span><br></pre></td></tr></table></figure><p>필드를 선언해서 사용 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Player &#123;</span><br><span class="line">  firstname: <span class="built_in">string</span>;</span><br><span class="line">  lastname: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eden = <span class="keyword">new</span> Player();</span><br><span class="line">eden.firstname = <span class="string">'ko'</span>;</span><br><span class="line">eden.lastname = <span class="string">'eden'</span>;</span><br></pre></td></tr></table></figure><p>생성자에 매개변수를 추가해서 선언할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Player &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> firstname: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> lastname: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> nickname: <span class="built_in">string</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eden = <span class="keyword">new</span> Player(<span class="string">"ko"</span>, <span class="string">"eden"</span>, <span class="string">"고수"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line"><span class="comment">// firstname는 private 이기 때문에 접근 불가</span></span><br><span class="line"><span class="comment">// javascript 에서는 아무 문제없이 작동함</span></span><br><span class="line">🚫 eden.firstname;</span><br></pre></td></tr></table></figure><ul><li>public: 모든 클래스에서 접근 가능</li><li>private: 해당 클래스 내에서만 접근 가능 (자식 클래스에서도 접근 불가)</li><li>protected: 해당 클래스와 자식 클래스에서 접근 가능</li></ul><h2 id="추상-클래스abstract-class"><a class="markdownIt-Anchor" href="#추상-클래스abstract-class"></a> 추상 클래스(Abstract Class)</h2><p>TypeScript 와 객체지향 프로그램이 가지고 있는 엄청 훌륭한 것은 추상 클래스(Abstract Class)라고 생각됩니다.</p><p>추상클래스는 다른 클래스가 상속받을 수 있는 클래스입니다. 하지만 이 클래스는 직접 새로운 인스턴스를 만들 수는 없습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> User &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> firstname: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> lastname: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> nickname: <span class="built_in">string</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> getNickname(): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">    getFullName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstname&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line"><span class="comment">// TypeScript 가 추상 클래스의 인스턴스를 만들 수 없다고 경고함</span></span><br><span class="line">🚫 <span class="keyword">const</span> eden = <span class="keyword">new</span> User(<span class="string">"ko"</span>, <span class="string">"eden"</span>, <span class="string">"고수"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Player <span class="keyword">extends</span> User &#123;</span><br><span class="line">  <span class="comment">// 추상 메서드는 추상 클래스를 상속받는 클래스들이 반드시 구현(implement)해야하는 메서드입니다.</span></span><br><span class="line">  getNickname() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.nickname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eden = <span class="keyword">new</span> Player(<span class="string">'ko'</span>, <span class="string">'eden'</span>, <span class="string">'고수'</span>);</span><br><span class="line">eden.getNickname();</span><br><span class="line">eden.getFullName();</span><br></pre></td></tr></table></figure><p>추상 클래스를 사용하기 위해서는 상속을 받아 사용합니다.</p><h2 id="static-members"><a class="markdownIt-Anchor" href="#static-members"></a> Static Members</h2><p>클래스에는 static 멤버가 있을 수 있습니다. 이 멤버는 클래스의 특정 인스턴스와 연결되지 않습니다. 클래스 생성자 객체 자체를 통해 액세스할 수 있습니다. static 멤버는 동일한 public, protected 및 private 과 함께 사용할 수도 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> printX() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MyClass.x);</span><br><span class="line">MyClass.printX();</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/classes.html</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/29/typescript-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] 다형성(Polymorphism)</title>
      <link>http://hgko1207.github.io/2023/03/16/typescript-3/</link>
      <guid>http://hgko1207.github.io/2023/03/16/typescript-3/</guid>
      <pubDate>Thu, 16 Mar 2023 05:59:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;다형성polymorphism&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#다형성polymorphism&quot;&gt;&lt;/a&gt; 다형성(Polymorphism)&lt;/h2&gt;
&lt;p&gt;다형성이란, 여러 타입을 받아들임으로써 여러 형태를 가지
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="다형성polymorphism"><a class="markdownIt-Anchor" href="#다형성polymorphism"></a> 다형성(Polymorphism)</h2><p>다형성이란, 여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미합니다.</p><ul><li><strong>poly:</strong> many, serveral, much, multi 등과 같은 뜻</li><li><strong>morphos:</strong> form, structure 등과 같은 뜻</li><li><strong>polymorphos = poly + morphos:</strong> 여러 다른 구조</li></ul><h2 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SuperPrint = &#123;</span><br><span class="line">  (arr: T[]): T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> superPrint: SuperPrint = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = superPrint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = superPrint([<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line"><span class="keyword">const</span> c = superPrint([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">const</span> d = superPrint([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="literal">true</span>]);</span><br></pre></td></tr></table></figure><h2 id="any-generics-차이점"><a class="markdownIt-Anchor" href="#any-generics-차이점"></a> any, generics 차이점</h2><p><strong>any</strong> 를 사용하는 것은 어떤 타입이든 받을 수 있다는 점에서 <strong>generics</strong> 과 같지만 함수를 반환하는데 있어 <strong>any</strong> 는 받았던 인수들의 타입을 활용하지 못합니다.</p><p>즉, <strong>generics</strong> 은 어떤 타입이든 받을 수 있다는 점에서 <strong>any</strong> 와 같지만 해당 정보를 잃지 않고 타입에 대한 정보를 다른 쪽으로 전달할 수 있다는 점이 다릅니다.</p><h2 id="generics"><a class="markdownIt-Anchor" href="#generics"></a> Generics</h2><p>제네릭은 C# 이나 Java 와 같은 언어에서 재사용 가능한 컴포넌트를 만들기 위해 사용하는 기법입니다. 단일 타입이 아닌 다양한 타입에서 작동할 수 있는 컴포넌트를 생성할 수 있습니다.<br />(구체적인 타입을 지정하지 않고 다양한 인수와 리턴 값에 대한 타입을 처리할 수 있습니다.)<br />타입스크립트에서 제네릭을 통해 인터페이스, 함수 등의 재사용성을 높일 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">Type</span>&gt;(<span class="params">arg: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제네릭 화살표 함수 (tsx기준)</span></span><br><span class="line"><span class="keyword">const</span> identity = &lt;Type <span class="keyword">extends</span> &#123;&#125;&gt;(arg: Type): <span class="function"><span class="params">Type</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'myString'</span>); <span class="comment">// 첫 번째 방법</span></span><br><span class="line"><span class="keyword">let</span> output = identity(<span class="string">'myString'</span>); <span class="comment">// 두 번째 방법</span></span><br></pre></td></tr></table></figure><p>위에서 두 번째 방법은 type argument inference(타입 인수 유추)를 사용합니다. 즉, 컴파일러가 전달하는 인수 유형에 따라 자동으로 Type 값을 설정하기를 원합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/16/typescript-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Function Overloads</title>
      <link>http://hgko1207.github.io/2023/03/16/typescript-2/</link>
      <guid>http://hgko1207.github.io/2023/03/16/typescript-2/</guid>
      <pubDate>Thu, 16 Mar 2023 05:47:52 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;function-overloads&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#function-overloads&quot;&gt;&lt;/a&gt; Function Overloads&lt;/h2&gt;
&lt;p&gt;동일한 이름에 매개 변수와 매개 변수 타입 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="function-overloads"><a class="markdownIt-Anchor" href="#function-overloads"></a> Function Overloads</h2><p>동일한 이름에 매개 변수와 매개 변수 타입 또는 리턴 타입이 다른 여러 버전의 함수를 만드는 것을 말합니다. TypeScript 에서는 오버로드 signatures 을 작성하여 **“다양한 방식으로 호출할 수 있는 함수”**를 지정할 수 있습니다.</p><h2 id="사용-예제"><a class="markdownIt-Anchor" href="#사용-예제"></a> 사용 예제</h2><h3 id="매개변수의-데이터-타입이-다른-경우"><a class="markdownIt-Anchor" href="#매개변수의-데이터-타입이-다른-경우"></a> 매개변수의 데이터 타입이 다른 경우</h3><p>매개변수의 데이터 타입이 다른 경우 예외 처리를 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add = &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add: Add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> b === <span class="string">'string'</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="string">'2'</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="매개변수의-수가-다른-경우"><a class="markdownIt-Anchor" href="#매개변수의-수가-다른-경우"></a> 매개변수의 수가 다른 경우</h3><p>매개변수의 수가 다른 경우 예외 처리를 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add = &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add2: Add = <span class="function">(<span class="params">a, b, c?: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c) <span class="keyword">return</span> a + b + c;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/16/typescript-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[WPF] 문자열(string)의 가로 세로 길이 계산</title>
      <link>http://hgko1207.github.io/2023/03/16/wpf-10/</link>
      <guid>http://hgko1207.github.io/2023/03/16/wpf-10/</guid>
      <pubDate>Thu, 16 Mar 2023 01:53:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;WPF 에서 글꼴 크기(FontSize)와 폰트(FontFamily)를 통해 문자열의 크기를 계산하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FormattedText&lt;/code&gt; 를 사용하여 텍스트의 서식을 지정한 후 크기를 계산할 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>WPF 에서 글꼴 크기(FontSize)와 폰트(FontFamily)를 통해 문자열의 크기를 계산하는 방법에 대해 알아보겠습니다.</p><p><code>FormattedText</code> 를 사용하여 텍스트의 서식을 지정한 후 크기를 계산할 수 있습니다.</p><h2 id="소스코드"><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><p><code>TextBlock</code> 컨트롤을 사용할 경우 다음과 같이 작성하여 문자열의 크기를 구합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 글자 가로 세로 길이 계산</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="textBlock"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Size <span class="title">MeasureString</span>(<span class="params">TextBlock textBlock</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FormattedText formattedText = <span class="keyword">new</span> FormattedText</span><br><span class="line">    (</span><br><span class="line">        textBlock.Text,</span><br><span class="line">        CultureInfo.CurrentUICulture,</span><br><span class="line">        FlowDirection.LeftToRight,</span><br><span class="line">        <span class="keyword">new</span> Typeface</span><br><span class="line">        (</span><br><span class="line">          textBlock.FontFamily,</span><br><span class="line">          textBlock.FontStyle,</span><br><span class="line">          textBlock.FontWeight,</span><br><span class="line">          textBlock.FontStretch</span><br><span class="line">        ),</span><br><span class="line">        textBlock.FontSize,</span><br><span class="line">        textBlock.Foreground,</span><br><span class="line">        VisualTreeHelper.GetDpi(textBlock).PixelsPerDip</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Size(formattedText.Width, formattedText.Height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TextBlock</code> 컨트롤을 사용하지 않고 string 문자열과 글꼴 크기, 폰트를 입력하여 길이를 구할 수 있습니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 글자 가로 세로 길이 계산</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="text"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="fontSize"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="fontFamily"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Size <span class="title">MeasureString</span>(<span class="params"><span class="keyword">string</span> text, <span class="keyword">int</span> fontSize, FontFamily fontFamily</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FormattedText formattedText = <span class="keyword">new</span> FormattedText</span><br><span class="line">    (</span><br><span class="line">        text,</span><br><span class="line">        CultureInfo.CurrentUICulture,</span><br><span class="line">        FlowDirection.LeftToRight,</span><br><span class="line">        <span class="keyword">new</span> Typeface</span><br><span class="line">        (</span><br><span class="line">            fontFamily,</span><br><span class="line">            FontStyles.Normal,</span><br><span class="line">            FontWeights.Bold,</span><br><span class="line">            FontStretches.Normal</span><br><span class="line">        ),</span><br><span class="line">        fontSize,</span><br><span class="line">        Brushes.Black,</span><br><span class="line">        VisualTreeHelper.GetDpi(<span class="keyword">this</span>).PixelsPerDip</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Size(formattedText.Width, formattedText.Height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용-방법"><a class="markdownIt-Anchor" href="#사용-방법"></a> 사용 방법</h2><ol><li><code>TextBlock</code> 컨트롤을 사용 할 경우 사용 방법입니다.</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TextBlock textBlock = <span class="keyword">new</span> TextBlock</span><br><span class="line">&#123;</span><br><span class="line">  Text = <span class="string">"test"</span>,</span><br><span class="line">  FontFamily = <span class="keyword">new</span> FontFamily(<span class="string">"Arial"</span>),</span><br><span class="line">  FontSize = <span class="number">16</span>,</span><br><span class="line">  Foreground = Brushes.Red</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Size textSize = MeasureString(textBlock);</span><br><span class="line"></span><br><span class="line">Console.Write(<span class="string">"Width =&gt; "</span> + textSize.Width);</span><br><span class="line">Console.Write(<span class="string">"Height =&gt; "</span> + textSize.Height);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>TextBlock</code> 컨트롤을 사용하지 않을 경우 사용 방법입니다.</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> text = <span class="string">"hello eden"</span>;</span><br><span class="line"><span class="keyword">int</span> fontSize = <span class="number">32</span>;</span><br><span class="line">FontFamily fontFamily = <span class="keyword">new</span> FontFamily(<span class="string">"Arial"</span>);</span><br><span class="line"></span><br><span class="line">Size textSize = MeasureString(text, fontSize, fontFamily);</span><br><span class="line"></span><br><span class="line">Console.Write(<span class="string">"Width =&gt; "</span> + textSize.Width);</span><br><span class="line">Console.Write(<span class="string">"Height =&gt; "</span> + textSize.Height);</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://learn.microsoft.com/ko-kr/dotnet/api/system.windows.media.formattedtext?view=netframework-4.7.2" target="_blank" rel="noopener">https://learn.microsoft.com/ko-kr/dotnet/api/system.windows.media.formattedtext?view=netframework-4.7.2</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/16/wpf-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[TypeScript] Types</title>
      <link>http://hgko1207.github.io/2023/03/13/typescript-1/</link>
      <guid>http://hgko1207.github.io/2023/03/13/typescript-1/</guid>
      <pubDate>Mon, 13 Mar 2023 04:56:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;타입스크립트란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#타입스크립트란&quot;&gt;&lt;/a&gt; 타입스크립트란?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TypeScript&lt;/strong&gt; 는 JavaScript 에 추가적인 구문을 추가하여
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="타입스크립트란"><a class="markdownIt-Anchor" href="#타입스크립트란"></a> 타입스크립트란?</h2><p><strong>TypeScript</strong> 는 JavaScript 에 추가적인 구문을 추가하여 editor 와의 단단한 통합을 지원합니다. editor 에서 초기에 오류를 잡을 수 있습니다.</p><p><strong>TypeScript</strong> 코드는 JavaScript 가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript 로 변환될 수 있습니다.</p><p><strong>TypeScript</strong> 는 JavaScript 를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다.</p><h2 id="types기본"><a class="markdownIt-Anchor" href="#types기본"></a> Types(기본)</h2><ul><li>✅ 배열: 자료형[]</li><li>✅ 숫자: number</li><li>✅ 문자열: string</li><li>✅ 논리: boolean</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Player = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  weapons: <span class="built_in">string</span>[];</span><br><span class="line">  attack: bool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="optional-사용"><a class="markdownIt-Anchor" href="#optional-사용"></a> optional 사용</h2><p>?를 :앞에 붙이면 optional 사용 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> player: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'eden'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>player.age</code> 를 optional 로 설정할 경우 Typescript 는 <code>player.age</code> 가 undefined 일수도 있다고 오류를 알려줍니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ player.age 가 undefined 일 가능성 알림</span></span><br><span class="line"><span class="keyword">if</span> (player.age &lt; <span class="number">10</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>player.age</code> 가 존재하는지 확인을 거쳐야 오류 알림이 사라집니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⭕ player.age 가 undefined 일 가능성 체크</span></span><br><span class="line"><span class="keyword">if</span> (player.age &amp;&amp; player.age &lt; <span class="number">10</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alias별칭-타입"><a class="markdownIt-Anchor" href="#alias별칭-타입"></a> Alias(별칭) 타입</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Player = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player: Player = &#123;</span><br><span class="line">  name: <span class="string">'eden'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="readonly-사용"><a class="markdownIt-Anchor" href="#readonly-사용"></a> readonly 사용</h2><p>변수 또는 별칭 앞에 <code>readonly</code> 를 붙이면 readonly 사용 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Player = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>readonly</code> 가 있으면 최초 선언 후 수정 불가합니다. 불변성(immutability)이 부여됩니다. 하지만 javascript 에서는 그냥 배열로 인식하여 수정이 됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> playerMaker = (name: <span class="built_in">string</span>): <span class="function"><span class="params">Player</span> =&gt;</span> (&#123; name &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> player = playerMaker(<span class="string">'eden'</span>);</span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line">🚫 player.name = <span class="string">"khk"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers: readonly <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line">🚫 numbers.push(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="tuple-타입"><a class="markdownIt-Anchor" href="#tuple-타입"></a> Tuple 타입</h2><p>정해진 개수와 순서에 따라 배열 선언이 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> player: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="string">'eden'</span>, <span class="number">1</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line">🚫 player[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 바꿀 수 없습니다. string으로 지정됨</span></span><br></pre></td></tr></table></figure><p>readonly 도 사용 가능 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> player: readonly [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="string">'eden'</span>, <span class="number">1</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><h2 id="any-undefined-null-타입"><a class="markdownIt-Anchor" href="#any-undefined-null-타입"></a> any / undefined / null 타입</h2><ul><li>✅ any: 어떠한 타입도 허용</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">any</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>✅ undefined: undefined 값만 가질 수 있음</li><li>✅ null: null 값만 가질 수 있음</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nullable: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> undefinedable: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line"><span class="comment">// 'undefined' 형식은 'null' 형식에 할당할 수 없습니다.</span></span><br><span class="line">🚫 nullable = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="void-타입"><a class="markdownIt-Anchor" href="#void-타입"></a> void 타입</h2><p><strong>void</strong> 는 값을 반환하지 않는 함수의 반환 값을 나타냅니다. 함수에 return 문이 없거나 해당 return 문에서 명시적 값을 반환하지 않을 때 항상 유추되는 타입입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The inferred return type is void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = test()</span><br><span class="line"><span class="comment">// [오류]</span></span><br><span class="line">🚫 a.toUpperCase()</span><br></pre></td></tr></table></figure><h2 id="unknown-타입"><a class="markdownIt-Anchor" href="#unknown-타입"></a> unknown 타입</h2><p><strong>unknown</strong> 타입은 모든 값을 나타냅니다. 이것은 any 타입과 비슷하지만 any 보다 unknown 이 더 안전합니다. 이유는 unknown 값으로 작업을 수행하는 것은 합법적이지 않기 때문입니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  a.b(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a: unknown</span>) </span>&#123;</span><br><span class="line">  🚫 a.b(); <span class="comment">// 에러: Object is of type 'unknown'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="never-타입"><a class="markdownIt-Anchor" href="#never-타입"></a> never 타입</h2><p><strong>never</strong> 타입은 모든 타입에 할당 가능한 하위 타입이나, never 타입에는 본인 외에 다른 타입이 할당될 수는 없습니다. never 타입은 절대 발생할 수 없는 타입을 나타냅니다.</p><p>가장 흔한 예제로는 에러를 발생시킬 때 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용법에 대해 좀 더 찾아봐야겠지만 그 외에도 특정 타입 값을 할당받지 않도록 하거나, 매개변수의 제한을 건다거나 뭐 그런 곳들에 사용된다는데, 사실 많이 사용하는 타입은 아니라고 봐도 무방합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.typescriptlang.org/play" target="_blank" rel="noopener">타입스크립트 코드 테스트</a></li><li><a href="https://typescript-kr.github.io/pages/basic-types.html" target="_blank" rel="noopener">타입스크립트 핸드북</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/13/typescript-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[WPF] Grid를 Bitmap 이미지로 변환 후 저장하기</title>
      <link>http://hgko1207.github.io/2023/03/13/wpf-9/</link>
      <guid>http://hgko1207.github.io/2023/03/13/wpf-9/</guid>
      <pubDate>Mon, 13 Mar 2023 01:49:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;WPF&lt;/strong&gt; 의 Grid 를 사용하여 사용자의 입력을 받는 문서를 작성하거나 여러 이미지를 가시화 할 시, 이를 이미지로 저장하는 기능이 필요할 경우가 있습니다.&lt;/p&gt;
&lt;p&gt;따라서 Grid 컨트롤을 하위 요소들과 함께 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>WPF</strong> 의 Grid 를 사용하여 사용자의 입력을 받는 문서를 작성하거나 여러 이미지를 가시화 할 시, 이를 이미지로 저장하는 기능이 필요할 경우가 있습니다.</p><p>따라서 Grid 컨트롤을 하위 요소들과 함께 Bitmap 으로 변환하고 이미지를 저장하는 방법에 대해 알아보겠습니다.</p><h2 id="소스코드"><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><p>먼저 Grid 컨트롤 내용들을 Bitmap 으로 변환합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Grid를 Bitmap이미지로 변환</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="element"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RenderTargetBitmap <span class="title">GetBitmapFromControl</span>(<span class="params">FrameworkElement element</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Size size = <span class="keyword">new</span> Size(element.ActualWidth, element.ActualHeight);</span><br><span class="line">    <span class="keyword">if</span> (size.IsEmpty)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    DrawingVisual drawingVisual = <span class="keyword">new</span> DrawingVisual();</span><br><span class="line">    <span class="keyword">using</span> (DrawingContext context = drawingVisual.RenderOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        context.DrawRectangle(<span class="keyword">new</span> VisualBrush(element), <span class="literal">null</span>, <span class="keyword">new</span> Rect(<span class="keyword">new</span> Point(), size));</span><br><span class="line">        context.Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RenderTargetBitmap result = <span class="keyword">new</span> RenderTargetBitmap((<span class="keyword">int</span>)size.Width, (<span class="keyword">int</span>)size.Height, <span class="number">96</span>, <span class="number">96</span>, PixelFormats.Pbgra32);</span><br><span class="line">    result.Render(drawingVisual);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변환된 Bitmap 을 PNG 또는 TIF 이미지 파일로 저장하는 코드입니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Bitmap을 이미지로 저장</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="bitmap"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span>파일 경로<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveImage</span>(<span class="params">RenderTargetBitmap bitmap, <span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> ext = System.IO.Path.GetExtension(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (FileStream stream = <span class="keyword">new</span> FileStream(filePath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ext == <span class="string">".png"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PngBitmapEncoder encoder = <span class="keyword">new</span> PngBitmapEncoder();</span><br><span class="line">            encoder.Frames.Add(BitmapFrame.Create(bitmap));</span><br><span class="line">            encoder.Save(stream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ext == <span class="string">".tif"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TiffBitmapEncoder encoder = <span class="keyword">new</span> TiffBitmapEncoder();</span><br><span class="line">            encoder.Frames.Add(BitmapFrame.Create(bitmap));</span><br><span class="line">            encoder.Save(stream);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stream.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용-방법"><a class="markdownIt-Anchor" href="#사용-방법"></a> 사용 방법</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">"TestProject.MainWindow"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Width</span>=<span class="string">"800"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Height</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Title</span>=<span class="string">"이미지 저장하기"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Name</span>=<span class="string">"grid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Canvas</span>&gt;</span></span><br><span class="line">          ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">          ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>GetBitmapFromControl</code> 함수를 사용하여 이미지로 저장하려는 Grid 를 Bitmap 으로 변환합니다. 그리고 <code>SaveImage</code> 함수의 파라미터에 bitmap, 파일경로를 넣어 이미지를 저장합니다.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 이미지 저장</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Capture</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RenderTargetBitmap bitmap = GetBitmapFromControl(<span class="keyword">this</span>.grid);</span><br><span class="line">    <span class="keyword">string</span> filePath = <span class="string">"d:\\test.png"</span>;</span><br><span class="line">    SaveImage(bitmap, filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Grid 컨트롤 뿐만 아니라 FrameworkElement 을 상속받는 모든 컨트롤들을 위의 함수를 사용하여 이미지를 저장할 수 있습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/13/wpf-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Angular] FormGroup 관련 에러</title>
      <link>http://hgko1207.github.io/2023/03/08/angular-9/</link>
      <guid>http://hgko1207.github.io/2023/03/08/angular-9/</guid>
      <pubDate>Wed, 08 Mar 2023 14:12:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Angular&lt;/strong&gt; 에서 FormGroup 사용 시 다음과 같이 에러가 발생할 경우 해결 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;error&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#er
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Angular</strong> 에서 FormGroup 사용 시 다음과 같이 에러가 발생할 경우 해결 방법에 대해 알아보겠습니다.</p><h2 id="error"><a class="markdownIt-Anchor" href="#error"></a> Error</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ERROR Error: NG01350: ngModel cannot be used to register form controls with a parent formGroup directive.  Try using</span><br><span class="line">    formGroup's partner directive "formControlName" instead.  Example:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div [formGroup]="myGroup"&gt;</span><br><span class="line">    &lt;input formControlName="firstName"&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  In your class:</span><br><span class="line"></span><br><span class="line">  this.myGroup = new FormGroup(&#123;</span><br><span class="line">      firstName: new FormControl()</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div [formGroup]="myGroup"&gt;</span><br><span class="line">      &lt;input formControlName="firstName"&gt;</span><br><span class="line">      &lt;input [(ngModel)]="showMoreControls" [ngModelOptions]="&#123;standalone: true&#125;"&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="해결-방법"><a class="markdownIt-Anchor" href="#해결-방법"></a> 해결 방법</h2><p>에러 메시지 내용은 <code>formGroup</code> 을 사용하려면 <code>formControlName</code> 을 사용하거나 <code>[(ngModel)]</code> 사용 시 <code>[ngModelOptions]=&quot;{standalone: true}</code> 를 추가하라고 합니다.</p><p>다음과 같이 formGroup 속성이 있는 태그의 자식 중에 ngModel 속성을 사용하는 모든 태그에 <code>formControlName</code> 또는 <code>[ngModelOptions]=&quot;{standalone: true}</code> 이 있어야 에러를 해결할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.myForm = <span class="keyword">new</span> FormGroup(&#123;</span><br><span class="line">  id: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">  name: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">  title: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"myForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"myForm.value.title"</span> [<span class="attr">ngModelOptions</span>]=<span class="string">"&#123;standalone: true&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fom</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그리고 추가적으로 Typescript 에서 <code>FormBuilder</code> 를 통해 Group 을 생성할 때 formControlName 에 있는 값들을 전부 넣어줘야 됩니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/03/08/angular-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] Dynamic Routes 사용 방법</title>
      <link>http://hgko1207.github.io/2023/02/23/nextjs-6/</link>
      <guid>http://hgko1207.github.io/2023/02/23/nextjs-6/</guid>
      <pubDate>Thu, 23 Feb 2023 07:28:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 에서 &lt;strong&gt;Dynamic Routes&lt;/strong&gt; 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;dynamic-routes&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 에서 <strong>Dynamic Routes</strong> 사용 방법에 대해 알아보겠습니다.</p><h2 id="dynamic-routes"><a class="markdownIt-Anchor" href="#dynamic-routes"></a> Dynamic Routes</h2><p>Next.js 에서는 page 에 대괄호([param])를 추가하여 <strong>Dynamic Route</strong> 를 생성할 수 있습니다.</p><p>pages/movies 경로에 [id].js 파일을 생성하면 <code>/movies/1</code>, <code>/movies/abc</code> 등과 같은 경로로 접속할 수 있습니다.</p><p>다음 예제처럼 <code>useRouter()</code>의 <code>query</code> 를 통해 /movies 다음의 하위 경로를 확인할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/movies/[id].js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Detail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = router.query;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'detail'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성한 경로로 이동을 원한다면 다음과 같이 <code>next/link</code>를 사용하여 작성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;Link href=<span class="string">"/movies/abc"</span>&gt;Go to movies/movies/[id].js&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;Link href=<span class="string">"/movies/abc?foo=bar"</span>&gt;Also goes to movies/post/[id].js&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><h2 id="catch-all-routes"><a class="markdownIt-Anchor" href="#catch-all-routes"></a> Catch all routes</h2><p>대괄호 안에 세 개의 점(…)을 추가하여 모든 경로를 포착하도록 Dynamic Routes를 확장할 수 있습니다.</p><p><strong>pages/movies/[…id].js</strong> 는 <code>/movies/1</code> 와 일치하지만 <code>/movies/1/2</code>, <code>/movies/1/ab/cd</code> 등과도 일치합니다.</p><p>일치하는 매개변수는 페이지에 쿼리 매개변수로 전송되며 항상 배열이므로 <code>/movies/a</code> 또는 <code>/movies/a/b</code> 경로일 경우 다음과 같이 조회가 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /movies/a</span></span><br><span class="line">&#123; <span class="string">"id"</span>: [<span class="string">"a"</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /movies/a/b</span></span><br><span class="line">&#123; <span class="string">"id"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>] &#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/routing/dynamic-routes" target="_blank" rel="noopener">https://nextjs.org/docs/routing/dynamic-routes</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/23/nextjs-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>엘라스틱 스택 개발부터 운영까지</title>
      <link>http://hgko1207.github.io/2023/02/22/book-3/</link>
      <guid>http://hgko1207.github.io/2023/02/22/book-3/</guid>
      <pubDate>Wed, 22 Feb 2023 01:12:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;책-정보&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#책-정보&quot;&gt;&lt;/a&gt; 책 정보&lt;/h3&gt;
&lt;img width=&quot;100%&quot; src=&quot;/images/book/book3.png&quot; alt=&quot;&quot; title=&quot;엘라스틱 스택 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="책-정보"><a class="markdownIt-Anchor" href="#책-정보"></a> 책 정보</h3><img width="100%" src="/images/book/book3.png" alt="" title="엘라스틱 스택 개발부터 운영까지"><h3 id="책-소개"><a class="markdownIt-Anchor" href="#책-소개"></a> 책 소개</h3><p>데이터를 처리하는 데 서로 잘 맞지도 않는 오픈소스 기술들을 굳이 동원해야 할까?<br />제각각인 오픈소스들을 통합하고 운영하느라 지친<br />개발자와 운영자들을 위한 솔루션! 이제 엘라스틱 스택 기술 하나면 OK!</p><p>어느덧 엘라스틱 스택은 검색 엔진을 넘어서 데이터 처리 시스템의 최강자로 자리 잡았다. 이 책에서는 빠르게 변화하는 세상에서 엘라스틱 스택을 지렛대로 삼아 기업의 생존 능력을 극대화하는 방법을 체계적으로 정리한다.</p><p>엔터프라이즈 빅데이터 파이프라인을 만들어 기업의 데이터를 처리하고 싶다면? 기업 내에 검색 엔진을 구축해서 빠르게 자료를 검색하고 싶다면? 방대한 데이터를 잘 가공해서 저장한 후에 멋진 시각화로 인사이트를 얻고 싶다면? 여러 서버에서 데이터들을 가져와 하나로 통합한 다음에 추이를 보거나 통계를 내고 싶다면? 바로 이럴 때 엘라스틱 스택이 정답이다. 실습을 위한 물리적인 컴퓨터나 가상 머신만 준비한다면 나머지는 모두 이 책이 책임져줄 것이다. 이 책에서는 엘라스틱 스택을 사용해 데이터 중심 애플리케이션을 설계하고, 개발하며, 운영하는 과정에서 꼭 알아야 할 필수 지식을 구체적인 사례와 함께 설명한다.</p><h3 id="리뷰"><a class="markdownIt-Anchor" href="#리뷰"></a> 리뷰</h3><p>데이터 검색과 분석을 위해서 엘라스틱 서치를 공부하려고 찾던 중 엘라스틱 스택을 알게되었고 궁금함을 못 참고 바로 구입하게 되었습니다. 엘라스틱 스택 개념과 구성요소(엘라스틱 서치, 로그스태시, 비트, 키바나 등)들이 잘 정리되어 있어 이해가 쉬웠고 참고가 많이 되었습니다. 엘라스틱 스택의 구성요소를 통해 데이터 수집부터 변환, 분석, 검색, 시각화까지 하는 내용들이 구성되어 있어 응용 학습에 많은 도움이 될 것 같습니다.</p>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/22/book-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] Redirect and Rewrite</title>
      <link>http://hgko1207.github.io/2023/02/21/nextjs-5/</link>
      <guid>http://hgko1207.github.io/2023/02/21/nextjs-5/</guid>
      <pubDate>Tue, 21 Feb 2023 02:25:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 에서 &lt;strong&gt;Redirect&lt;/strong&gt; 와 &lt;strong&gt;Rewrite&lt;/strong&gt; 설정 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;Redirect 와 Rewrite 설정은 next.co
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 에서 <strong>Redirect</strong> 와 <strong>Rewrite</strong> 설정 방법에 대해 알아보겠습니다.</p><p>Redirect 와 Rewrite 설정은 next.config.js 파일에서 설정하게 됩니다.</p><h2 id="nextconfigjs"><a class="markdownIt-Anchor" href="#nextconfigjs"></a> next.config.js</h2><p>Next.js 에서 커스텀 설정을 하기 위해서는 프로젝트 디렉터리의 루트에 next.config.js 또는 next.config.mjs 파일을 만들 수 있습니다. <strong>next.config.js</strong> 는 JSON 파일이 아닌 일반 Node.js 모듈입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;import('next').NextConfig&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">const</span> nextConfig = &#123;</span><br><span class="line">  reactStrictMode: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = nextConfig;</span><br></pre></td></tr></table></figure><p>Next.js 서버 및 빌드 단계에서 사용되며 브라우저 빌드에는 포함되지 않습니다.</p><h2 id="redirects-url변경됨"><a class="markdownIt-Anchor" href="#redirects-url변경됨"></a> Redirects (URL변경됨)</h2><p><strong>Redirect</strong> 을 사용하면 들어오는 request 경로를 다른 destination 경로로 Redirect 할 수 있습니다. Redirect 을 사용하려면 next.config.js 에서 <code>redirects</code> 키를 설정합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextConfig = &#123;</span><br><span class="line">  reactStrictMode: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">async</span> redirects() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        source: <span class="string">'/contact'</span>,</span><br><span class="line">        destination: <span class="string">'/form'</span>,</span><br><span class="line">        permanent: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = nextConfig;</span><br></pre></td></tr></table></figure><p><code>redirects</code> 은 source, destination 및 permanent 속성이 있는 객체를 포함하는 배열을 반환하는 비동기 함수입니다.</p><ul><li><strong>source:</strong> 들어오는 request 경로 (request 경로)</li><li><strong>destination:</strong> 라우팅하려는 경로 (redirect할 경로)</li><li><strong>permanent:</strong> <code>true</code> 인 경우 클라이언트와 search 엔진에 redirect 를 영구적으로 cache 하도록 지시하는 308 status code 를 사용하고, <code>false</code> 인 경우 일시적이고 cache 되지 않은 307 status code 를 사용합니다.</li></ul><p>request 경로에 요청되는 모든 쿼리 값도 destination 으로 전달됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextConfig = &#123;</span><br><span class="line">  reactStrictMode: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">async</span> redirects() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        source: <span class="string">'/old-blog/:path*'</span>,</span><br><span class="line">        destination: <span class="string">'/blog/:path*'</span>,</span><br><span class="line">        permanent: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = nextConfig;</span><br></pre></td></tr></table></figure><p>예를 들어 <code>/old-blog/post-1?hello=world</code> 요청이 들어오면 <code>/blog/post-1?hello=world</code> 경로로 Redirect 됩니다.</p><h2 id="rewrites-url변경되지-않음"><a class="markdownIt-Anchor" href="#rewrites-url변경되지-않음"></a> Rewrites (URL변경되지 않음)</h2><p><strong>Rewrites</strong> 를 사용하면 들어오는 request 경로를 다른 destination 경로에 매핑할 수 있습니다.</p><p>Rewrites 은 URL 프록시 역할을 하고 destination 경로를 mask 하여 사용자가 사이트에서 위치를 변경하지 않은 것처럼 보이게 합니다. 반대로 redirects 은 새 페이지로 reroute 되고 URL 변경 사항을 표시합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> API_KEY = process.env.API_KEY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextConfig = &#123;</span><br><span class="line">  reactStrictMode: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">async</span> rewrites() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        source: <span class="string">'/api/movies'</span>,</span><br><span class="line">        destination: <span class="string">`https://api.themoviedb.org/3/movie/popular?api_key=<span class="subst">$&#123;API_KEY&#125;</span>`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = nextConfig;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용</span></span><br><span class="line"><span class="keyword">const</span> &#123; results &#125; = <span class="keyword">await</span> (<span class="keyword">await</span> fetch(<span class="string">`/api/movies`</span>)).json();</span><br></pre></td></tr></table></figure><p>API 를 통해 데이터를 조회할 때 API Key 가 필요한 경우가 있습니다. 그럴 경우 API Key 가 노출되어 위험할 수 있습니다. 위의 내용처럼 Rewrites 를 사용하여 API 주소로 매핑을 하여 노출되지 않도록 해결하였습니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/api-reference/next.config.js/introduction" target="_blank" rel="noopener">https://nextjs.org/docs/api-reference/next.config.js/introduction</a></li><li><a href="https://nextjs.org/docs/api-reference/next.config.js/redirects" target="_blank" rel="noopener">https://nextjs.org/docs/api-reference/next.config.js/redirects</a></li><li><a href="https://nextjs.org/docs/api-reference/next.config.js/rewrites" target="_blank" rel="noopener">https://nextjs.org/docs/api-reference/next.config.js/rewrites</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/21/nextjs-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] Head 사용 방법</title>
      <link>http://hgko1207.github.io/2023/02/07/nextjs-4/</link>
      <guid>http://hgko1207.github.io/2023/02/07/nextjs-4/</guid>
      <pubDate>Tue, 07 Feb 2023 07:19:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 에서 &lt;strong&gt;Head&lt;/strong&gt; 사용 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;title-설정&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#title-설정&quot;&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 에서 <strong>Head</strong> 사용 방법에 대해 알아보겠습니다.</p><h2 id="title-설정"><a class="markdownIt-Anchor" href="#title-설정"></a> Title 설정</h2><p>Next.js 에는 페이지 헤더의 제목을 변경하고 meta 를 추가할 수 있는 내장 컴포넌트를 가지고 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">'next/head'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;Home | Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Head&gt;</span><br><span class="line">      &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="태그-중복-방지"><a class="markdownIt-Anchor" href="#태그-중복-방지"></a> 태그 중복 방지</h2><p><code>head</code> 에 태그가 중복되는 것을 방지하려면 다음 예제와 같이 태그가 한 번만 렌더링되도록 하는 key 속성을 사용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">'next/head'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;Home | Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">        &lt;meta property="og:title" content="My page title" key="title" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Head&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Head&gt;</span></span><br><span class="line"><span class="regexp">        &lt;meta property="og:title" content="My new title" key="title" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Head&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이 경우 두 번째 <code>meta property=&quot;og:title&quot;</code> 만 렌더링됩니다. 중복 키 속성이 있는 meta 태그는 자동으로 처리됩니다.</p><p>key 를 지정해주지 않으면 <code>meta property=&quot;og:title&quot;</code> 가 중복해서 2번 랜더링됩니다. Title 은 지정하지 않아도 2번 랜더링 되지 않습니다.</p><h2 id="공통-컴포넌트"><a class="markdownIt-Anchor" href="#공통-컴포넌트"></a> 공통 컴포넌트</h2><p>공통으로 사용할 컴포넌트 파일(예: Seo.js)을 생성합니다. title prop 을 받아서 화면마다 제목을 설정할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">'next/head'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Seo</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Head&gt;</span><br><span class="line">      &lt;title&gt;&#123;<span class="string">`<span class="subst">$&#123;title&#125;</span> | Title`</span>&#125;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Head&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Seo <span class="keyword">from</span> <span class="string">'@/components/Seo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Seo title=<span class="string">"Home"</span> /&gt;</span><br><span class="line">      &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/api-reference/next/head" target="_blank" rel="noopener">https://nextjs.org/docs/api-reference/next/head</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/07/nextjs-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] Styles 사용 방법</title>
      <link>http://hgko1207.github.io/2023/02/06/nextjs-3/</link>
      <guid>http://hgko1207.github.io/2023/02/06/nextjs-3/</guid>
      <pubDate>Mon, 06 Feb 2023 06:22:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 에서 스타일 적용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;1-css-in-js&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-css-in-js&quot;&gt;&lt;/a&gt; 1. CS
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 에서 스타일 적용하는 방법에 대해 알아보겠습니다.</p><h2 id="1-css-in-js"><a class="markdownIt-Anchor" href="#1-css-in-js"></a> 1. CSS-in-JS</h2><p>가장 간단한 방법은 인라인 스타일입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;&#125;&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-css-modules"><a class="markdownIt-Anchor" href="#2-css-modules"></a> 2. CSS Modules</h2><p>Next.js는 [name].module.css 파일 명명 규칙을 사용하여 CSS Module 을 지원합니다.</p><p><code>Common.module.css</code>파일을 생성하고 스타일을 다음과 같이 작성합니다. 중요한 것은 .module.css 패턴을 사용하는 것입니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성된 module을 import 해서 사용합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Common.module.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav className=&#123;styles.nav&#125;&gt;&lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>여러 개의 스타일을 적용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Common.module.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav className=&#123;<span class="string">`<span class="subst">$&#123;styles.nav&#125;</span> <span class="subst">$&#123;styles.text&#125;</span>`</span>&#125;&gt;&lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>또는 <code>join()</code> 함수를 사용해 적용합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Common.module.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav className=&#123;[styles.nav, styles.text].join(<span class="string">' '</span>)&#125;&gt;&lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-styled-jsx"><a class="markdownIt-Anchor" href="#3-styled-jsx"></a> 3. Styled JSX</h2><p>격리된 범위 CSS 에 대한 지원을 제공하기 위해 <strong>styled-jsx</strong> 를 번들로 제공합니다.</p><p>styled-jsx 를 사용하는 컴포넌트는 다음과 같습니다. style 에 <code>jsx</code> prop 을 넣고 중괄호({})와 백틱(`)을 사용하여 작성합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">  CSS 스타일..</span></span><br><span class="line"><span class="string">`</span>&#125;&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav&gt;&lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">      &lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">        nav &#123;</span></span><br><span class="line"><span class="string">          background-color: red;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        h1 &#123;</span></span><br><span class="line"><span class="string">          color: blud;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      `</span>&#125;&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Global Styles 설정하는 방법은 <code>global</code> Prop 을 추가하면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx global&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    background: black;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>&#125;&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vscode-익스텐션"><a class="markdownIt-Anchor" href="#vscode-익스텐션"></a> VSCode 익스텐션</h2><p>Styled JSX 사용 시 추천 VSCode 익스텐션입니다.</p><ul><li>styled-jsx : 하이라이팅, 코드 가독성에 도움이 됨</li><li>styled-jsx Language Server : 자동완성</li></ul><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js" target="_blank" rel="noopener">https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js</a></li><li><a href="https://github.com/vercel/styled-jsx" target="_blank" rel="noopener">https://github.com/vercel/styled-jsx</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/06/nextjs-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] Routing 사용 방법</title>
      <link>http://hgko1207.github.io/2023/02/03/nextjs-2/</link>
      <guid>http://hgko1207.github.io/2023/02/03/nextjs-2/</guid>
      <pubDate>Fri, 03 Feb 2023 07:36:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 에서 &lt;strong&gt;Rouing&lt;/strong&gt; 하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;a-사용&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#a-사용&quot;&gt;&lt;/a&gt; &lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 에서 <strong>Rouing</strong> 하는 방법에 대해 알아보겠습니다.</p><h2 id="a-사용"><a class="markdownIt-Anchor" href="#a-사용"></a> <code>&lt;a&gt;</code> 사용</h2><p><code>&lt;a&gt;</code> 태그를 사용해서 페이지 이동을 할 수 있습니다. 하지만 페이지 이동 시 전체 페이지 새고로침이 되는 문제가 발생했습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">NavBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;a href=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;a href="/</span>about<span class="string">"&gt;About Us&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/nav&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="link-사용"><a class="markdownIt-Anchor" href="#link-사용"></a> Link 사용</h2><p>single-page app 환경의 페이지 전환을 하려면 <code>Link</code> 컴포넌트를 사용해야 합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">NavBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;Link href=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link href="/</span>about<span class="string">"&gt;About Us&lt;/Link&gt;</span></span><br><span class="line"><span class="string">    &lt;/nav&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="userouter"><a class="markdownIt-Anchor" href="#userouter"></a> useRouter()</h2><p>컴포넌트에서 router 객체 내부에 접근하려면 <code>userRouter()</code> hook 을 사용할 수 있습니다.<br />useRouter 는 React Hook 입니다. 즉, 클래스와 함께 사용할 수 없습니다. withRouter 를 사용하거나 클래스를 함수 컴포넌트로 래핑할 수 있습니다.</p><p>다음 내용은 <code>useRouter()</code> hook 을 사용해서 메뉴의 색상을 변경하는 예제입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">NavBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;Link href=<span class="string">"/"</span>&gt;</span><br><span class="line">        &lt;span style=&#123;&#123; <span class="attr">color</span>: router.pathname === <span class="string">'/'</span> ? <span class="string">'red'</span> : <span class="string">'blue'</span> &#125;&#125;&gt;Home&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Link&gt;</span><br><span class="line">      &lt;Link href=<span class="string">"/about"</span>&gt;</span><br><span class="line">        &lt;span style=&#123;&#123; <span class="attr">color</span>: router.pathname === <span class="string">'/about'</span> ? <span class="string">'red'</span> : <span class="string">'blue'</span> &#125;&#125;&gt;About Us&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Link&gt;</span><br><span class="line">    &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/messages/no-html-link-for-pages" target="_blank" rel="noopener">https://nextjs.org/docs/messages/no-html-link-for-pages</a></li><li><a href="https://nextjs.org/docs/api-reference/next/router#userouter" target="_blank" rel="noopener">https://nextjs.org/docs/api-reference/next/router#userouter</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/03/nextjs-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>라이브러리와 프레임워크 차이점</title>
      <link>http://hgko1207.github.io/2023/02/03/info-1/</link>
      <guid>http://hgko1207.github.io/2023/02/03/info-1/</guid>
      <pubDate>Fri, 03 Feb 2023 06:50:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;라이브러리와 프레임워크의 주요 차이점에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;라이브러리&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#라이브러리&quot;&gt;&lt;/a&gt; 라이브러리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 파일 이름이나 구조 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>라이브러리와 프레임워크의 주요 차이점에 대해 알아보겠습니다.</p><h2 id="라이브러리"><a class="markdownIt-Anchor" href="#라이브러리"></a> 라이브러리</h2><ul><li>사용자가 파일 이름이나 구조 등을 정하고, 모든 결정을 내립니다.</li><li>우리 프로젝트에 가져와서 쓰는 방식</li><li>예) React: 렌더링 할 때 ReactDOM.render() 를 불러와서 사용합니다.</li></ul><h2 id="프레임워크"><a class="markdownIt-Anchor" href="#프레임워크"></a> 프레임워크</h2><ul><li>파일 이름이나 구조 등을 정해진 규칙에 따라 만들고 따릅니다.</li><li>정해진 틀 안에서 커스터마이징 방식</li><li>예) NextJS: 정해진 규칙에 따라 코드를 작성하면 렌더링됩니다.</li></ul><h2 id="차이점"><a class="markdownIt-Anchor" href="#차이점"></a> 차이점</h2><p>라이브러리와 프레임워크의 주요 차이점은 “Inversion of Control”(통제의 역전) 입니다.<br />라이브러리에서 메서드를 호출하면 사용자가 제어할 수 있습니다.<br />그러나 프레임워크에서는 제어가 역전되어 프레임워크가 사용자를 호출합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://www.youtube.com/watch?v=t9ccIykXTCM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=t9ccIykXTCM</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/03/info-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Next.js] 프로젝트 생성 및 시작 방법</title>
      <link>http://hgko1207.github.io/2023/02/03/nextjs-1/</link>
      <guid>http://hgko1207.github.io/2023/02/03/nextjs-1/</guid>
      <pubDate>Fri, 03 Feb 2023 00:48:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt; 를 사용하는 프로젝트 생성 하는 방법에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;시스템-요구-사항&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#시스템-요구-사항&quot;&gt;&lt;/a&gt; 시스템
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>Next.js</strong> 를 사용하는 프로젝트 생성 하는 방법에 대해 알아보겠습니다.</p><h2 id="시스템-요구-사항"><a class="markdownIt-Anchor" href="#시스템-요구-사항"></a> 시스템 요구 사항</h2><ul><li>Node.js 14.6.0 이상</li><li>MacOS, Windows(WSL 포함) 및 Linux 가 지원됩니다.</li></ul><h2 id="프로젝트-생성"><a class="markdownIt-Anchor" href="#프로젝트-생성"></a> 프로젝트 생성</h2><p>리액트 프로젝트를 생성하는 방법과 비슷하게 <code>create-next-app</code> 명령어를 사용합니다. <code>@latest</code> 를 추가하면 최신 버전으로 프로젝트를 생성합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npx</span> <span class="string">create-next-app@latest</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">yarn</span> <span class="string">create next-app</span></span><br></pre></td></tr></table></figure><p>TypeScript 프로젝트로 시작하려면 <code>--typescript</code> 옵션을 추가합니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npx</span> <span class="string">create-next-app@latest --typescript</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">yarn</span> <span class="string">create next-app --typescript</span></span><br></pre></td></tr></table></figure><p>위의 방법으로 프로젝트를 생성해보겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">D:\project\Study&gt;npx create-next-app@latest</span><br><span class="line">√ What is your project named? ... nextjs-intro</span><br><span class="line">√ Would you like to use TypeScript with this project? ... No / Yes</span><br><span class="line">√ Would you like to use ESLint with this project? ... No / Yes</span><br><span class="line">√ Would you like to use `src/` directory with this project? ... No / Yes</span><br><span class="line">√ Would you like to use experimental `app/` directory with this project? ... No / Yes</span><br><span class="line">√ What import <span class="built_in">alias</span> would you like configured? ... @/*</span><br><span class="line">Creating a new Next.js app <span class="keyword">in</span> D:\project\Study\nomadcoders\nextjs-intro.</span><br><span class="line"></span><br><span class="line">Using npm.</span><br><span class="line"></span><br><span class="line">Installing dependencies:</span><br><span class="line">- react</span><br><span class="line">- react-dom</span><br><span class="line">- next</span><br><span class="line">- @next/font</span><br><span class="line">- eslint</span><br><span class="line">- eslint-config-next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">added 264 packages, and audited 265 packages <span class="keyword">in</span> 25s</span><br><span class="line"></span><br><span class="line">102 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">Initializing project with template: default</span><br><span class="line"></span><br><span class="line">Success! Created nextjs-intro at D:\project\Study\nextjs-intro</span><br></pre></td></tr></table></figure><p>프로젝트 이름을 입력하고 TypeScript 와 ESLint 사용 여부를 선택하면 프로젝트가 성공적으로 생성됩니다.</p><h2 id="시작"><a class="markdownIt-Anchor" href="#시작"></a> 시작</h2><p>프로젝트 기본 구조 입니다.</p><p><img src="/images/nextjs/1.png" alt="" /></p><p>다음 명령어를 실행하여 개발 서버를 시작합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>개발 서버가 구동되면 <code>http://localhost:3000</code>에 접속하여 확인합니다.</p><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li><a href="https://nextjs.org/docs/getting-started" target="_blank" rel="noopener">https://nextjs.org/docs/getting-started</a></li></ul>]]></content:encoded>
      
      <comments>http://hgko1207.github.io/2023/02/03/nextjs-1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
