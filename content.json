{"meta":{"title":"규니의 블로그","subtitle":"hgko's IT Blog","description":"Information related to IT","author":"Hyeong Gyun Ko","url":"http://hgko1207.github.io","root":"/"},"pages":[{"title":"About","date":"2019-01-07T08:59:42.000Z","updated":"2023-04-25T01:49:09.423Z","comments":true,"path":"about/index.html","permalink":"http://hgko1207.github.io/about/index.html","excerpt":"","text":"안녕하세요. 블로그를 시작한지 얼마 안 된 새내기입니다. 이전에는 네이버 블로그에 조금씩 업로드를 하였었는데, Github 에 연동된 블로그가 있어 시작하게 되었습니다. 개발 경력은 쌓이는데 개발에 대한 내용을 기록한 적이 많이 없어 이번 계기로 열심히 기록해보려고 합니다. 컴퓨터공학과 학사 졸업 정보통신공학과 석사 졸업 현재 프리렌서 취미 축구 자전거 수영 게임 관심사 블로그 자격증 육아"},{"title":"Profile","date":"2020-07-29T00:52:04.000Z","updated":"2023-04-25T01:52:12.335Z","comments":true,"path":"profile/index.html","permalink":"http://hgko1207.github.io/profile/index.html","excerpt":"","text":"보유기술 Programming Laguage Java, JavaScript, TypeScript, HTML5, CSS Python, Dart C#, C++ Framework / Library Spring Framework, Spring Boot, JPA, Querydsl NodeJS, React, Next.js, Angular React Native, Android, WPF Bootstrap, JQuery Server MySQL, MSSQL, PostgreSQL, Oracle, Elasticsearch Docker, Nginx, Tomcat Kafka, Zookeeper Tooling / DevOps GitHub, GitLab, SVN Gradle, maven Jenkins, Travis CI Environment Windows, Linux, AWS 관심분야 Vue.js Go AI Contact GitHub : https://github.com/hgko1207 E-Mail : khkkhk1207@gmail.com 블로그 : https://hgko-dev.tistory.com/ 개인 프로젝트 Web 2022/03 Spring 진로상담센터 내 진로상담 신청 및 관리 시스템 2021/12 Spring 아파트 내 강의 관리 시스템(웹, 모바일) 2021/11 Spring 저수지 운영 및 관리 시스템 2021/08 Spring 하남미사 상수관망 통합관제시스템 2021/03 Spring 캠퍼스형 방과 후 학교 관리 시스템(웹, 모바일) 2020/11 Spring LED 조명 제어 관리 시스템 2020/08 Spring xx 회사 홈페이지 개발 2020/07 Spring 스마트 노지 토양환경 모니터링 시스템 2020/06 Spring AI 관제 시스템 2020/03 React 번역 서비스 : 구글, 및 파파고 번역을 동시에 할 수 있도록 지원 2020/03 React Paper Translation : 논문 번역 시 불필요한 문자들을 제거하여 번역이 쉽도록 도와주는 사이트 2020/03 React NodeJs + React : NodeJS와 React를 사용한 간단한 웹 프로젝트 2019/10 Spring 학교 외의 방과 후 관리 프로그램(웹, 모바일) 2019/07 Spring 새만금 작물 생육환경 모니터링 시스템 2019/03 Spring 학교 내의 방과 후 관리 프로그램 2016/08 Spring 가축 사양 관리 시스템 Server 2019/09 Java 가축 분뇨 관리 시스템 2018/03 Java(Eclipse RCP) 주차공간 모니터링 시스템 Android 2020/11 Android LED 조명 제어 앱 개발 Window Application 2021/05 C# 현미경 영상분석 소프트웨어 개발 2020/01 C# MapImageViewer : Gdal + WPF를 사용하여 개발한 이미지 뷰어 프로그램 2020/01 C# ImageViewer : 이미지를 열고 간단히 뷰어하는 프로그램 2019/04 C# Kiosk : Kiosk에 들어가는 GUI 개발 Template 2020/06 Spring SpringBoot + Thymeleaf + JPA : SpringBoot 기반 Template Project 2020/05 React SpringBoot + React : SpringBoot와 React를 사용하는 Template Project 2019/12 Spring SpringBoot + jsp + Tiles : SpringBoot 기반 Template Project 2019/12 Spring SpringBoot + PostgreSQL + JPA : SpringBoot 기반 Database 연동 Template Project 2019/12 Spring SpringBoot + Thymeleaf + Gradle : SpringBoot 기반 Template Project 2019/12 Spring SpringBoot + jsp + MySQL + JPA : SpringBoot 기반 Database 연동 Template Project"}],"posts":[{"title":"[Angular] OpenLayers로 지도 생성","slug":"angular-12","date":"2023-07-18T05:05:29.000Z","updated":"2023-07-19T05:10:32.332Z","comments":true,"path":"2023/07/18/angular-12/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/angular-12/","excerpt":"","text":"OpenLayers 는 개인 또는 상업 프로젝트에 지도를 추가해야 하는 경우 광범위한 사용 사례에 적합한 오픈 소스 라이브러리입니다. 아래 단계를 따라하면 몇 분 안에 빠르게 실행할 수 있습니다. Angular 프로젝트를 한 번도 해본 적이 없는 경우 새 프로젝트를 만드는 방법을 보여 드리겠습니다. 하지만 해당 부분을 건너뛰고 OpenLayers를 기존 프로젝트에 추가 할 수 있습니다. 새 Angular 프로젝트 만들기 이 시점에서 첫 번째 Angular 프로젝트를 설정하는 방법을 보여 드리겠습니다. 모든 컴퓨터 운영 체제를 사용할 수 있으며 Angular는 macOS, Linux 및 Windows에서 작동합니다. 이것은 지금 사용하는 설정입니다. 1234Angular CLI: 16.1.0Node: 18.15.0Package Manager: npm 9.5.0OS: win32 x64 먼저 Angular를 처음 사용하는 경우 로컬 환경을 설정해야 합니다. Node.js 와 npm이 필요합니다. 설치된 버전을 확인하려면 다음 명령을 실행하십시오. 12node -vnpm -v 자, 새 프로젝트를 만들어 봅시다. command line interface(터미널, 명령 프롬프트)를 열고 새 Angular 프로젝트에 사용하려는 디렉토리로 이동합니다. Angular CLI를 설치하려면 다음을 실행합니다. 1npm install -g @angular/cli 이제 작업 공간을 만듭니다. 1ng new openlayers-demo 그리고 앱을 실행할 수 있는지 확인하십시오. 12cd openlayers-demong serve — open 잘하셨습니다. 이제 OpenLayers 설정을 시작할 준비가 되었습니다. Angular 프로젝트에 OpenLayers 추가 최신 버전의 OpenLayers를 설치합니다. 1npm install --save ol 이 시점에서 앱을 제공하려고 하면 앱이 컴파일되지 않는 것을 알 수 있습니다. 이 문제는 Openlayers 6.6 이상 버전에 존재하므로 위의 명령에 @6.5를 추가하여 Openlayers 6.5 버전을 사용하도록 결정할 수도 있습니다. 그러나 이후 버전에 존재하는 문제를 해결하는 방법을 살펴보겠습니다. 아래와 같이 ol 라이브러리와 관련된 오류가 표시됩니다. 1234Error: node_modules&#x2F;ol&#x2F;source&#x2F;Cluster.d.ts:136:31 - error TS2314: Generic type &#39;Feature&lt;Geometry&gt;&#39; requires 1 type argument(s).136 protected features: Array&lt;Feature&gt;;Error: node_modules&#x2F;ol&#x2F;source&#x2F;Cluster.d.ts:152:23 - error TS2314: Generic type &#39;VectorSource&lt;Geometry&gt;&#39; requires 1 type argument(s).152 protected source: VectorSource; 오류를 해결하려면 tsconfig.json 파일을 열고 compilerOptions 안에 &quot;skipLibCheck&quot;:true 옵션을 추가합니다. 123456789101112131415161718192021222324252627&#123; \"compileOnSave\": false, \"compilerOptions\": &#123; \"baseUrl\": \"./src\", \"outDir\": \"./dist/out-tsc\", \"sourceMap\": true, \"declaration\": false, \"module\": \"es2020\", \"moduleResolution\": \"node\", \"experimentalDecorators\": true, \"allowSyntheticDefaultImports\": true, \"importHelpers\": true, \"target\": \"es2020\", \"typeRoots\": [\"node_modules/@types\"], \"lib\": [\"es2018\", \"dom\"], \"paths\": &#123; \"@core\": [\"@core/\"], \"environments\": [\"environments/\"] &#125;, \"resolveJsonModule\": true, \"skipLibCheck\": true &#125;, \"angularCompilerOptions\": &#123; \"fullTemplateTypeCheck\": false, \"strictInjectionParameters\": false &#125;&#125; 이제 OpenLayers CSS Style을 프로젝트에 추가하십시오. angular.json 파일을 열고 기존 CSS Style 옆에 &quot;node_modules/ol/ol.css&quot; 를 추가합니다. 123456789101112131415161718192021222324252627282930&#123; \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", \"version\": 1, \"newProjectRoot\": \"projects\", \"projects\": &#123; \"openlayers-demo\": &#123; \"projectType\": \"application\", \"schematics\": &#123; \"@schematics/angular:component\": &#123; \"style\": \"scss\" &#125; &#125;, \"root\": \"\", \"sourceRoot\": \"src\", \"prefix\": \"app\", \"architect\": &#123; \"build\": &#123; \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": &#123; ... \"styles\": [ \"src/styles.scss\", \"node_modules/ol/ol.css\" ], &#125; &#125; &#125; &#125; &#125;&#125; 이제 지도를 넣을 수 있는 구성 요소를 만들 차례입니다. 1ng generate component map 구성 요소의 콘텐츠를 추가합니다. map.component.html 1&lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; map.component.scss 1234.map &#123; width: 100%; height: 500px;&#125; map.component.ts 12345678910111213141516171819202122232425262728293031import &#123; Component, OnInit &#125; from '@angular/core';import 'ol/ol.css';import Map from 'ol/Map';import View from 'ol/View';import &#123; OSM &#125; from 'ol/source';import TileLayer from 'ol/layer/Tile';@Component(&#123; selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'],&#125;)export class MapComponent implements OnInit &#123; public map!: Map; ngOnInit(): void &#123; this.map = new Map(&#123; layers: [ new TileLayer(&#123; source: new OSM(), &#125;), ], target: 'map', view: new View(&#123; center: [0, 0], zoom: 2, maxZoom: 18, &#125;), &#125;); &#125;&#125; OSM 은 OpenStreetMaps를 의미하며 여기서는 표준 지도를 사용하지만 OpenLayers는 다양한 지도 Tile Servers, 이미지 등과 함께 작동하며 사용자 고유의 레이어를 만들고 사용자 지정할 수도 있습니다. 마지막 단계는 지도 구성요소의 내용을 포함하도록 루트 html 파일 app.component.html의 내용을 바꾸는 것입니다. 1&lt;app-map&gt;&lt;/app-map&gt; 이제 작동하는 웹사이트를 확인할 시간입니다! 이 가이드에서는 OpenLayers 라이브러리로 Angular 프로젝트를 설정하여 웹사이트에서 지도를 사용하는 방법을 배웠습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"}]},{"title":"[C#] FileSystemWatcher 파일 감시 모니터링","slug":"csharp-1","date":"2023-07-18T04:49:39.000Z","updated":"2023-07-20T14:08:07.347Z","comments":true,"path":"2023/07/18/csharp-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/csharp-1/","excerpt":"","text":"FileSystemWatcher 는 특정 폴더 경로(디렉토리)의 모든 파일이 생성되거나 변경되면 함수 호출을 해줍니다. 사용 방법 사용 방법 순서입니다. FileSystemWatcher 생성자 호출 감시할 폴더 설정(디렉토리) 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) 감시할 이벤트 설정 (생성, 변경, 삭제 등) FIleSystemWatcher 감시 모니터링 활성화 감시할 폴더 내부 변경 시 event 호출 구현 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;using System.IO;namespace Test.Utils&#123; public class FileWatcher &#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; initWatcher &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public void initWatcher() &#123; string filePath &#x3D; $&quot;D:\\\\files\\\\&quot;; &#x2F;&#x2F; 1. FileSystemWatcher 생성자 호출 FileSystemWatcher watcher &#x3D; new FileSystemWatcher(); &#x2F;&#x2F; 2. 감시할 폴더 설정(디렉토리) watcher.Path &#x3D; filePath; &#x2F;&#x2F; 3. 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) watcher.NotifyFilter &#x3D; NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size | NotifyFilters.LastAccess | NotifyFilters.CreationTime | NotifyFilters.LastWrite; &#x2F;&#x2F;감시할 파일 유형 선택 예) *.* 모든 파일 watcher.Filter &#x3D; &quot;*.*&quot;; watcher.IncludeSubdirectories &#x3D; true; &#x2F;&#x2F; 4. 감시할 이벤트 설정 (생성, 변경..) watcher.Created +&#x3D; new FileSystemEventHandler(Changed); watcher.Changed +&#x3D; new FileSystemEventHandler(Changed); watcher.Renamed +&#x3D; new RenamedEventHandler(Renamed); &#x2F;&#x2F; 5. FIleSystemWatcher 감시 모니터링 활성화 watcher.EnableRaisingEvents &#x3D; true; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Changed &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;source&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;e&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F; 6. 감시할 폴더 내부 변경 시 event 호출 private void Changed(object source, FileSystemEventArgs e) &#123; Console.Write(e.FullPath); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Renamed &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;source&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;e&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F; 이름 변경 시 event 호출 private void Renamed(object source, RenamedEventArgs e) &#123; MessageBox.Show(e.FullPath); &#125; &#125;&#125; FileSystemWatcher 은 using System.IO 를 선언해 주어야 합니다. initWatcher() 함수를 실행시키면 D:\\files\\ 해당 경로에 파일이 생기면 바로 Changed() 이벤트가 호출됩니다. 호출 될 때 담겨지는 파라미터 FileSystemEventArgs e 에서 e.Fullpath 를 통해 생성된 파일의 전체 경로를 가져옵니다. 12# 예)D:\\files\\새 텍스트 문서.txt 이렇게 FileSystemWatcher 를 사용해서 해당 폴더를 실시간으로 감지 모니터링하는 기능을 구현했습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"}]},{"title":"[Angular] cross-fetch 사용 방법","slug":"angular-11","date":"2023-07-11T02:48:34.000Z","updated":"2023-07-11T03:14:45.577Z","comments":true,"path":"2023/07/11/angular-11/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-11/","excerpt":"","text":"Angular 개발 시 api 통신을 하기 위해 Fetch API 사용해 보았다. Fetch API 란 Fetch API는 HTTP 파이프라인을 구성하는 요청과 응답 등의 요소를 JavaScript에서 접근하고 조작할 수 있는 인터페이스를 제공합니다. Fetch API가 제공하는 전역 fetch() 메서드로 네트워크의 리소스를 쉽게 비동기적으로 취득할 수도 있습니다. 설치 Fetch API를 사용하기 위해 cross-fetch 패키지를 설치한다. 12345# npm 을 사용하여 설치하는 경우npm install --save cross-fetch# yarn 을 사용하여 설치하는 경우yarn add cross-fetch ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; http 메서드 설정 HTTP 요청 메소드에서 자주 사용하는 GET, POST, PUT, DELETE 를 사용하는 함수를 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable &#125; from '@angular/core';import fetch from 'cross-fetch';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125; public get(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'GET', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public post(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'POST', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public put(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'PUT', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public delete(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'DELETE', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125;&#125; fetch 의 return 타입은 Promise 이기 때문에 then 함수를 사용하거나 async await 를 사용한다. 12345678910111213141516171819202122// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; ApiService &#125; from 'app/services/api.service';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; private BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private api: ApiService) &#123; this.api.get(`$&#123;BASE_URL&#125;/today`).then((response: any) =&gt; &#123; if (response.ok) &#123; console.log(response.json()); &#125; &#125;); &#125; ngOnInit(): void &#123;&#125;&#125; 참고 Fetch API 사용하기 https://github.com/lquixada/cross-fetch","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"}]},{"title":"[Angular] HttpClient 사용 방법","slug":"angular-10","date":"2023-07-11T02:13:24.000Z","updated":"2023-07-11T02:51:34.147Z","comments":true,"path":"2023/07/11/angular-10/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-10/","excerpt":"","text":"Angular 개발 시 프로젝트 초기에 api 통신에 대해 설정 파일을 생성하고 설정해두면 작업하기가 편합니다. Angluar 는 @angular/common 안에 존재하는 http 패키지를 사용하면 됩니다. import http 작업을 하기 위해 src/app.module.ts 파일에 HttpClientModule을 import 해야 합니다. 12345678910111213141516// src/app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpClientModule &#125; from '@angular/common/http';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], // BrowserModule 다음에 HttpClientModule를 작성해야 한다 imports: [BrowserModule, HttpClientModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; Injectable 이기 때문에 다른 module 에서 import 하지 않아도 바로 사용할 수 있다. baseUrl 설정 이제 불러 올 api의 baseUrl을 설정해준다. 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125;&#125; 보통 BASE_URL은 각 프로젝트의 환경 별로 다르게 설정 가능하다. 12345// src/environments/environments.tsexport const environment = &#123; production: false, baseUrl: 'https://test.api.example.com',&#125;; 12345// src/environments/environment.prod.tsexport const environment = &#123; production: true, baseUrl: 'https://api.example.com',&#125;; 위의 처럼 설정한 후 src/api/api.service.ts에 다음과 같이 불러와 사용하면 된다. 12345import &#123; environment &#125; from 'environments/environment';// ...생략export class ApiService &#123; public BASE_URL = environment.baseUrl;&#125; http 메서드 설정 HTTP 요청 메소드에서 자주 사용하는 GET, POST, PUT, DELETE 를 사용하는 함수를 생성한다. 123456789101112131415161718192021222324252627// src/api/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';import &#123; Observable &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125; post&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.post&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; put&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.put&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; delete&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.delete&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125;&#125; Angular의 http의 return 타입은 모두 Observable 이기 때문에, 할당할 변수의 타입도 Observable로 지정해야 한다. 1234567891011121314151617181920212223242526// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs';import &#123; ApiService &#125; from 'app/services/api.service';interface WebToonInfo &#123; id: string; title: string; thumb: number;&#125;@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; webToons$: Observable&lt;WebToonInfo[]&gt;; constructor(private api: ApiService) &#123; this.webToons$ = this.api.get('/today'); this.webToons$.subscribe(console.log); // console 확인 &#125; ngOnInit(): void &#123;&#125;&#125; Error 처리 만약 에러를 처리하고 싶다면, 각 api 요청마다 설정할 수도 있지만 api.service.ts 에서 설정 해줘도 된다. 1234567891011121314151617181920212223// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpErrorResponse &#125; from '@angular/common/http';import &#123; Observable, throwError &#125; from 'rxjs';import &#123; catchError &#125; from 'rxjs/operators';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; // ... 생략 private handleError(error: HttpErrorResponse) &#123; if (error.status === 0) &#123; console.error('Error:', error.error); &#125; else &#123; console.error(`Backend error $&#123;error.status&#125;, $&#123;error.error&#125;`); &#125; return throwError('예기치 못한 에러가 발생했습니다. 다시 시도해주세요.'); &#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`).pipe(catchError(this.handleError)); &#125;&#125; 참고 Understanding communicating with backend services using HTTP","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"}]},{"title":"Flutter 업그레이드","slug":"flutter-2","date":"2023-05-30T05:14:11.000Z","updated":"2023-06-05T00:44:56.894Z","comments":true,"path":"2023/05/30/flutter-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/30/flutter-2/","excerpt":"","text":"Flutter 버전 오류 Flutter 프로젝트를 진행하면서 http 패키지를 설치하려고 flutter pub get 명령어를 실행했을때 다음과 같은 오류가 발생했습니다. 123456[flutter\\example] flutter pub getResolving dependencies...The current Dart SDK version is 3.0.0-431.0.devBecause example depends on http &gt;=1.0.0 which requires SDK version ^3.0.0, version solving failed.exit code 1 http 패키지의 1.0.0 버전을 설치하는데 현재 Dart SDK 버전이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되지 않아 발생한 오류였습니다. 현재 Dart SDK 버전 3.0.0-431.0.dev 이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되는 것 같지만 실제로는 조건에 충족하지 않습니다. 오류 해결 Dart SDK 버전을 올려주면 해결됩니다. 버전을 올리기 위해 Dart 를 새로 설치를 해도 되지만 번거롭습니다. flutter 명령어로 Flutter 와 Dart 의 버전을 올릴 수 있기 때문에 flutter CLI 명령어로 버전을 변경합니다. 1flutter upgrade 위의 명령어를 실행하면 다음와 같이 업그레이드를 진행합니다. 12345678910111213141516171819202122232425Upgrading engine...Downloading android-arm-profile/windows-x64 tools... 387msDownloading android-arm-release/windows-x64 tools... 101msDownloading android-arm64-profile/windows-x64 tools... 132msDownloading android-arm64-release/windows-x64 tools... 97msDownloading android-x64-profile/windows-x64 tools... 101msDownloading android-x64-release/windows-x64 tools... 103msDownloading android-x86 tools... 639msDownloading android-x64 tools... 628msDownloading android-arm tools... 521msDownloading android-arm-profile tools... 216msDownloading android-arm-release tools... 142msDownloading android-arm64 tools... 526msDownloading android-arm64-profile tools... 261msDownloading android-arm64-release tools... 201msDownloading android-x64-profile tools... 258msDownloading android-x64-release tools... 214msDownloading android-x86-jit-release tools... 337msDownloading Web SDK... 1,662ms...Flutter 3.11.0-15.0.pre.48 • channel master • https://github.com/flutter/flutter.gitFramework • revision c5f45d7121 (54 minutes ago) • 2023-05-30 00:15:34 -0400Engine • revision b5f60d2b33Tools • Dart 3.1.0 (build 3.1.0-155.0.dev) • DevTools 2.23.1 flutter 업그레이드가 끝나고 다시 flutter pub get 명령어를 실행하면 정상적으로 dependency 를 가지고 오는 것을 확인 할 수 있습니다. 1234567891011[flutter\\example] flutter pub getResolving dependencies...&gt; collection 1.17.2 (was 1.17.1)+ http 1.0.0+ http_parser 4.0.2 matcher 0.12.15 (0.12.16 available)&gt; material_color_utilities 0.5.0 (was 0.3.0)&gt; test_api 0.5.2 (was 0.5.1) (0.6.0 available)+ typed_data 1.3.2Changed 6 dependencies!exit code 0","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"}]},{"title":"[NestJS] End-to-end 테스트","slug":"nest-7","date":"2023-05-15T07:11:20.000Z","updated":"2023-06-05T00:44:48.447Z","comments":true,"path":"2023/05/15/nest-7/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-7/","excerpt":"","text":"End-to-end 테스트 개별 모듈과 클래스에 중점을 두는 Unit 테스트와 달리 end-to-end(e2e) 테스트는 보다 종합적인 수준에서 클래스와 모듈의 상호 작용을 다룹니다. 애플리케이션이 성장함에 따라 각 API endpoint 의 E2E 동작을 수동으로 테스트하기가 어려워집니다. 자동화된 E2E 테스트는 시스템의 전반적인 동작이 정확하고 프로젝트 요구 사항을 충족하는지 확인하는 데 도움이 됩니다. Nest 를 사용하면 SuperTest 라이브러리를 사용하여 HTTP request 를 쉽게 시뮬레이션할 수 있습니다. SuperTest 는 superagent 를 기반으로 하는 HTTP 검증 라이브러리입니다. request() SuperTest 의 request(app.getHttpServer()) 함수를 사용하여 HTTP 테스트를 시뮬레이션합니다. 1234// localhost:3000/ 으로 라우팅될 때 Hello World!가 출력되는지 확인it('/ (GET)', () =&gt; &#123; return request(app.getHttpServer()).get('/').expect(200).expect('Hello World!');&#125;); 이러한 HTTP request 가 실행 중인 Nest 앱으로 라우팅되기를 원하므로 request() 함수에 Nest 의 기반이 되는 HTTP 리스너에 대한 참조를 전달합니다. 사용 예시 기본적인 CRUD (Create/Read/Update/Delete) 에 대한 테스트를 하기 위해 다음과 같이 작성할 수 있습니다. 1234567891011121314151617181920212223242526272829describe('/users', () =&gt; &#123; it('GET', () =&gt; &#123; return request(app.getHttpServer()).get('/users').expect(200).expect([]); &#125;); it('POST', () =&gt; &#123; return request(app.getHttpServer()) .post('/users') .send(&#123; name: 'hgko', age: 30, hobbies: ['soccer'], &#125;) .expect(201); &#125;); it('PATCH', () =&gt; &#123; return request(app.getHttpServer()) .patch('/users/1') .send(&#123; age: 35, &#125;) .expect(200); &#125;); it('DELETE', () =&gt; &#123; return request(app.getHttpServer()).delete('/users/1').expect(200); &#125;);&#125;); 참고 https://docs.nestjs.com/fundamentals/testing#end-to-end-testing https://github.com/visionmedia/supertest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"}]},{"title":"[NestJS] Jest 사용 방법","slug":"nest-6","date":"2023-05-15T01:55:57.000Z","updated":"2023-06-10T06:05:26.018Z","comments":true,"path":"2023/05/15/nest-6/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-6/","excerpt":"","text":"NestJS 에서 Jest 를 사용하는 방법에 대해 간략하게 알아보겠습니다. Jest Jest 는 단순함에 초점을 맞춘 유쾌한 JavaScript 테스팅 프레임워크입니다. Babel, TypeScript, Node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동합니다. 시작하기 describe() describe() 함수를 사용하면 작은 단위의 테스트 코드를 그룹화할 수 있습니다. 작성하는 테스트 코드가 특정 component 에 속하는 테스트 코드라면 다음과 같이 describe() 함수를 사용해서 해당 테스트 코드들을 그룹화하는 것이 좋습니다. 테스트 결과를 확인할 때 가시적으로 보기 편하게 테스트 케이스들을 확인할 수 있습니다. 12345678910111213describe('StudentService', () =&gt; &#123; test('getAll', () =&gt; &#123; ... &#125;); test('getOne', () =&gt; &#123; ... &#125;); test('create', () =&gt; &#123; ... &#125;);&#125;); it(), test() 테스트 케이스를 생성합니다. it() 함수 대신 test()도 사용 가능합니다. 123it('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 123test('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); expect() 값을 테스트할 때마다 expect() 함수가 사용됩니다. 테스트할 때 expect() 함수를 여러개 사용할 수 있습니다. 1234567function bestJuiceFlavor() &#123; return 'apple';&#125;test('the best flavor is apple', () =&gt; &#123; expect(bestJuiceFlavor()).toBe('apple');&#125;); Using Matchers Common Matchers toBe() 함수는 Object.is 를 사용하여 정확한 동등성을 테스트합니다. 객체의 값을 확인하려면 대신 toEqual() 함수를 사용하세요. 123it('two plus two is four', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 12345it('object assignment', () =&gt; &#123; const data = &#123; one: 1 &#125;; data['two'] = 2; expect(data).toEqual(&#123; one: 1, two: 2 &#125;);&#125;); Strings toMatch() 함수를 사용하여 정규 표현식에 대해 문자열을 확인할 수 있습니다. 123it('but there is a \"ko\" in hgko', () =&gt; &#123; expect('hgko').toMatch(/ko/);&#125;); Arrays and iterables toContain() 함수를 사용하여 배열 또는 iterable 에 특정 항목이 포함되어 있는지 확인할 수 있습니다. 123456789const shoppingList = ['egg', 'coffee', 'tissue', 'milk'];it('the shopping list has milk on it', () =&gt; &#123; // array expect(shoppingList).toContain('milk'); // iterable expect(new Set(shoppingList)).toContain('milk');&#125;); Exceptions 특정 함수가 호출될 때 오류가 발생하는지 테스트하려면 toThrow() 함수를 사용합니다. 예외를 발생시키는 함수는 래핑 함수 내에서 호출해야 합니다. 그렇지 않으면 toThrow assertion 이 실패합니다. 123456789101112131415describe('getOne', () =&gt; &#123; it('shoule find a student', () =&gt; &#123; const student = service.getOne(1); expect(student).toBeDefined(); &#125;); it('should throw 404 error', () =&gt; &#123; try &#123; service.getOne(999); &#125; catch (e) &#123; expect(e).toBeInstanceOf(NotFoundException); expect(e.message).toEqual(`Student with ID: 999 not found.`); &#125; &#125;);&#125;); toBeInstanceOf(Class) 함수를 사용하여 객체가 클래스의 인스턴스인지 확인 할 수 있습니다. 테스트 전/후 처리 beforeEach 각각의 테스트가 실행되기 전에 매번 함수를 실행합니다. 각각의 테스트 전에 각 테스트에서 사용할 전역 상태를 재설정하려는 경우에 유용합니다. 함수가 promise 을 반환하거나 generator 인 경우 Jest 는 테스트를 실행하기 전에 해당 promise 가 해결될 때까지 기다립니다. 밀리초로 대기할 시간을 지정할 수 있습니다. (기본 시간 5초) 1234567891011121314let users: User[];// test() 함수들이 실행될때마다 beforeEach()에서 설정한, users 데이터를 사용하게 된다.beforeEach(async () =&gt; &#123; users.push(&#123; id: 1, name: 'hgko' &#125;, &#123; id: 2, name: 'eden' &#125;);&#125;);test('find all users', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;);test('create a user', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;); afterEach 각각의 테스트가 완료된 후 함수를 실행합니다. beforeAll 모든 테스트가 실행되기 전에 딱 한 번 함수를 실행합니다. 123456let connection;beforeAll(() =&gt; &#123; // 테스트 실행하기전에 데이터베이스에 접속할 연결(Connection) 개체를 만든다. conection = openConnection(&#123; host: '...', port: '...' &#125;);&#125;); afterAll 모든 테스트가 완료된 후 함수를 실행합니다. 1234afterAll(() =&gt; &#123; // 데이터베이스 Connection을 종료한다. conection.close();&#125;); 실행 NestJS 개발환경에서 package.json 파일에 Testing 하는 명령어가 정의되어 있습니다. 123456789101112// package.json&#123; ... \"scripts\": &#123; ... \"test\": \"jest\", \"test:watch\": \"jest --watch\", \"test:cov\": \"jest --coverage\", \"test:debug\": \"node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand\", \"test:e2e\": \"jest --config ./test/jest-e2e.json\" &#125;,&#125; 다음과 같이 테스트 하려는 방식에 따라 명령어를 실행해서 테스트합니다. 1234567# Unit 테스트npm run testnpm run test:watchnpm run test:cov# E2E 테스트npm rum test:e2e 참고 https://jestjs.io/ https://jestjs.io/docs/getting-started https://jestjs.io/docs/expect","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"}]},{"title":"[NestJS] Mapped types의 Partial 사용 방법","slug":"nest-5","date":"2023-05-13T12:46:39.000Z","updated":"2023-05-15T06:18:07.943Z","comments":true,"path":"2023/05/13/nest-5/","link":"","permalink":"http://hgko1207.github.io/2023/05/13/nest-5/","excerpt":"","text":"Mapped types CRUD (Create/Read/Update/Delete) 와 같은 기능을 구축할 때 기본 엔터티 클래스를 기능에 맞게 변형하는 것이 필요한 경우가 많습니다. Nest 는 이 작업을 보다 편리하게 만들기 위해 클래스 변환을 수행하는 여러 유틸리티 기능을 제공합니다. Partial input validation types(DTO라고도 함)을 빌드할 때 동일한 클래스에 대한 create 및 update 클래스로 변형하는 것이 필요한 경우가 많습니다. 예를 들어, create 에는 모든 필드가 필요할 수 있지만 update 는 모든 필드를 선택 사항으로 만들 수 있습니다. Nest 는 이 작업을 더 쉽게 만들고 보일러플레이트(Boilerplate) 코드를 최소화하기 위해 PartialType() 유틸리티 함수를 제공합니다. PartialType() 함수는 입력 클래스의 모든 속성이 선택 사항으로 설정된 클래스를 반환합니다. 설치 Mapped types 설치를 통해 PartialType 을 가져올 수 있습니다. 1npm i @nestjs/mapped-types 사용 예시 이전 글 [NestJS] ValidationPipe 사용 방법 에서 생성한 사용자 등록 DTO 클래스를 이용합니다. 사용자 등록 DTO 클래스의 필드들은 모두 필수 항목입니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 DTO 클래스와 동일한 필드를 가지지만 각 필드가 선택 사항인 사용자 수정 DTO 클래스를 생성하려면 PartialType() 함수를 상속 받고 사용자 등록 DTO 클래스인 CreateUserDto 를 인수로 전달합니다. 12345// update-user.dto.tsimport &#123; PartialType &#125; from '@nestjs/mapped-types';import &#123; CreateUserDto &#125; from './create-user.dto';export class UpdateUserDto extends PartialType(CreateUserDto) &#123;&#125; 사용자 수정 요청을 받기 위해 컨트롤러 클래스를 생성합니다. update 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Patch &#125; from '@nestjs/common';import &#123; UpdateUserDto &#125; from './dto/update-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 수정 * @param userData * @returns */ @Patch() update(@Body() userData: UpdateUserDto) &#123; return '사용자 수정 성공'; &#125;&#125; 사용자 수정 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 PATCH 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12// 서버에서 응답사용자 수정 성공 사용자 등록과 달리 모든 필드가 선택 사항으로 설정되어 있어 요청할 때 속성들을 입력하지 않아도 잘 동작하는 것을 확인할 수 있습니다. 참고 https://docs.nestjs.com/openapi/mapped-types#partial https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"}]},{"title":"[NestJS] ValidationPipe 사용 방법","slug":"nest-4","date":"2023-05-11T03:10:18.000Z","updated":"2023-06-05T00:44:40.813Z","comments":true,"path":"2023/05/11/nest-4/","link":"","permalink":"http://hgko1207.github.io/2023/05/11/nest-4/","excerpt":"","text":"Validation 웹 애플리케이션으로 전송되는 데이터의 검증을 도와줍니다. 들어오는 요청을 자동으로 검증하기 위해 Nest 는 즉시 사용할 수 있는 여러 파이프를 제공합니다. ValidationPipe ValidationPipe는 강력한 클래스 유효성 검사기 패키지와 선언적 유효성 검사 데코레이터를 사용합니다. ValidationPipe는 들어오는 모든 클라이언트 페이로드에 대해 유효성 검사 규칙을 적용하는 편리한 접근 방식을 제공합니다. ValidationPipe 사용을 위한 class-validator, class-transformer 패키지를 설치합니다. 1npm i --save class-validator class-transformer 사용 예시 ValidationPipe 를 사용하기 위해 main.ts 파일에 다음과 같이 추가합니다. 123456789101112// main.tsimport &#123; NestFactory &#125; from '@nestjs/core';import &#123; AppModule &#125; from './app.module';import &#123; ValidationPipe &#125; from '@nestjs/common';async function bootstrap() &#123; const app = await NestFactory.create(AppModule); // ValidationPipe 추가 app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);&#125;bootstrap(); 유효성 검사를 위해 사용자 등록을 예시로 작성했습니다. 먼저 사용자 등록을 위한 DTO(Data Transfer Object) 클래스를 생성합니다. 그리고 validation decorator(IsString, IsNumber 등)를 유효성 검사하기 위한 필드에 추가합니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 요청을 받기 위해 컨트롤러 클래스를 생성합니다. create 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Post &#125; from '@nestjs/common';import &#123; CreateUserDto &#125; from './dto/create-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 등록 * @param userData * @returns */ @Post() create(@Body() userData: CreateUserDto) &#123; return '사용자 등록 성공!!'; &#125;&#125; 사용자 등록 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 POST 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12345678910// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [ \"name must be a string\", \"age must be a number conforming to the specified constraints\", \"each value in hobbies must be a string\" ], \"error\": \"Bad Request\"&#125; 요청 하는 데이터가 “name”, “age”, “hobbies” 필드가 존재하지 않으므로 예외를 응답합니다. 즉, ValidationPipe 를 사용하면 모든 엔드포인트가 잘못된 데이터를 수신하지 못하도록 보호됩니다. 간단한 설정만으로 유효성 체크를 할 수 있습니다. 옵션 whitelist whitelist: true로 설정하면 유효성 검사기는 class-validator의 유효성 검사 데코레이터를 적어도 하나라도 사용하지 않은 모든 속성 객체를 제거합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, &#125;)); forbidNonWhitelisted forbidNonWhitelisted: true로 설정하면 화이트리스트에 없는 속성을 제거하는 대신 유효성 검사기가 예외를 발생합니다. 123456app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, forbidNonWhitelisted: true, &#125;)); whitelist 와 forbidNonWhitelisted 옵션을 true 로 설정하면 “height” 이라는 속성은 화이트리스트에 존재하지 않으므로 HttpException 을 응답합니다. 1234567// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"name\": \"hgko\", \"age\": 35, \"hobbies\": [\"soccer\"], \"height\": 180&#125; 123456// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [\"property height should not exist\"], \"error\": \"Bad Request\"&#125; transform (자동 형변환) 네트워크를 통해 들어오는 payload 는 일반 JavaScript 객체입니다. ValidationPipe 는 payload 를 DTO 클래스에 따라 유형이 지정된 객체로 자동 변환할 수 있습니다. 자동 변환을 활성화하려면 transform 을 true 로 설정하십시오. 이 동작을 전역적으로 활성화하려면 전역 파이프에서 옵션을 설정합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; transform: true, &#125;)); 참고 https://docs.nestjs.com/techniques/validation https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"}]},{"title":"[NestJS] Param decorators","slug":"nest-3","date":"2023-05-10T03:05:36.000Z","updated":"2023-05-21T14:43:21.800Z","comments":true,"path":"2023/05/10/nest-3/","link":"","permalink":"http://hgko1207.github.io/2023/05/10/nest-3/","excerpt":"","text":"Param decorators Nest 는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 매개변수 데코레이터 세트를 제공합니다. 다음은 제공된 데코레이터와 이들이 나타내는 일반 Express(또는 Fastify) 객체의 목록과 사용 예시입니다. @Param Param 은 Path Variable 을 받아올 때 사용합니다. (예, /users/123) 12345// NestJS@Param(param?: string)// ExpressJSreq.params / req.params[param] 123456789import &#123; Controller, Get, Param &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('/:id') getOne(@Param('id') userId: string) &#123; return `This will return one user with the id: $&#123;userId&#125;`; &#125;&#125; @Body Body 는 JSON 형식으로 받아올 때 사용합니다. 12345// NestJS@Body(param?: string)// ExpressJSreq.body / req.body[param] 1234567891011121314151617import &#123; Body, Controller, Param, Patch, Post &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Post() create(@Body() userData) &#123; return userData; &#125; @Patch('/:id') update(@Param('id') userId: string, @Body() updateData) &#123; return &#123; updateData: userId, ...updateData, &#125;; &#125;&#125; @Query Query 는 Query Parameter 를 받아올 때 사용합니다. (예, /users?id=123) 12345// NestJS@Query(param?: string)// ExpressJSreq.query / req.query[param] 123456789import &#123; Controller, Get, Query &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('search') search(@Query('id') userId: string) &#123; return `We are searching for a user made after: $&#123;userId&#125;`; &#125;&#125; 참고 https://docs.nestjs.com/custom-decorators#param-decorators","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"}]},{"title":"[NestJS] Controller, Provider, Module 이란?","slug":"nest-2","date":"2023-05-08T02:40:07.000Z","updated":"2023-06-10T06:04:35.421Z","comments":true,"path":"2023/05/08/nest-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-2/","excerpt":"","text":"NestJS 에서 사용하는 Controller, Provider, Module 에 대한 간략한 내용을 정리하였습니다. Controllers 컨트롤러는 들어오는 요청을 처리하고 클라이언트에 응답을 반환하는 역할을 합니다. express 의 라우터 같은 역할을 합니다. 1234567891011121314151617import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125; @Get('/hello') sayHello(): string &#123; return 'Hello everyone'; &#125;&#125; @Controller(): express 의 app.use('/', router) 에서 '/'와 같은 역할을 합니다. @Controller('req') 이렇게 인자로 string을 넘겨주면 express 에서 app.use('/req', router) 처럼 코드를 작성한 것과 같습니다. @Get(): Route 핸들러(메소드) 데코레이터입니다. HTTP GET 요청을 지정된 경로로 라우팅합니다. @Get('hello') 이렇게 인자로 string을 넘겨주면 express 에서 router.get('/hello', sayHello) 처럼 코드를 작성한 것과 같습니다. Providers Provider 는 Nest 의 기본 개념입니다. 대부분의 기본 Nest Class 인 services, repositories, factories, helpers 등은 provider 로 취급될 수 있습니다. provider 는 단순히 @Injectable() 데코레이터가 달린 클래스입니다. 12345678import &#123; Injectable &#125; from '@nestjs/common';@Injectable()export class AppService &#123; getHello(): string &#123; return 'Hello World!'; &#125;&#125; provider 의 주요 아이디어는 의존성을 주입 할 수 있다는 것입니다. 즉, 개체가 서로 다양한 관계를 만들 수 있으며 개체 인스턴스를 &quot;연결&quot;하는 기능은 대부분 Nest 런타임 시스템에 위임 할 수 있습니다. 123456789101112import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125;&#125; 위의 AppController 생성자에 변수의 타입을 AppService 로 지정해줌으로써 Nest Injector 가 appService 변수를 AppService의 인스턴스로 만들어줍니다(인스턴스화한다). Modules NestJS 에는 모듈이 있습니다. @Module() 데코레이터로 모듈을 만들 수 있습니다. Nest 어플리케이션을 만들면 최소 하나의 모듈, 루트 모듈(AppModule)이 있습니다. 이 루트 모듈은 Nest가 Module 및 Provider 관계와 의존성을 해결하는 데 사용하는 내부 데이터 구조를 구축하는 시작점입니다. 모듈을 만들면 루트 모듈과 연결되어야합니다. 12345678910import &#123; Module &#125; from '@nestjs/common';import &#123; AppController &#125; from './app.controller';import &#123; AppService &#125; from './app.service';@Module(&#123; imports: [], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; @Module() 데코레이터는 하나의 객체를 인자로 가지며, 객체가 가질 수 있는 프로퍼티는 다음과 같습니다. providers: Nest injector에 의해 인스턴스화되고, 인스턴스들은 모듈 안에서 최소한으로 공유됩니다. controllers: 해당 모듈에서 정의된, 인스턴스화 되어야 하는 Controller 의 집합입니다. imports: 임포트된 모듈들의 리스트입니다. 이 리스트의 모듈들은 데코레이터에 사용 중인 모듈에서 필요한 providers 를 export 하고 있어야 합니다. exports: providers 의 하위 집합으로, 데코레이터를 사용 중인 모듈이 제공받은 Provider 의 일부를 내보낼 수 있습니다. 이는 다른 모듈에서 import 할 때 사용됩니다. 파일 생성 Module 생성 1nest g mo module-name Controller 생성 1nest g co controller-name Service 생성 1nest g s service-name Provider 생성 1nest g pr provider-name 참고 https://docs.nestjs.com/controllers#controllers https://docs.nestjs.com/controllers#routing https://docs.nestjs.com/providers#providers https://docs.nestjs.com/modules#modules","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"}]},{"title":"[NestJS] 설치 및 프로젝트 생성","slug":"nest-1","date":"2023-05-08T02:22:59.000Z","updated":"2023-05-08T04:54:25.056Z","comments":true,"path":"2023/05/08/nest-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-1/","excerpt":"","text":"설치 Nest CLI 를 사용하면 새 프로젝트를 설정하는 것이 매우 간단합니다. npm 이 설치된 상태에서 터미널에서 다음 명령을 사용하여 Nest CLI 를 설치합니다. 1npm i -g @nestjs/cli 프로젝트 생성 nest new 명령어로 새 Nest 프로젝트를 만들 수 있습니다. 1nest new project-name nest new 로 프로젝트 생성이 안된다면 npx nest new 로 진행합니다. 예시로 프로젝트를 생성해 보겠습니다. 1234567D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? (Use arrow keys)&gt; npm yarn pnpm 기본적으로 npm 을 선택합니다. 123456789101112131415161718192021222324252627282930313233D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? npmCREATE test-nestjs/.eslintrc.js (663 bytes)CREATE test-nestjs/.prettierrc (51 bytes)CREATE test-nestjs/nest-cli.json (171 bytes)CREATE test-nestjs/package.json (1942 bytes)CREATE test-nestjs/README.md (3340 bytes)CREATE test-nestjs/tsconfig.build.json (97 bytes)CREATE test-nestjs/tsconfig.json (546 bytes)CREATE test-nestjs/src/app.controller.spec.ts (617 bytes)CREATE test-nestjs/src/app.controller.ts (274 bytes)CREATE test-nestjs/src/app.module.ts (249 bytes)CREATE test-nestjs/src/app.service.ts (142 bytes)CREATE test-nestjs/src/main.ts (208 bytes)CREATE test-nestjs/test/app.e2e-spec.ts (630 bytes)CREATE test-nestjs/test/jest-e2e.json (183 bytes)✔ Installation in progress... ☕🚀 Successfully created project test-nestjs👉 Get started with the following commands:$ cd test-nestjs$ npm run start Thanks for installing Nest 🙏 Please consider donating to our open collective to help us maintain this package. 🍷 Donate: https://opencollective.com/nest 프로젝트에 필요한 파일과 폴더를 생성하고, 패키지들을 설치합니다. Nest CLI 를 사용하면 직접 파일을 만들 필요 없어 편리합니다. 프로젝트 시작 파일의 변경 사항을 감시하려면 다음 명령를 실행하여 프로젝트를 시작할 수 있습니다. 이 명령은 파일을 감시하여 자동으로 서버를 다시 컴파일하고 다시 로드합니다. 1npm run start:dev http://localhost:3000/ 주소로 접속해서 정상적으로 시작됐는지 확인합니다. 참고 https://docs.nestjs.com/first-steps","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"}]},{"title":"[Git] detached HEAD 문제 해결 방법","slug":"git-1","date":"2023-05-04T06:22:00.000Z","updated":"2023-06-05T00:44:35.644Z","comments":true,"path":"2023/05/04/git-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/04/git-1/","excerpt":"","text":"git 을 사용할 때 add 와 commit 까진 실행이 잘 되는데 다음과 같이 detached HEAD 문제로 push 가 안 될 때 해결 방법을 정리하였습니다. 123456D:\\project\\Study\\react&gt; git pushfatal: You are not currently on a branch.To push the history leading to the current (detached HEAD)state now, use git push origin HEAD:&lt;name-of-remote-branch&gt; Detached Head 란, 말 그대로 head가 (branch로부터) 떨어져있는 상태를 뜻한다. 즉, branch 를 통해서가 아니라 직접 다이렉트로 commit 을 참조하고 있는 상태를 뜻한다. git branch 명령어를 사용하여 살펴보니 지금 현재 브랜치는 HEAD detached from bdcfe3d8 로 설정되어 있습니다. 123D:\\project\\Study\\react&gt; git branch -a* (HEAD detached from 537d4a3) master 해결 방법 임시로 새로운 브랜치를 만들어 main 브랜치와 병합하여 해결하는 방법입니다. 브랜치 생성 현재 Head 분기를 참조하게끔 임시 브랜치를 생성합니다. 12git branch tempgit checkout temp 또는 12# -b 명령어 사용git checkout -b temp 이렇게 하면 temp 라는 브랜치가 만들어지고, temp 로 checkout 을 하게 됩니다. master 브랜치로 이동 1git checkout master 병합 새로운 브랜치와 master 브랜치를 병합합니다. 1git merge temp 새로운 브랜치 삭제 임시로 만든 temp 라는 브랜치를 삭제합니다. 1git branch -d temp push 마지막으로 push 를 실행하면 됩니다. 1git push push 를 실행했을 때 다음과 같이 내용이 보이면 git push --set-upstream origin master 명령어를 사용해서 기본 브랜치를 설정합니다. 12345678D:\\project\\Study\\react&gt; git pushfatal: The current branch master has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin masterTo have this happen automatically for branches without a trackingupstream, see 'push.autoSetupRemote' in 'git help config'.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"}]},{"title":"Chocolatey를 이용한 Flutter 설치 방법","slug":"flutter-1","date":"2023-04-25T01:58:13.000Z","updated":"2023-06-15T01:29:40.530Z","comments":true,"path":"2023/04/25/flutter-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/25/flutter-1/","excerpt":"","text":"윈도우 환경에서 Chocolatey 를 이용해서 Flutter 를 설치하고 안드로이드 기기와 연결하는 방법에 대해 알아보겠습니다. 1. Chocolatey 설치 이전 글 Chocolatey 설치 를 참고해서 Chocolatey 를 먼저 설치를 합니다. 2. Flutter 설치 관리자 권한으로 PowerShell 을 열고 다음 명령어를 실행하여 설치를 합니다. 1choco install flutter 설치가 완료되면 flutter 명령어를 실행하였을 때 다음과 같이 메시지가 나옵니다. 12345678910111213C:\\Windows\\system32&gt; flutterCommon commands: flutter create &lt;output directory&gt; Create a new Flutter project in the specified directory. flutter run [options] Run your Flutter application on an attached device or in an emulator....Run \"flutter help &lt;command&gt;\" for more information about a command.Run \"flutter help -v\" for verbose help output, including less commonly used options. 3. 안드로이드 연결 안드로이드 앱을 개발하려고 한다면 Android setup 사이트에 접속해서 가이드대로 Android 에뮬레이터를 설치하고 연결하면 됩니다. 설치 방법은 아래 기술하였습니다. 1) Android Studio 설치 https://developer.android.com/studio 사이트에 접속해서 Android Studio 를 다운로드 합니다. 다운로드가 완료되면 설치를 진행합니다. 2) Android SDK 빌드 도구 설치 Android Studio 를 시작하고 ‘Android Studio Setup Wizard’ 를 진행합니다. 이렇게 하면 Android 용으로 개발할 때 Flutter 에 필요한 최신 Android SDK, Android SDK Command-line Tools 및 Android SDK Build-Tools 가 설치됩니다. PowerShell 에서 flutter doctor 명령어를 실행해서 Flutter 가 설치된 Android Studio 를 찾았는지 확인합니다. 1234567891011121314151617C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[!] Android toolchain - develop for Android devices (Android SDK version 33.0.2) X cmdline-tools component is missing Run `path/to/sdkmanager --install \"cmdline-tools;latest\"` See https://developer.android.com/studio/command-line for more details. X Android license status unknown. Run `flutter doctor --android-licenses` to accept the SDK licenses. See https://flutter.dev/docs/get-started/install/windows#android-setup for more details.[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (3 available)[√] Network resources 3) Android 에뮬레이터 설정 Android 에뮬레이터에서 Flutter 앱을 실행하고 테스트할 준비를 하려면 다음 단계를 진행합니다. Machine 에서 VM acceleration 를 활성화합니다. Android Studio 를 실행하고 Tools &gt; Device Manager 메뉴를 클릭하거나 Device Manager 아이콘을 클릭한 다음 Virtual 탭 에서 Create Device 를 선택합니다. 이전 버전의 Android Studio 에서는 대신 Android Studio &gt; Tools &gt; Android &gt; AVD Manager 를 실행 하고 Create Virtual Device 를 선택해야 합니다. (Android 하위 메뉴는 Android 프로젝트 내부에만 있습니다.) 열려 있는 프로젝트가 없으면 점 3개 Menu / More Actions &gt; Virtual Device Manager 메뉴를 클릭한 다음 Create Device 를 선택할 수 있습니다. Visual Device Configuration 창에서 장치를 선택하고 Next 버튼을 클릭합니다. (저는 Pixel 3 XL 모델을 선택했습니다.) 에뮬레이션하려는 Android 버전의 시스템 이미지를 하나 이상 선택하고 Next 버튼을 클릭합니다. x86 또는 x86_64 이미지를 권장합니다. Verify Configuration 에서 하단에 Emulated Performance 에서 Graphics 를 Hardware-GLES 2.0 으로 선택 후 Finish 버튼을 클릭하여 하드웨어 가속을 활성화합니다. Android Virtual Device Manager 의 도구 모음에서 실행(▶)을 클릭합니다. 에뮬레이터가 시작되고 선택한 OS 버전 및 장치에 대한 기본 캔버스를 표시합니다. 4) Android 라이선스에 동의 Flutter 를 사용하려면 먼저 Android SDK 플랫폼의 라이선스에 동의해야 합니다. 이 단계는 위에 나열된 도구를 설치한 후에 수행해야 합니다. 자바 8 버전 이상이 설치되어 있고 JDK 의 폴더가 환경 변수 설정되어 있는지 확인합니다. PowerShell 또는 명령 프롬프트에서 다음 명령어를 실행하여 라이언스 서명을 시작합니다. 1flutter doctor --android-licenses 에러 발생 해결 방법 123C:\\WINDOWS\\system32&gt; flutter doctor --android-licensesAndroid sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed toresolve this. 만약 cmdline-tools 가 없으므로 설치하라는 빨간 메시지가 출력된다면 다음의 절차를 진행합니다. Android Studio 에서 SDK Manager 를 실행합니다. 좌측의 System Settings 에서 Android SDK 를 선택하고 우측 화면에서 SDK Tools 탭을 선택합니다. Android SDK Command-line Tools(latest) 를 체크한 후 OK 버튼을 클릭해 설치를 진행합니다. 설치가 완료되었다면 Finish 를 클릭하고 flutter doctor --android-licenses 명령어를 다시 입력합니다. 이때 동의에 대해 묻는데 y 입력해주시면 됩니다. All SDK package licenses accepted 메시지가 출력 되면 라이센스 동의가 끝났습니다. 1234C:\\WINDOWS\\system32&gt; flutter doctor --android-licenses...Accept? (y/N): yAll SDK package licenses accepted 5) 확인 라이선스 동의가 완료되면 flutter doctor 명령어를 다시 입력하여 Flutter 를 사용할 준비가 되었는지 확인합니다. 1234567891011C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[√] Android toolchain - develop for Android devices (Android SDK version 33.0.2)[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (4 available)[√] Network resources 에러 발생 해결 방법 flutter doctor 명령어를 실행하였을 때 Windows 10 SDK 이 없다고 하는 메시지가 출력될 경우 해결 방법입니다. https://visualstudio.microsoft.com/ko/downloads/ 사이트에서 Visual Studio 2022 버전의 무료 다운로드를 클릭하여 다운로드하고 설치해줍니다. Visual Studio Installer 창이 열리면 데스크톱 및 모바일에서 C++를 이용한 데스크톱 개발을 선택 후 설치합니다. 결론 Chocolatey 를 사용해서 Flutter 를 설치하면 zip 파일을 다운받고, 열어서 설치하고, path 설정하고, 여러가지 설정하는 것보다 훨씬 쉬운 방법입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"}]},{"title":"[Dart] 클래스(Class) 사용 방법","slug":"dart-6","date":"2023-04-18T04:55:52.000Z","updated":"2023-06-15T01:29:24.925Z","comments":true,"path":"2023/04/18/dart-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/18/dart-6/","excerpt":"","text":"Dart 에서 클래스(Class) 사용 방법에 대해 알아보겠습니다. Class 클래스 안에서 property 를 선언할 때는 타입을 사용해서 정의합니다. 1234567891011121314class Player &#123; final String name = 'eden'; final int age = 3; void sayName() &#123; print(\"Hi my name is $name\"); &#125;&#125;void main() &#123; // new 를 꼭 붙이지 않아도 됩니다. var player = Player(); player.sayName();&#125; 클래스 메서드 안에서는 this 를 붙이지 않는 것을 Dart 에서는 권장하나, 어쩔 수 없이 같은 변수명이 있을 때는 this 를 붙여서 사용해야 합니다. Constructor 생성자(constructor) 함수는 클래스 이름과 같아야 합니다. 123456789101112131415class Player &#123; // late 사용 late final String name; late final int age; Player(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;void main() &#123; // Player 클래스의 인스턴스 생성 var player = Player(\"eden\", 3);&#125; 위의 생성자 함수는 다음과 같이 줄일 수 있습니다. 1234567class Player &#123; // late 사용 안함 final String name; final int age; Player(this.name, this.age);&#125; 위의 코드는 late 를 사용하였지만 아래 코드에서 사용하지 않은 이유는 생성자 함수를 만들 때 변수에 값을 할당하지 않았기 때문입니다. 이전 생성자 함수를 만들 때에는 this.name = name; 식으로 값을 할당했기 때문에 먼저 선언한 변수에 late 를 붙여야 오류가 발생하지 않습니다. Named Constructor Parameters 클래스가 거대해질 경우 다음과 같이 생성자 함수를 만드는 것은 비효율적일 것입니다. 많은 파라미터를 받아야 하고 각 파라미터의 의미를 알 수가 없습니다. 123456789101112class Team &#123; final String name; int members; int ranking; String description; Team(this.name, this.members, this.ranking, this.description);&#125;void main() &#123; var team = Team(\"Tottenham\", 25, 5, \"Tottenham Hotspur Football Club\");&#125; 문제를 해결할려면 너무 간단합니다. 생성자 함수 생성할 때 중괄호({})를 사용하는 것입니다. 그리고 클래스를 정의할 때 Named Paramaters 를 사용합니다. 12345678910111213141516class Team &#123; final String name; int members; int ranking; String description; Team(&#123;this.name, this.members, this.ranking, this.description&#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; 하지만 여기에는 큰 문제가 있습니다. 변수가 null 일 수도 있기 때문에 기본 값(default value)을 주거나 required 파라미터 앞에 붙여 사용합니다. 다음의 코드는 required 를 사용하였습니다. 123456789101112131415161718192021class Team &#123; final String name; int members; int ranking; String description; Team(&#123; required this.name, required this.members, required this.ranking, required this.description &#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; Named Constructor 콜론(:)을 사용하면 특별한 생성자 함수를 만들 수 있습니다. 콜론을 넣음으로써 dart 에게 객체를 초기화하라고 명령할 수 있습니다. 12345678910111213141516171819class Team &#123; String name; int members; String description; Team(&#123;required this.name, required this.members, required this.description&#125;); Team.createTeam(&#123;required String name, required int members&#125;) : this.name = name, this.members = members, this.description = \"$name team is good.\";&#125;void main() &#123; var team = Team.createTeam( name: \"Tottenham\", members: 25, );&#125; Enum Enum 은 우리가 코드를 작성할 때 실수를 하지 않게 도와줍니다. enum type 의 변수들은 해당 enum type 에 생성된 값들 중에서만 값이 할당될 수 있습니다. 123456789101112enum Team &#123; red, blue &#125;class Player &#123; String name; Team team; Player(&#123;required this.name, required this.team&#125;);&#125;void main() &#123; var player = Player(name: 'eden', team: Team.red);&#125; Abstract Class 추상 클래스는 다른 클래스들이 직접 구현해야 하는 필드와 메소드들을 모아놓은 클래스입니다. 추상 클래스는 아직 메소드와 내용이 추상적이므로 객체를 생성할 수 없습니다. 추상 클래스를 상속받는 클래스들은 추상 클래스의 메소드들을 구현해야 합니다. 12345678910111213141516171819abstract class Person &#123; void walk();&#125;class Player extends Person &#123; String name; String team; Player(&#123;required this.name, required this.team&#125;); void walk() &#123; print(\"Player is walking\"); &#125;&#125;void main() &#123; var player = Player(name: 'eden', team: 'red'); player.walk();&#125; Mixin Mixin 은 생성자가 없는 클래스를 의미합니다. Mixin 은 클래스에 코드를 재사용하기 위해 사용되며, 다중 상속의 일부 단점을 보완합니다. Mixin 은 extends 가 아닌 with 키워드를 사용하여 클래스에 적용합니다. 1234567891011121314151617181920212223242526mixin Strong &#123; final double strengthLevel = 100.5;&#125;mixin Tall &#123; final double height = 180;&#125;mixin QuickRunner &#123; void run() &#123; print(\"run!!\"); &#125;&#125;class Player with Strong, Tall, QuickRunner &#123; final String name; Player(&#123;required this.name&#125;);&#125;void main() &#123; var player = Player( name: \"eden\", ); player.run(); // run!! 출력&#125; 상속과 Mixin 의 차이점 extends 를 사용하여 상속받은 클래스는 자식 클래스, 상속한 클래스는 부모클래스가 되는 것이고, 자식 클래스는 부모 클래스를 super 를 통해서 접근할 수 있습니다. Mixin 은 with 라는 키워드를 통해서 단순히 Mixin 내부의 프로퍼티와 메소드들을 가져오는 것 뿐입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"}]},{"title":"[Dart] 함수(Function) 사용 방법","slug":"dart-5","date":"2023-04-17T05:57:34.000Z","updated":"2023-06-05T00:44:10.357Z","comments":true,"path":"2023/04/17/dart-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-5/","excerpt":"","text":"Dart 에서 함수(Function) 사용 방법에 대해 알아보겠습니다. Functions Dart 는 진정한 객체 지향 언어이므로 함수도 객체이며 타입이 Function 입니다. 이는 함수를 변수에 할당하거나 다른 함수에 인수로 전달할 수 있음을 의미합니다. 12345678// 하나의 표현식만 포함하는 함수의 경우 아래와 같이 단축 구문을 사용할 수 있습니다.String sayHello(String name) =&gt; \"Hello $&#123;name&#125; nice to meet you!\";num plus(num a, num b) =&gt; a + b;void main() &#123; print(sayHello(\"eden\")); // Hello eden nice to meet you!&#125; Positional Paramaters 함수을 호출할 때 필요한 매개변수와 매개변수의 위치를 정확하게 알아야 합니다. 함수의 매개변수가 많아 질수록 함수 호출할 때 다 기억해야 하므로 사용하기 어렵습니다. 1234567String sayHello(String name, int age, String country) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello('eden', 30, 'Korea'));&#125; Named Paramaters 위의 Positional Paramaters 방식은 함수를 호출할 때 사용자가 요소들의 순서를 잊어버릴 수도 있고, 코드를 봤을 때 인자가 뜻하는 것이 무엇인지 바로 이해를 못할 수도 있습니다. 이 문제를 해결하기 위해 Dart 에서는 Named Paramaters 를 지원합니다. 다음과 같이 매개변수 앞뒤로 중괄호를 붙여주면 함수를 호출할 때 매개변수의 이름과 값을 함께 입력할 수 있어 사용자에게 훨씬 편리합니다. 이때 매개변수들의 순서는 지키지 않아도 됩니다. 1234567String sayHello(&#123;String name, int age, String country&#125;) &#123; return \"$&#123;name&#125; / $&#123;age&#125; / $&#123;country&#125;\";&#125;void main() &#123; print(sayHello(name: \"eden\", age: 30, country: \"Korea\"));&#125; 하지만 여기서 또 문제가 발생합니다. Dart 는 null safety 가 적용되는데, 매개변수 중 하나가 null 일 수도 있기 때문입니다. 다시 말해, 사용자가 name 과 age, country 3개의 매개변수 중 하나라도 빼고 보낼 수 있습니다. 이때는 두 가지 옵션이 있습니다. default value 1234567891011String sayHello(&#123; String name = 'ko', int age = 99, String country = 'Italy',&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello());&#125; 함수를 호출할 때 아무것도 전달하지 않아도 default value 가 이미 있으므로 null safety 에 걸릴 일이 없습니다. required 다음과 같이 매개변수 앞에 required 를 적어주면, 함수가 호출될 때 반드시 required 가 적힌 매개변수가 포함되어야 한다는 것입니다. 123456789101112String sayHello(&#123; required String name, required int age, required String country&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(🚫sayHello()); // name, country, age가 모두 포함되어야 하기 때문에 dart에서 컴파일하지 않음&#125; Optional Positional Paramaters Dart 에서 [] 은 optional, positional parameter 를 명시할 때 사용됩니다. name, age 는 필수값이고 []를 통해 country 를 optional 값으로 지정해줄 수 있습니다. 12345678String sayHello(String name, int age, [String? country = \"Korea\"]) &#123; return 'Hello $&#123;name&#125;, You are $&#123;age&#125; from the $&#123;country&#125;';&#125;void main() &#123; var result = sayHello(\"eden\", 3); print(result); // Hello eden, You are 3 from the Korea&#125; QQ Operator ?? 연산자를 이용하면 왼쪽 값이 null 인지 체크해서 null 이 아니면 왼쪽 값을 리턴하고 null 이면 오른쪽 값을 리턴합니다. 12345678String capitalizeName(String? name) &#123; return name?.toUpperCase() ?? \"NONE\";&#125;void main() &#123; print(capitalizeName(\"eden\")); // EDEN; print(capitalizeName(null)); // NONE&#125; 위의 코드를 더욱 간략하게 만들 수 있습니다. 1String capitalizeName(String? name) =&gt; name?.toUpperCase() ?? \"NONE\"; ??= 연산자를 이용하면 변수 안에 값이 null 일 때를 체크해서 값을 할당해줄 수 있습니다. 1234567void main() &#123; String? name; name ??= \"eden\"; name = null; name ??= \"ko\"; print(name); // ko&#125; TypeDef 자료형에 사용자가 원하는 alias 를 붙일 수 있게 해줍니다. (자료형 이름의 별명을 만들 때 사용) 12345// 사용 전List reverseListOfNumbers(List list) &#123; var reversed = list.reversed; return reversed.toList();&#125; 1234567891011// 사용 후typedef ListOfInts = List;ListOfInts reverseListOfNumbers(ListOfInts list) &#123; var reversedList = list.reversed.toList(); return reversedList;&#125;void main() &#123; print(reverseListOfNumbers([1, 2, 3])); // [3, 2, 1]&#125; 참고 https://dart.dev/guides/language/language-tour#functions https://dart.dev/guides/language/language-tour#parameters https://dart.dev/guides/language/language-tour#typedefs","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"}]},{"title":"[Dart] Data Types","slug":"dart-4","date":"2023-04-17T05:07:53.000Z","updated":"2023-05-18T05:57:23.332Z","comments":true,"path":"2023/04/17/dart-4/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-4/","excerpt":"","text":"Dart 에서 데이터 타입 사용 방법에 대해 알아보겠습니다. 기본 데이터 타입 Dart 에는 대표적으로 String, bool, int, double, num 타입이 있습니다. 중요한 점은 이 모든게 객체(object)라는 것 입니다. Dart 가 진정한 객체 지향 언어로 불리는 이유입니다. 12345678void main() &#123; String name = \"eden\"; bool isPlay = true; int age = 3; double money = 59.99; num x = 12; num y = 1.2;&#125; String Interpoldation String Interpoldation 은 텍스트에 변수를 추가하는 방법입니다. 단순히 변수의 값을 넣고 싶다면 $달러 기호 뒤에 사용할 변수를 적어주면 됩니다. 변수의 값을 계산하고 싶다면 $와 함께 중괄호(`${ })내에 계산할 내용을 적어주면 됩니다. 123456void main() &#123; var name = \"eden\"; var age = 3; var greeting = \"hello $name, I'm $&#123;age + 5&#125; years old.\"; print(greeting);&#125; Lists Dart 에서 List 를 선언하는 것은 두 가지 방법이 있습니다. 123456void main() &#123; List&lt;int&gt; numbers = [1, 2, 3]; numbers.add(4); var number2 = [4, 5, 6];&#125; Dart 에서 List 의 유용한 점은 collection if 와 collection for 를 지원합니다. collection if collection if 는 List 를 만들 때, if 를 통해 존재할 수도 안 할 수도 있는 요소를 가지고 만들 수 있습니다. 1234567891011void main() &#123; var giveMeFive = true; var item = [ 1, 2, 3, 4, if (giveMeFive) 5, // giveMeFive가 true이면 5가 추가됨 ]; print(item);&#125; Collection For Dart 에서는 반복(for)을 사용하여 컬렉션을 구축하는 데 사용할 수 있는 Collection for 를 제공합니다. 12345678910void main() &#123; var oldFriends = [\"ko\", \"lee\"]; var newFriends = [ \"eden\", \"woorim\", for (var friend in oldFriends) \"🥰 $friend\" ]; print(newFriends); // [eden, woorim, 🥰 ko, 🥰 lee]&#125; Maps 일반적으로 Map 은 key 와 value 를 연결하는 객체입니다. 키와 값 모두 모든 유형의 객체가 될 수 있습니다. 각 키는 한 번만 발생하지만 동일한 값을 여러 번 사용할 수 있습니다. Map 을 정의하는 방법은 두 가지가 있습니다. 첫 번째는 var 를 이용한 방법입니다. 두 번째는 var 대신 Map 을 사용하고, 자료형을 명시하는 것입니다. 1234567891011121314// 첫 번째var gifts = &#123; // Key: Value 'first': 'smartphone', 'second': 'laptop', 'third': 'bicycle'&#125;;// 두 번째Map players = &#123; 1 : true, 2 : false, 3 : true,&#125;; 12345// Map 생성자를 사용하여 동일한 객체를 만들 수 있습니다.var gifts = Map();gifts['first'] = 'smartphone';gifts['second'] = 'laptop';gifts['third'] = 'bicycle'; Sets Set 에 속한 모든 아이템들이 유니크해야될 때 사용합니다. 유니크할 필요가 없다면 List 를 사용하면 됩니다. Set 도 두 가지 방법으로 정의할 수 있습니다. 12345678910void main() &#123; var numbers1 = &#123;1, 2, 3&#125;; Set numbers2 = &#123;1, 2, 3&#125;; Set&lt;int&gt; numbers3 = &#123;1, 2, 3&#125;; numbers3.add(1); numbers3.add(2); numbers3.add(4); print(numbers3) // &#123;1, 2, 3, 4&#125;&#125; List 는 대괄호를 쓰며 Set 은 중괄호를 쓴다는 점이 다릅니다. List 는 같은 요소가 여러개 반복될 수 있지만, Set 은 중복이 허용되지 않습니다. 참고 https://dart.dev/guides/language/language-tour#collection-operators https://dart.dev/guides/language/language-tour#maps https://dart.dev/guides/language/language-tour#sets","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"}]},{"title":"[Dart] Null Safety","slug":"dart-3","date":"2023-04-14T05:10:05.000Z","updated":"2023-04-17T08:02:18.420Z","comments":true,"path":"2023/04/14/dart-3/","link":"","permalink":"http://hgko1207.github.io/2023/04/14/dart-3/","excerpt":"","text":"Null Safety 는 개발자가 null 값을 참조할 수 없게 하는 것입니다. 다음 코드를 봅시다. 123456bool isEmpty(String string) =&gt; string.length == 0;main()&#123; // [오류] isEmpty(🚫null);&#125; 다음과 같은 코드는 어떻게 실행될까요? 정답은 NoSuchMethodError 를 실행합니다. 왜 이렇게 실행될까요? 바로 String 을 보내야 할 곳에 null 을 보냈기 때문입니다. null 에는 length 라는 속성이 없기 때문이기도 합니다. 이와 같은 에러는 컴파일러에서 잡을 수 있는 에러가 아닙니다. 이런 상황이 발생하지 않도록 null 를 삭제하기에는 null 값은 유용합니다. 그럼 어떻게 null 값을 참조하는 것을 dart 는 어떻게 보호할까요? dart 에서는 변수가 null 이 될 수 있음을 명확히 표시해야합니다. 다음 코드를 봅시다. 1234void main() &#123; String name = \"eden\"; 🚫name = null;&#125; 이 코드는 에러가 납니다. name 이 null 값을 참조할 수 있다고 알려주지 않고 null 값을 참조하기 때문입니다. 그러면 다음 코드를 봅시다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; 이 코드는 에러가 나지 않습니다. 차이점이 뭘까요? 바로 변수 뒤에 ?를 사용해 이 변수에는 null 이 참조될 수 있음을 알려주는 것입니다. 만약 ?를 붙인 변수는 이 변수가 null 인지 아닌지 확인해야 합니다. 12345678void main() &#123; String? name = \"eden\"; name = null; if (name != null) &#123; print(name.length); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"}]},{"title":"[Dart] 변수(Variable) 사용 방법","slug":"dart-2","date":"2023-04-13T02:09:29.000Z","updated":"2023-05-11T01:30:30.536Z","comments":true,"path":"2023/04/13/dart-2/","link":"","permalink":"http://hgko1207.github.io/2023/04/13/dart-2/","excerpt":"","text":"Dart 에서 변수 사용 방법에 대해 알아보겠습니다. 변수를 만드는 2가지 방법 dart 에서는 변수를 var 키워드 또는 명시적으로 변수의 타입을 지정해서 사용합니다. 다른 타입의 변수는 서로 대입할 수 없습니다. 1234567// 방법 1void main() &#123; var name = \"car\"; name = \"bus\"; // [오류] 🚫 name = 1;&#125; 12345// 방법 2void main() &#123; String name = \"car\"; name = \"bus\";&#125; var 를 사용하는게 dart 스타일가이드의 권장 방식입니다. 함수나 메소드 내부에 지역변수를 선언할 때는 var 를 사용하고 class 에서 변수나 property 를 선언할 때는 타입을 지정해줍니다. Dynamic 타입 여러가지 타입을 가질 수 있는 변수에 쓰는 키워드입니다. 변수를 선언할 때 dynamic 을 쓰거나 값을 지정하지 않으면 dynamic 타입을 가집니다. 1234void main() &#123; dynamic name; var name2;&#125; 123456void main() &#123; var name; name = 'car'; name = 1; name = true;&#125; dynamic 타입은 언제 사용될까? 해당 변수의 타입을 알 수 없을 때 주로 사용합니다. 예를 들어 json 을 작업할 경우입니다. 하지만 dynamic 타입은 다양한 타입을 가질 수 있기 때문에 정말 필요할 때만 사용해야 합니다. (위험 방지) Null Safety null safety 는 개발자가 null 값을 참조할 수 없도록 하는 것입니다. String 뒤에 ?를 붙여줌으로서 name 이 String 또는 null 이 될 수 있다고 명시해준 것입니다. 기본적으로 모든 변수는 non-nullable(null이 될 수 없음)입니다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; final 변수 var 대신 final 로 변수를 만들게 되면 이 변수는 수정할 수 없게 됩니다. (딱 한 번만 설절될 수 있음) 자바스크립트의 const 랑 비슷합니다. 1234567void main() &#123; final name = \"pizza\"; 🚫name = \"ham\"; // 수정 불가 final String username = \"eden\"; 🚫name = \"eden2\"; // 수정 불가&#125; late 변수 초기 데이터 없이 먼저 변수를 생성하고 추후에 데이터를 넣을 때 주로 사용합니다. flutter 로 data fecthing 을 할 때 유용합니다. late 변수를 만들고, API 에 요청을 보낸 뒤에 API 에서 값을 보내주면 그 응답 값을 late 변수에 넣어 사용할 수 있습니다. 123456789void main() &#123; late final String name; 🚫print(name); // 값을 넣기 전에는 name 변수에 접근 불가 // do something, go to api name = 'api'; // 한번만 할당해 줄 수 있음 🚫name = 'test';&#125; const 변수 dart 에서 const 는 compile-time constant 를 만들어줍니다. const 는 컴파일할 때 알고 있는 값을 사용해야 합니다. 만약 어떤 값인지 모르고, 그 값이 API 로부터 오거나 사용자가 화면에서 입력해야 하는 값이라면 그건 const 가 아닌 final 이나 var 가 되어야 합니다. 1234567void main() &#123; // 컴파일 시점에 바뀌지 않는 값 const API_KEY = \"********\"; // 컴파일 시점에 바뀌는 값 final API = fetchAPI();&#125; const: 컴파일 시점에 바뀌지 않는 값 (상수) final: 컴파일 시점에 바뀌는 값 (API 에서 받아온 값, 사용자 입력값)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"}]},{"title":"[Dart] 시작하기","slug":"dart-1","date":"2023-04-12T01:35:46.000Z","updated":"2023-05-08T01:06:13.237Z","comments":true,"path":"2023/04/12/dart-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/12/dart-1/","excerpt":"","text":"Dart 란 Dart 는 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다. UI 최적화용 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발합니다. 생산적인 개발 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인 가능합니다. 모든 플랫폼에서 빠름 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript 로 컴파일합니다. Why Dart Dart 의 컴파일러 기술을 사용하면 다양한 방식으로 코드를 실행할 수 있습니다. 기본 플랫폼(Dart Native): 모바일 및 데스크톱 장치를 대상으로 하는 앱의 경우 Dart 에는 JIT(Just-In-Time) 컴파일 기능이 있는 Dart VM 과 기계 코드 생성을 위한 AOT(Ahead-of-Time) 컴파일러가 모두 포함되어 있습니다. 웹 플랫폼(Dart Web): 웹을 대상으로 하는 앱의 경우 Dart 는 개발 또는 프로덕션 목적으로 컴파일할 수 있습니다. 웹 컴파일러는 Dart 를 JavaScript 로 변환합니다. 또 다른 특징 null safety 특성을 가집니다. c 또는 java 에서 null 참조하면 오류가 발생합니다. flutter, dart 둘 다 구글에서 개발 한 것입니다. 즉 flutter 의 성능 향상을 위해 dart 를 최적화 할 수 있습니다. flutter 가 dart 에 대해 뭔가 필요한 게 있으면, flutter 를 위해 dart 를 수정할 수 있습니다. react-native, django, flask 등 다른 프레임워크들은 사용하는 언어를 수정할 수 없다는 점이 다릅니다. main 함수 main 함수는 모든 Dart 프로그램의 Entry point 입니다. main 함수에서 쓴 코드가 호출됩니다. (만약 main 함수가 없다면 실행이 되지 않음) dart 는 자동으로 세미콜론을 붙여주지 않기 때문에 직접 붙여야 합니다. (일부러 세미콜론을 안 쓸 때가 있기 때문입니다.) 123void main() &#123; print(\"hello world\");&#125; Flutter Flutter 프레임워크는 인기 있는 다중 플랫폼 UI 툴킷으로 Dart 플랫폼으로 구동되며 iOS, Android, macOS, Windows, Linux 및 웹에서 실행되는 UI 경험을 빌드하기 위한 도구 및 UI 라이브러리를 제공합니다. 참고 https://dart.dev/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"}]},{"title":"[TypeScript] JSDoc Reference 사용 방법","slug":"typescript-7","date":"2023-04-11T05:53:58.000Z","updated":"2023-06-05T00:43:58.865Z","comments":true,"path":"2023/04/11/typescript-7/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-7/","excerpt":"","text":"JavaScript 파일에서 TypeScript 처럼 코드를 보호받을 수 있도록 하는 방법에 대해 알아보겠습니다. @ts-check JavaScript 파일에서 오류를 활성화하려면 // @ts-check를 .js 파일의 첫 번째 줄에 추가하여 TypeScript 가 오류를 발생시키도록 합니다. TypeScript 는 여러 오류를 제공할 수 있습니다. 아래 코드는 TypeScript 와 같이 함수 파라미터에 정의가 되어 있지 않아 오류가 발생합니다. 1234567891011// @ts-check// [오류]export function init(🚫 config) &#123; return true;&#125;// [오류]export function exit(🚫 code) &#123; return code + 1;&#125; 이러한 오류를 무시하고 싶다면 // @ts-ignore 또는 // @ts-expect-error를 추가하여 특정 줄의 오류를 무시할 수 있습니다. JSDoc Reference JSDoc 주석을 사용하여 JavaScript 파일에 type 정보를 제공할 수 있습니다. (자바스크립트 파일에서 타입 정보를 제공할 수 있습니다.) 123456789101112131415161718192021// @ts-check/** * Initializes the project * @param &#123;object&#125; config * @param &#123;boolean&#125; config.debug * @param &#123;string&#125; config.url * @returns &#123;boolean&#125; */export function init(config) &#123; return true;&#125;/** * Exits the program * @param &#123;number&#125; code * @returns &#123;number&#125; */export function exit(code) &#123; return code + 1;&#125; JSDoc 주석을 통해 타입을 정의하고 TypeScript 파일에서 다음과 같이 함수를 사용할 수 있습니다. 123456init(&#123; debug: false, url: 'true',&#125;);exit(1); 주의 사항 @ts-check를 사용하면 JavaScript 파일 내에서 타입 검사를 허용합니다. @ts-check 를 사용하지 않고 JSDoc 만 사용하면 TypeScript 파일에서는 JavaScript 의 타입을 검사 하지만, JavaScript 내에서는 단순 주석이나 타입을 명시하는 정도로만 사용할 수 있는 것 같습니다 참고 https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"}]},{"title":"[TypeScript] 설치 및 설정 방법","slug":"typescript-6","date":"2023-04-11T02:10:23.000Z","updated":"2023-05-30T14:24:21.972Z","comments":true,"path":"2023/04/11/typescript-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-6/","excerpt":"","text":"NextJS, Create React App(CRA) 를 사용하지 않고 초기 프로젝트에 TypeScript 를 설치하고 설정하는 방법에 대해 알아보겠습니다. 프로젝트 시작 프로젝트 디렉터리를 생성합니다. 12$ mkdir typescripttest$ cd typescripttest 다음 명령어를 실행하여 package.json 을 초기화합니다. 1$ npm init -y TypeScript 설치 다음 명령어를 실행하여 TypeScript 를 설치합니다. 1$ npm i -D typescript tsconfig.json 설정 TypeScript 설정은 tsconfig.json 파일에서 합니다. 디렉터리에 tsconfig.json 파일이 있으면 해당 디렉터리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일과 컴파일러 옵션을 지정합니다. tsconfig.json 파일을 생성합니다. 다음과 같이 기본적인 설정을 작성합니다. 1234567// tsconfig.json&#123; \"include\": [\"src\"], // 자바스크립트로 컴파일 하고 싶은 모든 디렉터리 \"compilerOptions\": &#123; \"outDir\": \"build\" // 자바스크립트 파일로 생성될 디렉터리(빌드 디렉터리) &#125;&#125; 다음 명령어로도 기본적인 tsconfig.json 파일 생성이 가능합니다. 12$ npm i -g typescript$ tsc --init Target (기본값: ES3) 최신 브라우저는 모든 ES6 기능을 지원하므로 ES6 는 좋은 선택입니다. 코드가 이전 환경에 배포된 경우 더 낮은 target 을 설정하거나 최신 환경에서 코드 실행이 보장되는 경우 더 높은 target 을 설정하도록 선택할 수 있습니다. 12345678// tsconfig.json&#123; \"include\": [\"src\"], \"compilerOptions\": &#123; \"outDir\": \"build\", \"target\": \"ES6\" &#125;&#125; Lib(라이브러리) 타입스크립트에게 어떤 API를 사용하고 어떤 환경에서 코드를 실행하는 지를 지정할 수 있습니다. (target 런타임 환경이 무엇인지를 지정합니다.) 프로그램이 브라우저에서 실행되면 lib에 “DOM” 유형 정의를 할 수 있습니다. DOM: window, document 등 123456// ex)&#123; \"compilerOptions\": &#123; \"lib\": [\"ES6\", \"DOM\"] &#125;&#125; strict 모든 엄격한 타입 검사 옵션을 활성화합니다. strict 플래그는 프로그램 정확성을 더 강력하게 보장하는 광범위한 타입 검사 동작을 가능하게 합니다. tsconfig.json 에서 &quot;strict&quot;: true 를 통해 strict mode 로 해주면, Declaration Files 가 없는 경우에 대해서도 에러를 띄워줍니다. 12345&#123; \"compilerOptions\": &#123; \"strict\": true &#125;&#125; 참고 https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content https://www.typescriptlang.org/tsconfig#target https://www.typescriptlang.org/tsconfig#lib https://www.typescriptlang.org/tsconfig#strict","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"}]},{"title":"[TypeScript] 인터페이스(Interface) 사용 방법","slug":"typescript-5","date":"2023-04-06T14:20:26.000Z","updated":"2023-04-17T08:04:51.321Z","comments":true,"path":"2023/04/06/typescript-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/06/typescript-5/","excerpt":"","text":"TypeScript 에서 인터페이스(Interface)를 생성하고 사용하는 방법에 대해 알아보겠습니다. Interfaces 객체의 모양을 특정해주기 위해 사용합니다. 여기서는 firstName 및 lastName 필드가 있는 객체를 설명하는 인터페이스를 사용합니다. 1234interface Person &#123; firstName: string; lastName: string;&#125; 다른 인터페이스를 상속 받아 사용할 수 있습니다. 123456789interface User &#123; name: string;&#125;interface Player extends User &#123;&#125;const eden: Player = &#123; name: 'eden',&#125;; 인터페이스 이름이 같도록 3번 각각 만들어도 타입스크립트는 알아서 하나로 합쳐줍니다. Type 과 차이점입니다. 1234567891011121314151617interface User &#123; name: string;&#125;interface User &#123; nickname: string;&#125;interface User &#123; age: number;&#125;const eden: User = &#123; name: 'eden', nickname: 'ko', age: 30,&#125;; implements implements 을 사용하여 클래스가 특정 인터페이스를 충족하는지 확인할 수 있습니다. 클래스를 올바르게 구현하지 못하면 오류가 발생합니다. implements 절은 클래스가 인터페이스 유형으로 처리될 수 있는지 확인하는 것입니다. 클래스의 유형이나 메서드는 전혀 변경하지 않습니다. 또한 클래스는 여러 인터페이스를 구현할 수도 있습니다. 12// ex) 클래스 C 는 A, B 를 구현합니다.class C implements A, B &#123;&#125; 1234567891011interface Pingable &#123; ping(): void;&#125;// Sonar 클래스는 Pingable 인터페이스를 implement 했기 때문에// Pingable 가 가진 ping 메서드를 구현해줘야 합니다.class Sonar implements Pingable &#123; ping() &#123; console.log('ping!'); &#125;&#125; 여러 개의 인터페이스를 상속받아 사용할 수 있습니다. 123456789101112interface User &#123; firstName: string; lastName: string;&#125;interface Human &#123; health: number;&#125;class Player implements User, Human &#123; constructor(public firstName: string, public lastName: string, public health: number) &#123;&#125;&#125; Type Aliases 과 Interfaces 의 차이점 Type Aliases 과 인터페이스는 매우 유사하며 많은 경우 자유롭게 선택할 수 있습니다. 인터페이스의 거의 모든 기능은 type 에서 사용할 수 있으며, 주요 차이점은 type 을 다시 열어 새 속성을 추가할 수 없는 것입니다. 반면 인터페이스는 항상 확장 가능합니다. 참고 https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[TypeScript] 클래스(Class) 사용 방법","slug":"typescript-4","date":"2023-03-29T05:20:34.000Z","updated":"2023-04-17T08:04:44.791Z","comments":true,"path":"2023/03/29/typescript-4/","link":"","permalink":"http://hgko1207.github.io/2023/03/29/typescript-4/","excerpt":"","text":"TypeScript 에서 클래스(Class)를 생성하고 사용하는 방법에 대해 알아보겠습니다. 클래스(Class) 가장 기본적인 클래스입니다. 1class Player &#123;&#125; 필드를 선언해서 사용 가능합니다. 12345678class Player &#123; firstname: string; lastname: string;&#125;const eden = new Player();eden.firstname = 'ko';eden.lastname = 'eden'; 생성자에 매개변수를 추가해서 선언할 수 있습니다. 1234567891011121314class Player &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123;&#125;&#125;const eden = new Player(\"ko\", \"eden\", \"고수\");// [오류]// firstname는 private 이기 때문에 접근 불가// javascript 에서는 아무 문제없이 작동함🚫 eden.firstname; public: 모든 클래스에서 접근 가능 private: 해당 클래스 내에서만 접근 가능 (자식 클래스에서도 접근 불가) protected: 해당 클래스와 자식 클래스에서 접근 가능 추상 클래스(Abstract Class) TypeScript 와 객체지향 프로그램이 가지고 있는 엄청 훌륭한 것은 추상 클래스(Abstract Class)라고 생각됩니다. 추상클래스는 다른 클래스가 상속받을 수 있는 클래스입니다. 하지만 이 클래스는 직접 새로운 인스턴스를 만들 수는 없습니다. 1234567891011121314151617abstract class User &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123; abstract getNickname(): void getFullName() &#123; return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;`; &#125; &#125;&#125;// [오류]// TypeScript 가 추상 클래스의 인스턴스를 만들 수 없다고 경고함🚫 const eden = new User(\"ko\", \"eden\", \"고수\"); 12345678910class Player extends User &#123; // 추상 메서드는 추상 클래스를 상속받는 클래스들이 반드시 구현(implement)해야하는 메서드입니다. getNickname() &#123; console.log(this.nickname); &#125;&#125;const eden = new Player('ko', 'eden', '고수');eden.getNickname();eden.getFullName(); 추상 클래스를 사용하기 위해서는 상속을 받아 사용합니다. Static Members 클래스에는 static 멤버가 있을 수 있습니다. 이 멤버는 클래스의 특정 인스턴스와 연결되지 않습니다. 클래스 생성자 객체 자체를 통해 액세스할 수 있습니다. static 멤버는 동일한 public, protected 및 private 과 함께 사용할 수도 있습니다. 12345678910class MyClass &#123; static x = 0; static printX() &#123; console.log(MyClass.x); &#125;&#125;console.log(MyClass.x);MyClass.printX(); 참고 https://www.typescriptlang.org/docs/handbook/2/classes.html https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"}]},{"title":"[TypeScript] 다형성(Polymorphism)","slug":"typescript-3","date":"2023-03-16T05:59:01.000Z","updated":"2023-04-06T14:22:33.449Z","comments":true,"path":"2023/03/16/typescript-3/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-3/","excerpt":"","text":"다형성(Polymorphism) 다형성이란, 여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미합니다. poly: many, serveral, much, multi 등과 같은 뜻 morphos: form, structure 등과 같은 뜻 polymorphos = poly + morphos: 여러 다른 구조 예시 123456789101112type SuperPrint = &#123; (arr: T[]): T;&#125;;const superPrint: SuperPrint = (arr) =&gt; &#123; return arr[0];&#125;;const a = superPrint([1, 2, 3]);const b = superPrint([true, false, true]);const c = superPrint(['a', 'b']);const d = superPrint([1, 2, 'a', 'b', true]); any, generics 차이점 any 를 사용하는 것은 어떤 타입이든 받을 수 있다는 점에서 generics 과 같지만 함수를 반환하는데 있어 any 는 받았던 인수들의 타입을 활용하지 못합니다. 즉, generics 은 어떤 타입이든 받을 수 있다는 점에서 any 와 같지만 해당 정보를 잃지 않고 타입에 대한 정보를 다른 쪽으로 전달할 수 있다는 점이 다릅니다. Generics 제네릭은 C# 이나 Java 와 같은 언어에서 재사용 가능한 컴포넌트를 만들기 위해 사용하는 기법입니다. 단일 타입이 아닌 다양한 타입에서 작동할 수 있는 컴포넌트를 생성할 수 있습니다. (구체적인 타입을 지정하지 않고 다양한 인수와 리턴 값에 대한 타입을 처리할 수 있습니다.) 타입스크립트에서 제네릭을 통해 인터페이스, 함수 등의 재사용성을 높일 수 있습니다. 1234567891011function identity&lt;Type&gt;(arg: Type): Type &#123; return arg;&#125;// 제네릭 화살표 함수 (tsx기준)const identity = &lt;Type extends &#123;&#125;&gt;(arg: Type): Type =&gt; &#123; return arg;&#125;;let output = identity&lt;string&gt;('myString'); // 첫 번째 방법let output = identity('myString'); // 두 번째 방법 위에서 두 번째 방법은 type argument inference(타입 인수 유추)를 사용합니다. 즉, 컴파일러가 전달하는 인수 유형에 따라 자동으로 Type 값을 설정하기를 원합니다. 참고 https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"}]},{"title":"[TypeScript] Function Overloads","slug":"typescript-2","date":"2023-03-16T05:47:52.000Z","updated":"2023-04-06T14:22:37.020Z","comments":true,"path":"2023/03/16/typescript-2/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-2/","excerpt":"","text":"Function Overloads 동일한 이름에 매개 변수와 매개 변수 타입 또는 리턴 타입이 다른 여러 버전의 함수를 만드는 것을 말합니다. TypeScript 에서는 오버로드 signatures 을 작성하여 **“다양한 방식으로 호출할 수 있는 함수”**를 지정할 수 있습니다. 사용 예제 매개변수의 데이터 타입이 다른 경우 매개변수의 데이터 타입이 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: string): number;&#125;;const add: Add = (a, b) =&gt; &#123; if (typeof b === 'string') return a; return a + b;&#125;;add(1, '2');add(1, 2); 매개변수의 수가 다른 경우 매개변수의 수가 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: number, c: number): number;&#125;;const add2: Add = (a, b, c?: number) =&gt; &#123; if (c) return a + b + c; return a + b;&#125;;add(1, 2);add(1, 2, 3); 참고 https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"}]},{"title":"[WPF] 문자열(string)의 가로 세로 길이 계산","slug":"wpf-10","date":"2023-03-16T01:53:23.000Z","updated":"2023-06-05T00:43:52.297Z","comments":true,"path":"2023/03/16/wpf-10/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/wpf-10/","excerpt":"","text":"WPF 에서 글꼴 크기(FontSize)와 폰트(FontFamily)를 통해 문자열의 크기를 계산하는 방법에 대해 알아보겠습니다. FormattedText 를 사용하여 텍스트의 서식을 지정한 후 크기를 계산할 수 있습니다. 소스코드 TextBlock 컨트롤을 사용할 경우 다음과 같이 작성하여 문자열의 크기를 구합니다. 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"textBlock\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(TextBlock textBlock)&#123; FormattedText formattedText = new FormattedText ( textBlock.Text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( textBlock.FontFamily, textBlock.FontStyle, textBlock.FontWeight, textBlock.FontStretch ), textBlock.FontSize, textBlock.Foreground, VisualTreeHelper.GetDpi(textBlock).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; TextBlock 컨트롤을 사용하지 않고 string 문자열과 글꼴 크기, 폰트를 입력하여 길이를 구할 수 있습니다. 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"text\"&gt;&lt;/param&gt;/// &lt;param name=\"fontSize\"&gt;&lt;/param&gt;/// &lt;param name=\"fontFamily\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(string text, int fontSize, FontFamily fontFamily)&#123; FormattedText formattedText = new FormattedText ( text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( fontFamily, FontStyles.Normal, FontWeights.Bold, FontStretches.Normal ), fontSize, Brushes.Black, VisualTreeHelper.GetDpi(this).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; 사용 방법 TextBlock 컨트롤을 사용 할 경우 사용 방법입니다. 123456789101112TextBlock textBlock = new TextBlock&#123; Text = \"test\", FontFamily = new FontFamily(\"Arial\"), FontSize = 16, Foreground = Brushes.Red&#125;;Size textSize = MeasureString(textBlock);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); TextBlock 컨트롤을 사용하지 않을 경우 사용 방법입니다. 12345678string text = \"hello eden\";int fontSize = 32;FontFamily fontFamily = new FontFamily(\"Arial\");Size textSize = MeasureString(text, fontSize, fontFamily);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); 참고 https://learn.microsoft.com/ko-kr/dotnet/api/system.windows.media.formattedtext?view=netframework-4.7.2","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"}]},{"title":"[TypeScript] Types","slug":"typescript-1","date":"2023-03-13T04:56:29.000Z","updated":"2023-04-17T08:04:57.076Z","comments":true,"path":"2023/03/13/typescript-1/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/typescript-1/","excerpt":"","text":"타입스크립트란? TypeScript 는 JavaScript 에 추가적인 구문을 추가하여 editor 와의 단단한 통합을 지원합니다. editor 에서 초기에 오류를 잡을 수 있습니다. TypeScript 코드는 JavaScript 가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript 로 변환될 수 있습니다. TypeScript 는 JavaScript 를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다. Types(기본) ✅ 배열: 자료형[] ✅ 숫자: number ✅ 문자열: string ✅ 논리: boolean 123456type Player = &#123; name: string; age: number; weapons: string[]; attack: bool;&#125;; optional 사용 ?를 :앞에 붙이면 optional 사용 가능합니다. 123456const player: &#123; name: string; age?: number;&#125; = &#123; name: 'eden',&#125;; 위와 같이 player.age 를 optional 로 설정할 경우 Typescript 는 player.age 가 undefined 일수도 있다고 오류를 알려줍니다. 123// ❌ player.age 가 undefined 일 가능성 알림if (player.age &lt; 10) &#123;&#125; player.age 가 존재하는지 확인을 거쳐야 오류 알림이 사라집니다. 123// ⭕ player.age 가 undefined 일 가능성 체크if (player.age &amp;&amp; player.age &lt; 10) &#123;&#125; Alias(별칭) 타입 12345678type Player = &#123; name: string; age?: number;&#125;;const player: Player = &#123; name: 'eden',&#125;; readonly 사용 변수 또는 별칭 앞에 readonly 를 붙이면 readonly 사용 가능합니다. 1234type Player = &#123; readonly name: string; age?: number;&#125;; readonly 가 있으면 최초 선언 후 수정 불가합니다. 불변성(immutability)이 부여됩니다. 하지만 javascript 에서는 그냥 배열로 인식하여 수정이 됩니다. 123456789const playerMaker = (name: string): Player =&gt; (&#123; name &#125;);const player = playerMaker('eden');// [오류]🚫 player.name = \"khk\"const numbers: readonly number[] = [1, 2, 3, 4];// [오류]🚫 numbers.push(5) Tuple 타입 정해진 개수와 순서에 따라 배열 선언이 가능합니다. 123const player: [string, number, boolean] = ['eden', 1, true];// [오류]🚫 player[0] = 1 // 바꿀 수 없습니다. string으로 지정됨 readonly 도 사용 가능 합니다. 1const player: readonly [string, number, boolean] = ['eden', 1, true]; any / undefined / null 타입 ✅ any: 어떠한 타입도 허용 12const a: any[] = [1, 2, 3, 4];const b: any = true; ✅ undefined: undefined 값만 가질 수 있음 ✅ null: null 값만 가질 수 있음 123456let nullable: null = null;let undefinedable: undefined = undefined;// [오류]// 'undefined' 형식은 'null' 형식에 할당할 수 없습니다.🚫 nullable = undefined; void 타입 void 는 값을 반환하지 않는 함수의 반환 값을 나타냅니다. 함수에 return 문이 없거나 해당 return 문에서 명시적 값을 반환하지 않을 때 항상 유추되는 타입입니다. 1234// The inferred return type is voidfunction noop() &#123; return;&#125; 1234567function test() &#123; console.log('x')&#125;const a = test()// [오류]🚫 a.toUpperCase() unknown 타입 unknown 타입은 모든 값을 나타냅니다. 이것은 any 타입과 비슷하지만 any 보다 unknown 이 더 안전합니다. 이유는 unknown 값으로 작업을 수행하는 것은 합법적이지 않기 때문입니다. 1234567function test(a: any) &#123; a.b(); // OK&#125;function test2(a: unknown) &#123; 🚫 a.b(); // 에러: Object is of type 'unknown'.&#125; never 타입 never 타입은 모든 타입에 할당 가능한 하위 타입이나, never 타입에는 본인 외에 다른 타입이 할당될 수는 없습니다. never 타입은 절대 발생할 수 없는 타입을 나타냅니다. 가장 흔한 예제로는 에러를 발생시킬 때 사용됩니다. 123function fail(msg: string): never &#123; throw new Error(msg);&#125; 사용법에 대해 좀 더 찾아봐야겠지만 그 외에도 특정 타입 값을 할당받지 않도록 하거나, 매개변수의 제한을 건다거나 뭐 그런 곳들에 사용된다는데, 사실 많이 사용하는 타입은 아니라고 봐도 무방합니다. 참고 타입스크립트 코드 테스트 타입스크립트 핸드북","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"}]},{"title":"[WPF] Grid를 Bitmap 이미지로 변환 후 저장하기","slug":"wpf-9","date":"2023-03-13T01:49:24.000Z","updated":"2023-03-28T12:58:44.848Z","comments":true,"path":"2023/03/13/wpf-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/wpf-9/","excerpt":"","text":"WPF 의 Grid 를 사용하여 사용자의 입력을 받는 문서를 작성하거나 여러 이미지를 가시화 할 시, 이를 이미지로 저장하는 기능이 필요할 경우가 있습니다. 따라서 Grid 컨트롤을 하위 요소들과 함께 Bitmap 으로 변환하고 이미지를 저장하는 방법에 대해 알아보겠습니다. 소스코드 먼저 Grid 컨트롤 내용들을 Bitmap 으로 변환합니다. 1234567891011121314151617181920212223/// &lt;summary&gt;/// Grid를 Bitmap이미지로 변환/// &lt;/summary&gt;/// &lt;param name=\"element\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static RenderTargetBitmap GetBitmapFromControl(FrameworkElement element)&#123; Size size = new Size(element.ActualWidth, element.ActualHeight); if (size.IsEmpty) return null; DrawingVisual drawingVisual = new DrawingVisual(); using (DrawingContext context = drawingVisual.RenderOpen()) &#123; context.DrawRectangle(new VisualBrush(element), null, new Rect(new Point(), size)); context.Close(); &#125; RenderTargetBitmap result = new RenderTargetBitmap((int)size.Width, (int)size.Height, 96, 96, PixelFormats.Pbgra32); result.Render(drawingVisual); return result;&#125; 변환된 Bitmap 을 PNG 또는 TIF 이미지 파일로 저장하는 코드입니다. 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// Bitmap을 이미지로 저장/// &lt;/summary&gt;/// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;/// &lt;param name=\"filePath\"&gt;파일 경로&lt;/param&gt;public static void SaveImage(RenderTargetBitmap bitmap, string filePath)&#123; string ext = System.IO.Path.GetExtension(filePath); using (FileStream stream = new FileStream(filePath, FileMode.Create)) &#123; if (ext == \".png\") &#123; PngBitmapEncoder encoder = new PngBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; else if (ext == \".tif\") &#123; TiffBitmapEncoder encoder = new TiffBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; stream.Close(); &#125;&#125; 사용 방법 123456789101112131415&lt;Window x:Class=\"TestProject.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Width=\"800\" Height=\"600\" Title=\"이미지 저장하기\"&gt; &lt;Grid Name=\"grid\"&gt; &lt;Canvas&gt; ... &lt;/Canvas&gt; &lt;StackPanel&gt; ... &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; GetBitmapFromControl 함수를 사용하여 이미지로 저장하려는 Grid 를 Bitmap 으로 변환합니다. 그리고 SaveImage 함수의 파라미터에 bitmap, 파일경로를 넣어 이미지를 저장합니다. 123456789/// &lt;summary&gt;/// 이미지 저장/// &lt;/summary&gt;private void Capture()&#123; RenderTargetBitmap bitmap = GetBitmapFromControl(this.grid); string filePath = \"d:\\\\test.png\"; SaveImage(bitmap, filePath);&#125; Grid 컨트롤 뿐만 아니라 FrameworkElement 을 상속받는 모든 컨트롤들을 위의 함수를 사용하여 이미지를 저장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"}]},{"title":"[Angular] FormGroup 관련 에러","slug":"angular-9","date":"2023-03-08T14:12:56.000Z","updated":"2023-06-05T00:43:38.697Z","comments":true,"path":"2023/03/08/angular-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/08/angular-9/","excerpt":"","text":"Angular 에서 FormGroup 사용 시 다음과 같이 에러가 발생할 경우 해결 방법에 대해 알아보겠습니다. Error 1234567891011121314151617181920212223ERROR Error: NG01350: ngModel cannot be used to register form controls with a parent formGroup directive. Try using formGroup's partner directive \"formControlName\" instead. Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;/div&gt; In your class: this.myGroup = new FormGroup(&#123; firstName: new FormControl() &#125;); Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions: Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt; &lt;/div&gt; 해결 방법 에러 메시지 내용은 formGroup 을 사용하려면 formControlName 을 사용하거나 [(ngModel)] 사용 시 [ngModelOptions]=&quot;{standalone: true} 를 추가하라고 합니다. 다음과 같이 formGroup 속성이 있는 태그의 자식 중에 ngModel 속성을 사용하는 모든 태그에 formControlName 또는 [ngModelOptions]=&quot;{standalone: true} 이 있어야 에러를 해결할 수 있습니다. 12345this.myForm = new FormGroup(&#123; id: new FormControl(''), name: new FormControl(''), title: new FormControl(''),&#125;); 12345&lt;form [formGroup]=\"myForm\"&gt; &lt;input type=\"text\" formControlName=\"id\"&gt; &lt;input type=\"text\" formControlName=\"name\"&gt; &lt;input type=\"text\" [(ngModel)]=\"myForm.value.title\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt;&lt;/fom&gt; 그리고 추가적으로 Typescript 에서 FormBuilder 를 통해 Group 을 생성할 때 formControlName 에 있는 값들을 전부 넣어줘야 됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"}]},{"title":"[Next.js] Dynamic Routes 사용 방법","slug":"nextjs-6","date":"2023-02-23T07:28:30.000Z","updated":"2023-03-26T14:28:54.606Z","comments":true,"path":"2023/02/23/nextjs-6/","link":"","permalink":"http://hgko1207.github.io/2023/02/23/nextjs-6/","excerpt":"","text":"Next.js 에서 Dynamic Routes 사용 방법에 대해 알아보겠습니다. Dynamic Routes Next.js 에서는 page 에 대괄호([param])를 추가하여 Dynamic Route 를 생성할 수 있습니다. pages/movies 경로에 [id].js 파일을 생성하면 /movies/1, /movies/abc 등과 같은 경로로 접속할 수 있습니다. 다음 예제처럼 useRouter()의 query 를 통해 /movies 다음의 하위 경로를 확인할 수 있습니다. 123456789// pages/movies/[id].jsimport &#123; useRouter &#125; from 'next/router';export default function Detail() &#123; const router = useRouter(); const &#123; id &#125; = router.query; return 'detail';&#125; 생성한 경로로 이동을 원한다면 다음과 같이 next/link를 사용하여 작성합니다. 12345678910111213141516import Link from 'next/link';function Home() &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link href=\"/movies/abc\"&gt;Go to movies/movies/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=\"/movies/abc?foo=bar\"&gt;Also goes to movies/post/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;export default Home; Catch all routes 대괄호 안에 세 개의 점(…)을 추가하여 모든 경로를 포착하도록 Dynamic Routes를 확장할 수 있습니다. pages/movies/[…id].js 는 /movies/1 와 일치하지만 /movies/1/2, /movies/1/ab/cd 등과도 일치합니다. 일치하는 매개변수는 페이지에 쿼리 매개변수로 전송되며 항상 배열이므로 /movies/a 또는 /movies/a/b 경로일 경우 다음과 같이 조회가 됩니다. 12345// /movies/a&#123; \"id\": [\"a\"] &#125;// /movies/a/b&#123; \"id\": [\"a\", \"b\"] &#125; 참고 https://nextjs.org/docs/routing/dynamic-routes","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"}]},{"title":"엘라스틱 스택 개발부터 운영까지","slug":"book-3","date":"2023-02-22T01:12:03.000Z","updated":"2023-03-23T01:11:23.984Z","comments":true,"path":"2023/02/22/book-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/22/book-3/","excerpt":"","text":"책 정보 책 소개 데이터를 처리하는 데 서로 잘 맞지도 않는 오픈소스 기술들을 굳이 동원해야 할까? 제각각인 오픈소스들을 통합하고 운영하느라 지친 개발자와 운영자들을 위한 솔루션! 이제 엘라스틱 스택 기술 하나면 OK! 어느덧 엘라스틱 스택은 검색 엔진을 넘어서 데이터 처리 시스템의 최강자로 자리 잡았다. 이 책에서는 빠르게 변화하는 세상에서 엘라스틱 스택을 지렛대로 삼아 기업의 생존 능력을 극대화하는 방법을 체계적으로 정리한다. 엔터프라이즈 빅데이터 파이프라인을 만들어 기업의 데이터를 처리하고 싶다면? 기업 내에 검색 엔진을 구축해서 빠르게 자료를 검색하고 싶다면? 방대한 데이터를 잘 가공해서 저장한 후에 멋진 시각화로 인사이트를 얻고 싶다면? 여러 서버에서 데이터들을 가져와 하나로 통합한 다음에 추이를 보거나 통계를 내고 싶다면? 바로 이럴 때 엘라스틱 스택이 정답이다. 실습을 위한 물리적인 컴퓨터나 가상 머신만 준비한다면 나머지는 모두 이 책이 책임져줄 것이다. 이 책에서는 엘라스틱 스택을 사용해 데이터 중심 애플리케이션을 설계하고, 개발하며, 운영하는 과정에서 꼭 알아야 할 필수 지식을 구체적인 사례와 함께 설명한다. 리뷰 데이터 검색과 분석을 위해서 엘라스틱 서치를 공부하려고 찾던 중 엘라스틱 스택을 알게되었고 궁금함을 못 참고 바로 구입하게 되었습니다. 엘라스틱 스택 개념과 구성요소(엘라스틱 서치, 로그스태시, 비트, 키바나 등)들이 잘 정리되어 있어 이해가 쉬웠고 참고가 많이 되었습니다. 엘라스틱 스택의 구성요소를 통해 데이터 수집부터 변환, 분석, 검색, 시각화까지 하는 내용들이 구성되어 있어 응용 학습에 많은 도움이 될 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"}]},{"title":"[Next.js] Redirect and Rewrite","slug":"nextjs-5","date":"2023-02-21T02:25:34.000Z","updated":"2023-04-02T13:02:08.923Z","comments":true,"path":"2023/02/21/nextjs-5/","link":"","permalink":"http://hgko1207.github.io/2023/02/21/nextjs-5/","excerpt":"","text":"Next.js 에서 Redirect 와 Rewrite 설정 방법에 대해 알아보겠습니다. Redirect 와 Rewrite 설정은 next.config.js 파일에서 설정하게 됩니다. next.config.js Next.js 에서 커스텀 설정을 하기 위해서는 프로젝트 디렉터리의 루트에 next.config.js 또는 next.config.mjs 파일을 만들 수 있습니다. next.config.js 는 JSON 파일이 아닌 일반 Node.js 모듈입니다. 123456/** @type &#123;import('next').NextConfig&#125; */const nextConfig = &#123; reactStrictMode: true,&#125;;module.exports = nextConfig; Next.js 서버 및 빌드 단계에서 사용되며 브라우저 빌드에는 포함되지 않습니다. Redirects (URL변경됨) Redirect 을 사용하면 들어오는 request 경로를 다른 destination 경로로 Redirect 할 수 있습니다. Redirect 을 사용하려면 next.config.js 에서 redirects 키를 설정합니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/contact', destination: '/form', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; redirects 은 source, destination 및 permanent 속성이 있는 객체를 포함하는 배열을 반환하는 비동기 함수입니다. source: 들어오는 request 경로 (request 경로) destination: 라우팅하려는 경로 (redirect할 경로) permanent: true 인 경우 클라이언트와 search 엔진에 redirect 를 영구적으로 cache 하도록 지시하는 308 status code 를 사용하고, false 인 경우 일시적이고 cache 되지 않은 307 status code 를 사용합니다. request 경로에 요청되는 모든 쿼리 값도 destination 으로 전달됩니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/old-blog/:path*', destination: '/blog/:path*', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 예를 들어 /old-blog/post-1?hello=world 요청이 들어오면 /blog/post-1?hello=world 경로로 Redirect 됩니다. Rewrites (URL변경되지 않음) Rewrites 를 사용하면 들어오는 request 경로를 다른 destination 경로에 매핑할 수 있습니다. Rewrites 은 URL 프록시 역할을 하고 destination 경로를 mask 하여 사용자가 사이트에서 위치를 변경하지 않은 것처럼 보이게 합니다. 반대로 redirects 은 새 페이지로 reroute 되고 URL 변경 사항을 표시합니다. 1234567891011121314const API_KEY = process.env.API_KEY;const nextConfig = &#123; reactStrictMode: true, async rewrites() &#123; return [ &#123; source: '/api/movies', destination: `https://api.themoviedb.org/3/movie/popular?api_key=$&#123;API_KEY&#125;`, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 12// 사용const &#123; results &#125; = await (await fetch(`/api/movies`)).json(); API 를 통해 데이터를 조회할 때 API Key 가 필요한 경우가 있습니다. 그럴 경우 API Key 가 노출되어 위험할 수 있습니다. 위의 내용처럼 Rewrites 를 사용하여 API 주소로 매핑을 하여 노출되지 않도록 해결하였습니다. 참고 https://nextjs.org/docs/api-reference/next.config.js/introduction https://nextjs.org/docs/api-reference/next.config.js/redirects https://nextjs.org/docs/api-reference/next.config.js/rewrites","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"}]},{"title":"[Next.js] Head 사용 방법","slug":"nextjs-4","date":"2023-02-07T07:19:38.000Z","updated":"2023-04-04T04:29:57.795Z","comments":true,"path":"2023/02/07/nextjs-4/","link":"","permalink":"http://hgko1207.github.io/2023/02/07/nextjs-4/","excerpt":"","text":"Next.js 에서 Head 사용 방법에 대해 알아보겠습니다. Title 설정 Next.js 에는 페이지 헤더의 제목을 변경하고 meta 를 추가할 수 있는 내장 컴포넌트를 가지고 있습니다. 123456789101112import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 태그 중복 방지 head 에 태그가 중복되는 것을 방지하려면 다음 예제와 같이 태그가 한 번만 렌더링되도록 하는 key 속성을 사용할 수 있습니다. 12345678910111213141516import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;meta property=\"og:title\" content=\"My page title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;Head&gt; &lt;meta property=\"og:title\" content=\"My new title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 이 경우 두 번째 meta property=&quot;og:title&quot; 만 렌더링됩니다. 중복 키 속성이 있는 meta 태그는 자동으로 처리됩니다. key 를 지정해주지 않으면 meta property=&quot;og:title&quot; 가 중복해서 2번 랜더링됩니다. Title 은 지정하지 않아도 2번 랜더링 되지 않습니다. 공통 컴포넌트 공통으로 사용할 컴포넌트 파일(예: Seo.js)을 생성합니다. title prop 을 받아서 화면마다 제목을 설정할 수 있습니다. 123456789import Head from 'next/head';export default function Seo(&#123; title &#125;) &#123; return ( &lt;Head&gt; &lt;title&gt;&#123;`$&#123;title&#125; | Title`&#125;&lt;/title&gt; &lt;/Head&gt; );&#125; 12345678910import Seo from '@/components/Seo';export default function Home() &#123; return ( &lt;div&gt; &lt;Seo title=\"Home\" /&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 참고 https://nextjs.org/docs/api-reference/next/head","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"}]},{"title":"[Next.js] Styles 사용 방법","slug":"nextjs-3","date":"2023-02-06T06:22:16.000Z","updated":"2023-06-05T00:43:24.973Z","comments":true,"path":"2023/02/06/nextjs-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/06/nextjs-3/","excerpt":"","text":"Next.js 에서 스타일 적용하는 방법에 대해 알아보겠습니다. 1. CSS-in-JS 가장 간단한 방법은 인라인 스타일입니다. 1234567export default function Home() &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123; color: 'red' &#125;&#125;&gt;Hello&lt;/div&gt; &lt;/div&gt; );&#125; 2. CSS Modules Next.js는 [name].module.css 파일 명명 규칙을 사용하여 CSS Module 을 지원합니다. Common.module.css파일을 생성하고 스타일을 다음과 같이 작성합니다. 중요한 것은 .module.css 패턴을 사용하는 것입니다. 123456789.nav &#123; display: flex; justify-content: space-between; background-color: red;&#125;.text &#123; color: blue;&#125; 생성된 module을 import 해서 사용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;styles.nav&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 여러 개의 스타일을 적용할 수 있습니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;`$&#123;styles.nav&#125; $&#123;styles.text&#125;`&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 또는 join() 함수를 사용해 적용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;[styles.nav, styles.text].join(' ')&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 3. Styled JSX 격리된 범위 CSS 에 대한 지원을 제공하기 위해 styled-jsx 를 번들로 제공합니다. styled-jsx 를 사용하는 컴포넌트는 다음과 같습니다. style 에 jsx prop 을 넣고 중괄호({})와 백틱(`)을 사용하여 작성합니다. 123&lt;style jsx&gt;&#123;` CSS 스타일..`&#125;&lt;/style&gt; 12345678910111213141516export default function Home() &#123; return ( &lt;div&gt; &lt;nav&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;style jsx&gt;&#123;` nav &#123; background-color: red; &#125; h1 &#123; color: blud; &#125; `&#125;&lt;/style&gt; &lt;/div&gt; );&#125; Global Styles 설정하는 방법은 global Prop 을 추가하면 됩니다. 12345&lt;style jsx global&gt;&#123;` body &#123; background: black; &#125;`&#125;&lt;/style&gt; VSCode 익스텐션 Styled JSX 사용 시 추천 VSCode 익스텐션입니다. styled-jsx : 하이라이팅, 코드 가독성에 도움이 됨 styled-jsx Language Server : 자동완성 참고 https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js https://github.com/vercel/styled-jsx","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"}]},{"title":"[Next.js] Routing 사용 방법","slug":"nextjs-2","date":"2023-02-03T07:36:02.000Z","updated":"2023-06-15T01:28:49.785Z","comments":true,"path":"2023/02/03/nextjs-2/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-2/","excerpt":"","text":"Next.js 에서 Rouing 하는 방법에 대해 알아보겠습니다. &lt;a&gt; 사용 &lt;a&gt; 태그를 사용해서 페이지 이동을 할 수 있습니다. 하지만 페이지 이동 시 전체 페이지 새고로침이 되는 문제가 발생했습니다. 12345678export default function NavBar() &#123; return ( &lt;nav&gt; &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;a href=\"/about\"&gt;About Us&lt;/a&gt; &lt;/nav&gt; );&#125; Link 사용 single-page app 환경의 페이지 전환을 하려면 Link 컴포넌트를 사용해야 합니다. 12345678910import Link from 'next/link';export default function NavBar() &#123; return ( &lt;nav&gt; &lt;Link href=\"/\"&gt;Home&lt;/Link&gt; &lt;Link href=\"/about\"&gt;About Us&lt;/Link&gt; &lt;/nav&gt; );&#125; useRouter() 컴포넌트에서 router 객체 내부에 접근하려면 userRouter() hook 을 사용할 수 있습니다. useRouter 는 React Hook 입니다. 즉, 클래스와 함께 사용할 수 없습니다. withRouter 를 사용하거나 클래스를 함수 컴포넌트로 래핑할 수 있습니다. 다음 내용은 useRouter() hook 을 사용해서 메뉴의 색상을 변경하는 예제입니다. 1234567891011121314151617import Link from 'next/link';import &#123; useRouter &#125; from 'next/router';export default function NavBar() &#123; const router = useRouter(); return ( &lt;nav&gt; &lt;Link href=\"/\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/' ? 'red' : 'blue' &#125;&#125;&gt;Home&lt;/span&gt; &lt;/Link&gt; &lt;Link href=\"/about\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/about' ? 'red' : 'blue' &#125;&#125;&gt;About Us&lt;/span&gt; &lt;/Link&gt; &lt;/nav&gt; );&#125; 참고 https://nextjs.org/docs/messages/no-html-link-for-pages https://nextjs.org/docs/api-reference/next/router#userouter","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"}]},{"title":"라이브러리와 프레임워크 차이점","slug":"info-1","date":"2023-02-03T06:50:35.000Z","updated":"2023-03-11T12:06:50.800Z","comments":true,"path":"2023/02/03/info-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/info-1/","excerpt":"","text":"라이브러리와 프레임워크의 주요 차이점에 대해 알아보겠습니다. 라이브러리 사용자가 파일 이름이나 구조 등을 정하고, 모든 결정을 내립니다. 우리 프로젝트에 가져와서 쓰는 방식 예) React: 렌더링 할 때 ReactDOM.render() 를 불러와서 사용합니다. 프레임워크 파일 이름이나 구조 등을 정해진 규칙에 따라 만들고 따릅니다. 정해진 틀 안에서 커스터마이징 방식 예) NextJS: 정해진 규칙에 따라 코드를 작성하면 렌더링됩니다. 차이점 라이브러리와 프레임워크의 주요 차이점은 “Inversion of Control”(통제의 역전) 입니다. 라이브러리에서 메서드를 호출하면 사용자가 제어할 수 있습니다. 그러나 프레임워크에서는 제어가 역전되어 프레임워크가 사용자를 호출합니다. 참고 https://www.youtube.com/watch?v=t9ccIykXTCM","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"}]},{"title":"[Next.js] 프로젝트 생성 및 시작 방법","slug":"nextjs-1","date":"2023-02-03T00:48:16.000Z","updated":"2023-05-30T14:22:01.922Z","comments":true,"path":"2023/02/03/nextjs-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-1/","excerpt":"","text":"Next.js 를 사용하는 프로젝트 생성 하는 방법에 대해 알아보겠습니다. 시스템 요구 사항 Node.js 14.6.0 이상 MacOS, Windows(WSL 포함) 및 Linux 가 지원됩니다. 프로젝트 생성 리액트 프로젝트를 생성하는 방법과 비슷하게 create-next-app 명령어를 사용합니다. @latest 를 추가하면 최신 버전으로 프로젝트를 생성합니다. 123npx create-next-app@latest# oryarn create next-app TypeScript 프로젝트로 시작하려면 --typescript 옵션을 추가합니다. 123npx create-next-app@latest --typescript# oryarn create next-app --typescript 위의 방법으로 프로젝트를 생성해보겠습니다. 123456789101112131415161718192021222324252627282930D:\\project\\Study&gt;npx create-next-app@latest√ What is your project named? ... nextjs-intro√ Would you like to use TypeScript with this project? ... No / Yes√ Would you like to use ESLint with this project? ... No / Yes√ Would you like to use `src/` directory with this project? ... No / Yes√ Would you like to use experimental `app/` directory with this project? ... No / Yes√ What import alias would you like configured? ... @/*Creating a new Next.js app in D:\\project\\Study\\nomadcoders\\nextjs-intro.Using npm.Installing dependencies:- react- react-dom- next- @next/font- eslint- eslint-config-nextadded 264 packages, and audited 265 packages in 25s102 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesInitializing project with template: defaultSuccess! Created nextjs-intro at D:\\project\\Study\\nextjs-intro 프로젝트 이름을 입력하고 TypeScript 와 ESLint 사용 여부를 선택하면 프로젝트가 성공적으로 생성됩니다. 시작 프로젝트 기본 구조 입니다. 다음 명령어를 실행하여 개발 서버를 시작합니다. 123npm run dev# oryarn dev 개발 서버가 구동되면 http://localhost:3000에 접속하여 확인합니다. 참고 https://nextjs.org/docs/getting-started","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"}]},{"title":"WPF에서 Windows Forms(WinForm) Control 사용하기","slug":"wpf-8","date":"2023-02-01T07:33:44.000Z","updated":"2023-03-14T02:27:21.817Z","comments":true,"path":"2023/02/01/wpf-8/","link":"","permalink":"http://hgko1207.github.io/2023/02/01/wpf-8/","excerpt":"","text":"WPF에서 Windows Forms(WinForm) Control 사용하는 방법에 대해 알아보겠습니다. 참조 추가 프로젝트에 다음 어셈블리에 대한 참조를 추가합니다. WindowsFormsIntegration System.Windows.Forms XAML에 추가 WinForm 컨트롤을 사용하려는 XAML 파일을 열고 아래 네임스페이스 매핑을 추가합니다. wf 네임스페이스 매핑은 Windows Forms 컨트롤이 포함된 어셈블리에 대한 참조를 설정합니다. 1xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" 123456&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt;... 사용 WindowsFormsHost 컨트롤을 사용하고 자식으로는 WinForm 컨트롤을 사용합니다. 123&lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\"/&gt;&lt;/WindowsFormsHost&gt; 전체 소스 123456789101112&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt; &lt;Grid&gt; &lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\" /&gt; &lt;/WindowsFormsHost&gt; &lt;/Grid&gt;&lt;/Window&gt; 참고 WindowsFormsHost 클래스 연습: XAML을 사용하여 WPF에서 Windows Forms 컨트롤 호스팅","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"}]},{"title":"[Kibana] 사용 방법","slug":"elasticsearch-4","date":"2023-01-06T07:41:51.000Z","updated":"2023-03-14T02:27:19.312Z","comments":true,"path":"2023/01/06/elasticsearch-4/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-4/","excerpt":"","text":"키바나(Kibana) 사용 방법에 대해 알아보겠습니다. 운영환경 Windows Kibana Version: 7.17.8 키바나를 실행합니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 서버 상태 확인 키바나의 서버 상태는 http://localhost:5601/status 에서 확인 할 수 있습니다. 키바나 콘솔 사용법 키바나 Dev Tools에 있는 콘솔을 이용해 엘라스틱서치 REST API를 호출합니다. 키바나 왼쪽 상단의 토글 메뉴를 클릭하면 키바나 메뉴를 확인할 수 있는데 Management -&gt; Dev Tools를 선택하면 됩니다. 왼쪽 입력창에서 엘라스틱서치에서 제공하는 REST API를 입력하고 실행 버튼을 누르면 오른쪽 출력창에서 HTTP의 응답을 확인할 수 있습니다. 또한 키바나 콘솔은 엘라스틱서치 API 자동 완성 기능이 지원됩니다. 샘플 데이터 불러오기 엘라스틱 스택은 세 가지 샘플 데이터를 기본으로 제공합니다. 키바나에서 아주 쉽게 가능합니다. 샘플 데이터를 불러와서 검색 테스트를 할 수 있습니다. 키바나의 홈 화면에서 Try sample data 링크를 클릭합니다. 샘플 데이터를 추가할 수 있는 화면입니다. 총 3개의 심플 데이터(Sample eCommerce orders, Sample flight data, Sample web logs)가 있고, 각 샘플 데이터마다 Add data 버튼을 클릭해서 샘플을 추가할 수 있습니다. 샘플 데이터를 추가하면 키바나의 Visualize(시각화)와 Daashboard(대시보드) 등에도 샘플들이 함께 추가됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Kibana] 윈도우에 설치 및 실행 방법","slug":"elasticsearch-3","date":"2023-01-06T05:18:22.000Z","updated":"2023-06-05T00:43:11.688Z","comments":true,"path":"2023/01/06/elasticsearch-3/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-3/","excerpt":"","text":"Kibana(키바나): 시각화와 엘라스틱서치 관리 도구 키바나는 오픈서치의 자유-오픈 소스 후계자가 오픈서치 대시보드인 일래스틱서치용의 소스 이용이 가능한 데이터 시각화 대시보드 소프트웨어이다. 일래스틱서치 클러스터에 색인된 내용 기반의 시각화 기능을 제공한다. 사용자는 막대, 선, 산점도 플롯, 원 그래프, 지도를 다량의 데이터에 맞추어 만들 수 있다. 위키백과 엘라스틱서치는 REST API가 잘 설계된 제품이긴 하지만 복잡한 요청을 일일이 작성하기 에는 다소 불편할 수 있습니다. 키바나는 이런 불편함을 해소해줍니다. 엘라스틱서치에 대한 대부분의 관리 기능, API를 실행할 수 있는 콘솔, 솔루션 페이지들, 모니터링 페이지 등이 모두 카바나에 포함되어 있습니다. 개요 윈도우 환경에서 Kibana 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 엘라스틱서치와 동일하게 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/kibana 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치할 것이므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드 받습니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 kibana-7.17.8-windows-x86_64 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치 같은 실행 관련 파일들이 있습니다. config 폴더에는 설정 파일(kibana.yml)과 기타 설정 관련 파일들이 있습니다. 실행하기 키바나를 실행해봅니다. 키바나를 실행하기 전에 반드시 엘라스틱서치를 먼저 실행하고 나서 실행해야 합니다. bin 폴더에 있는 kibana.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\kibana-7.17.8-windows-x86_64&gt; .\\bin\\kibana.bat 기본적으로 포그라운드로 실행됩니다. 확인하기 키바나가 정상적으로 실행되면 동작 여부를 웹 브라우저에서 확인할 수 있습니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 다음과 같이 키바나 웹 페이지가 나왔다면 정상 동작하는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(8.X 버전)","slug":"elasticsearch-2","date":"2023-01-06T01:08:14.000Z","updated":"2023-06-15T01:28:33.278Z","comments":true,"path":"2023/01/06/elasticsearch-2/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-2/","excerpt":"","text":"윈도우 환경에서 Elasticsearch 8.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 8.X 대 버전을 설치하므로 Windows 버튼을 클릭하여 다운로드 받습니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-8.5.3 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. 실행하기 엘라스틱서치를 실행해봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch.bat 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 12C:\\elasticsearch-8.5.3&gt; curl -X GET \"localhost:9200/?pretty\"curl: (52) Empty reply from server 명령을 실행했지만 Elasticsearch 7.X 대 버전과는 다르게 연결이 되지 않습니다. Elasticsearch 8.X 대 버전으로 업데이트되면서 https를 사용하는 방식으로 변경되었습니다. 해결하기 엘라스틱서치를 실행하면 명령 프롬프트 마지막에 다음과 같이 출력된 것을 확인할 수 있습니다. curl을 사용하여 확인하기 위해서는 user와 password를 추가로 입력하면 됩니다. 1curl -u [user]:[password] https://localhost:9200 -k user는 기본적으로 elastic 이고, password는 위에서 나온 정보를 입력하여 실행합니다. 123456789101112131415161718C:\\elasticsearch-8.5.3&gt; curl -u elastic:yJ454NS-=mdaBI9bBVM= https://localhost:9200 -k&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Ne40oBP9Td2u-XLohcOFxQ\", \"version\" : &#123; \"number\" : \"8.5.3\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"4ed5ee9afac63de92ec98f404ccbed7d3ba9584e\", \"build_date\" : \"2022-12-05T18:22:22.226119656Z\", \"build_snapshot\" : false, \"lucene_version\" : \"9.4.2\", \"minimum_wire_compatibility_version\" : \"7.17.0\", \"minimum_index_compatibility_version\" : \"7.0.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치가 잘 실행된 것을 확인할 수 있습니다. 브라우저에서 http가 아닌 https로 변경된 https://localhost:9200 으로 접속해서 확인 할 수 있습니다. “고급” 버튼을 눌러 안전하지 않은 사이트로 이동하여 접속합니다. elatic 계정과 비밀번호를 입력하면 아래 그림과 같이 정보를 확인 할 수 있습니다. 비밀번호 변경 elastic 계정의 비밀번호를 변경하려면 다음의 명령을 실행합니다. 12345678C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch-reset-password -u elasticThis tool will reset the password of the [elastic] user to an autogenerated value.The password will be printed in the console.Please confirm that you would like to continue [y/N]yPassword for the [elastic] user successfully reset.New value: ubj9aU+XNNsqV0VKkWLx 명령을 실행하고 y를 입력하면 새로운 비밀번호가 생성됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(7.X 버전)","slug":"elasticsearch-1","date":"2023-01-05T06:50:51.000Z","updated":"2023-06-05T00:42:49.016Z","comments":true,"path":"2023/01/05/elasticsearch-1/","link":"","permalink":"http://hgko1207.github.io/2023/01/05/elasticsearch-1/","excerpt":"","text":"Elasticsearch(엘라스틱서치): 분산 검색 엔진 루씬 기반의 검색 엔진이다. HTTP 웹 인터페이스와 스키마에서 자유로운 JSON 문서와 함께 분산 멀티테넌트 지원 전문 검색 엔진을 제공한다. 일래스틱서치는 자바로 개발되어 있으며 아파치 라이선스 조항에 의거하여 오픈 소스로 출시되어 있다. 위키백과 엘라스틱서치는 모든 레코드를 JSON 도큐먼트 형태로 입력하고 관리하고 있으며, 일반적인 데이터베이스와 마찬가지로, 쿼리한 결과에 대해 일치하는 원본 도큐먼트를 반환합니다. 또한 엘라스틱서치는 텍스트 외에도 숫자, 날짜, IP 주소, 지리 정보 등 다양한 데이터 타입에 대해 최적화되어 있습니다. 또한 엘라스틱서치는 사용자의 모든 입력을 REST API 형태로 받아들이기 때문에 별도의 드라이버 라이브러리가 없더라도 웹 브라우저나 curl 명령어를 이용해 기능을 활용할 수 있습니다. 개요 윈도우 환경에서 Elasticsearch 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치하므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드 받습니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-7.17.8 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치나 키 생성 등의 실행 작업을 위한 파일들이 있습니다. config 폴더에는 설정 파일(elasticsearch.yml)을 포함하여 설정에 관한 파일들이 있습니다. 실행하기 엘라스틱서치를 실행해봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-7.17.8&gt; .\\bin\\elasticsearch.bat 기본적으로 포그라운드로 실행되고 로그를 출력합니다. 백그라운드로 실행을 원할 경우 실행 명령문 뒤에 -d를 추가하면 됩니다. 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 123456789101112131415161718C:\\elasticsearch-7.17.8&gt; curl -X GET \"localhost:9200/?pretty\"&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Qd8gx2FzSnyFb4zCvx9C6Q\", \"version\" : &#123; \"number\" : \"7.17.8\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"120eabe1c8a0cb2ae87cffc109a5b65d213e9df1\", \"build_date\" : \"2022-12-02T17:33:09.727072865Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.11.1\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치는 기본적으로 9200 포트를 사용하는데, localhost:9200 주소에 GET 메소드 요청을 해서 응답이 있다면 엘라스틱서치가 정상적으로 실행 된 것입니다. 응답 결과를 JSON 형태로 보여주는데, URL 뒤에 ?pretty를 추가하면 가독성 좋은 형태로 결과를 보여줍니다. 브라우저에서 http://localhost:9200 으로 접속해서 확인 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Gatsby] Page Query","slug":"react-17","date":"2023-01-04T14:45:56.000Z","updated":"2023-06-05T00:54:01.236Z","comments":true,"path":"2023/01/04/react-17/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-17/","excerpt":"","text":"gatsby-source-filesystem 로컬 파일 시스템에서 Gatsby 애플리케이션으로 데이터를 sourcing 하기 위한 Gatsby 소스 플러그인입니다. 플러그인은 파일에서 파일 노드를 생성합니다. 다양한 “transformer” 플러그인은 파일 노드를 다양한 다른 유형의 데이터로 변환할 수 있습니다. Markdown, JSON, 이미지, YAML, CSV 및 기타 수집 가지 데이터 유형이 지원됩니다. 설치 1$ npm install gatsby-source-filesystem 사용 방법 예시로 blog-posts 디렉토리를 생성하고 디렉토리안에 post1.md, post2.md 파일을 생성합니다. gatsby-config.ts 파일의 plugin 부분을 다음과 같이 수정합니다. path 속성 값에는 생성한 blog-posts 디렉토리를 입력합니다. 12345678910111213141516// gatsby-config.jsimport type &#123; GatsbyConfig &#125; from 'gatsby';const config: GatsbyConfig = &#123; ... plugins: [ &#123; resolve: `gatsby-source-filesystem`, options: &#123; path: `$&#123;__dirname&#125;/blog-posts`, &#125;, &#125;, ],&#125;;export default config; GraphQL 쿼리를 해보면 nodes 에 생성한 파일명들이 조회됩니다. 1234567query MyQuery &#123; allFile &#123; nodes &#123; name &#125; &#125;&#125; 12345678910111213141516// 결과&#123; \"data\": &#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125; &#125;, \"extensions\": &#123;&#125;&#125; index.tsx 파일에서 쿼리를 추가하고 별다른 작성없이 props 에 data 를 선언하기만 하면 Gatsby 가 자동으로 쿼리 결과를 가져올 수 있도록 도와줍니다. TypeScript 를 사용한다면 PageProps&lt;Queries.BlogTitlesQuery&gt; 타입을 지정합니다. 1234567891011121314151617181920212223import &#123; graphql, PageProps &#125; from 'gatsby';import React from 'react';export default function IndexPage(&#123; data &#125;: PageProps&lt;Queries.BlogTitlesQuery&gt;) &#123; console.log(data); return ( &lt;ul&gt; &#123;data.allFile.nodes.map((file, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;file.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export const query = graphql` query BlogTitles &#123; allFile &#123; nodes &#123; name &#125; &#125; &#125;`; 12345678910111213// data object&#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125;&#125; 결론 위와 같이 gatsby-source-filesystem 플러그인을 사용하여 Gatsby 가 생성한 파일들을 관찰 할 수 있게 허용해주고 쿼리를 통해 더 많은 정보를 조회 할 수 있도록 도와줍니다. 참고 https://www.gatsbyjs.com/plugins/gatsby-source-filesystem","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"}]},{"title":"[Gatsby] useStaticQuery(정적 쿼리 사용)","slug":"react-16","date":"2023-01-04T14:09:13.000Z","updated":"2023-03-14T02:27:04.929Z","comments":true,"path":"2023/01/04/react-16/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-16/","excerpt":"","text":"useStaticQuery useStaticQuery는 빌드 시 리액트 훅을 사용하여 Gatsby의 GraphQL 데이터 계층을 쿼리하는 기능을 제공합니다. 이를 통해 React 컴포넌트는 구문 분석, 평가 및 컴포넌트에 삽입될 GraphQL 쿼리를 통해 데이터를 검색할 수 있습니다. useStaticQuery 훅은 모든 컴포넌트 또는 페이지에서 사용할 수 있습니다. 123456789const data = useStaticQuery(graphql` query HeaderQuery &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 사용 방법 TypeScript를 사용하고 gatsby-config.ts 파일에서 GraphQL 타입 생성에 관한 항목인 graphqlTypegen 값이 true로 설정되어 있다면 Gatsby가 쿼리를 읽고서 자동적으로 맞는 타입을 생성합니다. gatsby-types.d.ts 파일을 열어서 보면 정의한 쿼리를 읽고 자동 타입 생성을 해버렸음을 확인 할 수 있습니다. 12345678910// useStaticQuery 정의const data = useStaticQuery(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 12// gatsby-types.d.tstype SeoDataQuery = &#123; readonly site: &#123; readonly siteMetadata: &#123; readonly title: string | null &#125; | null &#125; | null &#125;; 이렇게 자동 타입이 생성되었다면 Queries를 사용하여 SeoDataQuery를 찾아 타입을 부여합니다. TypeScript 자동완성이 제공됩니다. 123456789101112const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;( graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `);console.log(data.site?.siteMetadata?.title); 전체 코드 GraphQL 쿼리를 통해 조회해서 Title를 설정하는 코드입니다. 1234567891011121314151617181920212223import &#123; graphql, useStaticQuery &#125; from 'gatsby';import React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `); return ( &lt;title&gt; &#123;title&#125; | &#123;data.site?.siteMetadata?.title&#125; &lt;/title&gt; );&#125; 참고 https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/ https://www.gatsbyjs.com/docs/reference/graphql-data-layer/graphql-api/#usestaticquery GraphQL Typegen","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"}]},{"title":"SHACL(Shapes Constraint Language) 란","slug":"shacl","date":"2023-01-04T06:47:24.000Z","updated":"2023-01-17T14:46:57.175Z","comments":true,"path":"2023/01/04/shacl/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/shacl/","excerpt":"","text":"데이터를 검증하는 데 사용되는 SHACL(Shapes Constraint Language)에 대해 공부하고 정리한 내용입니다. SHACL(Shapes Constraint Language) 란 Shapes Constraint Language(SHACL)는 RDF(Resource Description Framework) 그래프 를 설명하기 위한 W3C(World Wide Web Consortium) 표준 언어입니다 . SHACL은 RDF 그래프로 표현되는 온톨로지의 의미 체계 및 기술 상호 운용성 계층을 향상시키도록 설계되었습니다. SHACL 모델은 그래프의 내용, 구조 및 의미에 대한 제약 조건으로 정의됩니다. SHACL은 표현력이 뛰어난 언어입니다. 무엇보다도 속성이 가질 수 있는 값의 수, 이러한 값의 유형, 숫자 범위, 문자열 일치 패턴 및 이러한 제약 조건의 논리적 조합을 제한하는 조건을 표현하는 기능이 포함되어 있습니다. SHACL에는 SPARQL 및 JavaScript 와 같은 언어로 보다 복잡한 조건을 표현하는 확장 메커니즘도 포함되어 있습니다 . SHACL 규칙은 SHACL에 추론 기능을 추가하여 사용자가 기존(어설션된) 문에서 추론할 수 있는 새 문을 정의할 수 있도록 합니다. 위키백과 2017년 7월 20일 이후 W3C 권장 사항(https://www.w3.org/TR/shacl/) RDF 언어 사용 RDF의 검증을 허용하도록 생성되었습니다. SHACL은 데이터를 검증하는 데 사용되는 &quot;Shapes Graph&quot;를 정의합니다. RDF(Resource Description Framework) 란 RDF는 자원의 정보를 표현하고 상호 연결 및 교환하기 위하여 월드 와이드 웹 컨소시움(W3C)에 의해 개발되고 있는 언어 규격이다. 여기서 말하는 자원이란 웹상에 존재하는 대부분의 객체를 의미하는 것으로, 사람이나 웹페이지, 저작물과 같은 특정지을 수 있는 개체들이 해당된다. RDF는 이러한 자원들의 메타데이터를 표현하기 위하여 개발된 규격으로, 예를 들어 웹페이지라면 제목, 저자, 수정날짜와 같은 정보가 RDF로 서술하는 대상이 된다. 나무위키 SHACL Validation SHACL Processor 두 개의 입력 데이터를 넣고 검증합니다. shapes graph(확인하는 방법), data graph(검증 대상) SHACL Processor는 graph를 변경해서는 안됩니다. 즉, 유효성 검사 종료 시 data 및 shapes graph는 유효성 검사 시작 시 graph와 동일해야 합니다. 결과 graph를 생성합니다. Shape 이란 targets(대상) 및 contraints(제약 조건) 모음입니다. Targets: data graph에서 어떤 노드가 shape을 준수해야 하는지 정의합니다. Constraint: 노드를 검증하는 방법을 정의합니다. Shapes and Constraints Targets (of a shape) Data Graph에서 어떤 노드가 형태를 따라야 하는지 정의합니다. Target 선언은 어떤 리소스(RDF 그래프 노드)가 Shape의 &quot;Focus Node&quot;가 될 것인지를 정의합니다. Property Description sh:targetClass 지정된 클래스의 인스턴스인 모든 리소스를 대상으로 합니다. 예) sh:targetClass schema:Person; sh:targetNode 특정 리소스(예: 주어진 인스턴스)를 대상으로 합니다. 예) sh:targetNode ex:John; Node Shapes 노드(클래스)에 대한 제약 조건을 지정합니다. Property Shapes을 그룹화하는데 사용됩니다. sh:NodeShape의 SHACL 인스턴스로 선언하는 것이 권장되지만 필수는 아닙니다. sh:NodeShape의 SHACL 인스턴스는 sh:path 속성 값을 가질 수 없습니다. 12345schema:ExampleNodeShape e a sh:NodeShape sh:targetClass schema:Example ; sh:property [ ... ] Property Shapes 속성 및 해당 값에 대한 제약 조건을 지정합니다. 1234567sh:property [ sh:path schema:name ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string ; sh:maxLength 20 ;] ; Core Constraint Components SHACL 프로세서에서 지원해야 하는 기본 제공 SHACL Core 제약 조건 구성 요소를 정의합니다. Type Constraints Types of values class, datatype, nodeKind Cardinality minCount, maxCount Values node, in, hasValue Range of values minInclusive, maxInclusive, minExclusive, maxExclusive String based minLength, maxLength, pattern, languageIn, uniqueLang Logical constraints not, and, or, xone Closed shapes closed, ignoredProperties Property pair constraints equals, disjoint, lessThan, lessThanOrEquals Non-validating constraints name, description, group, order, defaultValue Qualified shapes qualifiedValueShape, qualifiedMinCount, qualifiedMaxCount Value Type Constraint Components Value 노드의 유형을 제한하는 데 사용합니다. Property Description sh:class 주어진 클래스의 인스턴스인 노드로 제한합니다. sh:datatype 노드의 데이터 유형을 주어진 값으로 제한합니다. (예: xsd:integer) sh:nodeKind 각 값 노드의 RDF 노드 종류가 만족할 조건을 지정합니다. 가능한 값: BlankNode, IRI, Literal, BlankNodeOrIRI, BlankNodeOrLiteral, IRIOrLiteral 123456&lt;!-- sh:class --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:class :Person; ] . 123456&lt;!-- sh:datatype --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:birthDate ; sh:datatype xsd:date; ] . sh:datatype 에 대한 데이터 유형은 XMLSchema를 참고하여 지정합니다. The XML Schema Built-in Datatypes 1234567891011&lt;!-- sh:nodeKind --&gt;schema:Person a sh:NodeShape ; sh:nodeKind sh:IRI ; sh:property [ sh:path schema:knows ; sh:nodeKind sh:BlankNodeOrIRI; ]; sh:property [ sh:path schema:name ; sh:nodeKind sh:BlankNodeOrLiteral; ] . Cardinality Constraint Components Value 노드 수에 대한 제한을 나타냅니다. Property Description minCount 지정된 속성의 최소 발생 횟수를 제한합니다. 기본값: 0 maxCount 지정된 속성의 최대 발생 횟수를 제한합니다. 기본값: 0 123456schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:minCount 1; sh:maxCount 2; ] . Value Range Constraint Components &lt;, &lt;=, &gt; 및 &gt;= 와 같은 연산자를 통해 비교할 수 있는 값 노드가 충족할 값 범위 조건을 지정합니다. Property Description minInclusive 최소 포함(Inclusive) 값, &lt;= maxInclusive 최대 포함(Inclusive) 값, &gt;= minExclusive 최소 독점(Exclusive) 값, &lt; maxExclusive 최대 독점(Exclusive) 값, &gt; 1234567schema:Rating a sh:NodeShape; sh:property [ sh:path schema:ratingValue ; sh:minInclusive 1; sh:maxExclusive 6; sh:datatype xsd:integer; ] ;. String-based Constraint Components Value 노드의 문자열 표현에 대한 조건을 지정한다는 공통점이 있습니다. Property Description minLength 최소 문자열 길이를 제한합니다. maxLength 최대 문자열 길이를 제한합니다. pattern 문자열 값이 정규 표현식과 일치하는지 확인합니다. uniqueLang 동일한 언어 태그를 사용하는 노드 쌍이 없는지 확인합니다. languageIn 속성 값이 주어진 언어 목록으로 표현되는지 확인합니다. 1234567&lt;!-- sh:minLength, sh:maxLength --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:name ; sh:minLength 4; sh:maxLength 15; ] . 123456&lt;!-- sh:pattern --&gt;schema:Product a sh:NodeShape; sh:property [ sh:path schema:productID ; sh:pattern \"^P\" ; &lt;!-- P or p로 시작하는지 확인 --&gt; ] . 1234567&lt;!-- sh:uniqueLang, sh:languageIn --&gt;schema:Country a sh:NodeShape; sh:property [ sh:path schema:name ; sh:languageIn (\"en\" \"ex\") ; sh:uniqueLang true ; ] . Property Pair Constraint Components 다른 속성과 관련하여 값 노드 집합에 대한 조건을 지정합니다. Property Description equals 지정된 Focus 노드에서 두 속성의 값 집합은 동일해야 합니다. disjoint 지정된 Focus 노드에서 두 속성의 값 집합은 달라야 합니다. lessThan 값은 다른 속성 값보다 작아야 합니다. lessThanOrEquals 값은 다른 속성의 값보다 작거나 같아야 합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:givenName ; sh:equals foaf:firstName ; ] ; sh:property [ sh:path schema:givenName ; sh:disjoint schema:lastName ; ] . Logical Constraint Components 공통 논리 연산자 and, or 및 not과 xor(Exclusive-OR)을 구현합니다. Property Description not 각 노드가 주어진 Shape을 따를 수 없다는 조건을 준수하는지 확인합니다. and 각 노드가 제공된 모든 Shape을 준수하는 조건을 준수하는지 확인합니다. or 각 노드가 제공된 Shape 중 하나 이상 또는 둘 다를 준수하는지 확인합니다. xone 각 노드가 제공된 Shape 중 정확히 하나를 준수한다는 조건을 준수하는지 확인합니다 1234567&lt;!-- sh:not --&gt;schema:Person a sh:NodeShape; sh:not [ sh:path foaf:name ; sh:minCount 1; ] . 12345678910111213141516&lt;!-- sh:and --&gt;schema:Person a sh:NodeShape; sh:and ( [ sh:property [ sh:path schema:name ; sh:minCount 1; ] ] [ sh:property [ sh:path schema:affiliation ; sh:MinCount 1; ] ] ) . 123456789101112&lt;!-- sh:or --&gt;schema:Person a sh:NodeShape; sh:or ( [ sh:path foaf:name ; sh:minCount 1 ; ] [ sh:path schema:name ; sh:minCount 1 ; ] ) . 1234567891011121314151617181920&lt;!-- sh:xone --&gt;schema:Person a sh:NodeShape; sh:xone ( [ sh:property [ sh:path ex:fullName ; sh:minCount 1; ] ] [ sh:property [ sh:path ex:firstName ; sh:minCount 1 ; ] ; sh:property [ sh:path ex:lastName ; sh:minCount 1 ; ] ] ). Shape-based Constraint Components 특정 Shape에 대해 Value 노드의 유효성을 검사하여 복잡한 조건을 지정하는 데 사용할 수 있습니다. Property Description node 주어진 속성의 모든 값은 주어진 Shape을 준수해야 합니다. qualifiedValueShape 지정된 노드 수가 준수해야 하는 Shape을 정의합니다. qualifiedMinCount Shape에 맞는 최소 노드 수 qualifiedMaxCount Shape에 맞는 최대 노드 수 123456789101112&lt;!-- sh:node --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:node schema:Company; ].schema:Company a sh:Shape ; sh:property [ sh:path schema:name ; sh:datatype xsd:string ; ] . 12345678910111213&lt;!-- sh:qualifiedValueShape, sh:qualifiedMinCount --&gt;schema:QualifiedExampleShape a sh:NodeShape; sh:targetNode :Offspring ; sh:property [ sh:path :parent; sh:minCount 2; sh:maxCount 2; sh:qualifiedValueShape [ sh:path :gender ; sh:hasValue :Female ; ] ; sh:qualifiedMinCount 1 ; ] . Closed Constraint Components Shape에 명시적으로 열거된 속성에 대한 값만 갖는 조건을 지정합니다. Property Description closed true로 설정하면 Shape에 명시적으로 설명되지 않은 속성은 허용되지 않습니다. ignoredProperties Shape에 명시적으로 열거된 속성 외에 허용되는 속성의 Optional 목록입니다. 123456789schema:Person a sh:NodeShape; sh:closed true ; sh:ignoredProperties (rdf:type) ; sh:property [ sh:path ex:firstName ; ] ; sh:property [ sh:path ex:lastName ; ] . Non-Validating Constraint 유효성 검사 조건에서 무시되는 속성입니다. Property Description name 속성 라벨명을 정의합니다. description 속성에 대한 설명을 정의합니다. order 속성의 상대적 순서를 정의합니다. group 그룹을 정의합니다. 12345678910111213schema:Person a sh:NodeShape; sh:property [ sh:path schema:url; sh:name \"URL\"; sh:description \"User URL\"; sh:order 1; ] ; sh:property [ sh:path schema:name; sh:name \"Name\"; sh:description \"Person name\"; sh:order 2; ] . Other Constraint Components Property Description hasValue Focus 노드에 주어진 값이 있는지 확인합니다. in 속성이 가질 수 있는 값 옵션을 열거합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:hasValue :OurCompany; ]; sh:property [ sh:path schema:gender ; sh:in (schema:Male schema:Female); ] . 참고 Shapes Constraint Language (SHACL) Informatiemodellering met SHACL SHAPES CONSTRAINT LANGUAGE – SHACL SHACL validation with pySHACL","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"}]},{"title":"[Gatsby] Head API","slug":"react-15","date":"2023-01-03T14:26:44.000Z","updated":"2023-03-14T02:27:02.179Z","comments":true,"path":"2023/01/03/react-15/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-15/","excerpt":"","text":"Gatsby Head API Gatsby 에는 페이지의 문서 헤드에 요소를 추가할 수 있는 내장 head가 포함되어 있습니다. react-helmet 또는 기타 유사한 솔루션과 비교할 때 Gatsby Head는 사용하기 쉽고 성능이 우수하며 번들 크기가 더 작고 최신 React 기능을 지원합니다. 12// ex)export const Head = () =&gt; &lt;title&gt;Home Page&lt;/title&gt;; SEO Component 를 사용하여 Head 함수를 정의할 수 있습니다. 12345678910// src/components/Seo.tsximport React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; return &lt;title&gt;&#123;title&#125; | Hello!&lt;/title&gt;;&#125; 123456789// index.tsximport * as React from 'react';import Seo from '../components/Seo';export default function IndexPage() &#123; return &lt;div&gt;Welcome&lt;/div&gt;;&#125;export const Head = () =&gt; &lt;Seo title=\"Home Page\" /&gt;; Usage notes Gatsby Head를 사용할 때 다음 사항에 유의해야 합니다. 구성 요소가 아닌 페이지 내부에서만 Head export 를 정의 할 수 있습니다. Gatsby Head 의 내용은 페이지 마운트 해제 시 지워지므로 각 페이지가 &lt;head&gt;에 필요한 내용을 정의하는지 확인해야 합니다. Head 함수는 유효한 JSX를 반환해야 합니다. Head 함수 내부의 유효한 태그는 link, meta, style, title, base, script 및 noscript 입니다. 참고 https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/ https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-seo-component","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"}]},{"title":"[Gatsby] Layout Components","slug":"react-14","date":"2023-01-03T14:08:22.000Z","updated":"2023-06-05T00:42:43.300Z","comments":true,"path":"2023/01/03/react-14/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-14/","excerpt":"","text":"Layout Components Gatsby 는 기본적으로 레이아웃을 페이지에 자동으로 적용하지 않습니다. 대신 Layout Component를 사용하면 Header 및 Footer, 그리고 일부 페이지에서 사용하는 사이드바와 같은 여러가지 레이아웃을 만들 수 있습니다. 또한 레이아웃과 페이지 컴포넌트 간에 데이터를 전달할 수 있습니다. 즉 Layout Component를 사용하여 여러 페이지에서 일반적으로 사용하는 Header 및 Footer의 레이아웃을 공유하도록 구성할 수 있습니다. 예제 src/components/ 디렉토리를 생성하고 Layout.tsx 파일을 생성합니다. 다음과 같이 Gatsby 의 Link를 사용하여 페이지를 이동하는 Layout Component를 구성합니다. 12345678910111213141516171819202122232425// src/components/Layout.tsximport &#123; Link &#125; from 'gatsby';import React from 'react';interface ILayoutProps &#123; children: any;&#125;export default function Layout(&#123; children &#125;: ILayoutProps) &#123; return ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/blog\"&gt;Blog&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;/div&gt; );&#125; 페이지에 레이아웃을 적용하려면 Layout Component 를 포함하고 그 안에 페이지 내용을 넣어야 합니다. 레이아웃을 페이지에 적용하는 방법은 다음과 같습니다. 12345678910111213// src/pages/index.tsximport * as React from 'react';import Layout from '../components/Layout';export default IndexPage = () =&gt; &#123; return ( &lt;Layout&gt; &lt;div&gt; &lt;h1&gt;Welcome to Home&lt;/h1&gt; &lt;/div&gt; &lt;/Layout&gt; );&#125;; 이 레이아웃이 필요한 모든 페이지와 템플릿에 대해 반복을 합니다. 참고 https://www.gatsbyjs.com/docs/how-to/routing/layout-components/ https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-link/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"}]},{"title":"[Gatsby] Routing","slug":"react-13","date":"2023-01-03T13:56:08.000Z","updated":"2023-03-14T02:26:56.855Z","comments":true,"path":"2023/01/03/react-13/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-13/","excerpt":"","text":"Routing 리액트 라우터를 사용하여 페이지를 생성하는 것과 달리 Gatsby 는 src/pages 안에 각 .tsx 파일에 대한 페이지를 생성합니다. 예를 들어 src/pages/contact.tsx는 yoursite.com/contact 페이지를 생성하고 src/pages/home.tsx는 yoursite.com/home 페이지를 생성합니다. Gatsby 로 Routing 하는 것은 간단하고 리액트 라우터도, 스크린도 만들 필요 없고 그 경로와 요소들을 일일이 설명할 필요도 없다는 장점이 있습니다. 123456// src/pages/index.tsximport React from 'react';export default function Index() &#123; return &lt;div&gt;Hello world&lt;/div&gt;;&#125; 참고 https://www.gatsbyjs.com/docs/reference/routing/creating-routes/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"}]},{"title":"[MySQL] 5분 단위로 그룹핑하여 평균값 계산","slug":"mysql-8","date":"2023-01-02T01:14:53.000Z","updated":"2023-06-05T00:53:53.552Z","comments":true,"path":"2023/01/02/mysql-8/","link":"","permalink":"http://hgko1207.github.io/2023/01/02/mysql-8/","excerpt":"","text":"MYSQL 을 사용하여 5분 단위로 그룹핑하여 평균값 계산하는 방법에 대해 알아보겠습니다. 테이블 생성 먼저 분 단위로 그룹핑과 평균값 계산을 위해 DATETIME, FLOAT 타입이 포함된 테이블을 생성합니다. 123456CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, sensor_value FLOAT, log_time DATETIME, PRIMARY KEY(id),) ENGINE=MYISAM CHARSET=utf8; 테이블이 생성되면 값을 입력합니다. 첫 번째 방법 시간 단위로 먼저 그룹핑 한 후 분단위를 5로 나누어 그룹핑합니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 1, 10), FLOOR(SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 11, 2) / 5)ORDER BY log_time; 또는 다음과 같이 SUBSTR 함수를 빼고 format 을 다르게 해서 할 수 있습니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY date_format(log_time, '%Y%m%d%H'), FLOOR(date_format(log_time, '%i') / 5);ORDER BY log_time; FLOOR 함수는 가장 가까운 정수로 버림하여 반환합니다. 두 번째 방법 시간 및 분 단위로 분리하는 함수를 사용합니다. 1234SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY DATE(log_time), HOUR(log_time), FLOOR(MINUTE(log_time) / 5)ORDER BY log_time; DATE, HOUR, MINUTE 함수는 날짜, 시간, 분의 값을 반환합니다. 5분 단위 데이터 출력 123SELECT *FROM testWHERE MOD(date_format(log_time, '%i'), 5) = 0 또는 123SELECT *FROM testWHERE date_format(log_time, '%i') % 5 = 0 MOD 함수는 첫 번째 값을 두 번째 값으로 나눈 나머지를 반환합니다. 참고 date_format 함수의 두 번째 항목인 format 내용은 아래 사이트에서 자세하게 확인해 볼 수 있습니다. https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_date-format","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Gatsby] 설치 및 사용 방법","slug":"react-12","date":"2022-12-29T07:03:34.000Z","updated":"2023-05-30T14:13:10.412Z","comments":true,"path":"2022/12/29/react-12/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/react-12/","excerpt":"","text":"Gatsby 설치 및 사용 방법에 대해 알아보겠습니다. Gatsby(개츠비) 란 개츠비는 리액트 기반의 프레임워크입니다. 리액트를 이용하면서도 리액트에 새로운 규칙 몇 가지를 추가해주면서 아주 약간의 복잡함을 더해주고 있습니다. 주로 서버사이드 렌더링을 위해 사용하는 Next.js 와는 달리 개츠비는 서버 없이, 오로지 정적 웹사이트 생성을 위해 사용하는 오픈소스 프레임워크입니다. 정적 웹 페이지, 플랫 페이지는 저장된 그대로 사용자에게 전달되는 웹 페이지로서, 이는 웹 애플리케이션에 의해 생성되는 동적 웹 페이지와 반대되는 용어이다. 즉, 정적 웹 페이지는 모든 상황에서 모든 사용자에게 동일한 정보를 표시하며, 콘텐츠 타입이나 문서 언어의 협상(negotiate)을 위해 웹 서버의 현대적 기능에 종속된다. 위키백과 서비스 및 블로그, 포트폴리오 등에서 많이 사용됩니다. 설치 Gatsby를 사용하기 위해 gatsby-cli를 설치합니다. 1$ npm install -g gatsby-cli 12Gatsby requires Node.js 18.0.0 or higher (you have v14.17.5).Upgrade Node to the latest stable release: https:&#x2F;&#x2F;gatsby.dev&#x2F;upgrading-node-js 개츠비를 사용하려면 Node.js 18 이상 버전이 필요합니다. 버전이 낮다면 위와 같은 에러가 발생합니다. 프로젝트 생성 Gatsby CLI를 사용하여 프로젝트를 만듭니다. 1$ npm init gatsby 또는 1$ gatsby new 위의 명령어를 실행하면 프로젝트 생성을 위한 여러가지 입력하는 부분이 있습니다. 순서대로 입력하면 프로젝트가 생성됩니다. 프로젝트 명을 입력합니다. 디렉토리를 확인합니다. JavaScript 쓸 건지 TypeScript 쓸 건지 선택합니다. 사용할 CMS를 선택합니다. 사용하지 않을 경우 No를 선택합니다. 사용할 styling system(Sass, Emotion, styled-components 등…)을 선택합니다. 구글 애널리틱스, 반응형 이미지나 사이트맵 등을 추가할 것인지 묻습니다. 없다면 Done을 선택합니다. CMS 는 비개발자인 사람들이 콘텐츠를 계속 올리는 웹사이트 혹은 앱입니다. 실행 다음 명령어를 실행합니다. 12$ cd my-gatsby-site/$ npm run develop 완료가 되면 사이트를 접속해서 확인합니다. 1234...You can now view dev-stickers in the browser. http://localhost:8000/ 빌드 빌드를 진행하면 축소된 파일, 변환된 이미지, 페이지별 정보와 데이터가 있는 JSON 파일, 페이지별 정적 HTML 등이 모두 포함됩니다. 최적화가 잘되어 있어 빠르게 로드되는 정적 웹사이트를 배포할 수 있습니다. 1$ npm run build 결론 개츠비 설치와 기본적인 사용 방법에 대해서 정리하였습니다. 나만의 블로그를 만들고 싶을 때 사용하면 좋을 것 같습니다. Gatsby Plugin Library Gatsby 사이트나 앱을 커스텀할 수 있는 기능을 제공하는 라이브러리들입니다. https://www.gatsbyjs.com/plugins 참고 Documentation Tutorials Guides","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"}]},{"title":"[Spring Boot] MultipartFile transferTo() 사용 파일 저장시 주의사항","slug":"spring-4","date":"2022-12-29T04:50:03.000Z","updated":"2023-03-14T02:26:51.559Z","comments":true,"path":"2022/12/29/spring-4/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/spring-4/","excerpt":"","text":"multipart 기본 경로 Spring Boot 설정에서 spring.servlet.multipart.location를 특정 경로로 설정하지 않을 경우 기본적으로 tmp 폴더로 지정됩니다. 각 운영체제 tmp 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp Linux: \\tmp 각 운영체제 basedir 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT Linux: \\tmp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT 위와 같이 눈으로 보기에도 많이 지저분한 경로에 저장이 되므로 작업과 관리가 용이하도록 경로를 직접 설정해주는 것이 좋습니다. 주의사항 경로 설정시 주의사항은 파일 저장 경로를 /upload 로 할 경우 리눅스는 절대경로로 인식하여 /upload 로 인식하지만 윈도우는 상대경로로 인식하여 basedir 을 포함한 경로를 만듭니다. 결과는 C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT\\upload 입니다. 만약 C:/upload 에 저장하고 싶다면 /upload 가 아닌 C:/upload 로 상세하게 입력해야 합니다. 1spring.servlet.multipart.location=C:/upload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"}]},{"title":"[Spring Boot] MultipartFile + Modal 사용 파일 업로드","slug":"spring-3","date":"2022-12-26T14:01:16.000Z","updated":"2023-03-14T02:26:44.705Z","comments":true,"path":"2022/12/26/spring-3/","link":"","permalink":"http://hgko1207.github.io/2022/12/26/spring-3/","excerpt":"","text":"Spring Boot에서 MultipartFile와 Bootstrap의 Modal을 사용하여 이미지 파일을 업로드하는 방법에 대해 알아보겠습니다. Spring Boot 2.6.11 버전과 Bootstrap 5를 사용하였습니다. MultipartFile MultipartFile이란 스프링에서 업로드한 파일을 표현할 때 사용되는 인터페이스입니다. 파일 내용은 메모리에 저장되거나 임시로 디스크에 저장됩니다. 요청 처리가 끝나면 임시 저장소는 지워집니다. 설정 Spring Boot application.properties 설정 파일에 파일 업로드 경로와 파일 사이즈를 설정합니다. 윈도우 기준으로 d:/upload/ 경로로 파일을 업로드합니다. 12345# 지도 파일 업로드 경로spring.servlet.multipart.location=d:/upload/spring.servlet.multipart.max-file-size=512MBspring.servlet.multipart.max-request-size=512MB spring.servlet.multipart.location: 업로드된 파일의 임시 저장 공간 spring.servlet.multipart.max-file-size: 파일의 최대 사이즈 (default: 1MB) spring.servlet.multipart.max-request-size: 요청의 최대 사이즈 (default: 10MB) html CDN을 통해 Bootstrap CSS와 JS를 포함합니다. 파일 업로드하는 모달 팝업 코드를 작성합니다. 파일 업로드 시 form 태그에 enctype=&quot;multipart/form-data&quot;를 추가하고 input 태그 타입을 file로 작성해야 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;파일 업로드 예제&lt;/title&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD\" crossorigin=\"anonymous\" /&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN\" crossorigin=\"anonymous\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#uploadModal\"&gt; 파일 업로드 &lt;/button&gt; &lt;!-- Modal --&gt; &lt;div id=\"uploadModal\" class=\"modal fade\" tabindex=\"-1\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header bg-primary text-white border-0\"&gt; &lt;h5 class=\"modal-title\"&gt;지도 등록&lt;/h5&gt; &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;form id=\"uploadForm\" method=\"POST\" action=\"/file/upload\" class=\"form-horizontal\" enctype=\"multipart/form-data\" &gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"form-group row mb-2\"&gt; &lt;label class=\"col-form-label col-md-3\"&gt;파일 &lt;/label&gt; &lt;div class=\"col-md-8\"&gt; &lt;input type=\"file\" class=\"form-control\" name=\"file\" accept=\"image/*\" required /&gt; &lt;span class=\"text-muted\"&gt; ※ 이미지 파일만 업로드 가능합니다. &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary me-2\"&gt;등록&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-light\" data-bs-dismiss=\"modal\"&gt;닫기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /Modal --&gt; &lt;/body&gt;&lt;/html&gt; JavaScript Modal와 Form을 제어하는 JavaScript 코드를 추가합니다. 12345678910111213141516171819202122232425262728// modal 닫기const modalHide = (modalId) =&gt; &#123; const modalEl = document.getElementById(modalId); const modal = bootstrap.Modal.getInstance(modalEl); modal.hide();&#125;;$('#uploadForm').submit(function (e) &#123; e.preventDefault(); const form = $(this); const url = form.attr('action'); const formData = new FormData($('#uploadForm')[0]); $.ajax(&#123; url: url, type: 'POST', data: formData, processData: false, contentType: false, success: function (response) &#123; modalHide('uploadModal'); alert('파일 업로드 성공'); &#125;, error: function (response) &#123; alert('파일 업로드 실패'); &#125;, &#125;);&#125;); Java Controller 파일을 생성합니다. 파일을 입력받고 저장하는 코드를 작성합니다. MultipartFile의 transferTo() 함수를 사용하여 파일을 저장합니다. 123456789101112131415161718192021public class FileController &#123; @PostMapping(\"file/upload\") @ResponseBody public ResponseEntity&lt;?&gt; upload(MultipartFile file) &#123; if (file != null) &#123; writeFile(file); return new ResponseEntity&lt;&gt;(HttpStatus.OK); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); &#125; /** * 파일 저장 */ private void writeFile(MultipartFile multipartFile) throws IOException &#123; File file = new File(filePath); multipartFile.transferTo(file); &#125;&#125; 파일을 업로드하는 코드를 작성해봤습니다. 파일 업로드에 대한 간략한 코드이므로 응용해서 사용할 수 있을 것 같습니다. 참고 https://getbootstrap.com/docs/5.0/components/modal/ https://www.baeldung.com/spring-multipartfile-to-file","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"}]},{"title":"[리눅스] mount --bind 사용 방법","slug":"linux-28","date":"2022-12-16T01:00:04.000Z","updated":"2023-03-14T02:26:42.145Z","comments":true,"path":"2022/12/16/linux-28/","link":"","permalink":"http://hgko1207.github.io/2022/12/16/linux-28/","excerpt":"","text":"mount 명령어는 디스크 드라이브와 같은 블록 디바이스(Block Device)만 마운트가 가능합니다. --bind 옵션을 추가하면 특정 디렉토리를 다른 디렉토리에 마운트(mount)해서 양쪽 디렉토리가 같은 곳으로 연결되도록 할 수 있습니다. 1$ mount --bind [원본 디렉토리] [붙일 디렉토리] 사용 예시 먼저 두 개의 디렉토리를 생성합니다. 12$ mkdir src$ mkdir dest --bind 또는 -B 옵션을 사용해서 src 디렉토리를 dest 디렉토리에 연결합니다. 1$ mount --bind src dest dest 디렉토리 하위에 파일을 생성을 하면 src 디렉토리에도 반영이 됩니다. 1$ touch dest/test 변경된 내용을 양쪽 모두 확인이 가능합니다. 1234$ ls desttest$ ls srctest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"}]},{"title":"[리눅스] 네트워크 설정","slug":"linux-27","date":"2022-12-14T02:41:21.000Z","updated":"2023-06-05T00:42:35.963Z","comments":true,"path":"2022/12/14/linux-27/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-27/","excerpt":"","text":"리눅스 환경에서 ifconfig 를 이용하여 네트워크 설정하는 방법을 알아보겠습니다. ifconfig 란 TCP/IP를 사용하여 네트워크의 네트워크 인터페이스 매개변수를 구성 또는 표시합니다. ifconfig 명령을 사용하여 네트워크 인터페이스에 주소를 지정하고 현재 네트워크 인터페이스 구성 정보를 구성 또는 표시할 수 있습니다. IP 주소 확인 옵션없이 ifconfig 명령어만 실행하면 서버에 할당된 IP 주소를 확인합니다. 12345678910$ ifconfigenp5s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.0.19 netmask 255.255.255.0 broadcast 192.168.0.255 inet6 fe80::d487:3f17:d845:654b prefixlen 64 scopeid 0x20&lt;link&gt; ether 1c:1b:0d:7d:36:6f txqueuelen 1000 (Ethernet) RX packets 11943615 bytes 5682003196 (5.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8140188 bytes 2132065829 (1.9 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0... IPv4주소(inet), 서브넷마스트(netmask), 브로드캐스트주소(broadcast)가 표기되고 있고, MAC주소(ether)도 표시됩니다. 네트워크 설정 IP 주소, 서브넷마스크 주소, 브로드캐스트 주소를 모두 할당하려면 다음과 같이 모든 인수와 함께 ifconfig 명령을 사용하면 됩니다. 1$ ifconfig [이더넷명] [주소] netmask [주소] broadcast [주소] 추가로 up 옵션을 추가하여 이더넷을 활성화합니다. 1$ ifconfig [이더넷명] up 다음 예제는 eth0 에 IP 주소를 192.168.0.250, 서브넷마스크 주소를 255.255.255.0, 브로드캐스트 주소를 192.168.0.255 설정하고 활성화하는 명령어입니다. 1$ ifconfig eth0 192.168.0.250 netmask 255.255.255.0 broadcast 192.168.0.255 up 위의 방법으로 설정을 하면 물리적으로 변경된 것이 아니라 시스템 메모리상에서 로딩된 리눅스 커널이 사용하고 있는 랜카드 드라이브의 네트워크 설정이 바뀌는 것입니다. 따라서 시스템을 재부팅하고 나면 설정이 사라집니다. 고정 네트워크 설정 IP 주소를 고정하기 위해 설정을 해야 합니다. /etc/sysconfig/network 시스템 전체에 대한 Global 한 기본 게이트웨이 주소 설정과 호스트네임, 네트워킹 연결 허용 여부를 설정합니다. 123456$ vi /etc/sysconfig/networkNETWORKING=yesNETWORKING_IPV6=noHOSTNAME=hgko.comGATEWAY=192.168.0.1 /etc/resolv.conf 네임서버 설정과 기본적으로 사용할 도메인명을 설정합니다. 호스트명만 지정하였을 경우에 호스트명을 search 항목에 지정하여 도메인명으로 사용합니다. 1$ vi /etc/resolv.conf 1234# Generated by NetworkManagersearch hgko.comnameserver 168.126.63.1nameserver 168.126.63.2 /etc/sysconfig/network-script/ 시스템에서 사용하는 모든 이더넷 설정파일은 /etc/sysconfig/network-script/ 디렉토리에 존재합니다. 시스템에 설치되어 있는 기본 이더넷카드의 파일을 열고 고정 IP 부여를 위해 수정합니다. 1$ vi /etc/sysconfig/network-script/ifcfg-eth0 123456789101112131415161718192021222324# 장치명, 첫번째 이더넷카드DEVICE=eth0# IP 부여 방식 결정, static 은 고정IPBOOTPROTO=static# 이더넷카드의 MAC 주소HWADDR=XX:XX:XX:XX:XX:XX# 고유ID를 부여하는 것으로 자동으로 부여됨UUID=XXXXXXX-XXX-XXX-XXX-XXXXXXX# Ethernet 에 대한 설정TYPE=Ethernet# IP 주소 지정IPADDR=192.168.0.250# 서브넷마스크 지정NETMASK=255.255.255.0# 브로드캐스트 지정BROADCAST=192.168.0.255# 네트워크 지정NETWORK=192.168.0.0# 일반사용자의 eth0 제어 가능여부USERCTL=no# IPV6 사용여부IPV6INIT=no# 시스템 시작시 자동으로 활성화ONBOOT=yes 설정 적용 시스템을 재부팅하거나 재부팅 하지 않고 변경사항을 적용하는 명령어를 실행합니다. 1$ /etc/rc.d/init.d/network restart 또는 1$ service network restart 참고 https://www.ibm.com/docs/ko/aix/7.2?topic=i-ifconfig-command","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"}]},{"title":"[CentOS] netstat 사용 포트 확인","slug":"linux-26","date":"2022-12-14T01:35:12.000Z","updated":"2023-06-15T01:28:09.286Z","comments":true,"path":"2022/12/14/linux-26/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-26/","excerpt":"","text":"리눅스 환경에서 netstat 명령어를 사용하여 네트워크 정보를 확인하는 방법에 대해 알아보겠습니다. netstat 란 netstat는 전송 제어 프로토콜, 라우팅 테이블, 수많은 네트워크 인터페이스, 네트워크 프로토콜 통계를 위한 네트워크 연결을 보여주는 명령 줄 도구이다. 위키백과 netstat 는 네트워크 관련한 정보를 보는 유틸리티로 오래전부터 Unix 계열의 운영체제에서 사용되어 왔으며 현재 LISTEN 중인 포트, 모든 내외부/연결 정보등을 확인할 수 있습니다. 자주 사용하는 netstat 옵션 -a : 모든 소켓보기, 이 옵션이 없으면 상태가 ESTABLISHED 인 것만 나옵니다. --all 옵션과 동일합니다. -n : 도메인 주소를 읽어들이지 않고 숫자로 출력합니다. -p : PID(프로세스 ID) 와 사용 중인 프로그램명이 출력됩니다. netstat 옵션 -c : 현재 실행 명령을 매 초마다 실행 -l : listen 하고 있는 포트만 보여줌 -i : 내트워크 트래픽정보 모니터링 -t : tcp 로 연결된 내용 출력 -u : udp 로 연결된 내용 출력 -r : 라우팅 테이블을 출력 -s : 프로토콜별 통계 정보 netstat State LISTEN : 서버에 프로세스가 실행되어있으며 클라이언트의 접속 요청을 기다리는 상태 ESTABLISED : 서버와 클라이언트간에 세션 연결이 성립되어 통신이 이루어지는 상태 CLOSE_WAIT : TCP 연결이 상위 레벨로부터 연결 종료를 기다리는 상태 TIME_WAIT : 연결은 종료 되었지만 특정시간동안 소켓을 열어놓은 상태 CLOSE : 연결이 종료된 상태 모든 소켓 확인 12345678910111213141516$ netstat -aActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:sunrpc 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:wap-wsp 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:vrace 0.0.0.0:* LISTENtcp 0 0 localhost.locald:domain 0.0.0.0:* LISTEN...Active UNIX domain sockets (servers and established)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ] DGRAM 41808 @000f7unix 2 [ ACC ] STREAM LISTENING 46336 @/tmp/.ICE-unix/2446unix 2 [ ACC ] STREAM LISTENING 40451 /var/run/docker/metrics.sockunix 2 [ ACC ] STREAM LISTENING 42868 @/tmp/dbus-i51dyYJlx0... TCP 포트 목록 특정 문자열이 포함된 포트를 확인할 수 있습니다. 다음의 예시는 0 0.0.0.0 또는 0 ::: 문자열이 포함된 TCP 포트 목록을 출력하는 명령어입니다. 12345678910$ netstat -nlpt | egrep \"0 (0.0.0.0|:::)\"or$ netstat -anp | grep ^tcp | egrep \"0 (0.0.0.0|:::)\"tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 951/sshdtcp 0 0 :::22 :::* LISTEN 951/sshdtcp6 0 0 :::8080 :::* LISTEN 6959/javatcp6 0 0 :::8009 :::* LISTEN 6959/javatcp6 0 0 :::3306 :::* LISTEN 2025/mariadbd... 포트 &amp; 프로세스 목록 LISTEN 중인 포트 및 프로세스명만 확인하려면 다음과 같은 명령을 사용합니다. 1234567$ netstat -anp | grep \"LISTEN \" | grep -v 127.0.0.1 | sed 's/:::/0 /g' | sed 's/[:\\/]/ /g' | awk '&#123;print $5\"\\t\"$10&#125;' | sort -ug22 sshd8009 java8080 java3306 mysqld...","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"}]},{"title":"[CentOS] PM2 서비스 등록","slug":"linux-25","date":"2022-12-09T08:23:14.000Z","updated":"2023-03-14T02:26:30.908Z","comments":true,"path":"2022/12/09/linux-25/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/linux-25/","excerpt":"","text":"리눅스 환경에서 PM2 서비스 등록하는 방법에 대해 알아보겠습니다. PM2 에서는 시스템이 부팅되고 나서 자동으로 실행되도록 하는 서비스를 등록해주는 startup 명령어가 있습니다. pm2 등록 12$ pm2 start [파일명] --name test$ pm2 list 서비스 등록 pm2 startup 명령어를 사용하여 PM2 서비스를 등록합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142$ pm2 startup[PM2] Init System found: systemdPlatform systemdTemplate[Unit]Description=PM2 process managerDocumentation=https://pm2.keymetrics.io/After=network.target[Service]Type=forkingUser=rootLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityEnvironment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/binEnvironment=PM2_HOME=/root/.pm2PIDFile=/root/.pm2/pm2.pidRestart=on-failureExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrectExecReload=/usr/lib/node_modules/pm2/bin/pm2 reload allExecStop=/usr/lib/node_modules/pm2/bin/pm2 kill[Install]WantedBy=multi-user.targetTarget path/etc/systemd/system/pm2-root.serviceCommand list[ 'systemctl enable pm2-root' ][PM2] Writing init configuration in /etc/systemd/system/pm2-root.service[PM2] Making script booting at startup...[PM2] [-] Executing: systemctl enable pm2-root...Created symlink from /etc/systemd/system/multi-user.target.wants/pm2-root.service to /etc/systemd/system/pm2-root.service.[PM2] [v] Command successfully executed.+---------------------------------------+[PM2] Freeze a process list on reboot via:$ pm2 save[PM2] Remove init script via:$ pm2 unstartup systemd pm2 save 명령어를 통해 재부팅 시 프로세스 목록을 고정시킵니다. 123$ pm2 save[PM2] Saving current process list...[PM2] Successfully saved in /root/.pm2/dump.pm2 PM2 서비스를 시작합니다. 12345678910111213$ sudo systemctl start pm2-root.service$ systemctl status pm2-root.service● pm2-root.service - PM2 process manager Loaded: loaded (/etc/systemd/system/pm2-root.service; enabled; vendor preset: disabled) Active: active (running) since 금 2022-12-09 17:14:27 KST; 5min ago Docs: https://pm2.keymetrics.io/ Process: 18456 ExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrect (code=exited, status=0/SUCCESS) Main PID: 13515 (PM2 v5.2.0: God) Tasks: 0 Memory: 0B CGroup: /system.slice/pm2-root.service ‣ 13515 PM2 v5.2.0: God Daemon (/root/.pm2)... 시스템 재부팅 후 서비스를 확인합니다. 1$ sudo reboot 1$ pm2 list","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"메타마스크(MetaMask) 설치 및 사용 방법","slug":"blockchain-2","date":"2022-12-09T03:59:18.000Z","updated":"2023-01-06T02:33:30.916Z","comments":true,"path":"2022/12/09/blockchain-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/blockchain-2/","excerpt":"","text":"메타마스크 설치 및 사용 방법에 대해 알아보겠습니다. 메타마스크(MetaMask) 란 Ethereum 블록 체인과 상호 작용하는 데 사용되는 소프트웨어 암호 화폐 지갑입니다. 이를 통해 사용자는 브라우저 확장 프로그램이나 모바일 앱을 통해 이더리움 지갑에 액세스할 수 있으며, 이를 통해 분산 애플리케이션과 상호 작용할 수 있습니다. 위키백과 이더리움 지갑 중 메타마스크는 커뮤니티에서 사용죄는 가장 인기 있는 지갑 중 하나입니다. 설치 및 사용 방법 설치 메타마스크 웹사이트에서 크롬 플러그인으로 설치 할 수 있습니다. 사이트로 접속하여 Download 버튼을 클릭합니다. 크롬 웹 스토어 창이 열리게 되고 “Chrome에 추가” 버튼을 클릭합니다. 크롬 확장프로그램에 MetaMask가 추가됩니다. Mnemonic 복구 크롬 확장프로그램에서 MetaMask를 선택하고 “시작하기” 버튼을 클릭합니다. 처음 사용하는 사용자라면 비밀 복구 구문을 사용하여 기존 지갑 가져오기와 새 지갑과 비밀 복구 구문 생성을 선택하는 화면이 보입니다. 지갑 생성을 해서 MetaMask를 사용할 수 있지만 이전 글 [Ethereum] ganache-cli 설치 및 실행에서 생성된 Mnemonic을 사용하여 지갑을 가져오도록 하겠습니다. &quot;지갑 가져오기&quot;를 클릭하면 비밀 복구 구문으로 계정 가져오기 화면이 보입니다. 생성된 Mnemonic과 비밀번호를 입력하고 “가져오기” 버튼을 클릭합니다. 메타마스크 접속 시 화면입니다. 네트워크 추가 ganache로 실행한 네트워크를 연결하기 위해 메타마스크에서 네트워크 추가를 합니다. 메타마스크 화면에서 우측 네트워크를 클릭하고 “네트워크 추가” 버튼을 클릭합니다. 설정화면에서 &quot;네트워크 수동 추가&quot;를 클릭합니다. 네트워크 이름, 새 RPC URL(ip 주소와 포트), 체인 ID(url을 입력하면 자동으로 찾아줌), 통화 기호를 입력하고 “저장” 버튼을 클릭합니다. 추가된 네트워크가 보이며 선택 시 계정 정보가 보입니다. 결론 메타마스크 설치와 사용 방법에 대해 알아보았습니다. 이더리움 지갑에 쉽게 액세스할 수 있어 블록체인 기반 웹이나 앱개발 시 도움이 많이 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"}]},{"title":"[Spring Boot] WebSocket & STOMP 사용 방법","slug":"spring-2","date":"2022-12-09T00:58:32.000Z","updated":"2023-03-14T02:26:33.516Z","comments":true,"path":"2022/12/09/spring-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/spring-2/","excerpt":"","text":"WebSocket 이란 웹소켓(WebSocket)은 하나의 TCP 접속에 전이중 통신 채널을 제공하는 컴퓨터 통신 프로토콜이다. 웹소켓 프로토콜은 2011년 IETF에 의해 RFC 6455로 표준화되었으며 웹 IDL의 웹소켓 API는 W3C에 의해 표준화되고 있다. 위키백과 HTTP 프로토콜과 호환되며, 실시간 양방향 통신을 제공하기 위한 프로토콜이며 Spring 4.0에서 등장한 네트워크 서비스입니다. (접속까지는 HTTP 프로토콜을 사용하지만 이후 WebSocket 프로토콜로 변경) Spring Boot 로 구현하기 Spring Boot에서 WebSocket과 자바스크립트에서 STOMP을 사용하여 메세지를 주고 받는 예제를 구현해 보려고 합니다. 의존성 추가 pom.xml에 spring-boot-starter-websocket를 추가합니다. 12345&lt;!-- 웹소켓 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; WebSocketConfig 설정 웹 소켓을 사용하기 위한 설정 파일이 필요합니다. @Configuration을 통해 해당 파일이 Bean 설정을 할 것을 나타냅니다. @EnableWebSocketMessageBroker 을 통해 WebSocket 사용을 나타냅니다. 1234567891011121314151617181920212223242526@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; /** * 클라이언트가 웹 소켓 서버에 연결하는데 사용할 웹 소켓 엔드포인트 등록 * withSockJS 를 통해 웹 소켓을 지원하지 않는 브라우저에 대해 웹 소켓을 대체한다. * +)메소드명에 STOMP가 들어가는 경우 통신 프로토콜인 STOMP구현에서 작동된다. */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(\"/websocket\").setAllowedOriginPatterns(\"*\").withSockJS(); &#125; /** * 한 클라이언트에서 다른 클라이언트로 메시지를 라우팅하는데 사용될 메시지 브로커 */ @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; // topic으로 시작되는 요청을 구독한 모든 사용자들에게 메시지를 전달한다. registry.enableSimpleBroker(\"/topic\"); // 클라이언트에서 보낸 메세지를 받을 prefix registry.setApplicationDestinationPrefixes(\"/app\"); &#125;&#125; MessageDTO 생성 메세지 내용을 담아줄 MessageDTO를 생성합니다. 1234567@Datapublic class MessageDTO &#123; private String content; private String sender;&#125; MessageController 생성 /app/sendMessage 경로를 통해 전송되면 @MessageMapping 과 매핑되어 메서드를 호출합니다. 그리고 @SendTo 를 통해 /topic/message 를 구독하고 있는 사용자에게 MessageDTO 를 JSON 형식으로 전달합니다. 123456789101112131415@Controllerpublic class MessageController &#123; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message * @return */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public MessageDTO message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); return message; &#125;&#125; @SendTo Annotation이 아닌 SimpMessagingTemplate을 사용해서 메세지를 전달할 수 있습니다. 1234567891011121314151617@Controller@RequiredArgsConstructorpublic class MessageController &#123; private final SimpMessagingTemplate simpMessagingTemplate; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public void message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); simpMessagingTemplate.convertAndSend(\"/topic/message\", message); &#125;&#125; STOMP 사용 STOMP는 Simple Text Oriented Messaging Protocol의 약자입니다. 클라이언트와 서버가 서로 통신하는 데 있어 메시지의 형식, 유형, 내용 등을 정의해주는 프로토콜이라고 할 수 있습니다. STOMP를 사용하게 되면 단순한 Binary, Text가 아닌 규격을 갖춘 메시지를 보낼 수 있습니다. 라이브러리 추가 sockjs와 stomp 라이브러리를 추가합니다. 1234&lt;!-- sock js --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.2/sockjs.min.js\"&gt;&lt;/script&gt;&lt;!-- STOMP --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js\"&gt;&lt;/script&gt; 메세지 받기 클라이언트에서는 다음과 같이 연결하고 구독을 합니다. 12345678910function subscribeMessage() &#123; let socket = new SockJS('/websocket'); let stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; stompClient.subscribe('/topic/message', function (message) &#123; console.log(message.body); &#125;); &#125;);&#125; 메세지 전송 메세지 전송 시 실행되는 함수입니다. 12345678910111213function sendMessage() &#123; const socket = new SockJS('/websocket'); const stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; const message = &#123; content: 'test', sender: 'hgko', &#125;; stompClient.send('/app/sendMessage', &#123;&#125;, JSON.stringify(message)); stompClient.disconnect(); &#125;);&#125; 결론 Spring Boot 환경에서 WebSocket과 STOMP를 활용한 메시지 전송 기능 구현에 대해 알아보았습니다. 쉽게 구현할 수 있어 적용이 빠를 것 같습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"}]},{"title":"[OpenLayers] Feature Drag and Drop","slug":"js-dev-8","date":"2022-12-07T15:29:35.000Z","updated":"2023-03-14T02:26:25.696Z","comments":true,"path":"2022/12/08/js-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-8/","excerpt":"","text":"이전 글 [OpenLayers] Custom Icon Feature 추가 에서 추가된 Icon Feature 를 Drag and Drop 하는 예제입니다. Script ol.interaction.Modify 을 이용해서 Drag and Drop 기능을 구현합니다. modifystart, modifyend 이벤트를 등록하여 Icon 을 선택하거나 이동 시 커서가 변경되도록 하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;;// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// var dragInteraction = new ol.interaction.Modify(&#123; features: new ol.Collection([iconFeature]), &#125;); const target = document.getElementById('map'); dragInteraction.on('modifystart', function (event) &#123; target.style.cursor = 'grabbing'; &#125;); dragInteraction.on('modifyend', function (event) &#123; target.style.cursor = 'pointer'; event.features.forEach(function (feature) &#123; const name = feature.get('name'); console.log(name); // Drop 완료 시 프로세스 진행 &#125;); &#125;, iconFeature); const overlaySource = dragInteraction.getOverlay().getSource(); overlaySource.on(['addfeature', 'removefeature'], function (evt) &#123; target.style.cursor = evt.type === 'addfeature' ? 'pointer' : ''; &#125;); this.addInteraction(dragInteraction); /////////////////////////////////////////////////////// &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); Drop 이 되었을 때 feature.get() 함수를 이용해서 설정한 값을 가져와 다음 프로세스를 처리합니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Custom Icon Feature 추가","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"}]},{"title":"[OpenLayers] Custom Icon Feature 추가","slug":"js-dev-7","date":"2022-12-07T15:19:40.000Z","updated":"2023-03-14T02:26:23.116Z","comments":true,"path":"2022/12/08/js-dev-7/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-7/","excerpt":"","text":"이전 글 [OpenLayers] Static Image 에서 설정한 Static Image 위에 주어진 위치의 아이콘을 표시하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. Script 기존 코드에서 addVectorLayer 함수와 styles 객체가 추가되었습니다. 먼저 ol.style.Icon 을 이용해서 아이콘 경로를 설정합니다. 12345678const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;; ol.Feature, ol.layer.Vector 이용해서 Vector Layer를 생성하고 지도에 레이어를 추가합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); &#125;, ///////////////////////////////////////////////////////&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); 결과 [100, 100] 위치에 아이콘이 표시됩니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Static Image","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"}]},{"title":"[OpenLayers] Static Image","slug":"js-dev-6","date":"2022-12-07T12:10:10.000Z","updated":"2023-03-14T02:26:17.068Z","comments":true,"path":"2022/12/07/js-dev-6/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/js-dev-6/","excerpt":"","text":"OpenLayers 사용하여 OSM(OpenStreetMap)으로 지도를 가시화하는 것이 아닌 Static Image를 Layer Source로 사용하여 이미지를 가시화하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. HTML 12345678910111213141516171819202122232425&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Static Map Example&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.css\" /&gt; &lt;style&gt; .map &#123; width: 100%; height: 600px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.js\"&gt;&lt;/script&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Script 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// main.js// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName);&#125;); OpenLayers 활용 라이브러리입니다. ol.proj.Projection ol.View ol.layer.Image ol.source.ImageStatic ol.Map 결과 Static Image 가 지정한 크기의 지도 중앙에 가시화됩니다. 참고 https://openlayers.org/en/latest/examples/static-image.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"}]},{"title":"[CentOS] Node.js 및 NPM 설치","slug":"linux-24","date":"2022-12-07T03:47:28.000Z","updated":"2023-06-05T00:53:37.987Z","comments":true,"path":"2022/12/07/linux-24/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/linux-24/","excerpt":"","text":"리눅스 환경에서 Node.js 와 NPM 설치하는 방법에 대해 알아보겠습니다. 운영환경 Centor 7.6 저장소 추가 설치하려는 Node.js 버전을 확인하여 NodeSource yum 저장소를 추가합니다. NodeSource Node.js Binary Distributions 사이트에 다음과 같은 내용이 정리되어있습니다. Node.js v19.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_19.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_19.x | sudo bash - Node.js v18.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash - Node.js v16.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_16.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash - Node.js v14.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_14.x | sudo bash - Node.js LTS (18.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo bash - Node.js Current (19.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_current.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_current.x | sudo bash - 설치 yum 을 사용하여 Node.js 및 npm 을 설치합니다. Node.js 14 버전을 설치해보도록 하겠습니다. 12$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -$ yum install -y nodejs 설치 확인 다음 명령어를 통해 설치된 버전을 확인할 수 있습니다. 12$ node --versionv14.20.0 12$ npm --version6.14.17 참고 https://github.com/nodesource/distributions","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[Ethereum] ganache-cli 설치 및 실행","slug":"blockchain-1","date":"2022-12-07T01:20:28.000Z","updated":"2023-06-05T00:42:26.936Z","comments":true,"path":"2022/12/07/blockchain-1/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/blockchain-1/","excerpt":"","text":"ganache-cli 를 설치하고 실행하는 방법에 대해 알아보겠습니다. Ganache &quot;가나슈&quot;라고 읽으면 되고, 가상의 이더리움 네트워크를 생성해서 Smart Contract 를 실행할 수 있도록 해주는 프로그램입니다. 이런 가상 환경을 TestRPC 라고 합니다. Ganache CLI Ganache CLI 는 빠르고 사용자 정의 가능한 블록체인 에뮬레이터인 TestRPC 의 최신 버전입니다. 실제 이더리움 노드를 실행하는 오버헤드 없이 블록체인을 호출할 수 있습니다. Transactions are “mined” instantly. No transaction cost. Accounts can be re-cycled, reset and instantiated with a fixed amount of Ether (no need for faucets or mining). Gas price and mining speed can be modified. A convenient GUI gives you an overview of your testchain events. NPM 설치 Ganache 는 NPM 을 통해 설치할 수 있습니다. 먼저 NPM 이 설치되어 있어야 합니다. 이전 글 Node.js 및 NPM 설치 을 참고해서 설치를 합니다. Ganache 설치 1$ npm install -g ganache-cli 실행 1$ ganache-cli &lt;options&gt; ganache-cli 명령어를 통해 실행합니다. 옵션 없이 실행 시 다음과 같은 결과를 볼 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ ganache-cliGanache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x3F82D42b4b946aA53fF069cF931d940872C3f675 (100 ETH)(1) 0x0912b4EdD5279FEE8362257adD75715424C51a39 (100 ETH)(2) 0x668fF7BD1fe9ffe6758B9d1f71fcdA22c56f68ce (100 ETH)(3) 0xD74Dd2D769763B78009a67b6b87c7810a7eb7E6d (100 ETH)(4) 0x6Ec7b0A1f88f482711f4C8b378c8B4c6dCB863EB (100 ETH)(5) 0xa7eed29620A49ca13F780b740d597Cc79092E2D9 (100 ETH)(6) 0xfE7f9A8E6c147A07bd1b0601431dc74468456174 (100 ETH)(7) 0x0b3a29F6174631a97fe9B9289c66456ddD27D069 (100 ETH)(8) 0x89b626bAF633fAb58986499195b4F98d15D09252 (100 ETH)(9) 0xA42521a288fD576f59E1F7A7461Dfe88A52cAF99 (100 ETH)Private Keys==================(0) 0xe7c964a0050a9c8c79008eab74502ea7c105a425b5e6b8ffe57d72eef4165c20(1) 0x098196b42d262985b0f0b43edc4a51919d8dd9925e0feee485859c5987b4af9c(2) 0x23738d8fc442fd26c7a802423868bbfc0c0d930f15baef50531483a1e9f7cecd(3) 0xa67eaa626df00109e219b5f94d33535d536b19d362fbf0eff08e7143383fd95e(4) 0xede8027c26a03ec63d6b9c404216fe6328936cc6584f93b3389901bfe34efef0(5) 0x30541fc3cac5dbe9e96a482dcd4100930270f9759d1e15494bbf26932fd6e873(6) 0xa8ed660d43f2c775efff16732088e34ab23775fa56375f491c8bec3123bde75c(7) 0x5cf88b19ce7be57320c2a89bf03a9ea5a512a5dc07f9e14f4a752fb1a021deac(8) 0x557ae7917ca63f17fbb947933c3ad13cc699f42293aafbebe24729f91708eabe(9) 0xbe44643a2507aa8fc13893f4052edd154e6753d74bec3f8a8ec6a88fda645c19HD Wallet==================Mnemonic: convince have junior clean bomb fluid gossip surprise build twenty urban swordBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;Gas Price==================20000000000Gas Limit==================6721975Call Gas Limit==================9007199254740991Listening on 127.0.0.1:8545 기존 Mnemonic 을 가지고 있다면 -m 옵션을 추가하여 설정할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435$ ganache-cli -d -m \"taxi\"Ganache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1 (100 ETH)(1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0 (100 ETH)(2) 0x22d491Bde2303f2f43325b2108D26f1eAbA1e32b (100 ETH)(3) 0xE11BA2b4D45Eaed5996Cd0823791E0C93114882d (100 ETH)(4) 0xd03ea8624C8C5987235048901fB614fDcA89b117 (100 ETH)(5) 0x95cED938F7991cd0dFcb48F0a06a40FA1aF46EBC (100 ETH)(6) 0x3E5e9111Ae8eB78Fe1CC3bb8915d5D461F3Ef9A9 (100 ETH)(7) 0x28a8746e75304c0780E011BEd21C72cD78cd535E (100 ETH)(8) 0xACa94ef8bD5ffEE41947b4585a84BdA5a3d3DA6E (100 ETH)(9) 0x1dF62f291b2E969fB0849d99D9Ce41e2F137006e (100 ETH)Private Keys==================(0) 0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d(1) 0x6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1(2) 0x6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c(3) 0x646f1ce2fdad0e6deeeb5c7e8e5543bdde65e86029e2fd9fc169899c440a7913(4) 0xadd53f9a7e588d003326d1cbf9e4a43c061aadd9bc938c843a79e7b4fd2ad743(5) 0x395df67f0c2d2d9fe1ad08d1bc8b6627011959b79c53d7dd6a3536a33ab8a4fd(6) 0xe485d098507f54e7733a205420dfddbe58db035fa577fc294ebd14db90767a52(7) 0xa453611d9419d0e56f499079478fd72c37b251a94bfde4d19872c44cf65386e3(8) 0x829e924fdf021ba3dbbc4225edfece9aca04b929d6e75613329ca6f1d31c0bb4(9) 0xb0057716d5917badaf911b193b12b910811c1497b5bada8d7711f758981c3773HD Wallet==================Mnemonic: taxiBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;... 실행 옵션 옵션들을 확인하여 환경에 맞게 실행합니다. -a or --accounts: 시작 시 생성할 계정 수를 지정합니다. -b or --blocktime: 자동 마이닝을 위한 블록 타임을 초 단위로 지정합니다. 기본값은 0이며 자동 마이닝이 없습니다. -d or --deterministic: 미리 정의된 니모닉을 기반으로 결정적 주소를 생성합니다. -n or --secure: 기본적으로 사용 가능한 계정 잠금(제3자 트랜잭션 서명에 적합) -m or --mnemonic: 특정 HD 지갑 니모닉을 사용하여 초기 주소를 생성합니다. -p or --port: 포트 번호 설정. 기본값은 8545 입니다. -h or --hostname: 호스트 이름. 기본값은 노드의 server.listen() 입니다. -s or --seed: 임의의 데이터를 사용하여 사용할 HD 지갑 니모닉을 생성합니다. -g or --gasPrice: 사용자 지정 가스 가격 설정(기본값은 20000000000) -l or --gasLimit: 사용자 지정 가스 한도 설정(기본값은 90000) -f or --fork: 주어진 블록에서 현재 실행 중인 다른 이더리움 클라이언트에서 분기합니다. 입력은 다른 클라이언트의 HTTP 주소 및 포트여야 합니다.(예: http://localhost:8545) -i or --networkId: ganache-cli가 자신을 식별하는 데 사용할 네트워크 ID를 지정합니다. --db: 체인 데이터베이스를 저장할 디렉토리 경로를 지정합니다. 데이터베이스가 이미 존재하는 경우 ganache-cli는 새 체인을 생성하는 대신 해당 체인을 초기화합니다. --debug: Output VM opcodes for debugging --mem: ganache-cli 메모리 사용량 통계를 출력합니다. --e: 사용자 계정별 가스를 설정합니다.(기본값은 100) 참고 https://www.npmjs.com/package/ganache-cli https://docs.nethereum.com/en/latest/ethereum-and-clients/ganache-cli/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"}]},{"title":"[CentOS] 사용자 계정 관리","slug":"linux-23","date":"2022-12-05T01:15:46.000Z","updated":"2023-03-14T02:26:14.477Z","comments":true,"path":"2022/12/05/linux-23/","link":"","permalink":"http://hgko1207.github.io/2022/12/05/linux-23/","excerpt":"","text":"리눅스 환경에서 사용자 계정 조회, 추가, 수정, 삭제하는 방법에 대해 알아보겠습니다. 사용자 조회 모든 사용자를 출력합니다. 123456$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin... 사용자 계정 확인 root 와 useradd 또는 adduser 명령어를 통해 생성한 사용자 계정을 출력합니다. 123$ grep /bin/bash /etc/passwdroot:x:0:0:root:/root:/bin/bashhgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 사용자 계정 확인 입력한 특정 사용자 계정을 출력합니다. 1$ cat /etc/passwd | grep [사용자계정] 12$ cat /etc/passwd | grep hgkohgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 조건(ID 500 이상)을 통해 사용자 목록을 조회합니다. 123456$ awk -F':' '&#123;if($3 &gt;= 500)print $1&#125;' /etc/passwdpolkitdunboundlibstoragemgmtcolord... 사용자 추가 useradd 1$ useradd [사용자계정] test 사용자를 생성합니다. 1$ useradd test 사용자 홈 디렉토리도 같이 만들고 싶다면 -m 또느 -d 옵션을 사용합니다. 12345# 홈 디렉토리를 지정할 때 사용하고 디렉토리가 없으면 생성$ useradd test -m# 홈 디렉토리 지정$ useradd test -d /home/test test 사용자의 비밀번호를 생성합니다. passwd 는 리눅스 사용자 계정의 비밀번호를 변경하는 명령어입니다. 12345$ passwd testChanging password for user test.New password: ****Retype new password: ****passwd: all authentication tokens updated successfully. adduser adduser 명령어는 useradd 명령어와 달리 사용자 홈 디렉토리를 자동으로 만들고, 비밀번호 설정 등로 한 번에 할 수 있습니다. 1234567891011121314151617$ adduser testAdding user `test' ...Adding new group `test' (1000) ...Adding new user `test' (1000) with group `test' ...Creating home directory `/home/test' ...Copying files from `/etc/skel' ...New password: ****Retype new password: ****passwd: password updated successfullyChanging the user information for testEnter the new value, or press ENTER for the default Full Name []: test Room Number []: Work Phone []: Home Phone []: Other []:Is the information correct? [Y/n] 사용자 수정 1$ usermod [option] [사용자계정] test 사용자의 홈 디렉토리를 변경합니다. 1$ usermod -d /home/test1 test 사용자 삭제 1$ userdel [사용자계정] test 사용자를 삭제합니다. 1$ userdel test test 사용자를 강제로 삭제합니다. 1$ userdel -f test test 사용자와 함께 사용자 디렉토리도 같이 삭제합니다. 1$ userdel -r test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"}]},{"title":"리눅스 명령어","slug":"linux-22","date":"2022-11-30T02:05:43.000Z","updated":"2023-03-14T02:26:09.998Z","comments":true,"path":"2022/11/30/linux-22/","link":"","permalink":"http://hgko1207.github.io/2022/11/30/linux-22/","excerpt":"","text":"자주 사용하는 리눅스 명령어에 대해 알아보겠습니다. 명령어 설명 cdcd …cd -cd ~cd /cd [path] 디렉토리 이동 cp [path] [target] -R 파일 복사 tar cvfz backup.tar.gz [target] tar 로 압축 tar cvfz backup.tar.gz /test --exclude “/test/backup” 특정 디렉토리 제외하고 tar 로 압축 tar xvfz backup.tar.gz 압축 풀기 which [command]예) which find 특정 명령어의 위치 source /etc/profile 환경 설정 적용 find / -name [파일명]예) find / -name ‘test’ 파일 찾기 ls -al 디렉토리 조회 du -skh 디렉토리 용량 확인 df -h 디스크 용량 확인 ps -ef | grep [실행프로세스]예) ps -ef | grep tomcat 실행 프로세스 확인 kill -9 [pid] 프로세스 강제 종료 grep -nR [단어] * 예) grep -nR ‘/test/’ * 특정 단어 존재 여부 검사 mkdir [디렉토리명] 디렉토리 생성 rmdir [디렉토리명] 디렉토리 삭제 rm [파일명] 파일 삭제 pwd 현재 디렉토리 위치 catcat [파일명] 파일 내용 출력 id 사용자 로그인명 useradd [id] 계정 추가 userdel [id] 계정 삭제 usermod [id] 계정 수정 passwod [id] 비밀번호 변경 chmod 실행 권한 clear 화면 내용 지우기 free 메모리 확인 w 사용자 로그인 정보 top 시스템 운용상황 점검","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[JPA] CascadeType 정리","slug":"spring-jpa-6","date":"2022-11-29T04:51:38.000Z","updated":"2023-03-14T02:26:01.325Z","comments":true,"path":"2022/11/29/spring-jpa-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/29/spring-jpa-6/","excerpt":"","text":"동일 트랜잭션 내부 연관 엔티티가 수정되었을 경우 CascadeType 과 상관 없이 자동으로 수정됩니다. 같은 트랜젝션이라 하더라도 해당 엔티티가 CasecadeType.PERSIST 로 설정 되어 있지 않으면 연관 엔티티를 추가 하더라도 반영되지 않습니다. (CascadeType.MERGE 로 설정 되어도 추가는 되지 않음) CascadeType 별 동작 CascadeType.ALL 상위 엔티티에서 하위 엔티티로 모든 작업을 전파합니다. 모든 Cascade 설정을 적용합니다. CascadeType.PERSIST 상위 엔티티를 생성하고, 하위 엔티티를 추가 하였을때 persist() 를 수행하면 하위 엔티티도 같이 persist() 가 수행됩니다. 만약, 하위 엔티티가 DB에 등록된 키값을 가졌다면 detached entity passed to persist 예외가 발생합니다. CascadeType.MERGE 트랜젝션이 종료 되고 detach 상태에서 하위 엔티티를 추가하거나 변경된 이후에 상위 엔티티가 merge() 를 수행하게 되면 변경 사항이 적용됩니다. 하위 엔티티의 추가 및 수정 모두 반영됩니다. CascadeType.REMOVE 삭제 시 연관된 하위 엔티티들도 같이 삭제됩니다. CascadeType.DETACH 상위 엔티티가 detech() 를 수행 하게 되면 연관된 하위 엔티티도 detach() 상태가 되어 변경 사항이 반영되지 않습니다. 고려사항 부모/자식 간의 관계를 설정하는 과정에서 부모가 데이터베이스에 존재하지 않는 경우 데이터 무결성의 문제가 발생합니다. 자식 레코드를 삭제하지 않은 상태에서 부모 레코드를 먼저 삭제하려 시도하는 경우 참조 무결성 위반이 발생합니다. 참고 https://www.baeldung.com/jpa-cascade-types","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"}]},{"title":"[Spring] QuerydslRepositorySupport 사용","slug":"spring-querydsl-2","date":"2022-11-28T02:45:08.000Z","updated":"2023-03-14T02:25:59.231Z","comments":true,"path":"2022/11/28/spring-querydsl-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-2/","excerpt":"","text":"QueryDslPredicateExecutor 를 이용하는 findAll, findOne 등은 where, Sort, Limit 등의 조건만 넣을 수 있습니다. 하지만 Join 이나 Group by 등의 기능을 사용하려면 인터페이스 선언만으로는 기능을 구현하기 힘듭니다. 이를 해결하기 위해서 Spring Data JPA 에서 제공하는 QuerydslRepositorySupport 추상 클래스가 있습니다. QuerydslRepositorySupport 는 개발자에게 querydsl 객체를 직접 제공합니다. 예를 들어 권한별 사용자 수에 대한 데이터가 필요하다면, 다음과 같이 할 수 있습니다. 사용자 클래스와 DTO 클래스를 생성합니다. 1234567891011121314151617@Data@Entity@Tablepublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column(nullable = false, length = 50) private String username; @Column(nullable = false, length = 50) private String password; private int role;&#125; 123456789101112@Datapublic class UserRoleCountDTO &#123; private int role; private long count; public UserRoleCountDTO(int role, long count) &#123; this.role = role; this.count = count; &#125;&#125; 권한별 사용자 수를 얻어오는 인터페이스를 생성하고 메소드를 선언합니다. 123public interface UserRepositoryCustom &#123; List&lt;UserRoleCountDTO&gt; getUserRoleCount();&#125; UserRepository 에 상속 시킵니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt;, UserRepositoryCustom &#123;&#125; QuerydslRepositorySupport 를 이용해서 UserRepositoryCustom 를 구현하는 클래스를 작성합니다. UserRepository 이름 뒤에 Impl 이라는 Postfix 가 붙으면 자동으로 Spring Data JPA 의 AOP 주입 대상이 됩니다. 12345678910111213public class UserRepositoryImpl extends QuerydslRepositorySupport implements UserRepositoryCustom &#123; public UserRepositoryImpl() &#123; super(User.class); &#125; @Override public List&lt;UserRoleCountDTO&gt; getUserRoleCount() &#123; QUser user = QUser.user; return from(user).groupBy(user.role) .list(Projections.constructor(UserRoleCountDTO.class, user.role, user.role.sum)); &#125;&#125; 위의 예제를 통해 JpaRepository 의 기능과 추가로 구현한 UserRepositoryCustom 의 추가 기능까지 사용할 수 있습니다. 1234567891011@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public void testQuery() &#123; List&lt;UserRoleCountDTO&gt; userRoleCountDTOs = userRepository.getUserRoleCount(); System.out.println(\"result =&gt;\" + userRoleCountDTOs); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"}]},{"title":"[Spring] JPA with Querydsl","slug":"spring-querydsl-1","date":"2022-11-28T01:57:14.000Z","updated":"2023-03-14T02:25:56.997Z","comments":true,"path":"2022/11/28/spring-querydsl-1/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-1/","excerpt":"","text":"Query DSL JPA, JDO, SQL 같은 백엔드를 위해 type-safe SQL을 만드는 프레임워크 Domain Specific Language 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어 특징 type-safe 조회에 특화된 프로그래밍 언어 단순, 간결 다양한 저장소 조회 기능 통합 (데이터 조회 기능 추상화) 동작 방식 Member java or Member table 의 메타 데이터를 참조하여 코드 생성기를 통해 QMember.java 를 생성합니다. APT: Annotation Processing Tool Table Meta: Querydsl-maven-plugin 기능 Query: from, where, join Path: QMember, Qmember.name Expression: name.eq, name.qt 세부기능 from innerJoin, join, leftJoin, fetchJoin, fullJoin, on where (and, or, allOf, anyOf) groupBy having order By (desc, asc) limit, offset, restrict(limit + offset) (Paging) list listResults (list + Paging Info(totalCount)) iterate count singleResult, uniqueResult 사용 방법 설정 Spring Boot 프로젝트의 pom.xml 에 의존성과 플러그인을 추가합니다. QueryDSL 을 사용하기 위해서는 com.querydsl 에서 제공하는 querydsl-jpa 와 querydsl-apt 에 대한 의존성이 필요합니다. 123456789101112131415&lt;!-- dependencies 에 추가 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jdo&lt;/artifactId&gt;&lt;/dependency&gt; com.mysema.maven 에서 제공하는 apt-maven-plugin 을 설치합니다. 123456789101112131415161718&lt;!-- build - plugins 에 추가 --&gt;&lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;sourceEncoding&gt;UTF-8&lt;/sourceEncoding&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 이제 프로젝트 우클릭 후 maven -&gt; Update Project… 수행하면 Entity 에 대한 Q 클래스들이 target/generated-sources/java 경로에 생성된 것을 확인할 수 있습니다. 도메인 클래스 생성 테이블 도메인 클래스를 생성합니다. 1234567891011@Entity@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 인터페이스를 작성합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123;&#125; Querydsl 사용 예 Repository 인터페이스에 QuerydslPredicateExecutor 를 확장합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt;, QuerydslPredicateExecutor&lt;Team&gt; &#123;&#125; 1234567891011@Service@RequiredArgsConstructorpublic class TeamService &#123; private final TeamRepository teamRepository; public void testQuerydsel &#123; teamRepository.findAll(QTeam.team.name.eq(\"test\"1)); teamRepository.findOne(QTeam.team.rating.loe(100)); &#125;&#125; JPAQuery 사용 예 JPAQuery 을 Bean 등록 후 사용 가능합니다. 1234567891011@SpringBootApplicationpublic class TestWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestWebApplication.class, args); &#125; @Bean public JPAQueryFactory jpaQueryFactory(EntityManager em) &#123; return new JPAQueryFactory(em); &#125;&#125; 123456789101112131415@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl() &#123; QTeam team = QTeam.team; List&lt;Team&gt; teams = query.from(team) .where(team.name.eq(\"test1\").or(team.name.like(\"hgko%\"))) .list(team); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125; BooleanBuilder 사용 예 상황에 따라 동적으로 변경되는 쿼리를 작성할 경우 BooleanBuilder 를 사용하면 간편하게 쿼리를 작성할 수 있습니다. 12345678910111213141516171819@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl(String name) &#123; QTeam team = QTeam.team; // 검색 조건에 따른 동적 쿼리 작성 BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(name)) &#123; builder.and(team.name.contains(name)); &#125; List&lt;Team&gt; teams = factory.selectFrom(team).where(builder).fetch(); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"}]},{"title":"[JPA] NamedQuery","slug":"spring-jpa-5","date":"2022-11-25T01:10:56.000Z","updated":"2023-03-14T02:25:54.403Z","comments":true,"path":"2022/11/25/spring-jpa-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/25/spring-jpa-5/","excerpt":"","text":"NamedQuery 란 Entity 에 @NamedQuery 어노테이션을 통해 쿼리를 지정해줍니다. 쉽게 말하면 미리 이름을 부여해서 재활용 할 수 있는 JPQL 입니다. 사용 방법 도메인 클래스에 @NamedQuery 또는 @NamedNativeQuery 를 정의합니다. 2개 이상의 Query 를 정의하려면 @NamedQueries 또는 @NamedNativeQueries 를 사용하면 됩니다. Primary Key 가 되는 컬름은 @Id 를 사용하여 지정합니다. 테이블의 컬럼명과 도메인 클래스의 필드명이 다를경우 @Column 을 이용하여 지정할 수 있습니다. 클래스 생성 위의 설명의 어노테이션을 사용하여 도메인 클래스를 생성합니다. 12345678910111213141516171819@Entity@NamedQueries(&#123; @NamedQuery(name = \"Team.query1\", query = \"select t.id from Team t where t.name = 'test1'\"), @NamedQuery(name = \"Team.query2\", query = \"select t.name from Team t where t.name = ?1\"),&#125;)@NamedNativeQueries(&#123; @NamedNativeQuery(name = \"Team.nativeQuery1\", query = \"select t.id from tb_team t where t.name = 'test1'\"), @NamedNativeQuery(name = \"Team.nativeQuery2\", resultClass = Team.class, query = \"select * from tb_team t where t.name = '?1\")&#125;)@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 생성 Repository 인터페이스에 직접 @Query 를 이용하여 SQL문을 사용할 수 있습니다. nativeQuery 를 사용하려면 해당 필드를 true 로 설정하면 됩니다. @Param 을 사용하여 Query문의 파라메타와 연결할 수 있습니다. entityName 을 사용하면 도메인 타입이 자동으로 설정됩니다. 12345678910111213141516public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123; @Query(value = \"select * from tb_team t where t.name = 'test1'\", nativeQuery = true) List&lt;Team&gt; testNativeQuery(); @Query(value = \"select t.id from #&#123;#entityName&#125; t where t.name like :name%\", nativeQuery = true) List&lt;String&gt; testNativeQuery(@Param(\"name\") String name); List&lt;Integer&gt; query1(); List&lt;String&gt; query2(String name); List&lt;Integer&gt; nativeQuery1(); List&lt;Team&gt; nativeQuery2(String name);&#125; 위와 같이 클래스에 Native 쿼리문을 작성하고 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"}]},{"title":"[JPA] 쿼리 메서드","slug":"spring-jpa-4","date":"2022-11-24T06:24:06.000Z","updated":"2023-03-14T02:25:52.187Z","comments":true,"path":"2022/11/24/spring-jpa-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-4/","excerpt":"","text":"Spring Data JPA 쿼리 메서드는 가장 강력한 메서드이며, SQL 쿼리를 작성하지 않고도 데이터베이스에서 레코드를 선택하는 쿼리 메서드를 만들 수 있습니다. 백그라운드에서 Spring Data JPA 는 쿼리 메서드를 기반으로 SQL 쿼리를 생성하고 쿼리를 실행합니다. Entity 필드를 사용하여 Repository 에 대한 쿼리 메서드를 생성할 수 있으며 쿼리 메서드 생성을 finder methods(findBy, findAll …)라고도 합니다. 예 findByEmailAddressAndName() 이 쿼리 메서드인 UserRepository 가 있다고 가정합니다. 123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndName(String emailAddress, String name);&#125; 백그라운드에서 Spring Data JPA 는 위의 메서드(findByEmailAddressAndName)에서 JPA 기준 API를 사용하여 쿼리를 생성하지만 기본적으로 다음과 같은 JPQL 쿼리로 변환됩니다. 1select u from User u where u.emailAddress = ?1 and u.name = ?2 키워드들 JPA에 대해 지원되는 키워드와 해당 키워드를 포함하는 메서드가 무엇을 의미하는지 설명합니다. Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname, findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstname) = UPPER(?1) 참고 https://www.javaguides.net/2018/11/spring-data-jpa-query-creation-from-method-names.html https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"}]},{"title":"[JPA] @ElementCollection 사용 예","slug":"spring-jpa-3","date":"2022-11-24T06:05:52.000Z","updated":"2023-03-14T02:25:49.513Z","comments":true,"path":"2022/11/24/spring-jpa-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-3/","excerpt":"","text":"RDB(Relational DataBase) 에는 Collection 형태의 데이터를 컬럼에 저장할 수 있는 방법이 없습니다. 그래서 별도의 테이블을 생성하고 Collection 을 관리해야 합니다. JPA 의 @ElementCollection 사용하여 별도의 테이블을 생성하고 Collection 을 관리할 수 있습니다. ElementCollection 특징은 부모 Entity 에 의해 관리되고, 항상 부모와 함께 저장되고 삭제됩니다. casecade 옵션이 default 입니다. 예 Collection 대상이 되는 객체는 @Entity 가 아닌 Embeddable Class 로 생성하여 One-To-Many 관계를 맺습니다. 12345678910@Embeddable@Datapublic class Address &#123; @Column(length = 50) public String address; @Column(length = 50) public String detailAddress;&#125; @ElementCollection 생성하여 Collection 테이블을 생성합니다. 1234567891011121314@Entity@Datapublic class User &#123; @ElementCollection(fetch = FetchType.LAZY) @CollectionTable( name = \"user_address\", joinColumns = @JoinColumn(name = \"userId\") ) @ForeignKey(name = \"fk_user_address\") private List&lt;Address&gt; addresses; ...&#125; 결과 다음과 같은 DDL 스크립트가 만들어집니다. 1234567CREATE TABLE `user_address` ( `user_id` int(11) NOT NULL, `address` varchar(50) DEFAULT NULL, `detail_address` varchar(50) DEFAULT NULL, KEY `fk_user_address` (`user_id`), CONSTRAINT `fk_user_address` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 참고 https://prohannah.tistory.com/133","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"}]},{"title":"[MySQL] 스토리지 엔진(Storage Engine)","slug":"mysql-7","date":"2022-11-23T04:49:27.000Z","updated":"2023-03-14T02:25:46.489Z","comments":true,"path":"2022/11/23/mysql-7/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-7/","excerpt":"","text":"MySQL 스토리지 엔진 종류 및 간단 비교 내용입니다. MyISAM 정적인 테이블, 로그 테이블 쓰기 작업이 별로 없는 select 위주의 테이블 다수의 세션이 동시 작업을 하는 경우 성능이 저하 됨 InnoDB 민감한 정보를 갖는 테이블 (회원 등) 갱신 (읽기 / 쓰기) 위주의 트랜잭션이 요구되는 테이블 인덱스가 많이 걸린 대량의 테이블 Archive 로그 수집에 적합 데이터가 메모리상에서 압축된 후 압축된 상태로 디스크에 저장 Memory 일시적으로만 사용되는 임시 테이블","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"}]},{"title":"[MySQL] 유용 명령어","slug":"mysql-6","date":"2022-11-23T04:32:58.000Z","updated":"2023-03-14T02:25:44.036Z","comments":true,"path":"2022/11/23/mysql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-6/","excerpt":"","text":"Help 1234HELP SHOW;HELP &#123;SELECT | DELETE | UPDATE&#125;;HELP ALTER;HELP ALTER &#123;DATABASE | TABLE&#125;; Show 123SHOW PRIVILEGES;SHOW OPEN TABLES;SHOW TABLE STATUS; 테이블 컬럼 조회 명령어입니다. (코멘트 포함) 1SHOW FULL COLUMNS FROM 테이블명; Select 12345-- 왜래키 규약SELECT * FROM information_schema.REFERENTIAL_CONSTRAINTS;-- PRIMARY KEY, UNIQUE 규악 등SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_schema = 데이터베이스명; 백업 1$ mysqldump &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &gt; 백업파일명.sql 복구 1$ mysql &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &lt; 백업파일명.sql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[MySQL] ALTER TABLE 구문 정리","slug":"mysql-5","date":"2022-11-23T02:06:21.000Z","updated":"2023-03-14T02:25:39.687Z","comments":true,"path":"2022/11/23/mysql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-5/","excerpt":"","text":"MySQL 에서 사용하는 ALTER TABLE 구문에 대해 알아보겠습니다. 테이블 관련 테이블 생성 테이블 2개를 생성합니다. 1234567891011CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, age INT, name VARCHAR(50), jumin VARCAHR(15), PRIMARY KEY(id), UNIQUE(age), INDEX(name), KEY(jumin), INDEX(name, jumin)); 12345CREATE TABLE test2 ( id INT, parent_id INT, FOREIGN KEY (parent_id) REFERENCES test(id) ON DELETE CASCADE ON UIPDATE CASCADE); INDEX 를 KEY 로 바꿔도 됩니다. INDEX(name, jumin) 과 INDEX(name), INDEX(jumin) 은 다릅니다. 테이블 속성 변경 [] 에 들어가 있는 내용은 생략 가능합니다. 1. 필드 추가 12ALTER TABLE 테이블명 ADD [COLUMN] 추가할필드명 필드타입 [FIRST | AFTER 필드명];ALTER TABLE 테이블명 ADD [COLUMN] (추가할필드명 필드타입, ...); 2. 필드명 및 타입 변경 1ALTER TABLE 테이블명 CHANGE [COLUMN] 기존필드명 변경할필드명 변경할필드타입 [FIRST | AFTER 필드명]; 3. 필드 타입 변경 1ALTER TABLE 테이블명 MODIFY [COLUMN] 기존필드명 변경할필드명 [FIRST | AFTER 필드명]; 4. 필드 삭제 1ALTER TABLE 테이블명 DROP [COLUMN] 제거할필드명; 5. 필드 디폴트 정의 1ALTER TABLE 테이블명 ALTER [COLUMN] 필드명 &#123;SET DEFAULT 'XXX' | DROP DEFAULT&#125;; 6. 테이블명 변경 1ALTER TABLE 테이블명 RENAME 변경할테이블명; 7. COMMENT 추가 12ALTER TABLE 테이블명 COMMENT '내용';ALTER TABLE 테이블명 MODIFY 필드명 필드타입 [DEFAULT 'XXX'] COMMENT '내용'; 인덱스 관련 인덱스 생성 INDEX 123CREATE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD INDEX [인덱스명] [인덱스타입] (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD KEY [인덱스명 ] [인덱스타입] (필드1, 필드2, ...); UNIQUE 12CREATE UNIQUE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] UNIQUE [인덱스명] [인덱스타입] (필드1, 필드2, ...); PRIMARY KEY 1ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] PRIMARY KEY [인덱스타입] (필드1, 필드2, ...); FOREIGN KEY 외래키 생성 시 제약 조건과 INDEX 가 같이 생성되며, 외래키를 삭제 하더라도 INDEX 는 남게됩니다. 만약 인덱스도 삭제가 필요하다면 같이 삭제해야합니다. 123ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] FOREIGN KEY [인덱스명] (필드1, 필드2, ...) [레퍼런스조건] ON UPDATE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT] ON DELETE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT]; FULLTEXT 12CREATE FULLTEXT INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD FULLTEXT [인덱스명 ] (필드1, 필드2, ...); 인덱스 보기 1SHOW INDEX FROM 테이블명 인덱스 삭제 1234DROP INDEX 인덱스명 ON 테이블명;ALTER TABLE 테이블명 DROP INDEX 인덱스명;ALTER TABLE 테이블명 DROP INDEX PRIMARY KEY;ALTER TABLE 테이블명 DROP INDEX FOREIGN KEY [fk_symbol]; 기타 키 활성화 12ALTER TABLE 테이블명 ENABLE KEYS;ALTER TABLE 테이블명 DISABLE KEYS; 정렬 1ALTER TABLE 테이블명 ORDER BY 필드명; 캐릭터 셋 12ALTER TABLE 테이블명 CONVER TO CHARACTER SET 캐릭터셋ALTER TABLE 테이블명 CHARACTER SET 캐릭터셋 데이터베이스 엔진 변경 1ALTER TABLE 테이블명 ENGINE=&#123;InnoDB | MyISAM&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"}]},{"title":"[MySQL] 인덱스(INDEX) 정리","slug":"mysql-4","date":"2022-11-17T06:57:35.000Z","updated":"2023-03-14T02:25:36.785Z","comments":true,"path":"2022/11/17/mysql-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-4/","excerpt":"","text":"인덱스(index)란? 인덱스(index)는 테이블에서 원하는 데이터를 쉽고 빠르게 찾기 위해 사용합니다. 이러한 인덱스는 자주 사용되는 필드 값으로 만들어진 원본 테이블의 사본이라고 생각할 수 있습니다. MySQL은 데이터를 검색할 때 첫 번째 필드부터 차례대로 테이블 전체를 검색합니다. 따라서 테이블이 크면 클수록 데이터를 탐색하는 시간도 많이 늘어나게 됩니다. 장점 MIN(), MAX() 등의 함수를 사용하는 쿼리에 대해 해당 필드에 인덱스가 있는 경우 빠르게 찾을 수 있습니다. ORDER BY 와 GROUP BY 를 빠르게 수행할 수 있습니다. 단점 ISAM, MyISAM 테이블 인덱스를 무겁게 만들면 인덱스 파일이 데이터 파일보다 더 빠르게 최대 크기에 도달됩니다. BDB(Berkeley DB) 테이블은 동일한 파일 내에 데이터와 인덱스 값을 함께 저장하며, 인덱스를 추가 하게 되면 해당 테이블의 최대 파일 크기에 빠르게 도달하게 됩니다. InnoDB 테이블은 테이블 스페이스 안에 모든 공간을 공유하는 구조이며, 인덱스를 추가하면 테이블 스페이스 내의 공산을 빠르게 소모합니다. 검색속도는 향상되지만 삽입, 삭제, 갱신 속도는 느려집니다. 고려사항 인덱스를 위한 컬럼을 선택하는 가장 좋은 기준은 WHERE 절 안에 나오는 컬럼, 조인 절에 명명된 컬럼, ORDER BY, GROUP BY 절에 나오는 컬럼 등이 된다는 것 입니다. SELECT 키워드 뒤에 나오는 출력 컬럼, 목록에만 나오는 컬럼은 좋은 선택이 아닙니다. 유일한 인덱스 사용: 유일한 값을 가지고 있는 컬럼들에 대해 효과가 좋고, 중복된 값들이 많은 컬럼들에 대해 효과가 나쁩니다. 짧은 값으로 인덱스를 만듭니다. 가장 왼쪽의 접두어를 활용합니다. 인덱스 생성 CREATE 문을 사용하여 인덱스를 생성할 수 있습니다. 1CREATE INDEX 인덱스명 ON 테이블명 (필드명1, 필드명2, ...) 이때 쉼표(,)를 사용하여 여러 필드를 가지는 인덱스를 생성할 수도 있습니다. 12-- 예CREATE INDEX NameIdx On Test (Name); 인덱스 추가 기본 인덱스에서 필드의 값은 같은 값이 여러 번 저장될 수 있으며, NULL 값을 가질 수도 있습니다. 1ALTER TABLE 테이블명 ADD INDEX 인덱스명 (필드명) 12-- 예ALTER TABLE Test ADD INDEX NameIdx (Name); 인덱스 삭제 ALTER 문으로 삭제 ALTER 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1ALTER TABLE 테이블명 DROP INDEX 인덱스명 12-- 예ALTER TABLE Test DROP INDEX NameIdx; DROP 문으로 삭제 DROP 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1DROP INDEX 인덱스명 ON 테이블명 12-- 예DROP INDEX NameIdx ON Test; 인덱스 정보 보기 생성한 인덱스를 확인할 수 있습니다. 1SHOW INDEX FROM 테이블명 이때 반환되는 인덱스 정보의 필드 값은 다음과 같습니다. Table : 테이블의 이름을 표시함. Non_unique : 인덱스가 중복된 값을 저장할 수 있으면 1, 저장할 수 없으면 0을 표시함. Key_name : 인덱스의 이름을 표시하며, 인덱스가 해당 테이블의 기본 키라면 PRIMARY로 표시함. Seq_in_index : 인덱스에서의 해당 필드의 순서를 표시함. Column_name : 해당 필드의 이름을 표시함. Collation : 인덱스에서 해당 필드가 정렬되는 방법을 표시함. Cardinality : 인덱스에 저장된 유일한 값들의 수를 표시함. Sub_part : 인덱스 접두어를 표시함. Packed : 키가 압축되는(packed) 방법을 표시함. Null : 해당 필드가 NULL을 저장할 수 있으면 YES를 표시하고, 저장할 수 없으면 ''를 표시함. Index_type : 인덱스에 사용되는 메소드(method)를 표시함. Comment : 해당 필드를 설명하는 것이 아닌 인덱스에 관한 기타 정보를 표시함. Index_comment : 인덱스에 관한 모든 기타 정보를 표시함. 참고 http://www.tcpschool.com/mysql/mysql_index_create","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"}]},{"title":"[MySQL] 계정 관리","slug":"mysql-3","date":"2022-11-17T04:34:33.000Z","updated":"2023-05-30T14:09:54.949Z","comments":true,"path":"2022/11/17/mysql-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-3/","excerpt":"","text":"MySQL 에서 계정 생성 및 권한 부여와 계정 정보 수정하는 방법에 대해 알아보겠습니다. 로그인 root 의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MySQL [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MySQL [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 123456789MySQL [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+ 계정 생성 사용자 계정을 생성하는 방법입니다. CREATE 문으로 생성 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; INSERT 문으로 생성 1INSERT INTO user (host, user, password) VALUES ('localhost', '계정명', password('비밀번호')); ’localhost’ 를 ‘%’ 로 변경하면 원격에서 접속 가능합니다. 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. GRANT 문으로 권한 부여 1grant all privileges on *.* to 'USERNAME'@'%' identified by 'PASSWORD'; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; INSERT 문으로 권한 부여 12INSERT INTO db (Host, Db, USer, select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv)VALUES ('localhost', 'DB명', '계정명', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'); DB명에 ‘%’ 를 넣으면 모든 DB를 나타냅니다. 계정 정보 변경 계정의 비밀번호 변경 하는 방법입니다. UPDATE 문으로 변경 1UPDATE user SET password=password('비밀번호') where user='계정명'; SET 문으로 변경 1SET PASSWORD FOR '계정명'@'localhost' = PASSWORD('비밀번호'); 계정 삭제 DELETE 문으로 삭제 12DELETE FROM user WHERE user = '계정명';DELETE FROM db WHERE user = '계정명'; DROP 문으로 삭제 1DROP USER '계정명'@'localhost'; 권한 삭제 1REVOKE ALL ON *.* FROM '계정명'; 권한 확인 1234567MySQL [mysql]&gt; SHOW GRANTS FOR root;+--------------------------------------------------------------------------------------------------------------+| Grants for root@% |+--------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO `root`@`%` IDENTIFIED BY PASSWORD '*D08D94B3E46A8CCDA5F1682F57F8BE24F5FD1C79' |+--------------------------------------------------------------------------------------------------------------+1 row in set (0.002 sec) 설정 적용 위의 설정 명령어들을 실행 후 다음 명령어를 실행해야 적용이 됩니다. 1flush privileges;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[MySQL] 접속 에러 해결 방법","slug":"mysql-2","date":"2022-11-15T06:35:01.000Z","updated":"2023-06-15T01:28:02.178Z","comments":true,"path":"2022/11/15/mysql-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/mysql-2/","excerpt":"","text":"MySQL 서버에 접속 시도시 다음과 같은 에러가 발생할 경우 해결 방법입니다. 123$ sudo mysql -u rootERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (111) MySQL 사용자로 접속 시도시 /var/lib/mysql/ 경로에서 mysql.sock 파일을 찾을 수 없어서 나오는 오류입니다. 먼저 mysql.sock 파일을 찾습니다. 12$ find / -name \"mysql.sock\"/db/mysql_data/mysql.sock 해결 1 my.cnf 파일을 열고 다음 항목을 추가합니다. 12345$ vi /etc/my.cnf[client]socket=/db/mysql_data/mysql.sock[mysqld]socket=/db/mysql_data/mysql.sock 해결 2 심볼릭 링크를 사용합니다. 1$ ln -s /db/mysql_data/mysql.sock /var/lib/mysql/mysql.sock","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Java] Iteration 예","slug":"java-dev-11","date":"2022-11-15T06:20:43.000Z","updated":"2023-03-14T02:25:28.271Z","comments":true,"path":"2022/11/15/java-dev-11/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-11/","excerpt":"","text":"Iteration 람다(Lambda)의 forEach 함수를 사용하는 예제입니다. 사용 예 1List&lt;String&gt; friends = Arrays.asList(\"Brian\", \"Nate\", \"Neal\", \"Raju\", \"Sara\", \"Scott\"); 기존 for 문 1234567for (int i = 0; i &lt; friends.size(); i++) &#123; System.out.println(friends.get(i));&#125;for (String name : friends) &#123; System.out.println(name);&#125; 1234567# 결과BrianNateNealRajuSaraScott forEach 사용 forEach 함수를 사용한 예제입니다. 첫 번째부터 마지막까지 점점 코드가 간략해지는 것을 볼 수 있습니다. 12345678910111213141516// 1)friends.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String name) &#123; System.out.println(name); &#125;&#125;);// 2)friends.forEach((final String name) -&gt; System.out.println(name));// 3)friends.forEach(name -&gt; System.out.println(name));// 4)friends.forEach(System.out::println); 결과는 모두 같습니다. 1234567# 결과BrianNateNealRajuSaraScott","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"}]},{"title":"[Java] 스트림(Stream) 사용","slug":"java-dev-10","date":"2022-11-15T05:08:03.000Z","updated":"2023-03-14T02:25:26.029Z","comments":true,"path":"2022/11/15/java-dev-10/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-10/","excerpt":"","text":"스트림(stream) Java 8 버전부터 추가되었고 특정 요소 형식으로 이루어진 연속된 값에 대한 집합 인터페이스를 제공합니다. filter, map, reduce, sort, find 등의 함수들을 제공합니다. 사용 예 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String name; private String age;&#125; 123456List&lt;Person&gt; people = Arrays.asList( new Person(\"Eden\", 20), new Person(\"Ko\", 21), new Person(\"Lee\", 21), new Person(\"Kang\", 25)); Mutable 21살 이상의 사람을 찾는 코드입니다. filter 를 사용하여 20살 초과인 사람만 찾고 List 에 값을 넣는 예제입니다. 123456List&lt;Person&gt; olderThan20 = new ArrayList&lt;&gt;();people.stream() .filter(person -&gt; person.getAge() &gt; 20) .forEach(person -&gt; olderThan20.add(person));System.out.println(\"People older than 20: \" + olderThan20); 12# 결과People older than 20: [Person(name=Ko, age=21), Person(name=Lee, age=21), Person(name=Kang, age=25)] Collect collect 를 사용하여 ArrayList 형식의 List 를 반환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);System.out.println(\"People older than 20: \" + olderThan20); Collect To List Collectors.toList() 를 사용하여 Collect 형식을 List 로 변환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(Collectors.toList());System.out.println(\"People older than 20: \" + olderThan20); Group By(1) 나이를 Key 로 해서 Map 을 생성하는 예제입니다. 1234Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge));System.out.println(\"Grouped by age: \" + peopleByAge); 12# 결과Grouped by age: &#123;20=[Person(name=Eden, age=20)], 21=[Person(name=Ko, age=21), Person(name=Lee, age=21)], 25=[Person(name=Kang, age=25)]&#125; Group By(2) 값을 Person 객체가 아닌 이름으로 구성하는 예제입니다. 12345Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge, Collectors.mapping(Person::getName, Collectors.toList())));System.out.println(\"People grouped by age: \" + nameOfPeopleByAge); 12# 결과People grouped by age: &#123;20=[Eden], 21=[Ko, Lee], 25=[Kang]&#125; reducing 이름의 첫글자가 같은 사람 중 나이가 많은 사람만 찾는 예제입니다. 12345678// 나이 비교Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge);Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = people.stream() .collect(Collectors.groupingBy(person -&gt; person.getName().charAt(0), Collectors.reducing(BinaryOperator.maxBy(byAge))));System.out.println(\"Oldest person of each letter: \" + oldestPersonOfEachLetter); 12# 결과Oldest person of each letter: &#123;E=Optional[Person(name=Eden, age=20)], K=Optional[Person(name=Kang, age=25)], L=Optional[Person(name=Lee, age=21)]&#125; 예제들을 통해 스트림(Stream) 사용하는 방법을 알아봤습니다. 제공하는 함수들을 잘 사용하면 좋은 결과 값을 얻을 수 있습니다. 참고 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"}]},{"title":"Java 8 람다(Lambda) 적용 예","slug":"java-dev-9","date":"2022-11-09T01:17:47.000Z","updated":"2023-03-14T02:25:23.737Z","comments":true,"path":"2022/11/09/java-dev-9/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-9/","excerpt":"","text":"람다(Lamdba) 란 람다식, 또는 람다 함수라 부른다. 프로그래밍 언어에서 사용되는 개념으로, 익명 함수(Anonymous functions)를 지칭하는 용어이다. 나무위키 예제 Map 에서 특정한 값을 가지는 entry 에 대해서 삭제하는 코드입니다. 1234567891011121314Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"XXX\", \"111\");map.put(\"YYY\", \"222\");map.put(\"ZZZ\", \"333\");map.put(\"AAA\", \"444\");map.put(\"BBB\", \"555\");map.entrySet().stream() .filter(entry -&gt; entry.getValue().equals(\"111\")) .map(entry -&gt; entry.getKey()) .collect(Collectors.toList()) .forEach(map::remove);System.out.println(map); 실행 결과입니다. 1&#123;YYY=222, ZZZ=333, AAA=444, BBB=555&#125; 만약, collect 함수를 삭제할 경우 컴파일 에러는 없지만 다음과 같은 예외를 발생합니다. 12Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:20) 삭제하는 코드를 간략하게 구현할 수 있지만 위의 예제는 람다식의 다양한 함수를 보여주기 위해 사용하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"}]},{"title":"Java 8 스트림 적용시 성능 변화","slug":"java-dev-8","date":"2022-11-09T01:02:33.000Z","updated":"2023-03-14T02:25:19.532Z","comments":true,"path":"2022/11/09/java-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-8/","excerpt":"","text":"for 문 1234567891011121314int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = 0;for (long i = startIndex; i &lt; endIndex; i++) &#123; sum += i;&#125;long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 11919ms Stream 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 33446ms parallel 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).parallel().sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 9407ms 결과 기존 for 문으로 구현한 방식을 자바의 stream 형태로 변경했을 때 성능은 저하되나 병렬 처리를 사용하면 성능 향상을 할 수 있습니다. for 문은 병렬 처리를 하려면 여러 쓰레드에 공유 자원에 대한 접근을 고려하여 구현해야 하기 때문에 쉽지 않은데 자바의 stream 을 사용할 경우 병럴 처리로 변경하는 과장이 parallel() 메소드만 호출하면 가능합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"}]},{"title":"[PostgreSQL] 사용자, 그룹 관리","slug":"postgresql-6","date":"2022-11-08T05:03:30.000Z","updated":"2023-03-14T02:25:17.153Z","comments":true,"path":"2022/11/08/postgresql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-6/","excerpt":"","text":"실행 파일을 통합 방법 사용자 생성 1$ createuser hgko --createdb --no-superuser --no-createrole 사용자 삭제 1$ dropuser hgko DB 접속을 통한 방법 GROUP 생성, 수정, 삭제 SYSID: 내부의 GROUP ID 구분용 숫자 코드이며, 설정하지 않으면 자동으로 100부터 1씩 증가합니다. (1~99는 핵심적인 그룹을 위함) 자동으로 설정되게 하면됩니다. GROUP 생성 1234CREATE GROUP [그룹명];CREATE GROUP [그룹명] WITH USER user1, user2, user3;CREATE GROUP [그룹명] WITH SYSID 100 USER user1;CREATE GROUP [그룹명] WITH SYSID 100; GROUP 수정 123ALTER GROUP [그룹명] ADD USER user4, user5;ALTER GROUP [그룹명] DROP USER user3;ALTER GROUP [그룹명] RENAME TO [새로운 그룹명]; GROUP 삭제 1DROP GROUP [그룹명]; GROUP 조회 123456-- 1)postgres=# \\dgpostgres=# \\du-- 2)select * from pg_group; 사용자 생성, 수정, 삭제 사용자 생성 1CREATE USER test_user CREATEDB CREATEUSER IN GROUP test_group UNENCRYPTED PASSWORD '1234'; 사용자 생성에 사용되는 옵션들입니다. [ SUPERUSER | NOSUPERUSER ] [ CREATEDB | NOCREATEDB ] [ CREATEROLE | NOCREATEROLE ] [ CREATEUSER | NOCREATEUSER ] [ LOGIN | NOLOGIN ] [ ENCRYPTED | UNENCRYPTED ] PASSOWRD ‘password’ VALID UNTIL ‘timestamp’ IN ROLE role_name [, …] IN GROUP group_name [, …] ROLE role_name [, …] ADMIN role_name [, …] USER role_name [, …] SYSID uid 사용자 수정 1ALTER USER [사용자명] RENAME TO [새로운 사용자명]; 사용자 삭제 1DROP USER [사용자명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"}]},{"title":"[PostgreSQL] 사용자 인증","slug":"postgresql-5","date":"2022-11-08T04:39:56.000Z","updated":"2023-03-14T02:25:14.589Z","comments":true,"path":"2022/11/08/postgresql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-5/","excerpt":"","text":"사용자 인증 Postgresql 을 처음 설치하게 되면 비밀번호를 묻지 않고 로그인을 할 수 있습니다. 인증과정을 포함하려면 pg_hba.conf 에서 설정해야 합니다. pg_hba.conf 파일은 initdb 에서 생성된 클러스터 폴더에 위치합니다. Authentication Method 필드의 값에 따라서 인증처리가 됩니다. trust: 패스워드 없이 접근 가능 (local 이외에는 비추천) reject: 거부 md5: 패스워드를 md5 로 암호화해서 전송 password: text 로 패스워드를 사용 (스니핑에 바로 보임) 사용 예제 TCP/IP 로 127.0.0.1 에 접근시 모든 DB, 사용자로의 접근에 패스워드가 필요없는 예제입니다. 1host all all 127.0.0.1/32 trust TCP/IP 로 192.168.0.1 에 접근시 hgko 계정으로 모든 DB 에 대한 접근이 허용되며, md5 로 패스워드를 암호화 해야 하는 예제입니다. 1host all hgko 192.168.0.1/32 md5 TCP/IP 로 192.168.0.1 에 접근시 hgko 계정으로 mydb,test DB 에 대한 접근이 허용되며, md5 로 패스워드를 암호화 해야 하는 예제입니다. 1host mydb,test hgko 192.168.0.1/32 md5 원격 어디서든지 remotegroup 의 SYSID 로 설정된 계정들로 remotedb 의 접근이 허용되며, md5 로 패스워드를 암호화 해야 하는 예제입니다. 1host remotedb +remotegroup 0.0.0.0/0 md5 모든 호스트로 부터 접속 허용 postgresql.conf 파일을 수정합니다. 1listen_addresses = '*' pg_hba.conf 파일을 수정합니다. 12# TYPE DATABASE USER CIDR-ADDRESS METHODhost all all 0.0.0.0/0 md5 참고 https://www.postgresql.kr/docs/9.5/auth-methods.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"}]},{"title":"[Oracle] 사용자 및 테이블 조회","slug":"oracle-5","date":"2022-11-04T07:57:39.000Z","updated":"2023-03-14T02:25:12.225Z","comments":true,"path":"2022/11/04/oracle-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-5/","excerpt":"","text":"테이블 스페이스 남은 공간 조회 현재 접속한 사용자의 DEFAULT_TABLESPACE 남은 공간을 조회합니다. 123456789101112SELECT ts.tablespace_name, TO_CHAR(SUM(NVL(fs.bytes, 0)) / 1024 / 1024, '99,999,990.99') AS MB_FREEFROM user_free_space fs, user_tablespace ts, user_users usWHERE fs.tablespace_name(+) = ts.tablespace_name AND ts.tablespace_name(+) = us.default_tablespaceGROUP BY ts.tablespace_name; ‘user_’ prefix 가 붙게 되면 로그인한 계정에 관련된 내용이 출력됩니다. 사용자 조회 123SQL&gt; SELECT * FROM user_users;SQL&gt; SELECT username, user_id, default_tablespace FROM dba_users;SQL&gt; SELECT * FROM all_users; 테이블 조회 1234SQL&gt; SELECT * FROM tab;SQL&gt; SELECT table_name, tablespace_name FROM user_tables;SQL&gt; SELECT owner, table_name, tablespace_nsme, cluster_name FROM dba_tables;SQL&gt; SELECT * FROM all_tables;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"}]},{"title":"[Oracle] 테이블 스페이스 사용 방법","slug":"oracle-3","date":"2022-11-04T06:44:12.000Z","updated":"2023-03-14T02:25:06.546Z","comments":true,"path":"2022/11/04/oracle-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-3/","excerpt":"","text":"테이블 스페이스(Table Space)란 테이블스페이스(Tablespace)는 데이터베이스 오브젝트 내 실제 데이터를 저장하는 공간이다. 이것은 데이터베이스의 물리적인 부분이며, 세그먼트로 관리되는 모든 DBMS에 대해 저장소(세그먼트)를 할당한다. 테이블스페이스는 단지 데이터베이스 저장소 위치를 지정할 뿐이며, 논리적 데이터베이스 구조나 스키마를 지정하지 않는다. 예를 들면, 동일한 스키마내의 다른 오브젝트는 서로 다른 테이블스페이스에 놓일 수 있다. 마찬가지로, 하나의 테이블스페이스는 여러 세그먼트들을 서비스 할 수 있다. 위키백과 테이블 스페이스 조회 12SQL&gt; SELECT * FROM dba_tablespaces;SQL&gt; SELECT * FROM dba_data_files; 테이블 스페이스 생성 오라클 DBMS는 테이블스페이스 생성을 위해 CREATE TABLESPACE 명령어를 사용합니다. 123SQL&gt; CREATE TABLESPACE [테이블스페이스명] DATAFILE '/db/oracle_data/ts.dbf' SIZE 200M autoextent on next 100M; DATAFILE: 파일 경로 SIZE: 초기 데이터 파일 크기 설정 autoextent on next: 초기 크기 공간을 모두 사용하는 경우 자동으로 파일의 크기가 커지는 기능 테이블 스페이스 삭제 123SQL&gt; DROP TABLESPACE [테이블스페이스명] INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS; INCLUDING CONTENTS: 테이블 스페이스의 모든 세그먼트 삭제 INCLUDING CONTENTS AND DATAFILES: 테이블 스페이스의 물리적파일까지 삭제 CASCADE CONSTRAINTS: 제약 조건 삭제 테이블 스페이스 이동 12SQL&gt; ALTER TABLE [테이블명] MOVE TABLESPACE [테이블스페이스명];SQL&gt; ALTER INDEX [인덱스명] REBUILD TABLESPACE [테이블스페이스명];","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[Oracle] 계정 관리","slug":"oracle-4","date":"2022-11-04T06:44:12.000Z","updated":"2023-03-14T02:25:09.565Z","comments":true,"path":"2022/11/04/oracle-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-4/","excerpt":"","text":"Oracle 에서 계정 생성, 삭제 및 권한을 부여하는 방법입니다. 계정 생성 및 권한 부여 12345SQL&gt; CREATE USER [계정] IDENTIFIED BY [비밀번호] DEFAULT TABLESPACE [테이블스페이스명] QUOTA unlimited ON [테이블스페이스명] -- 테이블 스페이스의 내용을 모두 쓸 수 있다. TEMPORARY TABLESPACE [임시테이블스페이스명]; 123456-- 예SQL&gt; CREATE USER test IDENTIFIED BY 123!@#QWE DEFAULT TABLESPACE users QUOTA unlimited ON users TEMPORARY TABLESPACE temp; 계정 기본 테이블 스페이스 변경 12SQL&gt; ALTER USER [계정] DEFAULT TABLESPACE [테이블스페이스명];SQL&gt; ALTER USER [계정] TEMPORARY TABLESPACE [임시테이블스페이스명]; 계정 삭제 CASCADE 를 명시하면 계정과 관련된 모든 데이터베이스 스키마가 삭제되고 모든 스키마 객체도 물리적으로 삭제됩니다. 1SQL&gt; DROP USER [계정] CASCADE; 계정별 Lock 상태 조회 12SQL&gt; SELECT username, account_status, to_char(lock_date, 'YYYY-MM-DD HH24:MI') lock_date FROM dba_users; Lock 해제 1SQL&gt; ALTER USER [계정] IDENTIFIED BY [비밀번호] ACCOUNT UNLOCK;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[CentOS] Service 등록 및 실행 방법","slug":"linux-21","date":"2022-11-03T08:07:08.000Z","updated":"2023-03-14T02:25:04.233Z","comments":true,"path":"2022/11/03/linux-21/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/linux-21/","excerpt":"","text":"리눅스 환경에서 Tomcat 을 구동하는 서비스를 등록하고 실행하는 방법에 대해 알아보겠습니다. Service 파일 생성 /etc/systemd/system/ 위치에 service 파일을 생성합니다. 1$ sudo vi /etc/systemd/system/tomcat-server.service 1234567891011121314[Unit]Description=TOMCAT SERVER ServiceAfter=network.target syslog.target[Service]Type=forkingUser=rootGroup=rootExecStart=/usr/local/tomcat-server/bin/startup.shExecStop=/usr/local/tomcat-server/bin/shutdown.sh[Install]WantedBy=multi-user.target Description: 서비스 설명 ExecStart: 실행할 서버 및 프로그램이 위치한 전체 경로 ExecStop: 종료할 서버 및 프로그램이 위치한 전체 경로 WantedBy: systemctl enable 명령어로 유닛을 등록할때 등록에 필요한 유닛 지정 Service 등록 생성한 서비스를 등록합니다. 1$ sudo systemctl enable tomcat-server.service Service 비활성화 1$ sudo systemctl disable tomcat-server.service Service 시작 1$ sudo systemctl start tomcat-server.service Service 재시작 1$ sudo systemctl restart tomcat-server.service Service 종료 1$ sudo systemctl stop tomcat-server.service Service 실행 확인 1$ sudo systemctl status tomcat-server.service Service 목록 확인 1$ sudo systemctl list-unit-files","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"WGS84 - 도분초 변환","slug":"satellite-wgs84","date":"2022-11-03T07:58:10.000Z","updated":"2023-01-02T13:34:41.253Z","comments":true,"path":"2022/11/03/satellite-wgs84/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/satellite-wgs84/","excerpt":"","text":"세계 지구 좌표 시스템(World Geodetic System, WGS) 1984년에 제정된 범 지구적 측위 시스템으로 지도학, 측지학, 항법에 많이 사용된다. GPS측량 시 WGS84 타원체를 사용한다. 통칭 및 약칭은 WGS 84 (aka WGS 1984, EPSG:4326, WGS84)라고 부르며, 2004년에 마지막으로 개정되었다. 이전에 쓰던 초안으로 WGS 72, WGS 66, 그리고 WGS 60이 있다. 위키백과 3735.0079 는 위도로서 37도 35.0079분을 뜻합니다. 도(degree) 단위로 환산시, 대략 37.5도가 됩니다. 12701.6446 은 경도로서 127도 1.6446분을 뜻합니다. 도(degree) 단위로 환산시, 대략 127.0도가 됩니다. DDMM.MMMM , DDDMM.MMMM 형식입니다. 일반적으로 WGS84 좌표라고 하면서 37.494961 , 127.030380 이런식으로 이용하면 그냥 37점494961도 라고 읽으면 됩니다. 도분초 변환 도를 도 분 초로 변환하는 자바 소스 코드입니다. 12345678910float lat = 37.494961;float lon = 127.030380;lat_do = (int)lat;lat_min = (lat - (int)lat) * 60;lat_sec = ((lat - (int)lat) * 60 - lat_min) * 60;lon_do = (int)lon;lon_min = (lon - (int)lon) * 60;lon_sec = ((lon - (int)lon) * 60 - lon_min) * 60;","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"}]},{"title":"Angular Development with TypeScript","slug":"book-2","date":"2022-11-02T03:40:45.000Z","updated":"2023-03-04T12:56:02.340Z","comments":true,"path":"2022/11/02/book-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/02/book-2/","excerpt":"","text":"책 정보 책 소개 Angular는 Google이 주관하는 웹 애플리케이션 프레임워크다. 개발자들에게 큰 인기를 끌었던 이전 버전의 AngularJS는 이제 새로운 구조와 철학을 도입해서 완전히 새로운 프레임워크가 되어 돌아왔다. 새로운 버전의 Angular에서 제공하는 훌륭한 기능과 웹 컴포넌트 기반 철학을 깊이 있게 알아보고, 데이터를 뷰에 표시하는 방법, 사용자가 입력한 폼 데이터 처리, 서버와 통신, 테스트와 배포까지 애플리케이션의 모든 개발 단계를 다룬다. 더불어 현업에 바로 적용할 수 있도록 다양한 예제와 함께 설명하며, 중대형 규모의 애플리케이션 개발에 적합한 TypeScript와 ES6에 대해서도 알아본다. 이 책을 마지막까지 읽고 나면, 실무에 바로 도입할 수준이 될 것이다. 리뷰 최근 Angular로 프로젝트를 진행할 일이 생겨서 읽게 되었습니다. 예전에 나온 책이라 최근 Angular 버전과는 차이가 있지만 각 핵심 내용이 잘 정리가 되어 있고 번역서임에도 불구하고 번역이 굉장히 깔끔하였습니다. 분량이 많아 필요한 부분을 정독했는데 좋은 예제들로 쉽게 이해시켜줘서 프로젝트를 진행하는데 도움이 많이 된 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[MariaDB] 계정 생성 및 권한 부여","slug":"mariadb-1","date":"2022-10-28T08:19:20.000Z","updated":"2023-05-30T14:08:56.361Z","comments":true,"path":"2022/10/28/mariadb-1/","link":"","permalink":"http://hgko1207.github.io/2022/10/28/mariadb-1/","excerpt":"","text":"MariaDB 에서 계정을 생성하고 권한을 부여하는 방법입니다. 로그인 root 의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MariaDB [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 12345678910MariaDB [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+4 rows in set (0.002 sec) 계정 생성 로컬에서만 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'localhost' IDENTIFIED BY 'test!@'; 로컬 및 원격에서 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'%' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'%' IDENTIFIED BY 'test!@'; 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. 1grant all privileges on *.* to '계정명'@'%' identified by '비밀번호'; 1234-- 예MariaDB [mysql]&gt; grant all privileges on *.* to 'test'@'%' identified by 'test!@';-- 변경된 권한 적용MariaDB [mysql]&gt; flush privileges; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; 123-- 예)MariaDB [mysql]&gt; grant all privileges on test_db.* to 'test'@'%' identified by 'test!@';MariaDB [mysql]&gt; flush privileges; 확인 계정 생성이 완료되면 생성된 계정으로 로그인 합니다. 1$ sudo mysql -u test -p","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"}]},{"title":"[CentOS] MariaDB 설치","slug":"linux-20","date":"2022-10-26T04:32:16.000Z","updated":"2023-06-02T09:28:45.760Z","comments":true,"path":"2022/10/26/linux-20/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/linux-20/","excerpt":"","text":"리눅스 환경에서 MariaDB 설치 방법에 대해 알아보겠습니다. MariaDB 란 MariaDB는 오픈 소스의 관계형 데이터베이스 관리 시스템이다. MySQL과 동일한 소스 코드를 기반으로 하며, GPL v2 라이선스를 따른다. 오라클 소유의 현재 불확실한 MySQL의 라이선스 상태에 반발하여 만들어졌으며, 배포자는 몬티 프로그램 AB와 저작권을 공유해야 한다. 위키백과 MariaDB 저장소 추가 yum 저장소에는 MariaDB 라이브러리가 없기 때문에 저장소를 추가합니다. MariaDB Server 다운로드 사이트에 연결한 후에 MariaDB Repositories 탭을 클릭합니다. 사용하는 배포판을 선택합니다. 설치할 버전을 선택합니다. 미러 사이트를 선택합니다. 4번에 있는 내용을 아래 명령어를 실행한 후에 복사합니다. 1[root@localhost ~]$ vi /etc/yum.repos.d/MariaDB.repo 1234567891011# MariaDB 10.4 CentOS repository list - created 2023-06-02 08:54 UTC# https://mariadb.org/download/[mariadb]name = MariaDB# rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details.# baseurl = https://rpm.mariadb.org/10.4/centos/$releasever/$basearchbaseurl = https://tw1.mirror.blendbyte.net/mariadb/yum/10.4/centos/$releasever/$basearchmodule_hotfixes = 1# gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDBgpgkey = https://tw1.mirror.blendbyte.net/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck = 1 설치 저장소를 추가하였다면 설치를 합니다. 1[root@localhost ~]$ sudo yum install MariaDB-server MariaDB-client 설치 확인 잘 설치가 되었는지 확인합니다. 12345[root@localhost ~]$ rpm -qa | grep MariaDBMariaDB-common-10.4.26-1.el7.centos.x86_64MariaDB-client-10.4.26-1.el7.centos.x86_64MariaDB-server-10.4.26-1.el7.centos.x86_64MariaDB-compat-10.4.26-1.el7.centos.x86_64 서비스 시작 부팅시 자동시작되도록 서비스를 등록하고 시작합니다. 12[root@localhost ~]$ systemctl enable mariadb[root@localhost ~]$ systemctl start mariadb 패스워드 변경 패스워드를 변경합니다. 1[root@localhost ~]$ /usr/bin/mysqladmin -u root password '패스워드' 접속 확인 다음 명령어를 실행한 후 패스워드를 입력하면 접속이 됩니다. 1234567891011[root@localhost ~]$ mysql -u root -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.4.26-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; 모든 IP 허용 외부에서 접속을 하기 위해 모든 IP가 허용가능하도록 설정합니다. 12MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '패스워드';MariaDB [(none)]&gt; FLUSH PRIVILEGES; 방화벽 포트 개방 12[root@localhost ~]$ netstat -anp | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 12596/mysqld Mariadb 포트는 3306 입니다. 외부에서 접속하기 위해 3306 포트를 개방합니다. 123456# 포트 개방[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3306/tcp# 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload# 개방된 포트 목록 확인[root@localhost ~]$ firewall-cmd --list-ports 참고 https://zetawiki.com/wiki/CentOS7_MariaDB_%EC%84%A4%EC%B9%98","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"}]},{"title":"NVM 설치 및 사용 방법","slug":"nodejs-4","date":"2022-10-26T01:44:59.000Z","updated":"2023-03-14T02:24:58.780Z","comments":true,"path":"2022/10/26/nodejs-4/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/nodejs-4/","excerpt":"","text":"Windows 환경에서 NVM 을 설치하고 Node 버전을 관리하는 방법에 대해 알아보겠습니다. NVM(Node Version Manager) NVM 은 Node.js 의 버전을 관리하는 도구입니다. 여러 개의 Node.js 버전을 설치할 수 있고 설치된 모든 버전을 확인 할 수 있습니다. 그리고 필요에 따라 버전 변경도 할 수 있습니다. 설치 NVM Github Repository 사이트에 접속합니다. nvm-setup.zip 또는 nvm-setup.exe 을 선택하여 다운로드 하고 설치를 합니다. 사용 NPM 버전 조회 현재 최신의 사용가능한 Node.js 버전이 조회됩니다. 1$ nvm list available NPM 설치 원하는 버전을 입력하여 설치합니다. 1$ nvm install [node version] 예시입니다. 12$ nvm install 19.0.0$ nvm install 18.11.0 설치 확인 설치되어 있는 Node.js 버전들이 조회됩니다. 1$ nvm list 버전 변경 설치된 Node.js 버전들 중에서 사용하려는 버전으로 변경할 수 있습니다. 1$ nvm use [node version] 예시입니다. 1$ nvm use 18.11.0 Node.js 버전 확인 Node.js 버전이 설치 또는 변경되었는지 확인합니다. 1$ node -v 여기까지 NVM 설치 및 사용 포스팅을 마치겠습니다. 참고 https://github.com/nvm-sh/nvm","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"}]},{"title":"[JavaScript] 주민등록번호 유효성 검사","slug":"js-dev-5","date":"2022-10-23T08:26:18.000Z","updated":"2023-03-14T02:24:53.744Z","comments":true,"path":"2022/10/23/js-dev-5/","link":"","permalink":"http://hgko1207.github.io/2022/10/23/js-dev-5/","excerpt":"","text":"JavaScript 에서 주민등록번호 유효성 검사 방법에 대해 알아보겠습니다. 주민등록번호란 주민등록번호는 “주민의 거주관계를 파악하고 상시로 인구의 동태를 명확히 하여 행정사무의 적정하고 간이한 처리를 도모함”(1962년 주민등록법) 등을 목적으로 만든 일련번호로서, 개개인의 신원을 명확하게 구분하는 역할을 한다. 나무위키 내국인과 외국인 주민등록번호 유효성을 검사하는 소스코드입니다. 내국인 주민등록번호와 달리 외국인 등록번호는 뒤 7자리 숫자의 첫 숫자가 2000년 이전 출생 외국인에게는 남자는 5, 여자는 6, 2000년 이후 출생 외국인에게는 남자는 7, 여자는 8로 부여하고 있습니다. 내국인 주민등록번호 숫자는 1, 2, 3, 4 로 시작됩니다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;label class=\"font-weight-bold\"&gt;주민등록번호 입력 :&lt;/label&gt; &lt;div class=\"d-flex align-items-center\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"jumin1\" required /&gt; &lt;span class=\"font-weight-bold mx-2\"&gt;-&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" id=\"jumin2\" required /&gt; &lt;/div&gt; &lt;button type=\"button\" onclick=\"validate()\"&gt;검증&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const CommonUtil = (function () &#123; // 내국인/외국인 주민등록번호 유효성 검사 const validRegistrationNumber = function (rn, type) &#123; rn = rn.split('-').join(''); if (rn.length !== 13) return false; let checkSum = 0; for (let i = 0; i &lt; 12; i++) &#123; checkSum += (rn.substr(i, 1) &gt;&gt; 0) * ((i % 8) + 2); &#125; const korMatch = (11 - (checkSum % 11)) % 10 == rn.substr(12, 1); const frnMatch = (13 - (checkSum % 11)) % 10 == rn.substr(12, 1); if (type === 'local') return korMatch; else if (type === 'foreigner') return frnMatch; else return korMatch || frnMatch; &#125;; return &#123; // 주민등록번호가 내국민인지 외국인인지 분류 // 뒤 7자리의 첫번째 숫자가 1,2,3,4 일경우 내국인 / 5,6,7,8 일경우 외국인 validateJumin: function (ssn1, ssn2) &#123; const ssnType = ssn2.substr(0, 1); const rn = ssn1 + ssn2; if (ssnType == '5' || ssnType == '6' || ssnType == '7' || ssnType == '8') &#123; const type = 'foreigner'; &#125; else &#123; const type = 'local'; &#125; return validRegistrationNumber(rn, type); &#125;, &#125;;&#125;)();document.addEventListener('DOMContentLoaded', function () &#123; // 주민등록번호 검증 확인 function validate() &#123; const jumin1 = document.getElementById('jumin1'); const jumin2 = document.getElementById('jumin2'); const ssn1 = jumin1.value; const ssn2 = jumin2.value; return CommonUtil.validateJumin(ssn1, ssn2); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"}]},{"title":"[Python] OpenCV Sharpening","slug":"python-3","date":"2022-10-22T14:41:19.000Z","updated":"2023-03-14T02:24:50.685Z","comments":true,"path":"2022/10/22/python-3/","link":"","permalink":"http://hgko1207.github.io/2022/10/22/python-3/","excerpt":"","text":"Python 에서 OpenCV 를 사용하여 Sharpening 하는 방법에 대해 알아보겠습니다. Sharpening Sharpening 기법은 Bluring 과 반대되는 개념으로, 초점이 잘 맞은 사진처럼 사물의 윤곽이 뚜렷하고 선명한 느낌이 나도록 하는 것이다. 설치 Python 에서 OpenCV 를 사용하기 위해 패키지를 설치합니다. 1$ pip install opencv-python 예제 원본 이미지에 여러가지의 커널을 적용하여 선명하게 표현하였습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import cv2import numpy as npimport matplotlib.pyplot as pltimage = cv2.imread('images/lenna.png', cv2.IMREAD_GRAYSCALE)# 커널 생성(대상이 있는 픽셀을 강조)kernel_sharpen_1 = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])kernel_sharpen_2 = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])kernel_sharpen_3 = np.array([[1, 1, 1], [1, -7, 1], [1, 1, 1]])kernel_sharpen_4 = np.array([[-1, -1, -1, -1, -1], [-1, 2, 2, 2, -1], [-1, 2, 8, 2, -1], [-1, 2, 2, 2, -1], [-1, -1, -1, -1, -1]]) / 8.0smoothed = cv2.GaussianBlur(image, (5, 5), 1)unsharped = cv2.addWeighted(image, 1.5, smoothed, -0.5, 0)# 커널 적용image_sharp1 = cv2.filter2D(image, 0, kernel_sharpen_1)image_sharp2 = cv2.filter2D(image, 0, kernel_sharpen_2)image_sharp3 = cv2.filter2D(image, 0, kernel_sharpen_3)image_sharp4 = cv2.filter2D(image, 0, kernel_sharpen_4)fig, ax = plt.subplots(2, 3, figsize=(10, 5))ax[0][0].imshow(image, cmap='gray')ax[0][0].set_title('Original Image')ax[0][1].imshow(unsharped, cmap='gray')ax[0][1].set_title('addWeighted')ax[0][2].imshow(image_sharp1, cmap='gray')ax[0][2].set_title('image_sharp1')ax[1][0].imshow(image_sharp2, cmap='gray')ax[1][0].set_title('image_sharp2')ax[1][1].imshow(image_sharp3, cmap='gray')ax[1][1].set_title('image_sharp3')ax[1][2].imshow(image_sharp4, cmap='gray')ax[1][2].set_title('image_sharp4')plt.show(); 결과 필터에 따라 Sharpening 적용된 이미지를 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"}]},{"title":"[Angular] Cytoscape 사용 방법","slug":"angular-8","date":"2022-10-12T06:53:50.000Z","updated":"2023-07-20T14:29:27.212Z","comments":true,"path":"2022/10/12/angular-8/","link":"","permalink":"http://hgko1207.github.io/2022/10/12/angular-8/","excerpt":"","text":"Cytoscape 소개 Cytoscape 은 점 (node) 과 선 (edge)으로 이루어진 네크워크의 가시화, 통합, 분석을 가능하게하는 프리 오픈소스 소프트웨어입니다. 자바로 구현되어 있어 윈도우, 맥, 리눅스등에서 자유롭게 구동합니다. Cytoscape 라이브러리를 사용하여 노드 간의 절차를 시각화하는 그래프를 구현하는 방법에 대해 알아보겠습니다. 설치 cytoscape 패키지를 설치합니다. 1$ npm install --save cytoscape cytoscape-klay TypeScript 사용 시 추가로 설치합니다. 1$ npm install --save-dev @types/cytoscape 설정 angular.json 파일에서 다음의 내용을 추가합니다. 1\"scripts\": [\"./node_modules/cytoscape/dist/cytoscape.min.js\"], 예제 app.component.html 1&lt;div id=\"cy\"&gt;&lt;/div&gt; 그래프의 스타일을 정의합니다. app.component.scss 12345#cy &#123; height: 300px; width: 100%; display: block;&#125; cytoscape 패키지를 import 합니다. 기본적으로 container, elements, style 및 layout 옵션을 설정합니다. 노드 간의 연결을 시각화 하기 위해 layout 에 klay 를 정의합니다. app.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import &#123; Component, OnInit &#125; from '@angular/core';import cytoscape from 'cytoscape';import klay from 'cytoscape-klay';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; /** * constructor */ constructor() &#123;&#125; /** * ngOnInit */ ngOnInit(): void &#123; cytoscape.use(klay); const cy = cytoscape(&#123; container: document.getElementById('cy'), // container to render in elements: [ // node &#123; data: &#123; id: 'step1', name: 'step1' &#125; &#125;, &#123; data: &#123; id: 'step2', name: 'step2' &#125; &#125;, &#123; data: &#123; id: 'step3', name: 'step3' &#125; &#125;, &#123; data: &#123; id: 'step4', name: 'step4' &#125; &#125;, // edge &#123; data: &#123; id: '1', source: 'step1', target: 'step2' &#125; &#125;, &#123; data: &#123; id: '2', source: 'step1', target: 'step3' &#125; &#125;, &#123; data: &#123; id: '3', source: 'step2', target: 'step4' &#125; &#125;, &#123; data: &#123; id: '4', source: 'step3', target: 'step4' &#125; &#125;, ], style: [ // the stylesheet for the graph &#123; selector: 'node', style: &#123; content: 'data(name)', shape: 'rectangle', 'text-wrap': 'wrap', 'text-halign': 'center', 'text-valign': 'center', 'background-color': '#6FB1FC', width: '40px', height: '40px', color: 'black', 'font-size': '10px', &#125;, &#125;, &#123; selector: 'edge', style: &#123; 'curve-style': 'bezier', 'line-color': '#000000', 'target-arrow-shape': 'triangle', 'target-arrow-fill': 'filled', 'target-arrow-color': '#000000', width: '1px', 'line-style': 'solid', opacity: 0.666, &#125;, &#125;, ], layout: &#123; name: 'klay', &#125;, &#125;); const options = &#123; name: 'klay', nodeDimensionsIncludeLabels: true, klay: &#123; borderSpacing: 100, fixedAlignment: 'BALANCED', edgeRouting: 'POLYLINE', edgeSpacingFactor: 10, inLayerSpacingFactor: 2.0, layoutHierarchy: true, linearSegmentsDeflectionDampening: 3.0, spacing: 30, mergeEdges: false, &#125;, &#125;; cy.layout(options).run(); &#125;&#125; 아래 참고 사이트에서 예제 및 옵션 설정에 대해 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://js.cytoscape.org/ https://github.com/cytoscape/cytoscape.js","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"}]},{"title":"[Angular] Markdown 사용 방법","slug":"angular-7","date":"2022-09-29T04:30:09.000Z","updated":"2023-07-20T14:34:03.704Z","comments":true,"path":"2022/09/29/angular-7/","link":"","permalink":"http://hgko1207.github.io/2022/09/29/angular-7/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular 에서 ngx-markdown 패키지를 사용하여 Markdown 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown 패키지를 설치합니다. 1$ npm install ngx-markdown --save 설정 angular.json 파일에서 다음의 내용을 추가합니다. 123456789101112131415&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"scripts\": [ \"node_modules/marked/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; 예제 MarkdownModule 을 import 합니다. 1234567891011121314// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; MarkdownModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, MarkdownModule.forRoot()], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; markdown 태그를 사용하여 작성합니다. 1234567&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;markdown [data]=\"markdownText\"&gt;&lt;/markdown&gt; &lt;/div&gt;&lt;/div&gt; markdownText 에 임시로 데이터를 입력합니다. 123456789101112131415161718// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; constructor() &#123; this.markdownText = `# Test`; &#125; ngOnInit(): void &#123;&#125;&#125; 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://www.npmjs.com/package/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"}]},{"title":"[Angular] Markdown Editor 사용 방법","slug":"angular-6","date":"2022-09-28T01:07:39.000Z","updated":"2023-07-20T14:34:38.712Z","comments":true,"path":"2022/09/28/angular-6/","link":"","permalink":"http://hgko1207.github.io/2022/09/28/angular-6/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular 에서 ngx-markdown-editor 패키지를 사용하여 Markdown Editor 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown-editor 와 ace-builds, bootstrap, font-awesome 패키지도 필수로 설치합니다. 12$ npm install ngx-markdown-editor --save$ npm install ace-builds bootstrap font-awesome --save 설정 angular.json 파일에서 다음 내용을 추가합니다. 12345678910111213141516171819202122232425262728&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"assets\": [ &#123; \"glob\": \"**/*\", \"input\": \"node_modules/ace-builds/src-min\", \"output\": \"./assets/ace-builds/\" &#125; ], \"styles\": [ \"node_modules/bootstrap/dist/css/bootstrap.min.css\", \"node_modules/font-awesome/css/font-awesome.min.css\", \"node_modules/ngx-markdown-editor/assets/highlight.js/agate.min.css\" ], \"scripts\": [ \"node_modules/ngx-markdown-editor/assets/highlight.js/highlight.min.js\", \"node_modules/ngx-markdown-editor/assets/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; index.html 파일에서 아래 내용을 추가합니다. 123456&lt;html&gt; &lt;head&gt; &lt;script src=\"/assets/ace-builds/ace.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 예제 LMarkdownEditorModule 을 import 합니다. 12345678910111213141516// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; LMarkdownEditorModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, FormsModule, AppRoutingModule, LMarkdownEditorModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; md-editor 태그를 사용하여 작성합니다. 123456789101112131415161718&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;md-editor id=\"description\" name=\"description\" [upload]=\"doUpload\" [(ngModel)]=\"markdownText\" [mode]=\"mode\" [options]=\"options\" required height=\"400px\" &gt;&lt;/md-editor&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Option, Text, Mode, Upload 설정을 합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; UploadResult, MdEditorOption &#125; from 'ngx-markdown-editor';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; public mode: string = 'editor'; public options: MdEditorOption; constructor() &#123;&#125; /** * 이미지 파일 Upload * @param files * @returns */ doUpload(files: Array&lt;File&gt;): Promise&lt;Array&lt;UploadResult&gt;&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result: Array&lt;UploadResult&gt; = []; for (let file of files) &#123; result.push(&#123; name: file.name, url: `https://avatars3.githubusercontent.com/$&#123;file.name&#125;`, isImg: file.type.indexOf('image') !== -1, &#125;); &#125; resolve(result); &#125;, 3000); &#125;); &#125; ngOnInit(): void &#123; // markdown editor option 설정 this.options = &#123; showPreviewPanel: false, enablePreviewContentClick: false, resizable: true, customRender: &#123; image: function (href: string, title: string, text: string) &#123; let out = `&lt;img style=\"max-width: 100%; border: 20px solid red;\" src=\"$&#123;href&#125;\" alt=\"$&#123;text&#125;\"`; if (title) &#123; out += ` title=\"$&#123;title&#125;\"`; &#125; out += (&lt;any&gt;this.options).xhtml ? '/&gt;' : '&gt;'; return out; &#125;, &#125;, &#125;; &#125;&#125; Markdown Editor 구현된 이미지입니다. 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://openbase.com/js/ngx-markdown-editor https://openbase.com/js/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"}]},{"title":"[Angular] Can't resolve crypto 오류 해결 방법","slug":"angular-5","date":"2022-09-21T06:42:48.000Z","updated":"2023-07-20T14:32:11.263Z","comments":true,"path":"2022/09/21/angular-5/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-5/","excerpt":"","text":"Angular 에서 Web3 를 사용할 경우 다음과 같은 오류가 발생할 경우가 있습니다. 1234Module not found: Error: Can't resolve 'crypto' in ...Module not found: Error: Can't resolve 'stream' in ...Module not found: Error: Can't resolve 'fs' in ...Module not found: Error: Can't resolve 'os' in ... 12345678[NG_SERVE] BREAKING CHANGE: webpack &lt; 5 used to include polyfills for node.js core modules by default.[NG_SERVE] This is no longer the case. Verify if you need this module and configure a polyfill for it.[NG_SERVE][NG_SERVE] If you want to include a polyfill, you need to:[NG_SERVE] - add a fallback 'resolve.fallback: &#123; \"stream\": require.resolve(\"stream-browserify\") &#125;'[NG_SERVE] - install 'stream-browserify'[NG_SERVE] If you don't want to include a polyfill, you can use an empty module like this:[NG_SERVE] resolve.fallback: &#123; \"stream\": false &#125; polyfill.ts 파일에 내용을 추가하는 방법도 있지만 Webpack 을 구성하여 해결하였습니다. 해결 방법 설치 사용자 지정 웹팩 구성을 하여 빌드 및 실행할 수 있도록 custom-webpack 패키지를 설치합니다. 1$ npm install --save-dev @angular-builders/custom-webpack 오류가 발생하는 모듈의 패키지를 설치합니다. 1$ npm install --save-dev stream-http https-browserify 생성 custom-webpack.config.js 파일을 생성하고 다음 내용을 추가합니다. 123456789101112131415const webpack = require('webpack');module.exports = &#123; resolve: &#123; fallback: &#123; http: require.resolve('stream-http'), https: require.resolve('https-browserify'), fs: false, crypto: false, os: false, stream: false, assert: false, &#125;, &#125;,&#125;; 적용 angular.json 파일의 내용을 수정합니다. builder 와 options 부분을 custom-webpack 으로 수정합니다. 1234567891011121314151617181920\"architect\": &#123; ... \"build\": &#123; \"builder\": \"@angular-builders/custom-webpack:browser\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"customWebpackConfig\": &#123; \"path\": \"./custom-webpack.config.js\", // 생성한 파일 적용 \"replaceDuplicatePlugins\": true &#125;, ... &#125;, ... &#125;, \"serve\": &#123; \"builder\": \"@angular-builders/custom-webpack:dev-server\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"browserTarget\": \"test-project:build\" &#125; &#125;&#125; Angular 를 재실행하면 오류들이 없어 진 것을 확인할 수 있습니다. 참고 https://www.npmjs.com/package/@angular-builders/custom-webpack","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Angular] process is not defined 해결 방법","slug":"angular-4","date":"2022-09-21T00:34:20.000Z","updated":"2023-07-20T14:30:35.135Z","comments":true,"path":"2022/09/21/angular-4/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-4/","excerpt":"","text":"Angular 14 버전을 사용하면서 ERROR ReferenceError: process is not defined 오류가 발생할 경우 해결 방법입니다. 설치 process 패키지를 설치합니다. 1$ npm install --save-dev process 내용 추가 src/polyfill.ts 파일을 열고 다음 내용을 추가합니다. 123(window as any).global = window;global.Buffer = global.Buffer || require('buffer').Buffer;global.process = require('process');","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"node-gyp 설치 오류 해결 방법","slug":"nodejs-3","date":"2022-09-16T00:30:27.000Z","updated":"2023-03-14T02:24:34.826Z","comments":true,"path":"2022/09/16/nodejs-3/","link":"","permalink":"http://hgko1207.github.io/2022/09/16/nodejs-3/","excerpt":"","text":"node-gyp 설치 과정 중 오류가 발생하였을 때 해결 방법입니다. npm 버전 확인 npm 버전을 확인하고 버전에 맞게 수행합니다. 1$ npm --version Windows PowerShell 또는 명령 프롬프트(cmd.exe)를 “관리자 권한으로 실행” 으로 실행합니다. 먼저 node 가 설치된 디렉토리로 이동합니다. 1$ cd \"C:\\Program Files\\nodejs\" npm 버전이 7 미만인 경우 12$ cd node_modules\\npm\\node_modules\\npm-lifecycle$ npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 12$ cd node_modules\\npm\\node_modules\\@npmcli\\run-script$ npm install node-gyp@latest Linux, MacOS 다음 명령어를 실행하면 됩니다. 권한 오류가 나서 실패하면 앞에 sudo 명령어를 추가합니다. npm 버전이 7 미만인 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/npm-lifecycle -g -- npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/@npmcli/run-script -g -- npm_config_global=false npm install node-gyp@latest 참고 https://github.com/nodejs/node-gyp/blob/main/docs/Updating-npm-bundled-node-gyp.md","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"npm install 시 gyp ERR! 해결 방법","slug":"nodejs-2","date":"2022-09-05T04:39:40.000Z","updated":"2023-06-12T13:58:10.692Z","comments":true,"path":"2022/09/05/nodejs-2/","link":"","permalink":"http://hgko1207.github.io/2022/09/05/nodejs-2/","excerpt":"","text":"npm install 시 gyp ERR! 로 시작하는 설치 에러가 발생할 경우 해결 방법을 정리하였습니다. 첫 번째 방법 Microsoft 의 windows-build-tools 설치합니다. 관리자 권한으로 PowerShell 또는 터미널을 열고 다음 명령어를 실행하여 설치합니다. npm 버전이 8 이상 설치가 되어 있어야 합니다. 1$ npm install --global windows-build-tools 두 번째 방법 1) Visual Studio Download https://visualstudio.microsoft.com/ko/downloads/ 사이트를 접속해서 Visual Studio 를 다운받습니다. 2) C++ 설치 Visual Studio Installer 에서 Desktop development with C++ 선택 후 설치 3) msvs_version, msbuild_path 설정 12$ npm config set msvs_version 2022$ npm config set msbuild_path \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\Msbuild\\Current\\Bin\\MSBuild.exe\" msvs_version, msbuild_path 를 설정할 때 다른 버전이 설치되어 있으면 변경합니다. 설치 1$ npm install -g node-gyp 프로젝트에서 설치합니다. 1$ npm install 참고 https://exerror.com/errerr-find-vsfind-vs-msvs_version-not-set-from-command-line-or-npm-config-vcinstalldir-not-set/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[React] Animations","slug":"react-11","date":"2022-08-28T13:50:48.000Z","updated":"2023-03-14T02:24:29.824Z","comments":true,"path":"2022/08/28/react-11/","link":"","permalink":"http://hgko1207.github.io/2022/08/28/react-11/","excerpt":"","text":"Framer Motion 을 사용하여 애니메이션을 간편하고 쉽게 만드는 방법을 알아보겠습니다. Framer Motion Framer 는 디자이너들을 위해 프로토타입 등을 만들어 주는 회사입니다. Framer Motion 은 React 용 production-ready 모션 라이브러리입니다. 설치 1$ npm install framer-motion 사용 Animation Framer Motion 의 애니메이션은 모션 컴포넌트의 유연한 animate 속성을 통해 제어됩니다. 간단한 애니메이션의 경우 animate props 에서 직접 값을 설정할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 360 &#125;&#125; transition=&#123;&#123; duration: 2 &#125;&#125; initial initial: boolean | Target | VariantLabels (애니메이션의 초기값 지정) 속성, 변형 레이블 또는 시작할 변형 레이블의 배열입니다. animate의 값으로 초기화하려면 false로 설정합니다(마운트 애니메이션 비활성화).https://www.framer.com/docs/component/###initial Transition Transition 은 값이 한 상태에서 다른 상태로 움직이는 방식을 정의합니다. 또한 Tween, Spring 또는 Inertia 를 사용할 애니메이션 유형을 정의하는 소품을 허용할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 180 &#125;&#125; transition=&#123;&#123; type: 'spring' &#125;&#125; 예제 initial, animate, transition 을 사용하여 사각형이 회전하고 튕기는 애니메이션을 구현하였습니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';import &#123; motion &#125; from 'framer-motion';const Wrapper = styled.div` display: flex; max-width: 680px; width: 100vw; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Box = styled(motion.div)` width: 200px; height: 200px; background-color: white; border-radius: 15px; box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.06);`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box transition=&#123;&#123; type: 'spring', delay: 0.5 &#125;&#125; initial=&#123;&#123; scale: 0 &#125;&#125; animate=&#123;&#123; scale: 1, rotate: 360 &#125;&#125; /&gt; &lt;/Wrapper&gt; );&#125;export default App; 참고 https://www.framer.com/motion https://www.framer.com/docs/animation https://www.framer.com/docs/transition","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"}]},{"title":"[CentOS] alias 등록","slug":"linux-19","date":"2022-08-23T04:40:33.000Z","updated":"2023-06-15T01:30:21.694Z","comments":true,"path":"2022/08/23/linux-19/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-19/","excerpt":"","text":"alias 란 alias는 별칭이라는 뜻으로 리눅스에서 alias는 사용자가 명령어를 다른 이름으로 바꿔서 사용할 수 있는 쉘 내부 명령어를 말합니다. 이 alias 를 통해서 일일이 입력하기 번거로운. 길이가 긴 명령어를 간단한 이름으로 바꿔서 등록하여 업무 효율을 높일 수 있습니다. alias 확인 현재 등록된 alias 리스트를 확인할 수 있습니다. 1234567891011$ aliasalias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l.='ls -d .* --color=auto'alias ll='ls -l --color=auto'alias ls='ls --color=auto'alias mv='mv -i'alias rm='rm -i'... alias 등록 명령어 별칭은 alias 명령어별칭='명령어'의 형식으로 등록합니다. 다음의 예제처럼 등록하면 run_tomcat 라는 명령어를 실행할 경우 tomcat 이 실행됩니다. 12# alias 명령어별칭 = '명령어'$ alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start' alias 해제 unalias 명령어를 사용하여 등록된 alias 를 삭제할 수 있습니다. 1$ unalias run_tomcat alias 영구 등록 위에서 등록된 alias 들은 시스템을 재부팅하고 나면 다시 초기화가 되어 매번 재 설정해줘야 한다는 불편함이 있습니다. 이러한 문제를 방지하려면 alias 를 ./bashrc 이나 .bash_aliases 파일에 등록해서 사용해야 합니다. 재부팅이 되더라도 등록해둔 alias 가 영구 지속됩니다. 1$ vi ~/.bashrc ./bashrc 파일을 열고 alias 를 추가합니다. 123alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start'alias stop_tomcat='/usr/local/tomcat8/bin/catalina.sh stop'alias tomcat_logs='tail -n 150 -f /usr/local/tomcat8/logs/catalina.out' bashrc 파일을 수정하면 바로 적용되지 않고 source 명령어를 사용하여 동기화를 해야합니다. 1$ source ~/.bashrc 위의 방법으로 alias 별칭을 편리하게 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"}]},{"title":"[CentOS] Tomcat 다중 설치 및 운영 방법","slug":"linux-18","date":"2022-08-23T04:13:31.000Z","updated":"2023-06-05T00:41:30.570Z","comments":true,"path":"2022/08/23/linux-18/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-18/","excerpt":"","text":"리눅스 환경에서 Tomcat 을 다중 설치하고 운영하는 방법에 대해 알아보겠습니다. 1. Tomcat 설치 이전 글 [CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법 을 보면서 Tomcat 을 설치합니다. 설치된 Tomcat 폴더를 서로 다른 이름의 폴더로 복사합니다. 12- tomcat1 : /usr/local/tomcat_1- tomcat2 : /usr/local/tomcat_2 2. catalina.sh 파일 수정 /bin/catalina.sh 파일을 열고 다음 내용을 추가합니다. 1234export CATALINA_HOME=[Tomcat Path]export TOMCAT_HOME=[Tomcat Path]export CATALINA_BASE=[Tomcat Path]CATALINA_PID=[Tomcat Path]/bin/tomcat.pid tomcat1 1234export CATALINA_HOME=/usr/local/tomcat_1export TOMCAT_HOME=/usr/local/tomcat_1export CATALINA_BASE=/usr/local/tomcat_1CATALINA_PID=/usr/local/tomcat_1/bin/tomcat.pid tomcat2 1234export CATALINA_HOME=/usr/local/tomcat_2export TOMCAT_HOME=/usr/local/tomcat_2export CATALINA_BASE=/usr/local/tomcat_2CATALINA_PID=/usr/local/tomcat_2/bin/tomcat.pid 3. 포트 변경 /conf/server.xml 파일에서 포트를 수정합니다. Tomcat 마다 포트 3개를 다르게 입력 해야 합니다. 다음과 같이 tomcat1 은 80XX, tomcat2 은 81XX 포트로 변경합니다. 123Server Port 는 8005, 8105Connector Port 는 8080, 8180AJP/1.3 Port 는 8009, 8109 tomcat1 12345678910...&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... tomcat2 12345678910...&lt;Server port=\"8105\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8180\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8109\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... 4. 방화벽 해제 설정된 HTTP 포트의 방화벽을 해제합니다. 123$ sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent$ sudo firewall-cmd --zone=public --add-port=8180/tcp --permanent$ sudo firewall-cmd --reload 서비스를 시작 시킨 후 각각의 서비스 포트로 접속해서 제대로 동작하는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"}]},{"title":"[React] reference 사용","slug":"react-10","date":"2022-08-21T13:58:27.000Z","updated":"2023-06-05T00:41:39.195Z","comments":true,"path":"2022/08/21/react-10/","link":"","permalink":"http://hgko1207.github.io/2022/08/21/react-10/","excerpt":"","text":"reference 는 react 코드를 이용해 HTML 요소를 지정하고 가져올 수 있는 방법입니다. 다시 말해서 자바스크립트로부터 HTML 요소를 가져오고 수정 할 수 있도록 해줍니다. 사용 useRef 를 사용하여 HTML 요소를 가져옵니다. 다음 코드는 button 클릭 시 input 을 포커싱하고 해제하는 예제입니다. 1234567891011121314151617181920import &#123; useRef &#125; from 'react';function RefEx() &#123; const inputRef = useRef&lt;HTMLInputElement&gt;(null); const onClick = () =&gt; &#123; inputRef.current?.focus(); // 5초 뒤에 focus 사라짐 setTimeout(() =&gt; &#123; inputRef.current?.blur; &#125;, 5000); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputRef&#125; type=\"text\" placeholder=\"input\" /&gt; &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;export default RefEx; typescript 사용하므로 HTMLInputElement 를 지정하였습니다. useRef 를 사용하여 HTML 요소를 가져왔지만 수정 할 경우에는 HTMLInputElement 지정한 것 처럼 일반 자바스크립트를 이용합니다. useRef() useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 반환된 객체는 컴포넌트의 전 life cycle을 통해 유지될 것입니다. 일반적인 사용 사례는 자식에게 접근하는 경우입니다. 본질적으로 useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 &quot;상자&quot;와 같습니다. 참고 https://ko.reactjs.org/docs/hooks-reference.html#useref HTMLInputElement methods","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"}]},{"title":"[Spring] Swagger Header 설정 방법","slug":"spring-1","date":"2022-08-19T07:48:58.000Z","updated":"2023-03-14T02:24:18.830Z","comments":true,"path":"2022/08/19/spring-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/spring-1/","excerpt":"","text":"Spring 에서 Swagger Header 설정 방법에 대해 알아보겠습니다. API 마다 설정 각 API 마다 @ApiImplicitParam 을 통해 인증 정보(토큰)을 입력하도록 설정합니다. 1234567@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"Authorization\", value = \"JWT Token\", required = true, dataType = \"string\", paramType = \"header\") &#125;)@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 이 방법은 API 개수가 많아질 경우 코드 양이 늘어나고 가독성이 나빠집니다. 그리고 Swagger 를 통해 테스트 진행 시 각 API 마다 인증 정보를 입력해야 한다는 번거로움이 생기게 됩니다. Authroize 버튼 활성화 SWagger Version 2.9.2 부터는 번거로움을 없애주는 기능이 생겼습니다. Swagger 화면 상단 부분에 Autorize 버튼이 생겼습니다. Autorize 버튼을 클릭하면 모든 API 에 일괄 인증 할 수 있도록 해주는 인증 정보를 입력받는 창이 뜹니다. 설정 먼저 maven 또는 gradle 설정을 합니다. 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 1234dependencies &#123; compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' implementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2'&#125; SwaggerConfig 클래스를 생성하고 코드들을 추가합니다. 중요한 것은 ApiKey 를 유의해야합니다. 프로젝트마다 사용하는 인증 key 가 다르므로 확인해서 입력합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Arrays;import java.util.List;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.ApiKey;import springfox.documentation.service.AuthorizationScope;import springfox.documentation.service.SecurityReference;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger.web.DocExpansion;import springfox.documentation.swagger.web.ModelRendering;import springfox.documentation.swagger.web.OperationsSorter;import springfox.documentation.swagger.web.TagsSorter;import springfox.documentation.swagger.web.UiConfiguration;import springfox.documentation.swagger.web.UiConfigurationBuilder;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger 자동 문서화 웹 생성을 위한 Spring MVC 설정 * @author hgko * */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .useDefaultResponseMessages(false) // 웹 페이지에서 디폴트 설정되는 ResponseMessages 부분 표시하지 않음 .select() .apis(RequestHandlerSelectors.basePackage(\"com.hgko.controller\")) // Controller에서 api 추출 .paths(PathSelectors.any()) .build() .apiInfo(swaggerInfo()) .securityContexts(Arrays.asList(securityContext())) .securitySchemes(Arrays.asList(apiKey())); &#125; public ApiInfo swaggerInfo() &#123; return new ApiInfoBuilder() .title(\"Server API Documentation\") .description(\"서버 API에 대한 연동 문서입니다\") .version(\"0.0.1\") .build(); &#125; private ApiKey apiKey() &#123; return new ApiKey(\"Authorization\", \"Authorization\", \"header\"); &#125; private SecurityContext securityContext() &#123; return SecurityContext.builder() .securityReferences(defaultAuth()) .build(); &#125; private List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Arrays.asList(new SecurityReference(\"Authorization\", authorizationScopes)); &#125;&#125; 기존 API 코드에서 @ApiImplicitParams 부분을 제거합니다. 12345@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 설정은 다 끝났습니다. Swagger 화면에서 정상적으로 동작하는지 확인 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"}]},{"title":"[Angular] 기능 구현 방식","slug":"angular-3","date":"2022-08-19T00:59:13.000Z","updated":"2023-03-14T02:24:16.527Z","comments":true,"path":"2022/08/19/angular-3/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/angular-3/","excerpt":"","text":"Angular 프레임워크로 특정 기능을 구현할 때 어떤 방식으로 사용하는지에 대해 알아보겠습니다. UI Component 구현 클래스에 @Component Annotation 을 붙여서 생성합니다. HTML 템플릿 정의 인라인 HTML 코드를 사용할 때는 @Component 어노테이션 template 항목을 사용하고, 외부 파일에서 불러올 떄는 templateUrl 항목을 사용합니다. 컴포넌트 Property 를 UI에 표시 템플릿의 이중 중괄호 안에 Property 를 사용합니다. 1&lt;span&gt;&#123;&#123; customValue &#125;&#125;)&lt;/span&gt; 컴포넌트 Property 바인딩 대괄호를 사용해서 Property 를 바인딩합니다. 1&lt;input [value]=\"inputValue\" /&gt; 이벤트 처리 이벤트 이름을 괄호로 감싸고 핸들러를 지정합니다. 1&lt;button (click)=\"onClickEvent\"&gt;Click&lt;/button&gt; 양방향 바인딩 [()] 표기를 사용합니다. 1&lt;input [(ngModel)]=\"componentProperty\" /&gt; HTML 일부를 자식 컴포넌트에 전달하기 자식 컴포넌트의 템플릿에 &lt;ng-content&gt; 태그를 사용합니다. 내비게이션 구현 라우터를 사용해서 컴포넌트와 URL을 연결하고 컴포넌트의 템플릿이 렌더링될 위치를 &lt;router-outlet&gt; 태그로 지정합니다. 컴포넌트에서 데이터 받기 컴포넌트 프로퍼티를 선언할 때 @Input 어노테이션을 사용해서 외부 값과 연결합니다. 컴포넌트에 데이터 전달하기 컴포넌트 프로퍼티를 선언할 때 @Output 어노테이션을 사용하고 EventEmitter 를 이용해서 이벤트를 발생시킵니다. HTTP 요청 컴포넌트에 Http 객체를 주입하고 HTTP 함수를 사용합니다. 1this.http.get('/users'); HTTP 응답 처리 subscribe() 함수를 사용해서 옵저버블 스트림을 처리합니다. 123this.http.get('/users').subscribe(() =&gt; &#123; ...&#125;); 컴포넌트 상태가 변경되는 것을 가로채기 컴포넌트 생성주기 함수를 사용합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[React] memo 사용 방법","slug":"react-9","date":"2022-08-12T13:50:38.000Z","updated":"2023-03-14T02:24:14.361Z","comments":true,"path":"2022/08/12/react-9/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-9/","excerpt":"","text":"React에서 memo 사용 방법에 대해 알아보겠습니다. 컴포넌트가 동일한 props로 동일한 결과를 렌더링해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑하여 경우에 따라 성능 향상을 누릴 수 있습니다. 즉, React는 컴포넌트를 렌더링하지 않고 마지막으로 렌더링된 결과를 재사용합니다. 1234567import React from 'react';function MyComponent(props) &#123; /* props를 사용하여 렌더링 */&#125;export default React.memo(MyComponent, areEqual); 사용 이전 포스트 [React] Drag and Drop 에서 드래그, 드롭 시 바뀐 부분이 아닌 전체가 리랜더링이 되어 텍스트의 흔들림이 가끔씩 발생하는 문제가 있었습니다. Card 부분을 DraggableCard Component 로 새로 만들었습니다. DraggableCard 에게 동일한 index와 todo prop을 주고 불필요한 리랜더링을 하지 않도록 하기 위해 memo 를 사용하였습니다. 123456789101112131415161718192021222324252627282930// DraggableCard.tsximport React from 'react';import &#123; Draggable &#125; from 'react-beautiful-dnd';import styled from 'styled-components';const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;interface IDraggableCardProps &#123; toDo: string; index: number;&#125;function DraggableCard(&#123; toDo, index &#125;: IDraggableCardProps) &#123; return ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; );&#125;export default React.memo(DraggableCard); 실제로 바뀐 것들만 리렌더링 되어 텍스트가 흔들리는 문제를 해결함으로써 최적화 할 수 있었습니다. 주의 React.memo는 props 변화에만 영향을 줍니다. React.memo로 감싸진 함수 컴포넌트 구현에 useState, useReducer 또는 useContext 훅을 사용한다면, 여전히 state나 context가 변할 때 다시 렌더링됩니다. 이 메서드는 오직 성능 최적화를 위하여 사용됩니다. 렌더링을 방지하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다. 참고 https://ko.reactjs.org/docs/react-api.html#reactmemo","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"}]},{"title":"[React] Drag and Drop","slug":"react-8","date":"2022-08-12T13:21:15.000Z","updated":"2023-03-14T02:24:11.822Z","comments":true,"path":"2022/08/12/react-8/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-8/","excerpt":"","text":"react-beautiful-dnd 을 사용하여 React 에서 깔끔하고 사용하기 쉬운 드래그, 드롭, 애니메이션을 적용하는 방법에 대해 알아보겠습니다. 설치 1$ npm i react-beautiful-dnd TypeScript 사용 시 추가로 설치합니다. 1$ npm i --save-dev @types/react-beautiful-dnd 사용 임시 데이터 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’] 를 사용하여 카드 형태의 드래그, 드롭을 구현해봤습니다. 1234567// atoms.tsximport &#123; atom &#125; from 'recoil';export const toDoState = atom(&#123; key: 'toDo', default: ['a', 'b', 'c', 'd', 'e', 'f'],&#125;); DragDropContext, Draggable, Droppable 를 사용하여 구성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// App.tsximport &#123; DragDropContext, Draggable, Droppable, DropResult &#125; from 'react-beautiful-dnd';import &#123; useRecoilState &#125; from 'recoil';import styled from 'styled-components';import &#123; toDoState &#125; from './atoms';const Wrapper = styled.div` display: flex; max-width: 480px; width: 100%; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Boards = styled.div` display: grid; width: 100%; grid-template-columns: repeat(3, 1fr);`;const Board = styled.div` padding: 20px 10px; padding-top: 30px; background-color: gray; border-radius: 5px; min-height: 200px;`;const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;function App() &#123; const [toDos, setToDos] = useRecoilState(toDoState); const onDragEnd = (&#123; draggableId, destination, source &#125;: DropResult) =&gt; &#123; if (!destination) return; setToDos((oldToDos) =&gt; &#123; const copyToDos = [...oldToDos]; // 1) Delete item on source.index copyToDos.splice(source.index, 1); // 2) Put back the item on the destination.index copyToDos.splice(destination?.index, 0, draggableId); return copyToDos; &#125;); &#125;; return ( &lt;DragDropContext onDragEnd=&#123;onDragEnd&#125;&gt; &lt;Wrapper&gt; &lt;Boards&gt; &lt;Droppable droppableId=\"one\"&gt; &#123;(provided) =&gt; ( &lt;Board ref=&#123;provided.innerRef&#125; &#123;...provided.droppableProps&#125;&gt; &#123;toDos.map((toDo, index) =&gt; ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; ))&#125; &#123;provided.placeholder&#125; &lt;/Board&gt; )&#125; &lt;/Droppable&gt; &lt;/Boards&gt; &lt;/Wrapper&gt; &lt;/DragDropContext&gt; );&#125;export default App; Draggable 의 draggableProps 는 모든 영역을 dragHandleProps 는 특정 영역을 통해서만 드래그 할 수 있도록 설정할 수 있습니다. Draggable list 를 렌더링하는 경우 각 Draggable 에 key prop 을 추가하는 것이 중요합니다. key 는 list 내에서 고유해야 합니다. key 에 item 의 index 가 포함되어서는 안되기 때문에 일반적으로 draggableId 를 key 로 사용합니다. 참고 react-beautiful-dnd 테스트해 보기 react-beautiful-dnd 예시 코드 react-beautiful-dnd-kr","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"}]},{"title":"[React] React Hook Form","slug":"react-7","date":"2022-08-08T14:40:32.000Z","updated":"2023-03-14T02:24:09.486Z","comments":true,"path":"2022/08/08/react-7/","link":"","permalink":"http://hgko1207.github.io/2022/08/08/react-7/","excerpt":"","text":"React에서 React Hook Form 사용 방법에 대해 알아보겠습니다. 기본적으로 Form 을 사용할 때 작성하는 코드입니다. 하나의 input 이지만 여러 개의 input 을 사용할 경우 useState 와 onChange 이벤트가 많이 생성됩니다. 그리고 Validation Check 하는 코드도 복잡해집니다. 123456789101112131415161718192021222324252627282930313233// InputForm.tsximport React, &#123; useState &#125; from 'react';function InputForm() &#123; const [toDo, setTodo] = useState(''); const [toDoError, setTodoError] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setTodoError(''); setTodo(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); if (toDo.length &lt; 10) &#123; return setTodoError('To do should be longer'); &#125; console.log(toDo); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input onChange=&#123;onChange&#125; value=&#123;toDo&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &#123;toDoError !== '' ? toDoError : null&#125; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; react-hook-form 라이브러리를 사용하면 위의 코드들을 간략하게 줄일 수 있습니다. 그리고 Validation(검증)도 쉽게 관리할 수 있습니다. 설치 1$ npm install react-hook-form 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add react-hook-form 사용 먼저 useForm 을 import 합니다. 1import &#123; useForm &#125; from 'react-hook-form'; register useForm, register을 사용한 단 한줄의 코드가 onChange 이벤트와 value, useState 를 모두 대체했습니다. 사용법은 {...register(name)} 를 input 태크 안에 작성합니다. register 함수는 Validation 을 보다 쉽게 관리 할 수 있도록 해줍니다. required: true 처럼 조건을 작성 할 수 있습니다. 123456789101112131415// InputForm.tsxfunction InputForm() &#123; const &#123; register &#125; = useForm(); return ( &lt;div&gt; &lt;form&gt; &lt;input &#123;...register('toDo', &#123; required: true &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; watch watch 는 form 의 입력 값들의 변화를 관찰 할 수 있게 해줍니다. 12const &#123; register, watch &#125; = useForm();console.log(watch); handleSubmit handleSubmit 는 form 데이터의 Validation Check 를 해결해줍니다. 파라미터는 Validation 을 통과했을 때 호출되는 함수입니다. handleSubmit 를 사용하면 키보드랑 마우스를 조건이 유효하지 않은 항목으로 바로 focus 시켜줍니다. 123456789101112131415161718192021222324252627// InputForm.tsxfunction InputForm() &#123; const &#123; register, handleSubmit &#125; = useForm(); const onValid = (data: any) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('toDo', &#123; required: true, minLength: &#123; value: 5, message: 'Your todo is too short.', &#125;, &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; formState formState 을 통해 에러메시지를 출력해보겠습니다. 먼저 email 은 정규식을 통해 검증하도록 pattern 을 작성하였습니다. 조건을 입력할 때 메시지도 작성하여 에러메시지가 출력되도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344type IForm = &#123; errors: &#123; email: &#123; message: string; &#125;; &#125;; email: string;&#125;;function InputForm() &#123; const &#123; register, handleSubmit, formState: &#123; errors &#125;, &#125; = useForm&lt;IForm&gt;(&#123; defaultValues: &#123; email: '@gmail.com', &#125;, &#125;); const onValid = (data: IForm) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('email', &#123; required: '이메일을 입력하세요.', pattern: &#123; value: /^[A-Za-z0-9._%+-]+@gmail.com$/, message: '이메일 형식이 맞지 않습니다.', &#125;, &#125;)&#125; placeholder=\"Email\" /&gt; &lt;span&gt;&#123;errors?.email?.message&#125;&lt;/span&gt; &lt;button&gt;등록&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; email 을 입력하지 않았을 경우 이메일을 입력하세요. 에러메시지가 출력되고 email 형식이 맞지 않을 경우 이메일 형식이 맞지 않습니다. 에러메시지가 출력됩니다. SetValue submit 하고 난 후 값을 초기화 할 수 있습니다. Custom Validation setError 를 통해 직접 에러를 발생시키도록 할 수 있습니다. shouldFocus 옵션을 사용하면 form 의 커서가 자동으로 옮겨집니다. 12// 예setError('password1', &#123; message: '비밀번호가 다릅니다.' &#125;, &#123; shouldFocus: true &#125;); 참고 https://react-hook-form.com/ https://react-hook-form.com/kr/get-started/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"}]},{"title":"[Angular] Angular 시작","slug":"angular-2","date":"2022-08-07T12:51:25.000Z","updated":"2023-03-14T02:24:04.666Z","comments":true,"path":"2022/08/07/angular-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/07/angular-2/","excerpt":"","text":"Angular 는 구글이 만든 단일 페이지 웹 애플리케이션 개발을 위한 자바스크립트 프레임워크입니다. 다양한 플랫폼에서 동작할 수 있게 하는 개발 툴과 기능들을 제공합니다. Module 컴포넌트, 파이프, 서비스 등과 같은 앵귤러 애플리케이션의 주요 부분을 기능단위로 그룹핑 하게 해줍니다. 모든 앵귤러 애플리케이션은 하나의 Root Module 을 가집니다. 여러 Feature Module 을 가질 수 있습니다. 재사용할 수 있는 기능을 외부에 배포하기 위해 사용되기도 합니다. Component 빌딩 블록 형식 HTML 요소들의 그룹 뷰와 로직으로 구성 1$ ng g component todo/todos --module todo/todo.module.ts --export 컴포넌트 내부에서 html, css 코드를 작성하도록 생성할 수 있습니다. 1$ ng g component todos/todo --inline-template --inline-style Template HTML 코드로서 템플릿을 표현합니다. Template 표현식(Expression)과 Template 문장(Statement)을 가집니다. 바인딩 바인딩의 대상: 속성, 이벤트, ngModel, class, style 123456789101112&lt;!-- &#123;&#123; 템플릿 표현식 &#125;&#125; --&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;!-- [속성]=\"템플릿 표현식\" --&gt;&lt;todo [todo]=\"work\"&gt;&lt;/todo&gt;&lt;!-- (이벤트)=\"템플릿 문장(함수)\" --&gt;&lt;button (click)=\"handle()\"&gt;&lt;/button&gt;&lt;!-- [(ngModel)]=\"템플릿 문장\" --&gt;&lt;!-- 양방향 바인딩을 사용할 수 있음 --&gt;&lt;input type=\"text\" [(ngModel)]=\"name\" /&gt; 컴포넌트간 커뮤니케이션 부모 컴포넌트 -&gt; 자식 컴포넌트 @input() 사용 ES6 setter 사용 가능 @ViewChild() 사용 자식 컴포넌트 -&gt; 부모 컴포넌트 @Output() 사용 EventEmitter 사용하여 부모에게 이벤트 전달 부모 컴포넌트는 $event로 이벤트의 데이터를 전달 받음 자식이 부모 컴포넌트를 직접 주입받을 수 있음 파이프(Pipe) 템플릿(HTML)에서 보이는 데이터를 변환해줍니다. AngularJs 1.x 에서는 필터로 제공되었습니다. 실제 값을 변경하는 것이 아니라 보여주는 값만 바꿔 보여주기 위해 사용합니다. 123456789// 사용법&#123;&#123; express | pipeName: paramValue &#125;&#125;// 예today: Date = new Date();&#123;&#123; today | date &#125;&#125;&#123;&#123; today | date:\"yy/mm/dd\" &#125;&#125; // 날짜 포맷 변환&#123;&#123; today | date | uppercase &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Python] 기초(2)","slug":"python-2","date":"2022-08-02T14:47:28.000Z","updated":"2023-03-14T02:24:02.326Z","comments":true,"path":"2022/08/02/python-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-2/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본편)을 보면서 작성하였습니다. 기본 시작 함수 123456789101112131415161718192021222324def open_account(): print(\"새로운 계좌가 생성되었습니다.\")def deposit(balance, money): # 입금 print(\"입금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance + money)) return balance + moneydef withdraw(balance, money): # 출금 if balance &gt;= money: # 잔액이 출금보다 많으면 print(\"출금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance - money)) return balance - money else: print(\"출금이 완료되지 않았습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance)) return balancedef withdraw_night(balance, money): # 저녁에 출금 commission = 100 # 수수료 100원 return commission, balance - money - commissionbalance = 0balance = deposit(balance, 1000)# balance = withdraw(balance, 500)commission, balance = withdraw_night(balance, 500)print(\"수수료 &#123;0&#125; 원이며, 잔액은 &#123;1&#125; 원입니다.\".format(commission, balance)) 함수 기본값 12345678910def profile(name, age, main_lang): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\", 35, \"파이썬\")# 같은 학교 같은 학년 같은 반 같은 수업def profile(name, age=17, main_lang=\"파이썬\"): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\") 가변인자 123456789101112# def profile(name, age, lang1, lang2, lang3, lang4, lang5):# print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \")# print(lang1, lang2, lang3, lang4, lang5)def profile(name, age, *language): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \") for lang in language: print(lang, end=\" \") print()profile(\"고형균\", 35, \"Python\", \"Java\", \"C\", \"C++\", \"C#\", \"JavaScript\")profile(\"김태호\", 40, \"Kotlin\", \"Swift\", \"\", \"\", \"\") 지역변수와 전역변수 12345678910111213141516gun = 10def checkpoint(soldiers): # 경계근무 global gun # 전역 공간에 있는 gun 사용 gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun))def checkpoint_ret(gun, soldiers): gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun)) return gunprint(\"전체 총 : &#123;0&#125;\".format(gun))#checkpoint(2) # 2명이 경계 근무 나감gun = checkpoint_ret(gun, 2)print(\"남은 총 : &#123;0&#125;\".format(gun)) 표준 입출력 1234567891011121314import sysprint(\"Python\", \"Java\", file=sys.stdout)print(\"Python\", \"Java\", file=sys.stderr)# 시험 성적scores = &#123;\"수학\":0, \"영어\":50, \"코딩\":100&#125;for subject, score in scores.items(): #print(subject, score) print(subject.ljust(8), str(score).rjust(4), sep=\":\")# 은행 대기순번표# 001, 002, 003, ...for num in range(1, 21): print(\"대기번호 : \" + str(num).zfill(3)) 다양한 출력포맷 123456789101112131415161718# 빈 자리는 빈공간으로 두고, 오른쪽 정렬을 하되, 총 10자리 공간을 확보print(\"&#123;0: &gt;10&#125;\".format(500))# 양수일 땐 +로 표시, 음수일 땐 -로 표시print(\"&#123;0: &gt;+10&#125;\".format(500))print(\"&#123;0: &gt;+10&#125;\".format(-500))# 왼쪽 정렬하고, 빈칸으로 _로 채움print(\"&#123;0:_&lt;+10&#125;\".format(500))# 3자리 마다 콤마를 찍어주기print(\"&#123;0:,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이기print(\"&#123;0:+,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이고, 자릿수 확보하기# 돈이 많으면 행복해지니까 빈 자리는 ^ 로 채워주기print(\"&#123;0:^&lt;+30,&#125;\".format(1000000000))# 소수점 출력print(\"&#123;0:f&#125;\".format(5/3))# 소수점 특정 자리수 까지만 표시 (소수점 3째 자리에서 반올림)print(\"&#123;0:.2f&#125;\".format(5/3)) 파일 입출력 12345678910111213141516171819202122232425262728293031323334score_file = open(\"score.txt\", \"w\", encoding=\"utf8\") # writeprint(\"수학 : 0\", file=score_file)print(\"영어 : 50\", file=score_file)score_file.close()score_file = open(\"score.txt\", \"a\", encoding=\"utf8\") # updatescore_file.write(\"과학 : 80\")score_file.write(\"\\n코딩 : 100\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\") # readprint(score_file.read())score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")print(score_file.readline(), end=\"\") # 줄별로 읽기, 한 줄 읽고 커서는 다음 줄로 이동print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")while True: line = score_file.readline() if not line: break print(line, end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")lines = score_file.readlines() # list 형태로 저장for line in lines: print(line, end=\"\")score_file.close() pickle 1234567891011import pickleprofile_file = open(\"profile.pickle\", \"wb\") # b: 바이너리profile = &#123;\"이름\":\"고형균\", \"나이\":36, \"취미\":[\"축구\", \"볼링\", \"코딩\"]&#125;print(profile)pickle.dump(profile, profile_file) # profile 에 있는 정보를 file 에 저장profile_file.close()profile_file = open(\"profile.pickle\", \"rb\")profile = pickle.load(profile_file) # file 에 있는 정보를 profile 에 불러오기print(profile)profile_file.close() with 12345with open(\"study.txt\", \"w\", encoding=\"utf8\") as study_file: study_file.write(\"파이썬을 열심히 공부하고 있어요\")with open(\"study.txt\", \"r\", encoding=\"utf8\") as study_file: print(study_file.read()) 클래스 1234567891011class Unit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage print(\"&#123;0&#125; 유닛이 생성되었습니다.\".format(self.name)) print(\"체력 &#123;0&#125;, 공격력 &#123;1&#125;\\n\".format(self.hp, self.damage))marine1 = Unit(\"마린\", 40, 5)marine2 = Unit(\"마린\", 40, 5)tank = Unit(\"탱크\", 150, 35) 메소드 12345678910111213141516171819202122class AttackUnit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage def attack(self, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 적군을 공격합니다. [공격력 &#123;2&#125;]\".format(self.name, location, self.damage)) def damaged(self, damage): print(\"&#123;0&#125; : &#123;1&#125; 데미지를 입었습니다.\".format(self.name, damage)) self.hp -= damage print(\"&#123;0&#125; : 현재 체력은 &#123;1&#125; 입니다.\".format(self.name, self.hp)) if self.hp &lt;= 0: print(\"&#123;0&#125; : 파괴되었습니다.\".format(self.name))firebat1 = AttackUnit(\"파이어뱃\", 50, 16)firebat1.attack(\"5시\")# 공격 2번 받는다고 가정firebat1.damaged(25)firebat1.damaged(25) 상속 123456789class Unit: def __init__(self, name, hp): self.name = name self.hp = hpclass AttackUnit(Unit): def __init__(self, name, hp, damage): Unit.__init__(self, name, hp) self.damage = damage 다중 상속 1234567891011121314151617# 날 수 있는 기능을 가진 클래스class Flyable: def __init__(self, flying_speed): self.flying_speed = flying_speed def fly(self, name, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 날아갑니다. [속도 &#123;2&#125;]\".format(name, location, self.flying_speed))# 공중 공격 유닛 클래스class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, damage) Flyable.__init__(self, flying_speed)# 발키리 : 공중 공격 유닛, 한번에 14발 미사일 발사.valkrie = FlyableAttackUnit(\"발키리\", 200, 6, 5)valkrie.fly(valkrie.name, \"3시\"); 메소드 오버라이딩 1234567class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, 0, damage) Flyable.__init__(self, flying_speed) def move(self, location): self.fly(self.name, location) # &lt;= 메소드 오버라이딩 pass 12345678def game_start(): print(\"[알림] 새로운 게임을 시작합니다.\")def game_over(): passgame_start()game_over() super 12345class BuildingUnit(Unit): def __init__(self, name, hp, location): #Unit.__init__(self, name, hp, 0) super().__init__(name, hp, 0) self.location = location 예외처리 1234567891011121314try: print(\"나누기 전용 계산기입니다.\") nums = [] nums.append(int(input(\"첫 번째 숫자를 입력하세요 : \"))) nums.append(int(input(\"두 번째 숫자를 입력하세요 : \"))) nums.append(int(nums[0] / nums[1])) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(nums[0], nums[1], nums[2]))except ValueError: print(\"에러! 잘못된 값을 입력하였습니다.\")except ZeroDivisionError as err: print(err)except Exception as err: print(\"알 수 없는 에러가 발생하였습니다.\") print(err) 예외 발생시키기 12345678910111213141516171819class BigNumberError(Exception): def __init__(self, msg): self.msg = msg def __str__(self): return self.msgtry: print(\"한 자리 숫자 나누기 전용 계산기입니다.\") num1 = int(input(\"첫 번째 숫자를 입력하세요 : \")) num2 = int(input(\"두 번째 숫자를 입력하세요 : \")) if num1 &gt;= 10 or num2 &gt;= 10: raise BigNumberError(\"입력값 : &#123;0&#125;, &#123;1&#125;\".format(num1, num2)) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(num1, num2, int(num1 / num2)))except ValueError: print(\"잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.\")except BigNumberError as err: print(\"에러가 발생하였습니다. 한 자리 숫자만 입력하세요.\") print(err) 모듈 모듈을 사용하기 위해 theater_module.py 파일을 생성합니다. 1234567891011# 일반 가격def price(people): print(\"&#123;0&#125;명 가격은 &#123;1&#125;원 입니다.\".format(people, people * 10000))# 조조 할인 가격def price_morning(people): print(\"&#123;0&#125;명 조조 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 6000))# 군인 할인 가격def price_soldier(people): print(\"&#123;0&#125;명 군인 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 4000)) 생성한 모듈을 사용하기 위한 5가지 방법입니다. 1234567891011121314151617181920212223242526# 1) 기본import theater_moduletheater_module.price(3) # 3명이서 영화 보러 갔을 때 가격theater_module.price_morning(4) # 4명이서 조조 할인 영화 보러 갔을 때theater_module.price_soldier(5) # 5명의 군인이 영화 보러 갔을 때# 2) 별칭 사용import theater_module as mvmv.price(3)mv.price_morning(4)mv.price_soldier(5)# 3) 전체 사용from theater_module import *price(3)price_morning(4)price_soldier(5)# 4) 특정한 함수 사용from theater_module import price, price_morningprice(5)price_morning(6)# 5) 함수에 별칭 사용from theater_module import price_soldier as priceprice(5) all 1__all__ = [\"vietnam\"] 모듈 직접 실행 1234567891011class ThailandPackage: def detail(self): print(\"[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원\")if __name__ == \"__main__\": print(\"Thailand 모듈을 직접 실행\") print(\"이 문장은 모듈을 직접 실행할 때만 실행돼요\") trip_to = ThailandPackage() trip_to.detail()else: print(\"Thailand 외부에서 모듈 호출\") 패키지, 모듈 위치 123import inspectimport randomprint(inspect.getfile(random)) pip install https://pypi.org/search/ pip install beautifulsoup4 pip list pip show beautifulsoup4 pip install --upgrade beautifulsoup4 pip uninstall beautifulsoup4 내장 함수 Built-in Functions 사이트는 파이썬의 내장 함수 목록을 확인할 수 있습니다. 12345678910111213# input : 사용자 입력을 받는 함수language = input(\"무슨 언어를 좋아하세요?\")print(\"&#123;0&#125;은 아주 좋은 언어입니다!\".format(language))# dir : 어떤 객체를 넘겨줬을 때 그 객체가 어떤 변수와 함수를 가지고 있는지 표시import random # 외장 함수print(dir(random))lst = [1, 2, 3]print(dir(lst))name = \"Ko\"print(dir(name)) 외장 함수 Python Module Index 사이트는 파이썬의 외장 함수 목록을 확인할 수 있습니다. 123456789101112131415161718192021# glob : 경로 내의 폴더 / 파일 목록 조회 (윈도우 dir)import globprint(glob.glob(\"*.py\")) # 확장자가 py 인 모든 파일# os : 운영체제에서 제공하는 기본 기능import osprint(os.getcwd()) # 현재 디렉토리print(os.listdir())# time : 시간 관련 함수import timeprint(time.localtime())print(time.strftime(\"%Y-%m-%d %H:%M:%S\"))import datetimeprint(\"오늘 날짜는 \", datetime.date.today())# timedelta : 두 날짜 사이의 간격today = datetime.date.today() # 오늘 날짜 저장td = datetime.timedelta(days=100) # 100일 저장print(\"우리가 만난지 100일은\", today + td) # 오늘부터 100일 후","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Python] 기초(1)","slug":"python-1","date":"2022-08-02T14:40:29.000Z","updated":"2023-03-14T02:23:59.495Z","comments":true,"path":"2022/08/02/python-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-1/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본편)을 보면서 작성하였습니다. 환경설정 Python 설치 https://www.python.org/downloads/ 홈페이지 접속 후 다운로드 탭을 선택하고, 현재 버전(3.10.2) 다운로드를 합니다. 다운로드 완료 후 설치를 시작한다. Customize installation 클릭하고, install location 란에 c:\\Python310 입력 후 설치 버튼을 클릭합니다. Visual Studio Code 설치 https://code.visualstudio.com/ 홈페이지 접속 후 다운로드 후 설치합니다. python 익스텐션 설치 기본 시작 주석 1234567print(\"주석\")#print(\"주석\")'''여러문장주석입니다.''' 숫자처리함수 12345678910print(abs(-5)) #5print(pow(4, 2)) # 4^2 = 4*4 = 16print(max(5, 12)) # 12print(min(5, 12)) # 5print(round(3.14)) # 3from math import *print(floor(4.99)) # 내림. 4print(ceil(3.14)) # 올림. 4print(sqrt(16)) # 제곱근. 4 랜덤함수 123456789from random import *print(random()) # 0.0 ~ 1.0 미만의 임의의 값 생성print(random(10)) # 0.0 ~ 10.0 미만의 임의의 값 생성print(int(random() * 10)) # 0 ~ 10 미만의 임의의 값 생성print(int(random() * 10) + 1) # 1 ~ 10 이하의 임의의 값 생성print(int(random() * 45) + 1) # 1 ~ 45 이하의 임의의 값 생성print(randrange(1, 46)) # 1 ~ 46 미만의 임의의 값 생성print(randint(1, 45)) # 1 ~ 45 이하의 임의의 값 생성 문자열 123456789sentence = '나는 소년입니다'print(sentence)sentence2 = \"파이썬은 쉬워요\"print(sentence2)sentence3 = \"\"\"나는 소년이고,파이썬은 쉬워요\"\"\"print(sentence3) 슬라이싱 1234567891011jumin = \"990101-1234567\"print(\"성별 : \" + jumin[7])print(\"연 : \" + jumin[0:2]) # 0 부터 2 직전까지 (0, 1)print(\"월 : \" + jumin[2:4])print(\"일 : \" + jumin[4:6])print(\"생년월일 : \" + jumin[:6]) # 처음부터 6 직전까지print(\"뒤 7자리 : \" + jumin[7:]) # 7 부터 끝까지print(\"뒤 7자리 (뒤에부터) : \" + jumin[-7:])# 맨 뒤에서 7번째부터 끝까지 문자열 처리 함수 1234567891011121314python = \"Python is Amazing\"print(python.lower()) # 소문자로print(python.upper()) # 대문자로print(python[0].isupper())print(len(python)) # 길이print(python.replace(\"Python\", \"Java\")) # 문자열 바꿈index = python.index(\"n\") # 문자열 위치 찾기index = python.index(\"n\", index + 1) # 두번째 n의 위치 찾기print(python.find(\"Java\")) # 문자를 찾지 못할 경우 -1 출력print(python.index(\"Java\")) # 문자를 찾지 못할 경우 오류남print(python.count(\"n\")) # 문자열 n이 나오는 개수 문자열 포맷 123456789101112131415161718192021# 방법 1print(\"나는 %d살입니다.\" % 35) # 정수만print(\"나는 %s을 좋아해요\" % \"파이썬\") # 문자열만print(\"Apple 은 %c로 시작해요.\" % \"A\") # 한글자만 받겠다는 의미# %sprint(\"나는 %s살입니다.\" % 35)print(\"나는 %s색과 %s색을 좋아해요.\" % (\"파란\", \"빨간\"))# 방법 2print(\"나는 &#123;&#125;살입니다.\".format(35))print(\"나는 &#123;&#125;색과 &#123;&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;0&#125;색과 &#123;1&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;1&#125;색과 &#123;0&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))# 방법 3print(\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\".format(age=35, color=\"빨간\"))# 방법 4 (v3.6 이상~)age = 35color = \"빨간\"print(f\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\") 탈출 문자 1234567891011121314151617181920# \\n : 줄바꿈print(\"백문이 불여일견\\n백견이 불여일타\")# \\\" \\' : 문장 내에서 따옴표# 저는 \"고고고\" 입니다.print(\"저는 '고고고' 입니다.\")print('저는 \"고고고\" 입니다.')print(\"저는 \\\"고고고\\\" 입니다.\")# \\\\ : 문장 내에서 \\print(\"C:\\\\Users\\\\hgko\\\\Desktop\\\\project\\\\Python\\\\PythonStudy\")# \\r : 커서를 맨 앞으로 이동print(\"Red Apple\\rPine\")# \\b : 백스페이스 (한 글자 삭제)print(\"Redd\\bApple\")# \\t : 탭print(\"Red\\tApple\") 리스트 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 리스트 []# 지하철 칸별로 10명, 20명, 30명subway1 = 10subway2 = 20subway3 = 30subway = [10, 20, 30]print(subway)subway = [\"유재석\", \"조세호\", \"박명수\"]# 조세호 씨가 몇 번째 칸에 타고 있는지?print(subway.index(\"조세호\"))# 하하 씨가 다음 정류장에서 다음 칸에 탐subway.append(\"하하\")# 정형돈 씨를 유재석 / 조세호 사이에 태워봄subway.insert(1, \"정형돈\")# 지하철에 있는 사람을 한 명 씩 뒤에서 꺼냄print(subway.pop())# 같은 이름의 사람이 몇 명 있는지 확인subway.append(\"유재석\")print(subway.count(\"유재석\"))# 정렬num_list = [5,2,4,3,1]num_list.sort()# 순서 뒤집기num_list.reverse()# 모두 지우기num_list.clear()# 다양한 자료형 함께 사용num_list = [5,2,4,3,1]mix_list = [\"유재석\", 20, True]# 리스트 확장num_list.extend(mix_list) 사전 1234567891011121314151617181920212223242526272829303132cabinet = &#123;3:\"유재석\", 100:\"김태호\"&#125;print(cabinet[3])print(cabinet[100])print(cabinet.get(3))print(cabinet.get(5, \"사용 가능\"))print(3 in cabinet) # Trueprint(5 in cabinet) # Falsecabinet = &#123;\"A-3\":\"유재석\", \"B-100\":\"김태호\"&#125;print(cabinet[\"A-3\"])print(cabinet[\"B-100\"])# 새 손님cabinet[\"A-3\"] = \"김종국\" # 업데이트cabinet[\"C-20\"] = \"조세호\" # 추가# 간 손님del cabinet[\"A-3\"]# key 들만 출력print(cabinet.keys())# value 들만 출력print(cabinet.values())# key, value 쌍으로 출력print(cabinet.items())# 전체 삭제cabinet.clear() 튜플 1234menu = (\"돈까스\", \"치즈까스\")(name, age, hobby) = (\"김종국\", 20, \"코딩\")print(name, age, hobby) 세트 12345678910111213141516171819202122232425# 집합 (set)# 중복 안됨, 순서 없음my_set = &#123;1,2,3,3,3&#125;print(my_set)java = &#123;\"유재석\", \"김태호\", \"양세형\"&#125;python = set([\"유재석\", \"박명수\"])# 교집합 (java 와 python 을 모두 할 수 있는 개발자)print(java &amp; python)print(java.intersection(python))# 합집합 (java 할 수 있거나 python 도 할 수 있는 개발자)print(java | python)print(java.union(python))# 차집합 (java 할 수 있지만 python 은 할 줄 모르는 개발자)print(java - python)print(java.difference(python))# python 할 줄 아는 사람이 늘어남python.add(\"김태호\")# java 를 잊어버림java.remove(\"김태호\") 자료구조의 변경 123456789101112# 커피숍menu = &#123;\"커피\", \"우유\", \"주소\"&#125;print(menu, type(menu)) # &#123;'커피', '주소', '우유'&#125; &lt;class 'set'&gt;menu = list(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'list'&gt;menu = tuple(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'tuple'&gt;menu = set(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'set'&gt; if 1234567891011121314151617weather = input(\"오늘 날씨는 어때요?\")if weather == \"비\" or weather == \"눈\": print(\"우산을 챙기세요\")elif weather == \"미세먼지\": print(\"마스크를 챙기세요\")else: print(\"준비물 필요 없어요\")temp = int(input(\"기운은 어때요?\"))if 30 &lt;= temp: print(\"너무 더워요. 나가지 마세요\")elif 10 &lt;= temp and temp &lt; 30: print(\"괜찮은 날씨에요\")elif 0 &lt;= temp &lt; 10: print(\"외투를 챙기세요\")else: print(\"너무 추워요. 나가지 마세요\") for 123# randrange()for waiting_no in range(1, 6): # 1, 2, 3, 4, 5 print(\"대기번호 : &#123;0&#125;\".format(waiting_no)) while 12345customer = \"토르\"person = \"Unknown\"while person != customer: print(\"&#123;0&#125;, 커피가 준비 되었습니다.\".format(customer)) person = input(\"이름이 어떻게 되세요?\") 한 줄 for 123456students = [1,2,3,4,5]students = [i+100 for i in students]# 학생 이름을 길이도 반환students = [\"Iron man\", \"Thor\", \"I am groot\"]students = [len(i) for i in students]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Angular] Angular Cli 설치 및 사용 방법","slug":"angular-1","date":"2022-07-28T11:31:14.000Z","updated":"2023-06-22T08:17:26.748Z","comments":true,"path":"2022/07/28/angular-1/","link":"","permalink":"http://hgko1207.github.io/2022/07/28/angular-1/","excerpt":"","text":"Angular 는 Angular CLI 를 이용해 프로젝트 관리의 복잡도를 낮추고 Angular 개발에만 집중할 수 있게 합니다. 설치 Angular CLI 를 설치하려면 다음과 같은 npm 명령어를 실행합니다. 1$ npm install -g @angular/cli 설치가 완료되면 ng 명령어를 사용할 수 있습니다. ng 명령어는 Angular CLI 에서 제공하는 기능들을 실행하는 역할을 담당합니다. Angular CLI 도움말 옵션을 사용해 확인해봅니다. 1234567891011121314151617181920212223242526272829303132$ ng --helpng &lt;command&gt;Commands: ng add &lt;collection&gt; Adds support for an external library to your project. ng analytics Configures the gathering of Angular CLI usage metrics. ng build [project] Compiles an Angular application or library into an output directory named dist/ at the given output path. [aliases: b] ng cache Configure persistent disk cache and retrieve cache statistics. ng completion Set up Angular CLI autocompletion for your terminal. ng config [json-path] [value] Retrieves or sets Angular configuration values in the angular.json file for the workspace. ng deploy [project] Invokes the deploy builder for a specified project or for the default project in the workspace. ng doc &lt;keyword&gt; Opens the official Angular documentation (angular.io) in a browser, and searches for a given keyword. [aliases: d] ng e2e [project] Builds and serves an Angular application, then runs end-to-end tests. [aliases: e] ng extract-i18n [project] Extracts i18n messages from source code. ng generate Generates and/or modifies files based on a schematic. [aliases: g] ng lint [project] Runs linting tools on Angular application code in a given project folder. ng new [name] Creates a new Angular workspace. [aliases: n] ng run &lt;target&gt; Runs an Architect target with an optional custom builder configuration defined in your project. ng serve [project] Builds and serves your application, rebuilding on file changes. [aliases: s] ng test [project] Runs unit tests in a project. [aliases: t] ng update [packages..] Updates your workspace and its dependencies. See https://update.angular.io/. ng version Outputs Angular CLI version. [aliases: v]Options: --help Shows a help message for this command in the console. [boolean]For more information, see https://angular.io/cli/. 프로젝트 생성 Angular 프로젝트를 생성하려면 ng new 명령어를 사용합니다. 1$ ng new [프로젝트명] ng new 명령어 다음에 프로젝트 이름을 지정하면 프로젝트 이름과 일치하는 새로운 프로젝트 폴더가 생성되고 스캐폴딩(프로젝트 기본 골격)이 작성됩니다. 프로젝트 이름을 my-app 로 지정하여 프로젝트를 생성합니다. 1$ $ ng new my-app 프로젝트가 생성되면 아래와 같은 파일 구조의 스캐폴딩이 생성됩니다. 12345678910111213my-app&#x2F;├── .git&#x2F;├── node_modules&#x2F;├── src&#x2F;├── .editorconfig├── .gitignore├── angular.json├── package-lock.json├── package.json├── README.md├── tsconfig.app.json├── tsconfig.json└── tsconfig.spec.json 시작 프로젝트 폴더로 이동한 후 실행합니다. 1$ npm start 또는 ng serve 명령어를 사용합니다. 1$ ng serve 이미 포트 4200번을 사용하고 있다면 Angular CLI 내장 서버를 실행할 수 없습니다. 포트번호를 변경해 실행하려면 다음과 같이 --port(축약형 -p) 옵션을 추가한다. 1$ ng serve --port 4201 Build 빌드 결과는 기본적으로 dist/ 폴더에 저장됩니다. 1$ ng build 컴포넌트 생성 1$ ng generate component [component-name] 간략하게 명령어를 사용할 수 있습니다. 1$ ng g c [component-name] 사용 예시입니다. 123$ ng g c section$ ng g m section$ ng g c section/card ng generate directive|pipe|service|class|guard|interface|enum|module 명령어를 통해 컴포넌트 외에 다른 파일들을 생성할 수 있습니다. Running unit tests Karma 를 통해 단위 테스트를 할 수 있습니다. 1$ ng test Running end-to-end tests 선택한 플랫폼을 통해 end-to-end 테스트를 실행합니다. 이 명령을 사용하려면 먼저 end-to-end 테스트 기능을 구현하는 패키지를 추가해야 합니다. 1$ ng e2e 참고 Angular CLI https://angular.io/cli https://angular.io/tutorial https://material.angular.io/ https://angular.io/guide/devtools https://blog.angular.io/ vscode 플러그인 Angular Files Angular Language Service TypeScript Hero: 소스 코드 관리에 필요한 TypeScript 코드 정렬을 도와주는 Plugin","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"}]},{"title":"[React] Recoil 사용 방법","slug":"react-6","date":"2022-07-25T13:54:57.000Z","updated":"2023-06-15T01:30:16.858Z","comments":true,"path":"2022/07/25/react-6/","link":"","permalink":"http://hgko1207.github.io/2022/07/25/react-6/","excerpt":"","text":"Recoil 사용 방법에 대해 알아보겠습니다. Recoil Recoil 는 페이스북에서 만든 React를 위한 상태 관리 라이브러리입니다. Recoil을 사용하면 atoms (공유 상태)에서 selectors (순수 함수)를 거쳐 React 컴포넌트로 내려가는 data-flow graph를 만들 수 있습니다. 설치 Recoil 패키지는 npm에 존재합니다. 안정한 최신 버전을 설치하기 위해서는 다음의 명령어를 실행하면 됩니다. 1$ npm install recoil 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add recoil RecoilRoot 루트에 RecoilRoot를 감싸줍니다. 12345678910111213// index.tsximport &#123; RecoilRoot &#125; from 'recoil';import ToggleOutput from './ToggleOutput';import ToggleButton from './ToggleButton';function App() &#123; return ( &lt;RecoilRoot&gt; &lt;ToggleOutput /&gt; &lt;ToggleButton /&gt; &lt;/RecoilRoot&gt; );&#125; 사용 Atoms Atoms 는 상태(state)의 일부를 나타냅니다. Atoms 는 어떤 컴포넌트에서나 읽고 쓸 수 있습니다. atoms.ts 파일을 생성하고 Recoil의 atom function 을 사용하여 필요한 데이터를 설정합니다. atom 은 두 가지를 요구하는데 첫 번째는 key 로 unique ID 이고 두 번째는 default value 입니다. 1234567// atoms.tsimport &#123; atom &#125; from 'recoil';export const isToggleAtom = atom(&#123; key: 'isToggle', default: false,&#125;); 컴포넌트가 atom 을 읽게 하기 위해서는 useRecoilValue() 를 다음과 같이 사용하면 됩니다. 123456789// ToggleOutput.tsximport &#123; useRecoilValue &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleOutput() &#123; const isToggle = useRecoilValue(isToggleAtom); return &lt;div&gt;Toggle state: &#123;isToggle&#125;&lt;/div&gt;;&#125; 컴포넌트가 atom 을 쓰게 하기 위해서는 useSetRecoilState() 를 다음과 같이 사용하면 됩니다. atom 을 읽고 쓰게 하기 위해서는 useRecoilState() 를 사용하면 됩니다. 12345678910111213141516// ToggleButton.tsximport &#123; useSetRecoilState &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleButton() &#123; const setToggleAtom = useSetRecoilState(isToggleAtom); const toggle = () =&gt; setToggleAtom((prev) =&gt; !prev); return ( &lt;div&gt; &lt;br /&gt; &lt;button onClick=&#123;toggle&#125;&gt;Toggle Mode&lt;/button&gt; &lt;/div&gt; );&#125; Selectors Selectors는 devived state 를 나타냅니다. devived state 란 state 를 입력 받아서 그걸 변형해 반환하는 순수 함수를 거쳐 반환된 값을 말합니다. atom 의 output 은 한가지 형태이므로 조금 더 잘 써먹을 수 있는 형태로 변형해줍니다. 12345678910111213141516171819202122export interface IToDo &#123; text: string; id: number; category: 'TO_DO' | 'DOING' | 'DONE';&#125;export const toDoState = atom&lt;IToDo[]&gt;(&#123; key: 'toDo', default: [],&#125;);export const toDoSelector = selector(&#123; key: 'toDoSelector', get: (&#123; get &#125;) =&gt; &#123; const toDos = get(toDoState); return [ toDos.filter((toDo) =&gt; toDo.category === 'TO_DO'), toDos.filter((toDo) =&gt; toDo.category === 'DOING'), toDos.filter((toDo) =&gt; toDo.category === 'DONE'), ]; &#125;,&#125;); category 값을 3개의 타입 형태로 사용할 경우 타입 별로 값을 반환하고 싶을 때 selector 를 사용하여 atom 에서 각각의 타입 별로 값을 분류하고 합쳐서 하나의 값으로 반환합니다. 참고 https://recoiljs.org/ko/docs/introduction/getting-started https://recoiljs.org/docs/basic-tutorial/selectors/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"}]},{"title":"[React] ApexCharts 사용 방법","slug":"react-5","date":"2022-07-24T13:16:30.000Z","updated":"2023-03-14T02:23:51.399Z","comments":true,"path":"2022/07/24/react-5/","link":"","permalink":"http://hgko1207.github.io/2022/07/24/react-5/","excerpt":"","text":"ApexCharts 는 데이터를 시각화 해주는 차트 라이브러리입니다. 무료로 사용할 수 있고, Js, Angular, React, Vue를 지원합니다. ApexCharts 를 사용하여 React.js 에서 간단하게 차트 만드는 방법에 대해 알아보겠습니다. 설치 apexcharts 와 react-apexcharts 라이브러리를 같이 설치합니다. 1$ npm install --save react-apexcharts apexcharts 사용 코인 정보를 조회하여 차트를 구성하였습니다. Line Chart 를 예제로 사용하였습니다. 1234567891011// api.tsconst BASE_URL = `https://api.coinpaprika.com/v1`;// 코인 정보 조회export function fetchCoinHistory(coinId: string) &#123; const endDate = Math.floor(Date.now() / 1000); const startDate = endDate - 60 * 60 * 23; // 하루치 조회 return fetch(`$&#123;BASE_URL&#125;/coins/$&#123;coinId&#125;/ohlcv/historical?start=$&#123;startDate&#125;&amp;end=$&#123;endDate&#125;`).then((reponse) =&gt; reponse.json() );&#125; https://apexcharts.com/docs/options/# 페이지를 참고하여 옵션을 커스텀합니다. 테마, x축, y축, 색상, 툴바 감추기, 크기, 툴팁 설정 등 세세한 부분까지 커스텀 할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Chart.tsximport &#123; useQuery &#125; from 'react-query';import &#123; useOutletContext &#125; from 'react-router';import &#123; fetchCoinHistory &#125; from '../api';import ApexChart from 'react-apexcharts';interface IHistorical &#123; time_open: string; time_close: string; open: number; high: number; low: number; close: number; volume: number; market_cap: number;&#125;function Chart() &#123; const coinId = useOutletContext() as string; const &#123; isLoading, data &#125; = useQuery&lt;IHistorical[]&gt;(['ohlcv', coinId], () =&gt; fetchCoinHistory(coinId)); return ( &lt;div&gt; &#123;isLoading ? ( 'Loading chart...' ) : ( &lt;ApexChart type=\"line\" series=&#123;[ &#123; name: 'Price', data: data?.map((price) =&gt; price.close) as number[], &#125;, ]&#125; options=&#123;&#123; theme: &#123; mode: 'dark', &#125;, chart: &#123; height: 300, width: 500, toolbar: &#123; show: false, &#125;, background: 'transparent', &#125;, grid: &#123; show: false, &#125;, stroke: &#123; curve: 'smooth', width: 4, &#125;, yaxis: &#123; show: false, &#125;, xaxis: &#123; type: 'datetime', categories: data?.map((price) =&gt; price.time_close), labels: &#123; style: &#123; colors: '#9c88ff', &#125;, &#125;, &#125;, fill: &#123; type: 'gradient', gradient: &#123; gradientToColors: ['blue'], stops: [0, 100], &#125;, &#125;, colors: ['red'], tooltip: &#123; y: &#123; formatter: (value) =&gt; `$$&#123;value.toFixed(2)&#125;`, &#125;, &#125;, &#125;&#125; /&gt; )&#125; &lt;/div&gt; );&#125;export default Chart; 참고 https://apexcharts.com/docs/react-charts/ https://apexcharts.com/docs/options/# https://api.coinpaprika.com/#tag/Coins/paths/1coins1{coin_id}1ohlcv1historical/get","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"}]},{"title":"[React] React Query","slug":"react-4","date":"2022-07-22T15:07:58.000Z","updated":"2023-06-05T00:38:50.971Z","comments":true,"path":"2022/07/23/react-4/","link":"","permalink":"http://hgko1207.github.io/2022/07/23/react-4/","excerpt":"","text":"React Query 는 데이터 Fetching, 캐싱, 동기화, 업데이트, 에러핸들링 등 비동기 과정을 쉽게 만들어 주는 React 라이브러리입니다. React Query 를 사용하면 기존의 서버 데이터를 가져오거나 업데이트하는 코드를 축약할 수 있고 캐싱 처리가 간단해졌습니다. 간단하게 useQuery를 사용하여 코인들의 정보를 조회하는 코드를 통해 React Query 사용 전 후를 비교하였었습니다. 설치 123$ npm i react-queryor$ yarn add react-query useQuery 서버에서 데이터를 가져오기 위해 모든 Promise 기반 메서드(GET 및 POST 포함)와 함께 사용할 수 있습니다. 첫 번째 파라미터는 unique Key 이고, 두 번째는 비동기 함수(api호출 함수)입니다. return 개체에는 api 의 로딩상태, 성공, 실패여부, 결과 데이터를 포함한 객체입니다. React Query 사용 전 코인들의 정보를 조회하는 코드입니다. useState 를 사용하여 코인 데이터와 조회 상태를 따로 관리하였었습니다. 12345678910111213141516171819202122232425262728293031// Coins.tsximport &#123; useEffect, useState &#125; from 'react';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;function Coins() &#123; const [coins, setCoins] = useState&lt;ICoin[]&gt;([]); const [loading, setLoading] = useState(true); useEffect(() =&gt; &#123; (async () =&gt; &#123; const response = await fetch('https://api.coinpaprika.com/v1/coins'); const json = await response.json(); setCoins(json.slice(0, 100)); setLoading(false); &#125;)(); &#125;, []); return ( ... );&#125;export default Coins; React Query 사용 후 먼저 React Query 를 사용하도록 세팅합니다. 12345678910111213141516// index.tsximport React from 'react';import ReactDOM from 'react-dom';import App from './App';import &#123; QueryClient, QueryClientProvider &#125; from 'react-query';const queryClient = new QueryClient();ReactDOM.render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 코인들의 정보를 조회하는 코드를 별도 파일을 생성하여 관리합니다. 1234// api.tsexport function fetchCoins() &#123; return fetch('https://api.coinpaprika.com/v1/coins').then((reponse) =&gt; reponse.json());&#125; React Query 를 사용하기 전과 비교하면 많은 코드가 제거된 것을 확인할 수 있습니다. 12345678910111213141516171819202122import &#123; useQuery &#125; from 'react-query';import &#123; fetchCoins &#125; from '../api';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;// coins.tsxfunction Coins() &#123; const &#123; isLoading, isError, data &#125; = useQuery&lt;ICoin[]&gt;('allCoins', fetchCoins); return ( ... );&#125;export default Coins; useQuery 파라미터와 결과 값을 다음과 같이 변형해서 사용할 수 있습니다. 123const &#123; isLoading: infoLoding, data: infoData &#125; = useQuery&lt;InfoData&gt;(['info', coinId], () =&gt; fetchCoinInfo(coinId as string)); Devtools React Query 는 query 데이터를 시각화 하기 위해서 Devtools(Developer Tools, 개발자도구)를 기능을 가지고 있습니다. 1234567891011// App.tsximport &#123; ReactQueryDevtools &#125; from 'react-query/devtools';function App() &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &#123;/* The rest of your application */&#125; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; /&gt; &lt;/QueryClientProvider&gt; );&#125; initialIsOpen: 개발자도구가 기본적으로 열려 있도록 하려면 true 로 설정 참고 https://react-query-v3.tanstack.com/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"}]},{"title":"[React] Nested Routes","slug":"react-3","date":"2022-07-21T15:59:11.000Z","updated":"2023-03-14T02:23:46.305Z","comments":true,"path":"2022/07/22/react-3/","link":"","permalink":"http://hgko1207.github.io/2022/07/22/react-3/","excerpt":"","text":"Nested Routes 는 route 안에 있는 또 다른 route 입니다. React Router 가 v6 로 바뀌면서 Nested Routes 만 아니라 Route 사용하는 방법이 바뀌었습니다. 전 5 버전과 현재 6 버전 사용법을 비교하였습니다. React Router v5 nested routes 를 구현하는 방법은 자식 route 를 부모 route 의 element 내부에 작성하는 것 입니다. 1234567891011121314151617181920// Router.tsximport &#123; BrowserRouter, Switch, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/:coinId\"&gt; &lt;Coin /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Coins /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 12345678910111213141516171819202122// Coin.tsximport &#123; Switch, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Switch&gt; &lt;Route path=\"price\"&gt; &lt;Price /&gt; &lt;/Route&gt; &lt;Route path=\"chart\"&gt; &lt;Chart /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Container&gt; );&#125;export default Coin; React Router v6 nested routes 를 구현하는 방법은 두 가지가 있습니다. 6 버전에서는 Switch 가 Routes 로 변경됐습니다. 첫 번째 부모 route 의 path 마지막에 /*를 적어 명시적으로 이 route의 내부에서 nested route 가 render 될 수 있음을 표시하고 자식 route 를 부모 route 의 element 내부에 작성하는 방법입니다. 1234567891011121314151617// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId/*\" element=&#123;&lt;Coin /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415161718// Coin.tsximport &#123; Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Routes&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/Container&gt; );&#125;export default Coin; 두 번째 자식 route 를 부모 element 의 내부가 아닌 Router 내부에 작성하는 방법입니다. 그리고 이 자식 Route 들이 어디에 render 될지 부모의 element 안에 Outlet 을 이용해 표시해주면 됩니다. 12345678910111213141516171819202122// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Chart from './routes/Chart';import Coin from './routes/Coin';import Coins from './routes/Coins';import Price from './routes/Price';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId\" element=&#123;&lt;Coin /&gt;&#125;&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125; /&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125; /&gt; &lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415// Coin.tsximport &#123; Outlet, Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Outlet /&gt; &lt;/Container&gt; );&#125;export default Coin; 참고 https://ui.dev/react-router-nested-routes https://reactrouter.com/docs/en/v6/getting-started/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"}]},{"title":"[JPA] 복합키 사용","slug":"spring-jpa-2","date":"2022-07-13T10:21:50.000Z","updated":"2023-03-14T02:23:44.191Z","comments":true,"path":"2022/07/13/spring-jpa-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/13/spring-jpa-2/","excerpt":"","text":"서론 복합키는 기본키가 되지 못하는 컬럼들을 서로 묶어서 기본키처럼 사용하는 것입니다. Entity 예를 들어 사용자명과 이메일을 복합키로 사용한다고 가정합니다. 복합키로 묶는 CompositePK 클래스를 생성하고, @IdClass 어노테이션을 사용하여 설정합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = \"tb_user\")@IdClass(CompositePK.class) //이름과 이메일을 primary key로 사용@Datapublic class User &#123; @Data @AllArgsConstructor @NoArgsConstructor public static class CompositePK implements Domain &#123; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 이메일 */ @Column(length = 45) private String email; &#125; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Repository 인터페이스를 생성하고 JpaRepository 를 상속받습니다. 12public interface UserRepository extends JpaRepository&lt;User, CompositePK&gt; &#123;&#125; 사용 Service 클래스를 생성하고 Repository 인터페이스를 불러와서 사용합니다. 1234567891011@Service@Transactionalpublic class UserService &#123; @Autowired private UserRepository userRepository; public User get(CompositePK id) &#123; return userRepository.findById(id).orElse(null); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"}]},{"title":"[React] TypeScript 사용 방법","slug":"react-2","date":"2022-07-03T14:52:45.000Z","updated":"2023-05-30T14:21:27.806Z","comments":true,"path":"2022/07/03/react-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/03/react-2/","excerpt":"","text":"React 에서 TypeScript 를 적용하고 사용 방법에 대해 알아보겠습니다. 설치 create-react-app 명령어에 typescript 옵션을 추가합니다. 1$ npx create-react-app typescript --template typescript Typescript 를 추가하지 않은 기존 프로젝트가 있다면 다음 명령어를 실행하여 설치합니다. 1$ npm install --save typescript @types/node @types/react @types/react-dom @types/jest Typescript 사용 시 styled-components 부분에서 에러가 날 경우 다음 명령어를 실행하여 설치합니다. 1$ npm i --save-dev @types/styled-components Typing the Props Prop Types 는 코드를 실행한 후 에만 브라우저의 콘솔에 경고 표시로 확인이 가능합니다. TypeScript 를 사용하는 이유는 코드가 실행되기 전에 오류를 확인하기 위해서입니다. interface 는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있습니다. 123456789101112import Circle from './Circle';function App() &#123; return ( &lt;div&gt; &lt;Circle bgColor=\"teal\" /&gt; &lt;Circle bgColor=\"tomato\" /&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718import styled from 'styled-components';interface CircleProps &#123; bgColor: string;&#125;const Container = styled.div&lt;CircleProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;;`;function Circle(&#123; bgColor &#125;: CircleProps) &#123; return &lt;Container bgColor=&#123;bgColor&#125; /&gt;;&#125;export default Circle; Optional Props props는 기본으로 required 이지만 interface 의 object 뒤에 ?를 추가하여 optional 될 수 있도록 변경 가능합니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';interface ContainerProps &#123; bgColor: string; borderColor: string;&#125;const Container = styled.div&lt;ContainerProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;; border: 1px solid $&#123;(props) =&gt; props.borderColor&#125;;`;interface CircleProps &#123; bgColor: string; borderColor?: string; // object뒤에 ?를 추가 =&gt; Option props text?: string;&#125;function Circle(&#123; bgColor, borderColor, text = 'default text' &#125;: CircleProps) &#123; return ( &lt;Container bgColor=&#123;bgColor&#125; borderColor=&#123;borderColor ?? 'white'&#125;&gt; &#123;text&#125; &lt;/Container&gt; );&#125;export default Circle; State State 사용 시 number, string 타입을 같이 쓰고 싶다면 다음과 같이 정의합니다. 1234const [value, setValue] = useState&lt;number | string&gt;(0);setValue(1);setValue('hello');setValue(true); // error Event https://reactjs.org/docs/events.html SyntheticEvent 는 기본적으로 ReactJS 버전의 이벤트입니다. 이벤트들의 정보를 확인하는 사이트입니다. Form React.FormEvent&lt;HTMLInputElement&gt; 또는 React.FormEvent&lt;HTMLFormElement&gt; 와 같은 Element 를 사용함으로써 event 를 보호하고 어떤 event 를 받는지 알 수 있습니다. 12345678910111213141516171819202122232425import React, &#123; useState &#125; from 'react';function App() &#123; const [value, setValue] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setValue(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); console.log(value); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; type=\"text\" placeholder=\"username\" /&gt; &lt;button&gt;Log in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default App; Theme https://styled-components.com/docs/api#typescript styled.d.ts 파일을 생성합니다. 12345678910// styled.d.tsimport 'styled-components';declare module 'styled-components' &#123; export interface DefaultTheme &#123; textColor: string; bgColor: string; btnColor: string; &#125;&#125; thmem.ts 파일을 생성하고 테마를 정의합니다. 1234567891011121314// thmem.tsimport &#123; DefaultTheme &#125; from 'styled-components';export const lightTheme: DefaultTheme = &#123; bgColor: 'white', textColor: 'black', btnColor: 'tomato',&#125;;export const darkTheme: DefaultTheme = &#123; bgColor: 'black', textColor: 'white', btnColor: 'teal',&#125;; React에서 테마 사용하는 것과 똑같은 방식입니다. 123456789101112131415// index.tsximport React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';import &#123; lightTheme &#125; from './theme';ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;lightTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 참고 https://create-react-app.dev/docs/adding-typescript/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[React] Styled Components 사용 방법","slug":"react-1","date":"2022-06-28T14:36:34.000Z","updated":"2023-06-05T00:52:47.779Z","comments":true,"path":"2022/06/28/react-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/28/react-1/","excerpt":"","text":"React 에서 Styled Components를 사용하는 방법에 대해 알아보겠습니다. 설치 Visual Studio Code를 사용시 Styled-Component 자동 완성을 위해 vscode-styled-components 플러그인을 설치합니다. 1$ npm i styled-components https://styled-components.com/ 사용 예 123456789101112131415161718192021222324252627282930import styled from 'styled-components';const Father = styled.div` display: flex;`;const BoxOne = styled.div` background-color: teal; width: 100px; height: 100px;`;const BoxTwo = styled.div` background-color: tomato; width: 100px; height: 100px;`;const Text = styled.span` color: white;`;function App() &#123; return ( &lt;Father&gt; &lt;BoxOne&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/BoxOne&gt; &lt;BoxTwo /&gt; &lt;/Father&gt; );&#125;export default App; 확장 컴포넌트를 확장하는 방법입니다. 12345678const Box = styled.div` background-color: $&#123;(props) =&gt; props.bgColor&#125;; width: 100px; height: 100px;`;const Circle = styled(Box)` border-radius: 50px;`; ‘As’ and Attrs 다음과 같이 as 속성을 사용하여 값을 a 로 지정하면 button 태그가 a 태그로 변경됩니다. 12345678const Btn = styled.button` color: white; background-color: tomato; border: 0; border-radius: 15px;`;&lt;Btn as=\"a\"&gt;Log in&lt;/Btn&gt;; 속성 값 설정 attrs 을 사용하여 HTML 태그에 속성 값을 설정 할 수 있습니다. 123const Input = styled.input.attrs(&#123; require: true, minLength: 10 &#125;)` background-color: tomato;`; Animation keyframes 를 추가하고, Animation 을 설정합니다. 그리고 styled components 에 ${} 를 통해 설정된 변수를 지정합니다. 123456789101112131415161718192021222324252627282930313233343536import styled, &#123; keyframes &#125; from 'styled-components';const rotationAnimation = keyframes` 0% &#123; transform: rotate(0deg); border-radius: 0px; &#125; 50% &#123; border-radius: 100px; &#125; 100% &#123; transform: rotate(360deg); border-radius: 0px; &#125;`;const Wrapper = styled.div` display: flex;`;const Box = styled.div` height: 200px; width: 200px; background-color: tomato; animation: $&#123;rotationAnimation&#125; 1s linear infinite;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box /&gt; &lt;/Wrapper&gt; );&#125;export default App; Theme index.js 파일에서 ThemeProvider 를 styled-components 로 부터 Import 한 후 App 태그를 감쌉니다. Theme 에 어떤 색을 사용할 건지 설정합니다. 1234567891011121314151617181920212223import React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';const darkTheme = &#123; textColor: 'whitesmoke', backgroundColor: '#111',&#125;;const lightTheme = &#123; textColor: '#111', backgroundColor: 'whitesmoke',&#125;;ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;darkTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 위에서 설정한 Theme 변수를 사용합니다. Theme가 변경되면 Title 이나 Wrapper 안의 글자 색상과 배경색이 변화되는 것을 확인 할 수 있습니다. 123456789101112131415161718192021222324import styled from 'styled-components';const Title = styled.h1` color: $&#123;(props) =&gt; props.theme.textColor&#125;;`;const Wrapper = styled.div` display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; background-color: $&#123;(props) =&gt; props.theme.backgroundColor&#125;;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Title&gt;Hello&lt;/Title&gt; &lt;/Wrapper&gt; );&#125;export default App;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"}]},{"title":"[WPF] ffmpeg을 활용한 동영상 만들기","slug":"wpf-7","date":"2022-06-24T14:06:59.000Z","updated":"2023-06-05T00:38:30.681Z","comments":true,"path":"2022/06/24/wpf-7/","link":"","permalink":"http://hgko1207.github.io/2022/06/24/wpf-7/","excerpt":"","text":"FFmpeg Build 다운로드 받기 https://ffmpeg.org/download.html#build-windows 사이트에서 Windows EXE Files 항목의 원하는 형식으로 다운로드를 받습니다. 다운로드 받은 후 압축해제 합니다. 프로젝트의 ffmpeg 폴더를 생성 후 실행에 사용되는 exe, dll 파일들을 복사합니다. Bitmap들을 동영상으로 만들기 FFmpegLoader ffmpeg를 사용하기 위해 FFMediaToolkit 패키지를 Nuget 을 이용하여 설치합니다. FFmpegLoader를 사용하여 Path를 지정합니다. 12// 예FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; 동영상에 프레임 추가 아래는 예제코드입니다. StartRecordVideo 함수에 저장될 경로를 지정하여 mediaFile을 생성합니다. 그리고 AddRecordFrame 함수를 통해 Bitmap 이미지를 설정한 30fps 로 동영상에 추가합니다. 이렇게 생성된 동영상은 MPEG2 형식이므로 MPEG4 형식으로 변경합니다. MPEG2 형식의 동영상은 가끔 윈도우 환경에서 오류가 발생하는 경우가 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using FFMediaToolkit;using FFMediaToolkit.Encoding;using FFMediaToolkit.Graphics;namespace Hgko.Utils&#123; public class ImageService &#123; private bool ffmpegInit = false; private MediaOutput mediaFile = null; /// &lt;summary&gt; /// Start Record video /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public void StartRecordVideo(string path) &#123; if (mediaFile == null) &#123; if (!ffmpegInit) &#123; FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; ffmpegInit = true; &#125; int width = 1024; int heigth = 1024; VideoEncoderSettings settings = new VideoEncoderSettings(width, heigth, 30, VideoCodec.MPEG2); settings.EncoderPreset = EncoderPreset.Medium; mediaFile = MediaBuilder.CreateContainer(path).WithVideo(settings).Create(); &#125; &#125; /// &lt;summary&gt; /// Add RecordFrame /// &lt;/summary&gt; /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt; public void AddRecordFrame(Bitmap bitmap) &#123; if (bitmap == null) return; if (mediaFile == null) return; System.Drawing.Imaging.BitmapData bdata = bitmap.LockBits(new Rectangle(System.Drawing.Point.Empty, bitmap.Size), System.Drawing.Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat); ImageData imgdata = ImageData.FromPointer(bdata.Scan0, ImagePixelFormat.Bgra32, bitmap.Size); mediaFile.Video.AddFrame(imgdata); bitmap.UnlockBits(bdata); &#125; /// &lt;summary&gt; /// Stop Record Video /// &lt;/summary&gt; public void StopRecordVideo() &#123; if (mediaFile != null) &#123; mediaFile.Video.Dispose(); mediaFile.Dispose(); mediaFile = null; &#125; &#125; &#125;&#125; 동영상 포맷 변환 임시로 빌드되는 경로에 display/video 경로의 폴더를 생성합니다. 포맷 변환하는 방법은 많습니다. 다음 코드는 여러 이미지 또는 동영상을 합쳐서 새로운 동영상으로 만드는 형식의 방법을 활용하여 포맷 변환을 진행합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.IO;/// &lt;summary&gt;/// End Record Video/// &lt;/summary&gt;/// &lt;param name=\"mp2Path\"&gt;mp2 형식으로 저장된 파일경로&lt;/param&gt;public void EndRecordVideo(string mp2Path)&#123; string videoWorkingPath = @\".\\display\\video\\\"; string vedeoWorkingFolder = Directory.GetCurrentDirectory() + videoWorkingPath.Replace(\".\", \"\"); string outputVeideoPath = vedeoWorkingFolder + Path.GetFileNameWithoutExtension(mp2Path) + \".mp4\" // if exist video working directory, clean up. if (Directory.Exists(videoWorkingPath)) ClearFolder(videoWorkingPath); // remake working dir. Directory.CreateDirectory(videoWorkingPath); Task.Run(() =&gt; &#123; string lstPath = vedeoWorkingFolder + \"lst.txt\"; // 텍스트 파일에 앞에서 생성된 mp2 동영상 파일 경로 추가 using (StreamWriter writer = File.CreateText(lstPath)) &#123; writer.WriteLine(\"file '&#123;0&#125;'\", mp2Path); &#125; // h264 or mpeg4 string codec = \"h264\"; // 동영상 포맷 변환(mp2 -&gt; mp4) string arg = $@\"-safe 0 -f concat -i \"\"&#123;lstPath&#125;\"\" -c copy -vcodec \"\"&#123;codec&#125;\"\" \"\"&#123;outputVeideoPath&#125;\"\"\"; using (Process process = Process.Start(@\".\\ffmpeg\\ffmpeg.exe\", arg)) &#123; process.WaitForExit(); &#125; &#125;);&#125;/// &lt;summary&gt;/// Clear Folder/// &lt;/summary&gt;/// &lt;param name=\"path\"&gt;삭제할 경로&lt;/param&gt;public static void ClearFolder(string path)&#123; DirectoryInfo dir = new DirectoryInfo(path); // remove all files foreach (FileInfo fi in dir.GetFiles()) fi.Delete(); // remove dir recursive foreach (DirectoryInfo di in dir.GetDirectories()) &#123; ClearFolder(di.FullName); di.Delete(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"}]},{"title":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"book-1","date":"2022-06-22T07:05:37.000Z","updated":"2023-03-04T12:55:58.264Z","comments":true,"path":"2022/06/22/book-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/22/book-1/","excerpt":"","text":"책 정보 책 소개 이 책은 제목 그대로 스프링 부트와 AWS로 웹 서비스를 구현합니다. JPA와 JUnit 테스트, 그레이들, 머스테치, 스프링 시큐리티를 활용한 소셜 로그인 등으로 애플리케이션을 개발하고, 뒤이어 AWS 인프라의 기본 사용법과 AWS EC2와 RDS를 사용해 서비스가 가능하도록 합니다. 이렇게 점진적으로 스프링 부트 프로젝트를 개선해서 배포 자동화하고 무중단 배포까지 경험합니다. 실무 현장에서의 노하우와 테스트 방법, 객체지향 프로그래밍 등을 소개하고 다룹니다. 리뷰 스프링 부트와 AWS로 웹 서비스 구현에 대한 설명이 잘 정리 되어있고, 코드만 따라해도 완성품을 만들 수 있어 도움이 되었습니다. 다만 스프링 부트와 자바에 대한 경험이 필요합니다. 책의 예제 중에서 시간이 지나면서 안되는 기능, 부분들은 GitHub에 오류 수정으로 설명되어 있어 찾으면서 진행하면 좋습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"}]},{"title":"[WPF] 이미지 자르기","slug":"wpf-6","date":"2022-06-20T02:02:13.000Z","updated":"2023-06-05T00:38:17.382Z","comments":true,"path":"2022/06/20/wpf-6/","link":"","permalink":"http://hgko1207.github.io/2022/06/20/wpf-6/","excerpt":"","text":"사각형, 타원, 삼각형으로 이미지를 자르기 위해 다음처럼 정의합니다. 123456public enum ShapeType&#123; Rectangle, Ellipse, Triangle,&#125; 이미지 자르기 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 자릅니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public Bitmap CreateCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; RectangleF srcRect = new Rectangle((int)left, (int)top, (int)width, (int)height); switch (shapeType) &#123; case ShapeType.Rectangle: g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); break; case ShapeType.Ellipse: &#123; int x = (int)width / 2; int y = (int)height / 2; g.SmoothingMode = SmoothingMode.AntiAlias; g.TranslateTransform(result.Width / 2, result.Height / 2); GraphicsPath gp = new GraphicsPath(); gp.AddEllipse(0 - x, 0 - y, result.Width, result.Height); Region rg = new Region(gp); g.SetClip(rg, CombineMode.Replace); g.DrawImage(image, new Rectangle(-x, -y, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Replace); g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; &#125; &#125; return result;&#125; 이미지 제외 나머지 부분 제거 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 제외한 나머지 부분을 제거합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Bitmap CreateInvertCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; switch (shapeType) &#123; case ShapeType.Rectangle: Rectangle rect = new Rectangle((int)left, (int)top, (int)width, (int)height); g.SetClip(rect, CombineMode.Exclude); break; case ShapeType.Ellipse: &#123; GraphicsPath gp = new GraphicsPath(); gp.AddEllipse((int)left, (int)top, (float)width, (float)height); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; &#125; Rectangle destRect = new Rectangle(0, 0, result.Width, result.Height); Rectangle srcRect = new Rectangle(0, 0, result.Width, result.Height); g.DrawImage(image, destRect, srcRect, GraphicsUnit.Pixel); &#125; return result;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"}]},{"title":"[WPF] 이미지 불러오기","slug":"wpf-5","date":"2022-06-18T13:03:19.000Z","updated":"2023-03-14T02:23:28.017Z","comments":true,"path":"2022/06/18/wpf-5/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-5/","excerpt":"","text":"이미지 로드 이미지 파일 경로를 통해 이미지를 로드합니다. 123456789using System.Drawing.Imaging;public Bitmap LoadImage(string path)&#123; using (Bitmap bitmap = new Bitmap(path)) &#123; return bitmap.Clone(new Rectangle(0, 0, bitmap.Width, bitmap.Height), PixelFormat.Format32bppArgb); &#125;&#125; BitmapSource 변환 주어진 비트맵을 WPF 이미징 프레임워크에서 사용 가능한 BitmapSource 형식으로 변환합니다. 1234567891011121314151617181920212223242526using System.Drawing.Imaging;using System.Windows;using System.Windows.Media.Imaging;public BitmapSource ConvertGDIBitmapToWPF(Bitmap image)&#123; if (image == null) return null; Rectangle rect = new Rectangle(0, 0, image.Width, image.Height); BitmapData bitmapData = image.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb); try &#123; int size = rect.Width * rect.Height * 4; BitmapSource result = BitmapSource.Create(image.Width, image.Height, image.HorizontalResolution, image.VerticalResolution, PixelFormats.Bgra32, null, bitmapData.Scan0, size, bitmapData.Stride); result.Freeze(); return result; &#125; finally &#123; image.UnlockBits(bitmapData); &#125;&#125; 빈 비트맵 생성 주어진 크기를 갖는 빈 비트맵을 생성합니다. 123456using System.Drawing.Imaging;public Bitmap MakeEmptyImage(int width, int height)&#123; return new Bitmap(width, height, PixelFormat.Format32bppArgb);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[Devexpress] GridControl 자동 번호 매기기","slug":"wpf-4","date":"2022-06-18T02:33:14.000Z","updated":"2023-03-14T02:23:24.868Z","comments":true,"path":"2022/06/18/wpf-4/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-4/","excerpt":"","text":"Devexpress GridControl 의 TableView 에서 행이 추가될 때마다 컬럼의 숫자가 자동 증가하도록 구현한 코드입니다. Converter 생성 IValueConverter 인터페이스를 상속받아 IndexFromOneConverter 클래스를 생성합니다. 12345678910111213141516171819202122232425using System;using System.Globalization;using System.Windows.Data;/// &lt;summary&gt;/// GridControl의 자동 생성 인덱스를 1 부터로 변환하는 컨버터/// &lt;/summary&gt;namespace IVM.Studio.Utils&#123; public class IndexFromOneConverter : IValueConverter &#123; /// &lt;summary&gt; /// 자동 증가되도록 1을 더해준다. /// &lt;/summary&gt; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; return (int)value + 1; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; return value; &#125; &#125;&#125; 적용 위에서 만든 Converter를 불러와서 GridControl에 적용합니다. 123456789101112131415161718192021222324252627282930313233343536&lt;Window x:Class=\"Test.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"d\" xmlns:util=\"clr-namespace:Test.Utils\" xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\" Title=\"Test\" Height=\"600\" Width=\"560\"&gt; &lt;Window.Resources&gt; &lt;utils:IndexFromOneConverter x:Key=\"IndexFromOneConverter\"/&gt; &lt;/Window.Resources&gt; &lt;Grid Margin=\"10\"&gt; &lt;dxg:GridControl ItemsSource=\"&#123;Binding TestInfos&#125;\" SelectedItem=\"&#123;Binding SelectedTestInfo&#125;\" SelectionMode=\"Row\" ShowBorder=\"True\" RenderOptions.EdgeMode=\"Aliased\"&gt; &lt;dxg:GridControl.View&gt; &lt;dxg:TableView AutoWidth=\"True\"/&gt; &lt;/dxg:GridControl.View&gt; &lt;dxg:GridControl.Columns&gt; &lt;dxg:GridColumn Header=\"#\" Width=\"40\"&gt; &lt;dxg:GridColumn.CellTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=\"&#123;Binding RowData.RowHandle.Value, Converter=&#123;StaticResource IndexFromOneConverter&#125;&#125;\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; &lt;/DataTemplate&gt; &lt;/dxg:GridColumn.CellTemplate&gt; &lt;/dxg:GridColumn&gt; &lt;dxg:GridColumn Header=\"Note\" Width=\"100\" FieldName=\"Note\"/&gt; &lt;dxg:GridColumn Header=\"Content\" Width=\"200\" FieldName=\"Content\"/&gt; &lt;dxg:GridColumn Header=\"Area\" Width=\"200\" FieldName=\"Area\"/&gt; &lt;/dxg:GridControl.Columns&gt; &lt;/dxg:GridControl&gt; &lt;/Grid&gt;&lt;/Window&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"}]},{"title":"CE, LE 계산","slug":"satellite-ce-le","date":"2022-06-17T12:56:43.000Z","updated":"2023-06-19T12:29:20.509Z","comments":true,"path":"2022/06/17/satellite-ce-le/","link":"","permalink":"http://hgko1207.github.io/2022/06/17/satellite-ce-le/","excerpt":"","text":"관측값 즉, 지상기준점과 측정점의 차이에 대해 CE 및 LE 결과를 내기 위해 구현을 하게 되었고 참고자료를 바탕으로 정리하였습니다. 소스 코드는 CE, LE 계산 사이트에 있습니다. CE(Circular Error) X, Y 축의 값에 대한 2차원 오차를 측정합니다. 원형오차라고 부르며, CE 50, CE 90, CE 95 등의 형식으로 표현합니다. 예) CE90 5m는 오차들이 실제 값에서 5m 반경 안에 90% 있음을 나타냄. CE 90 계산 1) 관측값 평균이 0일 경우 CE_XX = R * 𝜎𝑚𝑎𝑥 2x2 공분산 행렬을 계산하고, 공분산 행렬에 대해 고유값(Eigenvalue) 계산 최소, 최대 고유값에 대해 제곱근으로 𝜎𝑚𝑖𝑛, 𝜎𝑚𝑎𝑥 값을 구함 예) MATLAB은 eig(A) 함수를 사용 r = 𝜎𝑚𝑖𝑛/𝜎𝑚𝑎𝑥, p=90/100 두 개의 값과 아래 표의 값을 통해 선형 보간하여 확률 계수 R을 구함 예) r = 0.509, p = 0.9 일 때, R = 0.041/0.05 * 1.7371 + 0.009/0.05 * 1.7621 = 1.7416 확률 계수와 𝜎𝑚𝑎𝑥를 곱함 2) 관측값 평균이 0이 아닐 경우 X, Y 축에 대해 각각 공분산 값을 구하고 2x2 공분산 행렬을 계산 i 수만큼 위의 수식으로 2x1(X, Y)의 Si 를 계산 Si 의 크기를 가장 작은 것부터 가장 큰 것 순으로 정렬(크기는 아래 수식과 같음) RExx는 xx% 가장 큰 크기, RE*xx는 다음으로 큰 크기를 지정. CE_XX 계산은 아래 수식으로 계산. LE(Linear Error) Z축(고도)에 대한 오차를 측정합니다. 지형의 수직 정확도를 측정합니다.(TIN, DEM, DSM 등) 선형오차라고 부르며, LE 50, LE 90, LE 95 등의 형식으로 표현합니다. LE 90 계산 1) 관측값 평균이 0일 경우 LE_XX = P(확률계수) * 𝜎𝑧 (표준편차) 관측값에 대한 표준편차를 구함 다음의 표에서 p=90/100(0.90) 에 대한 확률 계수인 1.6449를 구함 표준편차와 확률 계수를 곱함 LE_90 = 1.6449 * (표준편차) 2) 관측값 평균이 0이 아닐 경우 기준점과 측정점을 통해 표준편차와 평균을 구함 위의 식(누적분포함수)에서 p 값을 계산 p 값에 대해 오차 역함수(Inverse Error Function)을 구함 다음의 식을 통해 LE를 계산 참고내용 1) 분산(Variance) 관측값에 대한 분산 2) 공분산(Covariance) 관측값에 대한 공분산 3) 공분산 행렬 두 개의 확률 변수의 공분산 행렬은 각 변수 쌍에 대해 계산된 공분산 값으로 구성된 행렬 4) 표준편차(Standard Deviation) 관측값에 대한 표준편차 참고자료 Computation of scalar accuracy metrics LE, CE, and SE as both predictive and samplebased statistics (NGA) Geopositional Statistical Methods (NASA)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"}]},{"title":"DEM","slug":"satellite-dem","date":"2022-06-14T15:39:52.000Z","updated":"2022-09-02T14:49:52.097Z","comments":true,"path":"2022/06/15/satellite-dem/","link":"","permalink":"http://hgko1207.github.io/2022/06/15/satellite-dem/","excerpt":"","text":"Digital Elevation Models 수치표고모형(DEM)은 수치지형 또는 수심측량 데이터에 관한 일반적인 용어로서, 일반적으로 식생과 인공지물을 포함하지 않는 지형만의 높이를 의미하며, 강, 호수의 DEM 높이 값은 수표면을 나타냅니다. DEM은 일반적으로 **DTM(Digital Terrain Model)**과 비슷한 의미로 사용됩니다. **USGS(U.S. Geological Survey)**의 정의 : DEM은 보통 높이의 기준면으로부터 측정한 z값을 사용하여 x, y 방향으로 일정한 간격의 지형에 대한 높이 값을 수치지도 형식으로 표현한 것 입니다. 이 정의는 **NIMA(National Imagery and Mapping Agency)**에서 작성한 **DTED(Digital Terrain Elevation Data)**의 정의와 유사합니다. DEM의 기하학적 구조는 규칙격자망(Regular Grid, Elevation Matrix)과 불규칙삼각망(Triangular Irregular Network, TIN)이 있으며 각각 장단점을 가지고 있습니다. DTM(Digital Terrain Model) DEM과 유사한 뜻으로 사용되며, 동일한 간격의 z값을 가집니다. DTM은 DEM과 비슷하지만 지형을 좀 더 정확하게 묘사하기 위해 불규칙적으로 간격을 갖는 불연속성(breakline)이 존재 한다는 것이 다릅니다. DTM의 최종적인 결과는 특정 지형을 명확히 묘사하는 것이며, 등고선은 지형의 실제 형태에 가깝도록 DTM으로부터 생성하곤 합니다. DSM(Digital Surface Mode) DEM에 식생, 건물, 도로 등 자연 및 인공 지형지물의 표고 값이 포함된 것을 나타냅니다. 원거리통신관리, 산림관리, 3D 시뮬레이션 등에 이용됩니다. 규칙격자망 일정 크기 사각형 격자지점의 표고행렬로 지형기복 변화를 표현하는 방법입니다. 규칙적인 격자의 교차점에서의 고도를 저장하며, 보통 불규칙한 기준점 집합으로부터 정교한 보간 기법을 거쳐 계산됩니다. 일반적으로 격자의 크기는 기준점 사이의 거리보다 더 작으며, 불연속선이나 높이를 나타내는 점에 의해 표현된 지질학적 정보도 규칙적인 격자로 형성됩니다. 장점 고도만 저장되므로 자료의 구조가 간단함 등고선, 경사각, 경사 방향 계산, 음영이나 분지를 표현하는데 유용 행렬 처리를 적용함에 있어서 계산 시간이 빠름 단점 복잡한 지형의 표현 시 격자 간격을 좁게 해야 함 표면을 표현하기 위해 높은 밀도의 점들을 저장해야 함 규칙적인 격자에서 불연속선을 표현하는 데 따르는 문제점 불규칙삼각망(TIN) 불규칙삼각망은 원래의 자료 점들을 Delaunay 삼각망을 활용하여 불규칙한 형태의 연속적인 삼각형을 연결시켜 지형의 기복을 표현합니다. 장점 기복이 심한 지역에서 효과적으로 사용될 수 있음 자료의 중복을 줄일 수 있으므로 지형을 효과적으로 표현 최소한의 표고점을 이용하여 능선이나 곡선과 같은 지형 구조 특성을 반영한 보간을 할 수 있다는 점 단점 점 들의 불규칙한 구조로 인해 각각의 점들을 저장하려면 대상에 대한 더 많은 정보가 필요함 등고선, 능선, 합수선, 인공구조물 등을 가로질러 TIN이 구성되면 실제 지형 특성을 반영하기 못함 수치등고선으로 TIN을 구성할 때 동일 등고선 상의 꼭지점들 안으로 TIN이 구성되면 그 TIN 내부는 평지로 표현이 됨 원천 자료에 따른 DEM 구축 방법 별 특성 구분 소요 장비 경제성 정확성 현시성 지상 측량 Total Station, GPS 시간경비과다 우수 우수 종이 지도 Digitizer 수동, 시간 과다 지도에 달림 지도에 달림 Scanner GEOVEC 자동, 기술적 애로 지도에 달림 지도에 달림 수치 지도 MAP 지도 S/W 우수 지도에 달림 지도에 달림 기존 사진(사진 측량) 해석도화기 양호 우수 사진에 달림 신규 촬영(사진 측량) 수치도화기 촬영비 추가 우수 우수 원격 탐사 Image Processor 우수 개선 중 우수 레이저 측량 레이저 고도계 우수 우수 우수 DEM 추출 방법 – 수치 지도 활용 이미 제작된 수치지도를 이용하여 DEM을 구축하는 방법으로 수치지도의 등고선 및 고도점의 좌표를 추출하여 DEM을 생성합니다. DEM 생성 시 고려해야 할 사항 수치지도 제작 시기가 오래되었을 경우 현재의 지표 및 지물의 정보가 부족 인공지물 밀집 지역일 경우 고도 추출점이 표기되어 있지 않을 수 있음 따라서, 수치지도로 DEM을 작성할 때에는 항공사진 혹은 보다 대축척의 수치지도, 지상측량 등의 보조 자료를 이용하여 등고선 및 고도점을 보완해야 합니다. 등고선 데이터는 제한된 범위의 정확도를 가진 DEM을 구축합니다. 기대할 수 있는 최대의 정확도는 등고선 간격의 1/2 정보 등고선으로부터 DEM을 생성하는 것은 대부분의 상용 소프트웨어(PCI, Erdas Imagine)등에서 지원합니다. DEM 추출 방법 – 항공 사진 측량 항공사진(또는 항공영상)을 이용한 DEM 구축 방법은 현재 실용화된 방법 중 가장 정확하고 최신의 수치 고도 자료를 얻을 수 있습니다. 항공사진측량용 카메라로 촬영된 입체 항공사진을 이용하여 해석도화기와 도화사의 작업을 통해 수동으로 DEM을 추출하는 방법 항공사진을 스캐닝하거나 항공사진 측량용 디지털카메라로 획득한 항공 영상을 이용하여 수치도화기에서 자동으로 DEM을 추출하는 방법 항공사진(또는 항공영상)을 이용하면 지형은 물론이고 지물에 대한 DEM 구축이 가능합니다. DEM 추출 방법 – 위성 영상 위성영상의 해상력이 높아지고 이동한 위치에서 반복 촬영한 동일 지점의 영상을 획득할 수 있게 됨으로써 위성영상으로부터 DEM 구축이 가능해집니다. 위성영상은 항공사진에 비하여 포함면적이 넓고, 주기적으로 영상을 얻을 수 있으므로 최신의 정보를 획득하는데 소요되는 시간과 비용을 절감할 수 있습니다. 위성영상에 항공사진의 수치사진측량기법을 적용하여 자동으로 DEM을 생성할 수 있습니다. DEM의 정확도 수치표고모델의 정확도는 선형적으로 보간 된 DEM과 지도나 GPS 자료와 같은 참조자료와의 비교를 통한 RMSE(root-mean square error)값을 이용합니다. DEM의 정확도는 데이터의 스케일과 공간 해상도, 격자 간격에 영향을 많이 받습니다. DEM의 수평정확도는 표고행렬의 수평간격에 영향을 많이 받음 DEM의 수직정확도는 원시 데이터의 질과 공간 해상도, 자료의 수집과 처리과정에 많은 영향을 받음 등고선으로부터 구축된 DEM의 평가 기준(Carrara, 1997) 수치 지도의 등고선 근처에 배치된 격자점의 표고는 그 등고선의 표고와 일치하거나 큰 차이가 없어야 함 두 등고선으로 포위된 영역 내에 있는 격자점의 표고는 두 등고선 표고 사이의 표고이며, 두 등고선 사이에서 선형 변화함 경사 변화가 완만한 지역에서도 DEM은 지형을 현실적으로 묘사하여야 함 일정 규모이상의 인공 지물에 대한 정보를 DEM으로부터 추출할 수 있어야 함 DEM 자동 제작 방법","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"}]},{"title":"DPPDB","slug":"satellite-dppdb","date":"2022-06-14T12:36:15.000Z","updated":"2022-09-02T14:49:52.097Z","comments":true,"path":"2022/06/14/satellite-dppdb/","link":"","permalink":"http://hgko1207.github.io/2022/06/14/satellite-dppdb/","excerpt":"","text":"Digital Point Positioning Database 네이버 백과사전 정밀영상위치제공 지형정보로서 미(美) 국가영상지도국(NIMA)이 1970년대 베트남전 중 미 공군의 B-52와 F-111에서 정밀항법 유도무기를 사용하기 위해 개발했다가 1995년 IT 발달에 따라 디지털로 전환시켰습니다. 3차원 지형데이터에 각종 건물 등 지상 구조물 데이터를 통합해 매우 정밀한 위치정보를 제공합니다. 이 데이터와 미군용 GPS를 결합하면 수십km 밖에서도 미사일 등 유도 무기를 1m의 오차로 공격할 수 있습니다. DPPDB는 스테레오 이미지 쌍 및 관련 보조 데이터의 모음으로, 이미지에서 식별할 수 있는 모든 점 또는 특징에 대한 정확한 위치 데이터를 신속하게 확인할 수 있는 기능을 제공합니다. 이 데이터는 스테레오 이미지를 분할, 방사 보정, 합리적인 다항식 구성 및 압축 등의 추가 처리를 함으로써 얻을 수 있습니다. 일반적으로 1도 면적(60 x 60 NM)을 커버하며 NITF 파일로 제공됩니다. 참고로 DPPDB는 NITF(National Imagery Transmission Format ) 2.0 사양의 제품입니다. DPPDB 제품은 세 가지 주요 구성 요소로 구성된 디지털 제품입니다. 1. imagery support data : Master Product File(MPF) 2. a map graphic for reference(참고 용 지도) : CADRG 프레임 파일 3. stereo imagery(입체 영상) : 전체 해상도 및 Overview 이미지 파일 NITF 란 National Imagery Transmission Format Standard (국가 영상정보 전송 포맷 표준) NITF는 공중에서 영상을 획득하는 플랫폼들로부터 얻어진 원본 영상을 기반으로 영상, 서브-영상(sub-images), 그래픽, 심볼, 텍스트 뿐 아니라 영상과 관련된 정보를 담을 수 있는 하나의 패키지(package)로서 2차 디지털 영상(secondary digital imagery)의 배포 또는 유통을 지원하기 위한 포맷입니다. 따라서 단순히 영상 자체만을 저장하는 일반 영상 포맷과 차별화됩니다. NITF에 대한 개발은 1987년 미국 정부에 의하여 시작되었으며, 1991년 미국 국방부(DoD) 내에서 영상 파일에 대한 표준인 MIL-STD-2500B로 지정되었으며, 현재 MIL-STD-2500C로 발전되었습니다. NITF는 영상유통포맷의 최초 개발로 1989년 NITF 1.1 발표 이후, 1991년 국방부 표준으로 지정되면서 이름을 NITFS(National Imagery Transmission Format Standard)로 개명하게 되었습니다. DPPDB 구조 DPPDB 제품 파일은 아래 그림과 같이 순차적으로 배열됩니다. 첫 번째 파일은 MPF(Master Product File)이며 DPPDB 및 참조 그래픽에 대한 정보를 제공하는 수많은 서브 헤더 파일이 있습니다. MPF 다음에는 참조 그래픽 프레임을 구성하는 파일이 있습니다. DPPDB에 포함 된 나머지 파일은 이미지 파일입니다. 1) MPF (Master Product File) 정확도, 세그먼트간 이격점 데이터, 진단점, 불량 지역 정보, 풋 프린트 및 이미지 파일과 참조 그래픽에 대한 정보와 같은 보조 데이터를 포함하고 있습니다. 그림은 기본 구성 요소만 보여주는 MPF의 파일 구조입니다. 2) Reference Graphic files MPF 다음으로 구성된 그래픽 파일은 사용자가 지정한 영역에 대한 디지털 맵을 제공합니다. 다양한 벡터 오버레이를 표시하고 대상의 대략적인 위치를 식별하기 위해 사용됩니다. DPPDB 제품의 사각형보다 약간 큰 영역을 포함하는 8 비트 컬러 래스터 이미지입니다. 그래픽의 소스는 CADRG(Compressed ARC Digitized Raster Graphics) 데이터입니다. 3) Image Files 이미지 파일은 전체 해상도 및 overview(전체 해상도 이미지의 1/8x 또는 1/4x 축소 된 이미지) 세그먼트 이미지 세트로 구성되어 있습니다. 각 전체 해상도 및 overview 이미지 파일에는 해당 이미지에 대한 정보 및 함수 계수도 포함되어 있습니다. 이미지 파일은 4 개의 그룹 (왼쪽과 오른쪽의 전체 해상도 및 overview 이미지)으로 구성되며 각 그룹은 단일 DPPDB 모델에 포함됩니다. 아래 그림은 전체 해상도 및 overview 이미지 세그먼트의 파일 구조를 보여줍니다. DPPDB 생성 NITF 영상 및 위치결정자료 생성 절차를 설명합니다. 세그먼트 분할 입체시 영상에 대한 세그먼트 이미지를 분할합니다. 불량지역 생성 불량지역 생성 기능을 통해 영상에서 유효하지 않는 영역을 식별 또는 추가합니다. 불량지역은 구름으로 관측이 어려운 지역이나, 바다, 호수와 같이 수계지역을 의미합니다. 정확도 평가 각 세그먼트간 측정오차, 절대정확도, 상대정확도를 계산합니다. 세그먼트간 이격점 생성 각 세그먼트 간 중복지역에서 특징점을 추출하고, 매칭을 통해 자동으로 점을 생성합니다. 참고문헌 미국 군사규격서 MIL-PRF-89034 : Digital Point Positioning Data Base(DPPDB) MIL-STD-2500A: National Imagery Transmission Format(NITF) for NITFS MIL-STD-2301A : Computer Graphics Metafile(CGM) Implementation Standard for the National Imagery Transmission Format Standard(NITFS) MIL-PRF-89038 : Compressed ARC Digitized Raster Graphics(CARRG) MIL-PRF-89041: Controlled Image Base(CIB) NITF NITFS : https://terms.naver.com/entry.nhn?docId=3480012&amp;cid=58439&amp;categoryId=58439 NITF/NSIF Background : https://www.harrisgeospatial.com/docs/BackgroundNITFNSIFFormat.html#Main","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"}]},{"title":"CSM","slug":"satellite-csm","date":"2022-06-13T11:01:13.000Z","updated":"2023-06-05T00:52:29.781Z","comments":true,"path":"2022/06/13/satellite-csm/","link":"","permalink":"http://hgko1207.github.io/2022/06/13/satellite-csm/","excerpt":"","text":"Community Sensor Model(CSM) NGA(국가지리정보국, National Geospatial Intelligence Agency)에서는 센서 모델을 동일한 방법으로 접근할 필요성에 따라 CSM(Community Sensor Model)을 개발하여 통일된 인터페이스를 제공합니다. CSM은 현재 운용되고 있거나 추후 운용이 예상되는 위성 센서의 모델, 알고리즘, 소프트웨어에 대한 개발, 시험, 평가를 지원하는 플러그인 소프트웨어 라이브러리입니다. CSM은 WGS84 타원체의 ECEF(Earth Centered Earth Fixed) 좌표계를 사용하고 있습니다. 따라서 모든 함수에서 지상 좌표의 입력과 출력 값은 ECEF 좌표로 구성해야 합니다. CSM 사용 소프트웨어 ENVI, ERDAS, SOCET GXP 등 CSM 장단점 장점 센서모델링을 수행하기 위한 소프트웨어 개발 시 모델링에 사용되는 행렬과 반복 알고리즘만 구현하면 되므로 소프트웨어의 개발비용 절감효과가 큽니다. 새로운 센서나 모델들이 개발되면, 센서모델에 대한 플러그인만 개발하여 배포하고 응용 소프트웨어에서 호출하여 모델링을 수행하므로 센서모델의 확장성이 뛰어납니다. 단점 ECEF 좌표계 사용을 위해 경우에 따라 중복된 좌표 변환 작업을 수행하게 되어 효율성이 다소 저하됩니다. CSM Context Diagram CSM API CSM은 CSMPlugin 클래스와 CSMSensorModel 클래스로 구분됩니다. CSMPlugin 클래스 플러그인 제조사, 배포 일자와 같은 기본적인 정보를 제공합니다. 센서 모델 선택, Image Support Data(ISD) 처리, 센서 모델 생성과 같은 기능을 하는 함수들로 구성됩니다. SMSensorModel 클래스 영상좌표에서 지상좌표의 상호간 변환, 편미분, 공분산, 파라미터 설정 등 사진 측량에 필요한 함수들로 구성됩니다. Sensor Model Download Github Page - Community Sensor Model API Build 다운로드가 완료되면 압축을 풀어줍니다. 빌드에 필요한 CMake를 설치합니다. 설치가 완료되면 CMake gui를 실행합니다. 빌드를 하기 전 CSM 폴더 안에 build 폴더를 생성합니다. CMake gui에서 Source 및 Build(생성한 build 폴더 경로) 경로를 입력하고 Configure 버튼을 클릭합니다. 오류 없이 설정이 완료되면 Generate 버튼을 클릭합니다. CMake Build가 완료되면 다음과 같이 프로젝트가 생성됩니다. 프로젝트를 실행하여 빌드를 실행하면 csmapi.dll, csmapi.lib 파일이 생성됩니다. CSM 은 공통 인터페이스를 제공하기 때문에 csmapi.dll, csmapi.lib, 헤더 파일을 참조 및 로드하여 위성에 대한 센서 모델을 구현합니다. 기본적으로 Plugin, RasterGM을 상속받아 구현합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"}]},{"title":"개발 시 도움이 될 도구들","slug":"util-2","date":"2022-06-11T13:31:16.000Z","updated":"2022-09-02T14:49:52.097Z","comments":true,"path":"2022/06/11/util-2/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/util-2/","excerpt":"","text":"1. 댓글 게시판, 커뮤니티, 블로고 등 컨텐츠 위주의 서비스면 댓글은 필수입니다. 댓글 기능이 메인은 아니지만 필요한 기능 중 하나이며, 구현하기에는 시간도 많이 듭니다. 그래서 다음 서비스들로 대체해서 사용합니다. Disqus Disqus(https://disqus.com/)는 소셜 댓글 서비스입니다. 자바스크립트 코드만 사이트에 등록하면 위젯 형태로 서비스에서 바로 사용이 가능한 댓글 전문 서비스입니다. LiveRe LiveRe(https://www.livere.com/)는 국내에서 만든 소셜 댓글 서비스입니다. 별도의 가입이 필요하지 않고, SNS(카카오톡, 네이버, 페이스북 등) 계정이 있으면 언제든 댓글을 남길 수 있는 편의성이 있습니다. Utterances Utterances(https://rtterances.es/)는 깃허브 댓글입니다. 깃허브의 이슈 기능을 이용했기 때문에 무료로 사용 가능합니다. 깃허브의 마크다운 에디터를 그래도 사용하고 있어 댓글을 마크다운으로 작성할 수 있다는 장점이 있습니다. 2. 외부 서비스 연동 SNS 연동 서비스들입니다. Zapier Zapier(https://zapier.com/)는 수많은 클라우드와 SNS 서비스들의 오픈 API를 이용하여 서로 간의 연동을 지원하는 서비스입니다. IFTTT IFTTT(https://ifttt.com/)는 IF This Then That의 약자로, 만약 A를 하면 B를 하라는 의미로 클라우드와 SNS 연동을 지원하는 서비스입니다. 3. 방문자 분석 사이트 운영에 필요한 여러 정보들을 분석하는 기능을 무료로 지원하는 도구들입니다. 구글 애널리틱스 구글 애널리틱스는 구글에서 지원하는 사이트 분석 도구입니다. 국내에도 많은 자료가 공유되어 있어 사용하기 편하고 다른 구글 서비스들과의 연동도 잘 되어 있습니다. 4. CDN CDN은 Content Delivery Network의 약자로 전 세계에 분산되어 있는 서버 네트워크입니다. 정적 콘텐츠라고 불리는 JS, CSS, 이미지 등을 전 세계에 퍼진 서버에 전달하여 사용자가 서비스에 접속할 때 가장 가까운 서버에서 가져가도록 지원하는 서비스입니다. CDN의 목적은 트래픽 분산을 위함입니다. 클라우드플레어 클라우드플레어(https://www.cloudflare.com/)는 해외뿐만 아니라 국내에서도 가장 많이 사용되는 CDN 서비스입니다. 정적 파일들을 캐싱하여 제공하는 CDN의 기능은 무료로 사용할 수 있습니다. 5. 이메일 마케팅 뉴스레터와 같은 이메일 마케팅 기능을 지원하는 서비스입니다. Mailchimp Mailchimp(https://mailchimp.com/)는 해외에서 서비스 중인 이메일 마케팅 서비스입니다. 회원 2000명에게 월 12000개의 메일을 무료로 보낼 수 있어 초기에 사용하기 좋습니다. 반응형을 고려한 뉴스레터나 구독자 관리, 통계 등의 기능을 지원합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"}]},{"title":"지리공간자료 정확도","slug":"satellite-accuracy","date":"2022-06-11T13:29:25.000Z","updated":"2022-09-02T14:49:52.096Z","comments":true,"path":"2022/06/11/satellite-accuracy/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/satellite-accuracy/","excerpt":"","text":"지리공간자료 정확도의 형태 Spatial (position, geometry, topology) Attributional (correctness of attributes) Spectral (band depth) Temporal (appropriate date) Radiometric (capture piece of electromagnetic spectrum) 지리공간자료 기하보정된 위성영상 정사영상(Orthoimagery) DTM(Digital Terrain Model) DEM(Digital Elevation Model) DSM(Digital Surface Model) TIN(Triangulated Irregular Network) 정확도(Accuracy) 과학, 산업, 공업, 통계학 분야에서 재거나 계산된 양이 실제 값과 얼만큼 가까운지를 나타내는 기준이며, 관측의 정교성이나 균질성과는 무관합니다. 측정에 의해 얻은 최고 추정 값과 측정 된 수량의 &quot;참&quot;값에 대한 근접성입니다. 위치 정확도(Position Accuracy) 두 지리 공간 레이어 사이 또는 지리 공간 레이어와 현실 사이의 위치 차이를 나타내는 정량화 가능한 값 입니다. Root Mean Square Error(RMSE) 평균 제곱근 편차(Root Mean Square Deviation; RMSD) 또는 평균 제곱근 오차(Root Mean Square Error; RMSE)는 추정 값 또는 모델이 예측한 값과 실제 환경에서 관찰되는 값의 차이를 다룰 때 흔히 사용하는 측도이다. 정밀도를 표현하는데 적합합니다. 각각의 차이 값은 잔차(residual)라고도 하며, 평균 제곱근 편차는 잔차들을 하나의 측도로 종합할 때 사용됩니다. 잔차 값 간의 분산을 통계적으로 측정 한 것 입니다. Standard Deviation(StDev) : 표준 편차 자료의 산포도를 나타내는 수치로, 분산의 양의 제곱근으로 정의됩다. Circular Error(CE) : 원형 오차 CE는 X, Y 모두에 대한 2차원 오차를 측정합니다. CE90, CE95, CE99 형식으로 표현합니다. 원형 분포에서 모든 오차가 n%를 초과하지 않는 반경 오차 예) CE 90 = 2미터인 경우 : 오차들이 반지름 2미터인 원 안에 있을 확률이 90%라는 것을 나타낸다. Linear Error(LE) : 선형 오차 Z축(고도)에 대한 오차 측정을 합니다. 측정된 값과 실제 또는 알려진 값과의 차이를 계산합니다. 지형의 수직 정확도 측정(예: DEM 또는 TIN) LE90, LE95, LE99 형식으로 표현합니다. 예) LE 95 = 10m인 경우: 오차들이 10 미터 내에 있을 확률이 90%라는 것을 나타낸다. Circular Error Probable(CEP) Circular Error Probability 또는 Circular Error Probable, 원형 공산 오차 라고 하며 탄도학 에서 무장의 정밀도를 측정하는 단위. CEP는 폭탄 등이 투하되었을 경우, 그 중의 반수가 명중하는 원의 반경을 가리킵니다. 즉 10발 공격했을 때 5발이 들어가는 원을 그렸을 때 그 반경이 5m이라고 하면 CEP는 5m라고 합니다. 2차원의 수평방향 성분에 대해 50%의 원형 확률 오차(CEP)의 수치는 원의 반경과 같으며, 측점들의 각각의 계산 값에 포함되는 잔차들 중 50%는 이 원안에 들어오고 나머지는 원 밖에 존재합니다. 항해시의 위치정밀도 측정치로, 실제 수평자표에서 오차 타원에서 그 반경을 나타냅니다. 이 값은 현재 위치가 실제 위치에 있을 확률이 50%임을 나타냅니다. 실제위치를 중심으로 한 위치추정값의 50%를 함유하는 원의 반경 수치입니다. CE50 형식과 같습니다. 참고자료 GPS 기초 GCP 용어정리 Introduction to GPS","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"}]},{"title":"[CentOS] nohup 사용 방법","slug":"linux-17","date":"2022-05-29T13:11:12.000Z","updated":"2023-05-30T14:18:28.612Z","comments":true,"path":"2022/05/29/linux-17/","link":"","permalink":"http://hgko1207.github.io/2022/05/29/linux-17/","excerpt":"","text":"리눅스 환경에서 nohup 사용 방법에 대해 알아보겠습니다. nohup nohup 은 No Hang Ups의 약자로 백그라운드로 지속적으로 실행하는 프로세스를 의미합니다. nohup 은 실행을 현재 사용자 세션이 아닌 운영체제가 제공하는 백그라운드 공간에서 실행을 한다. &amp; 는 사용자 세션에서 실행되며, 화면 출력만 백그라운드로 전환한 상태입니다. 즉 &amp; 로 실행된 프로세스는 사용자 세션이 로그아웃되는 시점에 같이 종료되어지는 것입니다. 애플리케이션 실행할 때 터미널을 종료해도 애플리케이션은 계속 구동될 수 있도록 nohup 명령어를 사용합니다. 실행 기본 실행 nohup 명령어를 사용하여 실행합니다. nohup 으로 실행시킬 파일은 반드시 755 퍼미션을 가지고 있어야 합니다. 1$ nohup [실행파일명] 예시입니다. 1$ nohup ./run.sh 실행을 하면 “nohup: ignoring input and appending output to ‘nohup.out’” 메세지와 함께 해당 프로그램의 nohup 을 실행시킨 경로에 nohup.out 파일이 생성되고 표준출력 내용이 출력됩니다. 백그라운드 실행 &amp; 명령어를 맨 끝에 불여서 사용하면 백그라운드로 실행됩니다. 1$ nohup [실행파일명] &amp; 예시입니다. 1$ nohup ./run.sh &amp; 파일 저장 표준출력과 표준에러 같은 파일 저장 2&gt;&amp;1을 추가하면 표준 출력(1)과 표준 에러(2)를 한 파일에 저장됩니다. 1$ nohup [실행파일명] 2&gt;&amp;1 예시입니다. 1$ nohup ./run.sh 2&gt;&amp;1 표준출력과 표준에러 다른 파일 저장 표준 출력(1)은 run_output.out 파일로 저장하고, 표준 에러(2)는 run_output.err 파일로 저장됩니다. 1$ nohup ./run.sh 1 &gt; run_output.out 2 &gt; run_output.err 표준출력 다른 위치에 저장 표준 출력을 nohup.out 이 아닌 다른 이름의 파일이나 다른 위치에 저장하려면 다음 명령어를 사용합니다. 1$ nohup [실행파일명] &gt; [파일위치] 예시입니다. 1$ nohup ./run.sh &gt; /data/run_output.out 표준출력 남지기 않도록 표준 출력을 별도로 남기고 싶지 않다면 /dev/null 를 추가합니다. 1$ nohup [실행파일명] &gt; /dev/null 예시입니다. 1$ nohup ./run.sh &gt; /dev/null 실행 프로세스 확인 백그라운드 실행의 경우 다음 명령어를 통해 실행중인 프로세스 상태를 확인할 수 있습니다. 1$ ps -ef | grep run.sh 프로세스 종료 백그라운드로 실행 중인 프로세스를 종료하는 방법입니다. 먼저 프로세스 아이디를 찾고 종료를 합니다. 1$ ps -ef | grep run.sh 프로세스 아이디를 입력하여 종료합니다. 1$ kill -9 [프로세스 아이디] 여기까지 nohup 사용법에 대해 알아보았습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"}]},{"title":"[CentOS] Hostname 변경","slug":"linux-16","date":"2022-05-28T01:32:02.000Z","updated":"2023-05-30T14:18:17.513Z","comments":true,"path":"2022/05/28/linux-16/","link":"","permalink":"http://hgko1207.github.io/2022/05/28/linux-16/","excerpt":"","text":"HOSTNAME 등록 각 서버가 어느 서비스 인지 표현하기 위해 HOSTNAME을 변경합니다. 다음 명령어로 편집 파일을 엽니다. 1$ sudo vim /etc/sysconfig/network 편집 화면에서 HOSTNAME 항목을 본인이 원하는 서비스명으로 추가합니다. 123NETWORKING=yesHOSTNAME=hgko-webserviceNOZEROCONF=yes 변경 한 후 서버를 재부팅 합니다. 1$ sudo reboot 재부팅이 끝나고 나서 ssh 명령어를 사용하여 다시 접속해보면 HOSTNAME이 잘 변경됬는지 확인할 수 있습니다. 1$ ssh hgko-webservice 다른 HOSTNAME 등록 리눅스 버전에 따라 명령어가 다르기 때문에 위의 내용으로 등록이 안될 시 다음 명령어를 통해 HOSTNAME을 등록합니다. 1$ sudo hostnamectl set-hostname [변경할 호스트명] 1234567$ sudo hostnamectl set-hostname hgko-webservice# 확인hostname# 결과 출력hgko-webservice hosts 추가 호스트 주소를 찾을 때 먼저 검색해 보는 /etc/hosts 에 추가한 hostname을 등록합니다. 다음 명령어로 /etc/hosts 파일을 엽니다. 1$ sudo vim /etc/hosts 편집 화면에서 등록한 HOSTNAME을 추가합니다. 1127.0.0.1 hgko-webservice 저장하고 종료한 뒤 정상적으로 등록되었는지 다음 명령어로 확인합니다. 1$ curl hgko-webservice 잘 등록하였다면 다음과 같이 80 포트로 접근이 안 된다는 에러가 발생합니다. 1curl: (7) Failed to connect to hgko-webservice port 80 after 0 ms: Connection refused 아직 80 포트로 실행된 서비스가 없음을 의미입니다. curl 호스트 이름 명령어로 실행이 잘 되었음을 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"}]},{"title":"[CentOS] 타임존 변경","slug":"linux-15","date":"2022-05-26T23:14:00.000Z","updated":"2023-03-14T02:23:17.493Z","comments":true,"path":"2022/05/27/linux-15/","link":"","permalink":"http://hgko1207.github.io/2022/05/27/linux-15/","excerpt":"","text":"타임존 변경 리눅스 서버 타임존이 UTC인 경우가 있습니다. 이는 세계 표준 시간으로 한국의 시간대가 아닙니다. 한국의 시간과는 9시간 차이가 발생하므로 서버에서 수행되는 애플리케이션에서 생성되는 시간도 모두 9시간씩 차이가 나기 떄문에 수정이 필요합니다. 서버의 타임존을 한국 시간(KST)로 변경하겠습니다. 12$ sudo rm /etc/localtime$ sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime 타임존 확인 date 명령어로 타임존이 KST로 변경된 것을 확인 할 수 있습니다. 1$ date 결과입니다. 1Fri May 27 08:18:19 KST 2022","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"}]},{"title":"[CentOS] Java 8 설치 및 환경변수 설정 방법","slug":"linux-14","date":"2022-05-26T13:06:50.000Z","updated":"2023-06-12T13:57:35.053Z","comments":true,"path":"2022/05/26/linux-14/","link":"","permalink":"http://hgko1207.github.io/2022/05/26/linux-14/","excerpt":"","text":"리눅스 환경에서 Java 8 버전 설치 및 환경변수 설정 방법에 대해 알아보겠습니다. JAVA 설치 yum 을 이용해서 설치를 합니다. 1[root@localhost ~]# sudo yum install -y java-1.8.0-openjdk-devel.x86_64 버전 변경 설치가 완료되었으면 Java 버전을 8로 변경합니다. 다음 명령어를 실행하면 선택 화면이 나옵니다. 선택 화면에서 Java8을 선택합니다(1 입력). 1[root@localhost ~]# sudo /usr/sbin/alternatives --config java 확인 현재 버전이 Java8 로 되었는지 확인합니다. 12[root@localhost ~]# java -versionopenjdk version \"1.8.0_312\" 12[root@localhost ~]# rpm -qa java*jdk-develjava-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 제거 만약 사용하지 않는 Java 가 설치되었으면 삭제를 합니다. 1[root@localhost ~]# sudo yum remove java-1.7.0-openjdk 환경변수 설정 환경변수 확인 일단 현재 JAVA_HOME 환경변수가 설정 되어 있는지 확인합니다. 123[root@localhost ~]# echo $JAVA_HOME[root@localhost ~]# JAVA_HOME 환경변수가 설정이 안되어 있는 것을 확인했습니다. 설치위치 확인 1234[root@localhost ~]# which javac/usr/bin/javac[root@localhost ~]# readlink -f /usr/bin/javac/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64/bin/javac which javac 명령어는 javac 명령어의 위치를 알려줍니다. /usr/bin/javac 는 심볼릭 링크이므로 원본 파일의 위치를 찾기 위해 readlink -f /usr/bin/javac 명령어를 사용하였습니다. readlink -f 는 심볼릭 링크에서 원본파일을 추출하는 명령어입니다. 설정 환경변수를 설정할 수 있는 profile 파일을 엽니다. 1[root@localhost ~]# vi /etc/profile 해당 파일 하단에 다음의 내용을 추가한 후 저장합니다. 1export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 다음 명령어를 이용하여 수정한 파일을 적용합니다. 1[root@localhost ~]# source /etc/profile 설정 확인 JAVA_HOME 환경변수가 제대로 설정되었는지 확인합니다. 1234[root@localhost ~]# echo $JAVA_HOME/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64[root@localhost ~]# $JAVA_HOME/bin/javac -versionjavac 1.8.0_312","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[MyBatis] 동적 쿼리","slug":"mybatis-2","date":"2021-09-17T12:49:15.000Z","updated":"2023-05-18T02:35:48.846Z","comments":true,"path":"2021/09/17/mybatis-2/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-2/","excerpt":"","text":"검색 조건에 따라 비교하면서 동적 쿼리를 사용하는 방법에 대해 알아보겠습니다. MyBatis 와 데이터베이스는 Oracle 을 사용하였습니다. 조건문 조건문에는 단일(if), 다중(choose, when, otherwise) 조건문이 있습니다. 1. 단일 조건문 123456789&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 LIKE %'||#&#123;parameter2&#125;||'%' &lt;/if&gt;&lt;/select&gt; 2. 다중 조건문 1234567891011121314&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;choose&gt; &lt;when test=\"parameter2 != null and parameter2 == ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/when&gt; &lt;otherwise&gt; AND column3 = #&#123;parameter3&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 비교 형식 123456789&lt;!-- 문자열 비교 --&gt;&lt;if test=\"parameter != null and (parameter eq 'all'.toString())\"&gt;&lt;/if&gt;&lt;if test=\"!parameter.equals('all')\"&gt;&lt;/if&gt;&lt;!-- 공백 비교 --&gt;&lt;if test=\"parameter == ' '\"&gt;&lt;/if&gt;&lt;!-- 값 비교 --&gt;&lt;if test=\"uesYn == 'Y'\"&gt;&lt;/if&gt; for 문 foreach 를 사용하여 조건을 만들 수 있습니다. 12345678&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; column1 IN $&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; where 절 123456789101112&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"parameter1 != null and parameter1 != ''\"&gt; AND column1 = #&#123;parameter1&#125; &lt;/if&gt; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"}]},{"title":"[MyBatis] 페이징 처리","slug":"mybatis-1","date":"2021-09-17T12:44:53.000Z","updated":"2023-03-14T02:23:10.133Z","comments":true,"path":"2021/09/17/mybatis-1/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-1/","excerpt":"","text":"웹 개발 시 페이징 처리는 필수입니다. MyBatis 를 사용하여 페이징 처리하는 방법에 대해 알아보겠습니다. 데이터베이스는 Oracle 을 사용하였습니다. 1. 기본 페이징 공지사항 조회 시 페이징을 예제로 만들었습니다. Class 생성 공지사항 관련 Class 와 페이징을 위한 Class 를 생성하였습니다. 12345678910111213141516171819// Notice.java@Datapublic class Notice &#123; /** 작성사용자ID */ private String userId; /** 작성사용자명 */ private String userName; /** 제목 */ private String title; /** 내용 */ private String content; /** 조회수 */ private int hit;&#125; 12345678910// Pagination.java@Datapublic class Pagination &#123; /** 페이지 번호 */ private int pageNo; /** 한 페이지당 데이터 수 */ private int amount;&#125; Mapper 생성 123456// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination);&#125; 쿼리 작성 CDATA 태크는 XML 에서 부등호를 사용하기 위함입니다. 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.hgko.test.repository.NoticeMapper\"&gt; &lt;select id=\"getListWithPaging\" resultType=\"Notice\" parameterType=\"Pagination\"&gt; &lt;![CDATA[ SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM TB_NOTICE WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ) WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt; &lt;/select&gt;&lt;/mapper&gt; 테스트 123456789101112131415161718@RunWith(SpringRunner.class)@MybatisTestpublic class NoticeMapperTest &#123; @Autowired private NoticeMapper noticeMapper; @Test public void getListTest() &#123; Pagination pagination = new Pagination(); pagination.setPageNo(1); pagination.SetAmount(10); List&lt;Notice&gt; notices = noticeMapper.getListWithPaging(pagination); System.out.println(notices); &#125;&#125; 2. 조회 조건 추가 위의 기본 페이징 형식에서 조회 조건을 추가하였습니다. 조회 조건 Class 생성 조회 조건 Class 를 생성하고, Pagination Class 를 상속받았습니다. 12345678910// SearchParam.java@Datapublic class SearchParam extends Pagination &#123; /** 작성사용자명 */ private String userName; /** 제목 */ private String title;&#125; Mapper 수정 Mapper Class 에 조회 조건으로 조회하는 함수를 추가하였습니다. 123456789// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination); /** 조회조건을 통해 조회 */ public List&lt;Notice&gt; getListWithCondition(SearchParam searchParam);&#125; 조회 쿼리 추가 123456789101112131415161718192021222324252627&lt;!-- NoticeMapper.xml --&gt;&lt;select id=\"getListWithCondition\" resultType=\"Notice\" parameterType=\"SearchParam\"&gt; SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM ( SELECT * FROM TB_NOTICE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"userName != null and userName != ''\"&gt; AND USER_NAME LIKE %'||#&#123;userName&#125;||'%' &lt;/if&gt; &lt;if test=\"title != null and title != ''\"&gt; AND TITLE LIKE %'||#&#123;title&#125;||'%' &lt;/if&gt; &lt;/trim&gt; ) &lt;![CDATA[ WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ]]&gt; ) &lt;![CDATA[ WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt;&lt;/select&gt; MyBatis 와 Oracle DB 를 이용하여 페이징 처리를 해봤습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"}]},{"title":"[Vue] 설치와 세팅","slug":"vue-1","date":"2021-08-22T09:46:02.000Z","updated":"2023-05-30T14:05:45.695Z","comments":true,"path":"2021/08/22/vue-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/22/vue-1/","excerpt":"","text":"Vue 쓰는 이유 Web app(Single Page Application) 만들 때 사용합니다. 코드 작성할 때 방법이 정해져 있습니다. React 는 방법이 다양한 방면 Vue 는 v-for, v-if, v-else 등 방법이 하나로 정해져 있어 개발 초보에게도 쉽습니다. 물론 Vue 도 React 처럼 자유도 높은 개발도 가능합니다. HTML 렌더링이 React 보다 빠르다고 합니다.(크게 영향을 주지 않음) 업데이트가 잘 됩니다. 결론은 React 보다 학습 곡선이 낮아 쉽고, 가볍고 빠르며, 누구나 빨리 배울 수 있어 접근성이 뛰어나 많이 쓰이고 있습니다. 설치하기 1. Nodejs 설치 Node.js 공식 다운로드 페이지 에서 운영체제에 맞게 다운로드 하고 설치합니다. 현재 최신 버전은 14.17.5 입니다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인합니다. 12$ node -vv14.17.5 2. 에디터 설치 VS Code 공식 다운로드 페이지 에서 운영체제에 맞는 버전을 설치합니다. 여기서는 Windows 버전을 설치합니다. 이 에디터는 macOS, Window, 리눅스를 모두 지원합니다. VS Code 설치가 완료되었으면 Vue 개발을 효율적으로 하기 위해 Extension 을 설치합니다. Vetur html css support Vue 3 Snippets Vue-cli 설치 Vue 개발환경 세팅을 도와주는 프로그램을 설치합니다. 명령어를 실행하고 vue 버전 선택을 하면 설치가 완료됩니다. 1$ npm install -g @vue/cli 프로젝트 생성 프로젝트를 생성할 때는 vue create &lt;프로젝트명&gt; 명령어를 사용합니다. 1$ vue create exapmle-vue 실행 터미널에 npm run serve 명령어를 실행합니다. 실행하여 완료했다면 http://localhost:8080/ 로 접속하여 웹 페이지를 확인합니다. 12$ cd example-vue$ npm run serve 정리 Vue 에 대한 설명부터 설치, 프로젝트 실행까지 진행했습니다. 프로젝트를 진행하면서 중요한 부분을 정리 할 예정입니다. 참고 https://kr.vuejs.org/v2/guide/index.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"}]},{"title":"[CentOS] 압축 및 해제","slug":"linux-13","date":"2021-08-20T05:17:29.000Z","updated":"2023-03-14T02:23:04.084Z","comments":true,"path":"2021/08/20/linux-13/","link":"","permalink":"http://hgko1207.github.io/2021/08/20/linux-13/","excerpt":"","text":"압축 tar 파일 압축 123tar -cvf [파일명.tar] [압축할 파일 또는 폴더명]예) tar -cvf test.tar test/ tar.gz 파일 압축 123tar -zcvf [파일명.tar.gz] [압축할 파일 또는 폴더명]예) tar -zcvf test.tar.gz test/ 압축 해제 zip 파일 압축풀기 1234unzip [파일명]unzip [파일명] -d [폴더경로]예) unzip test.zip tar 파일 압축 풀기 123tar -xvf [파일명.tar]예) tar -xvf test.tar tar.gz 파일 압축 풀기 123tar -zxvf [파일명.tar.gz]예) tar -zxvf test.tar.gz tar 압축 옵션 옵션 설명 -c tar로 묶기 -v 묶거나 파일을 풀 때 과정을 화면으로 출력 -f 파일을 묶도록 지정 (반드시 추가되어야 함) -x tar를 풀기 -z gzip(gz)으로 압축 또는 해제 -p 심볼릭 링크 설정 -C 경로를 지정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"}]},{"title":"[Go] 설치 및 기본 사용 방법","slug":"go-1","date":"2021-08-19T00:38:09.000Z","updated":"2023-06-05T00:51:59.028Z","comments":true,"path":"2021/08/19/go-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/19/go-1/","excerpt":"","text":"서론 노마드 코더 에서 무료인 쉽고 빠른 Go 시작하기 강의 내용을 코딩하며 정리하였습니다. 시작 https://go.dev/ 페이지에서 Go 를 다운로드 합니다. 다운로드 완료 시 설치파일을 실행하여 설치합니다. 그리고 폴더를 다음과 같이 생성합니다. mkdir github.com/hgko1207 cd github.com/hgko1207 mkdir learngo cd learngo go mod init github.com/hgko1207/learngo 코딩 main.go 는 컴파일을 위한 파일 export 함수를 만들 경우 함수명 맨 앞에 대문자로 작성 function -&gt; func null -&gt; nil 상수와 변수 12// Constantsconst name string = \"eden\" 12345678// Variablesfunc main() &#123; var name string = \"eden\" // 변수를 아래와 같이 축약형으로 사용 가능 // 축약형은 함수 안에서만 동작 name := \"eden\"&#125; For 문 1234people := [2]string&#123;\"eden\", \"haeun\"&#125;for _, person := range people &#123; fmt.Println(person);&#125; 함수 1234567891011121314// naked returnfunc lenAndUpper(name string) (length int, uppercase string) &#123; // 'derfer' function이 끝난 후에 실행되는 코드 defer fmt.Println(\"I'm done\") length = len(name) uppercase = strings.ToUpper(name) return&#125;// Go가 내부적으로 호출하는 method를 사용하는 방법func (a Account) String() string &#123; return fmt.Sprint(a.Owner(), \"'s account.\\nHas: \", a.Balance())&#125; 배열 선언 123func main() &#123; data := [2]string&#123;\"test1\", \"test2\"&#125;&#125; Map 사용 12345678// empty map을 초기화하고 싶을때// map 끝에 중괄호(&#123;&#125;)를 작성하여 초기화 해야 함var results = map[string]string&#123;&#125;// 또는 make 사용var results = make(map[string]string)results[\"hello\"] = \"Hello\" Goroutines Goroutines 이란 기본적으로 다른 함수와 동시에 실행시키는 함수입니다. Goroutines 는 프로그램이 작동하는 동안(메인함수가 실행하는 동안)만 유효합니다. 123456789101112131415161718// 함수 앞에 go를 붙입니다.func main() &#123; go count() count()&#125;func count() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) time.Sleep(time.Second) &#125;&#125;// 이 경우는 main함수가 바로 종료되기 때문에 동작하지 않습니다.func main() &#123; go count() go count()&#125; Channels Channel 은 Goroutines 이랑 메인함수 사이에 정보를 전달하기 위한 방법입니다. 채널로부터 뭔가를 받을 때 메인 함수가 어떤 결과가 올때까지 기다립니다. 채널의 타입은 chan 입니다. 채널은 데이터를 받을 순 없고 보낼 수만 있도록 작성할 수 있습니다.(send-only) 12345678910111213141516func main() &#123; c := make(chan bool) go channelTest(c) result := &lt;- c fmt.Println(result)&#125;func channelTest(c chan bool) &#123; time.Sleep(time.Second * 5) c &lt;- true&#125;// send-onlyfunc sendOnlyTest(c chan&lt;- bool) &#123; c &lt;- true&#125; Error errors.New() 를 사용하여 에러를 정의하고 호출합니다. 123456789var err = errors.New(\"error content\")func main() &#123; fmt.PrintLn(errTest())&#125;func errTest() error &#123; return err&#125; goquery HTML 을 navigate 하고 필요한 걸 HTML에서 찾아내기 위해서 사용 JQuery 와 유사한 go 를 위한 라이브러리입니다. https://github.com/PuerkitoBio/goquery 1$ go get github.com/PuerkitoBio/goquery 참고 go lang std library https://golang.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"}]},{"title":"[CentOS] yum을 이용한 rpm 패키지 다운로드","slug":"linux-12","date":"2021-07-23T08:50:03.000Z","updated":"2023-03-14T02:22:58.983Z","comments":true,"path":"2021/07/23/linux-12/","link":"","permalink":"http://hgko1207.github.io/2021/07/23/linux-12/","excerpt":"","text":"yum-downloadonly 패키지 이용 yum-downloadonly 패키지를 설치합니다. 1$ yum install yum-downloadonly 1$ yum install [패키지명] -y --downloadonly --downloaddir=[다운로드 경로] 사용 예제입니다. 1$ yum install dotnet-sdk-5.0 -y --downloadonly --downloaddir=/home/rpm/download yumdownloader 이용 yumdownloader 명령어가 있는 yum-utils 패키지를 설치합니다. 1$ yum install yum-utils 1$ yumdownloader --downloadonly --resolve --destdir=[다운로드 경로] [패키지명] 사용 예제입니다. 1$ yumdownloader --downloadonly --resolve --destdir=/home/rpm/download dotnet-sdk-5.0 패키지 의존성 정보 확인 12$ yum deplist [패키지명]$ yum deplist dotnet-sdk-5.0 패키지 설치 1$ rpm -ivh [패키지 파일명] 패키지 삭제 설치된 패키지를 삭제합니다. 패키지명만 입력합니다. 1$ rpm -e [패키지명] 패키지 설치 여부 1$ rpm -q [패키지명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"}]},{"title":"Chocolatey 설치","slug":"chocolatey","date":"2021-07-21T10:21:51.000Z","updated":"2023-05-30T14:04:39.164Z","comments":true,"path":"2021/07/21/chocolatey/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/chocolatey/","excerpt":"","text":"윈도우를 사용하면서 개발 환경을 쉽게 꾸릴 수 있는 Chocolatey(윈도우용 패키지 매니저) 설치와 사용 방법에 대해 알아보겠습니다. 설치 공식 Install 홈페이지를 따라 설치를 진행합니다. 윈도우 7 이상, 윈도우 서버 2003 이상에서 설치가 가능하고, PowerShell 에서 명령어로 설치할 수 있습니다. PowerShell 사용 관리자 권한으로 실행해야 합니다. 그렇지 않으면 에러 메세지를 보여줍니다. 다음 설치 명령어를 복사하여 실행하면 설치가 진행됩니다. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 설치가 완료되었다면 choco 명령어를 실행하였을 때 다음과 같이 버전 정보가 나옵니다. 1234C:\\Windows\\system32&gt; chocoChocolatey v0.10.15Please run 'choco -?' or 'choco &lt;command&gt; -?' for help menu.C:\\Windows\\system32&gt; 패키지 설치 패키지 리스트 에서 설치 가능한 패키지들을 확인 할 수 있습니다. 구글 크롬을 예제로 설치해보겠습니다. 검색 창에 google chrome 을 검색하면 결과가 나오고 오른쪽에 설치 명령어가 보여집니다. 명령어를 복사하고 PowerShell 에 입력하면 설치가 진행됩니다. 1&gt; choco install googlechrome 설치가 완료되었으면 다음 명령어를 실행하여 설치된 패키지들을 확인합니다. 1&gt; choco search googlechrome Ubuntu 의 apt-get 와 CentOS rpm 명령어처럼 윈도우에서도 설치 명령어를 통해 필요한 프로그램을 쉽게 설치할 수 있습니다. 추천 패키지들 Windows Terminal vscode python3 git postman jdk8 Adobe Acrobat Reader Notepad++ Node JS PowerToys WSL(Windows Subsystem for Linux)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"}]},{"title":"알아두면 손해 안보는 사이트","slug":"util-1","date":"2021-07-21T02:59:01.000Z","updated":"2022-09-26T12:04:47.996Z","comments":true,"path":"2021/07/21/util-1/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/util-1/","excerpt":"","text":"개발 자바스크립트 https://beautifier.io/ 온라인 JSON Parser http://json.parser.online.fr/ 변수명 짓기 https://www.curioustore.com/#!/ 웹 템플릿 https://semantic-ui.com/ https://themeforest.net/ 마크다운 툴 https://stackedit.io/app# CSS Gradient Generator https://www.colorzilla.com/gradient-editor/ 디자인 컬러 팔레트 https://flatuicolors.com/ 무료 아이콘 모음 https://icons8.com/ https://www.flaticon.com/ 아이콘 변환 https://flat-icon.surge.sh/# 사진 모음 https://unsplash.com/ ETC. 파일 포맷 정보 https://eknote.tistory.com/89 좌표계 변환 http://www.synnatschke.de/geo-tools/coordinate-converter.php Convert Lat Long to UTM https://www.latlong.net/lat-long-utm.html 사진 용량 줄이기 https://tinypng.com/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"}]},{"title":"[JPA] Select Query","slug":"spring-jpa-1","date":"2021-06-19T13:27:35.000Z","updated":"2023-03-14T02:22:55.535Z","comments":true,"path":"2021/06/19/spring-jpa-1/","link":"","permalink":"http://hgko1207.github.io/2021/06/19/spring-jpa-1/","excerpt":"","text":"SpringData JPA 를 사용하여 웹 프로젝트를 진행하면서 Select Query 를 작성 시 잊어버리게 되어 검색을 하게되는데 자주 사용하는 내용들을 정리하였습니다. JpaRepository 를 상속받아 사용하는 기본 Query 와 @Query 주석을 사용하여 JPQL 및 네이티브 SQL 쿼리를 실행 하는 방법에 대해 알아보겠습니다. Entity 먼저 데이터베이스에 저장하기 위해 tb_user 테이블 이름의 Entity 클래스를 작성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) protected long id; /** 사용자ID */ @Column(nullable = false, length = 45) private String userId; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 이메일 */ @Column(length = 45) private String email; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Entity 클래스를 작성했다면 이번엔 Repository 인터페이스를 만들어야 합니다. Entity 의 기본적인 CRUD가 가능하도록 JpaRepository 인터페이스를 제공합니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 기본 Query Spring Data JPA 에서 기본적으로 제공하는 Query는 규칙에 맞게 작성해야 합니다. Method 설명 findBy… 쿼리를 요청 countBy… 쿼리 결과 행 수를 요청 orderBy… 쿼리 결과를 정렬 existsBy… 해당 조건의 항목이 존재하는지 확인 그리고 Query 메소드에 포함할 수 있는 키워드가 있습니다. 아래 참고 사이트에 자세하게 더 다양하게 정리가 되어있습니다. Keyword 설명 And 여러 컬럼을 and 로 쿼리 Or 여러 컬럼을 or 로 쿼리 Containing like 쿼리 Like like 쿼리 Between 컬럼의 두 값 사이에 있는 항목 쿼리 OrderBy 쿼리 결과를 정렬 In 여러 값 중에 하나인 항목 쿼리 Exists 해당 조건의 항목이 존재하는지 확인 아래는 예제 코드입니다. 12345678910111213User findByUserId(String userId);User findByUserIdAndPassword(String userId, String password);List&lt;User&gt; OrderByName();List&lt;User&gt; OrderByCreateDateDesc();List&lt;User&gt; findByRoleOrderByCreateDateDesc(Role role);List&lt;User&gt; findByNameContaining(String name);List&lt;User&gt; findByCreateDateBetween(LocalDateTime startDate, LocalDateTime endDate);boolean existsByUserId(String userId);int countByRole(Role role); JPQL(Java Persistence Query Language) JPQL은 SQL과 비슷한 문법을 가진 객체 지향 쿼리입니다. JPQL과 Native SQL 동일하게 @Query 어노테이션을 사용하여 쿼리를 작성하고, 또한 두 가지 방법으로 쿼리에 메소드의 매개변수 값을 전달 할 수 있습니다. @Param 어노테이션을 사용하여 이름으로 정의 된 매개변수를 쿼리에 전달합니다. 메소드의 매개변수 순서로 쿼리에 전달합니다.(1부터 시작) 1234567891011121314@Query(value = \"SELECT u FROM User u WHERE u.role = 'GUEST'\")List&lt;User&gt; findByRole();@Query(\"SELECT u FROM User u WHERE u.userId = :userId\")User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT u FROM User u WHERE u.userId = :userId and u.password = :password\")User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT u FROM User u WHERE u.userId = ?1\")User findByUserId(String userId);@Query(\"SELECT u FROM User u WHERE u.userId = ?1 and u.password = ?2\")User findByUserIdAndPassword(String userId, String password); Native SQL 네이티브 SQL을 사용하여 쿼리를 정의 할 수 있습니다. 네이티브 SQL을 사용하려면 nativeQuery 속성의 값을 true 로 설정합니다. 1234567891011121314@Query(value = \"SELECT * FROM tb_user u WHERE u.role = 'GUEST'\", nativeQuery = true)List&lt;User&gt; findByRole();@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId\", nativeQuery = true)User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId and u.password = :password\", nativeQuery = true)User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1\", nativeQuery = true)User findByUserId(String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1 and u.password = ?2\", nativeQuery = true)User findByUserIdAndPassword(String userId, String password); 참고 Spring Data JPA @Query https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"}]},{"title":"[JavaScript] 모달에서 이미지 및 동영상 출력","slug":"js-dev-4","date":"2021-06-16T13:25:20.000Z","updated":"2023-03-14T02:22:53.224Z","comments":true,"path":"2021/06/16/js-dev-4/","link":"","permalink":"http://hgko1207.github.io/2021/06/16/js-dev-4/","excerpt":"","text":"서론 [사진 보기], [동영상 보기] 버튼을 클릭 시 모달창이 띄워지면서 사진 또는 동영상이 출력되도록 하는 예제입니다. 사진과 동영상 파일을 images 경로에 저장하여 출력하였고, 실제 구동되는 프로젝트에서는 웹 서버가 실행되는 곳의 특정 경로에 저장하여 URL을 불러와서 출력합니다. html 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openImageModal()\"&gt;사진 보기&lt;/button&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openVideoModal()\"&gt;동영상 보기&lt;/button&gt; &lt;!-- 모달창 --&gt; &lt;div id=\"fileModal\" class=\"modal fade\" role=\"dialog\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header modal-header-sm\"&gt; &lt;h6 class=\"modal-title\"&gt;사진/동영상 보기&lt;/h6&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&amp;times;&lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body text-center\"&gt; &lt;div id=\"file-viewer\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; javascript JQuery 를 이용하여 모달창을 생성합니다. 1234567891011121314151617181920212223242526272829// 이미지 출력 모달창 오픈function openImageModal() &#123; $('#file-viewer').empty(); let img = document.createElement('img'); img.setAttribute('src', 'images/image.jpg'); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); $('#fileModal').modal();&#125;// 동영상 출력 모달창 오픈function openVideoModal() &#123; $('#file-viewer').empty(); var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); // video 태그 사용 var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); ideo.setAttribute('src', 'images/video.mp4'); div.append(video); $('#file-viewer').append(div); $('#fileModal').modal();&#125; 응용 서버에서 파일를 조회하여 출력하도록 하는 예제입니다. 12345678910111213141516171819202122232425262728const contextPath = '$&#123;pageContext.request.contextPath&#125;';$.ajax(&#123; url: contextPath + '/file/get', type: 'GET', success: function (file) &#123; if (file.fileType == 'IMAGE') &#123; var img = document.createElement('img'); img.setAttribute('src', contextPath + '/uploads/' + file.fileName); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); &#125; else if (file.fileType == 'VIDEO') &#123; var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); video.setAttribute('src', contextPath + '/uploads/' + file.fileName); div.append(video); $('#file-viewer').append(div); &#125; $('#fileModal').modal(); &#125;,&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"}]},{"title":"[WPF] Slider Custom Style","slug":"wpf-3","date":"2021-06-04T13:50:55.000Z","updated":"2023-06-05T00:51:29.296Z","comments":true,"path":"2021/06/04/wpf-3/","link":"","permalink":"http://hgko1207.github.io/2021/06/04/wpf-3/","excerpt":"","text":"WPF 기본 Slider Stlye 에서 Thumb 을 드래그할 때마다 박스 안에 숫자가 표시되도록 Style 을 하였습니다. Slider 모양 Style 추가 App.xaml 에 추가하거나 Resource.xaml 파일을 생성하여 Style 을 추가합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;SolidColorBrush x:Key=\"CustomSliderBackgroundSolidColorBrush\" Color=\"#1E211B\" /&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderForegroundBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#9B5B2B\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderThumBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#454543\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;Style x:Key=\"CustomSliderThumbStyle\" TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Setter Property=\"Focusable\" Value=\"false\"/&gt; &lt;Setter Property=\"SnapsToDevicePixels\" Value=\"true\"/&gt; &lt;Setter Property=\"OverridesDefaultStyle\" Value=\"true\"/&gt; &lt;Setter Property=\"Height\" Value=\"20\"/&gt; &lt;Setter Property=\"Width\" Value=\"30\"/&gt; &lt;Setter Property=\"Cursor\" Value=\"Hand\"/&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Canvas SnapsToDevicePixels=\"true\"&gt; &lt;Grid Height=\"20\" Width=\"30\"&gt; &lt;Rectangle x:Name=\"Background\" Fill=\"&#123;StaticResource CustomSliderThumBrush&#125;\" Stroke=\"#FFDADADA\" Height=\"20\" Width=\"30\" RadiusX=\"3\" RadiusY=\"3\"/&gt; &lt;TextBlock HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"White\" FontSize=\"10\" Text=\"&#123;Binding Value, RelativeSource=&#123;RelativeSource AncestorType=&#123;x:Type Slider&#125;&#125;&#125;\"/&gt; &lt;/Grid&gt; &lt;/Canvas&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property=\"IsMouseOver\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Orange\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsDragging\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"&#123;StaticResource CustomSliderThumBrush&#125;\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsEnabled\" Value=\"false\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Gray\"/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt;&lt;/Style&gt;&lt;ControlTemplate x:Key=\"CustomSliderControlTemplate\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Border Background=\"Transparent\" SnapsToDevicePixels=\"True\"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=\"&#123;TemplateBinding MinHeight&#125;\" /&gt; &lt;/Grid.RowDefinitions&gt; &lt;DockPanel LastChildFill=\"True\"&gt; &lt;Border x:Name=\"PART_SelectionRange\" Height=\"5\" ClipToBounds=\"True\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 -10 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderForegroundBrush&#125;\" /&gt; &lt;/Border&gt; &lt;Border ClipToBounds=\"True\" Height=\"5\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 0 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderBackgroundSolidColorBrush&#125;\" /&gt; &lt;/Border&gt; &lt;/DockPanel&gt; &lt;Track x:Name=\"PART_Track\"&gt; &lt;Track.Thumb&gt; &lt;Thumb Style=\"&#123;StaticResource CustomSliderThumbStyle&#125;\" VerticalAlignment=\"Center\" Width=\"&#123;TemplateBinding MinWidth&#125;\" Height=\"&#123;TemplateBinding MinHeight&#125;\" OverridesDefaultStyle=\"True\" Focusable=\"False\" /&gt; &lt;/Track.Thumb&gt; &lt;/Track&gt; &lt;/Grid&gt; &lt;/Border&gt;&lt;/ControlTemplate&gt;&lt;Style x:Key=\"CustomSliderStyle\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Setter Property=\"Template\" Value=\"&#123;StaticResource CustomSliderControlTemplate&#125;\" /&gt; &lt;Setter Property=\"VerticalAlignment\" Value=\"Center\" /&gt; &lt;Setter Property=\"MinWidth\" Value=\"30\" /&gt; &lt;Setter Property=\"MinHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"Height\" Value=\"20\" /&gt; &lt;Setter Property=\"MaxHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"BorderBrush\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"AutoToolTipPlacement\" Value=\"None\" /&gt; &lt;Setter Property=\"IsMoveToPointEnabled\" Value=\"True\" /&gt; &lt;Setter Property=\"SelectionStart\" Value=\"0\" /&gt; &lt;Setter Property=\"SelectionEnd\" Value=\"&#123;Binding Path=Value, RelativeSource=&#123;RelativeSource Self&#125;&#125;\" /&gt; &lt;Setter Property=\"Stylus.IsPressAndHoldEnabled\" Value=\"false\" /&gt;&lt;/Style&gt; Slider Style 적용 다음과 같이 Slider 에 Style을 지정합니다. 1&lt;Slider Minimum=\"1\" Maximum=\"255\" IsSnapToTickEnabled=\"True\" Style=\"&#123;StaticResource CustomSliderStyle&#125;\"/&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"}]},{"title":"[WPF] Prism ViewModelBase 정의","slug":"wpf-2","date":"2021-05-27T05:50:42.000Z","updated":"2023-03-14T02:22:48.518Z","comments":true,"path":"2021/05/27/wpf-2/","link":"","permalink":"http://hgko1207.github.io/2021/05/27/wpf-2/","excerpt":"","text":"WPF 에서 Prism 을 사용하여 ViewModel 을 구현할 때 필요에 따라 Container, EventAggregator, RegionManager, Logger 등의 서비스를 사용합니다. 서비스를 각각 ViewModel 에 정의해서 사용하는 것이 아닌 공통으로 작성하여 편리하게 사용할 수 있는 추상 클래스를 작성하였습니다. ViewModelBase Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using Prism.Events;using Prism.Logging;using Prism.Ioc;using Prism.Mvvm;using Unity;namespace Prism.Project.Common.Mvvm&#123; public abstract class ViewModelBase : BindableBase &#123; private string title; public string Title &#123; get =&gt; title; set =&gt; SetProperty(ref title, value); &#125; protected IUnityContainer Container &#123; get; &#125; private IEventAggregator eventAggregator; /// &lt;summary&gt; /// The EventAggregator /// &lt;/summary&gt; public IEventAggregator EventAggregator &#123; get &#123; return eventAggregator; &#125; private set &#123; this.SetProperty&lt;IEventAggregator&gt;(ref this.eventAggregator, value); &#125; &#125; private IRegionManager regionManager; /// &lt;summary&gt; /// The region manager /// &lt;/summary&gt; public IRegionManager RegionManager &#123; get &#123; return regionManager; &#125; private set &#123; this.SetProperty&lt;IRegionManager&gt;(ref this.regionManager, value); &#125; &#125; protected ILoggerFacade Logger &#123; get; &#125; protected ViewModelBase(IUnityContainer container) &#123; Container = container; RegionManager = container.Resolve&lt;IRegionManager&gt;(); EventAggregator = container.Resolve&lt;IEventAggregator&gt;(); Logger = container.Resolve&lt;ILoggerFacade&gt;(); &#125; &#125;&#125; 사용 코드 ViewModelBase 클래스를 상속받고 생성자에 container 를 정의합니다. 1234567891011121314151617181920212223242526using Prism.Project.Common.Mvvm;using Unity;using Prism.Events;namespace Prism.Project.ViewModels&#123; public class MainWindowViewModel : ViewModelBase &#123; public MainWindowViewModel(IUnityContainer container) : base(container) &#123; Title = \"Prism 테스트\"; Logger.Log(\"[MainWindowViewModel Created]\", Category.Debug, Priority.None); // Event 예제 코드 EventAggregator.GetEvent&lt;MainWindowClosedEvent&gt;().Subscribe(MainWindowClosed); &#125; /// &lt;summary&gt; /// MainWindow 화면 종료 시 /// &lt;/summary&gt; private void MainWindowClosed() &#123; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[JQuery] Select Box 제어","slug":"js-dev-3","date":"2021-05-21T02:47:06.000Z","updated":"2023-03-14T02:22:46.502Z","comments":true,"path":"2021/05/21/js-dev-3/","link":"","permalink":"http://hgko1207.github.io/2021/05/21/js-dev-3/","excerpt":"","text":"JQuery 를 이용해서 select 를 제어하는 방법에 대해 알아보겠습니다. 1&lt;select class=\"form-control\" name=\"name\" id=\"nameSelect\"&gt;&lt;/select&gt; 선택된 옵션 값 읽기 12$('#nameSelect option:selected').val();$('select[name=name]').val(); 선택된 옵션 이름 읽기 1$('#nameSelect option:selected').text(); 옵션 추가하기 123456$('#nameSelect').append( $('&lt;option&gt;', &#123; value: 1, text: '테스트', &#125;)); 값이 변경되었을 때 1234$('#nameSelect').change(function () &#123; const name = $(this).val(); console.log(name);&#125;); 특정한 값 선택하기 1$('#nameSelect').val(1).trigger('change'); 옵션 삭제 12345678// 지정한 인덱스의 옵션 삭제$('#nameSelect option:eq(0)').remove();// 첫 번째 옵션 삭제$('#nameSelect option:first').remove();// 마지막 옵션 삭제$('#nameSelect option:first').remove(); Select Box 비우기 1$('#nameSelect').empty();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"}]},{"title":"[Android] Yahoo Weather API를 이용하여 날씨정보 조회","slug":"android-dev-1","date":"2021-05-12T07:58:49.000Z","updated":"2023-06-12T13:57:20.493Z","comments":true,"path":"2021/05/12/android-dev-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/12/android-dev-1/","excerpt":"","text":"Yahoo Weather API 를 이용하여 현재 위치의 날씨 정보를 조회하는 방법에 대해 알아보겠습니다. 개발 환경 Android Studio Java 설정 build.gradle -&gt; dependencies 추가 1implementation 'zh.wang.android:yweathergetter4a:1.3.0' manifest -&gt; permission 추가 1234567&lt;!-- 인터넷 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;!-- GPS 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 코드 작성 Activity 또는 Fragment 에 YahooWeatherInfoListener 인터페이스를 implements 하면 gotWeatherInfo 함수를 오버라이딩(Override)을 하게 됩니다. 123456789101112public class WeatherActivity extends Activity implements YahooWeatherInfoListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; &#125;&#125; 이제 날씨 정보를 불러오기 위해 다음의 함수 중 상황에 맞게 호출합니다. 12345678// 장소 이름으로 쿼리public void queryYahooWeatherByPlaceName(final Context context, final String cityAreaOrLocation, final YahooWeatherInfoListener result)// 위도와 경도로 쿼리public void queryYahooWeatherByLatLon(final Context context, final String lat, final String lon, final YahooWeatherInfoListener result)// GPS를 사용하여 현재 위치로 쿼리public void queryYahooWeatherByGPS(final Context context, final YahooWeatherInfoListener result) 이번 프로젝트에는 GPS를 사용하여 현재 위치의 날씨 정보를 얻었습니다. 쿼리 함수를 호출하면 오버라이딩한 gotWeatherInfo 함수를 통해 날씨 정보를 얻을 수 있습니다. 123456YahooWeather yahooWeather = YahooWeather.getInstance();yahooWeather.setNeedDownloadIcons(true);yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS);yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS);yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); 날씨 정보를 한 번만 불러오는 것이 아니라 1분 마다 얻기 위해 Timer 를 사용하였습니다. Timer 를 사용하기 위해 위의 코드를 함수로 만들었습니다. 12345678910111213141516171819Timer timer = new Timer();timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125;&#125;, 0, 1000 * 60);public void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this);&#125; 이제 1분 마다 날씨 정보를 불러올 수 있게 되었습니다. 현재 위치, 시간, 온도, 습도, 대기압, 풍향, 풍속 등의 다양한 날씨 정보를 화면에 표출하여 완성하였습니다. 1234567891011121314151617@Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; 전체 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// WeatherActivity.javaimport android.os.Handler;import android.os.Looper;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import butterknife.BindView;import butterknife.ButterKnife;import me.hgko.networkinfo.R;import zh.wang.android.yweathergetter4a.WeatherInfo;import zh.wang.android.yweathergetter4a.YahooWeather;import zh.wang.android.yweathergetter4a.YahooWeatherInfoListener;public class WeatherActivity extends AppCompatActivity implements YahooWeatherInfoListener &#123; private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss\"); @BindView(R.id.logitudeText) TextView logitudeText; @BindView(R.id.latitudeText) TextView latitudeText; @BindView(R.id.datetimeText) TextView datetimeText; @BindView(R.id.addressText) TextView addressText; @BindView(R.id.weatherText) TextView weatherText; @BindView(R.id.temperatureText) TextView temperatureText; @BindView(R.id.humidityText) TextView humidityText; @BindView(R.id.pressureText) TextView pressureText; @BindView(R.id.windDirectionText) TextView windDirectionText; @BindView(R.id.windSpeedText) TextView windSpeedText; @BindView(R.id.windChillText) TextView windChillText; @BindView(R.id.visibilityText) TextView visibilityText; private YahooWeather yahooWeather; private Timer timer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); ButterKnife.bind(this); yahooWeather = YahooWeather.getInstance(); timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125; &#125;, 0, 1000 * 60 * 10); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; private void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!-- activity_weather.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"20dp\" android:paddingLeft=\"20dp\" android:paddingRight=\"20dp\" android:paddingTop=\"20dp\" tools:context=\".activity.WeatherActivity\"&gt; &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Datetime :\" /&gt; &lt;TextView android:id=\"@+id/datetimeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Logitude :\" /&gt; &lt;TextView android:id=\"@+id/logitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Latitude :\" /&gt; &lt;TextView android:id=\"@+id/latitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Address :\" /&gt; &lt;TextView android:id=\"@+id/addressText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Weather :\" /&gt; &lt;TextView android:id=\"@+id/weatherText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Temperature :\" /&gt; &lt;TextView android:id=\"@+id/temperatureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Chill :\" /&gt; &lt;TextView android:id=\"@+id/windChillText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Direction :\" /&gt; &lt;TextView android:id=\"@+id/windDirectionText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Speed :\" /&gt; &lt;TextView android:id=\"@+id/windSpeedText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Humidity :\" /&gt; &lt;TextView android:id=\"@+id/humidityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Pressure :\" /&gt; &lt;TextView android:id=\"@+id/pressureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Visibility :\" /&gt; &lt;TextView android:id=\"@+id/visibilityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; TextView 에 공통으로 스타일을 지정하기 위해 styles.xml 에 추가합니다. 123456789101112131415&lt;style name=\"TextStyle1\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;1&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt;&lt;style name=\"TextStyle2\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;2&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt; 실행 결과 앱을 실행하면 아래 이미지와 같이 현재 위치의 날씨 정보를 확인할 수 있습니다. 참고 https://github.com/zh-wang/YWeatherGetter4a","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"}]},{"title":"[MATLAB] MinGW-W64 수동 설치","slug":"matlab-1","date":"2021-05-06T07:41:52.000Z","updated":"2023-06-05T00:51:04.639Z","comments":true,"path":"2021/05/06/matlab-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/06/matlab-1/","excerpt":"","text":"MATLAB 에서 개발하고 MATLAB Coder를 사용하여 C 또는 C++ 코드로 변환하려고 하였다. 그런데 MEX 컴파일러를 확인할 수 없다는 에러가 났습니다. MATLAB 에서 mex -setup 명령어를 실행했더니 다음과 같이 MinGW-w64 C/C++ 컴파일러를 설치해야 한다는 내용이 나왔습니다. 1234&gt;&gt; mex -setup다음 사용 중 오류가 발생함: mex사용할 수 있는 컴파일러 또는 SDK를 찾을 수 없습니다. 무료로 제공되는 MinGW-w64 C/C++ 컴파일러를 설치할 수 있습니다. MinGW-w64 컴파일러 설치를 참조하십시오. 더 많은 옵션을보려면 http://www.mathworks.com/support/compilers/R2016a/win64.html을 참조하십시오. 구글 검색했을 때 홈 탭 &gt; 환경 섹션 &gt; 애드온 을 이용하여 설치할 수 있다고 하였는데 지금 사용하고 있는 MATLAB 2016a 버전 같은 경우에는 설치를 지원하지 않는 것인지 자동으로 설치를 할 수가 없었습니다. 그래서 직접 설치 파일을 다운받아 설치를 진행하였습니다. 수동 설치 https://jmeubank.github.io/tdm-gcc/download/ 페이지에서 현재 최신 버전인 tdm64-gcc-9.2.0.exe 설치 파일 다운로드(윈도우 운영체제에 맞게 다운로드) 위 그림처럼 체크를 해제한 후 Create 버튼을 클릭 설치 경로는 공백이 없는 C:\\TDM-GCC-64 경로로 지정하여 설치 환경 변수가 자동으로 등록되며 설치 완료 환경 설정 및 setup MATLAB 으로 돌아와서 setenv 명령어를 통해 설치된 경로에 대해 환경 설정을 하고 mex -setup 명령어를 실행하면 이제 MinGW64 Compiler 를 사용할 수 있습니다. 123456789101112&gt;&gt; setenv ( 'MW_MINGW64_LOC', 'C:\\TDM-GCC-64' )&gt;&gt; mex -setupMEX이(가) C 언어 컴파일에 'MinGW64 Compiler (C)'을(를) 사용하도록 구성되었습니다.경고: 2^32-1개의 요소를 초과하는 MATLAB 변수를 지원하기 위해 MATLAB C와 Fortran API가 변경되었습니다. 새 API를 활용하기 위해서는 가까운 시일 내에 코드를 업데이트해야 할 수 있습니다. 자세한 내용은 http://www.mathworks.com/help/matlab/matlab_external/upgrading-mex-files-to-use-64-bit-api.html에서 확인할 수 있습니다.다른 언어를 선택하려면 다음 중 하나를 선택하십시오. mex -setup C++ mex -setup FORTRAN MinGW64 Compiler (C++) 을 사용하도록 구성할 시 다음 명령어를 실행합니다. 1&gt;&gt; mex -setup C++ 결과 MATLAB Coder를 이용한 Code 변환도 성공적으로 완료되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"}]},{"title":"[C++] 평균, 표준편차 구하기","slug":"cpp-coding-4","date":"2021-04-28T00:49:09.000Z","updated":"2023-03-14T02:22:32.765Z","comments":true,"path":"2021/04/28/cpp-coding-4/","link":"","permalink":"http://hgko1207.github.io/2021/04/28/cpp-coding-4/","excerpt":"","text":"평균 및 표준편차 계산 함수 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;// 평균 계산 함수template&lt;class T&gt;double Mean(std::vector&lt;T&gt; array)&#123; double sum = 0.0; for (int i = 0; i &lt; array.size(); i++) sum += array[i]; return sum / array.size();&#125;// 표준 편차 계산 함수template&lt;class T&gt;double StandardDeviation(std::vector&lt;T&gt; array)&#123; double meanValue = Mean&lt;T&gt;(array); // 배열 요소가 1개밖에 없을 때는 // NaN(숫자가 아님)이라는 의미로 // sqrt(-1.0) 을 반환 int size = array.size(); if (size &lt; 2) &#123; return sqrt(-1.0); &#125; double sum = 0.0; for (int i = 0; i &lt; size; i++) &#123; double diff = array[i] - meanValue; sum += diff * diff; &#125; return sqrt(sum / (size - 1));&#125; 테스트 123456789101112131415161718int main()&#123; std::vector&lt;int&gt; array; array.push_back(5); array.push_back(2); array.push_back(7); array.push_back(8); array.push_back(4); array.push_back(1); array.push_back(10); array.push_back(9); double meanValue = Mean&lt;int&gt;(array); double stddevValue = StandardDeviation&lt;int&gt;(array); std::cout &lt;&lt; \"meanValue : \" &lt;&lt; meanValue &lt;&lt; std::endl; std::cout &lt;&lt; \"stddevValue : \" &lt;&lt; stddevValue &lt;&lt; std::endl;&#125; 결과 12meanValue : 5.75stddevValue : 3.28416","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"}]},{"title":"[JAVA] 날짜 비교","slug":"java-dev-7","date":"2021-04-26T01:18:29.000Z","updated":"2023-03-14T02:22:30.197Z","comments":true,"path":"2021/04/26/java-dev-7/","link":"","permalink":"http://hgko1207.github.io/2021/04/26/java-dev-7/","excerpt":"","text":"SimpleDateFormat 을 이용한 날짜 비교하는 방법에 대해 알아보겠습니다. 소스코드 12345678910111213141516171819202122232425262728293031import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatExample &#123; public static long getDayCount( String start, String end ) &#123; SimpleDateFormat format = new SimpleDateFormat( \"yyyy-M-d\" ); long diff = -1; try &#123; Date dateStart = format.parse( start ); Date dateEnd = format.parse( end ); // time is always 00:00:00 so rounding should help to ignore the // missing hour when going from winter to summer time as well as the // extra hour in the other direction diff = Math.round( ( dateEnd.getTime() - dateStart.getTime() ) / (double)( 60 * 60 * 24 * 1000 ) ); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; return diff; &#125; public static void main( String[] args ) &#123; long diff = getDayCount( \"2021-1-1\", \"2021-4-26\" ); System.out.println( \"결과 : \" + diff + \" 일\" ); &#125;&#125; 결과 1결과 : 115 일","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"}]},{"title":"[C++] Is the Point Inside the Polygon?","slug":"cpp-coding-3","date":"2021-04-13T04:58:06.000Z","updated":"2023-03-14T02:22:27.678Z","comments":true,"path":"2021/04/13/cpp-coding-3/","link":"","permalink":"http://hgko1207.github.io/2021/04/13/cpp-coding-3/","excerpt":"","text":"point-in-polygon (PIP) “In computational geometry, the point-in-polygon (PIP) problem asks whether a given point in the plane lies inside, outside, or on the boundary of a polygon.” Wikipedia. 점이 다각형(Polygon) 내부에 있는지 확인하는 코드입니다. 123456789101112131415161718192021struct Point&#123; int x; int y;&#125;;bool InsidePolygon(int nvert, Point polygon[], int pointx, int pointy)&#123; int i, j = 0; bool inside = false; for (i = 0, j = nvert - 1; i &lt; nvert; j = i++) &#123; if (((polygon[i].y &gt; pointy) != (polygon[j].y &gt; pointy)) &amp;&amp; (pointx &lt; (polygon[j].x - polygon[i].x) * (pointy - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) &#123; inside = !inside; &#125; &#125; return inside;&#125; 인수 nvert : 다각형의 정점 수 polygon[] : 다각형을 형성하는 점의 배열 pointx : 점의 X 좌표 pointy : 점의 Y 좌표 테스트 12345678910111213int main()&#123; Point polygon[] = &#123;&#123;0, 0&#125;, &#123;50, 0&#125;, &#123;50, 50&#125;, &#123;0, 50&#125;&#125;; int n = sizeof(polygon) / sizeof(polygon[0]); bool result = InsidePolygon(n, polygon, 0, 5); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; result = InsidePolygon(n, polygon, 60, 20); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; return 0;&#125; 결과 12YESNO","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[Oracle] Spatial Data Query","slug":"oracle-2","date":"2021-03-18T00:39:31.000Z","updated":"2023-03-14T02:22:25.175Z","comments":true,"path":"2021/03/18/oracle-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/18/oracle-2/","excerpt":"","text":"Table 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); INSERT SDO_GEOMETRY 컬럼에 넣을 데이터는 타입마다 형식이 다릅니다. Point(점) 타입 1234567SDO_GEOMETRY( 2001, 4326, SDO_POINT_TYPE(126.64,36.86, NULL), NULL, NULL ) Rectangle(직사각형) 타입 12345678SDO_GEOMETRY( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), -- 1개의 사각형 SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88) -- 사각형을 정의하기 위해 오직 2개의 포인트 필요(lower left and upper right)) Polygon 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1), -- 1개의 폴리곤 SDO_ORDINATE_ARRAY(126.63,36.88, 126.64,36.88, 126.64,36.84, 126.63,36.84, 126.63,36.88) ) Circle(원) 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,4), -- 1개의 원 SDO_ORDINATE_ARRAY(8,7, 10,9, 8,11) -- 1개의 원은 최소 3개의 점으로 정의됨 ) 두 개의 폴리곤 1234567SDO_GEOMETRY ( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1, 19,2003,1), SDO_ORDINATE_ARRAY(0,0, 10,0, 10,10, 0,10, 0,0, 4,4, 6,4, 6,6, 4,6, 4,4) ) Insert 예제 12345INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88)) ); SELECT 입력된 직사각형 영역 안의 데이터 조회 1234567891011# SDO_INTERSECTION(geometry1, geometry2, tolerance);SELECT id, nameFROM sample_tableWHERE SDO_GEOM.SDO_INTERSECTION( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 0.005 ) is not null 1234567891011# SDO_RELATE(geometry1, geometry2, param);SELECT id, nameFROM sample_tableWHERE SDO_RELATE( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 'mask=INSIDE+OVERLAPBDYINTERSECT+EQUAL+COVERS' ) = 'TRUE' 위의 쿼리에서 SDO_RELATE 의 param에 대한 내용은 참고 사이트에 자세하게 설명되어 있습니다. X, Y 좌표 조회 12SELECT name, t.x, t.y, t.idFROM sample_table s, TABLE(SDO_UTIL.GETVERTICES(s.shape)) t Polygon Center 좌표 조회 12345SELECT SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.X x, SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.Y yFROM sample_table s, user_sdo_geom_metadata mWHERE name = 'Polygon' Geometry 형식이 맞는가? 12SELECT s.name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(s.shape, 0.005)FROM sample_table s 참고 Oracle Help Center - Spatial Relationships and Filtering","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"}]},{"title":"[Oracle] SDO_GEOMETRY 사용 방법","slug":"oracle-1","date":"2021-03-16T01:22:54.000Z","updated":"2023-04-22T12:58:34.380Z","comments":true,"path":"2021/03/16/oracle-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/16/oracle-1/","excerpt":"","text":"SDO_GEOMETRY Oracle Spatial 을 사용하여 공간 데이터를 생성하고 관리합니다. Oracle 에는 SDO_GEOMETRY 타입을 통하여 공간 데이터를 구성할 수 있습니다. SDO_GEOMETRY 은 다음과 같이 정의됩니다. 1234567CREATE TYPE sdo_geometry AS OBJECT ( SDO_GTYPE NUMBER, SDO_SRID NUMBER, SDO_POINT SDO_POINT_TYPE, SDO_ELEM_INFO SDO_ELEM_INFO_ARRAY, SDO_ORDINATES SDO_ORDINATE_ARRAY); SDO_GTYPE 00 - UNKNOWN_GEOMETRY 01 - POINT 02 - LINE or CURVE 03 - POLYGON or SURFACE 04 - COLLECTION 05 - MULTIPOINT 06 - MULTILINE or MULTICURVE 07 - MULTIPOLYGON or MULTISURFACE 08 - SOLID 09 - MULTISOLID 예) 2003 일 경우 2차원의 POLYGON 형식 SDO_SRID Geometry 와 연관된 Coordinate System(Spatial Reference System) 입니다. 값이 NULL 이면 관련된 Coordinate System 이 없는 것 입니다. SDO_POINT POINT 형식일 때 사용합니다. SDO_POINT_TYPE(x, y, z) 을 통해 포인트를 입력합니다. SDO_ELEM_INFO SDO_ORDINATES 에 저장될 값의 형식을 정의합니다. 예) SDO_ELEM_INFO_ARRAY(1,1003,3) 첫 번째 1 은 SDO_ORDINATES 에 입력된 도형 ARRAY 의 시작 위치 1003과 3은 도형 형식을 정의 1003 은 외부도형, 2003 일 경우 내부도형 (1,1003,1) or (1,2003,1) : 폴리곤 형식으로 4면 다각형의 경우 5개의 점을 지정하고 점 5와 점 1은 동일 (1,1003,3) or (1,2003,3) : 직사각형 유형. 왼쪽 하단과 오른쪽 상단의 두 점을 지정 (1,1003,4) or (1,2003,4) : 원형 유형. 최소 3개의 점을 지정해야 함 자세한 내용은 참고 사이트에서 확인 SDO_ORDINATES SDO_ELEM_INFO 에서 정의된 형식으로 값을 입력합니다. Spatial Table 생성 1. 테이블 생성 shape 필드에 SDO_GEOMETRY 타입을 지정하여 Spatial 테이블을 생성하였습니다. 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); 2. 메타데이터 생성 SDO_GEOMETRY 를 사용하기 전에 꼭 메타데이터를 생성해줘야 합니다. 1234567891011121314151617insert into user_sdo_geom_metadata ( table_name, column_name, diminfo, srid )values ( 'sample_table', 'shape', SDO_DIM_ARRAY( SDO_DIM_ELEMENT('Longitude', -180, 180, 0.5), =&gt; 10 미터 허용오차 SDO_DIM_ELEMENT('Latitude', -90, 90, 0.5) ), 4326 ====&gt; Longitude/Latitude(WGS 84) : 4326 ); 3. 인덱스 생성 메타데이터 생성 후 Spatial 테이블의 인덱스를 생성합니다. 12345# 인덱스 생성 형식CREATE INDEX index_name ON table_name(column_name) INDEXTYPE IS MDSYS.SPATIAL_INDEX;# 사용 예제CREATE INDEX sample_index ON sample_table(shape) indextype IS MDSYS.SPATIAL_INDEX; 4. 데이터 입력 테이블을 생성하고 메타데이터와 인덱스까지 생성하였으면 데이터를 넣어봅니다. 123456# Rectangle 데이터INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(5,5, 10,10)) ); 5. 확인 입력된 데이터가 SDO_GEOMETRY 형식인지 확인합니다. 결과가 TRUE 가 아니면 잘못된 입력입니다. 1234SELECT id, name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(shape, 0.5) FROM sample_table;# 결과1, Rectangle, TRUE SDO_GEOMETRY 타입을 사용하여 공간 데이터 생성을 진행하였습니다. 다음에는 생성된 공간 데이터에 대한 쿼리를 알아보겠습니다. 참고 Oracle Help Center - SDO_GEOMETRY Object Type Oracle Help Center - Polygon with a Hole Oracle Spatial Geometry Type 및 Spatial Table 생성","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"}]},{"title":"[Spring Boot] 환경에 따른 설정 방법","slug":"springboot-2","date":"2021-03-11T00:38:25.000Z","updated":"2023-06-12T13:57:10.013Z","comments":true,"path":"2021/03/11/springboot-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/11/springboot-2/","excerpt":"","text":"Spring Boot 를 사용하여 웹 프로젝트를 할 때에 환경(개발 또는 배포)에 따라 설정 값들을 달리 할 필요가 있습니다. Spring Boot 에서는 application.properties 파일을 profile 로 구분하여 사용할 수 있습니다. profile 을 작성하지 않을경우 default 로 application.properties 를 사용합니다. application.properties 작성 규칙 profile 을 포함한 파일명을 작성합니다. 1234567891011121314# defaultapplication.properties# 배포 환경(prod)application-prod.properties# 개발 환경(dev)application-dev.properties# 테스트 환경(test)application-test.properties# customapplication-custom.properties 예제 개발과 배포 할 때의 설정을 나눈 예제입니다. 파일 생성 12345# 배포용(기본)application.properties# 개발용(dev)application-dev.properties application.properties 설정 application-dev.properties 파일에 spring.profiles.active=dev 을 추가합니다. application.properties 12345678# Server 설정server.port=8080# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://[외부 IP]:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=root!23 application-dev.properties 1234567891011# Profile 설정 - 이 값을 꼭 넣어야 합니다.spring.profiles.active=dev# Server 설정server.port=8081# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=test!23 Application 실행 설정 STS(Spring Tool Suite) - Spring Boot Run 다음의 이미지와 같이 Profile 에 적용하고자 하는 환경 값(예: dev)을 선택하면 application-dev.properties 의 설정을 읽어옵니다. 실행 테스트 dev 환경을 주입 후 실행 테스트를 하였습니다. dev 환경일 때 서버 포트를 8081 으로 설정을 하였었는데 다음의 실행 로그를 보면 Tomcat started on port(s): 8081 처럼 8081 포트로 서버가 실행 된 것을 확인할 수 있습니다. 123452021-03-11 13:52:28.738 INFO 13588 --- [ restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'2021-03-11 13:52:28.772 INFO 13588 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292021-03-11 13:52:29.903 INFO 13588 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2021-03-11 13:52:30.836 INFO 13588 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path '/admin'2021-03-11 13:52:30.839 INFO 13588 --- [ restartedMain] c.y.a.a.EAfterschoolAdminApplication : Started EAfterschoolAdminApplication in 6.985 seconds (JVM running for 7.822)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"}]},{"title":"[JavaScript] String형 Bytes length 구하기","slug":"js-dev-2","date":"2021-03-10T00:52:06.000Z","updated":"2023-06-12T13:57:01.518Z","comments":true,"path":"2021/03/10/js-dev-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/js-dev-2/","excerpt":"","text":"UTF-8 인코딩 방식 바이트 길이 구하기 한글 한글자당 3 바이트씩 계산됩니다. 12345678910// Functionconst getByteLengthOfString = function (s, b, i, c) &#123; for (b = i = 0; (c = s.charCodeAt(i++)); b += c &gt;&gt; 11 ? 3 : c &gt;&gt; 7 ? 2 : 1); return b;&#125;;// Testconst test = '테스트';console.log('length : ', getByteLengthOfString(test), 'Bytes'); 12// 결과length : 9 Bytes 한글의 경우 2바이트 계산되도록 다음의 함수를 통해 한글 문자열의 바이트 수를 2 바이트로 나오게 할 수 있습니다. 1234567891011121314151617181920// FunctionString.prototype.getBytes = function () &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; &#125; return int_char_count;&#125;;// Testconst test = '테스트';console.log('length : ', test.getBytes(), 'Bytes'); 12// 결과length : 6 Bytes 입력된 길이 만큼의 문자열을 리턴 1234567891011121314151617181920212223242526// FunctionString.prototype.getStringFromByteLength = function (length) &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; let returnValue = ''; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; if (int_char_count &gt; length) &#123; break; &#125; returnValue += str_character; &#125; return returnValue;&#125;;// Testconst test = '테스트';console.log('result : ', test.getStringFromByteLength(4)); 12// 결과result: 테스;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"[JAVA] String형 Bytes length 구하기","slug":"java-dev-6","date":"2021-03-10T00:32:48.000Z","updated":"2023-06-04T14:52:37.776Z","comments":true,"path":"2021/03/10/java-dev-6/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/java-dev-6/","excerpt":"","text":"String 길이 구하기 123String test = \"테스트\";System.out.println(\"length : \" + test.length()); 12# 결과length : 3 바이트 길이 구하기 1234String test = \"테스트\";int length = test.getBytes().length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 9 Bytes 기본 인코딩이 UTF-8 설정 되어있을 경우 한글은 한글자당 3바이트씩 계산됩니다. 한글 한글자당 2바이트씩 나오게 하려면 다음과 같이 인코딩을 설정하면 됩니다. 12345String charset = \"euc-kr\";String test = \"테스트\";int length = test.getBytes(charset).length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 6 Bytes 인코딩 문자셋에 따라 바이트 길이 구하기 12345678910111213141516/** * 문자열의 바이크 길이 구하기 * 인코딩 문자셋에 따라 바이크 길이 달라짐. * * @param str 문자열 * @param charset 인코딩 문자셋 * @return */private int getByteLength(String str, String charset) &#123; try &#123; return str.getBytes(charset).length; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"}]},{"title":"[Spring Boot] Maven 빌드 방법","slug":"springboot-1","date":"2021-03-09T04:52:07.000Z","updated":"2023-03-14T02:22:13.560Z","comments":true,"path":"2021/03/09/springboot-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/09/springboot-1/","excerpt":"","text":"STS(Spring Tool Suite) 에서 빌드 방법 메뉴 -&gt; Run -&gt; Run Configurations -&gt; Maven Build(우클릭) -&gt; New Configuration 클릭 [Name] 입력 란에 작성 [Base directory] 에서 Workspace 버튼 클릭 빌드하려는 프로젝트 선택 [Goals] 입력 란에 clean install 작성 저장 후 빌드 실행 아래 이미지는 설정 한 내용입니다. Maven 빌드 중에 데이터베이스 연결을 제외하는 방법 Maven Build -&gt; [Goals] 입력 란에 clean install -DskipTests 작성합니다. 또는 pom.xml에 아래 코드를 추가합니다. 1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"}]},{"title":"[Kubernetes] 명령어들","slug":"kubernetes-1","date":"2021-03-04T02:17:05.000Z","updated":"2023-03-14T02:22:11.262Z","comments":true,"path":"2021/03/04/kubernetes-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/04/kubernetes-1/","excerpt":"","text":"명령어들 123456789101112131415161718192021222324# 생성kubectl create -f test.pod.yaml# 중지 및 삭제kubectl delete pod test --grace-period=0 --forcekubectl delete service test# node 정보 확인kubectl get nodes# pod 확인kubectl get pods --all-namespaces# 서비스 확인kubectl get svc# 배포 확인kubectl get deployments# 상세 정보 확인kubectl describe pods# 개별 상세 정보 확인kubectl describe pod &lt;name&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"}]},{"title":"[Docker] 명령어들","slug":"docker-2","date":"2021-01-26T06:18:26.000Z","updated":"2023-03-14T02:22:08.827Z","comments":true,"path":"2021/01/26/docker-2/","link":"","permalink":"http://hgko1207.github.io/2021/01/26/docker-2/","excerpt":"","text":"컨테이너 관련 명령어들 명령어 설명 docker ps 실행되고 있는 컨테이너 목록 docker ps -a 전체 컨테이너 목록 docker ps --no-trunc 컨테이너 정보 전체 표시 docker logs [컨테이너명 or ID] 로그 확인 docker exec -i -t [컨테이너명 or ID] /bin/bash 컨테이너 내부 셸 접속 docker rm [컨테이너명 or ID] 컨테이너 삭제 docker rm -f [컨테이너명 or ID] 컨테이너 강제 삭제 docker commit [옵션] [컨테이너명] [이미지명]:[태그] 컨테이너 커밋 12345678# 컨테이너 압축# export의 경우 컨테이너를 동작하는데 필요한 모든 파일이 압축됨docker export [컨테이너명 or ID] &gt; [파일명]docker export test &gt; test.tar# 컨테이너 importdocker import [파일명]docker import test.tar 이미지 관련 명령어들 명령어 설명 docker images 이미지 목록 확인 docker build [옵션] [이미지명] [Dockerfile 경로] 이미지 생성 docker rmi [이미지명 or ID] 이미지 삭제 docker tag [기존 이미지명] [새로운 이미지명] 이미지 태그명 변경 docker tag [기존 이미지명]:[기존 태그명] [새로운 이미지명]:[새로운 태그명] 이미지 태그명 변경 docker pull [저장소 주소]/[이미지명] 도커 허브에서 다운로드 docker push [저장소 주소]/[이미지명] 도커 허브 저장소에 이미지 올리기 1234567891011121314# 이미지 압축docker save [옵션] [파일명] &lt;이미지명 또는 이미지ID&gt;docker save -o baseimage.tar baseimage# 모든 이미지 압축docker save -o images.tar $(docker image ls -q)# gzip을 이용한 이미지 압축docker save [이미지명] | gzip &gt; [파일명]docker save baseimage | gzip &gt; baseimage.tar.gz# 이미지 로드docker load [옵션] [파일명]docker load -i baseimage.tar 기타 명령어 12# 컨테이너 정보 일부 표시docker ps --format \"table &#123;&#123;.image&#125;&#125;\\t&#123;&#123;.command&#125;&#125;\"","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[CentOS] Cmake 설치 및 사용 방법","slug":"linux-11","date":"2021-01-25T07:36:18.000Z","updated":"2023-06-05T00:50:20.036Z","comments":true,"path":"2021/01/25/linux-11/","link":"","permalink":"http://hgko1207.github.io/2021/01/25/linux-11/","excerpt":"","text":"리눅스 환경에서 Cmake 설치 및 사용 방법에 대해 알아보겠습니다. 다운로드 https://cmake.org/download/ 페이지를 가서 최신 버전을 다운 받습니다. 현재 날짜 기준으로 3.19.3 버전입니다. 123[hgko@localhost ~]$ sudo su[root@localhost ~]$ cd /usr/local/src[root@localhost src]$ wget http://www.cmake.org/files/v3.19/cmake-3.19.3.tar.gz 다운로드가 완료되면 압축해제를 합니다. 1[root@localhost src]$ tar -zxvf cmake-3.19.3.tar.gz 설치 /usr/local 경로의 bin 폴더에 설치가 됩니다. 1234[root@localhost src]$ cd cmake-3.19.3[root@localhost cmake-3.19.3]$ ./bootstrap --prefix=/usr/local[root@localhost cmake-3.19.3]$ make[root@localhost cmake-3.19.3]$ make install 설치 확인 다음과 같이 버전 정보가 출력되면 성공적으로 설치가 완료되었습니다. 1234[root@localhost ~]$ cmake --versioncmake version 3.19.3CMake suite maintained and supported by Kitware (kitware.com/cmake). 사용 방법 다음 명령어는 사용 방법입니다. CMakeLists.txt 파일을 생성하고 내용을 작성 cmake 명령어로 실행 123$ cmake CMakeLists.txt$ make$ make install make 파일 정리 1$ make clean","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"}]},{"title":"[CentOS] 유용하게 쓰는 명령어들","slug":"linux-10","date":"2021-01-20T01:53:23.000Z","updated":"2023-03-14T02:22:03.502Z","comments":true,"path":"2021/01/20/linux-10/","link":"","permalink":"http://hgko1207.github.io/2021/01/20/linux-10/","excerpt":"","text":"유용하게 쓰는 명령어들 명령어 설명 source /etc/profile profile 적용 free -h 메모리 용량 확인 dh -h 디스크 용량 확인 nproc CPU 코어 수 확인 pwd 현재 경로 확인 chmod -R 755 [폴더 or 파일] 사용 권한 변경 chown -R root:root [폴더 or 파일] 소유자와 그룹 변경 ps -ef | grep [프로세스명] 프로세스 확인 rpm -qa | grep [패키지명] 설치된 패키지 확인 kill -9 [프로세스ID] 프로세스 삭제 mv [파일명] [변경할파일명] 파일명 바꾸기 mv [폴더명] [변경할폴더명] 폴더명 바꾸기 pgrep -f [파일명] 프로세스 id만 추출 1234567891011121314151617# 특정 파일 제외하고 삭제find ./ ! -name '*.h' -exec rm -rf &#123;&#125; \\;# 두 개의 파일 형식 빼고 다 삭제# 예) .h, .inl 파일 빼고 삭제find ./ \\( ! -name '*.inl' ! -name '*.h' \\) -exec rm -rf &#123;&#125; \\;# 별칭 설정alias rm='rm -i'alias cp='cp -i'alias mv='mv -i'# 환경변수 설정export LD_LIBRARY_PATH=/usr/bin:$LD_LIBRARY_PATH# 폴더와 하위 폴더에 있는 파일명 텍스트로 추출dir [폴더경로] &gt; list.txt 12# tail -n 로 가장 나중의 jar 파일 찾기ls -tr | grep jar | tail -n 1 가끔 쓰인 명령어들 명령어 설명 uname -r 커널 버전 확인 ln -s [원본파일] [링크파일] 심볼릭 링크 설정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[CentOS] Nginx 설치 및 사용 방법","slug":"linux-9","date":"2020-11-16T02:35:35.000Z","updated":"2023-06-04T14:52:06.129Z","comments":true,"path":"2020/11/16/linux-9/","link":"","permalink":"http://hgko1207.github.io/2020/11/16/linux-9/","excerpt":"","text":"리눅스 환경에서 Nginx 설치 및 사용 방법에 대해 알아보겠습니다. 1. Nginx 저장소 추가 yum 저장소에는 nginx 라이브러리가 없기 때문에 저장소를 추가합니다. 1[hgko@localhost ~]$ sudo vi /etc/yum.repos.d/nginx.repo /etc/yum.repos.d 경로에 nginx.repo 파일을 추가하고 다음과 같이 작성합니다. 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1 2. 설치 저장소를 추가하였다면 설치를 합니다. 1[hgko@localhost ~]$ sudo yum install -y nginx 3. 방화벽 포트 개방 웹서버의 8080 포트를 사용할 계획이므로, 8080 포트를 개방합니다. 123456# 포트 개방[hgko@localhost ~]$ sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp# 방화벽 재시작[hgko@localhost ~]$ sudo firewall-cmd --reload# 개방된 포트 목록 확인[hgko@localhost ~]$ sudo firewall-cmd --list-ports 4. 서비스 시작 서비스를 등록하고 시작합니다. 12[hgko@localhost ~]$ sudo systemctl enable nginx[hgko@localhost ~]$ sudo systemctl start nginx 5. 웹 서버 배포 서비스가 시작되었으면 개발된 웹 서버 배포 작업을 진행합니다. 빌드된 프로젝트를 /usr/share/nginx/ 경로로 이동시킵니다. 기존의 설정파일인 default.conf 파일을 엽니다. 기존 설정파일을 지우고 새로 생성해도 됩니다. 포트를 변경하고, 프로젝트 경로를 입력하고, 필요한 proxy 정보를 입력합니다. proxy_pass에는 backend server url을 입력합니다. 12[hgko@localhost ~]$ sudo su[root@localhost ~]$ vi /etc/nginx/conf.d/default.conf 12345678910111213141516171819202122232425262728293031server &#123; listen 8080; listen [::]:8080; server_name localhost; # 도메인 주소 root /usr/share/nginx/frontend; # 배포된 프로젝트 경로 index index.html index.htm; client_max_body_size 100M; location ^~ /api &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; location ^~ /stream &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_cache_bypass $http_upgrade; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 6. 서비스 재시작 설정이 완료되면 서비스를 재시작 합니다. 1[hgko@localhost ~]$ sudo systemctl restart nginx 7. 확인 http://localhost:8080을 접속하여 웹 서버가 잘 실행되고 있는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"}]},{"title":"[CentOS] PM2 설치 및 사용 방법","slug":"linux-8","date":"2020-10-26T06:57:59.000Z","updated":"2023-06-04T14:51:52.025Z","comments":true,"path":"2020/10/26/linux-8/","link":"","permalink":"http://hgko1207.github.io/2020/10/26/linux-8/","excerpt":"","text":"리눅스 환경에서 PM2 설치 및 사용 방법에 대해서 알아보겠습니다. Node.js 는 단일 CPU 코어에서 실행되기 때문에 CPU 개수만큼 멀티코어 시스템을 사용하기 위해 PM2(Process Manager 2) 를 설치하고 사용하였습니다. 설치 npm 이 설치되어 있어야 합니다. 1[root@localhost ~]$ npm install pm2 -g 설치 확인 pm2 프로세스의 상태를 확인합니다. 처음에는 시작한 어플리케이션이 없기 때문에 아무것도 없습니다. 1[root@localhost ~]$ pm2 list 기본 사용 방법 pm2를 사용해보기 위해 간단한 어플리케이션을 작성하겠습니다. app.js 파일을 생성하고 아래 코드를 복사합니다. 123456789101112// app.jsconst express = require('express');const app = express();const port = 3000;app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);app.listen(port, function () &#123; console.log(`application is listening on port $&#123;port&#125;...`);&#125;); pm2를 통해 실행합니다. 1[root@localhost test]$ pm2 start app.js 또는 이름을 지정하여 실행 할 수 있습니다. 1[root@localhost test]$ pm2 start app.js --name app 아무런 옵션없이 PM2를 사용하여 실행하면 위의 그림처럼 포크(fork)모드로 어플리케이션을 실행합니다. 클러스터 모드 사용 설정파일을 활용해 클러스터 모드로 실행할 수 있습니다. 123# 설정파일 생성[root@localhost test]$ touch ecosystem.config.js[root@localhost test]$ vi ecosystem.config.js 1234567891011// ecosystem.config.jsmodule.exports = &#123; apps: [ &#123; name: 'app', script: './app.js', instances: 0, exec_mode: 'cluster', &#125;, ],&#125;; 1[root@localhost test]$ pm2 start ecosystem.config.js 위의 코드를 복사하고 pm2 명령어로 실행하면 클러스터 모드로 실행됩니다. exec_mode 값을 'cluster’로 설정하면 클러스터 모드로 실행한다는 의미이고, instances 값을 '0’으로 설정하면 CPU 코어 수 만큼 프로세스를 실행한다는 의미입니다. instances 값을 0이 아닌 고정으로 설정할 수도 있습니다. 다수의 어플리케이션 설정 123456789101112131415161718module.exports = &#123; apps: [ &#123; name: 'collect', cwd: './workspace/pipeline-service-collector', script: 'npm', args: 'run serve', instances: 5, exec_mode: 'cluster', &#125;, &#123; name: 'collect-manager', cwd: './workspace/pipeline-service-collector-manager', script: 'npm', args: 'run serve', &#125;, ],&#125;; 위의 코드는 두 개의 어플리케이션을 실행하는 예제입니다. 첫 번째는 클러스터 모드로 5개의 프로세스를 실행하도록 설정하였고, 두 번째는 포크(fork) 모드로 하나의 프로세스를 실행하도록 하였습니다. 이렇게 여러 개의 어플리케이션을 한번에 실행하도록 설정을 할 수도 있습니다. 실제로 동작하는 상태는 아래 그림과 같습니다. 프로세스 줄이기 프로세스의 수가 많다면 프로세스를 2개로 줄일 수 있습니다. 1[root@localhost test]$ pm2 scale app 2 재시작 1[root@localhost test]$ pm2 reload 중지 1[root@localhost test]$ pm2 stop app 삭제 1[root@localhost test]$ pm2 delete app 추가 설정 nodejs 권한이 잘못 되어있는 경우 1234[hgko@localhost test]$ sudo su[root@localhost test]$ cd /usr/local/lib[root@localhost lib]$ chown -R hgko:hgko nodejs[root@localhost lib]$ exit","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"}]},{"title":"[CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법","slug":"linux-7","date":"2020-10-12T01:30:46.000Z","updated":"2023-03-14T02:21:55.759Z","comments":true,"path":"2020/10/12/linux-7/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-7/","excerpt":"","text":"리눅스 환경에서 아파치 톰캣 설치 및 사용 방법에 대해 알아보겠습니다. 아파치 톰캣(Tomcat) 이란 아파치 톰캣(Apache Tomcat)은 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너(또는 웹 컨테이너)만 있는 웹 애플리케이션 서버이다. 톰캣은 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 자바서버 페이지(JSP)와 자바 서블릿이 실행할 수 있는 환경을 제공하고 있다. 톰캣은 관리툴을 통해 설정을 변경할 수 있지만, XML 파일을 편집하여 설정할 수도 있다. 그리고, 톰캣은 HTTP 서버도 자체 내장하기도 한다. 출처 : 위키백과 1. 다운로드 http://archive.apache.org/dist/tomcat/tomcat-8/ 사이트에서 최신 버전을 확인하고 다운로드합니다. 12[hgko@localhost ~]$ cd /home/download[hgko@localhost download]$ wget http://archive.apache.org/dist/tomcat/tomcat-8/v8.5.59/bin/apache-tomcat-8.5.59.tar.gz 오프라인 환경에서는 Tomcat 8 Download 사이트 접속해서 tar.gz 파일을 직접 다운로드 후 서버에 전송합니다. 2. 설치 먼저 tar 명령어를 사용하여 압축을 풀어 줍니다. 압축이 풀리면 모든 사용자가 사용하고 관리가 편리하도록 Root 계정으로 접속 후 해당 폴더로 이동 시켜줍니다. 123456# 압축 해제[hgko@localhost download]$ tar zxvf apache-tomcat-8.5.59.tar.gz# 폴더 이동[hgko@localhost download]$ sudo su[root@localhost download]$ mv /home/download/apache-tomcat-8.5.59 /usr/local/lib 3. 환경 설정 1[root@localhost ~]$ vi /etc/profile 123456JAVA_HOME=/usr/local/javaJRE_HOME=/usr/local/javaCATALINA_HOME=/usr/local/lib/apache-tomcat-8.5.59CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$CATALINA_HOME/lib/jsp-api.jar:$CATALINA_HOME/lib/servlet-api.jarPATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/binexport JAVA_HOME JRE_HOME CLASSPATH PATH CATALINA_HOME Tomcat 설정 부분(CATALINA)만 수정하면 됩니다. 설정이 완료되면 반영합니다. 12345# 설정 반영[root@localhost ~]$ source /etc/profile# 설정 확인[root@localhost ~]$ echo $CATALINA_HOME 4. 방화벽 설정 현재 톰캣 포트가 8080이기 때문에 8080 포트에 대한 방화벽을 설정합니다. 12[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=8080/tcp[root@localhost ~]$ firewall-cmd --reload 5. 실행 12[root@localhost ~]$ cd /usr/local/lib/apache-tomcat-8.5.59/bin[root@localhost bin]$ ./startup.sh 6. 중지 1[root@localhost bin]$ ./shutdown.sh 7. 실행 확인 http://localhost(ip 주소):8080 에 접속해서 확인합니다. 1[root@localhost bin]$ tail -f /usr/local/lib/apache-tomcat-8.5.59/logs/catalina.out tail 명령어를 사용하여 로그 내용을 출력해서 진행 상태를 파악할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"}]},{"title":"[CentOS] NFS 설치 및 설정","slug":"linux-6","date":"2020-10-12T00:42:48.000Z","updated":"2023-06-05T00:50:01.049Z","comments":true,"path":"2020/10/12/linux-6/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-6/","excerpt":"","text":"리눅스 환경에서 NFS 설치 및 설정 방법에 대해 알아보겠습니다. NFS 란 네트워크 파일 시스템(Network File System, NFS)은 1984년에 썬 마이크로시스템즈가 개발한 프로토콜이다. 클라이언트 컴퓨터의 사용자가 네트워크 상의 파일을 직접 연결된 스토리지에 접근하는 방식과 비슷한 방식으로 접근하도록 도와 준다. 다른 수많은 프로토콜과 마찬가지로 ONC RPC 시스템을 기반으로 한다. 네트워크 파일 시스템은 RFC에 정의된 오픈 표준이므로 누구나 구현할 수 있다. 출처 : 위키백과 운영환경 CentOS 7.6 NFS 서버 설정 1. 설치 nfs-utils 패키지가 설치 되어있는지 확인하고 없을 시 yum 을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 부팅 시 자동 시작되도록 서비스 등록을 하고 실행을 합니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트할 디렉토리 생성 마운트 할 임의의 디렉토리 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 마운트 설정을 위해 /etc/export 파일을 수정합니다. 1$ vi /etc/export 아래 내용을 추가합니다. 1/nfstest 192.168.0.*(rw,sync) /nfstest: 공유할 디렉토리 192.168.0.*: 허가할 호스트 대역 rw : 읽기, 쓰기 가능 ro : 읽기만 가능 secure : 클라이언트 마운트 요청 시 포트를 1024 이하로 설정 noaccess : 액세스 거부 root_squach : 클라이언트의 root가 서버의 root 권한을 획득하는 것을 차단 no_root_squash : 클라이언트의 계정을 root로 매핑 sync : 파일 시스템이 변경되면 즉시 동기화 all_squach : root를 제외하고 서버와 클라이언트의 사용자를 동일한 권한으로 설정 no_all_squach : root를 제외하고 서버와 클라이언트의 사용자들을 하나의 권한을 가지도록 설정 참고로 /etc/exports 에서 IP 입력 후 띄어쓰기 없이 (rw) 설정을 해야하고, 만약 띄어쓰기를 사용하면 설정이 제대로 되지 않아 Read-only 설정으로 되어 에러가 발생할 수 있습니다. 4. 수정내용 적용 수정한 export 내용을 적용합니다. 1$ exportfs -r 서비스를 재시작 합니다. 1$ systemctl restart nfs-server 5. 수정내용 확인 NFS 설정이 정상적으로 되었는지 확인합니다. 12$ showmount -e$ exportfs -v 클라이언트 마운트 설정 1. 설치 nfs-utils 패키지가 설치 되어있는지 확인하고 없을 시 yum 을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 서비스 등록 및 시작 명령어입니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트할 디렉토리 생성 마운트 할 임의의 디렉토리를 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 생성된 디렉토리에 NFS 디렉토리를 마운트 합니다. 1$ mount -t nfs 192.168.0.100:/nfstest /nfstest 192.168.0.100: nfs 서버 주소 5. 마운트 영구 적용 마운트 영구 적용을 위해 /etc/fstab 파일을 수정합니다. 12$ vi /etc/fstab192.168.0.100:/nfstest /nfstest nfs defaults 0 0 192.168.0.100: nfs 서버 주소 6. 마운트 확인 정상적으로 마운트 되었는지 확인을 합니다. 12$ df -h | grep nfs192.168.0.100:/nfstest 24G 6.4G 16G 30% /nfstest 7. 설정 확인 설정이 완료되었다면 /nfstest 경로에서 파일을 생성해보고 클라이언트와 서버에 제대로 공유가 되는지 확인합니다. 12[root@localhost ~]$ cd /nfstest[root@localhost nfstest]$ touch test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"}]},{"title":"[PostgreSQL] TimescaleDB 설치","slug":"postgresql-4","date":"2020-10-08T04:12:58.000Z","updated":"2023-05-30T14:16:20.087Z","comments":true,"path":"2020/10/08/postgresql-4/","link":"","permalink":"http://hgko1207.github.io/2020/10/08/postgresql-4/","excerpt":"","text":"TimescaleDB 란 TimescaleDB는 빠른 수집, 복잡한 쿼리를 편리하게 사용하기 위해 설계된 오픈 소스 시계열 데이터베이스 입니다. PostgreSQL을 기반으로 하며 자동 파티셔닝과 SQL 지원을 제공합니다. PostgreSQL 보다 10 ~ 100배 빠른 쿼리를 수행하고 시계열에 대해 최적화가 되어 있습니다. 5 ~ 10분 단위로 수집되는 많은 양의 데이터를 데이터베이스에 추가하고 시계열로 관리하며 빠르게 조회하기 위해 TimescaleDB를 사용하였습니다. 운영환경 CentOS 7.6 PostgreSQL 11 설치 PostgreSQL이 설치 되어있어야 합니다. 미설치 시 [PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작을 참고해서 설치합니다. 1. PostgreSQL 설치 확인 1$ rpm -qa | grep postgresql 2. 계정 확인 1$ cat /etc/passwd | grep postgres postgres 계정이 없으면 생성합니다. 12$ sudo useradd postgres$ sudo passwd postgres 3. 설정 변경 1234$ vi /var/lib/pgsql/11/data/postgresql.conf#listen_addresses = 'localhost' -&gt; listen_addresses = '*'#password_encryption = md5 -&gt; password_encryption = md5 4. TimescaleDB 다운로드 다음 명령어를 복사해서 붙여넣습니다. 123456789101112$ sudo cat &gt; /etc/yum.repos.d/timescale_timescaledb.repo &lt;&lt;EOL[timescale_timescaledb]name=timescale_timescaledbbaseurl=https://packagecloud.io/timescale/timescaledb/el/7/\\$basearchrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/timescale/timescaledb/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300EOL 12$ sudo yum update -y$ yum install -y timescaledb-postgresql-11 5. 데이터베이스 설정 계속 y를 눌러줍니다. 1$ sudo timescaledb-tune --pg-config=/usr/pgsql-11/bin/pg_config 6. PostgreSQL 재시작 1$ systemctl restart postgresql-11 7. 접속 123$ sudo su$ su - postgres$ psql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"}]},{"title":"[CentOS] Apache Kafka 설치 및 사용 방법","slug":"linux-5","date":"2020-10-01T13:16:06.000Z","updated":"2023-06-04T14:51:05.343Z","comments":true,"path":"2020/10/01/linux-5/","link":"","permalink":"http://hgko1207.github.io/2020/10/01/linux-5/","excerpt":"","text":"아파치 카프카(Apache Kafka)는 아파치 소프트웨어 재단이 스칼라로 개발한 오픈 소스 메시지 브로커 프로젝트이다. 출처 : 위키백과 메시지 큐를 사용하여 동기화 서비스 및 대용량 분산 시스템을 구축하기 위해 Zookeeper와 함께 Apache Kafka를 사용하게 되었습니다. 운영환경 CentOS 7.6 1. 다운로드 및 설치 123[root@localhost ~]$ cd /home/test[root@localhost test]$ wget http://apache.mirror.cdnetworks.com/kafka/2.1.0/kafka_2.11-2.3.0.tgz[root@localhost test]$ ln -s kafka_2.11-2.3.0 kafka 2. server.properties 수정 123456789101112[root@localhost test]$ vim kafka/config/server.properties# zookeeper 서버의 myid 값으로 설정broker.id=1#Broker가 받은 데이터를 관리위한 저장공간log.dirs=/home/test/kafka-logs#Broker가 사용하는 호스트와 포트를 지정listeners=PLAINTEXT://0.0.0.0:9002#Producer와 Consumer가 접근할 호스트와 포트를 지정, 기본값은 listeners를 사용advertised.listeners=PLAINTEXT://192.168.24.10:9092# zookeeper의 접속 정보zookeeper.connect=192.168.24.7:2181 3. 실행 12[root@localhost test]$ cd kafka/bin[root@localhost bin]$ ./kafka-server.start.sh ../config/server.properties 정상적으로 실행이 되면 다음과 같은 메시지가 뜹니다. 12....중략....[KafkaServer id=1] started (kafka.server.KafkaServer) 4. 서비스 등록 마지막으로 kafka-server.service라는 스크립트를 만들고 서비스에 등록합니다. 123# 종료 후 서비스 등록[root@localhost bin]$ ./kafka-server-stop.sh[root@localhost bin]$ vi /etc/systemd/system/kafka.service 1234567891011121314151617[Unit]Description=kafkaAfter=network.target[Service]Type=simpleUser=testGroup=testSyslogIdentifier=kafkaWorkingDirectory=/home/test/kafkaRestart=alwaysRestartSec=0sExecStart=/home/test/kafka/bin/kafka-server-start.sh /home/test/kafka/config/server.propertiesExecStop=/home/test/kafka/bin/kafka-server-stop.sh[Install]WantedBy=multi-user.target 저장하고 나서 서비스를 재시작하고 카프카를 실행합니다. 정상적으로 실행되면 시스템 부팅 시 자동실행 설정을 지정합니다. 12345678# 서비스 데몬 재시작[root@localhost ~]$ systemctl daemon-reload# 카프카 실행 (종료는 stop, 재시작은 restart)[root@localhost ~]$ systemctl start kafka-server.service# 실행상태 확인[root@localhost ~]$ systemctl status kafka-server.service# 시스템 부팅할때 자동실행 설정[root@localhost ~]$ systemctl enable kafka-server.service 방화벽 설정 1234[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=9092/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload kafka topic 관리 topic 리스트 123# 192.168.24.7는 zookeeper 접속 주소[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --list --zookeeper 192.168.24.7:2181 topic 생성 topic 명은 manager-out 로 설정하였습니다. 123[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --create --zookeeper 192.168.24.7:2181 --replication-factor 1 --partitions 5 --topic manager-out[root@localhost bin]$ ./kafka-topics.sh --zookeeper 192.168.24.7:2181 --alter --topic manager-out --config retention.ms=600000 topic 삭제 1[root@localhost bin]$ ./kafka-topics.sh --delete --zookeeper 192.168.24.7:2181 --topic manager-out topic 상세정보 1[root@localhost bin]$ ./kafka-topics.sh --describe --zookeeper 192.168.24.7:2181","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"}]},{"title":"[CentOS] Apache Zookeeper 설치 및 사용 방법","slug":"linux-4","date":"2020-09-28T01:36:53.000Z","updated":"2023-06-04T14:50:59.475Z","comments":true,"path":"2020/09/28/linux-4/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-4/","excerpt":"","text":"아파치 주키퍼(Apache ZooKeeper)는 아파치 소프트웨어 재단 프로젝트중의 한 소프트웨어 프로젝트로서 공개 분산형 구성 서비스, 동기 서비스 및 대용량 분산 시스템을 위한 네이밍 레지스트리를 제공한다. 주키퍼는 하둡의 한 하위 프로젝트이었으나 지금은 독립적인 상위 프로젝트이다. 출처 : 위키백과 위의 설명처럼 메시키 큐를 관리하고 동기 서비스 및 대용량 분산 시스템을 구축하기 위해 Apache ZooKeeper 를 사용할 경우가 있습니다. Apache ZooKeeper 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Java jdk 설치 먼저 java jdk를 필수로 설치를 합니다. 1[root@localhost ~]$ yum install java-1.8.0-openjdk.x86_64 profile 정보를 변경합니다. 1234[root@localhost ~]$ vim /etc/profile# profile 파일 안에 아래의 내용을 추가export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk source 명령어를 이용해서 변경된 내용 적용합니다. 1[root@localhost ~]$ source /etc/profile Zookeeper 설치 Zookeeper 서버 패키지를 다운로드 받고 환경 설정을 합니다. 1. 계정 생성 먼저 계정을 생성합니다. 계정을 생성하는 이유는 Zookeeper를 별도로 관리하기 위함입니다. 12[root@localhost ~]$ useradd zookeeper[root@localhost ~]$ passwd zookeeper 생성된 계정으로 변경합니다. 1[root@localhost ~]$ su - zookeeper 2. 다운로드 및 설치 다음의 명령어 순서대로 실행해서 다운로드 한 후 압축을 해제합니다. 1234[zookeeper@localhost ~]$ cd /home/test[zookeeper@localhost zookeeper]$ wget http://apache.mirror.cdnetworks.com/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ tar xvfzp zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ ln -s zookeeper-3.4.14 zookeeper 3. 설정 파일 변경 데이터 디렉터리 경로와 서버 설정을 합니다. 12345678[zookeeper@localhost test]$ cd zookeeper/conf[zookeeper@localhost conf]$ cp zoo_sample.cfg zoo.cfg[zookeeper@localhost conf]$ vim zoo.cfgdataDir=/home/test/zookeeper/data #zookeeper 데이터 위치, 원하는 경로에 저장입력server.1=zoo-1:2888:3888 #멀티 서버 설정 (주키퍼 서버가 한곳이 아닐때)# server.2=server_host_1:2888:3888# server.3=server_host_2:2888:3888 4. myid 생성 반드시 myid 파일을 dataDir 속성에 넣었던 경로에 만들어야 합니다. 호스트마다 아이디를 부여해야 합니다. 위의 설정에서 server.1에만 설정하였기 때문에 {dataDir}/myid 내부에 1이라는 값이 있어야 합니다. 그리고 이 값은 유일해야 하고 1~255 사이로 설정해야 합니다. 123[zookeeper@localhost ~]$ cd /home/test/zookeeper/data[zookeeper@localhost data]$ touch myid[zookeeper@localhost data]$ echo 1 &gt; myid 5. Zookeeper 서버 실행 다음 명령어를 실행하면 이상없이 서버가 실행됩니다. 12[zookeeper@localhost ~]$ cd /home/test/zookeeper/bin[zookeeper@localhost bin]$ ./zkServer.sh start 실행 확인 12[zookeeper@localhost bin]$ ./zkCli.sh -server zoo-1:2181[zookeeper@localhost bin]$ ls / Zookeeper 서버 중지 1[zookeeper@localhost bin]$ ./zkServer.sh stop 추가 설정 추가적으로 프로세스 저장 경로와 로그 저장 경로 변경 및 환경변수 등록을 위한 절차입니다. 변경하지 않아도 됩니다. 폴더 권한 변경 Zookeeper 프로세스 아이디 저장 폴더와 로그 저장 폴더를 생성하고 권한을 변경합니다. 1234567891011# root 계정으로 전환[zookeeper@localhost ~]$ su -[root@localhost ~]$ cd /var/run[root@localhost run]$ mkdir zookeeper[root@localhost run]$ chown zookeeper:zookeeper /var/run/zookeeper[root@localhost run]$ cd ../log[root@localhost log]$ mkdir zookeeper[root@localhost log]$ chown zookeeper:zookeeper /var/log/zookeeper# zookeeper 계정으로 다시 돌아가기[root@localhost log]$ exit 추가로 위 두개의 폴더에 링크를 생성합니다. 123[zookeeper@localhost log]$ cd /home/test/zookeeper[zookeeper@localhost zookeeper]$ ln -s /var/run/zookeeper/ pids[zookeeper@localhost zookeeper]$ ln -s /var/log/zookeeper/ logs 환경변수 변경 12345678910export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdkexport ZOOKEEPER_HOME=/home/test/zookeeperexport ZOOKEEPER_CONF_DIR=$ZOOKEEPER_HOME/confexport ZOOKEEPER_LOG_DIR=/var/log/zookeeperexport ZOO_LOG_DIR=$ZOOKEEPER_LOG_DIRexport ZOOKEEPER_PID_DIR=/var/run/zookeeperexport ZOOPIDFILE=$ZOOKEEPER_PID_DIR/zookeeper_server.pidexport SERVER_JVMFLAGS=-Xmx1024mexport JAVA=$JAVA_HOME/bin/javaexport CLASSPATH=$ZOOKEEPER_CONF_DIR:/usr/share/java/jline.jar:/usr/share/java/log4j-1.2.jar:/usr/share/java/xercesImpl.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/netty.jar:/usr/share/java/slf4j-api.jar:/usr/share/java/slf4j-log4j12.jar:/usr/share/java/zookeeper.jar 서버 재시작 12[zookeeper@localhost bin]$ ./zkServer.sh stop[zookeeper@localhost bin]$ ./zkServer.sh start 방화벽 설정 123456[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2181/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2888/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3888/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"}]},{"title":"[CentOS] Proxy 서버를 사용한 내부망 yum 사용 방법","slug":"linux-3","date":"2020-09-28T00:49:32.000Z","updated":"2023-06-05T00:49:39.017Z","comments":true,"path":"2020/09/28/linux-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-3/","excerpt":"","text":"서버가 운영되는 시스템은 인터넷이 안되는 시스템이 많습니다. 이런 상황에서 yum 을 통한 Package 를 설치할 수 없게 되어 관리가 쉽지 않습니다. Proxy 서버를 이용하여 인터넷이 가능한 하나의 서버 시스템을 통해 모든 서버가 인터넷이 가능하도록 구성 할 수 있습니다. 운영환경 CentOS 7.6 설치 인터넷이 되는 서버에 squid Package를 설치합니다. 1$ yum -y install squid 설정 다음과 같이 Proxy 정책을 설정합니다. 1$ vi /etc/squid/squid.conf 12345678910111213141516... 생략 ...# Only allow cachemgr access from localhost#http_access allow localhost manager#http_access deny managerhttp_access allow all # 모든 IP 에 대해 Allow 정책 추가# And finally deny all other access to this proxy#http_access deny all # deny 정책 해제... 생략 ...# Squid normally listens to port 3128http_port 8080 # Proxy 로 사용하길 원하는 Port 지정#http_port 3128 서비스 시작 12$ systemctl start squid$ systemctl status squid 정상적으로 Proxy 서비스가 안될경우 다음과 같이 커널 파라미터를 추가합니다. 12net.ipv6.conf.all.disable_ipv6 = 1net.ipv4.ip_forward = 1 Proxy 서비스 테스트 인터넷이 안되는 내부 시스템에서 다음 명령어를 실행합니다. 1234567891011121314[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorDetermining fastest mirrorsCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - \"Could not resolve host: mirrorlist.centos.org; Unknown error\"Loading mirror speeds from cached hostfileLoading mirror speeds from cached hostfileLoading mirror speeds from cached hostfilerepo id repo name statusbase/7/x86_64 CentOS-7 - Base 0extras/7/x86_64 CentOS-7 - Extras 0updates/7/x86_64 CentOS-7 - Updates 0repolist: 0[root@localhost ~]# 아직 yum 을 사용 할 수 없습니다. yum.conf 수정 /etc/yum.conf 파일에 다음과 같이 proxy 옵션을 추가합니다. 인터넷이 되는 시스템의 IP와 Port 정보를 입력합니다. 12345678910111213141516[root@localhost ~]# vi /etc/yum.conf[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-releaseproxy=http://192.168.100.200:8080 # Proxy 서버 정보 추가 테스트 yum 사용이 가능한지 다시 확인합니다. 12345678910111213141516[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorLoaded plugins: fastestmirror, langpacksRepository nodesource is listed more than once in the configurationRepository nodesource-source is listed more than once in the configurationLoading mirror speeds from cached hostfile * base: mirror.kakao.com * epel: ftp.riken.jp * extras: mirror.kakao.com * updates: mirror.kakao.comrepo id repo name statusbase/7/x86_64 CentOS-7 - Base 10,070extras/7/x86_64 CentOS-7 - Extras 413updates/7/x86_64 CentOS-7 - Updates 1,134repolist: 11,617[root@localhost ~]# 위와 같은 결과가 나타나면 yum 을 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"}]},{"title":"[CentOS] VNC 설치 및 사용 방법(오프라인 환경)","slug":"linux-2","date":"2020-09-19T12:18:14.000Z","updated":"2023-03-14T02:20:05.305Z","comments":true,"path":"2020/09/19/linux-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/19/linux-2/","excerpt":"","text":"오프라인 환경에서 VNC 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Server 설치 다운로드 http://mirror.centos.org/centos/7/os/x86_64/Packages/ 사이트에 접속 후 tigervnc-server-1.8.0-19.el7.x86_64.rpm 파일을 선택하여 다운 받습니다. 다운로드가 완료되면 파일을 리눅스 환경으로 이동시킵니다. 설치 및 설정 12345# 실행$ sudo rpm -ivh tigervnc-server-1.8.0-19.el7.x86_64.rpm# 1 입력 시 5901 포트번호로 생성됩니다.cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 12345$ vi /etc/systemd/system/vncserver@:1.service# 변경ExecStart=/usr/bin/vncserver_wrapper &lt;USER&gt; %i- &lt;USER&gt;를 서버 계정으로 변경 서비스 등록 12$ systemctl daemon-reload$ systemctl enable vncserver@:1.service 방화벽 설정 123456# 포트 열기$ firewall-cmd --zone=public --permanent --add-port=5901/tcp# 포트 갱신$ firewall-cmd --reload# 포트 확인$ firewall-cmd --zone=public --list-all Client 설치 및 접속 https://www.realvnc.com/en/connect/download/viewer/ 사이트 접속 후 Download VNC Viewer를 클릭하여 다운 받습니다. 다운로드가 완료되면 설치를 합니다. VNC Viewer 실행 후 상단 search 란에 host:5901 입력 후 Enter 키를 누릅니다. 서버 계정명과 패스워드를 입력하면 리눅스 환경의 화면이 나오는 것을 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"}]},{"title":"[Node.js] 시작 및 구성","slug":"nodejs-1","date":"2020-09-15T09:11:31.000Z","updated":"2023-05-30T14:00:12.647Z","comments":true,"path":"2020/09/15/nodejs-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/15/nodejs-1/","excerpt":"","text":"다운로드 및 설치 위의 페이지에 접속 한 후 플랫폼에 맞게 선택을 하여 다운로드합니다. Windows 환경에서 개발하기 위해 Windows Installer (.msi) 64-bit를 다운로드 합니다. 현재 최신 LTS 버전은 v16.17.0 버전입니다. 다운 받은 인스톨러 파일을 실행해서 설치를 진행합니다. 설치가 완료 되면 다음 명령어를 실행해서 확인을 합니다. 12345D\\&gt; node -vv16.17.0D\\&gt; npm -v8.15.0 Node.js 를 설치하면 자동으로 NPM 이 설치가 됩니다. npm (노드 패키지 매니저/Node Package Manager)은 자바스크립트 프로그래밍 언어를 위한 패키지 관리자이다. 자바스크립트 런타임 환경 Node.js의 기본 패키지 관리자이다. 출처 : 위키백과 시작 1. 작업 디렉터리 생성 12D:\\&gt; mkdir node_testD:\\&gt; cd node_test 2. 프로젝트 초기화 npm init 명령어를 실행하면 각 항목들을 설정할 수 있는데 아무것도 입력하지 않고 엔터만 치면 괄호안의 기본값 또는 빈값으로 설정이 됩니다. 최종적으로 모든 설정이 끝나면 package.json 파일의 경로와 내용이 출력되고 yes를 입력하게 되면 저장과 동시에 종료됩니다. 1234567891011121314151617181920212223242526272829303132333435D:\\node_test&gt; npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\\node_test\\package.json:&#123; \"name\": \"node_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125;Is this OK? (yes) yesD:\\node_test&gt; 3. 패키지 설치 npm install 명령어를 실행합니다. 1D:\\node_test&gt; npm install 설치된 패키지들은 node_modules 디렉터리에 저장됩니다. 4. 웹 사이트 구축 app.js 파일을 생성합니다. 1D:\\node_test&gt; copy /Y /b NUL app.js 간단하게 Node.js 시작 가이드에 있는 코드를 복사해서 붙여넣습니다. 123456789101112131415// app.jsconst http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 5. 실행 node app.js 명령어를 실행합니다. 12D:\\node_test&gt; node app.jsServer running at http://127.0.0.1:3000/ 실행이 완료되면 서버가 구동이 됩니다. 사이트에 접속 하면 Hello World 문자가 출력됩니다. 이로써 Node.js 설치와 초기 설정 및 실행을 완료하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[CentOS] 기본 명령어","slug":"linux-1","date":"2020-09-14T02:21:19.000Z","updated":"2023-03-14T02:19:57.438Z","comments":true,"path":"2020/09/14/linux-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/linux-1/","excerpt":"","text":"기본 명령어 명령어 설명 ll 해당 디렉토리 파일 목록 보기 ls -al 숨김 파일까지 보기 ls -lt 시간순으로 보기 hostname 호스트명 보기 cat [파일명]예) cat /etc/hosts 파일 내용 출력 vi [파일명]예) vi /etc/hosts 파일 내용 편집 mkdir [폴더명] 폴더 생성 touch [파일명] 파일 생성 rm [파일명] 파일 삭제 rm -f [파일명] 묻지 않고 삭제 rm -rf [폴더명] 폴더 삭제 cp [복사대상] [붙여넣을파일명] 파일 복사 cp -r [복사대상] [붙여넣을폴더명] 폴더 복사 mv [파일] [변경할파일] 파일 또는 폴더 이동 pwd 현재 경로 보기 서비스 명령어 설명 systemctl enable [서비스명] 서비스 등록 systemctl start [서비스명] 서비스 시작 systemctl stop [서비스명] 서비스 중지 systemctl restart [서비스명] 서비스 재시작 systemctl status [서비스명] 서비스 상태확인 systemctl list-unit-files | grep [서비스명] 서비스 검색 계정 명령어 설명 su [계정명] 접속 계정 변경 su - 예) su - root 다시 로그인 whoami 접속 사용자 확인 주요 명령어 명령어 설명 ssh 계정@IP주소예) ssh root@192.168.20.25 SSH 접속 scp 파일명 계정@IP주소:폴더위치 예) scp mydb.sql root@192.168.20.24:/home/sql 파일 이동 실시간 명령어 명령어 설명 watch [-d] [-n seconds] ‘command’ 기본 사용 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[PostgreSQL] Command 명령어","slug":"postgresql-3","date":"2020-09-14T01:40:09.000Z","updated":"2023-03-14T02:19:59.865Z","comments":true,"path":"2020/09/14/postgresql-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/postgresql-3/","excerpt":"","text":"명령어 PostgreSQL에 접속합니다. 1$ psql -U postgres 명령어 설명 \\list or \\l 데이터베이스 목록 조회 \\list+ or \\l+ 데이터베이스 목록 상세조회 \\c [DB Name] 다른 DB에 접속 \\d 테이블 목록 보기 \\dt [Table Name] 지정된 테이블 컬럼 목록 보기 \\dS 시스템 테이블 목록 보기 \\dv 뷰 목록 보기 \\ds 시퀀스 목록 보기 \\du 롤 목록 보기 \\dn 스키마 목록 보기 \\q psql 종료(Ctrl + d) 백업 및 복원 명령어 설명 pg_dump &gt; [백업파일명] 전체 백업 pg_dump [DB명] &gt; [백업파일명]예) pg_dump mydb &gt; db.sql 데이터베이스만 백업 psql -U postgres [DB명] &gt; [백업파일명] 데이터베이스만 백업 psql -f [백업파일명] [복원할 DB명]예) psql -f db.sql mydb DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다. psql [복원할 DB명] &lt; [백업파일명]예) psql mydb &lt; db.sql DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[PostgreSQL] 외부 접속 허용","slug":"postgresql-2","date":"2020-09-11T01:20:47.000Z","updated":"2023-06-04T14:49:07.229Z","comments":true,"path":"2020/09/11/postgresql-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/11/postgresql-2/","excerpt":"","text":"외부 접속 허용 설정 1. 사용자 비밀번호 설정 외부에서 접속 하기 위해선 우선 postgres 비밀번호를 설정해야 합니다. postgres 계정으로 접속합니다. 1$ su - postgres psql 12345# 비밀번호 설정\\password postgres# 종료\\q 2. 방화벽 개방 방화벽에서 5432 포트를 개방합니다. 12$ firewall-cmd --permanent --zone=public --add-port=5432/tcp$ firewall-cmd --reload 3. 설정 파일 변경 postgresql 접속 후 Data 디렉토리 확인을 할 수 있습니다. 12$ show data_directory;-&gt; /var/lib/pgsql/11/data postgresql.conf 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/postgresql.conf 설정 파일에서 다음과 같이 변경합니다. 12# listen_addresses = 'localhost' -&gt; 주석으로 되어있음listen_addresses = '*' 4. 보안 설정 변경 외부 접속을 위해 보안 설정을 변경합니다. root 계정으로 복귀합니다. 1$ su - root 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/pg_hba.conf 설정 정보를 다음과 같이 변경합니다. 123local all all peer =&gt; local all all md5host all all 127.0.0.1/32 ident =&gt; host all all 0.0.0.0/0 md5host all all ::1/128 ident =&gt; host all all ::1/128 md5 md5 : 패스워드를 md5로 암호화해서 전송 5. 서비스 재시작 1$ sudo systemctl restart postgresql-11 참고 아래 링크에서는 pg_hba.conf를 수정하지 않고 접근제어를 할 수 있도록 하는 방법이 설명되어 있는데 테스트 해보진 않았습니다. CentOS 7 에서 방화벽에 PostgreSQL 리스너 포트 등록하기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"}]},{"title":"[PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작","slug":"postgresql-1","date":"2020-09-10T09:22:53.000Z","updated":"2023-03-14T02:19:52.569Z","comments":true,"path":"2020/09/10/postgresql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/10/postgresql-1/","excerpt":"","text":"리눅스 환경에서 PostgreSQL 설치 및 시작 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 PostgreSQL 11.9 인터넷이 되는 환경 12345# Install the repository RPM:$ sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm# PostgreSQL을 설치합니다.$ sudo yum install -y postgresql11-server postgresql11-contrib 인터넷이 안되는 환경 1. RPM 다운로드 외부 환경에서 PostgreSQL Database Server 11 PGDG 페이지에 접속해서 RPM 파일들을 다운로드 하고 리눅스 환경으로 이동시킨다. postgresql11-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-contrib-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-libs-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-server-11.9-1PGDG.rhel7.x86_64.rpm 2. 설치 postgresql11-libs -&gt; postgresql11 -&gt; (postgresql11-server, postgresql11-contrib) 순으로 설치합니다. 1234sudo rpm -ivh postgresql11-libs-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-server-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-contrib-11.5-1PGDG.rhel7.x86_64.rpm 설치된 패키지 확인 1$ rpm -qa | grep postgresql 기본 Database 생성 initdb 명령어를 통해 기본 데이터베이스를 설치합니다. 기본 데이터베이스는 postgres 라는 이름으로 생성됩니다. 1$ sudo /usr/pgsql-11/bin/postgresql-11-setup initdb 서비스 등록 및 실행 12$ sudo systemctl enable postgresql-11$ sudo systemctl start postgresql-11 postgresql 접속 1$ sudo -u postgres psql 데이터베이스 생성 1postgres=# create database &lt;name&gt; encoding 'utf-8';","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"}]},{"title":"[WPF] Event Notifier","slug":"wpf-1","date":"2020-09-07T01:40:55.000Z","updated":"2023-07-20T01:07:23.365Z","comments":true,"path":"2020/09/07/wpf-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/07/wpf-1/","excerpt":"","text":"컴포넌트 간의 데이터를 주고 받을 경우 Prism의 EventAggregator를 사용하면 편리하지만 WPF 만을 사용할 경우 아래 코드와 같이 구성하여 사용하였습니다. Event Manager EventManager.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace Tool.Event&#123; public class EventManager &#123; public delegate void EventHandler(); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish() &#123; event?.Invoke(); &#125; &#125; public class EventManager&lt;T&gt; &#123; public delegate void EventHandler(T item); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish(T item) &#123; event?.Invoke(item); &#125; &#125;&#125; Event Notifier EventNotifier.cs 1234567891011namespace Tool.Event&#123; public class EventNotifier &#123; public static EventManager&lt;string&gt; InputDataEvent = new EventManager&lt;string&gt;(); public static EventManager OpenEvent = new EventManager(); public static EventManager CloseEvent = new EventManager(); &#125;&#125; 사용 예 이벤트 등록 12345678910111213141516namespace Tool.Views&#123; public partial class TestWindow : Window &#123; public TestWindow() &#123; InitializeComponent(); &#125; private void CloseClick(object sender, RoutedEventArgs e) &#123; this.Close(); EventNotifier.CloseEvent.Publish(); &#125; &#125;&#125; 이벤트 받기 123456789101112131415namespace Tool.ViewModwl&#123; public class MainWindowViewModwl &#123; public MainWindow() &#123; EventNotifier.CloseEvent.Subscribe(CloseEvent); &#125; private void CloseEvent() &#123; Console.WriteLine(\"CloseEvent\"); &#125; &#125;&#125; 위의 코드는 다른 Window 에서 창을 종료시 메인 Window 의 기능을 수행하기 위한 예제입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[Docker] 주요 명령어 및 기본 사용법","slug":"docker-1","date":"2020-09-06T12:57:13.000Z","updated":"2023-05-30T13:58:54.862Z","comments":true,"path":"2020/09/06/docker-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/06/docker-1/","excerpt":"","text":"리눅스 환경에서 Docker 명령어와 기본 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 설치 1$ yum install docker 설치가 완료되면 버전을 조회하여 설치 확인을 합니다. 1$ docker -v 컨테이너 생성 및 실행 docker run 명령어는 컨테이너를 생성 및 실행과 동시에 컨테이너 내부로 들어갑니다. 기본 포맷입니다. 1$ docker run (&lt;옵션&gt;) &lt;이미지 식별자&gt; (&lt;명령어&gt;) (&lt;인자&gt;) 예시입니다. 가독성을 위해 (역슬래시)를 이용해 각 설정 옵션을 구분합니다. 1234567$ docker run -d \\ --name hgko.default.local \\ --privileged \\ -h hgko --network insnet \\ -v /data:/data \\ -p 5914:5901 \\ hgko 간략한 예시입니다. 1$ docker run -d -i -t test /bin/bash Run 옵션 목록 -d : 컨테이너를 백그라운드로 실행해야 할 때 사용 -name : 컨테이너를 식별할 수 있도록 이름을 부여 -h : 컨테이너 호스트 이름 설정 -v : 볼륨 마운트 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 디렉토리 마운트) -p : 포트 연결 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 포트간의 연결) --link : 내부 IP를 알 필요 없이 항상 컨테이너에 별명으로 접근하도록 설정 --privileged : 시스템 내 장치 등 주요 자원에 접근하며 커널의 기능을 대부분 사용할 수 있도록 설정 컨테이너 생성 docker create 명령어는 컨테이너를 생성만 할 뿐 컨테이너 내부로 들어가지 않습니다. 1$ docker create -i -t --name mycentos centos:7 컨테이너 실행 다음 명령어를 실행하여 컨테이너를 시작합니다. 1$ docker start mycentos 컨테이너 내부로 들어갑니다.(단, -i -t 옵션을 사용 했을 때) 1$ docker attach mycentos 컨테이너 내부 셸 사용 mycentos 컨테이너 내부에 bash 프로세스를 실행하고, -i -t 옵션을 사용해서 bash 셸을 쓸 수 있게 유지합니다. 12$ docker exec -i -t mycentos \\bin\\bash$ docker exec -i -t mycentos bash 컨테이너 내부에서 빠져나오기 컨테이너 내부에서 빠져나오는 방법은 두 가지가 있습니다. 첫 번째는 컨테이너 셸에서 exit를 입력하거나 Ctrl + D를 동시에 입력하는 것 입니다. 이 방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이서를 정지시킵니다. 두 번째는 Ctrl + P, Q를 입력하는 것 입니다. 이 방법은 컨테이너를 정지하지 않고 빠져나옵니다. 컨테이너 확인 정지되지 않은 컨테이너만 출력합니다. 1$ docker ps 정지된 컨테이너를 포함한 모든 컨테이너를 출력합니다. 1$ docker ps -a 출력 결과가 줄바꿈되어 알아보기 힘들 때 --format 옵션을 사용합니다/ 1$ docker ps --format \"table &#123;&#123;.ID&#125;&#125;\\&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\" 특정 컨테이너를 출력합니다. 1$ docker ps | grep mycentos 컨테이너 이름 변경 1$ docker rename mycentos my_centos 컨테이너 삭제 정지된 컨테이너만 삭제 가능합니다. 1$ docker rm mycentos 실행 중인 컨테이너도 삭제 가능합니다. (-f : 강제 삭제) 1$ docker rm -f mycentos 모든 컨테이너 삭제 가능합니다. 1$ docker container prune 이미지 목록 1$ docker images 이미지 삭제 1$ docker rmi &lt;이미지 식별자&gt; 이미지 빌드 1$ docker build -t hgko ./image/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[딥러닝] Preprocess 준비","slug":"ai-preprocess-1","date":"2020-09-01T14:10:35.000Z","updated":"2023-07-18T04:14:09.880Z","comments":true,"path":"2020/09/01/ai-preprocess-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/ai-preprocess-1/","excerpt":"","text":"로컬 데이터를 불러와 전처리시 필요한 내용이다. Load Packages 12345678910import osfrom glob import globimport numpy as npimport tensorflow as tffrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 12345678910# 현재 경로를 알려준다.os.getcwd()# 경로를 넣으면 경로의 파일명만 목록 형식으로 보여준다.os.listdir()os.listdir('dataset/mnist_png/training/')# 경로가 포함된 모든 파일들을 목록 형식으로 보여준다.# 원하는 포맷의 파일만을 가져올 수 있습니다.(png, txt 등)glob('dataset/mnist_png/training/*.png') 데이터 분석 123456label_nums = os.listdir('dataset/mnist_png/training/')&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']# Label 데이터 갯수 확인len(label_nums)&gt; 10 데이터 별 갯수 비교 1234567nums_dataset = []for lbl_n in label_nums: data_per_class = os.listdir('../dataset/mnist_png/training/' + lbl_n) nums_dataset.append(len(data_per_class))&gt; [5923, 6742, 5958, 6131, 5842, 5421, 5918, 6265, 5851, 5949] TensorFlow로 열기 12gfile = tf.io.read_file(path)image = tf.io.decode_image(gfile) 데이터 이미지 사이즈 알기 123456789101112from tqdm import tqdm_notebookheights = []widths = []for path in tqdm_notebook(data_paths): image_pil = Image.open(path) image = np.array(image_pil) h, w = image.shape heights.append(h) widths.append(w)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[C++] DLL 동적 로딩","slug":"cpp-coding-2","date":"2020-09-01T09:46:17.000Z","updated":"2023-07-18T04:14:41.812Z","comments":true,"path":"2020/09/01/cpp-coding-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/cpp-coding-2/","excerpt":"","text":"DLL 동적 로딩 특정 폴더 내에 다수의 DLL 라이브러리 파일들을 로딩하기 위한 코드다. Header 파일 1234567891011121314151617181920// dllload.h#include &lt;iostream&gt;class DLLLoad&#123;public: DLLLoad() &#123;&#125; ~DLLLoad() &#123;&#125; bool LoadLibrary(); bool FreeLibrary();private: // DLL 폴더 경로를 설정한다. const std::string DLL_DIR; // 로딩된 DLL 파일 경로들을 저장하고 관리한다. std::list&lt;std::string&gt; fileList;&#125; C++ 파일 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// dllload.cpp#include \"dllload.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;const std::string DLLLoad::DLL_DIR = \"C:\\\\dll\\\\\";DLLLoad::DLLLoad() &#123;&#125;DLLLoad::~DLLLoad() &#123;&#125;// DLL 라이브러리들을 동적 로딩한다.bool DLLLoad::LoadLibrary()&#123; // 처음 DLL 로드 이후에는 다시 로드하지 않는다. if (fileList.size() == 0) &#123; std::string input = DLL_DIR + \"*.dll\"; WIN32_FIND_DATA FindData; HANDLE hFind = FindFirstFile(input.c_str(), &amp;FindData); if (hFind == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; \"Error - Can't find a file : \" &lt;&lt; FindData.cFileName &lt;&lt; std::endl; return false; &#125; do &#123; if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_ARCHIVE) // 파일만 검색 &#123; std::string dir = CSM_DLL_DIR + FindData.cFileName; HINSTANCE hmodule = LoadLibrary(dir.c_str()); if (hmodule != NULL) &#123; fileList.push_back(dir); &#125; &#125; &#125; while (FindNextFile(hFind, &amp;FindData) != 0); FindClose(hFind); &#125; return true;&#125;// 로딩된 DLL 라이브러리들을 해제한다.bool DLLLoad::FreeLibrary()&#123; for (std::string file : fileList) &#123; HINSTANCE hmodule = GetModuleHandle(file.c_str()); if (hmodule != NULL) &#123; FreeLibrary(hmodule); &#125; &#125; return true;&#125; Main 함수 123456int main()&#123; DLLLoad dllLoad = new DLLLoad(); dllLoad-&gt;LoadLibrary(); dllLoad-&gt;FreeLibrary();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[MSSQL] Geometry Query","slug":"mssql-1","date":"2020-09-01T08:38:30.000Z","updated":"2023-03-14T02:19:43.856Z","comments":true,"path":"2020/09/01/mssql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/mssql-1/","excerpt":"","text":"Geometry 데이터 형식 쿼리 STContains STContains(geometry 데이터 형식) geometry 인스턴스에 다른 geometry 인스턴스가 완전히 포함되어 있으면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STContains(@h); POINT 좌표가 POLYGON 좌표에 완전히 포함되어 있지 않기 때문에 결과는 0을 반환합니다. STIntersects STIntersects(geometry 데이터 형식) geometry 인스턴스가 다른 geometry 인스턴스와 교차하면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STIntersects(@h); POINT 좌표가 POLYGON 좌표와 교차하기 때문에 결과는 1을 반환합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"}]},{"title":"[딥러닝] 교육자료","slug":"ai-deep-1","date":"2020-08-21T08:24:38.000Z","updated":"2023-07-18T04:13:41.727Z","comments":true,"path":"2020/08/21/ai-deep-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/ai-deep-1/","excerpt":"","text":"딥러닝 교육자료 딥러닝을 배우기 위한 강의 사이트와 책을 정리하였다. 교육 사이트 프로그래머스 - https://programmers.co.kr/ 에드윗 - https://www.edwith.org/ 입문 강의 파이썬 입문 - https://programmers.co.kr/learn/courses/2 딥러닝 입문(Tensorflow) - https://www.edwith.org/others26 입문 블로그 딥러닝 입문(Keras) - https://tykimos.github.io/lecture/ 딥러닝 책 밑바닥부터 시작하는 딥러닝(기초) DeepLearningBook(심화) 머신러닝 책 핸즈온 머신러닝(심화) PRML(심화)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[Web Design] Canvas","slug":"web-design-1","date":"2020-08-21T07:59:04.000Z","updated":"2023-07-18T04:13:52.343Z","comments":true,"path":"2020/08/21/web-design-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/web-design-1/","excerpt":"","text":"HTML 템플릿 회사 홈페이지 및 블로그 형태의 사이트 제작 요청이 있어 디자인 템플릿을 찾아보던 중 심플하기도 하고 이쁜 HTML 템플릿을 찾게 되었다. Canvas The Multi-Purpose HTML5 Template Canvas는 Mulit-Page 및 One-Page 사이트를 제공하고 반응형을 지원하는 다목적 HTML5 템플릿이다. 비즈니스, 의료, SEO, 여행, 건설, 부동산, 요가, 뷰티, 기사, 사진, 뉴스, 대여, 이력서, 블로그, 웨딩, 음악, 앱 쇼케이스, 애완 동물, 스토어 등 120개 이상의 즉시 사용 가능한 홈페이지 템플릿을 제공합니다. 유료 이지만 가격도 저렴해서 가성비가 좋다. 빠르게 개발을 해야 하거나 디자인 비용을 절감해야 할 때 사용하면 좋은 사이트를 제작할 수 있을 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"}]},{"title":"TensorFlow 2.0과 PyTorch 비교","slug":"ai-dev-8","date":"2020-08-13T07:36:58.000Z","updated":"2023-03-14T02:19:19.731Z","comments":true,"path":"2020/08/13/ai-dev-8/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-dev-8/","excerpt":"","text":"TensorFlow 2.0 123import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Hyperparameter 1234567batch_size = 64learning_rate = 0.001dropout_rate = 0.7input_shape = (28, 28, 1)num_classes = 10 Preprocess 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Build Model 1234567891011121314151617181920212223inputs = layers.Input(input_shape)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(dropout_rate)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), # Optimization loss='sparse_categorical_crossentropy', # Loss Function metrics=['accuracy']) # Metrics / Accuracy Training 1234567model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# OutTrain on 60000 samples60000/60000 [==============================] - 6s 103us/sample - loss: 0.3794 - accuracy: 0.8767 12model.evaluate(test_x, test_y, batch_size=batch_size)=&gt; [0.06760077927671373, 0.9776] PyTorch 12345678import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optim# 이미지 데이터를 관리하기 위한 라이브러리from torchvision import datasets, transforms Hyperparameter 12345678910111213# 랜덤 값을 고정시키기 위해seed = 1lr = 0.001momentum = 0.5batch_size = 64test_batch_size = 64epochs = 5no_cuda = Falselog_interval = 100 Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Preprocess 12345678910111213141516171819202122torch.manual_seed(seed)use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")kwargs = &#123;'num_workers': 1, 'pin_memory': True&#125; if use_cuda else &#123;&#125;train_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True, **kwargs)test_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True, **kwargs) Optimization 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=lr, momentum=momentum) Training 12345678910111213141516171819202122232425262728293031323334for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() # backpropagation 계산하기 전에 0으로 기울기 계산 output = model(data) loss = F.nll_loss(output, target) # https://pytorch.org/docs/stable/nn.html#nll-loss loss.backward() # 계산한 기울기를 optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) # Test mode model.eval() # batch norm이나 dropout 등을 train mode 변환 test_loss = 0 correct = 0 with torch.no_grad(): # autograd engine, 즉 backpropagatin이나 gradient 계산 등을 꺼서 memory usage를 줄이고 속도를 높임 for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() # sum up batch loss pred = output.argmax(dim=1, keepdim=True) # get the index of the max log-probability correct += pred.eq(target.view_as(pred)).sum().item() # pred와 target과 같은지 확인 test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) 결과 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Train Epoch: 1 [0/60000 (0%)] Loss: 2.300039Train Epoch: 1 [6400/60000 (11%)] Loss: 2.239658Train Epoch: 1 [12800/60000 (21%)] Loss: 2.133953Train Epoch: 1 [19200/60000 (32%)] Loss: 2.007281Train Epoch: 1 [25600/60000 (43%)] Loss: 1.656340Train Epoch: 1 [32000/60000 (53%)] Loss: 1.400340Train Epoch: 1 [38400/60000 (64%)] Loss: 0.864186Train Epoch: 1 [44800/60000 (75%)] Loss: 0.613089Train Epoch: 1 [51200/60000 (85%)] Loss: 0.615066Train Epoch: 1 [57600/60000 (96%)] Loss: 0.427881Test set: Average loss: 0.4822, Accuracy: 8651/10000 (87%)Train Epoch: 2 [0/60000 (0%)] Loss: 0.635855Train Epoch: 2 [6400/60000 (11%)] Loss: 0.361398Train Epoch: 2 [12800/60000 (21%)] Loss: 0.457372Train Epoch: 2 [19200/60000 (32%)] Loss: 0.393982Train Epoch: 2 [25600/60000 (43%)] Loss: 0.536390Train Epoch: 2 [32000/60000 (53%)] Loss: 0.258121Train Epoch: 2 [38400/60000 (64%)] Loss: 0.413061Train Epoch: 2 [44800/60000 (75%)] Loss: 0.174248Train Epoch: 2 [51200/60000 (85%)] Loss: 0.222638Train Epoch: 2 [57600/60000 (96%)] Loss: 0.401988Test set: Average loss: 0.2956, Accuracy: 9128/10000 (91%)Train Epoch: 3 [0/60000 (0%)] Loss: 0.425370Train Epoch: 3 [6400/60000 (11%)] Loss: 0.242881Train Epoch: 3 [12800/60000 (21%)] Loss: 0.266271Train Epoch: 3 [19200/60000 (32%)] Loss: 0.344442Train Epoch: 3 [25600/60000 (43%)] Loss: 0.271553Train Epoch: 3 [32000/60000 (53%)] Loss: 0.233463Train Epoch: 3 [38400/60000 (64%)] Loss: 0.206387Train Epoch: 3 [44800/60000 (75%)] Loss: 0.289864Train Epoch: 3 [51200/60000 (85%)] Loss: 0.227708Train Epoch: 3 [57600/60000 (96%)] Loss: 0.266247Test set: Average loss: 0.2279, Accuracy: 9320/10000 (93%)Train Epoch: 4 [0/60000 (0%)] Loss: 0.197864Train Epoch: 4 [6400/60000 (11%)] Loss: 0.334545Train Epoch: 4 [12800/60000 (21%)] Loss: 0.171417Train Epoch: 4 [19200/60000 (32%)] Loss: 0.261458Train Epoch: 4 [25600/60000 (43%)] Loss: 0.129152Train Epoch: 4 [32000/60000 (53%)] Loss: 0.129057Train Epoch: 4 [38400/60000 (64%)] Loss: 0.203361Train Epoch: 4 [44800/60000 (75%)] Loss: 0.304724Train Epoch: 4 [51200/60000 (85%)] Loss: 0.136878Train Epoch: 4 [57600/60000 (96%)] Loss: 0.171525Test set: Average loss: 0.1808, Accuracy: 9482/10000 (95%)Train Epoch: 5 [0/60000 (0%)] Loss: 0.199721Train Epoch: 5 [6400/60000 (11%)] Loss: 0.246554Train Epoch: 5 [12800/60000 (21%)] Loss: 0.217517Train Epoch: 5 [19200/60000 (32%)] Loss: 0.255912Train Epoch: 5 [25600/60000 (43%)] Loss: 0.182075Train Epoch: 5 [32000/60000 (53%)] Loss: 0.296272Train Epoch: 5 [38400/60000 (64%)] Loss: 0.283726Train Epoch: 5 [44800/60000 (75%)] Loss: 0.239351Train Epoch: 5 [51200/60000 (85%)] Loss: 0.293096Train Epoch: 5 [57600/60000 (96%)] Loss: 0.157650Test set: Average loss: 0.1533, Accuracy: 9581/10000 (96%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Evaluating 및 Predicting","slug":"ai-pytorch-5","date":"2020-08-13T07:11:54.000Z","updated":"2023-07-18T04:13:35.982Z","comments":true,"path":"2020/08/13/ai-pytorch-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-5/","excerpt":"","text":"이전 블로그를 이어서 진행해본다. Evaluation model.train() 모드로 변한 것 처럼 평가할 때는 model.eval() 으로 설정한다. 1234567891011# Test mode# batch norm이나 dropout 등을 train mode 변환model.eval()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) torch.no_grad() 함수는 autograd engine, 즉 backpropagatin 이나 기울기 계산 등을 꺼서 memory usage 를 줄이고 속도를 높인다. 12345678910111213141516171819test_loss = 0correct = 0with torch.no_grad(): data, target = next(iter(test_loader)) data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct = pred.eq(target.view_as(pred)).sum().item()# Outtest_loss : 29.74889373779297correct : 54test_loss /= len(test_loader.dataset)=&gt; 0.0029748893737792967 정리 1234567891011121314151617181920model.eval()test_loss = 0correct = 0with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item()test0_loss /= len(test_loader.dataset)print('\\nTest set: Average Loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset)))# OutTest set: Average Loss: 0.4799, Accuracy: 8660/10000 (87%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Optimizer 및 Training","slug":"ai-pytorch-4","date":"2020-08-13T04:48:37.000Z","updated":"2023-07-18T04:13:15.068Z","comments":true,"path":"2020/08/13/ai-pytorch-4/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-4/","excerpt":"","text":"Optimization &amp; Training https://github.com/pytorch/examples/tree/master/mnist Load Packages 1234567import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsimport numpy as np 1234567no_cuda = False# cuda를 사용할지 안할지use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")=&gt; device(type='cuda') Preprocess 12345678910111213141516171819202122seed = 1batch_size = 64test_batch_size = 64torch.manual_seed(seed)train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True) Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Optimization Model과 Optimization를 설정한다. SGD 사용 확률적 경사 하강법(Stochastic Gradient Descent, SGD) 옵티마이저 Lr(learning Rate) : 0 보다 크거나 같은 float 값. 학습률 momentum: 0 보다 크거나 같은 float 값. SGD를 적절한 방향으로 가속화하며, 흔들림(진동)을 줄여주는 매개변수 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.5) parameters를 확인합니다. 12345678910111213params = list(model.parameters())for i in range(8): print(params[i].size())# Weight, Bais를 순서대로 보여준다.torch.Size([20, 1, 5, 5])torch.Size([20])torch.Size([50, 20, 5, 5])torch.Size([50])torch.Size([500, 800])torch.Size([500])torch.Size([10, 500])torch.Size([10]) Before Training 학습하기 전에 Model이 Train할 수 있도록 Train Mode로 변환한다. Convolution 또는 Linear 뿐만 아니라, DropOut과 Batch Normalization과 같이 parameter를 가진 Layer들도 학습하기 위해 준비한다. 12345678910# train modemodel.train()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) 모델에 넣기 위한 첫 Batch 데이터를 추출하고 cpu 또는 gpu device에 컴파일한다. 12345data, target = next(iter(train_loader))data, target = data.to(device), target.to(device)data.shape, target.shape=&gt; (torch.Size([64, 1, 28, 28]), torch.Size([64])) 기울기(gradients)를 clear해서 새로운 최적화 값을 찾기 위해 준비한다. 그리고 준비한 데이터를 model에 넣어 output을 얻습니다. Model에서 예측한 결과를 Loss Function에 넣는다. 12345optimizer.zero_grad()output = model(data)# Negative Log-Likelihood Loss 사용loss = F.nll_loss(output, target) Back Propagation을 통해 기울기를 계산한다. 계산된 기울기는 Parameter에 업데이트를 한다. 1234# 기울기 계산loss.backward()# Updateoptimizer.step() Start Training 위의 최적화 과정을 반복하여 학습을 시작한다. 12345678910111213141516171819202122232425262728293031epochs = 1log_interval = 100for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100 * batch_idx / len(train_loader), loss.item() ))# OutTrain Epoch: 1 [0/60000 (0%)] Loss: 2.290735Train Epoch: 1 [6400/60000 (11%)] Loss: 2.228956Train Epoch: 1 [12800/60000 (21%)] Loss: 2.121080Train Epoch: 1 [19200/60000 (32%)] Loss: 1.893549Train Epoch: 1 [25600/60000 (43%)] Loss: 1.570034Train Epoch: 1 [32000/60000 (53%)] Loss: 1.213198Train Epoch: 1 [38400/60000 (64%)] Loss: 0.993993Train Epoch: 1 [44800/60000 (75%)] Loss: 0.778737Train Epoch: 1 [51200/60000 (85%)] Loss: 0.732925Train Epoch: 1 [57600/60000 (96%)] Loss: 0.624502","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 각 Layer별 역할 및 파라미터","slug":"ai-pytorch-3","date":"2020-08-13T02:31:56.000Z","updated":"2023-07-18T04:12:30.053Z","comments":true,"path":"2020/08/13/ai-pytorch-3/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-3/","excerpt":"","text":"PyTorch Layer 이해하기 Load Packages 123456import torchfrom torchvision import datasets, transformsimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline 예제 불러오기 1234567891011train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor() ])), batch_size=1)image, label = next(iter(train_loader))image.shape, label.shape=&gt; (torch.Size([1, 1, 28, 28]), torch.Size([1])) 12plt.imshow(image[0, 0, :, :], 'gray')plt.show() 각 Layer별 설명 Network 쌓기 위한 준비를 합니다. 123import torchimport torch.nn as nnimport torch.nn.functional as F Convolution in_channels : 받게 될 channel의 갯수 out_channels : 보내고 싶은 channel의 갯수 kernel_size : 만들고 싶은 kernel(weights)의 사이즈 1234# Device type : cpu, cuda, mkldnn, opengl, opencl, ideep, hip, msnpulayer = nn.Conv2d(in_channels=1, out_channels=20, kernel_size=5, stride=1).to(torch.device('cpu'))=&gt; Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) weight 시각화를 위해 slice하고 numpy화 합니다. 1234weight = layer.weightweight.shape=&gt; torch.Size([20, 1, 5, 5]) 여기서 weight는 학습 가능한 상태이기 때문에 바로 numpy로 뽑아낼 수 없다. detach() method는 그래프에서 잠깐 꺼내서 gradient에 영향을 받지 않게 한다. 1234weight = weight.detach().numpy()weight.shape=&gt; (20, 1, 5, 5) 123plt.imshow(weight[0, 0, :, :], 'jet')plt.colorbar()plt.show() output 시각화 준비를 위해 numpy화 합니다. 123456output_data = layer(image)output_data = output_data.dataoutput = output_data.cpu().numpy()output.shape=&gt; (1, 20, 24, 24) input으로 들어간 이미지 numpy화 한다. 1234image_arr = image.numpy()image_arr.shape=&gt; (1, 1, 28, 28) 1234567891011plt.figure(figsize=(15, 30))plt.subplot(131)plt.title('Input')plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(132)plt.title('Weight')plt.imshow(weight[0, 0, :, :], 'jet')plt.subplot(133)plt.title('Output')plt.imshow(output[0, 0, :, :], 'gray')plt.show() Pooling input을 먼저 앞에 넣고, 뒤어 kernel 사이즈와 stride를 순서대로 넣는다. 1234pool = F.max_pool2d(image, 2, 2)pool.shape=&gt; torch.Size([1, 1, 14, 14]) MaxPool Layer는 weight가 없기 때문에 바로 numpy() 사용 가능하다. 1234pool_arr = pool.numpy()pool_arr.shape, image_arr.shape=&gt; ((1, 1, 14, 14), (1, 1, 28, 28)) 12345678plt.figure(figsize=(10, 15))plt.subplot(121)plt.title(\"Input\")plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(122)plt.title('Output')plt.imshow(np.squeeze(pool_arr), 'gray')plt.show() Linear nn.Linear는 2D가 아닌 1D만 들어가기 때문에 view() 함수를 사용하여 1D로 펼쳐줘야 한다. 12345# image size가 28 이기 때문에 28 * 28을 넣는다.flatten = image.view(1, 28 * 28)flatten.shape=&gt; torch.Size([1, 784]) 123456789lin = nn.Linear(784, 10)(flatten)lin.shape=&gt; torch.Size([1, 10])lin=&gt; tensor([[-0.1198, 0.2404, -0.0522, -0.3474, -0.3997, -0.0318, -0.0630, 0.2680, 0.1849, 0.1000]], grad_fn=&lt;AddmmBackward&gt;) 12plt.imshow(lin.detach().numpy(), 'jet')plt.show() Softmax 결과를 numpy로 꺼재기 위해선 weight가 담긴 Linear에 weight를 꺼줘야 한다. 123456789with torch.no_grad(): flatten = image.view(1, 28 * 28) lin = nn.Linear(784, 10)(flatten) softmax = F.softmax(lin, dim=1)softmax=&gt; tensor([[0.0846, 0.1084, 0.0792, 0.1265, 0.1004, 0.0897, 0.0990, 0.1113, 0.1239, 0.0769]]) 12np.sum(softmax.numpy())=&gt; 0.99999994 Layer 쌓기 예제 출처 : https://pytorch.org/tutorials/beginner/pytorch_with_examples.html#id23 nn 과 nn.functional의 차이점 nn은 학습 파라미터가 담긴 것 nn.functional은 학습 파라미터가 없는 것 123456789101112131415161718192021class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): # Feature Extraction x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) # Fully Connected (Classficiation) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) image를 Model에 넣어서 결과를 확인한다. 12345model = Net()result = model.forward(image)=&gt; tensor([[-2.3262, -2.2901, -2.2722, -2.2262, -2.3148, -2.3693, -2.2773, -2.2977, -2.3222, -2.3371]], grad_fn=&lt;LogSoftmaxBackward&gt;)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 데이터 불러오기","slug":"ai-pytorch-2","date":"2020-08-13T01:14:45.000Z","updated":"2023-07-18T04:11:52.897Z","comments":true,"path":"2020/08/13/ai-pytorch-2/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-2/","excerpt":"","text":"PyTorch Data Preprocess 12import torchfrom torchvision import datasets, transforms Import Error 1ImportError: cannot import name 'PILLOW_VERSION' from 'PIL' pillow 버전이 7.0.0 이상 일경우 Import 에러 나는 경우가 있다. 아래 처럼 pillow 버전을 내려주면 해결이 된다. 1$ pip install pillow==6.2.2 Data Loader 부르기 Pytorch는 DataLoader를 불러 model에 넣는다. 12345678910batch_size = 32train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset/', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize(mean=(0.5,), std=(0.5,)) ])), batch_size=batch_size, shuffle=True) 12345678910test_batch_size = 32test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5)) ])), batch_size=test_batch_size, shuffle=True) 첫번째 iteration에서 나오는 데이터 확인 1234images, labels = next(iter(train_loader))image.shape, label.shape=&gt; torch.Size([32, 1, 28, 28]), torch.Size([32]) 데이터 시각화 123import numpy as npimport matplotlib.pyplot as plt%matplotlib inline 12345# squeeze() 함수는 차원의 원소가 1인 차원을 없애준다.torch_image = torch.squeeze(images[0])torch_image.shape=&gt; torch.Size([28, 28]) 1234image = torch_image.numpy()image.shape=&gt; (28, 28) 123plt.title(label)plt.imshow(image, 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[JavaScript] DataTables 사용","slug":"js-dev-1","date":"2020-08-12T04:24:43.000Z","updated":"2023-07-17T13:08:29.233Z","comments":true,"path":"2020/08/12/js-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/12/js-dev-1/","excerpt":"","text":"JQuery 용 테이블 라이브러리인 DataTables 플러그인을 사용하여 개발했을 경우 편리하게 사용하기 위해 구조를 설계하였다. DataTables는 데이터를 테이블로 쉽게 구현할 수 있도록 도와주는 라이브러리입니다. 설치와 사용법은 DataTables 공식 사이트에 잘 설명되어 있기 때문에 생략하겠다. 초기 설정 여러 곳에서 DataTables로 작업할 때 유용하도록 초기 기본값으로 설정하였다. 12345678910111213141516171819202122232425// table.js$.extend($.fn.dataTable.defaults, &#123; autoWidth: false, dom: `&lt;'row'&lt;'col-sm-12'tr&gt;&gt;&lt;'row'&lt;'col-sm-12 col-md-5'i&gt;` + `&lt;'col-sm-12 col-md-7 dataTables_pager'lp&gt;&gt;`, language: &#123; emptyTable: '데이터가 없습니다.', infoEmpty: '', info: ' _TOTAL_ 개의 데이터가 있습니다.', search: '&lt;span&gt;검색 :&lt;/span&gt; _INPUT_', searchPlaceholder: '내용 입력...', lengthMenu: 'Display _MENU_', paginate: &#123; first: 'First', last: 'Last', next: $('html').attr('dir') == 'rtl' ? '&amp;larr;' : '&amp;rarr;', previous: $('html').attr('dir') == 'rtl' ? '&amp;rarr;' : '&amp;larr;', &#125;, &#125;, // 검색 기능 숨기기 searching: false, // 표시 건수기능 숨기기 lengthChange: false, // 한 페이지에 표시되는 Row 수 pageLength: 10,&#125;); 기본 구조 기본 구조를 설계하여 다른 파일에서 공통으로 사용할 수 있도록 하였다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// table.jsconst Datatables = &#123; // 기본 테이블 구조 basic: function (id, tableOption, info) &#123; let table = $(id).DataTable(&#123; // 반응형 테이블 설정 responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, order: [[0, 'asc']], &#125;); return table; &#125;, // 정렬하는 컬럼을 설정하도록 order: function (id, tableOption, num, info) &#123; let table = $(id).DataTable(&#123; responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, columnDefs: [ &#123; orderable: true, className: 'reorder', targets: 0 &#125;, &#123; orderable: true, className: 'reorder', targets: num &#125;, &#123; orderable: false, targets: '_all' &#125;, ], order: [[num, 'desc']], &#125;); return table; &#125;, // 데이터 추가 rowsAdd: function (table, url, param) &#123; table.clear(); $.ajax(&#123; url: url, type: 'POST', data: JSON.stringify(param), contentType: 'application/json', success: function (data) &#123; table.rows.add(data).draw(); // 반응형 테이블 사용 table.responsive.recalc(); &#125;, &#125;); &#125;, // 새로고침 refresh: function (table, data) &#123; table.clear(); table.rows.add(data).draw(); &#125;,&#125;; 사용 예제 예를 들어 공지사항 테이블을 만들어 보겠다. 1234567891011121314151617&lt;!-- notice.html --&gt;&lt;table class=\"table\" id=\"noticeTable\"&gt; &lt;thead class=\"text-center\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;작성시간&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=\"text-center\"&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;!-- thymeleaf 사용 --&gt;&lt;script th:src=\"@&#123;/js/table.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/notice.js&#125;\"&gt;&lt;/script&gt; table 태그의 id를 설정하고 위에서 설정한 Datatables.order 함수를 통해 DataTables을 생성하였다. 123456789101112131415161718192021222324252627282930313233// notice.jsconst dataTable = &#123; ele: '#noticeTable', table: null, option: &#123; columns: [ &#123; data: null, render: function (data, type, row, meta) &#123; return meta.row + 1; &#125;, &#125;, &#123; data: 'title' &#125;, &#123; data: 'userId' &#125;, &#123; data: 'createDate' &#125;, &#123; data: 'hit' &#125;, ], &#125;, init: function () &#123; // DataTables 생성 this.table = Datatables.order(this.ele, this.option, 3); this.search(); &#125;, search: function () &#123; const param = new Object(); // 조회 조건에 따라 데이터를 조회해서 DataTables에 넣는다. Datatables.rowsAdd(this.table, contextPath + '/notice/search', param); &#125;,&#125;;$(document).ready(function () &#123; dataTable.init();&#125;); 결과 DataTables 라이브러리를 사용하여 구현해봤습니다. 여러 프로젝트에서 공통으로 사용하기 위해 정리를 하였는데 개선사항이 있으면 추가 할 예정이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"}]},{"title":"[MySQL] Packet for query is too large 에러 발생시","slug":"mysql-1","date":"2020-08-10T06:14:27.000Z","updated":"2023-07-17T13:07:15.977Z","comments":true,"path":"2020/08/10/mysql-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/10/mysql-1/","excerpt":"","text":"MySQL 을 사용하여 개발 중 4MB가 넘는 파일을 업로드 시 다음과 같은 패킷 에러가 발생하였다. 1com.mysql.jdbc.PacketTooBigException: Packet for query is too large (9,523,277 &gt; 4,194,304). You can change this value on the server by setting the 'max_allowed_packet' variable 기본적으로 할당된 패킷 사이즈 값이 너무 작기 때문에 에러가 발생했기 때문에 수정이 필요하다. MySQL 설정에서 max_allowed_packet 값을 변경하여 해결하였다. max_allowed_packet은 서버로 질의하거나 받게되는 패킷의 최대 길이를 나타내는 시스템 변수 다음은 해결방법에 대해 알아보겠다. 1) MySQL 커맨드 라인에서 변경 먼저 MySQL 에 접속한다. 1$ mysql -u root -p **** 12345678910111213141516mysql&gt; show variables;## 1024 * 1024 * 32 -&gt; 32MBmysql&gt; SET GLOBAL max_allowed_packet = 33554432;Query OK, 0 rows affected (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables where Variable_name = 'max_allowed_packet';+--------------------+----------+| Variable_name | Value |+--------------------+----------+| max_allowed_packet | 33554432 |+--------------------+----------+1 row in set (0.01 sec) 2) 설정파일 변경 /etc/my.cnf 설정파일 내의 값을 변경한다. 1$ vi /etc/my.cnf 12# 없을 시 추가한다.max_allowed_packet=32M 3) MySQL 재시작 다음 명령어를 사용여 MySQL 를 재시작한다. 12345678# 우분투$ service mysql restart# CentOS6$ service mysqld restart# CentOS7$ systemctl restart mysqld","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[JAVA] 동네예보 조회서비스 API","slug":"java-dev-5","date":"2020-08-06T06:13:50.000Z","updated":"2023-07-17T13:05:15.487Z","comments":true,"path":"2020/08/06/java-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/06/java-dev-5/","excerpt":"","text":"동네예보 조회서비스 동네예보 정보를 조회하기 위해 공공데이터 포털 사이트의 동네예보 조회서비스 API를 사용하였다. Open API 활용 방법 동네예보 조회서비스 사이트에서 활용신청을 하고 Service Key를 발급받는다. 오픈 API 활용 가이드를 다운로드 하여 조회 조건 및 결과 데이터를 이해한다. 동네예보 데이터 조회 1http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst?ServiceKey=&#123;발급받은 Service Key&#125;&amp;pageNo=1&amp;numOfRows=10&amp;dataType=JSON&amp;base_date=&#123;현재날짜&#125;&amp;base_time=&#123;현재시간&#125;&amp;nx=&#123;지점 X 좌표값&#125;&amp;ny=&#123;지점 Y 좌표값&#125; 결과 데이터(JSON 형식) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#123; \"response\": &#123; \"header\": &#123; \"resultCode\": \"00\", \"resultMsg\": \"NORMAL_SERVICE\" &#125;, \"body\": &#123; \"dataType\": \"JSON\", \"items\": &#123; \"item\": [ &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"POP\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"80\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"PTY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"R06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"9\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"REH\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"85\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"S06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"SKY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"4\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"T3H\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"24\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"UUU\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"-1.1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VEC\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"127\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VVV\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0.9\", \"nx\": 76, \"ny\": 122 &#125; ] &#125;, \"pageNo\": 1, \"numOfRows\": 10, \"totalCount\": 216 &#125; &#125;&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 조회 서비스 마다 결과 데이터의 items 부분이 다르므로 기본 구조 도메인과 Item 도메인을 분리해서 생성하였다. 12345678import lombok.Data;@Datapublic class ApiData &#123; private Response response;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.List;import lombok.Data;@Datapublic class Response &#123; private Header header; private Body body; @Data public static class Header &#123; private int resultCode; private String resultMsg; &#125; @Data public static class Body &#123; /** 데이터 타입 */ private String dataType; /** 한 페이지 결과 수 */ private int numOfRows; /** 페이지 번호 */ private int pageNo; /** 전체 결과 수 */ private int totalCount; private Items items; &#125; @Data public static class Items &#123; private List&lt;VilageFcst&gt; item; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import lombok.Data;/** * 동네예보 서비스 도메인 * * @author hgko * */@Datapublic class VilageFcst &#123; /** 발표일자 */ private String baseDate; /** 발표시각 */ private String baseTime; /** 예보일자 */ private String fcstDate; /** 예보시각 */ private String fcstTime; /** 자료구분문자 */ private CategoryType category; /** 예보 값 */ private float fcstValue; /** 예보지점 X 좌표 */ private float nx; /** 예보지점 Y 좌표 */ private float ny; /** * 코드값 정보 */ @Getter public enum CategoryType &#123; POP(\"강수확률\", \"강수확률\"), R06(\"6시간 강수량\", \"범주 (1 mm)\"), S06(\"6시간 신적설\", \"범주 (1 cm)\"), SKY(\"하늘상태\", \"코드값\"), T3H(\"3시간 기온\", \"℃\"), TMN(\"아침 최저기온\", \"℃\"), TMX(\"낮 최저기온\", \"℃\"), WAV(\"파고\", \"M\"), T1H(\"기온\", \"℃\"), RN1(\"1시간 강수량\", \"mm\"), UUU(\"동서바람성분\", \"m/s\"), VVV(\"남북바람성분\", \"m/s\"), REH(\"습도\", \"%\"), PTY(\"강수형태\", \"코드값\"), VEC(\"풍향\", \"m/s\"), WSD(\"풍속\", \"1\"); private String name; private String unit; private CategoryType(String name, String unit) &#123; this.name = name; this.unit = unit; &#125; &#125;&#125; 2) 데이터 조회 데이터 조회 시 주의해야 할 점은 시간을 3시간 단위로 설정해야 한다. 오전 02시부터 3시간 단위로 증가해서 시간을 설정한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final String BASE_URL = \"http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst\";private final String serviceKey = \"\"; /*공공데이터포털에서 받은 인증키*/public void getVilageFcst() &#123; try &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); urlBuilder.append(\"?\" + URLEncoder.encode(\"ServiceKey\", \"UTF-8\") + \"=\" + serviceKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"pageNo\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"numOfRows\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"10\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"dataType\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"JSON\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_date\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"20200807\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_time\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1100\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"nx\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"76\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"ny\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"122\", \"UTF-8\")); URL url = new URL(urlBuilder.toString()); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Content-type\", \"application/json\"); System.out.println(\"Response code: \" + conn.getResponseCode()); if (conn.getResponseCode() &gt;= 200 &amp;&amp; conn.getResponseCode() &lt;= 300) &#123; StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); in.lines().forEach(line -&gt; &#123; sb.append(line); &#125;); in.close(); conn.disconnect(); System.out.println(sb.toString()); setWeatherInfo(sb.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 동네예보 데이터 파싱 * @param json */private void setWeatherInfo(String json) &#123; try &#123; ObjectMapper objectMapper = new ObjectMapper(); ApiData data = objectMapper.readValue(json, ApiData.class); Items items = data.getResponse().getBody().getItems(); for (VilageFcst item : items.getItem()) &#123; if (item.getCategory() == CategoryType.T3H) &#123; &#125; else if (item.getCategory() == CategoryType.REH) &#123; &#125; else if (item.getCategory() == CategoryType.SKY) &#123; &#125; else if (item.getCategory() == CategoryType.PTY) &#123; &#125; &#125; &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 동네예보 데이터들이 조회되면 데이터들을 가공해서 사용하도록 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"}]},{"title":"[JAVA] 농업기상정보 서비스 API","slug":"java-dev-4","date":"2020-07-31T06:07:15.000Z","updated":"2023-07-17T13:04:22.233Z","comments":true,"path":"2020/07/31/java-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-4/","excerpt":"","text":"농업기상정보 서비스 농업 관련 기상 데이터가 필요하게 되어 공공데이터 포털 사이트의 농업기상정보 API를 사용하여 조회하였다. Open API 활용 방법 농업기상정보서비스 사이트에 접속한다. 이용방법에 따라 회원가입 후 Open API 신청을 하고 Service Key를 발급받는다. 활용 가이드를 다운로드하여 조회 조건 및 결과 데이터를 이해한다. 농업 기상 데이터 조회 1http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp?mberid=&#123;id&#125;&amp;regist_ky=&#123;발급받은 Service Key&#125; 결과 데이터(XML 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;Root&gt; &lt;Info&gt; &lt;stncode&gt;380959A001&lt;/stncode&gt; &lt;stnname&gt;충주시 달천동&lt;/stnname&gt; &lt;date&gt;2020/07/31 14:50&lt;/date&gt; &lt;temp_150&gt;28.3℃&lt;/temp_150&gt; &lt;tmprt_150Top&gt;29.7℃&lt;/tmprt_150Top&gt; &lt;tmprt_150Lwet&gt;22.5℃&lt;/tmprt_150Lwet&gt; &lt;tmprt_50&gt;-℃&lt;/tmprt_50&gt; &lt;tmprt_50Top&gt;-℃&lt;/tmprt_50Top&gt; &lt;tmprt_50Lwet&gt;-℃&lt;/tmprt_50Lwet&gt; &lt;tmprt_400&gt;-℃&lt;/tmprt_400&gt; &lt;tmprt_400Top&gt;-℃&lt;/tmprt_400Top&gt; &lt;tmprt_400Lwet&gt;-℃&lt;/tmprt_400Lwet&gt; &lt;hd_150&gt;86.2%&lt;/hd_150&gt; &lt;hd_150Top&gt;100.0%&lt;/hd_150Top&gt; &lt;hd_150Lwet&gt;75.6%&lt;/hd_150Lwet&gt; &lt;hd_50&gt;-%&lt;/hd_50&gt; &lt;hd_50Top&gt;-%&lt;/hd_50Top&gt; &lt;hd_50Lwet&gt;-%&lt;/hd_50Lwet&gt; &lt;hd_400&gt;-%&lt;/hd_400&gt; &lt;hd_400Top&gt;-%&lt;/hd_400Top&gt; &lt;hd_400Lwet&gt;-%&lt;/hd_400Lwet&gt; &lt;wd_300&gt;남동&lt;/wd_300&gt; &lt;wd_300Top&gt;남&lt;/wd_300Top&gt; &lt;wd_300Lwet&gt;정온&lt;/wd_300Lwet&gt; &lt;wd_150&gt;-&lt;/wd_150&gt; &lt;wd_150Top&gt;-&lt;/wd_150Top&gt; &lt;wd_150Lwet&gt;-&lt;/wd_150Lwet&gt; &lt;wd_1000&gt;-&lt;/wd_1000&gt; &lt;wd_1000Top&gt;-&lt;/wd_1000Top&gt; &lt;wd_1000Lwet&gt;-&lt;/wd_1000Lwet&gt; &lt;arvlty_300&gt;1.9&lt;/arvlty_300&gt; &lt;arvlty_300Top&gt;4.0&lt;/arvlty_300Top&gt; &lt;arvlty_300Lwet&gt;0.0&lt;/arvlty_300Lwet&gt; &lt;arvlty_150&gt;-&lt;/arvlty_150&gt; &lt;arvlty_150Top&gt;-&lt;/arvlty_150Top&gt; &lt;arvlty_150Lwet&gt;-&lt;/arvlty_150Lwet&gt; &lt;arvlty_1000&gt;-&lt;/arvlty_1000&gt; &lt;arvlty_1000Top&gt;-&lt;/arvlty_1000Top&gt; &lt;arvlty_1000Lwet&gt;-&lt;/arvlty_1000Lwet&gt; &lt;afp&gt;0.0mm&lt;/afp&gt; &lt;afv&gt;-mm&lt;/afv&gt; &lt;sunshnTime&gt;202.0hr&lt;/sunshnTime&gt; &lt;solradQy&gt;10.4MJ/㎡&lt;/solradQy&gt; &lt;dwcnTime&gt;0.0hr&lt;/dwcnTime&gt; &lt;pnwgTp&gt;-hr&lt;/pnwgTp&gt; &lt;pnwgTpTop&gt;-hr&lt;/pnwgTpTop&gt; &lt;pnwgTpLwet&gt;-hr&lt;/pnwgTpLwet&gt; &lt;frfrTp&gt;-℃&lt;/frfrTp&gt; &lt;frfrTpTop&gt;-℃&lt;/frfrTpTop&gt; &lt;frfrTpLwet&gt;-℃&lt;/frfrTpLwet&gt; &lt;udgrHeattCndctvt&gt;-100.0℃&lt;/udgrHeattCndctvt&gt; &lt;udgrHeattCndctvtTop&gt;-100.0℃&lt;/udgrHeattCndctvtTop&gt; &lt;udgrHeattCndctvtLwet&gt;-100.0℃&lt;/udgrHeattCndctvtLwet&gt; &lt;udgrTp_10&gt;-℃&lt;/udgrTp_10&gt; &lt;udgrTp_10Top&gt;26.1℃&lt;/udgrTp_10Top&gt; &lt;udgrTp_10Lwet&gt;24.4℃&lt;/udgrTp_10Lwet&gt; &lt;udgrTp_5&gt;-℃&lt;/udgrTp_5&gt; &lt;udgrTp_5Top&gt;-℃&lt;/udgrTp_5Top&gt; &lt;udgrTp_5Lwet&gt;-℃&lt;/udgrTp_5Lwet&gt; &lt;udgrTp_20&gt;-℃&lt;/udgrTp_20&gt; &lt;udgrTp_20Top&gt;-℃&lt;/udgrTp_20Top&gt; &lt;udgrTp_20Lwet&gt;-℃&lt;/udgrTp_20Lwet&gt; &lt;soilMitr_10&gt;32.5&lt;/soilMitr_10&gt; &lt;soilMitr_10Top&gt;36.3&lt;/soilMitr_10Top&gt; &lt;soilMitr_10Lwet&gt;27.3&lt;/soilMitr_10Lwet&gt; &lt;soilMitr_10Cmst&gt;23.4&lt;/soilMitr_10Cmst&gt; &lt;soilMitr_10CmstTop&gt;27.2&lt;/soilMitr_10CmstTop&gt; &lt;soilMitr_10CmstLwet&gt;18.2&lt;/soilMitr_10CmstLwet&gt; &lt;soilMitr_20&gt;-&lt;/soilMitr_20&gt; &lt;soilMitr_20Top&gt;-&lt;/soilMitr_20Top&gt; &lt;soilMitr_20Lwet&gt;-&lt;/soilMitr_20Lwet&gt; &lt;soilMitr_20Cmst&gt;-&lt;/soilMitr_20Cmst&gt; &lt;soilMitr_20CmstTop&gt;-&lt;/soilMitr_20CmstTop&gt; &lt;soilMitr_20CmstLwet&gt;-&lt;/soilMitr_20CmstLwet&gt; &lt;soilMitr_30&gt;-&lt;/soilMitr_30&gt; &lt;soilMitr_30Top&gt;-&lt;/soilMitr_30Top&gt; &lt;soilMitr_30Lwet&gt;-&lt;/soilMitr_30Lwet&gt; &lt;soilMitr_30Cmst&gt;-&lt;/soilMitr_30Cmst&gt; &lt;soilMitr_30CmstTop&gt;-&lt;/soilMitr_30CmstTop&gt; &lt;soilMitr_30CmstLwet&gt;-&lt;/soilMitr_30CmstLwet&gt; &lt;/Info&gt;&lt;/Root&gt; 1) Respone Domain 생성 기본적으로 결과가 XML 형식이므로 javax.xml를 사용하여 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import lombok.Data;/** * 기상청 API로 기상정보 조회할 때 쓰이는 도메인 * * @author hgko * */@Data@XmlRootElement(name = \"Root\")@XmlAccessorType(value = XmlAccessType.FIELD)public class ResponseXml &#123; @XmlElement(name = \"Info\") private Info info; @Data public static class Info &#123; /** 지역 코드 */ private String stncode; /** 지역 이름 */ private String stnname; /** 일시 */ private String date; /** 온도(150CM) */ private String temp_150; /** 습도(150CM) */ private String hd_150; /** 풍향(300CM) */ private String wd_300; /** 풍속(300CM) */ private float arvlty_300; /** 강수량 */ private String afp; /** 증발량 */ private String afv; /** 일사량 */ private String solradQy; /** 일조시간 */ private String sunshnTime; /** 토양수분(10CM) */ private float soilMitr_10; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회한다. 123456789101112131415161718private final String BASE_URL = \"http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp\";private final String userId = \"\"; // Login Idprivate final String serviceKey = \"\"; // 발급받은 Service Keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"mberid\", \"UTF-8\") + \"=\" + userId); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"regist_ky\", \"UTF-8\") + \"=\" + serviceKey); RestTemplate restTemplate = new RestTemplate(); ResponseXml response = restTemplate.getForObject(urlBuilder.toString(), ResponseXml.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"}]},{"title":"[JAVA] OpenWeather API","slug":"java-dev-3","date":"2020-07-31T05:12:22.000Z","updated":"2023-07-17T13:01:13.076Z","comments":true,"path":"2020/07/31/java-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-3/","excerpt":"","text":"OpenWeather API 200,000 개가 넘는 도시를 포함하여 지구상의 모든 위치에 대한 현재 날씨 데이터에 액세스 할 수 있습니다. 현재 날씨는 글로벌 모델과 4 만 개가 넘는 기상 관측소의 데이터를 기반으로 자주 업데이트됩니다. 데이터는 JSON, XML 또는 HTML 형식으로 제공됩니다. 출처 : OpenWeather OpenWeather API를 사용하여 현재 날씨 데이터를 조회하였다. 현재 날씨 데이터 조회 OpenWeather 사이트에 접속해서 API Key를 발급받는다. 메인에서 Current Weather Data를 선택받는다. 조회 조건 및 결과 정보와 다른 기능들에 대해 잘 설명되어 있다. 우리나라 전체에 대한 날씨 데이터를 조회할 것이기 때문에 조회 조건은 다음과 같다. 1http://api.openweathermap.org/data/2.5/weather?q=Koesan&amp;appid=&#123;발급받은 API Key&#125;&amp;lang=kr&amp;units=metric 결과 데이터(JSON 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"coord\": &#123; \"lon\": 127.79, \"lat\": 36.81 &#125;, \"weather\": [ &#123; \"id\": 803, \"main\": \"Clouds\", \"description\": \"튼구름\", \"icon\": \"04d\" &#125; ], \"base\": \"stations\", \"main\": &#123; \"temp\": 28, \"feels_like\": 32.65, \"temp_min\": 28, \"temp_max\": 28, \"pressure\": 1014, \"humidity\": 78 &#125;, \"visibility\": 10000, \"wind\": &#123; \"speed\": 1.5, \"deg\": 270 &#125;, \"clouds\": &#123; \"all\": 75 &#125;, \"dt\": 1596171614, \"sys\": &#123; \"type\": 1, \"id\": 8131, \"country\": \"KR\", \"sunrise\": 1596141211, \"sunset\": 1596191806 &#125;, \"timezone\": 32400, \"id\": 1842800, \"name\": \"Koesan\", \"cod\": 200&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;import lombok.Data;/** * OpenWeath API - 현재 날씨 데이터 * @author hgko */@Datapublic class OpenWeather &#123; private List&lt;Weather&gt; weather; /** 내부 매개 변수 */ private String base; private Main main; private Wind wind; private Clouds clouds; private Rain rain; private Snow snow; /** 가시성 */ private int visibility; /** 데이터 계산 시간, 유닉스, UTC */ private long dt; /** UTC에서 초 단위로 이동 */ private int timezone; /** 도시 ID */ private long id; /** 도시 이름 */ private String name; /** 내부 매개 변수 */ private int cod; @Data public static class Weather &#123; /** 기상 조건 ID */ private int id; /** 날씨 매개 변수 그룹 (비, 눈, 극한 등) */ private String main; /** 그룹 내 날씨 조건 */ private String description; /** 날씨 아이콘 ID */ private String icon; &#125; @Data public static class Main &#123; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float temp; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float feels_like; /** 현재 최저 온도.(대규모 대도시 및 도시 지역 내) */ private float temp_min; /** 현재 최대 온도.(대규모 대도시 및 도시 지역 내)*/ private float temp_max; /** 대기압 (해수면, 해수면 또는 grnd_level 데이터가 없는 경우), hPa */ private int pressure; /** 습도, % */ private float humidity; /** 해수면의 대기압, hPa */ private float sea_level; /** 지면에서의 대기압, hPa */ private float grnd_level; &#125; @Data public static class Wind &#123; /** 바람의 속도. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float speed; /** 풍향,도 (기상) */ private int deg; /** 바람 돌풍. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float gust; &#125; @Data public static class Clouds &#123; /** 흐림, % */ private int all; &#125; @Data public static class Rain &#123; /** 지난 1 시간 동안의 강우량, mm */ @JsonProperty(\"1h\") private float rain1h; /** 지난 3 시간 동안의 강우량, mm */ @JsonProperty(\"3h\") private float rain3h; &#125; @Data public static class Snow &#123; /** 지난 1 시간 동안의 눈량, mm */ @JsonProperty(\"1h\") private float snow1h; /** 지난 3 시간 동안의 눈량, mm */ @JsonProperty(\"3h\") private float snow3h; &#125; @Data public static class Sys &#123; private int type; private int id; /** 국가 코드 (GB, JP 등) */ private String country; /** 일출 시간, 유닉스, UTC */ private long sunrise; /** 일몰 시간, 유닉스, UTC */ private long sunset; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회하였다. 12345678910111213141516171819private final String BASE_URL = \"http://api.openweathermap.org/data/2.5/weather\";private final String apiKey = \"\"; // 발급받은 API keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"q\", \"UTF-8\") + \"=Koesan\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"appid\", \"UTF-8\") + \"=\" + apiKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"lang\", \"UTF-8\") + \"=kr\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"units\", \"UTF-8\") + \"=metric\"); RestTemplate restTemplate = new RestTemplate(); OpenWeather response = restTemplate.getForObject(urlBuilder.toString(), OpenWeather.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 결과가 출력되었는지 확인하고 정상이면 날씨 데이터들을 가공해서 사용하도록 한다. 추가 내용 풍향 데이터 변환 날씨 API에서 풍향 데이터는 대부분이 degree(integer) 형식으로 되어 있기 때문에 방향을 나타내는 String 형식으로 나타낼 필요가 있다. 123456789101112131415161718192021222324252627282930313233343536373839# Enum 정의@Getterpublic enum WindType &#123; N0(0, \"북\"), NNE(1, \"북북동\"), NE(2, \"북동\"), ENE(3, \"동북동\"), E(4, \"동\"), ESE(5, \"동남동\"), SE(6, \"남동\"), SSE(7, \"남남동\"), S(8, \"남\"), SSW(9, \"남남서\"), SW(10, \"남서\"), WSW(11, \"서남서\"), W(12, \"서\"), WNW(13, \"서북서\"), NW(14, \"북서\"), NNW(15, \"북북서\"), N16(16, \"북\"); private int code; private String name; private WindType(int code, String name) &#123; this.code = code; this.name = name; &#125; public static WindType value(int value) &#123; for (WindType type : WindType.values()) &#123; if (type.getCode() == value) &#123; return type; &#125; &#125; return null; &#125;&#125; Enum 을 사용하여 편리하게 변환한다. 12345private String getWindDirection(int degree) &#123; int result = (int)((degree + 22.5 * 0.5) / 22.5); WindType windType = WindType.value(result); return windType.getName();&#125; 1234public static void main(String[] args) &#123; String wd = getWindDirection(270); System.out.println(\"풍향 : \" : wd);&#125; 결과 1풍향 : 서 날씨 정보 변환 OpenWeatherMap API의 다국어에 한국어 지원을 위한 협업용 정보 openweathermap_api_translation_ko","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"}]},{"title":"[CSS] 그라데이션 효과","slug":"css-dev-1","date":"2020-07-31T01:20:38.000Z","updated":"2023-07-17T12:56:40.270Z","comments":true,"path":"2020/07/31/css-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/css-dev-1/","excerpt":"","text":"linear-gradient : CSS3에서 추가된 것으로, 선형 그라데이션 효과를 만들 수 있다. 1linear-gradient( direction, color1, color2, …, color3 ); direction에는 그라데이션 방향을 입력한다. to bottom : 위에서 아래로 그라데이션을 만든다. (기본값) to top : 아래에서 위로 그라데이션을 만든다. to left : 오른쪽에서 왼쪽으로 그라데이션을 만든다. to right : 왼쪽에서 오른쪽으로 그라데이션을 만든다. ndeg : n 도의 방향으로 그라데이션을 만든다. 예시 1234.gradation_bar &#123; width: 100%; background: linear-gradient(to right, #ff0000, orange, yellow, #00ff00, #0000ff, indigo, violet);&#125; 결과 참고 Ultimate CSS Gradient Generator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"}]},{"title":"[JAVA] proj4 투형변환","slug":"java-dev-2","date":"2020-07-31T01:04:39.000Z","updated":"2023-07-17T13:00:00.779Z","comments":true,"path":"2020/07/31/java-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-2/","excerpt":"","text":"투형변환 TM(미국좌표) 좌표와 WGS84(한국좌표) 좌표를 서로 변환한다. 다운로드 Java Map Projection Library 사이트에 접속하여 다음의 Download 에서 소스 및 jar 파일을 다운받는다. 다운받은 jar 파일은 프로젝트의 classpath 경로에 추가한다. 샘플 1234567891011121314151617181920212223// 투형 정보 입력(중부원점 직각좌표 투형정보)String[] proj4 = new String[] &#123; \"+proj=tmerc\", \"+lat_0=38N\", \"+lon_0=127.00289027777777777776E\", \"+ellps=bessel\", \"+units=m\", \"+x_0=200000\", \"+y_0=500000\", \"+k=1.0\"&#125;Projection proj = ProjectionFactory.fromPROJ4Specification(proj4);Point2D.Double srcProject = new Point2D.Double(132, 37);Point2D.Double dstProject = proj.transform(srcProject, new Point2D.Double());System.out.println(\"TM : \" + dstProject);srcProject = new Point2D.Double(644904.399587292, 400717.8948938238);dstProject = proj.inverseTransForm(srcProject, new Point2D.Double());System.out.println(\"WGS84 : \" + dstProjec); 결과 12TM : Point2D.Double[644904.399587292, 400717.8948938238]WGS84 : Point2D.Double[132.00000000065793, 36.999999999128526]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"}]},{"title":"[JAVA] Julian Date Conversion","slug":"java-dev-1","date":"2020-07-31T00:59:38.000Z","updated":"2023-03-14T02:18:51.709Z","comments":true,"path":"2020/07/31/java-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-1/","excerpt":"","text":"율리우스력 변환하기 율리우스력은 고대 로마의 정치가 율리우스 카이사르가 기원전 46년에 제정해 기원전 45년부터 시행한 양력(陽曆) 역법이다. 율리우스력의 1년은 365일 또는 366일(4년에 한번)이다. 기원전 46년 이전까지 고대 로마에서는 태음력을 사용하였으며, 점차 계절의 변화(즉, 태양의 일주)를 고려해 태음력과 태양력을 섞어서 년(年)과 월(月)을 계산하였다. 이에 따라 특히 달을 계산하는 데 적지 않은 혼란과 계산의 착오가 생겼으며, 이러한 착오는 제사장이 임의로 수정하였다. 율리우스 카이사르가 채택한 달력은 태양력을 기준으로 2월을 제외한 달은 모두 30일 또는 31일로 정함으로써 이전에 있던 번거로움을 한꺼번에 해소하였다. 출처 : 위키백과 1. Joda-Time Library 사용 12345String dateStr = \"2009218\";MutableDateTime mdt = new MutableDateTime();mdt.setYear(Integer.parseInt(dateStr.subString(0, 3)));mdt.setDayOfYear(Integer.parseInt(dateStr.subString(4)));Date parsedDate = mdt.toDate(); 2. Java Api 사용 12345String dateStr = \"2009218\";Calendar cal = new GregorianCalendar();cal.set(Calendar.YEAR,Integer.parseInt(dateStr.subString(0, 3)));cal.set(Calendar.DAY_OF_YEAR,Integer.parseInt(dateStr.subString(4)));Date parsedDate = cal.getTime();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"}]},{"title":"[Eclipse RCP] 폴더안의 파일 리스트 읽기","slug":"rcp-dev-4","date":"2020-07-31T00:53:37.000Z","updated":"2023-07-17T13:04:41.398Z","comments":true,"path":"2020/07/31/rcp-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-4/","excerpt":"","text":"SWT 의 DirectoryDialog 를 이용하여 폴더를 읽고 폴더의 파일들을 읽어서 원하는 List 의 형식으로 만든다. 123456789101112131415161718192021Shell shell = GUIUtil.getShell();shell.getDisplay().asyncExec(() -&gt; &#123; DirectoryDialog dialog = new DirectoryDialog(shell); dialog.setMessage(\"Please select a directory and click OK\"); String dir = dialog.open(); if (dir != null) &#123; List&lt;MapImage&gt; mapImages = null; try &#123; mapImages = Files.list(new File(dir).toPath()) .filter(file -&gt; file.toFile().isFile()) .filter(file -&gt; !file.toFile().getName().endsWith(\".txt\")) .map(file -&gt; &#123; return new MapImage(shell, file.toFile()); &#125;).collect(Collectors.toList()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.err.println(mapImages); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[Eclipse RCP] SWT에서의 GC, Drawable, Canvas 사용","slug":"rcp-dev-3","date":"2020-07-31T00:38:00.000Z","updated":"2023-06-19T12:29:27.288Z","comments":true,"path":"2020/07/31/rcp-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-3/","excerpt":"","text":"addPaintListener() Control 객체가 그 객체의 paintEvent를 통하여 그림을 그릴 수 있지만, 이보다는 Control 클래스를 상속받아 그래픽 작업을 위해 설계된 특별한 클래스인 Canvas 클래스를 사용하여 그림을 그리는 것이 더욱 좋습니다. Canvas 클래스를 생성한 후 addPaintListener()를 통하여 paintListener를 추가하거나, 사용자가 직접 정의한 Control을 상속받음으로서 그림을 그릴 수 있습니다. Canvas 클래스는 그림을 그릴때 사용할 수 있는 다양한 종류의 스타일 비트를 가지고 있습니다. SWT.NO_BACKGROUND Canvas의 기본적인 동작은 다음과 같습니다. 객체의 할당영역을 그리기 앞서, 객체에 할당된 전체 영역을 현재 배경색으로 칠합니다. 이때 화면이 깜박이는 현상을 볼 수 있는데 이는 paintEvent가 배경색을 칠하고, 그 위에 Canvas의 요소들을 덧칠하는 순간을 우리가 보는 것입니다. 이 현상을 방지하기 위한 방법 중 하나는, Canvas를 생성할 때 SWT.NO_BACKGROUND 스타일 비트를 사용하여 배경이 그려지지 않게 하는것입니다. 단, 이 비트를 사용할 경우, 프로그램은 영역 전체에 대하여 모든 픽셀을 직접 그려야 합니다. SWT.NO_REDRAW_RESIZE 위젯의 사이즈가 변경될 때에도 paintEvent가 발생합니다. 이 역시 화면을 깜박거리게 할 수 있는데, 왜냐하면 사이즈가 변경될 때마다 해당 영역에 대해 모든 요소들을 다시 그려야 하기 때문입니다. 이는 SWT.NO_REDRAW_RESIZE 스타일 비트를 사용하여 완화시킬 수 있으며, 이는 컨트롤의 사이즈가 변경되더라도 paintEvent가 발생하지 않는다는 것을 의미합니다. 이는 컨트롤이 불필요하게 다시 그려지는것을 방지한다는 의미를 갖으며, 만약 크기가 증가된다고 한다면, paintEvent의 GC는 이 영역을 제외한 부분만을 다시 그리게 됩니다. 단 사각형 모양이 Canvas가 존재할 경우 사각형의 오른쪽 하단에 L이 거꾸로 된 형태로 그려질 수 있습니다. SWT.NO_REDRAW_RESIZE 스타일 비트는 새로 그려지는 부분에 대해서 적절히 처리해줄 경우, 고정사이즈의 그림이 GC에 그려질 때 나타나는 깜박임을 감소시킬 수 있습니다. 하지만 잘못 쓰였을 경우, SWT.NO_REDRAW_RESIZE는 치즈(cheese)라는 효과를 불러올 수 있습니다. 치즈는 다시 그려야 할 상황에 제대로 다시 그려지지 않는 부분이 있는 경우를 지칭합니다. paintEvent가 클라이언트 전 영역을 다시 그려야 하는 다음의 예시를 확인해보세요. 화면이 작아질 때에는 paintEvent가 발생하지 않기 때문에 그림이 다시 그려지지 않습니다. SWT.NO_REDRAW_RESIZE 상태에서 화면이 커질 경우, paintEvent는 새로 그려야 하는 부분에 대해서만 영역을 다시 그립니다. 그래서 기존에 그려졌던 부분이 지워지지 않았기 때문에 치즈 현상이 발생하게 됩니다. 또한 Canvas 사이즈가 증가할 때 GC는 필요한 부분만 다시 그리기 때문에 치즈 현상이 발생하게 됩니다. 12345678910shell.setLayout(new FillLayout());final Canvas canvas = new Canvas(shell,SWT.NO_REDRAW_RESIZE);canvas.addPaintListener(new PaintListener() &#123; public void paintControl(PaintEvent e) &#123; Rectangle clientArea = canvas.getClientArea(); e.gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN)); e.gc.fillOval(0,0,clientArea.width,clientArea.height); &#125;&#125;); SWT.NONE 이 문제를 해결하는 방법은 SWT.NONE 스타일 비트를 사용하여 GC가 크기가 커질 때 커진 부분만 새로 그리는것이 아닌, 모든 부분을 새로 그리도록 하고, 동시에 paintEvent가 셸 사이즈가 작아졌을 때에도 발생하게 하여, Canvas의 전체 부분이 다시 그려지게 하는 것입니다. 1final Canvas canvas = new Canvas(shell,SWT.NONE); SWT.NO_MERGE_PAINTS 각각의 SWT 위젯에 대해, 만약 하나이상의 영역이 다시 그려져야 할 경우, 운영체제는 다시 그려야 할 영역을 하나의 영역으로 묶어서 paintEvent를 발생하여 효율적인 처리를 가능하게 합니다. Canvas의 SWT.NO_MERGE_PAINTS 스타일 비트는 각각의 위젯에서 다시 그릴 영역을 하나로 묶지 않고, 각각의 영역에 대해 일일히 paintEvent를 호출하는 방식으로 변경합니다. 정리 NO_BACKGROUND, NO_REDRAW_RESIZE, NO_MERGE_PAINTS 스타일 비트는 Composite와 이 하부 클래스인 Canvas, Shell, Group등에서 사용할 수 있습니다, SWT에서 허용하긴 하지만, Composite 클래스의 Javadoc에서는 스타일 비트에 대해서 다음과 같이 기술합니다. Canvas 이외의 Composite의 하위클래스에서의 사용은 정의되지 않았다. 그러므로 Canvas 클래스가 그림 그리는데에 가장 적합한 컨트롤이라 할 수 있습니다. 깜박임을 방지하는 또 다른 방법은 더블 버퍼링을 사용하여 그림 그리기를 한번에 처리하는 것입니다. 더블 버퍼링은 paintEvent에서 제공하는 GC기 아닌 GC에 그림을 미리 그린 후, 이것을 제공되는 GC에 복사하는 기술입니다. 이를 위하여, Canvas의 영역과 동일한 사이즈의 Image 객체를 만들고, GC(Image)를 통하여 이 객체에 그림을 그립니다. 그려진 그림(Image)은 drawImage(Image, int, int) 메소드를 호출함으로서 paintEvent의 GC로 그려지게 됩니다. 이 기술을 사용할 때 주의할 점은 몇몇 운영체제는 이미 더블 버퍼링을 자체적으로 구현하고 있으므로, 결국 트리플 버퍼링이 이루어질 수 있다는 점입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[PyTorch] 기초 사용법","slug":"ai-pytorch-1","date":"2020-07-30T06:04:07.000Z","updated":"2023-03-14T02:18:45.739Z","comments":true,"path":"2020/07/30/ai-pytorch-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/30/ai-pytorch-1/","excerpt":"","text":"Load Packages 12import numpy as npimport torch Basic PyTorch 기초 사용법 1234nums = torch.arange(9)nums.shapenums.numpy()nums.reshape(3, 3) 1234randoms = torch.rand((3, 3))zeros = torch.zeros((3, 3))ones = torch.ones((3, 3))torch.zeros_like(ones) Operations PyTorch로 수학연산 하기 1234567891011nums * 3nums = nums.reshape((3, 3))nums + numsresult = torch.add(nums, 10)result.numpy()# Outarray([[10, 11, 12], [13, 14, 15], [16, 17, 18]], dtype=int64) View reshape와 같다. 123456range_nums = torch.arange(9).reshape(3, 3)range_nums.view(-1)range_nums.view(1, 9)# Outtensor([[0, 1, 2, 3, 4, 5, 6, 7, 8]]) Compile numpy를 torch tensor로 불러오기 12345arr = np.array([1, 1, 1])arr_torch = torch.from_numpy(arr)arr_torch.float()# tensor([1., 1., 1.]) Device 설정 12345device = 'cuda' if torch.cuda.is_available() else 'cpu'arr_torch.to(device)# Out - GPU 사용 가능tensor([1, 1, 1], device='cuda:0', dtype=torch.int32) AutoGrad 기울기 구하기 123456x = torch.ones(2, 2, requires_grad=True)y = x + 2print(x.grad_fn)# Out&lt;AddBackward0 object at 0x000001FFE2A04148&gt; 1234567z = y * y * 3out = z.mean()print(z, out)# Outtensor([[27., 27.], [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;) 123456out.backward()print(x.grad)# Outtensor([[4.5000, 4.5000], [4.5000, 4.5000]])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[TensorFlow 2.0] Evaluating & Prediction","slug":"ai-dev-7","date":"2020-07-29T02:29:29.000Z","updated":"2023-07-17T12:56:15.225Z","comments":true,"path":"2020/07/29/ai-dev-7/","link":"","permalink":"http://hgko1207.github.io/2020/07/29/ai-dev-7/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Build Model 123456789101112131415161718192021222324252627input_shape = (28, 28, 1)num_classes = 10learning_rate = 0.001inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), loss='sparse_categorical_crossentropy', metrics=['accuracy']) Preprocess 데이터셋 불러오기 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Training 12345678910num_epochs = 1batch_size = 64hist = model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# 결과Train on 60000 samples60000/60000 [==============================] - 6s 94us/sample - loss: 0.0798 - accuracy: 0.9755 1234hist.history# 결과&#123;'loss': [0.07980264157739779], 'accuracy': [0.9755]&#125; Evaluating 학습한 모델을 확인합니다. 1234model.evaluate(test_x, test_y, batch_size=batch_size)# 결과[0.03286817007374484, 0.9888] 결과 확인 Input으로 들어갈 이미지 데이터를 확인한다. 123456789import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinetest_image = text_x[0, :, :, 0]test_image.shape# 결과(28, 28) 123plt.title(test_y[0])plt.imshow(test_image, 'gray')plt.show() 모델에 Input Data로 확인 할 이미지 데이터를 넣는다. 1234567# 이미지를 보기위해 shape를 바꿨었는데 다시 reshape로 차원을 변경합니다.pred = model.predict(test_image.reshape(1, 28, 28, 1))# 결과array([[2.4227038e-09, 2.3278629e-08, 5.8909092e-07, 1.0298673e-07, 9.4029007e-10, 6.1998517e-11, 1.4364351e-12, 9.9999928e-01, 4.7319365e-10, 4.7449920e-08]], dtype=float32) 12345# 배열에서 가장 높은 값의 인덱스를 찾을 때 np.argmax를 사용한다.np.argmax(pred)# 결과7 Test Batch Batch Test Dataset 모델에 넣는다. 12345test_batch = test_x[:32]test_batch.shape# 결과(32, 28, 28, 1) 12345preds = model.predict(test_batch)preds.shape# 결과(32, 10) 123456789# -1을 넣으면 하나의 값이 아니라 앞의 32개의 결과를 보여줍니다.np.argmax(preds, -1)# 결과array([7, 2, 1, 0, 4, 1, 4, 9, 5, 9, 0, 6, 9, 0, 1, 5, 9, 7, 5, 4, 9, 6, 6, 5, 4, 0, 7, 4, 0, 1, 3, 1], dtype=int64)plt.imshow(test_batch[5, :, :, 0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Expert)","slug":"ai-dev-6","date":"2020-07-28T08:38:22.000Z","updated":"2023-07-17T12:55:57.031Z","comments":true,"path":"2020/07/28/ai-dev-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/28/ai-dev-6/","excerpt":"","text":"TensorFlow 공식 홈페이지에서 설명하는 Expert 버전을 사용해본다. Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Build Model 1234567891011121314151617181920212223242526input_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Preprocess TensorFlow 공식 홈페이지에서 말한 expert 방법을 사용한다. 1234567891011mnist = tf.keras.datasets.mnist# Load Data from MNIST(x_train, y_train), (x_test, y_test) = mnist.load_data()# Channel 차원 추가x_train = x_train[..., tf.newaxis]x_test = x_test[..., tf.newaxis]# Data Normailzationx_train, x_test = x_train / 255.0, x_test / 255.0 tf.data 사용 from_tensor_slices() shuffle() batch() 123456train_ds = tf.data.Dataset.from_tensor_slices((x_train, y_train))train_ds = train_ds.shuffle(1000)train_ds = train_ds.batch(32)test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))test_ds = test_ds.batch(32) Visualize Data matplotlib 불러와서 데이터를 시각화한다. 1234567import matplotlib.pyplot as plt%matplotlib inlinefor image, label in train_ds.take(2): plt.title(label[0].shape) plt.imshow(image[0, :, :, 0], 'gray') plt.show() Training (Keras) Keras로 학습 할 때는 기존과 같지만, train_ds는 generator라서 그래도 넣을 수 있다. 12model.compile(optimizer='adam', loss='sparse_categorical_crossentropy')model.fit(train_ds, epochs=1000) Optimization Loss Function Optimizer Metrics 12345678loss_object = tf.keras.losses.SparseCategoricalCrossentropy()optimizer = tf.keras.optimizers.Adam()train_loss = tf.keras.metrics.Mean(name='train_loss')train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')test_loss = tf.keras.metrics.Mean(name='test_loss')test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy') Training @tf.function : 기존 session 열었던 것 처럼 바로 작동 안 하고, 그래프만 만들고 학습이 시작되면 돌아가도록 한다. 12345678910@tf.functiondef train_step(images, labels): with tf.GradientTape() as tape: predictions = model(images) loss = loss_object(labels, predictions) gradients = tape.gradient(loss, model.trainable_variables) optimizer.apply_gradients(zip(gradients, model.trainable_variables)) train_loss(loss) train_accuracy(labels, predictions) 1234567@tf.functiondef test_step(images, lebels): predictions = model(images) t_loss = loss_object(labels, predictions) test_loss(t_loss) test_accuracy(labels, predictions) 12345678910111213for epoch in range(2): for images, labels in train_ds: train_step(images, labels) for test_images, test_labels in test_ds: test_step(test_images, test_labels) template = 'Epoch &#123;&#125;, Loss: &#123;&#125;, Accuracy: &#123;&#125;, Test Loss &#123;&#125;, Test Accuracy: &#123;&#125;' print(template.format(epoch+1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100)) 결과 1234Start TrainingEpoch 1, Loss: 0.04196552559733391, Accuracy: 98.74666595458984, Test Loss 0.043360475450754166, Test Accuracy: 98.72000122070312Start TrainingEpoch 2, Loss: 0.033374134451150894, Accuracy: 99.0050048828125, Test Loss 0.03336939960718155, Test Accuracy: 98.95500183105469","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Keras)","slug":"ai-dev-5","date":"2020-07-24T08:35:22.000Z","updated":"2023-07-17T12:55:31.769Z","comments":true,"path":"2020/07/24/ai-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/24/ai-dev-5/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Prepare MNIST Datset 1(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data() Build Model 1234567891011121314151617181920212223inputs = layers.Input((28, 28, 1))net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(10)(net) # num_classesnet = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Optimization 모델을 학습하기 전에 설정을 한다. Loss Function Metrics Optimizer Loss Function Categorical vs Binary 12loss = 'binary_crossentropy'loss = 'categorical_crossentropy' sparse_categorical_crossentropy vs categorical_crossentropy 12345loss_fun = tf.keras.losses.sparse_categorical_crossentropy# 또는tf.keras.losses.categorical_crossentropytf.keras.losses.binary_crossentropy Metrics 모델을 평가하는 방법이다.(정확도 측정) Accuracy : 예측이 레이블과 일치하는 빈도를 계산 BinaryAccuracy: 예측이 이진 레이블과 일치하는 빈도를 계산 CategoricalAccuracy : 예측이 one-hot 레이블과 일치하는 빈도를 계산 TopKCategoricalAccuracy : 상위 K 예측에서 대상이 얼마나 자주 나타되는지 계산 SparseTopKCategoricalAccuracy : 상위 K 예측에서 정수 대상이 얼마나 자주 나타하는지 계산 12345# accurany를 이름으로 넣는 방법metrics = ['accuracy']# tf.keras.metricsmetrics = [tf.keras.metrics.CategoricalAccuracy()] Optimizer ‘sgd’ ‘rmsprop’ ‘adam’ 123456optm = tf.keras.optimizers.Adam()# Outtf.keras.optimizers.SGD()tf.keras.optimizers.RMSprop()tf.keras.optimizers.Adam() Compile Optimizer 적용을 합니다. 123model.compile(optimizer=optm, loss=loss_fun, metrics=metrics) Prepaer Dataset 학습에 사용할 데이터셋을 준비한다. 데이터셋 확인 12345train_x.shape, train_y.shape&gt; ((60000, 28, 28), (60000,))test_x.shape, test_y.shape&gt; ((10000, 28, 28), (10000,)) 차원 수 늘리기 1234567import numpy as npnp.expand_dims(train_x, -1).shape&gt; (60000, 28, 28, 1)tf.expand_dims(train_x, -1).shape&gt; TensorShape([60000, 28, 28, 1]) 123# 최신 버전train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis] Rescaling 12345678np.min(train_x), np.max(train_x)&gt; (0, 255)train_x = train_x / 255.test_x = test_x / 255.np.min(train_x), np.max(train_x)&gt; (0.0, 1.0) Training 본격적으로 학습을 해봅니다. 그 전에 학습용 Hyperparameter 설정한다. num_epochs, batch_size 12345# 전체 sample 데이터를 이용하여 한 바퀴 돌며 학습하는 것을 1회 epoch이라 부른다.num_epochs = 1# 모델에 한번에 들어가는 데이터 수를 조절하여 메모리 사용 효율을 향상시킨다.batch_size = 32 실행! 12345678model.fit(train_x, train_y, batch_size=batch_size, shuffle=True, epochs=num_epochs)# ResultTrain on 60000 samples60000/60000 [==============================] - 99s 2ms/sample - loss: 0.1414 - categorical_accuracy: 0.0992","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 각 Layer별 역할 및 파라미터","slug":"ai-dev-4","date":"2020-07-20T07:39:18.000Z","updated":"2023-07-17T12:54:57.875Z","comments":true,"path":"2020/07/20/ai-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-4/","excerpt":"","text":"Load Packages 12345import tensorflow as tfimport osimport matplotlib.pyplot as plt%matplotlib inline Input Image 1234567891011from tensorflow.keras import datasets(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()image = train_x[0]# 차원 수 높이기image = image[tf.newaxis, ..., tf.newaxis]image.shape# Out(1, 28, 28, 1) Feature Extraction Convolution filters: layer에서 나갈 때 몇 개의 filter를 만들 것인지 kernel_size: filter(Weight)의 크기 strides: 몇 개의 pixel을 skip 하면서 훑어지나갈 것인지 (크기에도 영향을 준다.) padding: zero padding을 만들 것인지. VALID는 padding이 없고, SAME은 padding이 있습니다. (크기에도 영향을 준다.) activation: Activation Function을 만들 것인지. 당장 설정 안해도 Layer 층을 따로 만들 수 있습니다. (Default: None) 1234tf.keras.layers.Conv2D(filters=3, kernel_size=(3, 3), strides=(1, 1), padding='VALID', activation='relu')# (3, 3) 대신에 3으로도 대체 가능tf.keras.layers.Conv2D(3, 3, 1, 'VALID') Visualization 1234image = tf.cast(image, dtype=tf.float32)layer = tf.keras.layers.Conv2D(3, 3, strides=(1, 1), padding='SAME')output = layer(image) 12345plt.subplot(121)plt.imshow(image[0, :, :, 0], 'gray')plt.subplot(122)plt.imshow(output[0, :, :, 0], 'gray')plt.show() weight 불러오기 1234567891011121314weight = layer.get_weights()[0]plt.figure(figsize=(15, 5))plt.subplot(131)plt.hist(output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(132)plt.title(weight.shape)plt.imshow(weight[:, :, 0, 0], 'gray')plt.subplot(133)plt.title(output.shape)plt.imshow(output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Activation Function 0 미만의 값들을 0으로 바꿔준다. 12345678import numpy as npact_layer = tf.keras.layers.ReLU()act_output = act_layer(output)np.min(act_output), np.max(act_output)# Out(0.0, 244.73064) # 0미만 값들이 0으로 바뀜 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(act_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(act_output.shape)plt.imshow(act_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Pooling 강조되는 것들만 압축합니다. 123456pool_layer = tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=(2, 2), padding='SAME')pool_output = pool_layer(act_output)pool_output.shape# OutTensorShape([1, 14, 14, 3]) 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(pool_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(pool_output.shape)plt.imshow(pool_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Fully Connected Flatten 1234567891011layer = tf.keras.layers.Flatten()flatten = layer(output)flatten.shape# OutTensorShape([1, 2352]) # 28 * 28 * 3output.shape# OutTensorShape([1, 28, 28, 3]) 123456plt.figure(figsize=(10, 5))plt.subplot(211)plt.hist(flatten.numpy().ravel())plt.subplot(212)plt.imshow(flatten[:, :100])plt.show() Dense 하나씩 연결하겠다는 의미다. 123456layer = tf.keras.layers.Dense(32, activation='relu')output = layer(flatten)output.shape# OutTensorShape([1, 32]) # 32로 줄어들었습니다. DropOut 학습할 때만 랜덤하게 끊어준다. 학습이 끝나면 다시 복구시킨다. 1234567# 0.7은 비율입니다. 얼마나 끊을 것인지 살릴 것인지layer = tf.keras.layers.Dropout(0.7)output = layer(output)output.shape# OutTensorShape([1, 32]) Build Model 1234567891011121314151617181920212223242526272829303132from tensorflow.keras import layersinput_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(shape=input_shape)# Feature Extractionnet = layers.Conv2D(32, 3, padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)# Fully Connectednet = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.25)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic-CNN')model.summary() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# OutModel: \"Basic-CNN\"_________________________________________________________________Layer (type) Output Shape Param #=================================================================input_1 (InputLayer) [(None, 28, 28, 1)] 0_________________________________________________________________conv2d_25 (Conv2D) (None, 28, 28, 32) 320_________________________________________________________________activation_8 (Activation) (None, 28, 28, 32) 0_________________________________________________________________conv2d_26 (Conv2D) (None, 28, 28, 32) 9248_________________________________________________________________activation_9 (Activation) (None, 28, 28, 32) 0_________________________________________________________________max_pooling2d_8 (MaxPooling2 (None, 14, 14, 32) 0_________________________________________________________________dropout_5 (Dropout) (None, 14, 14, 32) 0_________________________________________________________________conv2d_27 (Conv2D) (None, 14, 14, 64) 18496_________________________________________________________________activation_10 (Activation) (None, 14, 14, 64) 0_________________________________________________________________conv2d_28 (Conv2D) (None, 14, 14, 64) 36928_________________________________________________________________activation_11 (Activation) (None, 14, 14, 64) 0_________________________________________________________________max_pooling2d_9 (MaxPooling2 (None, 7, 7, 64) 0_________________________________________________________________dropout_6 (Dropout) (None, 7, 7, 64) 0_________________________________________________________________flatten_4 (Flatten) (None, 3136) 0_________________________________________________________________dense_3 (Dense) (None, 512) 1606144_________________________________________________________________activation_12 (Activation) (None, 512) 0_________________________________________________________________dropout_7 (Dropout) (None, 512) 0_________________________________________________________________dense_4 (Dense) (None, 10) 5130_________________________________________________________________activation_13 (Activation) (None, 10) 0=================================================================Total params: 1,676,266Trainable params: 1,676,266Non-trainable params: 0_________________________________________________________________","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 예제 데이터셋 (MNIST) 사용","slug":"ai-dev-3","date":"2020-07-20T04:02:24.000Z","updated":"2023-07-17T12:54:27.550Z","comments":true,"path":"2020/07/20/ai-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-3/","excerpt":"","text":"Load Packages 123456import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tf%matplotlib inline 데이터 불러오기 TensorFlow 에서 제공해주는 데이터셋(MNIST) 예제 불러오기다. 12345678from tensorflow.keras import datasetsmnist = datasets.mnist(train_x, train_y), (test_x, test_y) = mnist.load_data()train_x.shape# Out(60000, 28, 28) Image Dataset 들여다보기 불러온 데이터셋에서 이미지 데이터 하나만 뽑아서 시각화한다. 데이터 하나만 뽑기 12345image = train_x[0]image.shape# Out(28, 28) 시각화 하기 12plt.imshow(image, 'gray')plt.show() Channel 관련 [Batch Size, Height, Width, Channel] Gray Scale 이면 1, RGB 이면 3으로 만들어줘야 한다. 데이터 차원수 늘리기(numpy) 123456# -1 인 경우 마지막에 차원을 늘린다는 의미입니다.train_x = np.expand_dims(train_x, -1)train_x.shape# Out(60000, 28, 28, 1) 데이터 차원수 늘리기 (tensorflow) 12345new_train_x = tf.expand_dims(train_x, -1)new_train_x.shape# OutTensorShape([60000, 28, 28, 1]) TensorFlow 공식홈페이지에 나온 방법이다. 12345new_train_x =train_x[..., tf.newaxis]new_train_x.shape# Out(60000, 28, 28, 1) 다시 시각화 하기 주의사항: matplotlib로 이미지 시각화 할 때 gray scale의 이미지는 3번째 dimension이 없으므로, 2개의 dimension으로 차원 조절해서 넣어줘야 한다. 1234567display = new_train_x[0, :, :, 0]ordisplay = np.squeeze(new_train_x[0])display.shape# Out(28, 28) 12plt.imshow(display, 'gray')plt.show() Label Dataset 들여다보기 Label 하나를 열어서 Image와 비교하여 제대로 들어갔는지, 어떤 식으로 저장 되어 있는지 확인한다. Label 하나만 뽑아보기 1234train_y[0]# Out5 Lebel 시각화 하기 123plt.title(train_y[0])plt.imshow(train_x[0], 'gray')plt.show() OneHot Encoding 컴퓨터가 이해할 수 있는 형태로 변환해서 Label을 주도록 한다. 12345678# 1[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]# 5[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]# 9[0, 0, 0, 0, 0, 0, 0, 0, 0, 1] 1을 예시로 one hot encoding 하기 123456from tensorflow.keras.utils import to_categoricalto_categorical(1, 10)# Outarray([0., 1., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) Label 확인해서 to_categorical 사용 12345label = train_y[0]label_onehot = to_categorical(label, num_classes=10)# Outarray([0., 0., 0., 0., 0., 1., 0., 0., 0., 0.], dtype=float32) one hot encoding으로 바꾼 것과 이미지 확인 123plt.title(label_onehot)plt.imshow(train_x[0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[Tensorflow 2.0] 기초 사용법","slug":"ai-dev-2","date":"2020-07-20T02:30:15.000Z","updated":"2023-07-17T12:53:41.945Z","comments":true,"path":"2020/07/20/ai-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-2/","excerpt":"","text":"Load Packages 12import numpy as npimport tensorflow as tf Tensor 생성 list -&gt; Tensor 1234tf.constant([1, 2, 3])# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; tuple -&gt; Tensor 123456tf.constant(((1, 2, 3), (1, 2, 3)))# Out&lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy=array([[1, 2, 3], [1, 2, 3]])&gt; Array -&gt; Tensor 12345arr = np.array([1, 2, 3])tf.constant(arr)# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; Tensor에 담긴 정보 확인 shape 확인 12345tensor = tf.constant(arr)tensor.shape# OutTensorShape([3]) Data Type 확인 주의: Tensor를 생성 할 때 Data Type을 정해주지 않기 때문에 혼동이 올 수 있다. Data Type에 따라 모델의 무게나 성능 차이에 영향을 줄 수 있다. 1234tensor.dtype# Outtf.int32 Data Type 정의 1234tf.constant([1, 2, 3], dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Data Type 변환 1234tf.cast(tensor, dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Tensor에서 Numpy 불러오기 1234tensor.numpy()# Outarray([1, 2, 3]) Numpy로 변환된 것 확인 1234type(tensor.numpy())# Outnumpy.ndarray 난수 생성 Numpy에서는 난수 생성 시 기본적으로 Normal Distribution을 생성한다. Normal Distribution은 중심 극한 이론에 의한 연속적인 모양 Uniform Distribution은 중심 극한 이론과는 무관하며 불연속적이며 일정한 분포 Numpy에서 사용법 12345np.random.randn(9)# Outarray([ 0.53020669, 0.65508422, -0.59177912, 1.16459962, -1.05122869, 0.08080872, 0.17245994, 0.08721459, -0.69788519]) TensorFlow에서 사용법 1234567tf.random.normal([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[ 0.46394104, -0.8973731 , -0.1977468 ], [-1.6685097 , -0.8181516 , -1.8963411 ], [ 0.5654544 , 0.13616897, -1.7370273 ]], dtype=float32)&gt; 1234567tf.random.uniform([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[0.7996844 , 0.05048668, 0.7060809 ], [0.9390234 , 0.29056323, 0.33341527], [0.4387114 , 0.13688791, 0.12659645]], dtype=float32)&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"Tensorflow 2.0과 PyTorch 소개","slug":"ai-dev-1","date":"2020-07-17T10:02:44.000Z","updated":"2023-07-17T12:53:10.927Z","comments":true,"path":"2020/07/17/ai-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-dev-1/","excerpt":"","text":"TensorFlow 2.0 1.x에 비해 정말 쉬워졌다. Numpy Array와 호환이 쉽다. TensorBorad, TFLite, TPU 여전히 많은 사용자들이 사용한다. 상용 목적으로 주로 사용한다. PyTorch Dynamic Graph &amp; Define by Run 쉽고 빠르며 코드가 간결하다. 빠르게 성장하고 있다. 커뮤니티가 많이 활성화 되고 있다. 연구 목적으로 주로 사용한다. 둘 다 때에 따라 환경에 맞게 사용하면 될 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[Python] 시각화 기초(이미지)","slug":"ai-development-6","date":"2020-07-17T09:20:17.000Z","updated":"2023-07-17T12:53:30.798Z","comments":true,"path":"2020/07/17/ai-development-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-development-6/","excerpt":"","text":"Load Packages 12345import numpy as npfrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 이미지 불러오기 123456789path = 'images/dog.jpg'image_pil = Image.open(path)image = np.array(image_pil)image.shape# Out(300, 400, 3) 이미지 들여다 보기 1234np.min(image), np.max(image)# Out(0, 255) 그래프로 시각화 하기 12plt.hist(image.ravel(), 256, [0, 256])plt.show() 그림 나타내기 12plt.imshow(image)plt.show() 이미지 흑백으로 열기 1234567image_pil = Image.open(path).convert(\"L\")image_bw = np.array(image_pil)image_bw.shape# Out(300, 400) 흑백 이미지 열기 12plt.imshow(image_bw, 'gray')plt.show() 다른 색상으로 cmap 표현하기 gray scale 12plt.imshow(image_bw, 'gray')plt.show() RdBu(Red and Blue) 12plt.imshow(image_bw, 'RdBu')plt.show() jet 색상 값이 높을수록 빨간색, 낮을수록 파란색으로 표현한다. 12plt.imshow(image_bw, 'jet')plt.show() Colorbar 추가하기 123plt.imshow(image_bw, 'jet')plt.colorbar()plt.show() 이미지 설정 이미지 보기 사이즈를 조절한다. 123plt.figure(figsize=(10, 10))plt.imshow(image)plt.show() 이미지에 제목 추가 123plt.title('Dog')plt.imshow(image)plt.show() 두 번째 이미지 열기 1234567cat_path = 'images/cat.jpg'cat_pil = Image.open(cat_path)cat_image = np.array(cat_pil)plt.imshow(cat_image)plt.show() 두 번째 이미지를 첫 번째 이미지 모양에 맞추기 준비 먼저 opencv 패키지를 설치한다. 1$ pip install opencv-python 12345678# Inimport cv2dog_image = cv2.resize(image, (400, 300))dog_image.shape, cat_image.shape# Out((300, 400, 3), (300, 400, 3)) 이미지 합치기 123plt.imshow(dog_image)plt.imshow(cat_image, alpha=0.5)plt.show() Subplot 12345678plt.figure(figsize=(10, 10))plt.subplot(221)plt.imshow(dog_image)plt.subplot(222)plt.imshow(image_bw, 'gray')plt.subplot(223)plt.imshow(cat_image)plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] 시각화 기초(그래프)","slug":"ai-development-5","date":"2020-07-16T09:08:35.000Z","updated":"2023-07-17T12:52:51.906Z","comments":true,"path":"2020/07/16/ai-development-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/16/ai-development-5/","excerpt":"","text":"Python 에서 matplotlib 를 사용하여 시각화하는 방법에 대해 알아보겠다. Load Packages 1234import numpy as npimport matplotlib.pyplot as plt%matplotlib inline Basic Attributes 123456789101112131415alpha : 투명도king : 그래프 종류 'line', 'bar', 'barh', 'kde'logy : Y축에 대해 Log scalinguse_index : 객체의 색인을 눈금 이름으로 사용할지 여부rot : 눈금 이름 돌리기 (rotating) 0 ~ 360xticks, yticks : X, Y축으로 사용할 값xlim, ylim : X, Y축의 한계grid : 축의 그리드를 표현할지 여부subplots : 각 column에 독립된 subplot 그리기sharex, sharey : subplots=True 이면 같은 X, Y축을 공유하고 눈금과 한계를 연결figsize : 생성될 그래프의 크기를 tuple로 지정title : 그래프의 제목 지정legend : subplot의 범례 지정sort_columns : column을 알파벳 순서로 그린다. Matplotlib 사용하기 점선 그래프 그리기 123data = np.random.randn(50).cumsum()plt.plot(data)plt.show() 여러 그래프 그릴 준비 하기 123plt.subplot(1, 2, 1)plt.subplot(1, 2, 2)plt.show() Multi Graph 그리기 12345678910111213hist_data = np.random.randn(100)scat_data = np.arange(30)plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 옵션 그래프를 그릴 때 표시 되는 색이나 마커 패턴을 바꾸는 것을 확인한다. 색상: r(빨간색), g(초록색), b(파란색), C(청록색), y(노란색), k(검은색), w(흰색) 마커: o(원), v(역삼각형), ^(삼각형), s(네모), +(플러스), .(점) 12plt.plot(data, 'go')plt.show() 그래프 사이즈 조절 plt.figure 안에 figsize를 이용하여 가로, 세로 길이 조절 가능하다. (inch 단위) 123plt.figure(figsize=(10, 10))plt.plot(data, 'k+')plt.show() 여러 그래프 그리고 그에 대한 크기 조절을 한다. 12345678910111213# 맨 위에 있어야 한다.plt.figure(figsize=(10, 5))plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 겹치기와 legend 표시 123456data = np.random.randn(30).cumsum()plt.plot(data, 'k--', label='Default')plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')plt.legend()plt.show() 이름 달기 12345plt.plot(np.random.randn(1000).cumsum())plt.title('Random Graph')plt.xlabel('Stages')plt.ylabel('Values')plt.show() 종합 1234567plt.title('Graph')plt.plot(np.random.randn(500).cumsum(), 'k^', label='one')plt.plot(np.random.randn(500).cumsum(), 'b.', label='two')plt.plot(np.random.randn(500).cumsum(), 'r', label='three')plt.legend()plt.show() 그래프 저장하기 12# 현재 작업 위치로 저장한다.plt.savefig('saved_graph.svg')","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] Numpy 기초(3)","slug":"ai-development-4","date":"2020-07-09T07:16:50.000Z","updated":"2023-07-17T12:52:22.983Z","comments":true,"path":"2020/07/09/ai-development-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/09/ai-development-4/","excerpt":"","text":"zeros 0으로 채워진 numpy 배열을 만든다. 123456np.zeros([3, 3])# Outarray([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) ones 1로 채워진 numpy 배열을 만든다. 123456np.ones([3, 3])# Outarray([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) arange 하나의 값만 입력하면 1씩 증가하는 1차원 배열을 만든다. 1234np.arange(10)# Outarray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 두 개의 인자를 넣으면 입력한 값의 범위만큼 배열을 만든다. 1234np.arange(4, 9)# Outarray([4, 5, 6, 7, 8]) reshape 1차원 배열의 차원 수를 바꿀때 사용된다. 123456np.arange(9).reshape(3, 3)# Outarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) Index 기본적으로 python 에서 쓰는 방식과 동일하다. 12345arr = np.arange(9).reshape(3, 3)arr[1]# Outarray([3, 4, 5]) Slicing 다차원 배열의 원소 중 복수 개를 접근하기 위해 사용한다. 123456arr = np.arange(9).reshape(3, 3)arr[1:]# Outarray([[3, 4, 5], [6, 7, 8]]) 12345arr[1:, 1:]# Outarray([[4, 5], [7, 8]]) Boolean Indexing 원하는 행 또는 열의 값만 얻을 수 있고, 값들을 변경할 수 있다. 1234567891011data = np.random.randn(3, 3)data &lt;= 0# Outarray([[-0.43152818, -2.40848595, -0.00309727], [ 0.74972847, 0.18525482, -0.39854904], [ 1.09053126, 0.32096086, 0.31703319]])array([[ True, True, True], [False, False, True], [False, False, False]]) 1234data[data &lt;= 0]# Outarray([-0.43152818, -2.40848595, -0.00309727, -0.39854904]) 123456data[data &lt;= 0] = 1# Outarray([[1. , 1. , 1. ], [0.74972847, 0.18525482, 1. ], [1.09053126, 0.32096086, 0.31703319]]) Broadcast 연산 하려는 서로 다른 두 개의 행렬의 shape가 같지 않고, 한쪽의 차원이라도 같거나 또는 값의 갯수가 한 개 일 때 이를 여러 복사를 하여 연산한다. 1234567arr = np.arange(9).reshape(3, 3)arr + 3# Outarray([[ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) 123456arr * 3# Outarray([[ 0, 3, 6], [ 9, 12, 15], [18, 21, 24]]) 123456arr + np.array([1, 2, 3])# Outarray([[ 1, 3, 5], [ 4, 6, 8], [ 7, 9, 11]]) Math Function 배열 연산에 대해 여러가지 예제다. 123456arr + 5arr * 5arr + arrnp.add(arr, 1)np.multiply(arr, 3) 12345678910np.sum(arr)np.sum(arr + arr_2)np.sum(arr, 0) # 0차원 기준으로 더해서 배열을 만든다.np.max(arr)np.max(arr, 0) # 0차원에서 가장 큰 값들을 배열로 만든다.np.min(arr)np.mean(arr) 12345678910arr = np.array([1, 6, 3, 7, 3, 2, 9, 0, 2])np.argmax(arr) # 가장 큰 수의 index값을 리턴한다.# Out6np.argmin(arr)# Out7 12345arr = np.array([3, 5, 6, 6, 3, 3, 1])np.unique(arr) # 유니크한 값들을 리턴한다.# Outarray([1, 3, 5, 6])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(2)","slug":"ai-development-3","date":"2020-07-02T01:36:18.000Z","updated":"2023-07-17T12:51:30.649Z","comments":true,"path":"2020/07/02/ai-development-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/02/ai-development-3/","excerpt":"","text":"Numpy 기초에 대해 다뤄보겠다. Load Package 1import numpy as np data type 배열의 dtype 을 봅니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3]])arr.dtype# Outdtype('int32') .astype() 으로 datatype 을 변환 가능하다. 123456arr = arr.astype('float32')arr = arr.astype(np.float32)# Outarray([[1., 2., 3.], [1., 2., 3.]], dtype=float32) len(arr.shape) 를 통해서 차원이 갯수를 확인할 수 있지만, 다음과 같이 ndim 을 통해 차원 수를 확인하다. 12345len(arr.shape)arr.ndim# Out2 Reshape 차원을 바꾼다. 12345arr = arr.reshape([1, 6])arr.shape# Out(1, 6) 차원을 몇 개로 나눠야할지 모를 경우 -1 을 활용하다. 12345arr = arr.reshape(-1)arr.shape# Out(6,) 3차원으로 늘리는 방법이다. 123456arr = np.random.randn(8, 8) # (8, 8)arr = arr.reshape([32, 2]) # (32, 2)arr = arr.reshape([-1, 2, 1])# Out(32, 2, 1) Ravel 배열을 1차원으로 바꿔준다. 나중에 배열 layer를 flatten 할 때 같은 기능이라 생각하면 된다. 12345arr = arr.ravel()arr.shape# Out(64,) np.expand_dims() 안의 값은 유지하되 차원 수를 늘리고 싶을 때 사용한다. 12345arr = np.expand_dims(arr, 0)arr.shape# Out(1, 64)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(1)","slug":"ai-development-2","date":"2020-07-01T08:11:52.000Z","updated":"2023-06-19T12:29:31.495Z","comments":true,"path":"2020/07/01/ai-development-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/01/ai-development-2/","excerpt":"","text":"Numpy 란 Numpy는 C언어로 구현된 파이썬 라이브러리로써, 고성능의 수치계산을 위해 제작되었습니다. Numerical Python의 줄임말이기도 한 Numpy는 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공합니다. 출처: Tigercow.Door Numpy는 고차원적인 데이터를 다루기 쉽게 만들어져 있어 딥러닝을 하게 되면 많이 접하게 됩니다. 이제 Numpy 사용방법에 대해 알아보겠습니다. 12# Numpy 사용하기import numpy as np 0차원 numpy array는 1 또는 5, 10와 같이 숫자 데이터를 array화 해줄 수 있습니다. 12345arr = np.array(5);arr.shape # 배열의 형태(크기)를 나타냅니다.# Out() # shape가 아무것도 없는 것으로 나옵니다. 1234arr.ndim # 배열의 차원을 나타냅니다.# Out0 # 0차원을 의미합니다. 1차원 숫자가 10과 같이 하나만 들어간다고 해도 [] 리스트를 한번 씌우게 되면 차원이 생깁니다. 이때는 1차원이 되는데 numpy 에서 shape를 표현할 때 (1)이 아닌 (1,) 형식으로 표현하게 됩니다. 12345arr = np.array([5])arr.shape# Out(1,) (3,)에서 3은 3이라는 값이 들어간 것이 아닌 1차원에 3개의 값이 들어갔다는 의미입니다. 2차원 대괄호를 추가적으로 씌우면 차원이 추가적으로 하나 생깁니다. 12345arr = np.array([[1, 2, 3]])arr.shape# Out(1, 3) 다음의 shape를 보면 차원이 2개 있고, 각 차원 마다 각각 3개의 값이 들어있다는 의미입니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])arr.shape# Out(3, 3) 참고로 0차원 숫자에 대괄호를 2번 씌우면 두 개의 차원이 됩니다. 12345arr = np.array([[10]])arr.shape# Out(1, 1) 다차원 12345678910111213141516171819arr = np.array([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]])# Outarray([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]]) 4차원의 배열을 나타냅니다. 1234arr.shape# Out(2, 2, 3, 3)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"인공지능 개발준비 - 개발환경 구축(Windows)","slug":"ai-development-1","date":"2020-06-30T02:34:28.000Z","updated":"2023-07-13T03:30:36.205Z","comments":true,"path":"2020/06/30/ai-development-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/ai-development-1/","excerpt":"","text":"인공지능(AI)을 통해 개발을 하기 위해 개발 도구들을 설치한다. 1. Anaconda 설치 Anaconda는 여러가지 수학 및 과학 패키지들을 기본적으로 포함하고 있는 Python 배포판이다. 그래서 머신러닝, 딥러닝, 데이터 분석에서 사용을 하려고 한다면 Anaconda를 통해 설치하는 것이 좋다. Anaconda Download 사이트에 접속하여 아래로 내려가 보면 다운로드 화면이 보인다. 현재 Windows 운영체제에 맞게 선택하여 다운로드를 한다. 다운로드가 완료되면 설치를 진행한다. Next 버튼을 클릭하다가 아래 그림처럼 All Users를 선택한다. 간혹 Windows에서 사용자의 계정을 한글로 만들었을 경우 설치할 때 또는 개발할 때 에러가 날 수 있기 때문에 선택한다. 아래 그림처럼 체크박스도 선택을 하여 환경변수 설정이 되도록 한다. Install 버튼을 클릭하면 설치가 된다. 설치가 잘 되었나 확인하려면 workspace 폴더에서 커맨드 창을 열고 다음 명령어를 실행한다. 1$ c:\\workspace&gt; jupyter notebook Jupyter Notebook 페이지가 실행되고 Python 코드를 작성할 수 있다. 2. TensorFlow 설치 TensorFlow는 머신러닝을 위한 엔드 투 엔드 오픈소스 플랫폼입니다. 도구, 라이브러리, 커뮤니티 리소스로 구성된 포괄적이고 유연한 생태계를 통해 연구원들은 ML에서 첨단 기술을 구현할 수 있고 개발자들은 ML이 접목된 애플리케이션을 손쉽게 빌드 및 배포할 수 있습니다. 출처 : https://www.tensorflow.org/?hl=ko TensorFlow 2 설치 사이트에 접속한다. 설치 가이드에 따라 설치를 한다. 1$ pip install tensorflow 설치가 완료되면 Jupyter Notebook에서 import를 하여 확인한다. 3. Pytorch 설치 PyTorch는 Python을 위한 오픈소스 머신 러닝 라이브러리입니다. Torch를 기반으로 하며, 자연어 처리와 같은 애플리케이션을 위해 사용됩니다. 출처 : 위키백과 Pytorch 사이트에 접속합니다. 아래로 내려가 보면 여러가지 설정을 하여 설치하는 방법을 안내해준다. Windows 버전이기 때문에 아래 그림 처럼 설정을 한다. 만약에 GPU를 사용할 수 있으면 CUDA 버전에 맞게 설정하면 된다. 설정이 완료되었으면 Run this Command 칸의 내용을 복사하여 Command 창에 붙여넣기 하고 실행을 한다. TensorFlow와 마찬가지로 Jupyter Notebook에서 import를 하여 설치가 완료되었는지 확인한다. AI 개발 준비가 모두 완료 되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"}]},{"title":"[C++] string을 이용한 File Path 분리 방법","slug":"cpp-coding-1","date":"2020-06-30T02:05:16.000Z","updated":"2023-07-13T03:30:58.368Z","comments":true,"path":"2020/06/30/cpp-coding-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/cpp-coding-1/","excerpt":"","text":"개요 string 형식의 파일 경로를 이용하여 File Path와 Name을 분리한다. 1) File Path와 File Name 분리 1234567891011121314#include &lt;iostream&gt;namespace using std;int main()&#123; string pullPath = \"c:\\\\test\\\\test.tif\"; int find = pullPath.rfind(\"\\\\\") + 1; string filePath = pullPath.substr(0, find); string fileName = pullPath.substr(find, pullPath.length() - find); cout &lt;&lt; \"Folder Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"File Name : \" &lt;&lt; fileName &lt;&lt; endl;&#125; 결과 12Folder Path : c:\\\\testFile Name : test.tif 2) 파일 확장자 바꾸기 123456789101112131415161718#include &lt;iostream&gt;namespace using std;int main()&#123; string filePath = \"c:\\\\test\\\\test.tif\"; string modExt = \"ntf\"; int ext = filePath.rfind(\"tif\"); int name = filePath.rfind(\"\\\\\") + 1; string dstPath = filePath.substr(0, name); dstPath += filePath.substr(name, ext - name); dstPath += modExt; cout &lt;&lt; \"Input Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"Output Path : \" &lt;&lt; dstPath &lt;&lt; endl;&#125; 결과 12Input Path : c:\\\\test\\\\test.tifOutput Path : c:\\\\test\\\\test.ntf","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"Hexo Quick Start","slug":"hello-world","date":"2020-06-29T06:30:00.000Z","updated":"2022-12-30T01:18:40.221Z","comments":true,"path":"2020/06/29/hello-world/","link":"","permalink":"http://hgko1207.github.io/2020/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[Git] 이클립스에서 Git Repository 연동","slug":"eclipse-git-clone","date":"2020-05-18T01:48:33.000Z","updated":"2023-07-13T03:28:59.293Z","comments":true,"path":"2020/05/18/eclipse-git-clone/","link":"","permalink":"http://hgko1207.github.io/2020/05/18/eclipse-git-clone/","excerpt":"","text":"이클립스와 Git 원격저장소 연동하는 방법과 프로젝트를 내려받는 방법에 대해 알아보도록 하겠다. 1. 원격저장소 주소 복사 먼저 github 사이트에서 생성한 저장소의 주소를 복사한다. 2. 이클립스 실행 이클립스를 실행하고 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보인다. Git을 선택하고 [OK] 버튼을 눌러 활성화 시킨다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경된다. 3. 원격저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭한다. Clone Git Repository 창의 첫 번째 빨간 박스에 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력된다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭한다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭한다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭한다. 원격저장소가 연동되면 아래 그림과 같이 프로젝트를 확인할 수 있다. 4. 프로젝트 내려받기 연동된 원격저장소에서 Working Tree -&gt; 프로젝트 선택 -&gt; 우클릭 -&gt; Import Projects 선택을 한다. Import Projects 창에서 내려받아지는 경로를 확인 후 [Finish] 버튼을 클릭한다. 내려받기가 완료되면 프로젝트가 생성된다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"}]},{"title":"Hyperspectral(초분광) 센서","slug":"satellite-hyperspectral","date":"2020-05-11T01:17:10.000Z","updated":"2023-07-13T03:27:46.618Z","comments":true,"path":"2020/05/11/satellite-hyperspectral/","link":"","permalink":"http://hgko1207.github.io/2020/05/11/satellite-hyperspectral/","excerpt":"","text":"Hyperspectral 특징 초분광 영상의 픽셀 분광은 하나의 표면에 대한 다중분광픽셀 스펙트럼에서 이용할 수 있는 것보다 훨씬 많은 정보 제공 가능하다. Hyperspectral 원격탐사 특징 입사되는 빛을 분광시켜 영상의 각 화소에 해당하는 지표물의 수십에서 수백 개의 분광 정보를 취득하고 그 개체의 정보를 이미지 형태로 확보 가능 물질 고유의 광학적 성질과 물질의 흡수 및 반사 특징을 분석함으로써 토지피복, 식생, 그리고 수질 등의 식별에 주로 이용된다. 스펙트럼 영상은 두 개의 공간적 차원과 하나의 스펙트럼 크기로 구성된 3차원 (x, y, λ)으로 나타남(x, y : 공간적 2차원 / λ : 스펙트럼 크기) 2차원 (2-D) 검출기에서 각 화소에 스펙트럼 정보를 수집하여 초분광 큐브로 알려진 공간 및 스펙트럼 정보인 3차원(3-D) 데이터를 형성 Hyperspectral 활용 위성 Terra/Aqua(MODIS) STSat-3(COMIS) NMP-EO-1(Hyperion) NMP-EO-1(Hyperion)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"}]},{"title":"[MySQL] Query","slug":"mysql-query","date":"2020-05-07T02:17:14.000Z","updated":"2023-03-14T02:17:52.190Z","comments":true,"path":"2020/05/07/mysql-query/","link":"","permalink":"http://hgko1207.github.io/2020/05/07/mysql-query/","excerpt":"","text":"SELECT 123SELECT * FROM 테이블명SELECT * FROM 테이블명 WHERE 조건SELECT 필드명1, 필드명2, ... FROM 테이블명 WHERE 조건 INSERT 123INSERT INTO 테이블명(필드명1, 필드명2, 필드명3, ...) VALUES (데이터값1, 데이터값2, 데이터값3, ...)또는INSERT INTO 테이블명 VALUES (데이터값1, 데이터값2, 데이터값3, ...) UPDATE 1UPDATE 테이블명 SET 필드명1=데이터값1, 필드명2=데이터값2, ... WHERE 필드명=데이터값 DELETE 1DELETE FROM 테이블명 WHERE 필드명=데이터값 중복 데이터 조회 중복된 것 모두 조회 1SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 중복된 갯수가 n개 이상인 것 12345SELECT 필드명, count(*) as 변수명 FROM 테이블명 GROUP BY 필드명 HAVING 변수명 &gt; n;또는SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 HAVING count(*) &gt; n;SELECT 필드명, count(*) as 변수명 FROM 테이블명 WHERE 조건 GROUP BY 필드명 HAVING 변수명 &gt; n; 중복 데이터 추출(WHERE 절의 IN 사용) 123SELECT * FROM 테이블명 WHERE column1 IN ( SELECT column1 FROM 테이블명 WHERE 조건 GROUP BY column1 HAVING count(*) &gt; 1) AUTO_INCREMENT 초기화 1ALTER TABLE 테이블명 AUTO_INCREMENT = 시작할 값; 날짜 12SELECT * FROM 테이블명 WHERE 필드명 &gt;= 시작날짜SELECT * FROM 테이블명 WHERE 필드명 BETWEEN 시작날짜 and 종료날짜","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"Clean Code","slug":"book-cleancode","date":"2020-04-28T00:50:27.000Z","updated":"2023-07-13T03:27:29.689Z","comments":true,"path":"2020/04/28/book-cleancode/","link":"","permalink":"http://hgko1207.github.io/2020/04/28/book-cleancode/","excerpt":"","text":"책 정보 책 소개 애자일 소프트웨어의 혁명적인 패러다임을 제시하는 책이다. 저자 로버트 마틴은 오브젝트 멘토(Object Mentor)의 동료들과 힘을 모아 ‘개발하며’ 클린 코드를 만드는 최상의 애자일 기법을 정제하여『Clean Code 클린 코드』에 담았다. 아주 많은 코드를 읽고 그 코드의 무엇이 옳은지, 그른지 생각하며 전문가로서 자신이 지니는 가치를 돌아보기 위해 꾸준히 노력한다면, 이 책을 통해 여러분의 프로그래밍 실력은 한층 더 높아질 것이다. 리뷰 전부 다 읽어보진 못하였지만 읽다보면 얼마나 잘못하고 있었는지 반성하게 된다. 의미 있는 이름, 좋은 주석 다는 법, 객체와 자료 구조 등 어떻게 깨끗하고 아름다운 코드를 작성할 수 있는지 알려준다. 잘못된 점과 좋은 점을 짚어주기 때문에 내가 짰던 코드와 비교 할 수 있고 17장에는 사례 연구를 만들면서 수집한 휴리스틱과 냄새를 열거한다. 협업을 할 때 필요한 내용들이며, 지금은 중간 개발자로서 신입 개발자를 교육할 때에도 정말 좋은 추천서라고 느껴진다. 책 내용이 많고 글자 수도 많아서 끈기 있게 읽어야 할 것 같다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"}]},{"title":"Microwave(극초단파) 센서","slug":"satellite-microwave","date":"2020-04-27T00:42:37.000Z","updated":"2023-07-13T03:27:04.724Z","comments":true,"path":"2020/04/27/satellite-microwave/","link":"","permalink":"http://hgko1207.github.io/2020/04/27/satellite-microwave/","excerpt":"","text":"Microwave 특징 물체들이 방출하는 마이크로웨이브 파를 위성에서 감지하여 원격탐사에 활용하는 기술이다. 마이크로파의 파장 영역은 보통 1mm ~ 1m 이다. 자연방사 에너지를 관측하는지, 위성에서 Microwave를 쏘아서 되돌아오는 신호를 관측하는지에 따라 Passive microwave와 Active microwave로 나눌 수 있다. 대표적으로 SAR, 산란계, 고도계, 복사계로 나눠진다. Microwave 원격탐사 특징 1. Passive vs Active 2. 센서 특징 Microwave 활용 위성 GCOM-W1(AMSR-2) SMAP(SMAP) NOAA, AQUA, Metop(AMSU-A) GPM(GMI, GPM Microwave Imager)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"}]},{"title":"IR(적외선) 센서","slug":"satellite-ir-sensor","date":"2020-04-24T00:50:14.000Z","updated":"2023-07-13T03:26:42.946Z","comments":true,"path":"2020/04/24/satellite-ir-sensor/","link":"","permalink":"http://hgko1207.github.io/2020/04/24/satellite-ir-sensor/","excerpt":"","text":"IR(Infrared) 정의 가시광선대의 적색 끝부분에서부터 마이크로파전까지의 전자기파, 가시광선이나 자외선에 비해 강한 열작용을 가지고 있다. 파장 대역 : 0.7-1000㎛ 활용 분야 : 소독/멸균, 외과수술 및 종양 제거, 군사적(야간 투시경), 야간 촬영용 카메라 IR 특징 태양빛을 프리즘을 이용하여 스펙트럼으로 분산시킬 때 붉은색보다 더 바깥쪽에 위치함 열을 가지는 모든 물체에서 방출 또는 반사되는 특징이 있기 때문에 강한 열작용을 가짐(열선이라고도 불림) 파장에 따라 지구 대기를 투과하지 못하는 특성이 있어 대기 환경에 민감 IR 원격탐사의 특징 장파장으로 갈수록 물체 고유의 특성이 잘 관측될 수 있음 야간이나 해무(바다 안개), 옅은 구름이 낀 상황에서도 촬영 가능 해양 및 구름의 온도를 측정하여 지구의 열 balance를 측정하고, 해수표면으로부터 방사되어 나오는 원적외선을 감지함 인접한 물체간의 열적 특성 차이나 잠열 분석이 가능한 정보 제공(공간 분해능 + 열적 분해능) 센서의 발달과 더불어 온도 해상도는 1K에서 0.3K 정도로 높아짐 공간 해상도 역시 250m의 해상도를 갖는 것이 개발됨에 따라 large scale에서 small scale의 연구가 가능해짐 IR 활용 위성 Terra(ASTER) Terra/Aqua(MODIS) Landsat-7(ETM+)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"}]},{"title":"[Android Studio] 설치 및 주요 기능","slug":"android-studio","date":"2020-04-21T00:49:50.000Z","updated":"2023-07-13T03:26:15.516Z","comments":true,"path":"2020/04/21/android-studio/","link":"","permalink":"http://hgko1207.github.io/2020/04/21/android-studio/","excerpt":"","text":"1. Android Studio 다운로드 및 설치 다운로드 사이트에서 최신 버전의 Android Studio를 다운받아 설치합니다. 현재 최신은 3.6.3 버전이다. 설치를 완료하고 다음 화면이 오픈되면 이제 개발을 시작할 수 있다. 2. 프로젝트 생성 Start a new Android Studio Project 선택 Slelect a Project Templat Empty Activity 선택 Configure Your Project Name: HelloApp Package: com.hgko.helloapp Language: Java or Kotlin Minimum SDK: API 26: Android 8.0(Oreo) Finish 버튼 클릭하면 다음과 같이 프로젝트가 생성된다. 3. 실행 1) 스마트폰 연결 시 스마트폰에서 USB 디버깅 설정 설정 &gt; 빌드 번호 6번 터치 -&gt; 개발자 옵션 화성화(메뉴가 보임) &gt; USB 디버깅 활성화 선택 스마트폰 케이블 연결 logcat에서 디바이스 연결 확인 2) 가상 디바이스 사용 시 Tools &gt; AVD Manager Create Virtual Device… 클릭 Select Hardware 적당한 디바이스를 선택한다. 예) Phone &gt; Pixel XL System Image Android 버전을 선택 Finish 버튼 클릭 스마트폰 또는 가상 디바이스를 연결 후 상단 툴바에서 장비를 선택 후 Run을 클릭하면 컴파일이 되며, 앱이 설치되고 구동된다. 4. SDK 설치 Tools &gt; SDK Manager 에서 설치 현황 및 안드로이드 버젼별 SDK 설치/삭제/업데이트 등을 수행할 수 있다. 5. Device File Explorer 연결된 장비(스마트폰 or 가상 디바이스)의 파일 시스템을 탐색하는 뷰를 제공한다. View &gt; Tool Windows &gt; Device File Explorer 메뉴를 클릭하여 다음과 같이 Device File Explorer 뷰를 오픈한다. 디바이스 파일 중에 특히 다음과 같은 경로들이 유용하다. 1) data/data/app_name/ 내부 저장소에 저장괸 입의 데이터 파일 경로 2) sdcard/ 외부 사용자 SD 카드에 저장된 파일(사진 등) 경로 6. 주요 단축키 참고 : Android 스튜디오 단축키 설명 단축키 기본 코드 완성 Ctrl+Space 스마트 코드 완성 Ctrl+Shift+Enter, Ctrl+Enter 자동 Import Alt+Enter 주석 Ctrl+/ 블록 주석 Ctrl+Shift+/ 빌드 Ctrl+F9 복사 F5 코드 서식 자동 지정 Ctrl+Alt+L 자동 들여 쓰기 Ctrl+Alt+I 7. 자동 import 설정 Alt + Enter를 입력하지 않아도 클래스 사용시 자동으로 import 문을 추가해 주는 기능이다. File &gt; Settings &gt; Editor &gt; General &gt; Auto Import 에서 다음과 같이 “Add unambiguous…” 와 “Optimize imports…” 를 체크한다. 8. 새로운 개념/기능 1) ART VM 안드로이드는 이전 가지는 DVT에서 구동되었으나 현재는 ART라는 VM을 이용한다. ART는 JIT(Just In Time, 실행 시 컴파일 방식으로 2.2 버젼부터 지원)을 지원하는 VM들과 달리 앱이 설치 시 전체 바이트 코드가 기계어로 컴파일되는 AOT(Ahead Of Time)를 이용하므로 획기적으로 성능이 개선되었다. 2) App Bundle 안드로이드 앱 내보내기에 기존 APK 파일 외에 앱 번들이 추가되었다. Google Play의 새로운 앱 제공 모델인 Dynamic Delivery는 App Bundle을 사용하여 각 사용자의 기기 설정에 최적화된 APK를 생성하고 제공하므로, 사용자는 앱 실행에 필요한 최소한의 코드와 리소스만 다운로드하면 된다. 개발자가 더 이상 다양한 기기를 지원하기 위해 여러 개의 APK를 빌드하고 서명하고 관리할 필요가 없으며 사용자는 더 작고 최적화된 앱을 다운로드할 수 있다. 또한 앱 프로젝트에 동적 기능 모듈을 추가하여 App Bundle에 포함할 수 있다. 모듈의 일부 기능과 자원(동영상, 이미지 등)들은 사용자가 처음 앱을 다운로드하고 설치할 때 포함되지 않도록 할 수 있다. 나중에 앱에서 Play Core 라이브러리를 사용하여 이러한 모듈을 동적 기능 APK로 다운로드하도록 요청할 수 있다. 정리하면 App Bundle로 내보내기를 추천한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"}]},{"title":"[JavaScript] IE에서 작동하지 않는 BLOB 다운로드","slug":"javascript-blob","date":"2020-04-20T00:56:01.000Z","updated":"2023-07-13T03:24:54.579Z","comments":true,"path":"2020/04/20/javascript-blob/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/javascript-blob/","excerpt":"","text":"이미지를 Jcrop 라이브러리를 사용하여 자르고 Canvas 영역을 blob 형식으로 바꿔서 a Tag 를 생성하여 다운로드를 시도하였다. 크롬에서는 잘 동작하였지만 IE 에서는 동작하지 않고 에러를 발생하였다. 아래 코드처럼 작성하였더니 둘 다 동작하였다. 소스 코드 12345678910111213function downloadURI(blob, name) &#123; if (window.navigator &amp;&amp; window.navigator.msSaveOrOpenBlob) &#123; // IE에서 동작 window.navigator.msSaveBlob(blob, name); &#125; else &#123; // 크롬에서 동작 var link = document.createElement('a'); link.download = name; link.href = URL.createObjectURL(blob); link.click(); delete link; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"}]},{"title":"SAR 위성 활용","slug":"satellite-sar","date":"2020-04-20T00:31:30.000Z","updated":"2022-09-02T14:49:52.079Z","comments":true,"path":"2020/04/20/satellite-sar/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/satellite-sar/","excerpt":"","text":"SAR 위성 소개 SAR 위성이란? SAR(Synthetic Aperture Radar)란 각 Band의 다양한 파장대의 신호를 이용 지표면의 특성을 영상화 함 BANS 별 소개 SAR(파장 and 편파) 1. KOMPSAT-5(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. TerraSAR-X(독일의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. ALOS-2(일본의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 4. RADARSAT-2(캐나다의 위성) 위성의 본체 및 탑재체 제원 촬영모드 활용 분야 별 촬영 모드(개념도) 활용 분야 별 촬영 모드(지상) 활용 분야 별 촬영 모드(해양)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"}]},{"title":"[Android Studio] lombok 사용 방법","slug":"android-lombok","date":"2020-04-18T11:14:23.000Z","updated":"2023-07-13T03:24:41.511Z","comments":true,"path":"2020/04/18/android-lombok/","link":"","permalink":"http://hgko1207.github.io/2020/04/18/android-lombok/","excerpt":"","text":"자바에서 코드를 작성 시 모델을 만들다 보면 constructor 와 기본 getter/setter 그리고 상황에 따라서 builder를 만들어 사용해야 한다. 그런데 이런 일들을 모두 타이핑 하다 보니 보일러플레이트 같은 코드들이 많이도 써야한다. lombok 를 사용하면 모델 객체들의 불필요한 보일러플레이트 코드들을 줄일 수 있다. annotation 방법으로 사용하기 때문에 사용 방법도 간단하다. lombok annotation @Getter / @Setter 기본적으로 멤버 필드들에 대한 getter/setter 메소드들을 만들어 준다. @AllArgsConstructor / @NoArgsConstructor 멤버필드들이 모두 파라미터로 지정된 생성자와 빈 생성자를 만들어 준다. @Builder 모델을 빌더 패턴으로 만들어 준다. @ToString toString의 override된 메소드를 만들어 준다. @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 합쳐 둔 어노테이션이다. @EqualsAndHashCode 해당 객체의 equals()와 hashCode() 메소드를 생성한다. 그 외에도 여러가지가 있다. 그럼 AndroidStudio 에 적용하는 방법을 알아보자. 적용 방법 우선 lombok plugin을 설치해야 합니다. File -&gt; Settings -&gt; Plugins -&gt; Browse repositories lombok을 검색하여 Lombok Plugin을 설치한다. gradle에 lombok 적용하기 Gradle Scripts -&gt; build.gradle 파일을 연다. dependencies 아래에 추가해 준다. 12compileOnly 'org.projectlombok:lombok:1.18.12'annotationProcessor 'org.projectlombok:lombok:1.18.12' 이와 같은 과정 후에 다음과 같은 결과를 볼 수 있다. 결과","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"}]},{"title":"광학 위성 활용","slug":"satellite-optical","date":"2020-04-17T04:04:26.000Z","updated":"2022-09-02T14:49:52.079Z","comments":true,"path":"2020/04/17/satellite-optical/","link":"","permalink":"http://hgko1207.github.io/2020/04/17/satellite-optical/","excerpt":"","text":"위성영상 활용 목적 원격탐사 : 기록장치에 의해 물리적인 접속이 없이 관심 대상이 되는 목표물이나 현상에 대한 정보를 획득하는 방법 원격 : 관찰자와 관찰 대상이 분리되어 간격이 있는 것 탐사 : 감지하거나 특징을 지음 = 원거리에서 관찰 대상을 감지하거나 특징을 찾는 것 광학 위성 소개 고성능 광학 카메라를 탑재한 지구 관측 위성 해상도 : 위성의 해상도는 10m 급에서 0.4m 에 이르기까지 다양함 저해상도 활용 : 주로 광범위한 지역의 탐사나 지속적 관찰이 필요한 부분에 사용 고해상도 활용 : 고해상도로 갈수록 군사용이나 특수목적으로 사용 촬영 방식 : 전자광학카메라를 이용한 촬영(광학 신호를 전자신호로 변환하여 영상을 제공하는 방식) 장점 : 눈에 익숙한 영상이 촬영 됨 단점 : 촬영 지역에 구름이 심하게 끼거나 밤이 되면 사진을 찍지 못함 1. KOMPSAT-3(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. World View-3(미국의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. SkySat-2(미국의 상용 위성 + Google) 위성의 본체 및 탑재체 제원 배포자료 활용 분야 4. STOP-7(프랑스의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"}]},{"title":"리팩토링","slug":"book-refactoring","date":"2020-04-16T04:43:08.000Z","updated":"2023-07-13T03:22:43.239Z","comments":true,"path":"2020/04/16/book-refactoring/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/book-refactoring/","excerpt":"","text":"책 정보 책 소개 코드 품질을 개선하는 객체지향 사고법을 정리한 참고서 프로그램이 돌아가기면 하면 객체지향인가? 객체지향이라는 도구를 제대로 활용하지 못하고 마구잡이로 작성한 코드에는 악취가 진동한다. 리팩토링은 코드의 동작이나 의도는 유지하면서 코드의 구조, 재사용성, 가독성을 개선해 코드의 악취를 제거하고 전체 디자인을 개선하는 방법이다. 독자는 72가지 리팩토링 기법을 통해 코드를 점진적으로 개선하는 방법을 학습할 수 있으며, 이 책을 마쳤을 때는 객체지향 프로그래밍 능력이 한 단계 향상될 것이다. 객체지향 언어의 문법을 익혔다고 저절로 객체지향 프로그래밍을 할 수 있는 게 아니다. 리팩토링 카탈로그를 통해 어떤 코드를 고쳐야 하는지, 왜 고쳐야 하는지, 고친 코드가 왜 좋은지 이해할 수 있다. 이런 과정을 통해 객체지향에 어울리는 코드 디자인을 배우게 되고, 자신의 코딩 스타일도 바뀌게 된다. 이 책을 읽기 전과 후는 코드의 품질에 결정적인 차이를 가져오게 된다. 리뷰 3년차 개발을 하던 중 팀장님에게 추천 받았던 책이다. 여러가지 프로젝트를 개발하면서 고민했던 부분이 개발을 하고 있을 때 또는 유지보수 시 코드를 다시 보게 되면 너무 지저분해 보이고 가독성도 떨어지며 수정 작업이 오래걸리는 것을 느끼게 되었다. 그래서 중복 코드를 제거하고 코딩 규칙을 검색하면서 개선해보려고 노력을 하였지만 지식이 없어 힘들었다. 이 책을 읽으면서 리팩토링에 대해 알게 되고 필요성을 더욱 느끼게 되고 개발자로서 조금 더 성장할 수 있는 계기가 된 것 같다. 다만 번역서이기도 하고 글이 많아 읽기가 힘든 부분이 있다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"}]},{"title":"[Openlayers] getGetFeatureInfoUrl 함수 사용","slug":"openlayers-dev-1","date":"2020-04-16T01:02:45.000Z","updated":"2023-07-13T03:23:06.155Z","comments":true,"path":"2020/04/16/openlayers-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/openlayers-dev-1/","excerpt":"","text":"Geoserver 에서 필요한 정보를 가져오기 위해 OpenLayers 의 getGetFeatureInfoUrl 함수를 사용하였다. feature 의 정보 중에 GRAY_INDEX 라는 컬럼의 정보를 가져와야 한다. 아래 방식으로 image 형태인 layer 를 구성하였다. 1234567891011var wmsLayer = new ol.layer.Image(&#123; source: new ol.source.ImageWMS(&#123; ratio: 1, url: 'http://localhost:8080/geoserver/img/wms', params: &#123; FORMAT: 'image/png', VERSION: '1.1.1', STYLES: '', &#125;, &#125;),&#125;); getGetFeatureInfoUrl 함수를 사용하여 feature 정보를 불러와 표출하였다. url 에 요청할 때 Cross-Origin Read Blocking(CORN) 문제가 있어 ajax 대신 XMLHttpRequest 를 사용하였다. 123456789101112131415161718192021222324252627var url = wmsLayer.getSource().getGetFeatureInfoUrl([longitude, latitude], view.getResolution(), view.getProjection(), &#123; INFO_FORMAT: 'application/json', FEATURE_COUNT: 10, QUERY_LAYERS: imageLayers, LAYERS: imageLayers,&#125;);if (url) &#123; var parser = new ol.format.GeoJSON(); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === xhr.DONE) &#123; // 요청이 완료되면 if (xhr.status === 200 || xhr.status === 201) &#123; var result = parser.readFeatures(xhr.responseText); if (result.length) &#123; var info = result[0].get('GRAY_INDEX'); $('#measurement_text').text( 'Val: ' + info + ', Lon: ' + longitude.toFixed(3) + ', Lat: ' + latitude.toFixed(3) ); &#125; &#125; &#125; &#125;; xhr.open('GET', url); xhr.send();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"}]},{"title":"[Cesium] 개발 팁","slug":"cesium-tip","date":"2020-04-15T13:04:56.000Z","updated":"2023-07-13T03:22:26.142Z","comments":true,"path":"2020/04/15/cesium-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/15/cesium-tip/","excerpt":"","text":"영상 레이어 추가 Geoserver 에 추가된 영상 레이어를 Cesium 지도에 표출 하는 코드다. layers 에는 Geoserver 에 있는 레이어의 이름을 넣으면 된다. 123456789101112131415var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: '', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', &#125;, &#125;)); CesiumJS 포인트 그리기 마우스 왼쪽 버튼을 누를 때 포인트 그리기 1234567891011121314151617181920var ellipsoid = viewer.scene.globe.ellipsoid;var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);handler.setInputAction(function (event) &#123; if (event.position != null) &#123; var cartesian = scene.camera.pickEllipsoid(event.position, ellipsoid); if (cartesian) &#123; var cartographic = Cesium.Cartographic.fromCartesian(cartesian); var longitude = Cesium.Math.toDegrees(cartographic.longitude); var latitude = Cesium.Math.toDegrees(cartographic.latitude); var point = scene.primitives.add(new Cesium.PointPrimitiveCollection()); point.add(&#123; position: Cesium.Cartesian3.fromDegrees(longitude, latitude), color: Cesium.Color.RED, // default: WHITE &#125;); &#125; &#125;&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 영상 레이어 추가 시 스타일 지정 영상 레이어 추가와 거의 같지만 styles와 COLORSCALERANGE 파라미터가 추가되었다. styles 에는 Geoserver 에 추가된 스타일 이름을 지정하고, COLORSCALERANGE 에는 min, max 값을 지정한다. (COLORSCALERANGE 파라미터는 없어도 된다.) 12345678910111213141516var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: 'lut_redblue', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', COLORSCALERANGE: '0,100', &#125;, &#125;));","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"}]},{"title":"[Eclipse RCP] 개발 팁","slug":"rcp-tip","date":"2020-04-14T04:14:58.000Z","updated":"2023-07-13T03:22:00.355Z","comments":true,"path":"2020/04/14/rcp-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/rcp-tip/","excerpt":"","text":"1) RCP 배포시 필수사항 build.properties 에 javacDefaultEncoding…=UTF-8 추가하기 추가하지 않을 시 한글이 깨지거나 다른 클래스를 참조할 수 없는 문제로 인해 배포된 프로그램이 실행이 되지 않을 수 있다. 2) Spring Bean 사용 방법 RCP에서 Spring 빈 생성 방법 서비스 인터페이스 설정 파일의 Runtime에 관련 라이브러리 Export 한다. String : core, beans, cglib, scheduling Log : slf4f, logback 빈 설정 정보를 담고 있는 클래스 인 AppConfig를 생성하고, AppConfig 클래스에 서비스 빈등록을 하고, SpringBeanFinder 클래스를 생성하여, 애플리케이션 컨텍스트를 로딩하고, getBean 메소드를 이용하여 해당 빈을 룩업 시킨다. RCP에서 DL(Dependency Lookup) 방법 SpringBeanFinder를 Activator를 이용하여 사용한다. getSpringBean(Class beanClass) Service를 사용하는 클래스에서private final XXXService = Activator.getSpringBean(XXXService.class); 형식으로 최상단에 멤버변수 선언을 한다. 서비스 인터페이스 설계 GUI에서 요구되는 서비스를 리스트업 한다. 리스트한 서비스를 인터페이스로 생성한다. DummyXXXService를 먼저 생성하고 GUI에서 테스트 및 구현한다. ConnectionManager를 이용해서 서비스 구현한다. RequestMessage, ResponseMessage 생성 RequestMessage 생성시 Service 정의 3) RCP 카페 https://cafe.naver.com/eclipseplugin 4) RCP Tutorial SWT : http://www.java2s.com/Tutorial/Java/0280__SWT/Catalog0280__SWT.htm SWT JFace Eclipse : http://java2s.com/Code/Java/SWT-JFace-Eclipse/CatalogSWT-JFace-Eclipse.htm Eclipse JFace Table : http://www.vogella.com/articles/EclipseJFaceTable/article.html Eclipse 4 RCP : http://www.vogella.com/articles/EclipseRCP/article.html Eclipse Commands : http://www.vogella.com/articles/EclipseCommands/article.html Eclipse RCP : http://www.vogella.com/articles/Eclipse3RCP/article.html#tips_loadimages","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"}]},{"title":"개발자의 성장","slug":"info-developer","date":"2020-04-14T01:55:09.000Z","updated":"2022-09-02T14:49:52.077Z","comments":true,"path":"2020/04/14/info-developer/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/info-developer/","excerpt":"","text":"회사에서 성장하기 1. 업무를 소비하지 말자 그냥 시키는 것을 그냥 하던대로 그냥 빨리 해치워 버려야한다는 생각으로 그냥 일단 돌아가면 되도록 그냥 개발을 하는 것 그냥 아무생각 없이 누군지는 해주겠지(위험) 이렇게 업무를 개발을 하지 말자 책임감을 가지고 하자 2. 질문을 잘하자 배울 점이 많은 동료가 있는 것은 정말 큰 메리트 하지만 이것을 활용하지 못한다면 아무 의미 없음 회사의 업무는 혼자하는 것이 아님 이 점을 최대한 활용 질문하는 법 충분한 구글링(검색)을 먼저 하자 사전 준비(질문 정리) 현재 발생한 상황 정리 자신의 시도들을 정리 최종적으로 Yes / No로 대답할 수 있도록 정리 그럴 수 없다면 자신의 결론에 대한 의견을 답할 수 있도록 정리 자신의 수준을 아는 사람에게 질문하자(중요) 3. 문서화를 잘하자 트러블 슈팅 나는 어쩌다 이 버그를 마주했는가 그 원인은 무엇이 있는가 그래서 어떤 시도를 해보았나 그래서 최종적으로 어떻게 해결을 했나 개발에 대한 팁 또는 유틸을 정리 4. 변화 무쌍한 스펙 변경에 맞서는 경험 초기에 결정된 스펙은 무조건 변경된다. 나는 이에 어떻게 대응할 것인가 변경될 수 있는 요소들을 어떻게 제어할 것인가","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"}]},{"title":"자바 ORM 표준 JPA 프로그래밍","slug":"book-jpa","date":"2020-04-10T01:58:49.000Z","updated":"2023-07-13T03:21:07.796Z","comments":true,"path":"2020/04/10/book-jpa/","link":"","permalink":"http://hgko1207.github.io/2020/04/10/book-jpa/","excerpt":"","text":"책 정보 책 소개 자바 ORM 표준 JPA는 SQL 작성 없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주고, 객체와 관계형 데이터베이스의 차이도 중간에서 해결해줍니다. 이 책은 JPA 기초 이론과 핵심 원리, 그리고 실무에 필요한 성능 최적화 방법까지 JPA에 대한 모든 것을 다룹니다. 또한, 스프링 프레임워크와 JPA를 함께 사용하는 방법을 설명하고, 스프링 데이터 JPA, QueryDSL 같은 혁신적인 오픈 소스를 활용해서 자바 웹 애플리케이션을 효과적으로 개발하는 방법을 다룹니다. 리뷰 스프링 프레임워크로 웹 개발할 때 JPA를 사용하기 전에는 MyBatis를 많이 사용하였다. JPA를 알고 난 후 책을 바로 구매하여 공부를 시작하게 되었다. 4년 전에 구매한 책이지만 지금까지도 가끔 보고 있고 설명이 잘 되어있어 실무에 바로 반영할 수 있었다. JPA를 사용하면서 더욱 데이터베이스 사용에 대해 편리해졌고, QueryDSL까지 사용하면서 웹 개발이 재미있어졌다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"}]},{"title":"[React] UI 추천","slug":"react-design","date":"2020-04-08T08:36:55.000Z","updated":"2023-07-13T03:20:46.239Z","comments":true,"path":"2020/04/08/react-design/","link":"","permalink":"http://hgko1207.github.io/2020/04/08/react-design/","excerpt":"","text":"React 로 개발 시 기본적인 디자인을 적용하기 위해 고민이 많이 됩니다. 유료 템플릿 프로젝트를 구매해서 사용할 수 있지만 매번 사는게 부담이기 때문에 디자인을 하기 무척 힘들다. 검색하던 중에 편리하게 디자인 할 수 있도록 지원해주는 것들을 몇가지 찾을 수 있었다. 1) Ant Design 리액트와 타입스크립트(Typescript) 기반으로 제작된 UI 라이브러리 중국 회사에서 오픈소스화한 라이브러리 코드가 리액트 기반이기 때문에 사용하기 편리함 앤트 디자인의 10가지 디자인 원칙 Proximity (근접성) Alignment (정렬) Contrast (대조) Repetition (반복) Make it Direct (직관적으로 만들어라) Stay on the Page (화면에 머물러라) Keep it Lightweight (가볍게 유지하라) Provide an Invitation (가이드를 제공해라) Use Transition (트랜지션을 사용하라) React Immediately (즉각적인 반응) 12$ npm i antd$ npm i --save @ant-design/icons 2) Material UI 리액트 기반 UI 라이브러리 중에 가장 인기 있고, 성숙한 라이브러리 구글 머테리얼 디자인 기반으로 제작 1$ npm install @material-ui/core 3) React Bootstrap 웹 UI 라이브러리로 전세계에서 가장 많이 사용되는 Bootstrap을 리액트 기반으로 변경한 라이브러리 Bootstrap 3.x 버전을 기반으로 제작된 라이브러리 Bootstrap 4.x 버전으로 마이그레이션 할 수 있음 1$ npm install react-bootstrap bootstrap 4) reactstrap Bootstrap 4.x 버전을 기반으로 제작된 라이브러리 1$ npm install --save reactstrap react react-dom 5) Semantic UI React 부트스트랩 만큼이나 인기 있는 Semantic UI의 리액트 버전 Semantic UI에 jQuery 의존성을 제거하고 순수하게 리액트로만 개발 된 버전 1$ yarn add semantic-ui-react","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"}]},{"title":"PROJ.4 란?","slug":"satellite-proj4","date":"2020-03-27T00:38:26.000Z","updated":"2023-07-13T03:20:19.305Z","comments":true,"path":"2020/03/27/satellite-proj4/","link":"","permalink":"http://hgko1207.github.io/2020/03/27/satellite-proj4/","excerpt":"","text":"PROJ.4 란? ​다양한 좌표계 변환을 제공하는 라이브러리 자유롭게 인자를 지정하여 표준이 아닌 좌표계 간도 변환 가능 USGS의 Gerald Evenden에 의해 만들어진 오픈소스 라이브러리 현재 OSGeo 프로젝트 중 하나이며 MIT 라이센스 GeoServer, OpenLayers, PostGIS, QGIS, GDAL, OGR, GeoTools 등 엄청나게 많은 프로그램에서 사용 중 C, C++, JAVA, Javascript 등 다양한 언어로 포팅 되어 있음​ 경위도 좌표계(WGS84) GPS가 사용하는 좌표계 EPSG:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs https://epsg.io/4326 구글 좌표계(Mercator) EPSG:3857, EPSG:900913 +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs https://epsg.io/3857 TM(Transverse Mercator) 국토지리정보원 기준 좌표계 +proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs UTM(Universal Transverse Mercator) 전세계를 6도 단위로 나누는 표준적인 TM으로 군사지도에서 많이 사용 UTM52N: 경도 120 ~ 126도 사이에서 사용 EPSG:32652 +proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32652 UTM51N: 경도 126 ~ 132도 사이에서 사용 EPSG:32651 +proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32651 Polar Stereographic 기상청 북반구 표현에 사용 +proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://spatialreference.org/ref/epsg/wgs-84-ups-north/ 참고 epsg.io 한국 주요 좌표계 EPSG코드 및 proj4 인자 정리","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"}]},{"title":"Gdal 사용법","slug":"satellite-gdal","date":"2020-03-26T02:07:02.000Z","updated":"2023-07-13T03:19:49.291Z","comments":true,"path":"2020/03/26/satellite-gdal/","link":"","permalink":"http://hgko1207.github.io/2020/03/26/satellite-gdal/","excerpt":"","text":"GDAL 은 래스터 및 벡터 지리 공간 데이터를 조작 할 수 있는 오픈 소스 라이브러리다. 라이브러리로서 지원되는 모든 형식의 호출 응용 프로그램에 단일 추상 데이터 모델을 제공한다. 데이터 변환 및 처리를 위한 다양한 명령 행 인터페이스 유틸리티가 제공된다. Windows, Linux 및 MacOS 에서 사용 가능하다. 1. gdalinfo (http://www.gdal.org/gdalinfo.html) GDAL 이 지원하는 영상 정보를 확인한다. 1gdalinfo test.tif 2. gdal_translate (http://www.gdal.org/gdal_translate.html) 다른 형식으로 래스터 데이터를 변환 영상 resize 및 포멧 변경 1gdal_translate -of GTiff -outsize 50% 50% src_dataset dst_dataset 3. gdalwarp (http://www.gdal.org/gdal_utilities.html) image reprojection and warping utility 좌표변환, resampling, image mosaicing 1gdalwarp -t_srs EPSG:4326 input.tif output.tif 4. gdal_merge (https://gdal.org/programs/gdal_merge.html) 일련의 이미지를 자동으로 모자이크한다. 모든 이미지는 동일한 좌표계에 밴드 수가 일치해야 한다. 겹치는 영역에서는 마지막 이미지가 이전 이미지에 복사된다. 1gdal_merge.py -init 255 -o out.tif in1.tif in2.tif 5. gdalmanage (http://www.gdal.org/gdalmanage.html) Mode: identify datasetname : List data format of file. 데이터 포맷 정보 보기 copy datasetname newdatasetname : 파일 복사 rename datasetname newdatasetname : 이름 수정 delete datasetname : 이미지 삭제 12345# 파일일 때gdalmanage identify test.tif# 폴더일 때gdalmanage identify –r test/ 6. gdal_contour (http://www.gdal.org/gdal_contour.html) 입력 래스터 표고 모델(DEM)로부터 벡터 등고선 파일을 생성한다. 7. gdal_polygonize.py (http://www.gdal.org/gdal_polygonize.html) Produces a polygon feature layer from a raster. ERS -&gt; Shape 파일로 변환 1python gdal_polygonize.py inputFile -f ”ESRI Shapefile” outputFile 8. ogr2ogr (http://www.gdal.org/ogr2ogr.html) Shape 파일 좌표 변환 1ogr2ogr -f \"ESRI Shapefile\" out.shp wgs84.shp -s_srs EPSG:32616 -t_srs EPSG:4326 Shape -&gt; GeoJSON 변환 1ogr2ogr -f GeoJSON -t_srs crs:84 [name].geojson [name].shp http://www.mercatorgeosystems.com/blog-articles/2008/05/30/using-ogr2ogr-to-re-project-a-shape-file/ 9. gdaldem (https://gdal.org/programs/gdaldem.html) ERS -&gt; GTiff 파일로 변환한다. 1gdaldem color-relief -of GTiff -co \"TILED=YES\" K220100502_22131215_ref_med_union.ers color_file.txt color.tif ※ GDAL 에서 .py 파일은 .exe로 만들어서 붙입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"}]},{"title":"[java] Geocoder을 이용해 주소를 위도/경도로 변환하기","slug":"java-geocoder","date":"2020-03-25T01:18:14.000Z","updated":"2023-07-13T03:18:38.622Z","comments":true,"path":"2020/03/25/java-geocoder/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/java-geocoder/","excerpt":"","text":"Geocoding 이란 주소를 위도, 경도로 변환해주는 Google 에서 제공하는 API 이다. 링크 : 지오코딩이란? 처음엔 HttpURLConnection 으로 접속해서 InputStreamReader 로 읽은 후 JSON 으로 파싱하게 만들었는데 해외 사이트에 geocoder 라이브러리를 이용하여 받아오는 예제가 있다. 어쨌든 더 편리하고 깔끔하게 해결되었다. Geocoder Maven dependency 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.geocoder-java&lt;&#x2F;groupId&gt; &lt;artifactId&gt;geocoder-java&lt;&#x2F;artifactId&gt; &lt;version&gt;0.16&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Method 123456789101112131415161718192021222324252627public static Float[] findGeoPoint(String location) &#123; if (location == null) return null; // setAddress : 변환하려는 주소 (경기도 성남시 분당구 등) // setLanguate : 인코딩 설정 GeocoderRequest geocoderRequest = newGeocoderRequestBuilder().setAddress(location).setLanguage(\"ko\").getGeocoderRequest(); try &#123; Geocoder geocoder = new Geocoder(); GeocodeResponse geocoderResponse = geocoder.geocode(geocoderRequest); if (geocoderResponse.getStatus() == GeocoderStatus.OK &amp; !geocoderResponse.getResults().isEmpty()) &#123; GeocoderResult geocoderResult=geocoderResponse.getResults().iterator().next(); LatLng latitudeLongitude = geocoderResult.getGeometry().getLocation(); Float[] coords = new Float[2]; coords[0] = latitudeLongitude.getLat().floatValue(); coords[1] = latitudeLongitude.getLng().floatValue(); ​return coords; &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return null;&#125; latitudeLongitude.getLat().floatValue(); 이 부분은 floart 형이 아닌 toString() 으로도 가능하다. 테스트 1234String location = \"대전광역시 유성구 궁동\";Float[] coords = CommonUtil.findGeoPoint(location);System.out.println(location + \": \" + coords[0] + \", \" + coords[1]); 결과 1대전광역시 유성구 궁동 : 36.366701, 127.344510","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"}]},{"title":"Spring AOP","slug":"spring-aop","date":"2020-03-25T01:04:18.000Z","updated":"2023-07-13T03:18:58.228Z","comments":true,"path":"2020/03/25/spring-aop/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/spring-aop/","excerpt":"","text":"AOP(Aspect Oriented Programming) 는 공통관심사항을 분리하여 반복되는 부분을 추출해 핵심 로직에 영향을 미치지 않고 소스의 중복을 줄이는 방법으로 기존 OOP(Object-Oriented Programming) 에서 공통관심사항을 여러 모듈에서 적용하며 발생하는 중복된 코드 양산의 한계를 극복하기 위해 나오게 되었다. Spring AOP의 장점 예를 들어 어떠한 홈페이지에 로그인 처리를 해야할 때 AOP 를 사용하지 않는다면 모든 페이지마다 로그인 상태인지 확인하는 소스코드를 넣어야 할테고 혹시나 그 로직이 변경되게 된다면 또 그 모든페이지의 소스를 수정해야하는 일이 생길 것아다. 하지만 AOP 를 적용한다면 단 하나의 로그인 로직만 바꿔도 모든 소스에 적용시킬수 있는 장점이 있다. 스프링 AOP 용어 스프링 AOP 를 이해하기 위해선 5가지 용어에 대한 이해가 필요하다. Aspect : 여러객체에서 공통으로 적용되는 공통 관심사항(ex:트랜잭션, 로깅, 보안) JoinPoint : Aspect가 적용될수있는지점(ex:메소드, 필드) Pointcut : 공통 관심사항이 적용될 Joinpoint Advice : 어느시점(ex: 메소드수행전/후, 예외발생후등)에 어떤 공통관심기능(Aspect)을 적용할지 정의한것 Weaving : 어떤 Advice 를 어떤 Pointcut(핵심사항)에 적용시킬 것 인지에 대한 설정(Advisor)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"}]},{"title":"com, net, co.kr의 차이는?","slug":"info-domain","date":"2020-03-25T01:01:05.000Z","updated":"2023-07-13T03:18:17.744Z","comments":true,"path":"2020/03/25/info-domain/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/info-domain/","excerpt":"","text":"사용 com(company) : 회사의 도메인에 사용한다. net(network) : 네트워크를 관리하는 기관의 도메인에 사용한다. co.kr(company korea) : 회사의 도메인에 사용한다.(한국) 인터넷이 미국에서 시작했기 때문에 도메인도 미국이 먼저 선점했다. 그래서 다른 국가들은 .kr 처럼 국가고유 도메인을 추가하여 쓰게 되었다. 일본은 jp, 영국은 uk, 중국은 cn 등이 다 그런 것이다. 원래의 의미는 co.kr, com : 영리목적으로 설립된 회사의 홈페이지를 나타내는 말 or.kr, org : 비영리기구 ne.kr, net : 네트워크 관련 회사, 혹은 통신 관련 회사를 나타내는 말 하지만 or,org 를 제외하고는 모두 동일한 의미를 나타낸다고 보면 된다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"}]},{"title":"[Git] 커맨드 명령어","slug":"git-use","date":"2020-03-24T01:45:42.000Z","updated":"2023-07-13T03:13:21.726Z","comments":true,"path":"2020/03/24/git-use/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/git-use/","excerpt":"","text":"설정 확인 1$ git config --list 계정 확인 12$ git config user.name$ git config user.email 계정 변경 12$ git config --global user.name \"user name\"$ git config --global user.email \"user email\" Git Create 12345$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin https://github.com/username/repositoryName$ git push -u origin master 현재 master 브랜치를 push 할 때 origin의 master 브랜치로 푸쉬하는 명령어다. 처음 push 할 때 사용한다. 1$ git push --set-upstream origin master Git Update 12$ git add .$ git commit -m \"update\" commit 내용을 확인한다. 1$ git status 원격 저장소에 반영한다. 1$ git push Git Pull 12$ git remote add origin https://github.com/username/repositoryName$ git pull origin master 독립적인 두 프로젝트를 병합할 경우 --allow-unrelated-histories 옵션을 사용한다. 1$ git pull origin master --allow-unrelated-histories Git Repository Download 1$ git clone https://github.com/username/repositoryName 서브 모듈 포함에서 받을 경우 다음 명령어를 참고한다. 1234$ git clone https://github.com/username/repositoryName$ git submodule initor$ git clone --recurse-submodules https://github.com/username/repositoryName Git Ignore .gitignore 파일을 생성한다. 1$ touch .gitignore Git에 이미 올라가 있는 파일을 삭제하고 .gitignore 적용 123456789101112# 원격 저장소와 로컬 저장소에 있는 파일을 삭제한다.git rm [File Name]# 원격 저장소에 있는 파일을 삭제한다.(로컬 저장소에 있는 파일은 삭제하지 않는다.)git rm --cached [File Name]# 폴더 하위의 모든 파일을 삭제한다.git rm -r --cached [Directory]git rm -r --cached example/# 원격 저장소의 파일을 모두 삭제한다.git rm -r --cached . Git branch branch 를 만들고 관리하는 명령어다. 1234567891011# branch 만들기git branch [branch name]# branch 목록 보기git branch# 지정한 branch 삭제git branch -d [branch name]# branch 선택하기git checkout [branch name] Git Remote 원격 저장소를 관리할 수 있는 명령어다. 1234567891011# 원격 저장소의 이름 목록git remote# 원격 저장소에 대한 자세한 목록보기git remote -v# 원격 저장소 추가git remote add [name] [url]# 원격 저장소를 삭제git remote rm [name] Git Clean 작업 디렉토리에서 추적되지 않는 파일을 삭제하는 명령어다. 12345678# untracked 파일 모두 삭제git clean -f# 디렉토리까지 삭제git clean -fd# .gitignore로 무시되는 파일 삭제git clean -d -x Git Stash 1234567891011121314151617# 트래킹 된 파일을 stash 영역에 임시 저장하고 수정 내용은 제거git stash# stash 한 기록을 리스트 형태로 확인git stash list# 가장 최근에 저장한 stash 복원git stash apply# 가장 최근에 저장한 stash 삭제git stash drop# stash 기록 모두 삭제git stash clear# stash를 복원하고 삭제git stash pop 참고 Git 개요","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"}]},{"title":"React Study(2)","slug":"react-study-2","date":"2020-03-24T01:41:09.000Z","updated":"2023-07-13T03:17:42.633Z","comments":true,"path":"2020/03/24/react-study-2/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-2/","excerpt":"","text":"React 세미나😊(2) 2. Project Setup 2.1. Requirements 먼저 Node.js 가 설치되어 있어야 한다. Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/)에서 Window Installer 를 다운로드하고 설치한다. 12$ node -v$ npm -v 에디터로는 MS에서 제공하는 Visual Studio Code(VS Code)를 사용한다. vscode 는 크로스 플랫폼 에디터로 다양한 언어를 서포트 하며, IntelliSense 와 Git 기능, 그리고 Extension 을 이용한 확장 기능을 제공하고 있다. 설치 방법은 https://code.visualstudio.com/ 에 접속하여 다운로드 후 설치하면 된다. React 개발에 좋은 Extension는 ESLint, Prettier, vscode-styled-components, Auto Close Tag, React-Native/React/Redux snippets for es6/es7 등 다양하게 있어 설치하고 사용하면 됩니다. 2.2. Creating React App 기존에는 Webpack, Babel 등 필요한 모듈들을 직접 설치하고 설정하느라 상당한 시간이 소요가 되었다. 2016년에 React 작업 환경을 명령어 하나로 설정 할 수 있는 공식 도구가 나오면서 개발자들과 입문자들에게 많은 도움이 되었다. 먼저 프로젝트 생성을 한다. 주의사항은 npm 5.2.0 이상 버전을 설치해야 합니다. 최신 npm 버전에는 npx 가 설치되어 있다. 123456$ npm install npx -global$ npx create-react-app test-project$ cd test-project$ code . 설치가 완료되면 Visual Studio Code 편집기로 프로젝트를 연다. 처음 프로젝트가 설치되면 여러가지 파일이 생성되는데 초기 세팅을 위해 불필요한 파일을 제거하는 것이 좋다. src 폴더에서 App.js, index.js 파일을 제외한 파일을 제거하고 import 된 코드를 제거한다. 3. React 개발 3.1. JSX JSX (JavaScript eXtension) 는 자바스크립트 언어 문법의 확장입니다. 자바스크립트 안에서 HTML 문법을 사용해서 화면을 구성할 수 있게 도와주는 문법으로, React 개발에 엄청난 도움을 줍니다. 123456789101112import React, &#123; Component &#125; from 'react';class HelloMessage extends React.Component &#123; render() &#123; return ( // JSX 문법 &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; ); &#125;&#125;export default HelloMessage; 아래는 스타일링의 여러가지 방법이다. class 대신 className 을 사용한다. 스타일 속성은 중괄호 ({}) 안에 객체 형태로 표시하며 단어 사이의 '-'를 없애는 대신 카멜케이스(Camel Case)를 사용해 CSS 프로퍼티는 나타낸다. styled-components는 리액트 CSS-in-JS 관련 라이브러리 중에서 가장 잘나가는 라이브러리로써 자바스크립트 파일 안에 CSS 를 작성하는 형태다. 12345678910111213141516171819// App.jsimport React, &#123; Component &#125; from 'react';import styled from 'styled-components';import './App.css';const Content = styled.div` background-color: 'blue'; font-size: 16px;`;function App() &#123; return ( &lt;div&gt; &lt;div className=\"App\"&gt;&lt;/div&gt; &lt;div style=&#123;&#123; backgroundColor: 'black', fontSize: '12px', color: 'white' &#125;&#125;&gt;&lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; );&#125; 123456// App.css.App &#123; background-color: white; font-size: 16px; color: black;&#125; JSX 는 꼭 지켜야 할 몇몇 제한이 있다. JSX 를 사용하는 스크립트 파일은 상단에 React 라이브러리를 꼭 불러와야 한다.1import React from 'react'; 열어 놓은 태그는 꼭 닫아야 한다.1234# 에러&lt;hello&gt;# 정상 동작&lt;hello&gt;&lt;/hello&gt; or &lt;hello /&gt; 최상위 태그는 꼭 1개여야 한다.12345678&lt;Fragment&gt; &lt;header&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;h1&gt;main&lt;/h1&gt; &lt;/main&gt;&lt;/Fragment&gt; 3.2. Component 기반 구조 React 는 Component 기반 라이브러리다. 하나의 코드로 작성하는 것이 아니라 여러 부분을 분할해서 만들기 때문에 코드의 재사용성과 유지보수성이 증가 된다. 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;홈페이지&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;!-- 헤더 내용 --&gt; &lt;/header&gt; &lt;div class=\"content-list\"&gt; &lt;!-- 콘텐츠 리스트 --&gt; &lt;/div&gt; &lt;footer&gt; &lt;!-- 푸터 내용 --&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 위와 같은 html 코드가 있다고 해보자. 이를 React 로 만들게 되면 다음과 같다. 123456789101112131415161718import React, &#123; Component &#125; from 'react';import Header from './component/Header';import Footer from './component/Footer';import ContentList from './component/ContentList';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;ContentList /&gt; &lt;Footer /&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header 나 Footer, ContentList 등은 컴포넌트로 만들고, 이를 조립해서 루트 컴포넌트를 만드는 방식이다. 컴포넌트의 종류로는 클래스형(stateful)과 함수형(stateless)으로 나누어진다. 3.3. Props props란 부모 컴포넌트에서 자식 컴포넌트로 전달해 주는 데이터를 말한다. props는 읽기 전용 데이터라고 생각하면 된다. 자식 컴포넌트에서 전달 받은 props를 변경이 불가능하고 props를 전달해준 최상위 부모 컴포넌트만 props를 변경할 수 있다. 3.4. State state는 동적인 데이터를 다룰 때 사용한다. 사용자와의 상호작용을 통해 데이터를 동적으로 변경을 해야 할 때 사용한다. state는 클래스형 컴포넌트에서만 사용할 수 있는데 각각의 state는 독립적이라 다른 컴포넌트의 직접적인 접근은 불가능하다. 3.5 LifeCycle API LifeCycle API는 컴포넌트가 DOM 위에 생성되기 전 후 및 데이터가 변경되어 상태를 업데이트하기 전 후로 실행되는 메소드들이다. 자원낭비를 줄이기 위하여 코드를 최적화 할 때 사용된다. 많이 사용하는 LifeCycle 메소드들은 constructor, componentDidMount, render, shouldComponentUpdate 이다. 참고 VS Code 기본 세팅 vscode 추천 익스텐션(Extensions)과 세팅 craete-react-app github React 시작하기 [npm] 🤔npx란 무엇인가? JSX 소개 - React 누구든지 하는 리액트 3편: JSX 리액트 Styled Components - 1편 강의 https://academy.nomadcoders.co/ https://www.opentutorials.org/module/4058","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"React Study(1)","slug":"react-study-1","date":"2020-03-24T01:39:16.000Z","updated":"2023-07-13T03:15:03.997Z","comments":true,"path":"2020/03/24/react-study-1/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-1/","excerpt":"","text":"React 세미나😊(1) 최근 React를 다시 공부하게 되면서 올해 초에 회사에서 세미나를 하게 되었다. 물론 기초이지만 React 에 관심을 다시 가지게 되는 계기가 되었다. React란? React는 페이스북에서 제공해주는 프론트엔드 라이브러리다. 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM을 통해 속도와 편의를 높이고, 단방향 데이터 플로우를 지원하여 보일러플레이트 코드를 감소 시켜준다. React 는 싱글 페이지 애플리케이션(SPA)이나 모바일 애플리케이션을 개발할 때 사용할 수 있다. 특징 컴포넌트 기반 아키텍처 템플릿 언어가 아닌 자바스크립트로 컴포넌트 작성 특정 관심사에 집중된 기능 블록 (관심사의 분리) One Way Data flow(단방향 데이터 흐름 지향) React 는 데이터의 흐름이 한 방향으로만 흐흔다. 데이터가 내려가기만 하고 밑에서 데이터를 올릴 수 없다. 그래서 부모의 데이터를 바꿔주기 위해서는 state를 이용해야 한다. Virtual DOM - React는 가상의 DOM을 만들어서 진짜 DOM 과 비교하여 변경 사항이 있을 경우 전체를 새롭게 만드는 것이 아니라 변경된 부분만 진짜 DOM 에 반영하는 방식으로 작업을 수행한다. 그럼으로써 애플리케이션의 효율성과 속도를 높일 수 있게 된다. JSX 문법 리액트 JS를 하기 위해 알아야 할 것 Javascript(ES6) HTML CSS 1. Fundamentals(기초) React에서 많이 사용되는 자바스크립트 ES6 문법 기초를 먼저 알아보자. 기존에 우리가 웹 개발에서 많이 보던 자바스크립트는 2009년 12월에 나온 ECMAScript5(ES5) 버전이다. 최근 Node.js, react에서는 2015년 6월에 업데이트 된 ECMAScript6(ES6) 문법의 자바스크립트를 사용하고 있다. ES6 문법을 사용하면서 처음에는 익숙해지기 어려웠지만 사용할 수록 코드가 간결해지고 깔끔해지면서 가독성이 좋아졌고, 모듈 별로 개발하면서 코드 관리가 쉬워졌다. 현재는 ES8까지 업데이트 되었지만 몇 가지 걸림돌이 있어 넘어가지 않고 있다. 아래에는 바뀐 ES6 문법과 많이 사용되는 기능들이다. 1.1. var -&gt; let &amp; const const 는 블록 범위이며 값이 지정되면 나중에 바꿀 수 없다. 또한, 재 선언 될 수도 없다. let 은 블록 범위이며 값이 지정되어도 값을 바꿀 수 있다. 12const name = 'eden';let tel = '010-0000-0000'; 1.2. Arrow Functions 함수는 간결해지고 코드는 짧아졌다. Argument가 하나 일 때는 괄호가 필요 없다.(유일한 규칙) 1234567// ES5function sayHello(name) &#123; reutn \"Hello \" + name;&#125;// ES6const sayHello = name =&gt; \"Hello \" + name;const sayHello = (name, something) =&gt; \"Hello \" + name + something; 1.3. Template Literals ``(backticks) 사용 12345const name = 'eden';// ES5console.log('Hello ' + name);// ES6console.log(`Hello $&#123;name&#125;`); 1.4. Object Destructuring (비구조화) 적은 코드를 사용해서 더 깔끔하게 보이도록 한다. 1234567891011121314151617181920212223const human = &#123; name: 'Ko', lastName: 'HyeongGyun', nationality: 'Korea', favFood: &#123; dinner: 'Samgyupsal', &#125;,&#125;;// ES5const name = human.name;const lastName = human.lastName;const difName = human.nationality;const dinner = human.favFood.dinner;// ES6const &#123; name, lastName, nationality: difName, favFood: &#123; dinner &#125;,&#125; = human;console.log(name, lastName, difName, dinner); 1.5. Spread Operator Iterable Object(열거 가능한 오브젝트)를 하나씩 전개한다. 표현방식 […iterable], 변수 앞에 ‘…’ 찍어서 선언한다. 변수 뿐만 아니라 Argument, Function에서도 쓰인다. 123456const days = ['Mon', 'Tues', 'Wed'];const otherDays = ['Thu', 'Fri', 'Sat'];const allDays = [...days, ...otherDays, 'Sun'];console.log(allDays);결과: ['Mon', 'Tues', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; 1.6. Classes constructor 메소드도 사용할 수 있고 extends를 통해서 클래스 상속도 가능하다. 123456789101112131415161718class Human &#123; constructor(name, lastName) &#123; this.name = name; this.lastName = lastName; &#125;&#125;class Baby extends Human &#123; cry() &#123; console.log('cry'); &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;&#125;const myBaby = new Baby('mini', 'me');console.log(myBaby.cry(), myBaby.sayName()); 1.7. Array.map 요소를 일괄적으로 변경한다. 12345const days = ['Mon', 'Tues', 'Wed', 'Thu', 'Fri'];const smilingDays = days.map((day) =&gt; `😂 $&#123;day&#125;`);console.log(smilingDays);결과: ['😂 Mon', '😂 Tues', '😂 Wed', '😂 Thu', '😂 Fri']; 1.8. Array.filter 요소를 걸러내어 배열로 true/false 반환, 없으면 빈 배열을 반환한다. 123const numbers = [123, 5, 15, 67, 241, 54, 1, 6, 23, 90];const otherNumbers = numbers.filter((number) =&gt; number &gt; 15);console.log(otherNumbers); 1.9. forEach, includes, push 123456let posts = ['Hi', 'Hello', 'Bye'];if (!posts.includes('new')) &#123; posts.push('new');&#125;posts.forEach((post) =&gt; console.log(post)); CodeSandbox 웹 기반 자바스크립트 에디터 서비스를 제공하는 사이트 간단한 소스 코드 테스트를 할 때 사용하면 편리하다. codesandbox.io 참고 https://velog.io/@stampid/React란 https://velog.io/@kyusung/react-summary https://hgko1207.github.io/2019/01/09/react-start/ https://sanghaklee.tistory.com/54 http://woowabros.github.io/experience/2017/12/01/es6-experience.html https://blog.asamaru.net/2017/08/14/top-10-es6-features/ https://velog.io/@decody/map-정리","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"Node.js 교과서","slug":"book-nodejs","date":"2019-06-19T07:31:30.000Z","updated":"2023-07-13T03:12:07.169Z","comments":true,"path":"2019/06/19/book-nodejs/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/book-nodejs/","excerpt":"","text":"책 정보 책 소개 노드의 기본부터 실무까지, 전 과정을 한 권에 담았다! 다양한 서비스를 직접 만드는, 실무에 가장 가까운 강의! Node.js 10 + 자바스크립트 ES2018, 최신 문법으로 배우자. 서버와 데이터베이스 개념을 시작으로 노드의 기본 개념을 차근차근 설명해나간다. 군더더기 없는 직관적인 설명, 풍부한 그림으로 기본 개념을 확실히 이해하고, 노드의 기능과 생태계를 사용해보며 실제로 동작하는 서버를 만들어보자. 웹 서버, 웹 API 서버, SNS 서비스, 실시간 GIF 채팅방, 경매 시스템, 위치 기반 장소 검색 서비스, 커맨드라인 인터페이스를 모두 만들어 볼 수 있다. 실무에 당장 적용할 수 있고, 참고할 수 있는 예제와 코드를 최신 문법으로 다뤄보자. 리뷰 최근 Node.js 에 관심이 생겨 공부를 해볼까 하다가 지인의 추천으로 이 책을 사게 되었다. 노드의 기본부터 실무까지 꼼꼼하게 설명되어 있고 무엇보다 예제 소스가 잘 되어 있어 힘들게 코드를 안봐도 되고 이해도 빨라 금방 익숙해졌다. 아직은 걸음마 단계이지만 차근차근 공부하고 프로젝트도 진행해 볼 예정이다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[WPF] Prism Library 사용","slug":"wpf-prism","date":"2019-06-19T07:26:34.000Z","updated":"2023-07-13T03:12:41.783Z","comments":true,"path":"2019/06/19/wpf-prism/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/wpf-prism/","excerpt":"","text":"최근 WPF 기반으로 응용 어플리케이션을 개발하고 있다. C#을 처음하는 거라 처음에는 익숙하지 않았지만 자바와 비슷한 면이 많아 금방 적응하였다. WPF 개발을 하는데 Prism Library를 적용하였다. Prism 은 WPF 를 통해 풍부하고 유연하고 유지보수가 쉬운 설계를 할수 있게 도와준다고 한다. 그리고 MVVM 패턴, Dependency Inejction, CompositeView, Event Aggregator 들을 이용하여 독립적인 컴포넌트들 간의 느슨한 결합들을 이용한 설계 중심의 어플리케이션 제작에도 도움을 준다고 한다. 즉, WPF 어플리케이션을 만들 시 MVVM 디자인 패턴으로 개발하고 이에 추가적으로 Prism이 제공하는 CompositeView 제작방식과 Event Aggregator 기능들을 사용할 수 있는 것이다. Prism 설계 목표(Prism Design Goals) 재사용성(Reuse) 확장성(Extensibility) 유연성(Flexibility) 협업(Team Development) 품질(Quality) Prism Key Concepts Prism 의 설계 목표와 핵심 개념들이다. Modules Module catalog Shell Views View models Models Commands Regions Navigation EventAggregator Dependency injection container Services Controllers Bootstrapper Prism 아키텍쳐","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"Hexo 시작 및 기본 사용법","slug":"hexo-basic-usage","date":"2019-02-13T01:38:15.000Z","updated":"2023-07-13T03:11:52.865Z","comments":true,"path":"2019/02/13/hexo-basic-usage/","link":"","permalink":"http://hgko1207.github.io/2019/02/13/hexo-basic-usage/","excerpt":"","text":"Hexo Hexo 라는 블로그 프레임워크를 사용하여 블로그를 작성하던 중에 시간이 지나면 생성하는 법이나 작성하는 법 등 사용법들을 자꾸 잊어버리게 되어 기존에 자주 보곤 했던 Hexo 사용법이 잘 정리되어있던 블로그 링크를 모아놨다. 참고 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 기본 사용법 Hexo 시작하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[JavaScript] 우편번호 주소 조회","slug":"javascript-postcode","date":"2019-01-18T06:52:14.000Z","updated":"2023-07-13T03:11:37.120Z","comments":true,"path":"2019/01/18/javascript-postcode/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-postcode/","excerpt":"","text":"웹 프로젝트를 하면서 사용자 등록을 하게 될 때 주소를 입력을 하게 되는데, 우편번호 주소 조회가 되도록 처리해달라는 요청이 있었다. 그래서 우편번호 서비스를 검색해 봤을 때 여러가지가 있었지만 개인적으로 좋아보이는 Daum 우편번호 서비스를 사용하게 되었다. Daum 우편번호 서비스 쉽고 간편하게 우편번호 검색, 도로명 주소 입력 기능을 만들 수 있다. Key 를 발급받을 필요가 없다. 사용량에 대한 제한이 전혀 없다. 기업용이든 상업적 용도이든 상관없이 무조건 무료로 사용 가능하다. 도로명 주소, 지번 주소, 영문 주소까지 모두 확인 가능하다. 이 것 말고도 여러 가지 장점이 더 있지만 사용하기 쉽고 무료이며 사용량에 대한 제한이 없고, 특히나 기본 사용법이 정말 쉽게 잘 설명되어 있어서 사용하게 되었다. 다음은 적용한 코드다. 1) HTML 부끄럽지만 HTML 코드는 다음과 같다. 우편번호, 도로명 주소, 상세 주소 입력 란이 있고 우편번호 찾기 버튼이 있다. 버튼을 클릭하게 되면 execDaumPostcode() 함수를 호출하게 된다. 123456789101112131415161718192021222324252627282930&lt;div class=\"form-group m-form__group row\"&gt; &lt;label class=\"col-md-2 offset-md-3 col-form-label\"&gt; 주&amp;nbsp;&amp;nbsp;소&amp;nbsp;&amp;nbsp;&lt;span class=\"m--font-orange vertical-middle\"&gt;*&lt;/span&gt; &lt;/label&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"text\" class=\"form-control m-input\" name=\"postcode\" id=\"postcode\" placeholder=\"우편번호\" readonly /&gt; &lt;/div&gt; &lt;div class=\"col-md-2 postcode-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-info m-btn--air\" onclick=\"execDaumPostcode()\"&gt;우편번호 찾기&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-md-4 offset-md-5\"&gt; &lt;input type=\"text\" class=\"form-control m-input m--margin-top-10\" name=\"address\" id=\"address\" placeholder=\"도로명 주소\" readonly /&gt; &lt;/div&gt; &lt;div class=\"col-md-4 offset-md-5\"&gt; &lt;input type=\"text\" class=\"form-control m-input m--margin-top-10\" name=\"detailAddress\" placeholder=\"상세 주소\" required /&gt; &lt;/div&gt;&lt;/div&gt; 결과 화면이다. 2) JavaScript 버튼을 클릭하여 execDaumPostcode() 함수가 호출되면서 주소 검색 팝업창이 보여지게 한다. 팝업팡에서 주소 검색 결과 항목을 클릭했을 때 우편번호와 도로명주소 입력란에 값을 채워넣게 된다. 1234567891011121314151617&lt;!--autoload=false 파라미터를 이용하여 자동으로 로딩되는 것을 막습니다.--&gt;&lt;script src=\"http://dmaps.daum.net/map_js_init/postcode.v2.js?autoload=false\"&gt;&lt;/script&gt;&lt;script&gt;/** 우편번호 찾기 */function execDaumPostcode() &#123; daum.postcode.load(function()&#123; new daum.Postcode(&#123; oncomplete: function(data) &#123; // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다. $(\"#postcode\").val(data.zonecode); $(\"#address\").val(data.roadAddress); &#125; &#125;).open(); &#125;);&#125;&lt;/script&gt; Daum 우편번호 서비스를 사용하여 주소를 검색하고 우편번호와 도로명 주소를 받아 입력란에 넣어줬다. Daum 우편번호 서비스 사이트 가시면 예제와 속성, 함수에 대한 부분도 잘 설명 되어 있기 때문에 다양하게 개발할 수 있다. 참고 Daum 우편번호 서비스 Daum 우편번호 서비스 사용 가이드 - 우편번호 검색, 적용법 및 사용예제","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Postcode","slug":"Postcode","permalink":"http://hgko1207.github.io/tags/Postcode/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"Daum","slug":"Daum","permalink":"http://hgko1207.github.io/tags/Daum/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"[JavaScript] 전화번호 하이픈(-) 자동입력","slug":"javascript-autoHypenTel","date":"2019-01-18T06:22:36.000Z","updated":"2023-07-13T03:10:18.660Z","comments":true,"path":"2019/01/18/javascript-autoHypenTel/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-autoHypenTel/","excerpt":"","text":"사용자 등록 시 전화번호를 입력하게 되는데 아래 그림처럼 세 개의 입력을 받아 합치는 형식으로 많이 개발한다. 이렇게 개발해도 괜찮지만 좀 더 쉽게 하기 위해서 전화번호 입력 시 자동으로 하이픈(-)이 입력되도록 하는 형식으로 바꾸면 좋겠다 싶어 구현해봤다. 개발 된 화면은 다음과 같다. 1) HTML 먼저 HTML 소스 코드다. input 태그를 사용하고 pattern과 maxlength, required, placeholder를 사용하였다. 속성에 대한 설명은 참고 사이트를 보시면 된다. 12345678910&lt;input type=\"tel\" class=\"form-control m-input\" name=\"tel\" id=\"telInput\" required pattern=\"[0-9]&#123;2,3&#125;-[0-9]&#123;3,4&#125;-[0-9]&#123;4&#125;\" maxlength=\"13\" placeholder=\"예) 010-1234-5678\"/&gt; 2) JavaScript 먼저 전화번호 크기에 따라 나눴다. 서울 전화번호는 02 로 두자리로 시작하고 핸드폰은 010, 011… 이고 다른 지역 전화번호는 031, 041, 051 등 세자리로 시작하여 {2}-{3 or 4}-{4} 또는 {3}-{3 or 4}-{4} 형태가 되도록 문자열을 잘라내는 방식으로 하였다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function autoHypenTel(str) &#123; str = str.replace(/[^0-9]/g, ''); var tmp = ''; if (str.substring(0, 2) == 02) &#123; // 서울 전화번호일 경우 10자리까지만 나타나고 그 이상의 자리수는 자동삭제 if (str.length &lt; 3) &#123; return str; &#125; else if (str.length &lt; 6) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2); return tmp; &#125; else if (str.length &lt; 10) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 3); tmp += '-'; tmp += str.substr(5); return tmp; &#125; else &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 4); tmp += '-'; tmp += str.substr(6, 4); return tmp; &#125; &#125; else &#123; // 핸드폰 및 다른 지역 전화번호 일 경우 if (str.length &lt; 4) &#123; return str; &#125; else if (str.length &lt; 7) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3); return tmp; &#125; else if (str.length &lt; 11) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 3); tmp += '-'; tmp += str.substr(6); return tmp; &#125; else &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 4); tmp += '-'; tmp += str.substr(7); return tmp; &#125; &#125; return str;&#125; 호출 부분 코드다. 키가 입력될 때마다 검사를 진행한다. 12345$('#telInput').keyup(function (event) &#123; event = event || window.event; var _val = this.value.trim(); this.value = autoHypenTel(_val);&#125;); 전화번호 시작이 1588, 1668 등과 같은 번호 일 경우에 대해서는 작성하지 않았다. 보다시피 완벽하게 최적화가 되지 않았기 때문에 추후에 수정이 될 것 같다. 참고 HTML Input 속성들(Attributes) 핸드폰 번호 하이픈(-) 자동입력 전화번호 입력시 하이픈(-) 자동 입력","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"}]},{"title":"[Git] 이클립스에서 Git 사용법","slug":"eclipse-git","date":"2019-01-18T02:17:07.000Z","updated":"2023-07-12T06:34:35.000Z","comments":true,"path":"2019/01/18/eclipse-git/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/eclipse-git/","excerpt":"","text":"기존에는 사내에서 개발할 때 SVN으로 형상관리를 하였는데, 이번에 개인 공부도 하고 프로젝트로 만들다 보니 GitHub를 사용하게 되었다. GitHub는 원격 저장소를 제공하며 여러가지 프로젝트 진행을 원활하게 하는 도구를 함께 제공하는 이점이 있어서 사용하였다. 스프링 프레임워크 기반 웹 프로젝트를 이클립스로 개발하고 있어 이클립스와 GitHub 를 연동하였다. 이제 연동 방법을 설명한다. 1. 원격 저장소 생성 먼저 공식 사이트인 https://github.com/ 에서 회원가입을 한다. 회원가입 후 로그인을 하고 “Start a project” 버튼을 클릭한다. 다음 그림처럼 화면이 나온다. 원격 저장소 이름을 입력하고 다른 것은 수정하지 말고 “Create repository” 버튼을 클릭하면 다음과 같은 원격저장소가 생성된다. 빨간 네모 박스의 경로를 복사해둔다. 2. EGit 설치 이클립스를 실행하고 Help -&gt; Eclipse Marketplace 를 클릭한다. Marketplace 에서 Egit 를 검색한다. 다음 그림 처럼 EGit - Git Integration for Eclipse 를 찾아 설치한다. 설치가 완료되면 이클립스를 다시 실행하게 된다. 재실행 후에 이클립스의 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보인다. Git 을 선택하고 [OK] 버튼을 눌러 활성화 시킨다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경된다. 3. 원격 저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭한다. Clone Git Repository 창이 보이면 Clone URL 를 선택하고 [Next] 버튼을 클릭하면 다음의 그림처럼 화면이 보인다.(이클립스 버전마다 조금씩 다른 것 같다.) 첫 번째 빨간 박스에서 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력된다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭한다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭한다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭한다. 4. 프로젝트 연동 개발하고 있는 프로젝트와 연동하기 위해 작업을 한다. 프로젝트를 마우스 우클릭 후 그림 처럼 [Team] -&gt; [Share Project] 를 클릭한다. Git 을 선택하고 [Next] 버튼을 클릭한다. 그런 다음 Repository 란에서 앞에서 생성한 저장소를 설정해주고 [Finish] 버튼을 클릭한다. 4. 첫 번째 커밋 원격 저장소에 첫 번째로 커밋한다. 프로젝트를 마우스 우클릭 후 [Team] -&gt; [Commit] 을 클릭한다. 다음과 같은 화면이 뜨면 Commit Message 항목에 메시지를 작성 한 후 프로젝트 파일 전체를 Staged Changes 로 옮긴다. 그런 후에 마지막으로 [Commit and Push] 버튼을 클릭한다. Branch에 push 하기 과정인데 이 부분은 패스하겠습니다. [Next] 버튼을 클릭한다. 그럼 로그인 창이 뜰텐데, GitHub의 아이디와 비밀번호를 입력하시고 [OK] 버튼을 클릭한다. Push 확인 화면이 보여지는데 확인하고 [Finish] 버튼을 클릭한다. 다시 로그인 창이 뜹니다. 처음에만 2번 로그인하고 그 다음에는 한번만 로그인 하면 됩니다. 아이디 비밀번호를 입력하고 [OK] 버튼을 클릭한다. 완료가 되면 아래 그림 처럼 Push 결과 화면이 보여진다. 5. GitHub에서 프로젝트 확인 GitHub 홈페이지를 가서 Push 된 프로젝트를 확인 할 수 있다. 그림 처럼 프로젝트가 올라가있고 수정된 이력도 보여진다. 이클립스에서 소스 코드를 수정하고 위에서 본 Commit 과정과 같이 하면 프로젝트를 관리할 수 있다. 이클립스와 GitHub의 원격 저장소와 연동하여 설정을 하였다. 아직은 깃을 많이 사용해보지 못하였고 조금씩 알아가며 사용하고 있고 Branch에 대해서도 알아가고 있다. 늦은 감이 있긴 한데 이제라도 얼른 써서 익숙해지려고 노력해야겠다. 참고 [Git] 이클립스에서 Git 사용하기 [Git] 이클릭스에서의 Git 사용법(egit) 1 [Git] 이클립스와 깃(GitHub) 연동하여 원격 저장소의 프로젝트 내려받기 [git] 이클립스(eclipse) 연동하여 처음 사용하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"}]},{"title":"[React Native] Expo 사용 방법","slug":"react-native-expo-start","date":"2019-01-11T07:35:26.000Z","updated":"2023-07-12T06:28:43.877Z","comments":true,"path":"2019/01/11/react-native-expo-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-expo-start/","excerpt":"","text":"Expo 리액트 네이티브는 리액트 아키텍처를 모바일에 적용한 것으로, ES6 문법과 리액트를 이용해 모바일 어플리케이션을 개발할 수 있도록 해주는 프레임워크다. 리액트 네이티브 프로젝트 생성 시 react-native init &lt;프로젝트 이름&gt;을 입력하여 사용하였다. 이것만으로도 충분하다고 느껴졌는데 다른 강좌를 보던 중에 Expo 툴을 발견하게 되었다. Expo 는 리액트 네이티브 어플리케이션의 빌드를 돕는 툴이다. 네이티브 API에 접근하는 것도 쉽게 만들어주고, 안드로이드와 iOS 버전을 알아서 빌드해준다. 무엇보다 코드를 수정하면 바로 hot reloading 시켜주는 것이 가장 편하다. 작년 12월 쯤에 리액트 네이티브를 알게 되고 최근에 Expo도 접하게 되면서 찾던 중 처음에는 Expo Xde를 다운받아 사용하라고 하여서 Expo 홈페이지를 찾아봤지만 다운받지 못하였다. 그러던 중 xde 지원이 중단되고 대신 Expo dev tool(=expo cli 최신버전)을 설치해서 사용하라고 하는 내용을 보게 되었다. Expo cli 설치 및 실행 1. node.js 설치 이전 글인 리액트 시작하기 를 참고한다. &gt; [Programming/React/리액트 시작하기] - Node.js 설치: Windows 2. expo-cli 설치 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행한다. 1$ npm install -g expo-cli 3. 프로젝트 생성 프로젝트 생성할 때는 expo init &lt;프로젝트 이름&gt; 명령어를 사용한다. init 입력 후 프로젝트 개발 목적에 맞게 선택한다. 그런 다음 Use Yarn to install dependencies? 하는 질문에 Y 를 입력하고 엔터를 입력한다. 그러면 설치가 시작되고 완료 후 프로젝트가 정상적으로 생성이 되었는지 확인한다. 1$ expo init react-native-project 4. 프로젝트 실행 프로젝트를 실행하면 새 탭이 생성되면서 다음 그림처럼 보여진다. 12$ cd react-native-project$ expo start 5. 모바일 디바이스 연결 실제 모바일 디바이스 먼저 Expo 홈페이지에서 계정을 생성한다. 그런 다음 모바일에서 “Expo client” 앱을 설치한다. 그리고 프로젝트 실행 화면에서 Publish or republish project… 을 클릭하고 내용을 입력 후 Publish Project 버튼을 클릭한다. 클릭하는 순간 터미널(또는 명령프롬프트)에 계정 정보를 입력하라는 문구가 뜬다. 그럼 생성한 계정정보를 입력 후 엔터키를 누르고 프로젝트 실행 화면으로 넘어와서 성공했는지 확인한다. &quot;Expo client&quot; 앱을 실행하고 생성한 계정정보를 입력한다. 로그인 성공 후 하단에 있는 Projects 탭을 클릭한다. 그러면 Publish 성공한 프로젝트가 보인다. 프로젝트를 클릭하면 우리가 작업한 화면이 보일 것이다. 코드를 수정하면 바로 앱에서 변경되는 것을 확인할 수 있다. 이슈사항은 모바일 디바이스와 연결 시 같은 망의 네트워크여야 하는 것 같다. QR Code로 하는 방법도 있는 것 같은데 아직 시도를 못 해봤다. 에뮬레이터 iOS는 Xcode를 설치하고 Android는 Android Studio를 설치하고 AVD manager에서 디바이스를 생성 후 실행시켜준다. 그런 다음 프로젝트 실행 화면에서 “Run on Android device/emulator” 또는 “Run on iOS simulator” 를 클릭한다. 자동으로 에뮬레이터에 앱이 설치가 되고 실행이 된다. 그리고서 실행된 화면을 확인하고 코드를 변경한다. 라이브 리로드 설정이 되어있으면 바로 리로드가 되는 것을 확인할 수 있다. 에뮬레이터 연결은 Expo 뿐만 아니라 앱 개발할 때 자주 사용하기 때문에 따로 설명은 없고 아래 링크에서 가이드를 보면 나와있다. &gt; 모바일 클라이언트 : iOS 및 Android 에뮬레이터 참고 Expo Quick Start Expo Xde 지원 중단에 따른 Expo dev tool(Expo cli) 설치 및 실행 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"}]},{"title":"[React Native] 시작하기","slug":"react-native-start","date":"2019-01-11T04:20:56.000Z","updated":"2023-07-12T06:30:28.770Z","comments":true,"path":"2019/01/11/react-native-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-start/","excerpt":"","text":"React Native 란 리액트는 페이스북이 웹 개발을 쉽게 하기 위해 만든 기술이다. 리액트 네이티브는 리액트의 접근 방법을 모바일로 확장하는 페이스북의 오픈소스 프로젝트다. 기존의 하이브리드 앱은 WebView에 화면을 만들어 놓고 모바일 앱에서 접근하는 것이었기 때문에 퍼포먼스가 떨어지고, 모바일 앱과의 괴리감이 있었다. 리액트 네이티브는 실제 네이티브 UI를 사용하여 모바일 앱을 구현한다. 퍼포먼스는 올라가고 괴리감도 사라지게 된다. 리액트 네이티브를 사용하면 JavaScript를 사용하여 모바일 앱을 제작할 수 있다. 리액트와 동일한 디자인을 사용하여 선언적 구성 요소에서 풍부한 모바일 UI를 구성 할 수 있다. 출처: 배고픈사자의 React Native [리액트 네이티브] 장점 높은 생산성 리액트를 사용하여 개발해 보신분이라면 처음부터 빠르게 개발을 시작할 수 있다. 아니라면 처음에 당연히 러닝커브(Learning Curve)는 필요하다. 그렇지만 Swift, Java 또는 Kotlin, Objective-C 를 배우는 것보다 자바스크립트 언어 하나로 작성하기 때문에 생산성이 당연히 좋다고 생각한다. 그리고 iOS 와 Android를 동시에 개발할 수 있다는 점이 매우 큰 장점이다. 라이브 리로딩 리액트 네이티브를 사용하면 앱을 더 빠르게 빌드할 수 있다. 기존 앱을 개발할 때는 변경되면 다시 빌드를 해야 했지만 리액트 네이티브로 개발할 때 다시 컴파일 하는 대신 즉시 앱을 다시 로드 할 수 있다. 코드를 수정해서 저장만 하면 변경된 내용을 바로 확인 할 수 있어 실제 개발시간을 확신히 단축시킬 수 있다. 필요한 경우 원시 코드 사용 리액트 네이티브는 Swift, Java 또는 Objective-C 로 작성된 구성 요소와 원활하게 결합한다. 애플리케이션의 몇 가지 측면을 최적화해야하는 경우 네이티브 코드로 간단하게 작성 할 수 있다. 단점 개발자료 부족 시작된지 얼마 되지 않는 프로젝트라서 검색을 하였을 때 확실히 자료가 적은 것 같다. 더군다나 영어 자료는 있는데 한글로 된 자료는 더욱 없다고 느껴진다. 힘든 유지보수 플랫폼 기기에 대한 문제가 생기면 원인을 찾기가 힘든 것 같다. 그리고 국내에 리액트 네이티브 개발자가 많이 없다고 들었다. 만약에 리액트 네이티브로 개발을 완료하고 퇴사를 하게 되면 후임자나 유지보수를 해야하는 개발자를 구해야 하는데 특히 소규모 회사들은 더욱 어렵다고 느껴진다. 비고 위의 단점이 있더라도 장점이 크다고 느껴지고 흥미가 있어 리액트 네이티브에 대해 공부하고 앞으로 있는 새로운 프로젝트에서 사용해 볼 예정이다. 리액트 네이티브 설치와 실행 및 환경설정은 워낙 정리가 잘 되어있는 블로그가 많아서 따로 정리를 하지 않았다. 아래 참고에 되어 있는 링크를 따라가면 window, macOS 환경에서의 설치와 ios, android 플랫폼에서 실행할 수 있도록 잘 설명되어 있다. 그리고 리액트 네이티브에 대한 내용과 장단점에 대해서도 참고 링크를 보면 자세하게 볼 수 있다. 참고 React Native 설치와 실행(hello world) [RN] React-Native 시작하기 React Native React Native Getting Started [RN] React-Native의 장단점은?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"}]},{"title":"WPF MVVM 일주일 만에 배우기","slug":"book-wpf","date":"2019-01-11T02:00:22.000Z","updated":"2023-07-12T06:26:18.327Z","comments":true,"path":"2019/01/11/book-wpf/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/book-wpf/","excerpt":"","text":"책 정보 책 소개 필자의 십 수년간의 강의 경험을 최적화하여 집필한 가장 얇은 WPF 개발 서적으로 군더더기 없이 WPF를 빨리 배울 수 있다. 간단한 연습 과제와 따라 하기 방식의 해당 풀이를 통해 컨트롤 및 레이아웃, 데이터 바인딩 등의 WPF 기본 사항들을 익히고 최종적으로는 MVVM 패턴을 사용한 WPF 응용 프로그램 예제를 만들어 본다. 한국어판에서는 좀 더 쉽게 이해할 수 있도록 스크린샷과 설명을 추가했다. 짧은 시간 내에 WPF 및 MVVM 패턴에 대한 내용을 익히고 실제 프로젝트에 적용하고자 한다면 WPF 개발 서적이 몇 없는 국내 현실에서 단비와 같은 이 책 한 권으로 의도한 바를 이룰 수 있을 것이다. 리뷰 WPF 기반 프로젝트를 하기 전에 WPF 에 대한 기본 개념을 잡기 위해 구매한 책이다. 기본 개념을 잡기 위해 구매한 책이라 그런지 입문하는 입장에서는 좋은 책 인 것 같지만 정말 기본만 배우게 되어 조금 아쉬웠다. 그래도 애플리케이션 생성과 데이터 바인딩, MVVM 패턴 등 중요한 용어에 대해 알려줘서 나중에 개발 시 구글 검색을 할 때 좋을 것 같았다. 코드 양은 얼마 없고 페이지 수도 짧아 일주일이 되지 않아 다 읽게 되었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"}]},{"title":"이것이 C#이다","slug":"book-c","date":"2019-01-09T09:13:33.000Z","updated":"2023-07-12T06:22:38.847Z","comments":true,"path":"2019/01/09/book-c/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/book-c/","excerpt":"","text":"책 정보 책 소개 한 번 배울 때 제대로, 기본기부터 탄탄히 다지고 간다! 이 책은 C# .NET 프레임워크 세계에 첫 발을 들이는 입문자를 위한 책이다. 따라서 딱딱하지 않은 대화식 표현으로 1:1 강의처럼 배울 수 있는 것이 이 책의 가장 큰 장점이다. 또한 C#의 핵심 문법은 물론, 프로그래밍 동작 원리까지도 입문자 입장에서 하나하나 꼼꼼히 설명하였다. 책을 덮을 때쯤이면 기초 문법부터, 고급 문법, 그리고 .NET 프레임워크의 활용까지 C#의 전반적인 큰 틀을 자연스레 익힐 수 있을 것이다.『이것이 C#이다』로 C# 프로그래밍을 시작한다면, 튼튼한 기본기가 갖춰져, 더 이상 실전과 응용도 두렵지 않습니다. 리뷰 개발 서적을 구매하고 공부하는 것을 좋아해서 찾아보다가 예전부터 알개발해 보고 싶었던 C# 책을 찾게 되었다. 마침 회사에서도 C#, WPF 기반 프로젝트를 수행하게 되어 급하게 알아보다가 이 책을 구매해서 역시나 코드를 보며 이해하였다. Java 개발을 몇년 간 한 경험으로 C# 코드를 봤을 때 정말 비슷한 점이 많고 오히려 더 쉽게 느껴졌다. 역시나 개발을 하면서 더 익숙해지겠지만 LINQ 나 람다식으로 인해 코드가 직관적이고 간결하게 표현되는 것을 보며 책을 구매하기 잘 했다고 생각하였다. 여러모로 만족이었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[React] 설치 및 설정 방법","slug":"react-start","date":"2019-01-09T05:10:34.000Z","updated":"2023-07-12T06:26:03.548Z","comments":true,"path":"2019/01/09/react-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/react-start/","excerpt":"","text":"리액트란 React 는 사용자 인터페이스를 만들기위해 페이스북과 인스타그램에서 개발한 오픈소스 자바스크립트 라이브러리로써, 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM 을 통해 속도와 편의를 높이고, 단방향 데이터플로우를 지원하여 보일러플레이트 코드를 감소시켜, 많은 사람들이 React를 MVC의 V를 고려하여 선택한다. 즉, React는 지속해서 데이터가 변하는 대규모 어플리케이션의 구축이라는 하나의 문제를 풀기 위해서 만들어졌다. 아래는 React 에서 장점들이다. 단순함 : 당신의 어플리케이션이 어떤 주어진 시점에 어떻게 보여야할지를 단순하게 표현함으로써, React 는 그 데이터들이 변할 때, 자동적으로 모든 UI 업데이트들을 관리할 것이다. 선언적인 문법 : 데이터가 변할 때, React 는 개념적으로 ‘새로고침’ 버튼을 눌러서, 변화된 부분을 알아채 업데이트하게 된다. 구성적인 컴포넌트 개발 : React 는 재사용가능한 컴포넌트들을 개발하기 위한 모든 것이다. 사실, React 로 당신이 할 수 있는 오직 한가지는 컴포넌트를 개발하는 것이다. 그것들은 캡슐화 되어있기 때문에, 컴포넌트들은 재사용될 수 있고, 테스트될 수 있으며, 관심의 분리(seperation of concerns)를 지키게 해준다. 설치하기 리액트를 설치하고 프로젝트를 만들어 보자. 리액트 프로젝트를 만들 때는 Node.js 와 npm 을 반드시 먼저 설치해야 한다. Node.js 는 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임이다. 2009년 Node.js 를 출시한 이후 자바스크립트는 웹 브라우저 영역 외에 웹 서버는 물론, 모바일 애플리케이션, 데스크톱 애플리케이션 영역에서도 엄청나게 활약할 수 있게 되었다. 1. Node.js 설치: Windows Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/) 에서 Windows Installer 를 다운로드하고 설치한다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인한다. 12$ node -vv10.15.0 2. 에디터 설치 리액트 애플리케이션을 만들면서 코드를 수정할 때는 코드 에디터를 설치하여 사용하는 것이 편하다. 브래킷(Bracket), 아톰, VS Code 를 써본 결과 모든 운영체제를 지원하는 VS Code를 사용하고 있다. VS Code 공식 다운로드 페이지(https://code.visualstudio.com/Download) 에서 운영체제에 맞는 버전을 설치한다. 여기서는 Windows 버전을 설치한다. 이 에디터는 macOS, Window, 리눅스를 모두 지원한다. 3. create-react-app 설치 create-react-app 도구는 npm 으로 설치 할 수 있다. 패키지를 설치하는 방법은 두 가지가 있는데, 첫 번째는 지역적으로 설치하는 것이고, 두 번째는 전역적으로 설치하는 것이다. create-react-app은 커맨드라인 도구라서 모든 디렉토리에서 필요하므로 전역적으로 설치한다. 1$ npm install -g create-react-app 프로젝트 생성 프로젝트 생성할 때는 create-react-app &lt;프로젝트 이름&gt; 명령어를 사용한다. 123$ create-react-app test-react$ cd test-react$ npm start npm start 실행하여 완료했다면 http://localhost:3000/ 로 접속하여 확인한다. 프로젝트 구조 VS Code 를 실행하여 만들어진 test-react 프로젝트를 열면 다음과 같은 구조로 만들어져 있다. 이미 modules 가 설치되어 있고, 의존성 패키지는 대부분 node_modules/react-scripts 모듈내에 선언되어 있다. src 폴더안 에 있는 파일들을 추가하고 수정하면서 개발을 하면 된다. 정리 리액트에 관심이 생겨 책을 읽고 검색한 내용들을 모아서 리액트에 대한 설명부터 설치, 프로젝트 실행까지 간략하게 설명하였다. 현재는 리액트를 공부하면서 정리하는 단계라서 현업에서 리액트 라이브러리를 사용하면서 겪는 이슈사항이나 팁은 추후에 정리 할 예정이다. 참고 React 시작하기 [ReactJs] create-react-app으로 react 시작하기 [React] 1. 리액트 시작하기 개발 관련 강좌 사이트 리액트를 다루는 기술 출간 / 집필후기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"}]},{"title":"[React Native] Live Reload","slug":"react-enable-reload","date":"2019-01-08T08:59:53.000Z","updated":"2023-07-12T06:22:18.704Z","comments":true,"path":"2019/01/08/react-enable-reload/","link":"","permalink":"http://hgko1207.github.io/2019/01/08/react-enable-reload/","excerpt":"","text":"Live Reload 리액트 네이티브 기반으로 안드로이드 앱 개발을 할 때 자동으로 리로드 되게 하려면 어떻게 해야 할까. 리액트 기반으로 웹 개발을 할 때에는 코드를 수정 시 자동으로 리로드 되었는데 리액트 네이티브로 개발할 때에 자동으로 되지 않아 검색하던 중 아래 내용 처럼 옵션 설정을 하니까 잘 동작하였다. 명령 프롬프트에서 다음을 입력하여 장치 또는 에뮬레이터에서 앱을 설치하고 실행한다.1$ react-native run-android 에뮬레이터를 클릭하고 CTRL + M ( MacOS의 경우 CMD + M )을 누르거나 실행 중인 응용 프로그램이 있는 Android 장치를 흔들면 된다. 팝업 메뉴에서 Enable Live Reload 옵션을 선택한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"}]},{"title":"[Eclipse RCP] 이클립스 플러그인 추가","slug":"eclipse-rcp","date":"2019-01-07T09:25:03.000Z","updated":"2023-07-11T06:54:41.708Z","comments":true,"path":"2019/01/07/eclipse-rcp/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/eclipse-rcp/","excerpt":"","text":"Eclipse Piug-in 추가 Eclipse에 플러그인을 추가하는 방법에는 두 가지가 있다. 첫 번째 방법은 플러그인을 직접 복사해서 설치하는 방법이고, 두 번째 방법은 Eclipse 에서 제공하는 Software Update Manager 를 활용하는 방법이다. 직접 복사하는 방법 설치하고자하는 플러그인을 Eclipse_home/plugin 디렉토리에 복사한 다음 Eclipse를 재시작하면 새롭게 설치된 Eclipse 플러그인 기능을 활용할 수 있다. Software Update Manager를 활용하는 방법 Eclipse 에서 제공하는 Software Update Manager 기능은 플러그인을 개발한 곳에서 이 기능을 사용할 수 있도록 지원하지 않으면 사용할 수 없다. Eclipse 에서 Help-&gt;Install New Software로 이동 후 설치 할 플러그인 URL를 입력하여 다운받는다. 또 다른 방법은 Help-&gt;Eclipse Marketplace로 이동 후 설치 플러그인을 검색 후 다운받는다. 이클립스 RCP Piug-in 구조 모든 플러그인의 실제 동작에 대한 정의는 코드에 들어있지만, 플러그인의 종속성과 서비스는 MANIFEST.MF와 plugin.xml 파일에서 선다. 이런 구조 덕분에 플러그인 코드가 당장 필요한 순간이 되어서야 로딩되는 늦은 로딩(lazy loading)이 가능하며, 이에 따라 이클립스의 시동 시간과 메모리 사용량을 줄일 수 있습니다. 이클립스 시동될 때는 플러그인 로더가 각 플러그인에 대한 MANIFEST.MF와 plugin.xml 파일 전부를 훑어본 다음, 플러그인에 대한 정보를 포함하는 구조체를 구성한다. Piug-in 선언(MANIFEST.MF) 각 번들 내역서 내에는 이름, ID, 버전, 플러그인 클래스, 프로바이더에 대한 항목이 들어 있다. 1. Piug-in ID 플러그인 ID(Bundle-SymbolicName)는 단 하나의 플러그인을 식별하기 위해 설계된 것이며 일반적으로 자바 패키지 이름 규약(예: com.&lt;회사명&gt;.&lt;제품명&gt;)을 이용해 구성된다. 2. Piug-in 버전 플러그인에 지정된 버전(Bundle-version)은 항상 3개의 수를 점으로 구분해 나열한 것이다. 첫 번째 수는 주 버전(major version)을 의미하며 두 번째는 부 버전(minor version), 세 번째는 서비스 레벨을 의미한다. 3. Piug-in 이름과 제공자 이름과 제공자는 둘 다 사람이 읽기 위한 텍스트이므로 어떻게 입력하든지 상관없고 또한 유일할 것일 필요도 없다. 4. Piug-in 클래스 선언 모든 플러그인은 필요한 경우에 플러그인 클래스(Bundle-Activator)를 지정할 수 있다. 5. Piug-in 런타임 MANIFEST.MF 파일의 Bundle-ClassPath 선언에는 플러그인 코드에 포함된 라이브러리(*.jar 파일) 를 콤마(‘ , ‘)로 구분해 나열한다. Bundle-ClassPath에서 정의한 라이브러리에 들어있는 패키지를 다른 플러그인에서 접근 할 수 있게 지정하려면 ExportPackage 선언을 써서 접근 가능하게 할 패키지를 콤마 구분 목록으로 지정한다. 6. Piug-in 종속성 플러그인 로더는 각 로딩된 플러그인마다 개별 클래스 로더의 인스턴스를 생성하며 내역서의 Require-Bundle 선언을 사용해 해당 플러그인이 실행 중 참조해야 할 플러그인이 어느 것인지를 지정한다. Piug-in 모델 이클립스는 처음 실행될 때 각 플러그인 디렉토리를 모두 돌아본 다음, 찾아낸 개별 플러그인을 표현하는 내부 모델을 구성한다. 개별 플러그인 전체를 로딩하지 않으며 플러그인 내역서만 검토한다. 1. Platform org.eclipse.core.runtime.Platform 클래스는 현재 실행 중인 이클립스 환경에 대한 정보를 제공한다. 이 클래스를 사용해 설치되어 있는 플러그인(번들), 확장, 확장점, 명령행 인자, 작업 관리자 등의 정보를 얻을 수 있다. 2. Piug-in 과 번들 Platform.getBundleGroupProviders() 나 Platform.getBundle(String)을 사용해 현재 설치된 플러그 인(번들)에 대한 정보를 얻을 수 있다. 플러그인 클래스, 즉 번들 액티베이터에 접근하려면 해당 플러그인을 로드해야 하지만 Bundle 인터페이스에는 별도의 부담 없이 접근할 수 있다. 3. Piug-in 확장 레지스트리 Platform.getExtensionRegistry() 메소드를 사용해서 플러그인 확장 레지스트리(extension registry)에 접근할 수 있다. 확장 레지스트리에는 각 플러그인을 표현하는 플러그인 디스크립터가 포함되어 있으며 플러그인을 로딩하지 않고도 다양한 플러그인 정보를 얻을 수 있는 메소드를 제공한다. Piug-in 개발 Piug-in Project 생성 New -&gt; Plug-in Project 클릭한다. Project name 입력 후 Next 클릭한다. ID에 패키지명 입력 Activator 패키지 명을 1)번에 입력한 패키지명과 같도록 입력 No 버튼 클릭 후 Next 클릭 “Hello, World Command” 선택 후 Finish 클릭한다. 위와 같이 플러그인 프로젝트가 생성되면 MANIFEST.MF 클릭 -&gt; Extensions 탭으로 이동 기본적으로 “Hello, World Command”를 선택하면 commands, handlers, bindings, menus 4개의 트리가 만들어진다. Commands는 실제 동작으로부터 독립적이며 선언적이고, org.eclipse.ui.commands 확장점을 통하여 정의되어 있다. 그리고 단축키(Key Binding)가 정의될 수 있고, 커맨드의 행동은 핸들러를 통하여 정의된다. Handlers는 commands로부터 명령을 받아 호출되고, 호출되자마자 클래스를 실행한다. 클래스를 정의할 때 org.eclipse.core.commands.AbstractHandler 클래스를 상속받는다. Execute() 메소드는 핸들러가 실행되면 호출 되며, HandlerUtil 클래스를 통하여 서비스에 접근할 수 있다. Bindings는 메뉴에 단축키를 지정할 수 있다. Menus는 애플리케이션 메인 메뉴, 툴바, 뷰 툴바, 팝업메뉴를 만들 수 있다. org.eclipse.ui.menus 에서 menuContribution는 사용자 인터페이스에서 메뉴가 표시되는 위치를 정의할 수 있는 locationURI 속성을 가지고 있다. locationURI 속성에는 기본적으로 menu:와 toolbar:, popup: 으로 시작하며 그 다음에는 메뉴가 표시될 위치를 지정할 수 있다. 예를 들어, 파일 메뉴(ID:fileMenu)의 하의 메뉴에 위치시키려면 다음와 같은 위치식을 이용한다. 12// 예)menu:fileMenu?after=addition Piug-in 배포 플러그인을 만들었으면 jar로 생성해야 합니다. Export -&gt; Plug-in Development -&gt; Deployable plug-ins and fragments 선택 후 Next 클릭한다. 배포하는 플러그인 프로젝트를 선택하고, Directory란에 배포하는 폴더를 지정하고, Finish를 클릭한다. 지정한 폴더에 jar로 배포가 되는 것을 확인할 수 있다. 참고 이클립스 커맨드 튜토리얼 Eclipse RCP 란?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"도메인이란","slug":"it-domain","date":"2019-01-07T08:16:14.000Z","updated":"2023-07-11T06:56:07.100Z","comments":true,"path":"2019/01/07/it-domain/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/it-domain/","excerpt":"","text":"도메인 이름은 ‘인터넷에 연결된 컴퓨터들에 부여되는 교유의 문자 주소’ 정도라고 보시면 된다. 영어로는 DNS(Domain Name System) 라고 한다. 인터넷에 연결되어 있는 컴퓨터에 접속하려면 IP 주소(Internet Protocol Address)를 알아야 한다. 그런데 IP 주소는 기억하기가 힘들고 매우 불편하다. 그래서 쉽게 사이트의 주소를 기억하고 여기서 좀 더 나아가서 사이트의 특성을 파악할 수 있도록 고안된 것이 바로 ‘도메인 이름’ 이다. 도메인은 각 컴퓨터 고유의 IP 주소에 대응되는 문자로 된 인터넷 주소다. EX) 구글(google) 사이트 google . co . kr =&gt; 소속기관이름 . 소속기관 분류 . 소속국가 도메인은 크게 3단계로 구분된다. (인터넷 도입 초기에는 3단계 였으나, 현재는 2단계도 혼용 사용, 예) .kr) 가) 최상위 도메인(2가지로 분류) 미국 최상위 도메인 : com, edu, net, org, gov, re, mil, int 국가 최상위 도메인 : kr, jp, cn 나) 2차 도메인 미국 최상위 도메인에서의 2차 도메인 : naver, yahoo, google 국가 최상위 도메인에서의 2차 도메인 : or, co, ac, ne 다) 3차 도메인 국가 최상위 도메인에서의 3차 도메인 : nate, yahoo com : 상업기관 co.kr : 상업기기관 + 국가도메인 net : 네트워크 관련 기관 go.kr : 정부기관 + 국가도메인 or.kr : 비영이/기타 기관 + 국가도메인 kr 과 혼합된 주소는 한국 관련 회사를 뜻하는 것이다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"}]},{"title":"[JPA] Annotation 정리","slug":"jpa-annotation","date":"2019-01-07T05:15:34.000Z","updated":"2023-07-12T01:30:37.156Z","comments":true,"path":"2019/01/07/jpa-annotation/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/jpa-annotation/","excerpt":"","text":"JPA 로 개발하면서 자주 사용하는 어노테이션을 정리하였다. @Entity 해당 클래스가 엔티티임을 알리기 위해 사용한다. 애플리케이션이 실행이 될 때 엔티티 자동검색을 통하여 이 어노테이션이 선언 된 클래스들은 엔티티 빈으로 등록한다. @Table 데이터의 저장소, 테이블을 의미한다. name 값은 실제 데이터베이스의 테이블 명을 의미하며, 생략이 가능한다. 어노테이션을 생략하면 클래스의 이름을 테이블의 이름으로 자동 인식하게 된다. @Id 엔티티빈의 기본키를 의미한다. 이 어노테이션은 하나의 엔티티에는 반드시 하나가 존재해야 한다. 복수키도 설정할 수 있다. @GeneratedValue 데이터베이스에 의해 자동으로 생성된 값이라는 의미다. 즉, 프로그램 상에서 조작된 데이터가 아닌, 실제 데이터베이스에 데이터가 영속(저장)될 때 생성되는 값이다. 몇 가지 생성전략이 존재한다. IDENTITY : 기본 키 생성을 데이터베이스가 함 SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키 할당 TABLE : 키 생성 테이블 생성 @Column 필드와 테이블의 컬럼을 매핑시켜준다. 이 어노테이션은 생략이 가능하며, 생략 시 필드의 이름이 테이블의 컬럼으로 자동으로 매핑이 된다. name속성(String) 필드와 매핑 될 컬럼의 이름을 명시한다. nullable속성(boolean) 해당 컬럼이 null값을 허용하는가 하지않는가의 여부다. length속성(int) 컬럼의 길이값을 의미합니다. unique속성(boolean) 컬럼이 유일한 값을 가져야 하는가 아닌가의 여부다. insertable속성(boolean) 엔티티가 영속될 때 insert에 참여할지 말지를 결정한다. 기본값은 true updatable속성(boolean) 변경된 필드의 값을 테이블에도 반영할지를 결정한다. 기본값은 true name 속성을 제외한 나머지 속성은 잘 사용되지 않을 것 이라고 생각된다. nullable, length, unique는 DDL과 관련된 속성이고, insertable, updatable은 원래 잘 사용되지 않는 속성이기 때문이다. @Temporal java.util.Date와 java.util.Calendar 값을 매핑 할 때 사용한다. TemporalType.Date : 년-월-일 의 date 타입 (2019-01-04) TemporalType.Time : 시:분:초 의 time 타입 (12:11:11) TemporalType.TIMESTAMP : date + time 의 timestamp(datetime) 타입 (2019-01-04 12:11:11) 어노테이션을 사용하지 않을 경우 기본값은 timestamp 다. JPA 데이터베이스 방언에 의해, 데이터베이스의 타입에 따른 timestamp 또는 datetime은 자동으로 작성된다. @ColumnPosition(1) 컬럼 순서 정한다. @Enumerated 자바의 enum 타입을 매핑할 때 사용한다. 속성으로 EnumType.ORDINAL 과 EnumType.STRING 이 존재하는데 이름 그대로 ORDINAL은 순서를 STRING은 Enum의 이름을 저장한다. @LOB 데이터베이스 BLOB, CLOB 타입과 매핑된다. CLOB(String, char[], java.sql.CLOB)은 문자, BLOB(byte[], java.sql.BLOB)은 나머지가 매핑된다. @Transient 저장 조회에 사용되지도 않고 그냥 단순 값을 가지고 있고 싶을 때 사용한다. @Access 데이터베이스에 엔티티에 값이 저장될 때 필드(AccessType.FIELD)의 값을 직접 접근해서 사용할 것인가 아니면 메서드에 직접(AccessType.PROPERTY) 접근할 것 인가를 설정하는 것이다. @MappedSuperClass 어노테이션을 사용하면 부모 엔티티 접근 없이 부모 클래스의 매핑정보를 사용할 수 있다. 부모의 내용을 별도로 재정의해서 사용하고 싶은 경우에는 @AttributeOverride를 사용하여 재정의 한다. 여러 개를 한번에 정의하기 위해서는 @AttributeOverrides를 사용한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"}]},{"title":"리액트를 다루는 기술","slug":"book-react-technology","date":"2019-01-07T04:53:57.000Z","updated":"2023-07-11T06:50:52.178Z","comments":true,"path":"2019/01/07/book-react-technology/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-react-technology/","excerpt":"","text":"책 정보 책소개 리액트를 이해하기 위한 핵심 개념은 물론이고 어떤 상황에서 어떻게 사용해야 하는지, 왜 이렇게 사용하는 것이 효과적인지를 배우자. 공식 문서에는 나오지 않는 실전 노하우와 팁을 풍부하게 담았다. 또한, 프로젝트 생성부터 코드를 작성 및 개선하고, 배포하기까지 실무에 바로 응용할 수 있도록 예제를 준비했다. 일정 관리 애플리케이션을 만들면서 리액트의 기본기를 다지고, 프로젝트를 진행하면서 컴포넌트 스타일링, 상태 관리, API 연동, 라우팅, 코드 스플리팅, 서버사이드 렌더링 등 리액트를 활용한 다양한 기술을 사용해보자. 마지막으로 마크다운 기반의 블로그 시스템을 만들며 배운 지식을 종합적으로 활용해보자. 리뷰 작년에 처음으로 AngularJS 를 사용하여 프로젝트를 하면서 접한 이후로 관심이 생겨 최신 버전인 Angular6 를 공부하였었는데 뭔가 착 달라붙는 다는 느낌이 들지 않아 잠깐 공부를 멈췄었다. 최근에 다시 새로운 기술을 공부하고 싶어 찾던 중에 리액트가 자바스크립트 라이브러리라서 접근하기가 쉽고 이해도도 빠를 것 같아 책을 바로 구매하게 되었다. 책을 사면 예제를 직접 하나씩 다 코딩하면서 공부하는 타입이라서 이번에도 모두 다 코딩을 하면서 익숙해져갔다. 그런데 책에 있는 예제들이 자바스크립트라서 익숙하긴 한데 리액트 초보자에게는 조금 어렵다는 느낌이 들었다. 그래도 열심히 따라서 코딩한 덕분에 흐름을 이해할 수 있었다. 리액트를 알게 되면서 리액트 네이티브에 대해서도 공부하고 싶은데 출간 된 책이 많이 없는 것 같아 아쉬웠다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"}]},{"title":"[Android] Tab 구성 시 주의사항","slug":"android-tab","date":"2019-01-07T04:42:09.000Z","updated":"2023-07-11T02:18:10.352Z","comments":true,"path":"2019/01/07/android-tab/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/android-tab/","excerpt":"","text":"FragmentStatePagerAdapter의 getItem() 이 두 번 호출될 때 Viewpager 를 사용하여 Tab 을 구성하였을 때 FragmentStatePagerAdapter 를 사용하였다. 탭에 추가한 Fragment 와는 상관없이 getItem() 이 두 번 호출이 되어서 Fragment 를 두 번 로드하게 되는 현상 때문에 문제가 생겨 꼬이게 되었다. 이럴경우 Fragment 화면이 보일 때와 보이지 않을 때 setUSerVisiblaHint() 함수를 사용하여 처리하는데 탭에 추가한 Fragment 가 전부 로드되지 않고 어중간하게 두 개의 화면만 로드되었기 때문에 다른 탭을 누르거나 다시 돌아왔을 때 setUSerVisiblaHint() 와 onCreateView() 함수가 비정상적으로 호출되는 바람에 코딩을 하는데 애먹었다. 그래서 찾은 방법은 아래 코드 처럼 ViewPagerAdapter 에 Fragment 를 3개 추가 하였을 때 setOffscreenPageLimit() 함수에 viewPager 에 추가한 Fragement 의 수를 지정하여 화면이 미리 로드되게 하면 getItem() 은 Fragement 수 만큼(예: 3번) 호출되지만 앞에서 문제되는 것을 해결할 수 있었다. 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tabs) TabLayout tabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); setupViewPager(); &#125; private void setupViewPager() &#123; ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager()); viewPagerAdapter.addFragment(new MobileFragment()); viewPagerAdapter.addFragment(new LteFragment()); viewPagerAdapter.addFragment(new WifiFragment()); viewPager.setOffscreenPageLimit(viewPagerAdapter.getCount()); viewPager.setAdapter(viewPagerAdapter); tabLayout.setupWithViewPager(viewPager); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"}]},{"title":"[JavaScript] Chart 라이브러리 정리","slug":"javascript-chart","date":"2019-01-07T04:19:53.000Z","updated":"2023-07-11T06:57:01.524Z","comments":true,"path":"2019/01/07/javascript-chart/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/javascript-chart/","excerpt":"","text":"웹 개발을 하면서 사용해본 Chart 를 정리 해보았다. 무료인 것도 있고 조건부 무료인 차트도 있다. 대부분 사용하기에 편리하여 적용하기도 쉽고 심플하고 이쁜 디자인도 많고 예제와 설명이 잘 되어있어 좋았다. 1. AmCharts 링크 : ​https://www.amcharts.com/ 예제 : http://www.amcharts.com/demos/ 유료 라이센스 이지만 조건부 무료다. 사용해본 라이브러리 중에 기능이 엄청 많고 디자인이 제일 깔끔하다. 라이센스 비용은 개인이 사용하기에는 부담이 될 수 있지만, 차트에 개발사 링크가 출력되는 조건만 지키면 무료로 사용 가능하다. 2. HighCharts 링크 : https://www.highcharts.com/ amCharts와 같이 조건부 무료입니다. Angular에서도 쓸 수 있고, 차트 종류도 다양하고, 사용법이 편리하며 커스터마이징도 쉽게 할 수 있다. 현재 가장 많이 사용하는 차트다. 3. D3 Data-Driven Documents 링크 : https://d3js.org/ 무료입니다. 데이터 시각화 프레임워크로 잘 알려져 있고, 자바스크립트로 개발을 한다. HTML5의 SVG(Scalable Vector Graphic)을 통해 다양한 화면 해상도에서 깨짐 없는 가시화가 가능하다. D3 차트에서는 버블차트와 OpenLayers3에 파이차트를 올려 사용하였다. D3는 기본적인 개념과 사용법을 익혀야 사용이 가능하므로 공부를 많이 해야 한다. 4. Chart.js 링크 : http://www.chartjs.org/ 예제 : http://www.chartjs.org/docs/latest/ 오픈소스이며, 전체적으로 깔끔하고 문서도 정리가 잘 되어 있습니다. 인기가 많고, 사용법이 편리하고 이쁩니다. 5. Google Chart 링크 : https://developers.google.com/chart/ 구글 차트는 많이 사용해보지 못하였지만, 기능은 많습니다. 하지만 디자인이 다른 차트에 비해 이쁘지 않은 것 같아 많이 사용하지 않았습니다. 그렇지만 사용하기는 편리합니다. 6. Morris.js 링크 : http://morrisjs.github.io/morris.js/ 무료이며 사용이 정말 간단합니다. 그리고 디자인도 심플한 편이라 간단하게 테스트 용으로 많이 사용하였습니다. 7. Chartist.js 링크 : http://gionkunz.github.io/chartist-js/ Chartist 또한 인기있는 Chart Javascript 라이브러리 중의 하나로 SVG를 사용하며, CSS를 통해 모양을 다듬을 수 있습니다. 위의 차트들이 자주 사용하는 차트들입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"}]},{"title":"[Cesium] 초기 설정","slug":"cesium-init","date":"2019-01-07T02:37:21.000Z","updated":"2023-07-11T06:51:46.863Z","comments":true,"path":"2019/01/07/cesium-init/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/cesium-init/","excerpt":"","text":"GIS 관련 프로젝트를 하다보니 오픈소스인 CesiumJS 나 Openlayers 라이브러리를 사용하게 되었다. 최근에는 2D, 3D 모드가 가능한 CesiumJS 를 주로 사용하게 되었다. Cesium 이란? 순수 웹 기불을 이용한 3D Globe 엔진 WebGL 기반 다양한 배경 영상/지도 기본 제공 3D / 2.5D / 2D 모드 지원 -&gt; Openlayers3에 통합 카메라 움직임 추적, 시간 시뮬레이션 등 다양한 기능 제공 Cesium 을 시작할 때 초기 설정이 복잡하다. 다음 두 개의 링크를 따라가서 따라하면 쉽게 할 수 있다. 하지만 웹에서 커스터마이징을 하기 위해 아래 코드 처럼 Cesium 에서 지원하는 기본적인 기능들을 끄고 지도만 보이도록 설정해야 한다. API 들은 문서나 인터넷 검색으로 찾아봅시다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- Include the CesiumJS JavaScript and CSS files --&gt; &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt; &lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; imageryProvider: new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/gwc/service/wms', layers: 'osm:osm', parameters: &#123; service: 'WMS', version: '1.1.1', request: 'GetMap', layers: 'osm:osm', srs: 'EPSG:3857', crs: 'EPSG:3857', format: 'image/png', tranparent: true, tiled: true, &#125;, tilingScheme: new Cesium.WebMercatorTilingScheme(), &#125;), animation: false, baseLayerPicker: false, fullscreenButton: false, vrButton: false, geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, selectionIndicator: false, timeline: false, navigationHelpButton: false, projectionPicker: false, selectedEntity: false, trackedEntity: false, clockTrackedDataSource: false, &#125;); const scene = viewer.scene; const camera = viewer.camera; const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas); const ellipsoid = scene.globe.ellipsoid; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 위의 예제는 미리 구축된 Geoserver 를 베이스 맵으로 설정하였다. Geoserver 가 구축되지 않았다면 Cesium 에서 제공되는 기본 Provider 를 사용하면 된다. 123456&lt;!-- 예시 --&gt;&lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; terrainProvider: Cesium.createWorldTerrain(), // 기본 지도를 지형지도로 셋팅 &#125;);&lt;/script&gt; 참고 https://cesium.com/docs/tutorials/quick-start/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"깡샘의 안드로이드 프로그래밍","slug":"book-ggangsam","date":"2019-01-07T01:09:21.000Z","updated":"2023-07-11T06:50:24.778Z","comments":true,"path":"2019/01/07/book-ggangsam/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-ggangsam/","excerpt":"","text":"책 정보 책 소개 이 책은 각 챕터마다 안드로이드 프로그램과 각 기능이 어떠한 구조로 어떻게 작동하는지 그 원리를 파악하는 데 주력합니다. 그리고 이를 구현하는 핵심 코드를 알아본 다음, 이를 종합하여 실제 상용 앱에서 많이 사용하는 기능을 직접 개발해보는 실습을 진행합니다. 그리고 각 파트별로 도전 과제를 통해 학습자 스스로 주어진 조건에 맞는 앱을 만들어봄으로써 앞에서 배운 이론과 실습을 복기하고 문제 해결 능력을 기를 수 있게 구성하였습니다. 한 마디로 체계적이고 따라 하기 쉽습니다. 리뷰 최근에 안드로이드를 다시 공부하면서 보는 책이다. 안드로이드 스튜디오 3.0 기반으로 개발할 수 있도록 해주며, 끝에는 Kotlin 까지 나온다. 그리고 예제도 다양하여 도움이 많이 되고 있다.​","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"}]},{"title":"[Angular] 강좌 추천","slug":"angular","date":"2019-01-07T00:55:40.000Z","updated":"2023-07-11T06:50:04.409Z","comments":true,"path":"2019/01/07/angular/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/angular/","excerpt":"","text":"Angular 강좌 추천 작년에 Angular1 즉 AngluarJS 를 Spring Framework + Spring JPA + MySQL 합쳐서 연동하여 개발하였다. 그 때에 AngularJS 를 처음 접해보았고, 제가 아는 분에게 배우기도 해서 일부분을 개발하다가 하나의 프로젝트를 처음부터 만들어 보았었다. 그 이후로 Angular 를 사용하지 않았었는데, 지금 벌써 Angular 6 버전 까지 나와서 놀랐다. 아래 URL은 Angular 6 은 아니지만 Angular 5 버전 강좌다. NodeJS 와 Typescript 가 대세여서 공부해보려고 하다가 Angular 를 다시 보게 되어 찾다가 이 강좌가 설명이 너무 잘 되어 있어서 공부를 하는 중이다. 여러모로 감사합니다. URL: https://moon9342.github.io/angular-lecture-introduction","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"}]},{"title":"[Web Design] Metronic Dashboard","slug":"dashboard","date":"2019-01-04T09:13:00.000Z","updated":"2023-07-11T02:17:43.137Z","comments":true,"path":"2019/01/04/dashboard/","link":"","permalink":"http://hgko1207.github.io/2019/01/04/dashboard/","excerpt":"","text":"대시보드 템플릿 웹 개발을 하다보면 작은 프로젝트인데도 디자인 요청이 있다. 그럴때마다 디자인된 부트스트랩 기반 템플릿을 찾곤 했었다. 매번 디자인이 아쉽고 템플릿을 사용하여도 직접 CSS 를 작업하는 경우가 많았는데 지인의 추천으로 Metronic 을 알게 되었다. Metronic - Responsive Admin Dashboard Template The World’s #1 Bootstrap 4 HTML, Angular 9, React, VueJS &amp; Laravel Admin Dashboard Theme 이 템플릿은 사용하기도 편하고 디자인도 요즘 트렌드에 맞게 계속 업데이트를 하고 있다. 알아둘 점은 유료다. 구매비용이 저렴한 것에 비해 다양한 컴포넌트들이 있고 10가지 이상의 템플릿을 제공해준다. 한 마디로 가성비가 좋다. React, Angular, Vue 에서 사용 가능하며 업데이트 될 때마다 바로 적용되는 점이 매우 좋다. 이 템플릿을 쓰려면 구조와 사용법을 공부를 해야 하는 시간이 조금 소요되지만 커스텀하기가 편해서 자주 사용하고 있다. 물론 직접 프론트엔드를 개발하면서 하면 좋지만 편리하고 빠르게 개발하기 위해 템플릿들을 써서 개발하는 것도 좋은 것 같다. 단점이라면 포함된 기능들이 많아 초기에 로드할 때 느리다는 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"}]}],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"},{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"},{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"},{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"},{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"},{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"},{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"},{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"},{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"},{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"},{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"},{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"},{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"},{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"},{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"},{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"},{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"},{"name":"Postcode","slug":"Postcode","permalink":"http://hgko1207.github.io/tags/Postcode/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"Daum","slug":"Daum","permalink":"http://hgko1207.github.io/tags/Daum/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"},{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"}]}