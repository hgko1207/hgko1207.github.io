{"meta":{"title":"규니의 블로그","subtitle":"hgko's IT Blog","description":"Information related to IT","author":"Hyeong Gyun Ko","url":"http://hgko1207.github.io","root":"/"},"pages":[{"title":"About","date":"2019-01-07T08:59:42.000Z","updated":"2023-04-25T01:49:09.423Z","comments":true,"path":"about/index.html","permalink":"http://hgko1207.github.io/about/index.html","excerpt":"","text":"안녕하세요. 블로그를 시작한지 얼마 안 된 새내기입니다. 이전에는 네이버 블로그에 조금씩 업로드를 하였었는데, Github 에 연동된 블로그가 있어 시작하게 되었습니다. 개발 경력은 쌓이는데 개발에 대한 내용을 기록한 적이 많이 없어 이번 계기로 열심히 기록해보려고 합니다. 컴퓨터공학과 학사 졸업 정보통신공학과 석사 졸업 현재 프리렌서 취미 축구 자전거 수영 게임 관심사 블로그 자격증 육아"},{"title":"Profile","date":"2020-07-29T00:52:04.000Z","updated":"2023-07-21T14:20:02.504Z","comments":true,"path":"profile/index.html","permalink":"http://hgko1207.github.io/profile/index.html","excerpt":"","text":"보유기술 Programming Laguage Java, JavaScript, TypeScript, HTML5, CSS Python, Dart C#, C++ Framework / Library Spring Framework, Spring Boot, JPA, Querydsl NodeJS, React, Next.js, Angular React Native, Android, WPF Bootstrap, JQuery Server MySQL, MSSQL, PostgreSQL, Oracle, Elasticsearch Docker, Nginx, Tomcat Kafka, Zookeeper Tooling / DevOps GitHub, GitLab, SVN Gradle, maven Jenkins, Travis CI Environment Windows, Linux, AWS 관심분야 Vue.js Go AI Contact GitHub : https://github.com/hgko1207 E-Mail : khkkhk1207@gmail.com 블로그 : https://hgko-dev.tistory.com/"}],"posts":[{"title":"원활한 원격 회의를 위한 최고의 AI 회의 도우미 살펴보기","slug":"ai-5","date":"2024-01-16T01:00:27.000Z","updated":"2024-01-16T01:16:27.490Z","comments":true,"path":"2024/01/16/ai-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/16/ai-5/","excerpt":"","text":"소개 빠르게 변화하는 현대 비즈니스 세계에서 원활하고 생산적인 회의에 대한 필요성이 그 어느 때보다 커졌습니다. 인공지능(AI) 회의 도우미의 출현으로 팀의 협업 방식에 혁신을 가져왔으며, 가상 회의를 더욱 효율적이고 즐겁게 만들어주었습니다. 1. Google Meet - 언어의 장벽을 허물다 AI 회의 도우미 분야의 선두주자 중 하나인 Google Meet은 언어 장벽을 허무는 데 탁월합니다. 실시간 언어 번역 기능을 통해 Google Meet는 언어 차이로 인해 효과적인 커뮤니케이션이 방해받지 않도록 합니다. 예시 시나리오 다국적 팀이 프로젝트를 위해 협력하는 시나리오를 생각해 보세요. Google Meet의 AI 기반 언어 번역은 음성 단어를 각 참가자가 선호하는 언어로 원활하게 변환하여 진정으로 포용적이고 협력적인 환경을 조성합니다. 2. Microsoft Teams - 자동화를 통한 더욱 스마트한 회의 Microsoft Teams는 AI 회의 도우미 기능으로 공동 작업의 수준을 한 단계 끌어올립니다. 바쁜 프로젝트 관리자가 여러 작업을 처리하는 모습을 상상해 보세요. Microsoft Teams는 회의 예약을 자동화하고, 미리 알림을 보내고, 참가자의 참석 가능 시간에 따라 최적의 회의 시간을 제안할 수도 있습니다. 예시 시나리오 이러한 수준의 자동화를 통해 팀은 회의을 설정하고 관리의 실행 계획보다는 당면한 안건에 계속 집중할 수 있습니다. 3. Zoom - 동등한 참여를 위한 안면 인식 기능 Zoom은 회의에서 AI를 혁신적으로 사용하는 것으로 유명합니다. 얼굴 인식 기능을 사용하면 가상 공간에 있는 모든 사람이 각자의 시간에 기여할 수 있도록 보장합니다. 대규모 팀 회의에서 Zoom의 AI 회의 도우미는 각 참가자를 식별하고 그들이 말할 때 강조 표시합니다. 이는 동등한 참여를 장려할 뿐만 아니라 목소리에 얼굴을 입혀 참여도를 높이고 가상 상호작용을 더욱 개인화합니다. 예시 시나리오 서로 다른 위치에 있는 팀원들이 참여하는 가상 회의실을 상상해 보십시오. Zoom의 얼굴 인식 기능은 각 사람이 동등한 관심을 받을 수 있도록 보장하여 포용성과 참여감을 고취합니다. AI 회의 도우미(AI Meeting Assistant)의 이점 시간 효율성 일상적인 작업을 자동화하여 보다 효율적인 회의를 진행하세요. 참가자의 참석 가능 여부에 따라 최적의 회의 시간을 제안합니다. 향상된 커뮤니케이션 실시간 언어 번역은 글로벌 협업을 촉진합니다. 얼굴 인식을 통해 참가자 참여도가 향상됩니다. 글로벌 협업 포용적인 토론을 위해 언어 장벽을 허물어줍니다. 다양한 시간대에 걸쳐 원활한 협업을 촉진합니다. 생산성 향상 자동화를 통해 수동 개입을 줄이고 시간을 절약합니다. 프로젝트 관리 도구와 통합되어 토론에서 실행 항목으로 보다 원활하게 전환할 수 있습니다. 참여도 향상 얼굴 인식을 통해 모든 사람이 동일한 목소리를 낼 수 있습니다. 자동화된 회의 요약 기능으로 참가자에게 정보를 제공하고 참여를 유도합니다. 결론 원격 근무와 글로벌 협업의 역동적인 환경에서는 AI 회의 도우미의 역할은 매우 중요합니다. 제공된 실제 사례는 이러한 어시스턴트가 어떻게 가상 ​​회의를 변화시켜 더욱 효율적이고 포용적이며 매력적인 회의로 만들 수 있는지 보여줍니다. 언어 포용성을 위해 Google Meet을 선택하든, 자동화를 위해 Microsoft Teams를 선택하든, 얼굴 인식을 위해 Zoom을 선택하든 AI 회의 도우미를 워크플로에 통합하는 것은 팀 협업의 잠재력을 최대한 발휘하기 위한 전략적인 조치입니다. AI 회의 도우미의 강력한 기능을 도입하여 효율성이 효율성과 혁신이 만나고 협업의 경계가 없는 새로운 차원의 가상 회의를 경험하세요. 효율적인 회의는 물론 특별한 회의를 위해 설계된 최첨단 솔루션으로 끊임없이 진화하는 원격 근무의 세계에서 앞서 나가세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"원격회의","slug":"원격회의","permalink":"http://hgko1207.github.io/tags/%EC%9B%90%EA%B2%A9%ED%9A%8C%EC%9D%98/"},{"name":"회의도우미","slug":"회의도우미","permalink":"http://hgko1207.github.io/tags/%ED%9A%8C%EC%9D%98%EB%8F%84%EC%9A%B0%EB%AF%B8/"},{"name":"AI Meeting Assistant","slug":"AI-Meeting-Assistant","permalink":"http://hgko1207.github.io/tags/AI-Meeting-Assistant/"}]},{"title":"Pandas 마스터하기: 데이터 조작을 위한 고급 기술","slug":"python-4","date":"2024-01-15T05:10:27.000Z","updated":"2024-01-15T05:52:02.557Z","comments":true,"path":"2024/01/15/python-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/15/python-4/","excerpt":"","text":"Pandas 여정을 진행하면서 기본을 넘어 데이터 조작 기술에 정교함을 더하는 몇 가지 강력한 기술을 살펴보겠습니다. 1. DataFrame 병합 및 연결 여러 소스의 데이터를 결합하는 기술을 자세히 살펴보세요. DataFrame 병합과 연결의 차이점을 이해하고 다양한 유형의 조인을 처리하는 방법을 알아보세요. 12# Concatenate DataFrames verticallyresult = pd.concat([df1, df2]) 12# Merge DataFrames based on a common columnmerged_df = pd.merge(left_df, right_df, on='common_column', how='inner') 설명 연결: pd.concat()은 DataFrame을 수직으로 쌓는 데 사용됩니다. 동일한 열을 가진 데이터 세트가 있고 행 단위로 결합하려는 경우에 유용합니다. 병합: pd.merge()는 공통 열(column)을 기준으로 DataFrame을 결합하는 데 사용됩니다. SQL 조인과 유사하며 데이터 세트와 관련 정보를 결합하려는 경우에 유용합니다. 사용 사례 연결: 여러 달 또는 여러 해의 데이터를 동일한 열로 결합합니다. 병합: 공통 식별자를 가진 데이터 세트 통합(예: 고객 ID를 기반으로 판매 데이터와 고객 정보 병합) 2. 피벗(Pivot) 테이블로 데이터 재구성 피벗 테이블을 사용하여 더 나은 분석을 위해 데이터 재구성하는 데 능숙해집니다. DataFrame을 피벗 형태로 변환하여 정보를 요약하여 더 나은 인사이트를 얻을 수 있습니다: 12# Create a pivot tablepivot_table = df.pivot_table(index='Category', columns='Month', values='Value', aggfunc='sum') 설명 df.pivot_table()은 데이터를 재구성하여 요약 테이블을 생성합니다. 인덱스, 열, 값 및 집계 함수를 지정합니다. 이 예에서는 합계를 사용하여 각 'Category’와 ‘Month’ 조합에 대한 ‘Value’ 열을 요약합니다. 사용 사례 제품 카테고리 및 월별로 분류된 판매 데이터를 분석하여 추세를 파악합니다. 3. 범주형 데이터 처리 범주형 데이터를 효율적으로 관리하여 분석을 향상합니다. 원-핫(one-hot) 인코딩 및 범주형 데이터 유형 변환과 같은 기술을 배워보세요. 12# Convert a column to categorical typedf['Category'] = pd.Categorical(df['Category']) 12# Perform one-hot encodingdf_encoded = pd.get_dummies(df, columns=['Category']) 설명 열을 범주형 유형으로 변환(pd.Categorical())하면 고유 값이 제한된 열의 메모리 사용량이 최적화할 수 있습니다. 원-핫(one-hot) 인코딩(pd.get_dummies())은 범주형 변수를 이진 열로 변환하는 데 사용됩니다. 각 카테고리는 1과 0이 포함된 고유한 열을 갖게 됩니다. 사용 사례 ‘성별(Gender)’ 또는 '국가(Country)'와 같은 범주형 변수를 머신 러닝 알고리즘에 적합한 형식으로 변환합니다. 4. 시간 효율적인 문자열 작업 문자열 조작을 위한 Pandas의 다양한 기능을 살펴보세요. 문자열 작업을 효율적으로 적용하여 텍스트 데이터를 정리하고 변환하는 방법을 배워보세요. 12# Convert text to lowercasedf['Text_Column'] = df['Text_Column'].str.lower() 12# Extract information using regular expressionsdf['Extracted_Info'] = df['Text_Column'].str.extract(r'(\\d+)') 설명 str.lower()는 열의 모든 텍스트를 소문자로 변환하여 일관성을 유지합니다. str.extract()는 정규식을 사용하여 텍스트에서 특정 정보를 추출합니다. 사용 사례 비교하기 쉽도록 모든 텍스트를 소문자로 만들어 텍스트 데이터를 표준화합니다. 제품 설명에서 제품 ID를 추출하는 등 텍스트 열에서 숫자 정보를 추출합니다. 5. 날짜/시간 데이터 처리 기본적인 날짜/시간 작업을 넘어 고급 기술을 살펴보세요. 특정 구성 요소를 추출하고, 시차를 계산하고, 표준 시간대로 작업하는 방법을 배워보세요. 123# Extract month and year from a datetime columndf['Month'] = df['Date'].dt.monthdf['Year'] = df['Date'].dt.year 설명 dt.month 및 dt.year는 각각 월과 연도를 추출하는 날짜/시간 접근자(dt)의 속성입니다. 사용 사례 월별 또는 연도별 추세 분석과 같은 더 나은 시간 기반 분석을 위해 날짜/시간 데이터를 구성 요소로 세분화합니다. 6. 메모리 최적화 DataFrame의 메모리 사용량을 최적화하여 보다 효율적으로 처리하세요. 데이터 무결성을 손상시키지 않고 메모리 사용량을 줄이는 방법을 알아보세요. 12# 숫자 열을 더 작은 데이터 유형으로 다운캐스트(Downcast)하기df = df.apply(pd.to_numeric, downcast='integer') 설명 pd.to_numeric()은 열을 숫자 유형으로 변환합니다. downcast='integer'는 데이터에 맞는 가장 작은 정수 유형을 선택하여 메모리 사용량을 더욱 최적화합니다. 사용 사례 대규모 데이터 세트의 메모리 사용을 최적화하며, 특히 메모리에 않을 수 있는 데이터 세트로 작업할 때 유용합니다. 결론 이러한 고급 Pandas 기술은 데이터 조작 기술을 향상시켜 복잡한 시나리오에 대한 솔루션을 제공합니다. 주요 내용은 다음과 같습니다. 포괄적인 데이터 통합을 위해 DataFrame을 병합하고 연결합니다. 데이터 재구성을 위해 피벗 테이블의 기능을 활용합니다. 범주형 데이터를 효율적으로 처리하고 원-핫(one-hot) 인코딩을 수행합니다. 시간 효율적인 문자열 및 날짜/시간 작업을 마스터합니다. 대규모 데이터 세트의 메모리 사용량을 최적화합니다. 이러한 고급 기술을 적용하면 다양한 데이터 시나리오에서 Pandas를 정확하게 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","permalink":"http://hgko1207.github.io/tags/Pandas/"}]},{"title":"콘텐츠 작성을 위한 ChatGPT: 50가지 이상의 프롬프트 시도하기","slug":"chatgpt-6","date":"2024-01-13T07:03:54.000Z","updated":"2024-01-14T13:41:56.616Z","comments":true,"path":"2024/01/13/chatgpt-6/","link":"","permalink":"http://hgko1207.github.io/2024/01/13/chatgpt-6/","excerpt":"","text":"디지털 시대에는 AI 기술의 발전으로 콘텐츠 작성이 더욱 역동적이고 혁신적으로 변했습니다. 이러한 발전 가운데 ChatGPT는 콘텐츠 제작자를 위한 혁신적인 도구로 주목받고 있습니다. 다양한 글쓰기 요구 사항을 충족할 수 있는 다양한 프롬프트를 제공하는 획기적인 도구입니다. 이 글에서는 ChatGPT와 함께 콘텐츠 작성을 향상하는 데 사용할 수 있는 50개 이상의 프롬프트를 살펴보겠습니다. ChatGPT 이해하기 프롬프트를 살펴보기 전에 ChatGPT가 무엇인지 간략하게 살펴보겠습니다. OpenAI에서 개발한 ChatGPT는 수신된 입력을 바탕으로 사람과 유사한 텍스트를 이해하고 생성하도록 설계된 AI 언어 모델입니다. 기사 작성, 창의적인 아이디어 생성, 이메일 작성 등에 도움이 될 수 있습니다. 콘텐츠 작성을 위한 50가지 이상의 ChatGPT 프롬프트 모든 틈새시장에 맞는 다양하고 매력적인 프롬프트를 탐색하면서 창의력을 발휘하여 글쓰기 기술을 향상하세요. 톡톡 튀는 아이디어부터 문장을 다듬는 것까지, 콘텐츠 작성의 수준을 한 단계 끌어올릴 수 있는 영감의 세계를 발견하세요. 블로그 게시물 아이디어: 재생 에너지 트렌드에 관한 5개의 블로그 게시물 아이디어를 생성하세요. 기사 소개: 원격 근무가 생산성에 미치는 영향에 대한 기사 소개를 작성하세요. SEO 친화적인 콘텐츠: 건강한 식습관에 관한 SEO 최적화된 기사의 개요를 작성하세요. 이메일 캠페인: 젊은 기업가를 대상으로 하는 마케팅 캠페인의 이메일 초안을 작성하세요. 소셜 미디어 게시물: 여행사를 위한 매력적인 소셜 미디어 게시물 아이디어 5개를 제안하세요. 제품 설명: 친환경 물병에 대한 매력적인 제품 설명을 작성하세요. 면접 질문: 모바일 앱 개발자에게 면접에서 물어볼 10가지 질문을 나열하세요. 보도 자료: 새로운 온라인 강좌 플랫폼 출시에 대한 보도 자료를 작성하세요. 전자책(E-Book) 챕터: 마음챙김과 정신 건강에 관한 전자책의 첫 번째 장의 개요를 작성하세요. 동영상 대본 작성: 인터넷의 역사에 관한 YouTube 동영상의 대본을 작성하세요. 창의적 글쓰기: 시간 여행 모험에 관한 단편 소설을 작성하세요. 시와 노래: 봄의 아름다움에 대한 시를 창작하세요. 기술 글쓰기: 블록체인 기술을 간단한 쉬운 용어로 설명하세요. 사례 연구: 성공적인 디지털 마케팅 캠페인을 위한 사례 연구 개요 개요를 작성하세요. 사업 계획: 비건 카페의 사업 계획서 작성을 도와주세요. 웨비나 콘텐츠: 지속 가능한 삶에 대한 웨비나 주제를 제안해 주세요. 사용자 가이드 및 매뉴얼: 피트니스 트래킹 앱 사용에 대한 단계별 가이드를 작성하세요. 코스 커리큘럼: 그래픽 디자인 강좌의 커리큘럼 개요를 개발하세요. 연구 제안서: 소셜 미디어가 정신 건강에 미치는 영향에 대한 연구 제안서를 작성하세요. 도서 요약: Daniel Kahneman의 'Thinking, Fast and Slow’의 요점을 요약하세요. 팟캐스트(Podcast) 스크립트: 기업가 정신에 관한 팟캐스트의 첫 번째 에피소드에 대한 대본 초안을 작성하세요. 퀴즈 및 설문조사: 디지털 마케팅 기술을 평가하는 퀴즈를 디자인하세요. 랜딩 페이지 카피: 새로운 마음챙김 앱에 대한 랜딩 페이지의 매력적인 문구를 작성하세요. 브로셔 콘텐츠: 웰니스 휴양지를 홍보하는 브로셔 콘텐츠를 개발하세요. 인포그래픽 텍스트: 재생 에너지원에 대한 인포그래픽의 텍스트를 작성하세요. 법률 문서: 새로운 모바일 앱의 서비스 약관 문서 초안을 작성하세요. 연설문 작성: 최근 대학을 졸업한 신입사원을 위한 동기 부여 연설문 작성하기. FAQ 섹션: 유기농 원예에 관한 웹사이트에 대한 FAQ를 생성하세요. 서평: James Clear의 ‘Atomic Habits’ 책에 대한 리뷰를 작성하세요. 뉴스 기사: AI(인공지능) 기술의 최신 발전에 관한 뉴스 기사 초안을 작성하세요. 여행 가이드: 주말 파리 여행을 위한 여행 가이드를 작성하세요. 피트니스 및 건강 팁: 더 건강한 라이프스타일을 위한 10가지 일상 습관을 나열하세요. 어린이를 위한 교육 콘텐츠: 어린이를 위한 물 순환에 대한 짧은 교육용 글을 작성하세요. 패션 및 라이프스타일 기사: 지속 가능한 패션 트렌드에 대한 기사 아이디어를 제안하세요. 부동산 목록: 해변 부동산에 대한 목록 설명을 작성하세요. 레시피 작성: 비건 초콜릿 케이크의 레시피를 작성하세요. 자기계발 조언: 시간 관리와 생산성에 대한 조언을 해주세요. 전기: Elon Musk의 짧은 전기를 써주세요. 이벤트 설명: 가상 기술 컨퍼런스에 대한 설명 초안을 작성하세요. 마케팅 전략: 새로운 피트니스 앱을 위한 마케팅 전략의 개요를 작성하세요. 자동차 리뷰: 최신 전기 자동차 모델에 대한 리뷰를 작성하세요. 건강 관리 기사: 정신 건강 인식에 관한 블로그의 주제를 제안하세요. 재무 계획 팁: 효과적인 개인 예산 책정을 위한 팁을 나열하세요. 기술 튜토리얼: 스마트 홈 시스템 설정에 대한 튜토리얼을 작성하세요. 문화 논평: 소셜 미디어가 현대 커뮤니케이션에 미치는 영향에 대해 토론하세요. ​​환경 인식 콘텐츠: 재활용을 장려하는 캠페인을 위한 콘텐츠를 개발하세요. ​유머와 엔터테인먼트:​ 원격 근무의 특이한 점에 대해 유머러스한 글을 작성하세요. ​동기 부여 콘텐츠:​ 팀 빌딩을 위한 일일 동기부여 메시지를 작성하세요. ​역사적 기사:​ 르네상스 시대의 중요성에 관한 기사 초안을 작성하세요. ​지속 가능성 관행:​ 중소기업을 위한 지속 가능한 관행에 대해 글을 작성하세요. ​DIY 및 공예 지침:​ 새집 만들기 위한 단계별 지침을 제공하세요. ​양 가이드:​ 운동선수를 위한 다량 영양소 균형에 대한 가이드를 만드세요. ​육아 조언:​ 부모를 위한 자녀의 화면 시간 관리에 대한 조언을 제공하세요. ​원예 가이드:​ 텃밭을 시작하기 위한 초보자 가이드를 작성하세요. ​사진 촬영 팁:​ 더 나은 풍경 사진을 찍기 위한 5가지 팁을 나열하세요. 간소화된 콘텐츠 생성을 위한 ChatGPT ChatGPT는 글쓰기 과정을 간소화할 뿐만 아니라 창의력에도 영감을 줍니다.콘텐츠에 대화적 관점을 제공하는 ‘AI 채팅’ 역할을 할 수 있습니다 . 이 도구는 아이디어를 브레인스토밍하거나 다양한 관점을 모색할 때 특히 유용합니다. ChatGPT 활용 극대화하기 콘텐츠 작성에 ChatGPT를 최대한 활용하려면 다음과 같이 하세요. 구체적으로 작성하세요: 프롬프트가 구체적일수록 응답이 더욱 맞춤화되고 유용해집니다. 반복하세요: 받은 응답에 따라 주저하지 말고 프롬프트를 다듬거나 문구를 바꾸세요. 프롬프트 결합하기: 때로는 두 개 이상의 프롬프트를 결합하면 더 포괄적인 콘텐츠를 만들 수 있습니다. 창의성을 발휘하세요: ChatGPT를 출발점으로 삼아 창의력을 발휘하고 개성을 더하세요. 결론 ChatGPT는 콘텐츠 크리에이터에게 폭넓은 가능성을 제공하여 글쓰기를 보다 쉽게 ​​접근할 수 있고 효율적이며 창의적으로 만들어줍니다. 숙련된 작가든 이제 막 시작하는 작가든, 50개 이상의 프롬프트는 콘텐츠 지평을 탐색하고 확장할 수 있는 탄탄한 기반을 제공합니다. AI의 힘을 활용하고 ChatGPT로 콘텐츠 작성 프로세스를 혁신하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"콘텐츠","slug":"콘텐츠","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0/"}]},{"title":"ChatGPT로 파이썬을 처음부터 빠르게 배우는 방법","slug":"chatgpt-5","date":"2024-01-12T14:19:41.000Z","updated":"2024-01-12T14:37:43.938Z","comments":true,"path":"2024/01/12/chatgpt-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/12/chatgpt-5/","excerpt":"","text":"Chat GPT와 같은 챗봇이 등장하면서 많은 사람들이 인공지능 비서가 효과적인 교사가 될 수 있는지 궁금해하고 있습니다. 이 글에서는 완전 초보자로서 ChatGPT를 사용하여 Python을 배우는 방법에 알아보겠습니다. 1. 기초부터 시작하세요. 새로운 프로그래밍 언어를 배울 때는 기초부터 시작하는 것이 중요합니다. ChatGpt에 다음과 같은 질문을 할 것입니다. Python의 기본 데이터 유형은 무엇인가요? 변수를 할당하고 문자열을 print 하려면 어떻게 해야 하나요? Python에서 list, tuple, dictionary이란 무엇인가요? if/else와 같은 조건문을 어떻게 작성하나요? for 및 while 루프를 어떻게 구성하나요? 더 깊이 들어가기 전에 기본 구성 요소에 익숙해지는 것이 목표입니다. ChatGpt는 간단한 코드 예제와 개념에 대한 명확한 설명을 제공할 수 있습니다. 2. 간단한 프로그램 작성하기 기본 사항을 숙지한 후에는 배운 내용을 적용하기 위해 간단한 프로그램을 작성하기 시작합니다. ChatGPT에서 도움을 받을 수 있는 몇 가지 아이디어는 다음과 같습니다. 섭씨를 화씨로 변환하는 프로그램 목록에서 가장 큰 숫자를 찾는 스크립트 Mad Libs 단어 게임 텍스트 기반 계산기 숫자 맞추기 게임 미니 프로그램을 작성하면 새로운 구문을 익히고 개념을 연결하는 데 도움이 됩니다. ChatGpt에 시작 코드를 제공해 달라고 요청하고 예제를 통해 안내해 달라고 요청합니다. 3. 주요 라이브러리 배우기 Python의 핵심 기능에 대한 경험을 쌓은 후에는 데이터 과학자와 개발자가 사용하는 인기 있는 라이브러리를 배웁니다. 주요 라이브러리는 다음과 같습니다. 수치 계산을 위한 Numpy 데이터 분석을 위한 Pandas 데이터 시각화를 위한 Matplotlib 각 라이브러리에 대한 개요, 실제 예제, 적용을 위한 연습 문제를 ChatGpt에 요청합니다. 이러한 라이브러리를 사용하여 프로젝트를 구축하면 고급 Python 작업에 대비할 수 있습니다. 4. 프로젝트 아이디어 발굴하기 Python의 기초가 탄탄해지면 ChatGpt를 활용하여 기술 수준을 높이기 위해 구축할 수 있는 프로젝트 아이디어를 생성합니다. 영감을 얻기 위해 다음과 같이 질문합니다. Pandas와 Matplotlib를 사용하는 초보자 Python 프로젝트에는 어떤 것이 있나요? Python 숙련도를 입증할 수 있는 중급 코딩 프로젝트 아이디어를 제공해 주실 수 있나요? ChatGPT는 날씨 대시보드, 2D 게임, 데이터 분석 웹 앱과 같이 내 능력에 맞는 아이디어를 제공할 수 있습니다. 이러한 프로젝트를 구현하면 귀중한 실무 경험을 쌓을 수 있습니다. 결론 코딩을 배우는 데는 시간과 연습이 필요하지만 ChatGpt와 같은 AI 비서는 맞춤형 예제, 설명 및 프로젝트 아이디어를 제공함으로써 그 과정을 가속화할 수 있습니다. 실습 코딩을 대체할 수는 없지만, ChatGpt는 Python의 기초을 익히고 새로운 개념을 탐구하는 데 훌륭한 보조 도구입니다. 약간의 창의력만 있다면, 호기심 많은 초보자도 ChatGpt를 활용하여 Python 코딩 여정을 시작할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}]},{"title":"소프트웨어 개발의 미래로서의 DevOps","slug":"info-8","date":"2024-01-10T01:22:16.000Z","updated":"2024-01-12T14:22:10.046Z","comments":true,"path":"2024/01/10/info-8/","link":"","permalink":"http://hgko1207.github.io/2024/01/10/info-8/","excerpt":"","text":"최근 몇 년 동안 소프트웨어 개발 환경은 DevOps로 알려진 보다 협업적이고 효율적인 접근 방식으로 크게 변화하고 있습니다. &quot;development&quot;과 &quot;operations&quot;이 융합된 DevOps는 소프트웨어 개발자와 IT 운영팀 간의 통합과 협업을 강조합니다. 이 글에서는 DevOps의 인기가 높아지는 이유와 소프트웨어 개발의 미래를 바꿀 수 있는 잠재력에 대해 살펴봅니다. 속도에 대한 필요성 기존 소프트웨어 개발 방법론은 느리고 번거로운 프로세스로 인해 어려움을 겪는 경우가 많았습니다. 이러한 문제를 해결하기 위해 등장한 DevOps는 소프트웨어 개발 라이프사이클을 간소화하고 가속화하는 것을 목표로 합니다. DevOps는 개발, 테스트, 배포 및 운영을 원활한 워크플로우로 결합하여 소프트웨어 제품의 출시 기간을 단축하고 점점 증가하는 디지털 시대의 요구 사항을 충족합니다. 지속적인 통합 및 지속적인 배포(CI/CD) DevOps는 소프트웨어 변경 사항이 지속적으로 통합, 테스트 및 배포하는 CI/CD 방식의 채택을 권장합니다. 자동화를 핵심으로 하는 CI/CD 파이프라인을 통해 개발자는 새로운 기능과 버그 수정을 더 자주 그리고 안정적으로 제공할 수 있습니다. 이러한 반복적인 접근 방식은 소프트웨어 품질을 향상시키고 결함의 위험을 줄이며 조직이 고객 피드백에 신속하게 대응할 수 있도록 지원합니다. 협업과 커뮤니케이션 DevOps의 핵심 원칙 중 하나는 개발팀과 운영팀 간의 사일로를 허무는 것입니다. DevOps는 협업과 커뮤니케이션을 촉진함으로써 공동 책임과 상호 이해의 문화를 조성합니다. 개발자는 코드의 운영 측면에 대한 통찰력을 얻고 운영팀은 개발 프로세스에 대한 가시성을 얻습니다. 이러한 협업을 통해 효율성이 향상되고 오류가 줄어들며 비즈니스 목표에 더 잘 부합하게 됩니다. 사일로효과 조직의 부서들이 서로 다른 부서와는 교류하지 않고, 자기 부서의 이익만을 추구하는 현상을 빗댄 말. 경영학에서 주로 사용하는 부서 이기주의를 표현하는 용어이다. 자동화 및 IaC(Infrastructure as Code) 자동화는 DevOps에서 중요한 역할을 하며, 조직이 복잡한 소프트웨어 시스템을 쉽게 관리할 수 있도록 해줍니다. IaC(코드형 인프라)를 사용하면 개발자는 인프라 구성을 버전 제어 아티팩트로 처리하여 인프라 리소스를 프로그래밍 방식으로 정의하고 프로비저닝할 수 있습니다. 자동화를 통해 수동 오류를 제거하고 일관성을 보장하며 변화하는 비즈니스 요구 사항을 충족하기 위해 인프라를 신속하게 확장할 수 있습니다. 클라우드 기술 수용 클라우드 컴퓨팅은 소프트웨어 개발 및 배포 방식에 혁신을 가져왔습니다. DevOps는 클라우드 기술을 활용하여 확장 가능하고 유연하며 비용 효율적인 환경을 만듭니다. 클라우드 플랫폼은 자동 확장, 컨테이너화, 서버리스 컴퓨팅과 같은 DevOps 방식을 지원하는 데 필요한 인프라, 도구 및 서비스를 제공합니다. 클라우드의 힘을 활용함으로써 조직은 하드웨어와 인프라를 관리하는 대신 고객에게 가치를 제공하는 데 집중할 수 있습니다. 안정성과 복원력 향상 DevOps는 소프트웨어 시스템의 안정성과 복원력을 보장하는 데 중점을 둡니다. 지속적인 모니터링, 자동화된 테스트 및 사전 오류 감지를 통해 조직은 개발 주기 초기에 문제를 식별하고 해결할 수 있습니다. DevOps는 내결함성, 점진적 성능 저하, 재해 복구 계획과 같은 기술을 사용하여 강력하고 가용성이 높은 애플리케이션을 구축하는 데 도움을 줍니다. 이러한 안정성에 대한 집중은 고객의 신뢰와 충성도를 높여줍니다. 민첩하고 반복적인 개발 DevOps는 유연성, 적응성 및 고객 협업을 강조하는 Agile 방법론과 잘 맞습니다. Agile 방식을 DevOps와 통합함으로써 조직은 변화하는 고객 요구와 시장의 역학 관계에 신속하게 대응할 수 있습니다. 지속적인 피드백 루프의 지원을 받는 반복적인 개발 주기를 통해 팀은 소프트웨어를 지속적으로 개선하여 빠르게 변화하는 환경에서 관련성과 가치를 유지할 수 있습니다. 보안 및 규정 준수 개선 사이버 위협이 증가함에 따라 보안은 소프트웨어 개발에 있어서 가장 중요한 관심사가 되었습니다. DevOps는 개발 프로세스 전반에 걸쳐 보안 및 규정 준수 관행을 통합하여 이러한 문제를 해결합니다. DevOps를 확장한 DevSecOps는 소프트웨어 배포의 모든 단계에 보안 원칙과 프로세스를 통합합니다. 처음부터 보안 조치를 포함함으로써 조직은 개발 속도를 유지하면서 안전하고 규정을 준수하는 소프트웨어 시스템을 구축할 수 있습니다. 결론 디지털 환경이 계속 발전함에 따라 DevOps는 소프트웨어 개발에 대한 혁신적인 접근 방식으로 등장했습니다. DevOps는 협업, 자동화 및 지속적인 개선을 촉진함으로써 개발 속도, 안정성 및 보안을 향상시킵니다. DevOps 방식을 도입하면 조직이 최신 소프트웨어 개발 라이프사이클의 과제를 극복하고 고객 기대에 부응하는 고품질 소프트웨어 제품을 제공할 수 있습니다. 미래를 내다보면 DevOps는 소프트웨어 개발 산업을 형성하고 디지털 시대의 혁신을 주도하는 데 중추적인 역할을 할 것입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"DevOps","slug":"DevOps","permalink":"http://hgko1207.github.io/tags/DevOps/"},{"name":"Software Development","slug":"Software-Development","permalink":"http://hgko1207.github.io/tags/Software-Development/"}]},{"title":"ChatGPT를 최대한 활용하는 방법: 10가지 팁과 요령","slug":"chatgpt-4","date":"2024-01-09T13:32:00.000Z","updated":"2024-01-09T13:32:25.183Z","comments":true,"path":"2024/01/09/chatgpt-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/09/chatgpt-4/","excerpt":"","text":"ChatGPT는 사용자가 입력하는 프롬프트에 따라 텍스트를 생성할 수 있는 AI 언어 모델입니다. 아이디어를 생성하고, 텍스트를 요약하고, 심지어 언어를 번역하는 데 도움이 되는 강력한 도구입니다. 이 글에서는 ChatGPT를 최대한 활용하기 위한 10가지 팁과 요령을 살펴보겠습니다. 1) 직원처럼 대화하세요. ChatGPT의 가장 큰 장점 중 하나는 자연어를 이해할 수 있다는 것입니다. 즉, 사람과 대화할 때와 같은 방식으로 질문하고 요청할 수 있습니다. 예를 들어, &quot;개에 관한 텍스트를 생성하세요&quot;라고 말하는 대신 &quot;개에 대한 기사를 작성해줄 수 있어?&quot;라고 말할 수 있습니다. generate text about dogs -&gt; can you write an article about dogs? 2) 다양한 프롬프트로 실험해 보세요. ChatGPT는 사용자가 입력하는 프롬프트에 따라 텍스트를 생성하도록 설계되었습니다. 따라서 원하는 결과가 나오지 않는다면 다양한 프롬프트를 사용해 실험해 보세요. 예를 들어, &quot;고양이에 관한 이야기를 써주세요&quot;라고 말하는 대신 &quot;고양이에 대한 이야기를 들려줄 수 있나요?&quot;라고 말할 수 있습니다. write a story about a cat -&gt; can you tell me a story about a cat? 3) 맥락을 제공하세요 ChatGPT에 더 많은 컨텍스트를 제공할수록 사용자가 요청하는 내용을 더 잘 이해할 수 있습니다. 예를 들어, &quot;자동차에 관한 기사를 작성해 주세요&quot;라고 말하는 대신 &quot;전기 자동차와 그것이 환경에 미치는 영향에 대한 기사를 작성해 주실 수 있나요?&quot;라고 말할 수 있습니다. write an article about cars -&gt; can you write an article about electric cars and their impact on the environment? 4) 일괄 처리 한 번에 많은 양의 텍스트를 생성하는 경우 더 작은 배치로 배치로 나누어 작성하는 것이 좋습니다. 이렇게 하면 ChatGPT에 과부하가 걸리지 않고 고품질의 텍스트를 생성할 수 있습니다. 예를 들어, ChatGPT에 책 전체를 작성하도록 요청하는 대신 한 번에 한 장씩 작성하도록 요청할 수 있습니다. 5) 더 짧은 텍스트 프롬프트를 사용하세요. 짧은 프롬프트가 긴 프롬프트보다 더 잘 작동하는 경향이 있습니다. 이는 ChatGPT가 사용자의 프롬프트에 따라 짧은 텍스트를 생성하도록 설계되었기 때문입니다. 예를 들어, &quot;기후 변화에 관한 10페이지 분량의 보고서를 작성하세요&quot;라고 말하는 대신 &quot;기후 변화의 영향을 한 문단으로 요약해 주시겠습니까?&quot;라고 말할 수 있습니다. write a 10-page report on climate change -&gt; can you summarize the impact of climate change in one paragraph? 6) ChatGPT의 요약 기능을 활용하세요. 요약이 필요한 텍스트가 있다면 ChatGPT가 도움이 될 수 있습니다. 예를 들어, 특정 주제에 대한 기사 전체를 읽는 대신 ChatGPT에게 요약해 달라고 요청할 수 있습니다. 7) 번역에 ChatGPT를 사용하세요. ChatGPT는 한 언어에서 다른 언어로 텍스트를 번역하는 데 도움을 줄 수 있습니다. 예를 들어 이메일을 영어에서 스페인어로 번역해야 하는 경우 ChatGPT에 도움을 요청할 수 있습니다. 8) ChatGPT를 사용하여 아이디어를 창출하세요. 문제가 막혔거나 영감이 필요할 때 ChatGPT를 사용하여 아이디어를 생각해 보세요. 예를 들어, 신제품에 대한 아이디어를 얻으려는 경우 ChatGPT에 제안을 요청할 수 있습니다. 9) 단어 제한을 우회하려면 &quot;계속&quot;과 같은 간단한 프롬프트를 사용하세요. ChatGPT는 텍스트를 생성할 때 단어 수 제한이 있습니다. 이 제한을 우회하려면 “계속하기(go on)”, “계속 진행(keep going)” 또는 &quot;계속(continue)&quot;과 같은 간단한 프롬프트를 사용하세요. 예를 들어 ChatGPT가 500단어 이후에 텍스트 생성을 중지하는 경우 &quot;계속 진행&quot;이라고 말하면 더 많은 텍스트를 얻을 수 있습니다. 10) 인내심을 갖고 끈기 있게 기다리세요! ChatGPT는 여전히 매일 학습하고 개선되고 있으므로 항상 원하는 결과를 바로 나오지 않더라도 낙심하지 마세요. 원하는 결과를 얻을 때까지 다양한 프롬프트를 계속 실험하고 상황에 맞는 정보를 제공하세요. 결론 ChatGPT는 고품질 텍스트를 빠르고 쉽게 생성하는 데 도움이 되는 강력한 도구입니다. 이 10가지 팁과 요령을 따르면 ChatGPT를 최대한 활용하고 원하는 결과를 얻을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"}]},{"title":"한 줄로 완성하는 최신 CSS 레이아웃 10가지","slug":"web-design-5","date":"2024-01-08T00:53:46.000Z","updated":"2024-01-12T14:22:21.535Z","comments":true,"path":"2024/01/08/web-design-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/08/web-design-5/","excerpt":"","text":"소개 역동적인 웹 개발 세계에서 CSS는 웹사이트의 시각적 매력을 형성하는 데 중요한 역할을 합니다. 수년에 걸쳐 개발자들은 레이아웃을 효율적으로 효율적으로 만들 수 있는 혁신적인 방법을 고안해 왔습니다. 이 글에서는 각각 단 한 줄의 코드로 구현할 수 있는 10가지 최신 CSS 레이아웃을 살펴보겠습니다.이러한 간결한 솔루션은 시간을 절약할 뿐만 아니라 CSS(Cascading Style Sheets)의 강력한 성능과 유연성을 보여줍니다. 1) Flexbox Centering 12345.container &#123; display: flex; justify-content: center; align-items: center;&#125; 2) Grid Centering 1234.container &#123; display: grid; place-items: center;&#125; 3) 전체 페이지 이미지 배경 123body &#123; background: url('image.jpg') center/cover no-repeat;&#125; 4) 반응형 Square 123.square &#123; aspect-ratio: 1/1;&#125; 5) 고정 바닥글 123456789body &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125; 6) 같은 너비의 열(Column) 123.column &#123; flex: 1;&#125; 7) 원형 요소(Element) 123.circle &#123; border-radius: 50%;&#125; 8) 유동적인 타이포그래피(Typography) 123body &#123; font-size: calc(1rem + 1vw);&#125; 9) Multi-column Text 1234.text &#123; column-count: 3; column-gap: 1rem;&#125; 10) 반응형 Square Grid 12345.grid &#123; display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem;&#125; 결론 모던하고 반응이 빠른 웹 디자인을 제작하려면 CSS 레이아웃 기술을 숙지하는 것이 필수적입니다. 이 한 줄짜리 솔루션은 CSS가 프로젝트에 가져올 수 있는 우아함과 단순함을 보여줍니다. 이러한 스니펫(Snippets)을 실험해보고 필요에 맞게 조정하여 최소한의 코드로 최대의 효과를 내면서 웹 개발의 수준을 높여보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"C#에서 String과 string의 차이점 이해하기","slug":"csharp-7","date":"2024-01-07T07:47:47.000Z","updated":"2024-01-07T14:18:46.094Z","comments":true,"path":"2024/01/07/csharp-7/","link":"","permalink":"http://hgko1207.github.io/2024/01/07/csharp-7/","excerpt":"","text":"C#은 강력한 형식의 프로그래밍 언어입니다. 효과적인 C# 코드를 작성하려면 데이터 형식을 아는 것이 필수적입니다. C#에서 가장 자주 사용되는 데이터 유형 중 하나는 문자열 유형으로 String, string로 선언할 수 있습니다. 이로 인해 약간의 혼동이 발생할 수 있습니다. String과 string의 차이점은 무엇이며, 언제 각각을 사용해야 할까요? 이 글에서는 이 두 가지 유형을 자세히 살펴보고 유사점과 차이점을 이해하고 어느 쪽을 더 선호할 수 있는 몇 가지 시나리오를 살펴보겠습니다. String과 string은 무엇입니까? String String 클래스는 시스템 네임스페이스(System.String)의 일부입니다. Substring, Concat, Replace 등과 같은 문자열 조작을 위한 다양한 메소드를 제공하는 클래스입니다. 다음과 같이 사용할 수 있습니다. 12345678910111213using System;namespace StringExample&#123; class Program &#123; static void Main(string[] args) &#123; String name = \"HyeongGyun\"; Console.WriteLine(name.ToLower()); // \"hyeonggyun\" &#125; &#125;&#125; string 반면에 string은 C# 언어의 String의 별칭입니다. 문자열 변수를 선언하는 더 읽기 쉬운 방법이며 구문상 더 간단합니다. string은 단순히 System.String의 약어입니다. 1234567891011namespace StringExample&#123; class Program &#123; static void Main(string[] args) &#123; string name = \"HyeongGyun\"; Console.WriteLine(name.ToLower()); // \"hyeonggyun\" &#125; &#125;&#125; 유사점 상호 교환 가능: String과 string을 문제없이 바꿔서 사용할 수 있습니다. 12345String name1 = \"Ko\";string name2 = \"HyeongGyun\";// perfectly validstring fullName = name1 + \" \" + name2; 동일한 메서드: string은 System.String의 별칭일 뿐이므로 둘 모두에 동일한 메서드를 사용할 수 있습니다. 12345String name1 = \"Ko\";string name2 = \"HyeongGyun\";Console.WriteLine(name1.ToLower());Console.WriteLine(name2.ToUpper()); 차이점 기능적으로는 동일하지만 언제 어느 쪽을 사용해야 하는지에 대한 몇 가지 모범 사례가 있습니다. 가독성: 많은 개발자들은 string 사용하는 것이 int, bool, double과 같은 다른 단순한 유형과 잘 어울리기 때문에 가독성이 더 높다고 생각합니다. Namespacing: using System;을 사용하여 선언한 경우 문제없이 String을 사용할 수 있습니다. 그렇지 않으면 System.String으로 사용해야 합니다. 표준화: 대부분의 C# 코딩 표준에서는 지역 변수 및 메서드 매개 변수에 대해 string보다 String을 사용할 것을 권장합니다. 반환(return) 유형의 경우 둘 다 사용할 수 있지만 일반적으로 일관성을 유지하는 것이 좋습니다. String과 string 사용 시기 String 정적 메서드(Static Method)로 작업하기: String 클래스의 정적 메서드를 사용할 때는 String을 사용하는 것이 좋습니다. 12String.Concat(\"Hello, \", \"world!\");String.Format(\"&#123;0&#125; &#123;1&#125;\", var1, var2); 정규화된 이름 필요: 네임스페이스가 문제가 되는 환경에서 작업하는 경우(매우 드물지만) System.String을 지정해야 할 수 있습니다. string 지역 변수 및 매개변수: 로컬 변수 선언과 메서드 매개변수 유형에는 string을 사용하는 것이 일반적입니다. 12345public void SayHello(string name)&#123; string greeting = \"Hello, \" + name; Console.WriteLine(greeting);&#125; ** 가독성:** string을 사용하면 다른 기본 제공 유형(int, bool 등)을 사용할 때와 코드의 일관성을 유지할 수 있습니다. 결론 C#의 String과 string 유형은 기능적으로 동일하지만 둘 중 하나를 선택할 때 고려해야 할 몇 가지 미묘한 모범 사례가 있습니다. 대부분의 개발자는 로컬 변수 및 매개변수에는 string을 사용하고 정적 메서드 호출에는 String을 사용하면 코드를 가독성 있고 일관성 있게 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"String","slug":"String","permalink":"http://hgko1207.github.io/tags/String/"},{"name":"string","slug":"string","permalink":"http://hgko1207.github.io/tags/string/"}]},{"title":"Vue.js 애플리케이션 개발을 위한 모범 사례","slug":"vue-4","date":"2024-01-05T02:23:02.000Z","updated":"2024-01-12T14:22:24.853Z","comments":true,"path":"2024/01/05/vue-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/05/vue-4/","excerpt":"","text":"Vue.js는 웹 애플리케이션 개발에 사용되는 널리 사용되는 자바스크립트 프레임워크입니다. 간단하고 적응 가능하며 확장성이 뛰어난 것으로 유명합니다. 그러나 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션을 개발하는 것은 어려울 수 있습니다. 이 글에서는 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션 개발을 위한 모범 사례에 대해 설명합니다. 모듈식 접근 방식 따르기 확장 가능하고 유지 관리 가능한 Vue.js 애플리케이션을 개발하기 위한 가장 중요한 모범 사례 중 하나는 모듈식 접근 방식을 따르는 것입니다. 이를 위해서는 애플리케이션을 보다 관리하기 쉽고 재사용 가능한 컴포넌트로 나누십시오. 각 컴포넌트에는 단일 책임이 있어야 이해하고 유지 관리하기 쉽습니다. 모듈식 접근 방식을 따르면 복잡한 Vue.js 애플리케이션을 더 쉽게 개발하고 유지 관리할 수 있습니다. 이를 통해 애플리케이션을 더 작고 관리하기 쉬운 부분으로 나눌 수 있으므로 문제를 더 쉽게 디버깅하고 해결할 수 있습니다. 또한 모듈화를 사용하면 테스트하기 쉬운 코드를 작성할 수 있으므로 오류가 줄어들고 성능이 향상될 수 있습니다. 애플리케이션을 더 작은 컴포넌트로 나누면 다른 개발자와 더 쉽게 협업할 수 있습니다. 애플리케이션을 모듈로 나누면 개별 개발자에게 특정 모듈을 할당할 수 있어 협업이 더 쉬워지고 충돌을 피할 수 있습니다. 상태 관리에 Vuex 사용 Vue.js 앱의 상태 관리 라이브러리를 Vuex라고 합니다. 이를 통해 중앙 집중식 저장소에서 애플리케이션 상태를 관리할 수 있습니다. 이는 문제를 깔끔하게 분리하고 예측 가능한 방식으로 애플리케이션 상태를 관리할 수 있도록 해줍니다. Vuex를 사용하면 애플리케이션의 상태 관리를 중앙 집중화하여 관리 및 업데이트를 더 쉽게 만들 수 있습니다. 이렇게 하면 여러 컴포넌트가 동일한 상태를 관리하려고 할 때 발생하는 일반적인 문제를 방지할 수 있습니다. 또한 Vuex는 문제를 깔끔하게 분리하여 애플리케이션을 더 쉽게 유지 관리하고 버그 위험을 줄일 수 있습니다. Vuex를 사용하면 애플리케이션 성능을 최적화하는 데에도 도움이 될 수 있습니다. 중앙 집중식 저장소에서 상태를 관리하면 중복 계산 및 업데이트를 방지하여 더 빠르고 효율적인 코드를 만들 수 있습니다. 탐색에 Vue Router 사용 Vue.js 앱의 표준 라우터를 Vue Router라고 합니다. 이를 통해 선언적 방식으로 애플리케이션의 탐색을 관리할 수 있습니다. 애플리케이션의 탐색을 일관되게 관리할 수 있는 방법을 제공하며 새 경로를 쉽게 추가할 수 있습니다. Vue Router를 사용하면 애플리케이션을 더 쉽게 탐색할 수 있습니다. Vue Router는 애플리케이션의 탐색을 관리하는 선언적 방법을 제공하므로 이해하고 유지 관리하기가 더 쉽습니다. 또한 Vue Router는 애플리케이션 전반에 걸쳐 일관된 사용자 경험을 만들어 사용자 만족도를 높이고 혼란을 줄일 수 있습니다. Vue Router는 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 지연 로딩을 사용하면 특정 경로에 필요한 컴포넌트만 로드할 수 있으므로 로드되는 불필요한 코드의 양이 줄어듭니다. 따라서 로드 시간이 빨라지고 전반적으로 성능이 향상될 수 있습니다. 모듈 번들링에 Webpack 사용 Webpack은 자바스크립트 애플리케이션을 위한 모듈 번들러입니다. 이를 통해 애플리케이션의 모듈을 단일 파일로 묶을 수 있습니다. 애플리케이션의 종속성을 깔끔하게 관리할 수 있는 방법을 제공하며 애플리케이션의 성능을 쉽게 최적화할 수 있습니다. Webpack을 사용하면 애플리케이션의 종속성 관리를 단순화할 수 있습니다. Webpack을 사용하면 애플리케이션의 모든 모듈을 단일 파일로 묶을 수 있으므로 관리 및 유지보수가 더 쉬워집니다. 또한 Webpack은 최종 파일의 크기를 최소화하여 애플리케이션 성능을 최적화하는 방법을 제공합니다. Webpack은 또한 코드를 모듈화하여 관리 및 유지보수를 더 쉽게 만드는 데 도움이 될 수 있습니다. 애플리케이션을 더 작고 재사용 가능한 컴포넌트로 분할하면 코드를 더 쉽게 개발하고 테스트할 수 있습니다. 또한 Webpack을 사용하면 다양한 플러그인과 로더를 활용할 수 있어 애플리케이션 빌드 프로세스를 더욱 유연하게 제어할 수 있습니다. 코드 품질을 위한 ESLint 사용 ESLint는 자바스크립트 애플리케이션을 위한 코드 품질 도구입니다. 이를 통해 일관된 코딩 표준을 적용하고 코드의 잠재적인 문제를 감지할 수 있습니다. 코드의 일관성, 가독성 및 일반적인 오류가 없는지 확인할 수 있는 방법을 제공합니다. ESLint를 사용하면 팀 전체에 코딩 표준을 적용할 수 있으므로 일관된 코드베이스를 더 쉽게 유지할 수 있습니다. 또한 ESLint는 사용되지 않는 변수나 정의되지 않은 함수 등 코드에서 잠재적인 문제를 감지하는 데 도움이 됩니다. 이를 통해 큰 문제가 되기 전에 잠재적인 오류를 잡아낼 수 있습니다. ESLint는 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 불필요한 코드나 최적화되지 않은 코드 등 잠재적인 성능 문제를 감지하여 애플리케이션을 더 빠르고 효율적으로 실행할 수 있습니다. 단위 테스트 작성 단위 테스트를 사용하면 애플리케이션의 개별 컴포넌트를 개별적으로 테스트하여 예상대로 작동하는지 확인할 수 있습니다. 단위 테스트를 작성하면 개발 프로세스 초기에 잠재적인 문제를 파악하여 심각한 문제가 발생하기 전에 문제를 쉽게 해결할 수 있습니다. 단위 테스트를 애플리케이션을 변경하거나 새로운 기능을 추가할 때에도 애플리케이션이 예상대로 작동하는지 확인할 수 있습니다. 또한 단위 테스트는 잠재적인 회귀를 파악하여 애플리케이션의 한 부분을 변경해도 다른 부분이 손상되지 않도록 하는 데 도움이 될 수 있습니다. 단위 테스트는 애플리케이션 성능을 최적화하는 데에도 도움이 됩니다. 잠재적인 성능 문제를 조기에 감지하면 코드를 변경함으로써 애플리케이션이 최대한 효율적으로 실행되도록 할 수 있습니다. 비동기 컴포넌트 사용 비동기 컴포넌트를 사용하면 컴포넌트를 한꺼번에 로드하지 않고 필요할 때만 로드할 수 있습니다. 이는 애플리케이션의 초기 로드 시간을 줄이고 전반적인 성능을 개선하는 데 도움이 될 수 있습니다. 비동기 컴포넌트를 사용하면 애플리케이션을 더 빠르고 효율적으로 실행할 수 있습니다. 모든 컴포넌트를 한 번에 로드하는 것이 아니라 필요할 때만 로드할 수 있어 불필요한 코드 로드량이 줄어듭니다. 이는 애플리케이션의 전반적인 성능을 개선하여 응답성이 향상되고 사용자 친화적인 애플리케이션을 만드는 데 도움이 됩니다. 또한 비동기 컴포넌트를 사용하면 코드를 모듈화하여 유지 관리와 이해가 쉬워집니다. 애플리케이션을 더 작고 재사용 가능한 컴포넌트로 분할하면 코드를 더 쉽게 개발하고 테스트할 수 있습니다. CSS 전처리기 사용 CSS 전처리기를 사용하면 표준 CSS에서 사용할 수 없는 변수, 함수 및 기타 기능을 사용하여 CSS를 작성할 수 있습니다. 이를 통해 CSS를 더 읽기 쉽고 유지 관리하기 쉽게 만들고 오류 위험을 줄이고 변경을 더 쉽게 만드는 데 도움이 됩니다. CSS 전처리기를 사용하면 CSS를 더욱 모듈화하여 애플리케이션 전체에서 코드를 더 쉽게 재사용할 수 있습니다. 또한 전처리기를 사용하면 보다 효율적인 CSS를 작성하여 로드되는 코드의 양을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다. CSS 전처리기는 애플리케이션의 유지보수성을 개선하는 데도 도움이 될 수 있습니다. 모듈화되고 재사용 가능한 CSS를 더 많이 작성할 수 있으므로 작성되는 중복 코드의 양을 줄일 수 있어 시간이 지나도 코드를 유지 관리하고 업데이트하기가 더 쉬워집니다. 사용자 정의 지시문(Directive) 사용 사용자 정의 지시문 사용하면 자신만의 지시문을 생성하여 Vue.js의 기능을 확장할 수 있습니다. 이는 코드를 더 모듈화하고 재사용할 수 있으므로 유지 관리와 이해가 더 쉬워집니다. 사용자 정의 지시문을 사용하면 Vue.js 컴포넌트에 새로운 기능을 추가하여 복잡한 애플리케이션을 더 쉽게 만들 수 있습니다. 또한 사용자 지정 지시문을 사용하면 코드를 더 읽기 쉽게 만들고 오류 위험을 줄이고 유지 관리가 더 쉬워집니다. 사용자 지정 지시문은 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 특정 작업에 최적화된 사용자 지정 지시문을 생성하면 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다. 서버 사이드 렌더링 사용 서버 사이드 렌더링(Server-Side Rendering, SSR)을 사용하면 사용자 브라우저가 아닌 서버에서 Vue.js 애플리케이션을 렌더링할 수 있습니다. SSR을 사용하면 초기 로드 시간을 줄이고 애플리케이션의 SEO를 개선하여 애플리케이션 성능을 향상시킬 수 있습니다. 또한 SSR은 자바스크립트 지원이 제한적이거나 전혀 없는 사용자도 애플리케이션에 액세스할 수 있도록 보장하여 접근성이 높은 애플리케이션을 만드는 데 도움이 됩니다. 또한 SSR은 애플리케이션의 상태를 중앙 집중식으로 관리함으로써 애플리케이션의 유지 관리성을 높이는 데 도움이 될 수 있습니다. 이렇게 하면 오류의 위험을 줄이고 시간이 지나도 코드를 더 쉽게 유지 관리할 수 있습니다. 코드 분할(Code Splitting) 사용 코드 분할을 사용하면 애플리케이션의 코드를 더 작고 관리하기 쉬운 덩어리로 분할할 수 있습니다. 코드 분할을 사용하면 로드되는 불필요한 코드의 양을 줄여 애플리케이션 성능을 향상시킬 수 있습니다. 또한 코드 분할을 사용하면 코드를 더 작고 관리하기 쉬운 덩어리로 나누어 애플리케이션을 더욱 모듈화하고 유지 관리하기 쉽게 만들 수 있습니다. 또한 코드 분할은 모든 코드를 한 번에 로드하는 대신 애플리케이션이 필요한 코드만 로드하도록 하여 보다 반응성이 뛰어나고 사용자 친화적인 애플리케이션을 만드는 데 도움이 될 수 있습니다. 결론 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션을 개발하려면 모듈식 컴포넌트 사용, 성능 최적화, 코딩 표준 적용, ESLint, 단위 테스트 및 비동기 컴포넌트와 같은 도구 사용을 포함한 모범 사례의 조합이 필요합니다. 이러한 모범 사례를 따르면 Vue.js 애플리케이션을 더욱 확장 가능하고 유지 관리 가능하며 사용자 친화적으로 만들 수 있습니다. 또한 애플리케이션의 성능과 접근성을 향상시켜 자바스크립트 지원이 제한적이거나 전혀 없는 사용자도 애플리케이션에 더 쉽게 접근할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Vue 2","slug":"Vue-2","permalink":"http://hgko1207.github.io/tags/Vue-2/"},{"name":"Vue 3","slug":"Vue-3","permalink":"http://hgko1207.github.io/tags/Vue-3/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"}]},{"title":"WinUI vs WPF, WinForms, UWP, MFC","slug":"window-1","date":"2024-01-04T06:16:49.000Z","updated":"2024-01-04T07:58:00.180Z","comments":true,"path":"2024/01/04/window-1/","link":"","permalink":"http://hgko1207.github.io/2024/01/04/window-1/","excerpt":"","text":"**Windows UI 라이브러리(WinUI)**는 Windows의 기본 레이어입니다. 여기에는 디자이너와 개발자가 Windows 애플리케이션을 구축하는 데 필요한 컨트롤과 유연한 디자인 시스템이 포함되어 있습니다. WinUI는 MFC(Microsoft Foundation Class Library) 프레임워크, WinForms, WPF(Windows Presentation Foundation) 및 UWP(Universal Windows Platform)와 같은 다양한 그래픽 사용자 인터페이스(GUI) 프레임워크의 최신 버전입니다. Microsoft는 데스크톱 앱(MFC, WinForms, WPF) 및 UWP 앱을 위한 포괄적인 최신 UI 프레임워크를 만들었으며, 새로운 Windows 애플리케이션 및 이전 애플리케이션에서 작동하도록 설계했습니다. 향상된 직관적인 기능을 통해 기본 애플리케이션을 빠르게 실행하거나 앱을 처음부터 새로 빌드할 수 있습니다. WinUI는 수년에 걸쳐 개선되었습니다. WinUI 2와 WinUI 3의 두 가지 버전이 있습니다. WinUI 2 라이브러리에는 UWP XAML 애플리케이션을 위한 UI 컨트롤과 스타일이 포함되어 있습니다. 이는 Windows 10 운영 체제에 내장된 XAML 및 시각적 계층과 운영 체제 위에 구축된 컨트롤 라이브러리로 구성됩니다. WinUI 3에는 전체 UWP XAML 코드베이스와 WinUI 2의 모든 컨트롤 및 스타일이 포함되어 있습니다. 또한 Windows 10 시각적 계층 내에 다른 강력한 Windows 기술 계층이 있으며, 이 모든 것이 단일 UI 프레임워크로 통합되어 있습니다. 이전 Windows 인터페이스를 좀 더 자세히 살펴보고 WinUI가 이전 버전과 어떻게 비교되는지 살펴보겠습니다. WinUI와 이전 프레임워크의 기능 비교하기 WinUI와 이전 프레임워크 간에는 몇 가지 차이점이 있습니다. MFC 1992년에는 최첨단 MFC(Microsoft Foundation Class Library)가 있었습니다. 이 라이브러리는 네이티브 C++ 및 객체 지향 UI 프레임워크로 구성되어 Windows 앱을 만들 수 있었습니다. 이 시기는 Windows의 기본 UI 계층에 Windows 애플리케이션 빌드하기 위한 스타일 및 컨트롤과 같은 기능이 포함되기 전이었습니다. MFC는 클래스 인스턴스화를 제공하고 데이터 구조나 객체를 동적으로 변환하여 나중에 저장, 전송 또는 재구성하는 방식으로 작동합니다. 또한 기본적인 입력 및 출력, 창 관리, 메뉴 및 대화 상자 컬렉션 저장을 위한 코드도 제공합니다. MFC 프레임워크는 재사용 가능한 클래스 세트를 통해 Windows 프로그래밍을 간소화하여 프로그래밍을 쉽게 만듭니다. 이 프레임워크는 문자열, 파일, 표준 Windows API 및 데이터 구조(예: Windows 및 Controls)와 같은 기본 프로그래밍에 사용되는 객체에 대한 클래스를 제공합니다. 오늘날 MFC 애플리케이션을 구축하는 개발자는 VSFlexGrid 및 True DBGrid와 같은 레거시 ActiveX 컨트롤을 사용할 수 있습니다. WinForms 2002년에 Microsoft는 .NET Framework와 함께 WinForms라는 또 다른 GUI를 출시했습니다. MFC와 마찬가지로 WinForms는 생산성을 크게 향상시켰지만 개발자가 .NET 애플리케이션에서만 사용할 수 있기 때문에 MFC를 대체하기에는 부족했습니다. WinForms는 .NET Framework 래퍼를 사용하며 Windows Forms에 고유한 컨트롤과 기능을 제공합니다. WinForms는 비주얼 디자이너 기반의 Visual Studio를 사용하여 데스크톱 또는 Win32 애플리케이션을 만듭니다. 또한 Visual Studio와 같은 끌어서 놓기 기능을 지원하므로 데스크톱 응용 프로그램 구축을 간소화할 수 있습니다. WinForms는 HTML 텍스트 형식을 지원하며 사용 가능한 HTML 서식 태그를 설명합니다. 이 기능 하나로 데이터를 필터링하는 UI를 구축할 수 있습니다. 거의 20년이 지난 지금, WinForms 개발은 ComponentOne의 .NET WinForms 컨트롤을 통해 더욱 강력해졌습니다. WPF 2006년에 Microsoft는 다양한 기능을 갖춘 개선된 WPF(Windows Presentation Foundation)를 출시했습니다. .NET 개발자를 대상으로 하는 WPF를 사용하면 Windows에서 Direct3D 렌더링을 사용하여 일부 그래픽 작업을 GPU로 오프로드할 수 있습니다. 이러한 오프로드는 컴퓨터 CPU의 작업 부하를 줄이는 데 도움이 됩니다. WPF는 최신 2D 및 3D 그래픽 하드웨어, 애니메이션, 스타일 및 미디어를 활용합니다. 마크업과 Code-behind를 모두 사용하여 애플리케이션을 개발할 수 있습니다. 마크업은 애플리케이션의 모양을 선언적으로 구현합니다. 예를 들어 대화 상자(Dialog box), 페이지 및 사용자 컨트롤의 모양을 디자인하고 도형과 그래픽으로 채웁니다. 반면, Code-behind는 애플리케이션의 동작을 구현하는 데 사용할 수 있는 관리되는 프로그래밍 언어입니다. WPF를 사용하면 XAML을 사용하여 UI를 만들 수 있습니다. 그래픽은 벡터 기반이므로 확장성이 뛰어나고 래스터 이미지에 비해 저장 용량을 덜 필요로 합니다. WPF는 데스크톱 애플리케이션을 쉽게 개발할 수 있는 최첨단 .NET 개발자 프레임워크였지만, UI에 초점을 맞추지 않았기 때문에 WinForms GUI 프레임워크를 대체하지는 못했습니다. WinForms 외에도 ComponentOne은 스타일과 현대화에 더 초점을 맞춘 유사한 WPF 컨트롤을 지원합니다. UWP 2006년 당시에는 서로 다른 선호도와 목표를 가진 Windows 개발자에게 적합한 클라이언트 애플리케이션 구축을 위한 세 가지 훌륭한 UI 프레임워크를 보유하고 있습니다. 그러다가 2012년에 Microsoft는 또 다른 GUI 프레임워크인 UWP XAML(Universal Windows Platform Extensible Application Markup Language)이 포함된 Windows 8을 출시했습니다. 이 프레임워크는 개발자가 Metro 또는 Store 앱이라고도 하는 모든 종류의 앱을 제작하는 데 도움이 됩니다. Microsoft는 최신 그래픽 엔진을 기반으로 UWP를 구축했으며, 개발자는 이를 C++ 및 .NET에서 사용할 수 있지만 제한 사항이 있습니다. 우선, UWP XAML은 UWP 앱에서만 작동하며, 이는 MFC, WinForms, WPF와 같은 프레임워크로 제작된 앱과는 다릅니다. MFC, WinForms 및 WPF로 빌드된 앱은 데스크톱 또는 Win32 앱이라고 하는 반면, UWP로 빌드된 앱은 UWP 앱이라고 합니다. 이들은 서로 다른 API 세트와 서로 다른 라이브러리 생태계를 가지고 있습니다. 예를 들어 MFC, WinForms 또는 WPF를 사용하는 Windows 개발자는 UWP XAML을 사용하기로 결정할 수 있습니다. 이 경우 UWP XAML은 UWP 앱에서만 작동하므로 엄격하게 UWP 앱을 빌드해야 합니다. 결과적으로 일부 개발자는 이를 꺼리게 됩니다. UWP 프레임워크는 WinRT(Windows Runtime) API를 사용하여 강력한 UI 기능을 제공하며, Windows 업데이트와 함께 배포되어 애플리케이션 수준을 한 단계 끌어올릴 수 있습니다. UWP는 가상 레지스트리와 시스템 파일을 사용하여 다른 앱과 충돌하지 않도록 작동합니다. 또한 Appx 패키지의 앱을 더 쉽게 제거하고 원활하게 업데이트하여 이미 설치된 앱에 새로운 기능을 추가할 수 있습니다. UWP가 마이크, 웹캠 또는 전체 파일 시스템과 같은 하드웨어에 액세스하려면 먼저 사용자가 액세스 권한을 부여해야 하므로 악성 앱이 손상을 입히는 것을 방지할 수 있습니다. 인기 있는 WPF 컨트롤을 기반으로 UWP 플랫폼용을 위한 유사한 컨트롤을 개발했으며, 여기에서 확인할 수 있습니다 . WinUI 이제 WinUI의 작동 방식을 살펴보겠습니다. WinUI와 이전 GUI 프레임워크 간의 중요한 차별화 요소 중 하나는 새로운 기능에 대한 이전 버전과의 호환성을 제공한다는 점입니다. Windows 10 장치하고만 호환되는 UWP와 달리 WinUI는 이전 버전의 Windows 10 및 11과도 호환됩니다. 예를 들어 WinUI 3을 사용하면 사용자가 최신 Windows 업데이트를 실행할 때까지 기다릴 필요 없이 새로운 기능이 포함된 앱을 빌드하고 출시할 수 있습니다. 또한 WinUI는 고도로 최적화되고 철저한 테스트를 거친 기본 Windows UI 플랫폼이며 개발자가 광범위하게 사용할 수 있습니다. 또한 사용자의 운영 체제 버전에 맞게 자동으로 조정되므로 앱을 더 쉽게 빌드할 수 있습니다. MAUI MAUI는 Google, Apple 및 Microsoft 기술을 하나로 통합하는 Xamarin과 유사한 최신 .NET 플랫폼입니다. MAUI는 다른 플랫폼에서 실행되는 앱이 공통된 비즈니스 로직을 공유할 수 있도록 Android, iOS, macOS 및 Windows API(WinUI)를 단일 API로 출력합니다. MAUI는 .NET 6 이상에서 지원되며, 지원되는 각 프레임워크에서 동일한 .NET Base Class Library(BCL)에 대한 액세스를 허용합니다. BCL은 기본 프레임워크의 세부 사항을 추상화하여 C# 코드를 한 번만 작성하면 여러 모바일 및 데스크톱 환경에서 애플리케이션을 출력할 수 있습니다. WinUI와 UWP 결합 기본적으로 WinUI 프레임워크로 구축된 대부분의 앱은 핵심이 UWP 앱입니다. 두 프레임워크는 동일한 기본 시각적 개체, 동일한 기본 Windows API 및 동일한 XAML 모델을 공유합니다. WinUI와 UWP의 기본 API 로직은 C이지만 이러한 프레임워크를 사용하는 개발자는 Windows 앱을 빌드할 때 C#, C, F#, Visual Basic .NET(VB.NET), JavaScript 등 다양한 프로그래밍 언어 중에서 선택할 수 있습니다. WinUI와 UWP의 이러한 모든 유사점에도 불구하고 차이점이 있습니다. 예를 들어 UWP는 Windows와 함께 배포되므로 사용자가 수정 사항, 개선 사항 및 새로운 UI 컨트롤에 액세스하려면 최신 Windows 버전으로 업데이트해야 합니다. 이러한 업데이트 필요성은 최신 버전의 Windows로 지속적으로 업데이트할 수 없는 사용자에게는 약간의 병목 현상이 될 수 있습니다. Microsoft는 이 문제를 해결하기 위해 WinUI를 설계했습니다. Windows와 분리되어 있고 UWP에서 추출된 API를 사용하므로 업데이트가 더 쉽습니다. 이 두 프레임워크를 결합하여 멋진 앱을 만들 수 있습니다. 개발자는 WinUI 2.x를 사용하여 UWP 애플리케이션을 만들 수 있습니다. UWP는 Windows에 배포되므로 WinUI와 UWP가 함께 작동하여 XAML Islands와 같은 기능을 기존 데스크톱 애플리케이션에 추가할 수 있습니다. WinUI 기능 WinUI의 많은 기능 중 하나는 이전 버전과 호환되는 Windows Creators Update입니다. WinUI에는 Windows용 React Native도 포함되어 있습니다. React와 비슷하지만 웹 구성 요소 대신 기본 구성 요소를 빌딩 블록으로 사용한다는 점이 다릅니다. WinUI의 새로운 기능인 React Native를 사용하면 새로운 코드를 배우거나 사용하지 않고도 새 앱을 만들거나 기존 앱을 업그레이드할 수 있습니다. Windows 스토어를 통해 이러한 JavaScript 앱을 패키징하고 배포할 수 있습니다. 그 기능에는 기본 모듈 자동 연결, 더 나은 테마 지원 및 탐색 메뉴가 포함됩니다. React Native는 Windows 10 SDK와 macOS 10.13 SDK를 모두 지원합니다. 개발자는 JavaScript를 사용하여 Windows 10과 macOS 데스크톱 및 노트북 생태계에서 지원되는 장치용 기본 Windows 앱을 구축할 수 있습니다. WinUI를 사용한 개발의 이점 다른 프레임워크와 비교하여 WinUI를 사용하여 앱을 빌드할 때 얻을 수 있는 몇 가지 이점을 살펴보겠습니다. 지속적인 업데이트: 다른 프레임워크와 비교하여 WinUI를 사용하면 Windows SDK를 업데이트할 필요 없이 최신 버전의 Fluent 디자인, 컨트롤 및 시각적 요소로 앱을 최신 상태로 유지할 수 있다는 이점이 있습니다. 뛰어난 유연성: 개발자들은 모든 버전의 운영 체제에 유연하게 적응할 수 있는 WinUI를 높이 평가합니다. 또한 네이티브 개발도 지원합니다. 예를 들어 100% C++이더라도 .NET 앱에서 사용할 수 있습니다. 이전 버전과의 호환성: WinUI는 다양한 Windows 10 버전과의 하위 호환성을 제공합니다. 예를 들어 최신 버전의 Windows 10을 사용하지 않는 사용자도 새로운 XAML 기능이 포함된 앱을 출시 직후에 빌드하여 출시할 수 있습니다. 버전 확인이 필요하지 않습니다: WinUI로 빌드된 애플리케이션은 UWP XAML의 주요 컨트롤이나 기능을 사용하기 위해 버전 확인이 필요하지 않습니다. 사용성: UWP와 달리 WinUI를 사용하면 개발자는 Windows를 업데이트하지 않고도 최신 UI 컨트롤을 사용할 수 있습니다. 확장성: MAUI로 개발하면 Android, iOS, macOS용 모바일 버전으로 즉시 확장할 수 있는 WinUI 애플리케이션을 만들 수 있습니다. WinUI 단점 WinUI는 이전 프레임워크에 비해 개선되었지만 몇 가지 단점이 있습니다. 우선, WinUI는 WPF 앱과 달리 Uno 플랫폼 없이 Windows 7에서 실행하거나 배포할 수 없습니다. 또한 WinForms와 비교할 때 WinUI는 빠른 UI 개발에 대한 평판이 좋지 않습니다. 예를 들어, 많은 Windows 개발자는 .NET 라이브러리에 대한 간단한 유틸리티 또는 UI Test harness를 만들 때 여전히 WinForms로 되돌아갑니다. Test harness 시스템 및 시스템 컴포넌트를 시험하는 환경의 일부분으로 시험을 지원하는 목적 하에 생성된 코드와 데이터. 시험 드라이버 (test driver)라고도 하며 일반적으로 단위 시험이나 모듈 시험에 사용하기 위해 코드 개발자가 만든다. 결론 WinUI는 다양한 GUI 프레임워크 중 최신 버전입니다. WinUI와 이전 프레임워크의 핵심 차이점은 SDK를 업데이트할 필요 없이 유연한 디자인과 업데이트된 컨트롤에 액세스할 수 있다는 점입니다. 이전 프레임워크에 비해 몇 가지 단점이 있지만 유연성, 이전 버전과의 호환성 및 범용성 때문에 많은 개발자가 WinUI로 전환했습니다. WinUI로 전환하는 경우에도 GrapeCity ComponentOne의 .NET 구성 요소 제품군(2021년 중반부터 WinUI에서 사용 가능)을 사용하여 개발 시간을 절약할 수 있습니다. 작고 유연한 데이터 그리드, 차트, 보고서, 달력, 입력, 비즈니스 인텔리전스 대시보드 및 기타 UI 요소를 WinUI 애플리케이션에 빠르게 추가하여 익숙한 컨트롤로 사용자 경험을 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WinUI","slug":"Programming/Frontend/WinUI","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WinUI/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"WinUI","slug":"WinUI","permalink":"http://hgko1207.github.io/tags/WinUI/"},{"name":"WinForms","slug":"WinForms","permalink":"http://hgko1207.github.io/tags/WinForms/"},{"name":"UWP","slug":"UWP","permalink":"http://hgko1207.github.io/tags/UWP/"},{"name":"MFC","slug":"MFC","permalink":"http://hgko1207.github.io/tags/MFC/"}]},{"title":"자바스크립트 프레임워크 소개","slug":"js-dev-12","date":"2024-01-03T01:36:32.000Z","updated":"2024-01-15T01:50:04.447Z","comments":true,"path":"2024/01/03/js-dev-12/","link":"","permalink":"http://hgko1207.github.io/2024/01/03/js-dev-12/","excerpt":"","text":"소개 자바스크립트(JavaScript)는 현대 웹 개발의 필수 구성 요소가 되었으며, 그 인기로 인해 복잡한 애플리케이션을 구축하는 과정을 간소화하는 많은 프레임워크가 만들어졌습니다. 이러한 프레임워크는 개발자가 웹 애플리케이션을 빠르고 효율적으로 제작하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서는 가장 인기 있는 자바스크립트 프레임워크 중 일부를 살펴보고 고유한 기능을 살펴보겠습니다. Vue Vue는 개발자들 사이에서 인기를 얻고 있는 경량 자바스크립트 프레임워크입니다. 쉽게 배우고 사용할 수 있도록 설계되었으며 다양한 기능을 제공하여 중소규모 애플리케이션을 구축하는 데 탁월한 선택입니다. Vue는 사용자 인터페이스 구축에 반응형 접근 방식을 사용합니다. 즉, 사용자 인터페이스의 변경 사항이 실시간으로 자동 업데이트됩니다. 또한 복잡한 애플리케이션 구축하는 과정을 간소화하는 다양한 내장 지시어와 플러그인을 제공합니다. React React는 Facebook에서 개발하여 널리 사용되는 자바스크립트 라이브러리입니다. 개발자가 크고 복잡한 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다. React는 사용자 인터페이스를 더 작은 컴포넌트로 나누어 애플리케이션 전체에서 쉽게 재사용할 수 있도록 하는 방식으로 작동합니다. 이러한 모듈식 접근 방식을 사용하면 복잡한 사용자 인터페이스를 쉽게 관리할 수 있으며 개발자는 사용자 인터페이스가 아닌 애플리케이션의 로직에 집중할 수 있습니다. 또한 React는 속도와 성능이 뛰어나 실시간 업데이트가 필요한 웹 애플리케이션을 구축하는 데 탁월한 선택입니다. Angular Angular는 Google에서 개발한 또 다른 인기 있는 자바스크립트 프레임워크입니다. 개발자가 동적이고 확장 가능한 웹 애플리케이션을 구축할 수 있도록 설계되었습니다. Angular는 사용자 인터페이스 구축하는 데 선언적 접근 방식을 사용하므로 복잡한 사용자 인터페이스를 쉽게 관리할 수 있습니다. 또한 종속성 주입, 양방향 데이터 바인딩, 내장 지시어 등 다양한 기능을 제공하므로 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Angular는 성능도 뛰어나 고성능 웹 애플리케이션을 구축하는 데 널리 사용됩니다. Ember Ember는 개발자가 야심 찬 웹 애플리케이션을 구축할 수 있도록설계된 강력한 자바스크립트 프레임워크입니다. 강력한 라우터, 데이터 레이어, 내장된 테스트 프레임워크 등 다양한 기능을 제공하므로 크고 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Ember는 개발자가 모범 사례를 쉽게 따르고 시간이 지나도 쉽게 유지 관리할 수 있는 애플리케이션을 쉽게 구축할 수 있도록 하는 일련의 규칙을 제공합니다. Backbone Backbone은 개발자가 중소규모 웹 애플리케이션을 구축할 수 있도록 설계된 경량 자바스크립트 프레임워크입니다. 간단한 이벤트 시스템, 모델 및 컬렉션, 강력한 라우터 등 다양한 기능을 제공합니다. Backbone은 단순하고 사용하기 쉬운 것으로 유명하여 간단한 애플리케이션을 빠르게 구축하는 데 탁월한 선택입니다. 결론 자바스크립트 프레임워크는 최신 웹 개발의 필수 구성 요소가 되었습니다. 개발자가 복잡한 애플리케이션을 빠르고 효율적으로 구축하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서 논의한 프레임워크는 개발자가 사용할 수 있는 다양한 옵션 중 일부에 불과합니다. 프레임워크를 선택할 때 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다. 올바른 프레임워크와 숙련된 개발 팀이 있으면 복잡한 웹 애플리케이션을 구축하는 것이 그 어느 때보다 쉬워졌습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"}]},{"title":"예측 분석을 통한 인공지능(AI) 기반 상호 작용","slug":"ai-4","date":"2024-01-02T06:19:41.000Z","updated":"2024-01-02T07:06:48.139Z","comments":true,"path":"2024/01/02/ai-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/02/ai-4/","excerpt":"","text":"인공 지능(AI)은 다양한 산업 분야에서 강력한 도구로 부상하여 기술과 상호 작용하는 방식에 혁명을 일으켰습니다. AI가 크게 발전한 분야 중 하나는 예측 분석 분야로, 기업이 데이터 기반 인사이트를 바탕으로 정보에 입각한 의사결정을 내릴 수 있도록 지원합니다. 이 글에서는 AI 기반 상호작용과 예측 분석이 어떻게 산업을 변화시키고 비즈니스의 미래를 만들어가는지 살펴봅니다. 인사이트는 통찰력이나 깊은 이해를 의미하는 단어로, 특히 비즈니스나 마케팅 분야에서는 데이터를 분석하여 얻은 유용한 정보나 통찰력을 의미하기도 합니다. 예측 분석의 힘 예측 분석은 기존 데이터 세트에서 정보를 추출하여 패턴을 파악하고 미래의 결과나 추세를 예측하는 작업입니다. 기업은 과거 데이터를 분석하여 고객 행동, 시장 동향, 운영 효율성에 대한 귀중한 인사이트를 얻을 수 있습니다. 데이터의 양이 방대하고 복잡하기 때문에 사람이 데이터를 효율적으로 처리하고 의미 있는 인사이트를 도출하기란 쉽지 않습니다. 바로 이 점이 인공지능이 필요한 이유입니다. 예측 분석에서 AI의 역할 AI 알고리즘은 방대한 양의 데이터를 매우 빠른 속도로 처리하여 인간이 놓칠 수 있는 패턴과 추세를 파악할 수 있습니다. AI의 하위 집합인 머신러닝 알고리즘은 과거 데이터를 통해 학습하고 패턴과 상관관계를 기반으로 예측할 수 있습니다. 기업은 AI 기반 예측 분석을 통해 이러한 알고리즘을 활용하여 데이터 기반 의사결정을 내리고 해당 산업에서 경쟁 우위를 확보할 수 있습니다. 고객 상호 작용 향상 예측 분석을 통한 AI 기반 상호 작용은 기업이 고객과 소통하는 방식을 변화시켰습니다. AI 알고리즘은 구매 내역, 검색 행동, 소셜 미디어 상호 작용 상호 작용과 같은 고객 데이터를 분석하여 고객 경험을 개인화할 수 있습니다. 예를 들어, 전자상거래 플랫폼은 개인별 선호도에 따라 제품을 추천하여 고객 만족도를 높이고 판매를 촉진할 수 있습니다. 또한 AI 기반의 챗봇은 실시간 고객 지원을 제공하여 문의에 답변하고 문제를 신속하게 해결할 수 있습니다. 공급망 관리 최적화 AI와 결합된 예측 분석은 수요를 예측하고 재고 관리를 개선하며 물류를 간소화하여 공급망 관리를 최적화할 수 있습니다. AI 알고리즘은 과거 판매 데이터를 분석하여 미래 수요 패턴을 예측함으로써 기업이 생산 수준을 조정하고 품절이나 과잉 재고를 방지할 수 있도록 지원합니다. 또한 AI 기반 알고리즘은 운송 경로를 최적화하여 운송 비용을 절감하고 배송 효율성을 개선할 수 있습니다. 사기 탐지 및 위험 완화 AI 기반 예측 분석은 사기 탐지 및 위험 완화에 있어 매우 유용하다는 것이 입증되었습니다. AI 알고리즘은 대량의 금융 데이터를 분석하여 사기 행위를 나타내는 의심스러운 패턴과 이상 징후를 식별할 수 있습니다. 이러한 사전 예방적 접근 방식을 통해 기업은 심각한 재정적 손실을 초래하기 전에 사기를 탐지하고 예방할 수 있습니다. 또한 AI는 여러 소스의 데이터를 분석하여 잠재적인 위험을 식별하고 완화 전략을 개발하여 잠재적인 위협으로부터 비즈니스를 보호할 수 있습니다. 의료 및 예측 분석 의료 업계에서는 AI 기반 상호 작용과 예측 분석이 환자 치료에 혁신을 일으키고 있습니다. AI 알고리즘은 환자 기록을 분석하여 질병 진행을 예측하고, 개인 맞춤형 치료 계획을 추천하며, 환자 치료 결과를 개선할 수 있습니다. 또한 AI는 잠재적인 건강 위험을 식별하여 조기 개입 및 예방 조치를 가능하게 합니다. AI 기반 챗봇과 가상 비서는 24시간 지원을 제공하여 환자의 질문에 답하고 의료 조언을 제공할 수 있습니다. 재무 예측 및 투자 결정 AI 기반 예측 분석은 정확한 예측과 투자 결정을 지원함으로써 금융 산업을 재편하고 있습니다. AI 알고리즘은 시장 동향, 경제 지표 및 과거 데이터를 분석하여 주식 시장 움직임을 예측하여 거래자가 정보에 입각한 결정을 내릴 수 있도록 돕습니다. 또한 AI 기반 로보 어드바이저는 개인의 위험 프로필을 기반으로 개인화된 투자 추천을 제공하여 금융 서비스의 효율성과 접근성을 향상시킬 수 있습니다. 결‍론 AI와 예측 분석의 결합은 다양한 산업 분야에서 엄청난 잠재력을 발휘하고 있습니다. 고객과의 상호작용을 강화하고 공급망 관리를 최적화하는 것부터 사기를 탐지하고 의료 결과를 개선하는 것까지, AI 기반 상호작용과 예측 분석의 결합은 비즈니스를 변화시키고 미래를 만들어가고 있습니다. 기술이 계속 발전함에 따라 전 세계 비즈니스에서 데이터 기반 의사결정을 내리고 새로운 기회를 창출하는 데 AI의 역할이 점점 더 중요해질 것으로 예상됩니다. 이러한 혁신적인 기술을 수용하는 것은 끊임없이 진화하는 디지털 환경에서 경쟁력을 유지하는 데 핵심이 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"예측분석","slug":"예측분석","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EC%B8%A1%EB%B6%84%EC%84%9D/"}]},{"title":"블록체인, 영향력 있는 새로운 트렌드","slug":"blockchain-3","date":"2024-01-02T01:52:51.000Z","updated":"2024-01-15T01:10:05.712Z","comments":true,"path":"2024/01/02/blockchain-3/","link":"","permalink":"http://hgko1207.github.io/2024/01/02/blockchain-3/","excerpt":"","text":"블록체인 기술은 전 세계적으로 다양한 산업에 혁명을 일으키고 있는 획기적인 혁신으로 등장했습니다. 처음에는 비트코인과 같은 암호화폐와의 연관성으로 알려졌던 블록체인은 이제 소프트웨어 개발에 광범위한 영향을 미치는 파괴적인 힘으로 인식되고 있습니다. 이 글에서는 블록체인이 어떻게 소프트웨어 개발에 영향력 있는 트렌드가 되어 다양한 애플리케이션 전반에 걸쳐 보안, 투명성 및 효율성을 향상시키는지 살펴봅니다. 보안 강화 블록체인 기술의 가장 중요한 장점 중 하나는 강력한 보안 기능입니다. 기존 소프트웨어 시스템은 중앙화된 기관이나 서버에 의존하는 경우가 많아 해킹과 데이터 침해에 취약합니다. 반면 블록체인은 데이터가 여러 노드에 분산되고 저장되는 탈중앙화 네트워크를 사용합니다. 이러한 고유한 탈중앙화와 암호화 알고리즘이 결합되어 블록체인에 저장된 데이터는 안전하고 위변조가 불가능합니다. 그 결과, 안전한 애플리케이션을 구축하고 민감한 정보를 보호하며, 사용자 신뢰를 높이기 위해 소프트웨어 개발에 블록체인 기술이 점점 더 많이 채택되고 있습니다. 투명성과 책임성 블록체인의 투명성과 불변성은 신뢰와 책임이 필요한 산업을 변화시키고 있습니다. 블록체인을 사용하면 모든 거래나 데이터 입력이 투명하고 영구적인 방식으로 기록되어 네트워크의 모든 참가자가 볼 수 있습니다. 이러한 투명성 덕분에 관련된 모든 당사자가 거래를 독립적으로 검증하고 감사할 수 있으므로 중개자가 필요하지 않습니다. 소프트웨어 개발에서 블록체인 기반 솔루션을 활용하여 감사 가능한 시스템을 만들고, 공급망을 간소화하며, 투표 시스템, 부동산 거래 및 지적 재산 관리의 투명성을 보장합니다. 분산형 애플리케이션(Decentralized Applications, DApps) 블록체인이 소프트웨어 개발에 미치는 영향은 보안과 투명성 그 이상입니다. 이는 탈중앙화 애플리케이션(DApps) 개발의 길을 열었습니다. DApps는 블록체인의 탈중앙화 아키텍처, 스마트 계약 및 분산 합의 메커니즘을 활용하여 단일 개체에 의해 제어되지 않고 자율적으로 운영되는 애플리케이션을 만듭니다. DApps는 중개자가 필요 없기 때문에 사용자가 자신의 데이터와 상호 작용을 더 잘 제어할 수 있는 P2P 생태계를 만듭니다. 소프트웨어 개발자들은 금융, 게임, 공급망 관리, 신원 확인과 같은 분야에서 DApps의 잠재력을 점점 더 많이 탐색하고 있습니다. 스마트 컨트랙트 스마트 컨트랙트는 특정 조건이 충족되면 미리 정의된 작업을 자동으로 실행하는 코드로 작성된 자체 실행 계약입니다. 블록체인의 스마트 컨트랙트 기능은 소프트웨어 개발자에게 새로운 길을 열어주었습니다. 개발자는 스마트 컨트랙트를 활용하여 복잡한 비즈니스 프로세스를 자동화하고, 중개자의 필요성을 줄이며, 투명하고 감사 가능한 계약의 실행을 보장할 수 있습니다. 이 기술은 신뢰, 투명성, 효율성이 가장 중요한 보험금 청구, 공급망 관리, 금융 거래와 같은 분야에서 특히 유용합니다. 토큰화 및 디지털 자산 블록체인 기술은 자산의 토큰화를 가능하게 하여 블록체인 상에서 실물 또는 디지털 아이템을 디지털 토큰으로 표현합니다. 이러한 토큰화는 안전하게 거래, 저장 및 검증할 수 있는 디지털 자산을 생성함으로써 소프트웨어 개발에 새로운 가능성을 열어줍니다. 예를 들어, 예술품, 수집품, 가상 부동산과 같은 고유한 디지털 자산을 소유하고 검증할 수 있는 대체 불가능한 토큰(NFT)이 큰 주목을 받고 있습니다. 소프트웨어 개발자들은 디지털 신원 확인, 디지털 투표, 탈중앙화 금융(DeFi)과 같은 분야에서 혁신적인 애플리케이션을 개발하기 위해 토큰화를 모색하고 있습니다. 상호운용성 및 확장성 블록체인 기술이 계속 발전함에 따라 블록체인 고유의 문제인 확장성과 상호운용성을 해결하기 위한 노력도 계속되고 있습니다. 다양한 프로젝트에서 서로 다른 블록체인이 원활하게 통신할 수 있도록 지원하여 협업과 데이터 교환을 향상시키는 솔루션을 개발하고 있습니다. 상호운용성을 통해 소프트웨어 개발자는 여러 블록체인 플랫폼의 강점을 활용하고 다양한 사용 사례에 맞는 애플리케이션을 구축할 수 있습니다. 블록체인의 트랜잭션 처리 기능의 한계를 극복하기 위해 레이어 2 프로토콜 및 샤딩과 같은 확장성 솔루션도 개발되고 있습니다. 결론 블록체인 기술은 소프트웨어 개발의 강력한 힘으로 부상하여 다양한 애플리케이션에 향상된 보안, 투명성 및 효율성을 제공합니다. 스마트 컨트랙트, 토큰화, 상호운용성과 같은 기능과 함께 탈중앙화된 특성은 산업을 재편하고 혁신적인 솔루션을 위한 길을 열어주고 있습니다. 소프트웨어 개발자들이 블록체인의 잠재력을 수용함에 따라 기존 비즈니스 프로세스를 재정의하고 사용자가 데이터와 디지털 자산을 더 잘 제어할 수 있도록 지원하는 파괴적인 애플리케이션이 등장할 것으로 예상됩니다. 소프트웨어 개발의 미래는 의심할 여지 없이 블록체인 기술의 영향력 있는 트렌드와 얽혀 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"암호화폐","slug":"암호화폐","permalink":"http://hgko1207.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"}]},{"title":"HTML과 CSS 기술을 향상시킬 수 있는 10가지 소규모 프로젝트 아이디어","slug":"web-design-4","date":"2023-12-29T15:13:09.000Z","updated":"2023-12-29T15:32:41.084Z","comments":true,"path":"2023/12/30/web-design-4/","link":"","permalink":"http://hgko1207.github.io/2023/12/30/web-design-4/","excerpt":"","text":"소개 HTML과 CSS를 배우는 것은 웹 개발에 관심이 있는 모든 사람에게 필수적인 단계입니다. 이러한 기본 기술은 인터넷에 있는 모든 웹사이트의 구성 요소입니다. 이를 익히려면 연습이 필요한데, 소규모 프로젝트에 참여하는 것보다 더 좋은 방법이 있을까요? 이 글에서는 HTML 및 CSS 기술을 연마하는 데 도움이 되는 10가지 소규모 프로젝트 아이디어를 살펴보겠습니다. 개인 포트폴리오 웹사이트 개인 포트폴리오 웹사이트를 만들어 자신의 기술, 프로젝트, 경험을 보여주세요. 이 프로젝트를 통해 콘텐츠 구조화를 위한 HTML과 레이아웃 및 디자인을 위한 CSS를 연습하면서 웹사이트를 디자인하고 스타일을 지정할 수 있습니다. 레시피 북 HTML과 CSS를 사용하여 디지털 요리책을 디자인하세요. 좋아하는 요리법을 나열하고, 이미지를 추가하고, 시각적으로 매력적으로 보이도록 레이아웃을 스타일링할 수 있습니다. 제품 랜딩 페이지 마음에 드는 제품을 선택하고 해당 제품의 랜딩 페이지를 디자인하세요. 제품 설명, 이미지, 클릭 유도 버튼을 포함하여 실제 전자상거래 페이지를 모방할 수 있습니다. 블로그 페이지 HTML과 CSS로 간단한 블로그 페이지를 만들어보세요. 블로그 게시물을 표시하고, 탐색을 위한 사이드바를 포함하며, 원하는 대로 스타일을 지정할 수 있습니다. 이 프로젝트는 레이아웃 및 반응형 디자인 작업에 도움이 됩니다. 헌정 페이지 존경하는 역사적인 인물이나 유명인을 선택하여 해당 인물에 대한 헌정 페이지를 만드세요. 이미지, 인용문, 간략한 소개를 포함하세요. HTML로 콘텐츠를 구조화하고 CSS로 스타일을 지정하는 연습을 할 수 있는 좋은 프로젝트입니다. 로그인/등록 양식 유효성 검사가 포함된 로그인 및 등록 양식을 작성하세요. 이 프로젝트는 양식 작성 및 사용자 입력 작업에 대한 인사이트를 얻을 수 있습니다. 이미지 갤러리 HTML과 CSS로 간단한 이미지 갤러리를 개발해 보세요. 이미지 썸네일을 추가하고, 라이트박스를 만들고, 부드러운 전환을 구현할 수 있습니다. 레이아웃과 인터랙션 디자인을 연습하기에 좋은 프로젝트입니다. 할 일 목록 할 일 목록 앱을 만들어 보세요. 기본 기능으로 작업을 추가, 편집, 제거할 수 있습니다. 이 프로젝트는 HTML과 CSS를 사용하여 DOM을 조작하는 방법을 이해하는 데 도움이 됩니다. 날씨 앱 API에서 날씨 데이터를 가져와 사용자 친화적인 인터페이스에 표시하는 날씨 앱을 만드세요. 이 프로젝트를 통해 외부 데이터 소스 및 동적 콘텐츠 작업에 대한 인사이트를 얻을 수 있습니다. CSS 애니메이션 로딩되는 스피너, 튀어 오르는 공 또는 슬라이딩 탐색 메뉴를 만들어 CSS 애니메이션을 실험해 보세요. 애니메이션은 CSS의 창의적인 측면을 탐색할 수 있는 재미있는 방법입니다. 결론 소규모 프로젝트 작업은 HTML과 CSS 기술을 향상시키는 훌륭한 방법입니다. 이러한 프로젝트는 실무 경험을 쌓는 데 도움이 될 뿐만 아니라 잠재적인 고용주나 고객에게 선보일 작업 포트폴리오를 구축하는 데도 도움이 됩니다. 이러한 프로젝트를 완료하면서 지속적으로 도전하고 HTML 및 CSS의 새로운 기술과 기능을 탐색하는 것을 잊지 마세요. 연습을 많이 할수록 웹 개발에 대한 자신감과 숙련도가 높아집니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"사용자 인터페이스 디자인의 기초: 종합 가이드","slug":"web-5","date":"2023-12-27T13:36:52.000Z","updated":"2023-12-27T13:58:08.491Z","comments":true,"path":"2023/12/27/web-5/","link":"","permalink":"http://hgko1207.github.io/2023/12/27/web-5/","excerpt":"","text":"소개 사용자 인터페이스(UI) 디자인은 사용자 친화적이고 시각적으로 매력적인 소프트웨어, 웹 사이트, 모바일 애플리케이션을 만드는 데 중요한 측면입니다. 잘 디자인된 UI는 성공적이고 직관적인 제품과 실망스러운 제품 사이의 차이를 만들 수 있습니다. 이 글에서는 사용자 인터페이스 디자인의 기본 사항을 살펴보고, 주요 원칙을 세분화하고, 이러한 개념을 설명하기 위한 실제 사례를 제공합니다. 사용자 이해 UI 디자인의 첫 번째 단계는 타겟 고객을 이해하는 것입니다. 효과적인 디자인은 사용자의 요구, 선호도, 기대치를 충족시켜야 합니다. 이 점을 설명하기 위해 Facebook의 예를 살펴보겠습니다. Facebook의 UI 디자인은 기술에 능숙한 밀레니얼 세대부터 노년층에 이르기까지 다양한 사용자층에 맞춰져 있습니다. 깔끔하고 탐색하기 쉬운 인터페이스로 모든 연령대의 사람들이 쉽게 접근할 수 있어 폭넓은 사용자층을 확보할 수 있습니다. 일관성과 단순성 UI 디자인의 일관성은 매우 중요합니다. 사용자가 시스템의 작동 방식을 쉽게 예측할 수 있기 때문입니다. 탐색 메뉴의 배치, 버튼 스타일, 색 구성표 등 모든 면에서 일관성을 유지하면 편안한 사용자 환경을 만들 수 있습니다. Google의 검색 엔진을 예로 들어 보겠습니다. 수년 동안 Google의 UI는 비교적 일관성을 유지해 왔습니다. 사용자는 무엇을 기대해야 할지 알고 있으며, 이러한 친숙함은 널리 사용되는 데 기여합니다. 단순성은 또 다른 핵심 요소입니다. 어수선하거나 지나치게 복잡한 UI는 사용자를 압도할 수 있습니다. Apple의 iPhone은 단순함의 힘을 보여주는 대표적인 예입니다. 깔끔하고 직관적인 인터페이스를 통해 사용자는 학습 곡선을 거의 또는 전혀 거치지 않고도 기기를 집어 들고 사용할 수 있습니다. 시각적 계층 UI 디자인에서 시각적 계층 구조는 화면에서 요소의 배열과 우선순위를 의미합니다. 시각적 계층 구조는 사용자의 주의를 유도하고 인터페이스를 효과적으로 탐색할 수 있도록 도와줍니다. 에어비앤비(Airbnb) 웹사이트를 생각해 보세요. 검색창과 클릭 유도 버튼은 페이지 상단에 눈에 잘 띄게 배치되어 가장 중요한 작업으로 사용자의 주의를 집중시킵니다. 피드백과 응답성 사용자는 UI와 상호작용할 때 피드백을 받아야 합니다. 버튼에 마우스를 갖다 대면 색이 바뀌거나 작업이 로드 중일 때 진행률 표시줄이 표시되는 등 간단한 방법으로도 피드백을 받을 수 있습니다. 인기 있는 팀 커뮤니케이션 플랫폼인 Slack은 실시간 입력 표시, 메시지 전송 확인 및 읽음 확인을 통해 뛰어난 피드백을 제공합니다. 이를 통해 사용자는 플랫폼 내에서 진행 중인 작업과 상호 작용에 대한 정보를 계속 확인할 수 있습니다. 접근성 UI 디자인은 장애인을 포함한 모든 사람이 애플리케이션을 사용할 수 있도록 접근성을 우선적으로 고려해야 합니다. Microsoft의 Windows 운영 체제는 접근성 기능을 개선하는 데 상당한 진전을 이루었습니다. 모든 사용자가 UI에 액세스할 수 있도록 화면 판독기 및 음성 명령과 같은 다양한 보조 기술을 제공합니다. 타이포그래피와 가독성 올바른 글꼴과 타이포그래피를 선택하는 것은 UI 디자인에 매우 중요합니다. 텍스트는 가독성이 뛰어나고 심미적으로도 아름다워야 합니다. 예를 들어 트위터의 UI는 트윗에 간단하고 가독성이 좋은 글꼴을 사용하여 사용자가 콘텐츠에 쉽게 참여할 수 있도록 합니다. 사용자 테스트 사용자 테스트에는 디자인 과정에서 실제 사용자로부터 피드백을 받는 과정이 포함됩니다. 이러한 피드백은 문제를 파악하고 UI를 개선하는 데 매우 중요합니다. 클라우드 스토리지 플랫폼인 Dropbox는 사용자 경험을 개선하기 위해 정기적으로 사용자 테스트를 실시합니다. 실제 사용자의 참여를 통해 인터페이스를 지속적으로 개선하고 사용자 친화적인 인터페이스를 만듭니다. 결론 사용자 인터페이스 디자인은 예술과 과학을 결합하여 사용자에게 매력적이고 직관적인 경험을 제공하는 종합 분야입니다. 사용자를 이해하고, 일관성을 유지하고, 단순성을 우선시하고, 시각적 계층 구조를 설정하고, 피드백을 제공하고, 접근성을 보장하고, 적절한 타이포그래피를 선택하고, 사용자 테스트를 수행하는 것은 모두 UI 디자인의 필수 요소입니다. Facebook, Google, Apple, Airbnb, Slack, Microsoft 및 Twitter와 같은 회사의 실제 사례를 통해 확인할 수 있습니다. 이러한 기본 원칙을 준수하면 원활한 사용자 경험을 제공하면서 잠재 고객의 마음을 사로잡고 참여를 유도하는 사용자 인터페이스를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"HTML, CSS, JavaScript 숙달하기","slug":"web-4","date":"2023-12-23T15:14:04.000Z","updated":"2023-12-27T13:25:09.272Z","comments":true,"path":"2023/12/24/web-4/","link":"","permalink":"http://hgko1207.github.io/2023/12/24/web-4/","excerpt":"","text":"능숙한 웹 개발자가 되기 위해서는 HTML, CSS, JavaScript와 같은 핵심 웹 기술을 마스터하는 것이 필수적입니다. 다음은 이러한 각 기술을 숙달하는 방법에 대한 분석입니다. 1. HTML (Hypertext Markup Language) 기본 사항 알아보기: 제목(h1, h2, …), 단락§, 목록(ul, li), 링크(a) 및 이미지(image)와 같은 기본적인 HTML 요소와 태그를 이해하는 것부터 시작하세요. 시맨틱 HTML: 콘텐츠에 의미와 구조를 부여하기 위해 &lt;header&gt;, &lt;nav&gt;, &lt;main&gt;, &lt;article&gt;, &lt;section&gt;, &lt;footer&gt;와 같은 시맨틱 HTML 태그를 사용하는 데 집중하세요. 양식(Forms): 입력 필드, 텍스트 영역, 라디오 버튼, 체크박스, submit 버튼 등 HTML을 사용하여 양식을 만드는 방법을 알아보세요. HTML5 기능: 비디오 및 오디오 요소, 그래픽을 위한 canvas, 클라이언트 측 데이터 저장을 위한 로컬 스토리지 API와 같은 HTML5 기능에 익숙해집니다. 유효성 검사: 온라인 유효성 검사기 또는 통합 개발 환경(IDE) 도구를 사용하여 HTML 코드의 유효성을 검사하는 방법을 이해합니다. 2. CSS (Cascading Style Sheets) 박스 모델: 요소의 크기(size)와 여백(margin), 테두리(border), 패딩(padding), 콘텐츠가 상호 작용하는 방식을 이해하는 등 CSS 박스 모델에 대해 알아보세요. 선택기(Selectors): 스타일 지정을 위해 특정 HTML 요소를 지정하는 CSS 선택기를 마스터하세요. 레이아웃 기법: 반응형 디자인을 만들기 위한 Flexbox 및 CSS 그리드와 같은 다양한 레이아웃 기법을 살펴보세요. 반응형 디자인: 미디어 쿼리와 반응형 디자인 원칙을 이해하여 다양한 기기와 화면 크기에서 웹 페이지가 멋지게 보이도록 만드세요. 전환(Transitions) and 애니메이션(Animations): 더 나은 사용자 경험을 위해 CSS를 사용하여 부드러운 전환과 애니메이션을 만드는 방법을 알아보세요. 전처리기: CSS 워크플로우와 유지보수성을 향상시키기 위해 SASS 또는 LESS와 같은 CSS 전처리기를 학습하는 것도 고려해 보세요. 3. JavaScript 구문과 기초: 변수, 데이터 유형, 연산자, 제어 구조(if 문, 루프) 등 JavaScript의 기초부터 시작하세요. DOM 조작: DOM(Document Object Model )과 상호 작용하여 HTML 콘텐츠와 스타일을 동적으로 변경하는 방법을 이해합니다. 이벤트 처리: 클릭, 키 누름, 양식(form) 제출과 같은 사용자 상호작용과 이벤트를 처리하는 방법을 알아보세요. 함수 및 범위: JavaScript의 기본 개념인 함수(function), 범위(scope), 클로저(closure)에 대해 자세히 알아보세요. AJAX와 Fetch: 서버에 요청하기 위한 AJAX 또는 최신 Fetch API를 사용한 비동기 프로그래밍을 살펴보세요. 프레임워크와 라이브러리: 대화형 웹 애플리케이션을 구축하기 위해 React, Angular 또는 Vue.js와 같은 인기 있는 JavaScript 프레임워크와 라이브러리를 학습해 보세요. ES6 이상: ES6(ECMAScript 2015)를 비롯한 최신 JavaScript 기능 및 표준에 대해 알아보세요. 테스트: 단위 테스트를 작성하고 Jest와 같은 테스트 프레임워크를 사용하여 JavaScript 코드의 안정성을 보장하는 방법을 알아보세요. 디버깅: 브라우저 개발자 도구와 디버깅 기술을 사용하여 JavaScript 오류를 해결하고 수정하세요. 결론 숙달하려면 시간과 연습이 필요하다는 것을 기억하세요. 작은 프로젝트부터 시작하여 점차 더 복잡한 프로젝트로 나아가세요. 온라인 튜토리얼, 강좌, 코딩 연습은 HTML, CSS, JavaScript 기술을 배우고 향상하는 데 유용한 자료가 될 수 있습니다. 정기적으로 연습하고, 피드백을 구하고, 웹 개발의 최신 동향을 파악하여 능숙한 웹 개발자가 되세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"}]},{"title":"웹 기술 디코딩: HTML, XML, JSON, AJAX에 대한 종합 가이드","slug":"web-3","date":"2023-12-23T14:45:36.000Z","updated":"2023-12-23T15:13:27.227Z","comments":true,"path":"2023/12/23/web-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/23/web-3/","excerpt":"","text":"소개 빠르게 발전하는 웹 개발 분야에서는 인터넷을 주도하는 핵심 기술에 대한 기초적인 이해가 가장 중요합니다. 이 블로그 게시물은 최신 웹 애플리케이션의 동적 기능에 기여하는 필수 구성 요소인 HTML, XML, JSON 및 AJAX의 복잡한 내용을 풀어내는 것을 목표로 합니다. HTML: 웹 페이지의 구성 요소 HTML(Hypertext Markup Language)은 웹 페이지 구성의 초석입니다. 표준화된 프레임워크 역할을 하는 HTML은 태그를 사용하여 제목, 단락§, 이미지 및 링크와 같은 다양한 요소를 정의합니다. 웹 브라우저는 HTML을 해석하여 다양한 기기에서 일관된 디스플레이를 보장합니다. 기본적인 HTML 구조를 살펴보겠습니다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My Web Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;p&gt;This is a simple web page.&lt;/p&gt; &lt;img src=\"image.jpg\" alt=\"An example image\" /&gt; &lt;a href=\"https://example.com\"&gt;Visit Example.com&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; XML: 유연한 데이터 표현 XML(eXtensible Markup Language)은 데이터 전송 및 저장에 맞게 조정되었습니다. XML은 사용자 정의 태그를 사용하여 정보를 계층적으로 구성하여 사람과 기계의 가독성을 높입니다. XML은 서로 다른 시스템 간의 데이터 교환에서 빛을 발하며 원활한 커뮤니케이션을 촉진합니다. 다음은 XML의 구조입니다. 12345&lt;person&gt; &lt;name&gt;John Doe&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;city&gt;New York&lt;/city&gt;&lt;/person&gt; JSON: 경량 데이터 교환 민첩한 데이터 교환 형식인 JSON(JavaScript Object Notation)은 사람이 읽을 수 있고 기계 친화적입니다. 비동기식 브라우저/서버 통신에 널리 사용되며 API(Application Programming Interfaces)에서 널리 사용되는 JSON은 데이터 표현을 간소화합니다. 12345&#123; \"name\": \"hg Ko\", \"age\": 35, \"city\": \"Daejeon\"&#125; AJAX: 동적 웹 상호 작용 AJAX(Asynchronous JavaScript and XML)는 HTML, CSS, JavaScript, XML 및 JSON을 통합하는 기술입니다. 브라우저와 서버 간의 비동기식 데이터 교환을 용이하게 하여 전체 재로드 없이 동적 웹 페이지 업데이트를 가능하게 합니다. 다음은 AJAX가 실제로 작동하는 모습을 보여줍니다. 123456789// Example AJAX request using JavaScriptvar xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function () &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById('demo').innerHTML = this.responseText; &#125;&#125;;xhttp.open('GET', 'ajax-example.txt', true);xhttp.send(); 모든 것 종합하기 개발자는 구조를 위한 HTML, 데이터 표현을 위한 XML, 가벼운 데이터 교환을 위한 JSON을 결합하여 강력하고 동적인 웹 애플리케이션을 만들 수 있습니다. 비동기 통신을 통해 AJAX는 원활한 상호 작용을 보장하여 사용자 경험을 향상시킵니다. 결론 HTML, XML, JSON, AJAX는 웹 개발에서 각각 고유한 역할을 수행합니다. HTML은 콘텐츠를 구조화하고, XML은 데이터를 표현하며, JSON은 상호 교환을 용이하게 하며, AJAX는 역동성을 구현합니다. 웹 개발 여정을 시작할 때 이러한 기술을 숙지하는 것은 필수적입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"XML","slug":"XML","permalink":"http://hgko1207.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://hgko1207.github.io/tags/JSON/"},{"name":"AJAX","slug":"AJAX","permalink":"http://hgko1207.github.io/tags/AJAX/"},{"name":"디코딩","slug":"디코딩","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%BD%94%EB%94%A9/"}]},{"title":"인공 지능(AI)과 머신 러닝(ML) 활용하기","slug":"ai-3","date":"2023-12-22T14:03:24.000Z","updated":"2024-01-12T13:38:56.142Z","comments":true,"path":"2023/12/22/ai-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/22/ai-3/","excerpt":"","text":"소개 빠르게 발전하는 기술 환경에서 인공 지능(AI)과 머신 러닝(ML)은 게임 체인저로 등장하여 우리가 세상과 상호 작용하고 인식하는 방식에 혁명을 일으켰습니다. 효율성 향상부터 복잡한 문제 해결까지 AI와 ML의 융합은 산업을 재편하고 전례 없는 속도로 혁신을 주도하고 있습니다. 인공지능과 머신러닝의 이해 인공 지능은 우리가 &quot;스마트&quot;하다고 생각하는 방식으로 작업을 수행할 수 있는 기계의 광범위한 개념입니다. 반면 머신러닝은 명시적으로 프로그래밍하지 않고도 기계가 데이터를 통해 학습할 수 있도록 하는 AI의 하위 집합입니다. 이 두 가지를 함께 사용하면 시간이 지남에 따라 성능을 향상할 수 있는 지능형 시스템을 만들 수 있습니다. 정의 인공 지능(AI): AI는 일반적으로 인간의 지능이 필요한 작업을 수행할 수 있는 기계나 시스템을 만드는 것을 목표로 하는 컴퓨터 과학의 광범위한 분야입니다. 여기에는 문제 해결, 학습, 지각, 언어 이해 등 기계가 인간의 지능을 시뮬레이션할 수 있도록 설계된 다양한 기법, 접근 방식, 기술이 포함됩니다. 머신 러닝(ML): 머신 러닝은 컴퓨터가 명시적인 프로그래밍 없이 작업을 수행할 수 있도록 하는 알고리즘 및 통계 모델 개발에 중점을 두는 AI의 하위 집합입니다. 즉, 머신러닝을 통해 기계는 특정 작업에 대해 명시적으로 프로그래밍하지 않고도 데이터를 통해 학습하고 시간이 지남에 따라 성능을 향상시킬 수 있습니다. 산업 전반에 걸친 응용 분야 의료: AI와 ML은 개인 맞춤형 치료 계획부터 질병 조기 발견에 이르기까지 의료 분야에 큰 변화를 일으키고 있습니다. 머신러닝 알고리즘으로 구동되는 예측 분석은 의사가 정보에 입각한 의사 결정을 내리는 데 도움을 주어 생명과 자원을 절약합니다. 금융: 금융 부문에서는 AI와 ML이 리스크 관리, 사기 탐지, 고객 서비스를 최적화하고 있습니다. 머신러닝 모델을 기반으로 하는 알고리즘 트레이딩은 방대한 데이터 세트를 분석하여 순식간에 결정을 내리고 수익을 극대화합니다. 소매업: 맞춤형 추천, 공급망 최적화, 수요 예측이 소매업 환경을 변화시키고 있습니다. AI 기반 챗봇과 가상 비서는 고객 경험을 향상시켜 실시간 지원을 제공합니다. 자율주행차: 자동차 산업은 AI와 ML로 인해 패러다임 전환을 겪고 있습니다. 자율주행차는 이러한 기술을 활용하여 실시간 데이터를 해석하고 대응함으로써 보다 안전하고 효율적인 운송을 보장합니다. 교육: AI 기반의 적응형 학습 플랫폼은 학생 개개인의 요구를 충족하여 맞춤형 학습 경험을 제공합니다. 머신러닝 알고리즘은 학생 성과 데이터를 분석하여 개선이 필요한 영역을 파악하고 그에 따라 교육 콘텐츠를 맞춤화합니다. 새로운 트렌드와 기술 설명 가능한 AI(XAI): AI 시스템이 점점 복잡해짐에 따라 의사 결정 과정을 투명하고 이해하기 쉽게 만드는 것이 점점 더 강조되고 있습니다. XAI는 AI 알고리즘을 해석하고 신뢰할 수 있도록 보장하는 중요한 트렌드입니다 엣지 컴퓨팅: AI 및 ML을 엣지 컴퓨팅과 통합하면 데이터 소스에 더 가까운 곳에서 처리가 수행하여 대기 시간을 줄이고 실시간 의사 결정을 향상시킬 수 있습니다. 이는 IoT 장치 및 자율주행차와 같은 애플리케이션에 특히 중요합니다. 자연어 처리(NLP): NLP의 발전으로 기계는 인간과 유사한 언어를 이해하고 해석하며 생성할 수 있게 되었습니다. 이는 챗봇, 가상 비서 및 언어 번역 서비스의 혁신을 주도하고 있습니다. AI 윤리 및 편향성 완화: AI 시스템이 더욱 널리 보급됨에 따라 윤리적 문제를 해결하고 알고리즘의 편견을 완화하는 것이 무엇보다 중요해졌습니다. 책임감 있는 AI 개발 및 배포에 초점을 맞춘 이니셔티브가 주목을 받고 있습니다. 인공 지능(AI)과 머신 러닝(ML)은 밀접하게 관련된 개념이지만 컴퓨터 과학과 기술의 서로 다른 측면을 나타냅니다. 예시 인공 지능(AI): 가상 개인 비서(예: Siri 또는 Alexa), 게임 플레이 알고리즘(예: 체스나 바둑에 사용되는 알고리즘) 및 전문가 시스템이 AI 애플리케이션의 예입니다. 기계 학습(ML): 넷플릭스나 아마존에서 사용하는 것과 같은 추천 시스템, 이미지 및 음성 인식, 예측 분석은 머신 러닝 기술을 많이 사용하는 애플리케이션의 예입니다. 결론 인공 지능과 기계 학습은 지능형 시스템이 인간의 능력을 보조할 뿐만 아니라 증강하는 미래로 우리를 이끌고 있습니다. 혁신의 잠재력은 무한해 보이며, 이러한 기술이 달성할 수 있는 한계를 뛰어넘는 혁신이 끊임없이 이루어지고 있습니다. 이러한 기술적 한계를 탐색할 때 윤리적 고려 사항을 항상 경계하고 모든 사람이 AI 및 ML의 이점에 접근할 수 있도록 하는 것이 중요합니다. 혁신적인 기술의 잠재력을 최대한 활용하면서 다음 발전의 물결을 계속 지켜봐 주시기 바랍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ML","slug":"ML","permalink":"http://hgko1207.github.io/tags/ML/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hgko1207.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://hgko1207.github.io/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"}]},{"title":"최고의 무료 AI 이미지 생성기 살펴보기","slug":"ai-2","date":"2023-12-21T13:10:45.000Z","updated":"2024-01-08T00:44:27.832Z","comments":true,"path":"2023/12/21/ai-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/21/ai-2/","excerpt":"","text":"소개 디지털 콘텐츠 제작의 역동적인 영역에서 인공지능(AI) 이미지 생성기는 새로운 차원의 창의성을 발휘할 수 있는 강력한 도구로 부상했습니다. 그래픽 디자이너, 소셜 미디어 애호가 또는 시각적 콘텐츠를 향상시키고자 하는 사람 모두에게 AI 이미지 생성기의 세계는 흥미로운 가능성으로 가득합니다. 이 글에서는 아이디어를 멋진 비주얼로 손쉽게 변환할 수 있도록 도와주는 최고의 무료 AI 이미지 생성기 몇 가지를 소개합니다. Deep Dream Generator Deep Dream Generator로 초현실적인 여행을 떠나보세요. Google의 신경망으로 구동되는 이 도구는 평범한 이미지를 꿈같은 사이키델릭한 작품으로 바꿔줍니다. 다양한 필터와 스타일로 실험하면서 상상력을 발휘하여 독특하고 이색적인 비주얼을 만들어 보세요. Psychedelic은 주로 환각적인 경험을 일으키는 약물이나 물질을 가리키며, 이로 인해 감각이 왜곡되고 정신적으로 변화되는 경험을 의미합니다. 이러한 경험은 종종 색채, 모양, 패턴 등의 시각적 변화와 함께 음악이나 감각적인 자극에 대한 강한 반응을 포함합니다. https://deepdreamgenerator.com/ DALL-E by OpenAI OpenAI에서 개발한 AI 모델인 DALL-E와 함께 무한한 상상의 영역으로 들어가 보세요. 이 획기적인 이미지 생성기는 텍스트 설명을 기반으로 이미지를 생성하여 AI가 구현할 수 있는 한계를 뛰어넘습니다. 몇 가지 간단한 프롬프트만으로 신화 속 생물부터 미래 풍경까지 무엇이든 생성할 수 있습니다. https://openai.com/dall-e-2 Artbreeder Artbreeder를 사용하면 이미지를 혼합하고 변형하여 완전히 새로운 구성을 만들어 디지털 아티스트의 역할을 수행할 수 있습니다. 이 직관적인 플랫폼을 사용하면 색 구성표부터 얼굴 특징까지 작품의 모든 측면을 세밀하게 조정하여 시각적으로 멋지고 고도로 맞춤화된 이미지를 만들 수 있습니다. https://www.artbreeder.com/ RunwayML 다양한 AI 모델을 찾는 사람들에게 RunwayML은 보물창고와도 같습니다. 이 플랫폼은 다양한 크리에이티브 작업에 특화된 사전 학습된 모델을 호스팅합니다. 예술, 음악, 동영상 조작 등 어떤 작업을 하든 RunwayML은 최첨단 AI를 실험할 수 있는 사용자 친화적인 인터페이스를 제공합니다. https://runwayml.com/?ref=zguyun.com This Person Does Not Exist &quot;이 사람은 존재하지 않습니다.&quot;로 사실적이지만 완전히 가상의 얼굴을 만들어 보세요. GAN(Generative Adversarial Network)으로 구동되는 이 AI 이미지 생성기는 실존하지 않는 인물의 초상화를 제작합니다. 캐릭터 디자인부터 프로젝트에 미스터리한 느낌을 더하는 것까지 다양한 용도로 이 이미지를 사용하세요. https://this-person-does-not-exist.com/en 결론 AI 이미지 생성기의 시대가 열리면서 디지털 크리에이티브의 혁명이 시작되었고, 그 어느 때보다 더 쉽게 접근하고 흥미롭게 만들 수 있게 되었습니다. 아티스트, 디자이너, 콘텐츠 제작자 모두에게 이 무료 AI 이미지 생성기는 상상력을 발휘할 수 있는 놀이터를 제공합니다. 이러한 도구로 실험하고, 현실과 환상을 혼합하고, 디지털 영역에서 창의력을 마음껏 발휘하세요. 가능성은 무궁무진하며, 유일한 한계는 여러분의 창의력뿐입니다. 지금 바로 AI 기반 이미지 생성의 매혹적인 세계에 빠져보세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"Generative Ai Tools","slug":"Generative-Ai-Tools","permalink":"http://hgko1207.github.io/tags/Generative-Ai-Tools/"},{"name":"이미지 생성기","slug":"이미지-생성기","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%83%9D%EC%84%B1%EA%B8%B0/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"}]},{"title":"거절을 마스터하기: 좌절을 성공으로 바꾸는 가이드","slug":"etc-1","date":"2023-12-21T06:09:02.000Z","updated":"2024-01-09T06:08:16.451Z","comments":true,"path":"2023/12/21/etc-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/21/etc-1/","excerpt":"","text":"거절은 직장이나 개인적인 영역 모두에서 피할 수 없는 삶의 일부입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 어떤 상황에서든 거절을 당하면 감당하기 어려울 수 있습니다. 하지만 거절에 어떻게 대응하느냐에 따라 미래의 성공과 행복에 큰 영향을 미칠 수 있습니다. 다음은 전문성과 회복탄력성을 가지고 거절을 처리하는 방법에 대한 가이드입니다. 감정 수용하기 감정을 수용한다는 것은 거절에 대한 반응으로 발생하는 감정을 인정하고 받아들이는 것을 포함합니다. 감정을 억누르거나 피하지 말고 스스로 감정을 느끼고 처리할 수 있도록 하세요. 이 단계는 진정성과 자기 인식을 바탕으로 어려움을 헤쳐 나갈 수 있는 기반을 마련하기 때문에 감성 지능, 회복탄력성, 개인적 성장을 촉진하는 데 매우 중요합니다. 건설적인 피드백 구하기 건설적인 피드백을 구하는 것은 개인적, 직업적 발전을 위한 적극적인 접근 방식입니다. 여기에는 특히 거절을 당했을 때 귀중한 통찰력을 얻기 위해 다른 사람의 의견을 적극적으로 구하는 것이 포함됩니다. 피드백을 수용함으로써 개선이 필요한 부분을 파악하고, 기술을 연마하며, 궁극적으로 좌절을 성장의 기회로 바꿀 수 있습니다. 전문성 유지 전문성을 유지하는 것은 거절을 우아하게 처리하는 데 있어 핵심적인 요소입니다. 여기에는 부정적인 반응을 자제하고 침착하고 정중한 태도로 좌절에 대응하는 것이 포함됩니다. 전문적 기준을 유지함으로써 자신의 평판을 유지하고, 회복력을 키우며, 미래의 기회에 기여할 수 있는 긍정적인 인상을 남길 수 있습니다. 목표에 대한 성찰 목표를 되돌아보는 것은 거절을 극복하는 데 있어 중요한 단계입니다. 여기에는 좌절에 직면했을 때 목표를 재평가하고 재조정하기 위해 잠시 멈추는 것이 포함됩니다. 이러한 성찰적 과정은 자기 인식을 향상시킬 뿐만 아니라 전략적인 조정을 가능하게 하여 개인 및 직업적 성장의 진화하는 여정에서 목표가 탄력적으로 유지되고 적응할 수 있도록 해줍니다. 성장 마인드 기르기 성장 마인드를 키우는 것은 거절에 직면했을 때 회복력을 키우는 데 필수적입니다. 여기에는 도전이 학습과 발전의 기회라는 믿음을 키우는 것이 포함됩니다. 성장 마인드로 도전을 받아들임으로써 좌절을 학습 과정의 자연스러운 일부로 간주하여 더 강하게 회복하고 적응하며 개인 및 직업적 성공을 향한 여정에서 지속적으로 발전할 수 있습니다. 지원 시스템과 연결하기 지원 시스템과 연결하는 것은 거절을 극복하는 데 있어 중요한 전략입니다. 여기에는 격려와 조언, 가치 있는 관점을 제공할 수 있는 친구, 멘토, 동료에게 연락하는 것이 포함됩니다. 강력한 지원 네트워크를 구축함으로써 어려운 시기에 다른 사람들로부터 힘을 얻고 회복력을 키우며 개인 및 직업적 성장을 향한 여정을 더욱 원활하게 진행할 수 있습니다. 자기 관리에 집중하기 자기 관리에 집중하는 것은 거절에 대처하는 데 있어 가장 중요한 측면입니다. 여기에는 휴식과 원기 회복을 촉진하는 활동에 참여하여 정신적, 정서적 웰빙을 우선시하는 것이 포함됩니다. 좌절 속에서도 자신을 돌봄으로써 회복력을 유지하고, 관점을 되찾고, 새로운 균형 감각과 긍정성을 가지고 도전에 접근할 수 있습니다. 새로운 목표 설정 새로운 목표를 설정하는 것은 거절에 대한 능동적인 대응으로, 적응력과 앞으로의 추진력을 의미합니다. 여기에는 열망을 재평가하고, 목표를 구체화하며, 미래의 성공을 위한 과정을 계획하는 것이 포함됩니다. 새로운 목표를 향해 집중력과 에너지를 재분배함으로써 개인은 좌절을 성장과 회복력, 지속적인 개인 및 전문성 개발의 기회로 전환할 수 있습니다. 작은 승리 축하하기 작은 승리를 축하하는 것은 거절에 직면한 후 회복의 여정에서 중요한 요소입니다. 여기에는 그 과정에서 작은 성과라도 인정하고 감사하는 것이 포함됩니다. 이러한 점진적인 승리를 인정함으로써 사기를 높이고 동기를 유지하며 긍정적인 사고방식을 함양하여 지속적인 개인 및 직업적 성장을 위한 기반을 마련할 수 있습니다. 끈기 유지 끈기를 유지하는 것이 거절에 맞서 승리하는 열쇠입니다. 여기에는 좌절에도 불구하고 흔들리지 않는 결단력과 회복력을 유지하는 것이 포함됩니다. 확고한 사고방식을 수용함으로써 도전을 헤쳐나가고, 경험을 통해 배우고, 목표를 끈질기게 추구할 수 있습니다. 끈기는 개인을 궁극적인 성공의 길로 나아가게 하는 원동력이며, 좌절을 지속적인 성취를 위한 디딤돌로 바꿔줍니다. 결론 거절은 업무적 영역과 개인적 영역을 모두 아우르는 우리의 여정에서 피할 수 없는 측면입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 그 어떤 것이든, 문제는 거절을 피할 수 없는 상황에서 어떻게 대응하느냐에 달려 있습니다. 이 글은 거절에 직면했을 때 전문성과 회복력을 키우고 좌절을 미래의 성공으로 가는 디딤돌로 삼을 수 있는 실행 가능한 단계를 제시합니다. 거절의 복잡한 지형을 헤쳐 나가면서 감정을 수용하고, 피드백을 구하고, 전문성을 유지하고, 성장 마인드를 키우는 방법을 배워보세요. 거절은 끝이 아니라 지속적인 성장과 성취를 향한 변화의 단계임을 기억하세요.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://hgko1207.github.io/categories/ETC/"}],"tags":[{"name":"거절","slug":"거절","permalink":"http://hgko1207.github.io/tags/%EA%B1%B0%EC%A0%88/"},{"name":"좌절","slug":"좌절","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%EC%A0%88/"},{"name":"성공","slug":"성공","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EA%B3%B5/"},{"name":"긍정적인 생각","slug":"긍정적인-생각","permalink":"http://hgko1207.github.io/tags/%EA%B8%8D%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%9D%EA%B0%81/"},{"name":"Motivation","slug":"Motivation","permalink":"http://hgko1207.github.io/tags/Motivation/"},{"name":"동기부여","slug":"동기부여","permalink":"http://hgko1207.github.io/tags/%EB%8F%99%EA%B8%B0%EB%B6%80%EC%97%AC/"}]},{"title":"[React vs Vue.js] Vue.js가 React보다 좋을까?","slug":"web-2","date":"2023-12-20T14:05:21.000Z","updated":"2024-01-12T13:38:15.432Z","comments":true,"path":"2023/12/20/web-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/20/web-2/","excerpt":"","text":"소개 끊임없이 진화하는 웹 개발 환경에서 올바른 프런트엔드 프레임워크를 선택하는 것은 때로는 혼란스러울 수 있습니다. 특히 선택할 수 있는 js 프레임워크가 많은 경우에는 더욱 그렇습니다. 가장 유명한 js 프런트엔드 프레임워크는 다음과 같습니다. 1. React Facebook에서 개발하고 유지 관리합니다. Virtual DOM, 컴포넌트 기반 아키텍처 및 성능으로 유명합니다. 광범위하게 채택되어 방대한 커뮤니티와 생태계를 보유하고 있습니다. 많은 기업이 대규모 애플리케이션을 위해 선택했습니다. 2. Angular Google에서 개발하고 유지관리합니다. 양방향 데이터 바인딩, 종속성 주입 및 대규모 애플리케이션 기능으로 잘 알려진 포괄적인 프런트엔드 프레임워크입니다. 동적 웹 애플리케이션 구축을 위한 완벽한 솔루션을 제공합니다. 3. Vue.js 커뮤니티에서 유지 관리하는 오픈 소스 프레임워크입니다. 단순성, 통합 용이성, 완만한 학습 곡선으로 잘 알려져 있습니다. React 및 Angular와 유사한 기능을 제공하지만 보다 접근하기 쉬운 방식으로 제공됩니다. 고성능(React 보다 빠름) 개발 속도가 빠릅니다. 4. Svelte 오픈 소스 프런트엔드 프레임워크입니다. DOM을 직접 조작하는 매우 효율적인 명령형 코드로 컴포넌트를 컴파일하여 차별화됩니다. 간단한 구문을 제공하고 더 나은 성능을 목표로 합니다. 5. Ember.js 오픈 소스 프런트엔드 프레임워크입니다. 구성 원칙에 대한 규칙을 따르기 때문에 크고 복잡한 애플리케이션에 적합한 강력한 선택입니다. 강력한 템플릿 엔진과 데이터 레이어를 제공합니다. 6. Backbone.js 오픈 소스 JavaScript 프레임워크입니다. Model, View, Collection, Router에 중점을 두고 웹 애플리케이션을 구축하는 데 필요한 최소한의 구조를 제공합니다. 다른 라이브러리와 함께 사용하여 더 복잡한 애플리케이션을 만드는 데 자주 사용됩니다. 7. Meteor 웹 및 모바일 애플리케이션 구축을 위한 오픈 소스 플랫폼입니다. React, Angular, Vue.js와 같은 프런트엔드 프레임워크와 통합되어 풀스택 솔루션을 제공합니다. 실시간 데이터 업데이트와 개발 용이성으로 잘 알려져 있습니다. 자바스크립트 프레임워크 영역에서 가장 눈에 띄는 두 경쟁자는 React와 Vue.js입니다. 각각 고유한 장점과 단점이 있으며 이를 뒷받침하는 대규모 커뮤니티가 있습니다. 이 글에서는 개발자의 관점으로 React와 Vue.js 차이점, 인기, 성능을 분석하고 비교할 것입니다. React와 Vue.js의 차이점 React와 Vue.js는 모두 널리 사용되는 자바스크립트 프레임워크이지만 구문, 학습 곡선, 생태계, 상태 관리 등 여러 측면에서 차이가 있습니다. 현명한 선택을 위해서는 이러한 차이점을 이해하는 것이 필수적입니다. React vs Vue.js: 인기 콘테스트 인기도는 기술 채택에 중요한 역할을 하는 경우가 많습니다. 현재 트렌드와 사용 통계를 살펴보고 이 경쟁 구도에서 React와 Vue.js가 어떻게 경쟁하고 있는지에 대한 인사이트를 제공하겠습니다. Vue.js GitHub Stars: 204k GitHub Commits: 3.2k GitHub 기여자: 404 스택 오버플로에 대한 질문: 91.9k Live Websites: 2071k React GitHub Stars: 208k GitHub Commits: 14.8k GitHub 기여자: 1.5k 스택 오버플로에 대한 질문: 376.4k Live Websites: 2609k 여기서 React가 Vue.js보다 더 인기가 있다는 것을 분명히 알 수 있지만, 그렇다고 해서 Vue.js를 사용하는 사람이 전혀 없다는 것을 의미하지는 않습니다. Vue.js는 React보다는 조금 적지만 자체적으로 많은 팔로워와 프로젝트에서 채택되고 있습니다. 사용 방법 비교 Vue.js: 디렉티브(Directive)를 사용한 HTML 템플릿 Vue.js를 사용하면 개발자가 템플릿에서 HTML 구문을 사용할 수 있으므로 HTML에 익숙한 사람들이 쉽게 시작할 수 있습니다. 또한 Vue.js는 HTML 요소의 렌더링 및 동작을 조건부로 제어하기 위해 v-if, v-else, v-show 등과 같은 강력한 디렉티브를 제공합니다. 이 접근 방식은 프로세스를 단순화하며 특히 초보자에게 친숙합니다. 다음은 Vue.js 템플릿에서 v-if 사용법을 보여주는 간단한 예입니다. 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt; &lt;p v-if=\"showMessage\"&gt;This message will be shown if showMessage is true.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; showMessage: true &#125;; &#125;&#125;;&lt;/script&gt; React: JavaScript 통합이 포함된 HTML과 유사한 구조를 위한 JSX React는 개발자가 JavaScript 파일 내에서 HTML과 유사한 코드를 작성할 수 있게 해주는 구문 확장인 JSX를 활용합니다. 처음에는 기존 HTML과 다르게 보일 수 있지만 JSX는 HTML 구조와 매우 유사하며 JavaScript 표현식 및 로직과의 완벽한 통합이라는 이점을 제공합니다. 다음은 JSX와 함께 React를 사용하는 유사한 예입니다. 1234567891011121314import React, &#123; useState &#125; from 'react';const MyComponent = () =&gt; &#123; const [showMessage, setShowMessage] = useState(true); return ( &lt;div&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &#123;showMessage &amp;&amp; &lt;p&gt;This message will be shown if showMessage is true.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;;export default MyComponent; 이 예제에서 단락(&lt;p&gt;) 요소는 showMessage 상태가 true인 경우에만 렌더링됩니다. JSX는 JavaScript 표현식(예: {showMessage &amp;&amp; ...})을 통합하여 조건부로 렌더링을 제어합니다. React와 Vue.js 성능 비교 성능은 프런트엔드 프레임워크를 선택할 때 중요한 요소입니다. 렌더링 속도, 번들 크기, 최적화 기술 등 두 프레임워크의 성능 측면을 자세히 살펴보겠습니다. 렌더링 속도 Vue.js Vue.js는 무언가 변경될 때 화면을 빠르게 업데이트하는 데 능숙합니다. 마치 필요한 것만 업데이트하는 가장 효율적인 방법을 알아내는 스마트 시스템을 갖춘 것과 같습니다. React React는 또한 화면을 효율적으로 업데이트합니다. 가장 좋은 방법으로 업데이트하는 방법을 계획하는 스마트 비서와 같아서 모든 일이 원활하게 진행됩니다. 번들 크기 Vue.js Vue.js는 특히 &quot;범위가 지정된 슬롯(Scoped Slots)&quot;이라는 기능을 사용하여 파일 크기를 작게 유지하는 데 도움이 됩니다. 공간을 덜 차지하는 방식으로 물건을 정리하는 것과 같습니다. React React는 필요한 것을 골라서 사용할 수 있는 툴킷과 같습니다. 하지만 어떻게 사용하느냐에 따라 추가 도구를 추가할 수 있기 때문에 툴킷이 조금 더 커질 수 있습니다. 최적화 기술 Vue.js Vue.js에는 캐싱 및 효율적인 데이터 처리와 같이 작업 속도를 높일 수 있는 기본 제공 방법이 있습니다. 단축키를 사용하여 작업을 빠르게 완료하는 것과 같습니다. React React에는 암기 및 지연 로딩과 같이 더 빠르게 작동하도록 하는 트릭도 있습니다. 게임에서 필살기를 사용하여 진행 속도를 높이는 것과 같습니다. 간단히 말해서 Vue.js와 React는 모두 작업을 빠르고 효율적으로 수행하는 데 도움이 되는 스마트 비서와 같습니다. Vue.js는 번들 크기가 더 작고 조금 더 빠르며, React는 더 유연한 툴킷이며 대규모 프로젝트에 본질적으로 사용되는 확장성이 있습니다. 결론 프리랜서이거나 소규모 스타트업을 운영하고 있다면 개발 속도가 빠르고, 성능이 뛰어나며, 상용구 코드가 훨씬 적은 Vue.js가 최선의 선택입니다. 대규모 프로젝트를 수행하는 대기업이라면 상용구 코드가 더 많지만 코드베이스가 커짐에 따라 프로젝트를 더 쉽게 처리할 수 있는 JSX를 사용하는 것이 좋습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"}]},{"title":"열정 없이 돈만을 위해 프로그래밍에 입문하면 안되는 5가지 이유","slug":"info-7","date":"2023-12-19T12:58:52.000Z","updated":"2023-12-22T13:56:08.054Z","comments":true,"path":"2023/12/19/info-7/","link":"","permalink":"http://hgko1207.github.io/2023/12/19/info-7/","excerpt":"","text":"바보라도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있습니다. 훌륭한 프로그래머는 인간이 이해할 수 있는 코드를 작성합니다. — 마틴 파울러 프로그래밍은 열정과 헌신이 필요한 분야입니다. 높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍을 할 충분한 이유가 될 수는 없습니다. 열정 없이 돈만 보고 프로그래밍에 뛰어들면 안 되는 5가지 이유는 다음과 같습니다. 프로그래밍은 끊임없는 학습과 개선이 필요한 도전적인 분야입니다. 열정이 없으면 동기를 유지하고 최신 기술과 트렌드를 따라가는 것이 어려울 수 있습니다. 프로그래밍은 문제 해결 능력과 고정 관념에서 벗어나는 능력을 요구하는 창의적인 분야입니다. 열정이 없으면 복잡한 문제에 대한 혁신적인 솔루션을 찾기가 어려울 수 있습니다. 프로그래밍은 팀워크와 의사소통 능력이 필요한 협업 분야입니다. 열정이 없으면 다른 사람들과 함께 일하고 팀에 기여하기가 어려울 수 있습니다. 프로그래밍은 세심한 주의와 높은 수준의 정확성이 요구되는 분야입니다. 열정이 없으면 집중력을 유지하고 실수를 피하는 것이 어려울 수 있습니다. 프로그래밍은 스트레스가 많고 까다로울 수 있는 분야입니다. 열정이 없으면 압박감을 견디고 일과 삶의 균형을 유지하기 어려울 수 있습니다. 열정이 없으면 기능적일 뿐만 아니라 이해하고 유지 관리하기 쉬운 코드를 작성하기 어려울 수 있으며, 반면에 열정이 부족한 프로그래머는 경력이 단절될 수 있습니다. 최신 기술과 트렌드를 따라잡는 데 어려움을 겪을 수 있으며, 이로 인해 경력 성장과 기회가 제한될 수 있습니다. 또한 다른 사람들과 협업하는 데 어려움을 겪을 수 있으며, 이로 인해 팀에 기여하는 능력이 저하될 수 있습니다. 또한 열정이 부족한 프로그래머는 업무의 스트레스와 요구를 감당하기 어려워 번아웃과 일과 삶의 균형이 깨질 수 있습니다. 스티브 잡스는 이렇게 말했습니다. 일이 인생의 많은 부분을 차지하게 될 것이며, 진정으로 만족할 수 있는 유일한 방법은 자신이 훌륭한 일이라고 믿는 일을 하는 것입니다. 그리고 훌륭한 일을 할 수 있는 유일한 방법은 자신이 하는 일을 사랑하는 것입니다. 이 인용문은 프로그래밍에서 열정의 중요성과 그것이 어떻게 만족스럽고 성공적인 커리어로 이어질 수 있는지를 강조합니다. 결론적으로, 열정은 프로그래밍에서 중요한 요소이며 프로그래머의 경력에 큰 차이를 만들 수 있습니다. 열정적인 프로그래머는 항상 자신의 기술을 배우고 향상시키기 위해 노력하며, 이는 끊임없이 진화하는 분야에서 필수적인 요소입니다. 또한 복잡한 문제에 대한 혁신적인 솔루션을 개발하는 데 필요한 창의적이고 틀에 박힌 사고방식을 벗어날 수 있는 능력을 갖추고 있습니다. 따라서 사람들의 삶을 변화시킬 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다. 높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍에 도전할 충분한 이유가 될 수는 없습니다. 프로그래밍에는 창의력, 문제 해결 능력, 팀워크, 세부 사항에 대한 주의력, 스트레스 처리 능력이 필요합니다. 유명한 프로그래머 도널드 어빈 크누스(Donald Ervin Knuth)는 이렇게 말했습니다. 프로그래밍은 컴퓨터가 무엇을 하길 원하는지 다른 사람에게 알려주는 기술이다. 따라서 사람들의 삶에 변화를 가져올 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"열정","slug":"열정","permalink":"http://hgko1207.github.io/tags/%EC%97%B4%EC%A0%95/"}]},{"title":"MVC, MVVM, MVP 이해 및 비교","slug":"web-1","date":"2023-12-18T13:53:01.000Z","updated":"2024-01-12T13:37:07.525Z","comments":true,"path":"2023/12/18/web-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/18/web-1/","excerpt":"","text":"소개 소프트웨어 개발 세계에는 개발자가 모듈성, 유지 관리성 및 확장성을 촉진하는 방식으로 코드를 설계하고 구성하는 데 도움이 되는 다양한 아키텍처 패턴이 있습니다. 이러한 인기 있는 세 가지 패턴은 MVC(Model-View-Controller), MVVM(Model-View-ViewModel) 및 MVP(Model-View-Presenter)입니다. 이 글에서는 이러한 아키텍처 패턴의 세부 사항을 자세히 살펴보고 주요 원칙, 장점 및 사용 사례를 알아보겠습니다. Model-View-Controller(MVC) MVC는 소프트웨어 개발에서 가장 오래되고 가장 널리 사용되는 아키텍처 패턴 중 하나입니다. 다음 구성 요소로 구성됩니다. Model: 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 데이터 조작, 저장 및 검색을 관리합니다. View: 사용자에게 데이터를 표시하는 역할을 담당합니다. Model의 정보를 표시하고 사용자 입력을 처리합니다. Controller: Model과 View 사이의 중개자 역할을 합니다. View로부터 사용자 입력을 받아 이를 처리하고, Model을 업데이트하고 그에 따라 View를 새로 고칩니다. MVC의 장점 관심사를 명확하게 분리하여 코드를 더욱 유지 관리하고 테스트할 수 있게 만듭니다. 서로 다른 View가 동일한 Model 과 Controller를 사용할 수 있으므로 코드 재사용성이 향상됩니다. 병렬 개발을 지원하여 UI 디자이너와 개발자가 독립적으로 작업할 수 있습니다. 사용 사례 MVC는 Spring Framework, Ruby on Rails, Django 및 ASP.NET과 같은 웹 개발 프레임워크에서 일반적으로 사용됩니다. Model-View-ViewModel(MVVM) MVVM은 특히 복잡하고 데이터가 풍부한 애플리케이션의 맥락에서 MVC의 일부 제한 사항에 대한 대응으로 등장한 디자인 패턴입니다. MVVM은 다음 구성 요소로 구성됩니다. Model: MVC 모델과 유사하게 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. View: 사용자 인터페이스를 나타내지만 MVC보다 더 수동적입니다. ViewModel에 의해 노출된 속성 및 명령에 바인딩됩니다. ViewModel: View의 상태와 동작을 추상화하는 역할을 합니다. Model과 View 간의 통신을 중재하고 View가 바인딩하는 데이터와 명령을 노출합니다. MVVM의 장점 View 와 Model 간의 결합을 줄여 MVC보다 더 나은 관심사 분리를 촉진합니다. 데이터 바인딩을 촉진하여 기본 데이터가 변경될 때 UI 업데이트를 단순화합니다. ViewModel을 UI와 독립적으로 테스트할 수 있으므로 테스트 가능성이 향상됩니다. 사용 사례 MVVM은 클라이언트 측 애플리케이션, 특히 Angular, React, Vue.js 및 Xamarin과 같은 프레임워크에서 널리 사용됩니다. Model-View-Presenter(MVP) MVP는 관심사 분리에 초점을 맞추지만 MVC 및 MVVM과는 다른 방식으로 수행되는 또 다른 아키텍처 패턴입니다. 다음 구성 요소로 구성됩니다. Model: MVC 및 MVVM과 유사하며 애플리케이션의 데이터와 비즈니스 로직을 캡슐화합니다. View: 사용자 인터페이스를 나타내지만 MVVM의 View에 비해 더 활동적입니다. View는 사용자 입력을 Presenter에게 직접 전달합니다. Presenter: MVC의 Controller와 유사하게 Model과 View 사이의 중개자 역할을 합니다. 그러나 MVP에서는 View가 일반적으로 더 수동적입니다. MVP의 장점 Presenter는 UI 없이 쉽게 단위 테스트할 수 있으므로 높은 수준의 테스트 가능성을 제공합니다. 관심사를 명확하게 분리하고 UI와 애플리케이션 로직을 강력하게 구분하도록 권장합니다. 개발자가 Presenter 및 Model에서 작업하는 동안 UI 디자이너가 View에서 작업할 수 있으므로 병렬 개발이 용이합니다. 사용 사례 MVP는 특히 WinForms, WPF 및 GWT와 같은 기술을 사용하여 데스크톱 애플리케이션 개발에 일반적으로 사용됩니다. MVC, MVVM, MVP 비교 데이터 바인딩: MVVM은 데이터 바인딩에 탁월하므로 UI와 기본 데이터의 동기화를 더 쉽게 유지할 수 있습니다. MVC와 MVP는 수동 동기화가 필요합니다. 테스트 가능성: MVP와 MVVM은 애플리케이션의 로직을 별도로 테스트할 수 있기 때문에 MVC에 비해 더 나은 테스트 가능성을 제공합니다. 복잡성: MVC는 더 간단하고 소규모에서 중간 정도 복잡한 애플리케이션에 더 적합할 수 있는 반면, MVVM과 MVP는 더 크고 복잡한 프로젝트에서 빛을 발합니다. 학습 곡선: MVVM 및 MVP는 추가 구성 요소 및 개념으로 인해 학습 곡선이 더 가파르게 느껴질 수 있습니다. 플랫폼: 이러한 패턴 간의 선택은 플랫폼에 따라 달라질 수도 있습니다. MVC는 웹 개발과 관련되는 경우가 많고, MVVM은 클라이언트 측 애플리케이션에 널리 사용되고 MVP는 데스크톱 애플리케이션에 일반적으로 사용됩니다. 테스트 가능성(Testability)은 과학과 과학적 방법의 주요 측면입니다. 테스트 가능성에는 반증 가능성 또는 실현 불가능성 두 가지 구성 요소가 있습니다. 이는 가설에 대한 반례가 논리적으로 가능함을 의미합니다. 위키백과 결론 결론적으로 MVC, MVVM, MVP 중에서 선택하는 것은 특정 프로젝트 요구 사항, 팀 전문 지식, 개발 대상 플랫폼에 따라 달라집니다. 각 패턴은 강력하고 유지보수가 가능한 소프트웨어를 구축하는 데 필요한 관심사 분리(Separation of concerns), 모듈성(Modularity) 및 테스트 가능성(Testability)을 달성하기 위한 다양한 접근 방식을 제공합니다. 각 패턴의 원리와 장점을 이해하면 다음 소프트웨어 애플리케이션을 설계할 때 정보에 입각한 결정을 내리는 데 도움이 될 수 있습니다. 컴퓨터 과학에서 관심사 분리(Separation of concerns)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙으로, 각 부문은 개개의 관심사를 해결한다. 관심사란 컴퓨터 프로그램 코드에 영향을 미치는 정보의 집합이다. 위키백과","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"MVC","slug":"MVC","permalink":"http://hgko1207.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://hgko1207.github.io/tags/MVP/"}]},{"title":"[ChatGPT] 코딩에서 활용하기 위한 5가지 팁","slug":"chatgpt-3","date":"2023-12-16T05:49:03.000Z","updated":"2024-01-12T13:36:27.909Z","comments":true,"path":"2023/12/16/chatgpt-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/16/chatgpt-3/","excerpt":"","text":"ChatGPT는 매우 빠르게 개발자들의 필수 도구가 되었습니다. 우리 모두는 이 도구가 루프 생성이나 if 조건 등을 사용하는 작은 알고리즘 등 코딩의 사소한 작업을 잘 처리한다는 것을 알고 있습니다. 또한 최근 또는 새로운 주요 변경 사항이 있는 라이브러리에 대한 코드를 생성하거나 적절하게 설명되지 않은 복잡한 대규모 작업의 경우 약점이 있다는 것을 알 수 있습니다. 팁 코딩에서 ChatGPT를 더 잘 사용하기 위한 5가지 팁에 대해 알아보겠습니다. 질문을 작은 작업으로 나누고 한 번에 한 단계씩 점진적으로 추가하여 코드를 생성하도록 요청하세요. 이 접근 방식은 복잡한 코드 블록과 관련하여 더 나은 코딩 결과를 제공하고 오류를 줄이는 것으로 나타났습니다. 외부 라이브러리 등이 포함된 복잡한 작업에 특히 유용합니다. 가능한 한 구체적인 용어와 전문 용어를 사용하여 명확하고 상세하게 프롬프트를 작성하세요. 지식이 풍부한 웹 개발자와 대화하는 것처럼 ChatGPT와 대화하고 아이디어를 전달하는 데 사용할 모든 용어를 사용하세요. 프롬프트를 단순화하기 위해 기술 용어를 사용하는 것을 주저하지 마십시오. 외부 라이브러리의 경우 ChatGPT에 의해 생성되는 오래된 구문에 주의하세요. ChatGPT에 의해 생성된 외부 라이브러리 사용 코드에 이상한 오류가 표시되면 항상 이를 의심해 보세요. 이 경우 해당 라이브러리의 설명서를 확인하는 것이 좋습니다. 대규모 작업을 구현하기 위한 계획을 찾을 때는 ChatGPT에 코딩 문제와 프로젝트에 대한 개요를 제공하고 여러 가지 방법과 제안을 요청하는 것이 좋습니다. 이렇게 하면 머릿속에 떠오르지 않았던 아이디어를 떠올릴 수 있습니다. 생성된 코드에 대한 설명을 ChatGPT에 묻는 것을 게을리하지 마십시오. Chatgpt는 생성된 코드를 매우 잘 설명할 수 있으며 코드가 무엇을 하고 있는지 명확하게 알려줌으로써 생성된 코드의 버그를 더 빨리 해결하는 데 도움이 됩니다. 결론 ChatGPT가 개발자를 그렇게 빨리 대체할 수 있다고 믿지 않습니다. 그러나 프로그래밍의 낮은 수준 작업을 자동화하여 개발자가 단조롭고 지루한 부분을 맡길 수 있습니다. ChatGPT를 잘 활용하면 개발자의 업무 효율을 최소 2배 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"}]},{"title":"생성형 AI(Generative AI)의 미래","slug":"ai-1","date":"2023-12-15T01:41:28.000Z","updated":"2024-01-12T13:34:42.178Z","comments":true,"path":"2023/12/15/ai-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/15/ai-1/","excerpt":"","text":"소개 인공지능의 세계는 변혁의 시대를 맞이하고 있으며, 이 혁명의 중심에는 생성형 AI(Generative AI)가 있습니다. 이 고급 모델은 콘텐츠를 제작하고 복잡한 문제를 해결할 수 있는 힘을 가지고 있으며, 우리가 기술과 상호작용하는 방식과 그 가능성을 재정의하고 있습니다. 이 글에서는 생성형 AI의 현실감과 창의성 향상부터 윤리적, 환경적 영향에 이르기까지 생성형 AI의 미래에 대해 살펴볼 것입니다. 앞으로 펼쳐질 흥미진진한 여정에 대해 자세히 알아봅시다. 생성형 인공지능(generative artificial intelligence) 또는 생성형 AI(generative AI)는 프롬프트에 대응하여 텍스트, 이미지, 기타 미디어를 생성할 수 있는 일종의 인공지능(AI) 시스템이다. 생성형 AI는 입력 트레이닝 데이터의 패턴과 구조를 학습한 다음 유사 특징이 있는 새로운 데이터를 만들어낸다. 위키백과 현실감과 창의성 향상 생성형 AI는 많은 발전을 이루었지만 아직 시작에 불과합니다. 미래의 모델은 사실주의와 창의성의 경계를 넓혀 사실상 인간의 창조물과 구별할 수 없는 콘텐츠를 제작할 것입니다. 실제과 같은 텍스트, 이미지, 음악, 심지어 동영상을 생성하는 이러한 모델은 사람과 AI가 생성한 콘텐츠 사이의 경계를 계속해서 허물어뜨릴 것입니다. 다중 모드 기능 텍스트, 이미지, 오디오 등 다양한 데이터 유형을 동시에 원활하게 작업할 수 있는 AI 모델을 상상해 보세요. 이러한 다중 모드 기능은 이전에는 불가능하다고 여겨졌던 방식으로 내러티브에 생동감을 불어넣는 새로운 형태의 몰입형 스토리텔링을 가능하게 할 것입니다. 이야기 또는 '내러티브’란 어떤 사물이나 사실, 현상에 대하여 일정한 줄거리를 가지고 하는 말이나 글을 말한다. 문학에서 이야기는 배경, 인물, 구성, 이야기를 이루는 분위기인 톤으로 이루어진다. 위키백과 대규모 개인화 생성형 AI의 가장 유망한 측면 중 하나는 고도로 개인화된 경험을 대규모로 제공할 수 있는 잠재력입니다. 개별 학습 스타일에 맞춘 교육부터 개인 취향에 맞는 제품 추천에 이르기까지, 생성형 AI는 각 사용자의 고유한 요구 사항을 충족할 수 있습니다. 산업별 솔루션 맞춤형 생성 AI 모델은 의료, 금융, 교육, 제조 등 특정 산업을 위해 개발될 것입니다. 이러한 모델은 산업별 과제를 해결하여 전문가가 작업하고 문제를 해결하는 방식을 혁신을 가져올 것입니다. 인간과 기계의 협업 강화 생성형 AI는 인간을 대체하는 것이 아니라 오히려 인간의 능력을 보완할 것입니다. 인간과 AI 간의 효과적인 협업은 다양한 직업에서 표준이 되어 업무의 효율성을 높이고 새로운 가능성의 문을 열 것입니다. 콘텐츠 조정(Content Moderation) 및 검증 디지털 정보 시대에는 허위 정보와의 전쟁과 콘텐츠 무결성 유지가 매우 중요합니다. 생성형 AI는 콘텐츠 조정 및 사실 확인을 자동화하여 정확하고 신뢰할 수 있는 정보만 대중에게 전달되도록 하는 데 중요한 역할을 할 것입니다. 사용자에게 댓글을 게시하도록 요청하는 인터넷 웹사이트에서 콘텐츠 조정은 유용하거나 유익한 게시물과는 대조적으로 관련성이 없거나 외설적이거나 불법적이거나 유해하거나 공격적인 게시물을 감지하는 프로세스이며, 종종 반대 관점을 검열하거나 억제합니다. 위키백과 자연어 인터페이스 생성형 AI로 구동되는 고급 챗봇과 가상 비서는 보다 자연스럽고 인간과 유사한 대화 상호 작용을 제공할 것입니다. 사용자 경험과 고객 지원이 개선되면서 우리가 기술과 상호 작용하는 방식을 재정의할 것입니다. 예술과 디자인의 혁신 생성형 AI가 예술, 디자인, 건축의 경계를 허물면서 창조 산업에 혁명이 일어날 것입니다. 그리고 새로운 형태의 표현을 가능하게 하여 혁신과 창의성을 촉진할 것입니다. 음악 및 엔터테인먼트 생성형 AI로 생성된 음악, 영화 및 기타 형태의 엔터테인먼트가 더욱 보편화될 것입니다. 이는 완전히 새로운 장르와 경험의 출현으로 이어져 엔터테인먼트 세계에서 가능한 일의 지평을 넓힐 것입니다. 지속적인 학습과 자기 계발 미래의 생성형 AI 모델은 사람의 개입 없이도 새로운 데이터와 진화하는 트렌드에 적응하면서 지속적으로 학습할 수 있게 될 것입니다. 이를 통해 빠르게 변화하는 세계에서 관련성과 최신성을 유지할 수 있습니다. 책임감 있는 AI 개발 생성형 AI가 널리 보급됨에 따라 윤리적이고 책임감 있는 AI 개발에 대한 강조가 커질 것입니다. 회사와 연구자들은 AI가 사회 전체에 혜택을 줄 수 있도록 편견, 공정성, 투명성과 같은 문제를 해결하기 위한 보호 장치를 구현할 것입니다. 환경 고려 사항 AI의 에너지 소비는 우려의 대상이었지만 미래의 생성형 AI 모델은 환경의 지속 가능성을 염두에 두고 설계될 가능성이 높습니다. 탄소 배출량과 에너지 소비를 최소화하는 것이 최우선 과제가 될 것입니다. 법률 및 규제 프레임워크 생성형 AI가 우리 삶에 더욱 필수적인 요소가 되면서 지적 재산권, 개인정보 보호, 안전 문제를 해결하기 위한 법률 및 규제 프레임워크가 발전할 것입니다. 이러한 프레임워크는 AI가 책임감 있고 윤리적으로 사용되도록 보장할 것입니다. 과학적 발견 생성형 AI는 과학 연구에서 중추적인 역할을 하며 신약 개발, 재료 과학, 기후 모델링과 같은 분야의 발견을 가속화할 것입니다. 이는 연구자들이 방대한 양의 데이터를 처리하고 이전에 숨겨져 있던 패턴을 찾는 데 도움이 될 것입니다. 맞춤화 및 개인 비서 AI 개인 비서는 개별 사용자에게 더욱 맞춤화되어 지원뿐만 아니라 동반자 역할과 정서적 지원까지 제공할 것입니다. 이러한 개인적인 접촉은 인간과 AI 관계를 강화할 것입니다. 교육 생성형 AI는 개인화된 학습 경험을 제공하고, 교육 콘텐츠를 제작하고, 적응형 학습을 제공함으로써 교육에 혁명을 일으킬 것입니다. 이를 통해 학습의 몰입도와 효과를 높여 학생들이 필요한 교육을 받을 수 있게 될 것입니다. AI가 만들어낸 혁신 생성형 AI는 기술과 비즈니스의 경계를 허무는 새로운 아이디어, 발명품, 프로토타입을 생성하는 혁신의 원동력이 될 것입니다. 이는 오늘날 우리가 상상조차 할 수 없는 발전을 가져올 것입니다. 결론 생성형 AI의 미래는 엄청난 가능성을 갖고 있습니다. 이는 우리의 삶을 개선하고, 경제 성장을 촉진하며, 시급한 글로벌 과제를 해결할 수 있는 잠재력을 가지고 있습니다. 그러나 이는 생성형 AI가 계속 발전함에 따라 신중하게 고려하고 해결해야 할 윤리적, 사회적 문제도 제기되고 있습니다. 앞으로의 여정은 무한한 가능성으로 가득 차 있으며, 빠르게 변화하는 세상에서 생성형 AI가 선한 역할을 할 수 있도록 하는 것은 우리에게 달려 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Generative AI","slug":"Generative-AI","permalink":"http://hgko1207.github.io/tags/Generative-AI/"},{"name":"생성형 AI","slug":"생성형-AI","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%84%B1%ED%98%95-AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"}]},{"title":"[ChatGPT] 대화형 AI 활용","slug":"chatgpt-2","date":"2023-12-14T15:00:18.000Z","updated":"2023-12-23T15:12:58.255Z","comments":true,"path":"2023/12/15/chatgpt-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/15/chatgpt-2/","excerpt":"","text":"기술이 디지털 세계와 상호 작용하는 방식을 지속적으로 변화시키는 시대에 챗봇과 가상 비서는 인간과 컴퓨터의 상호 작용을 위한 강력한 도구로 등장했습니다. 이 분야의 최신 혁신 중에는 OpenAI가 개발한 최첨단 AI 모델인 ChatGPT가 있습니다. 이 글에서는 ChatGPT의 매혹적인 세계와 그 기능, 대화형 AI의 미래에 미치는 영향을 살펴봅니다. 챗봇과 가상 비서의 등장 챗봇(Chatbot)과 가상 비서(Virtual Assistant)는 처음부터 많은 발전을 이루었습니다. 처음에는 간단한 작업과 반복적인 쿼리를 위해 설계되었으나 인간과 유사한 텍스트를 이해하고 생성할 수 있는 매우 정교한 대화 에이전트로 발전했습니다. 오늘날 챗봇은 고객 서비스, 의료, 전자상거래, 엔터테인먼트 등 다양한 산업 분야에서 사용되고 있습니다. ChatGPT 소개 ChatGPT는 대화형 AI 세계에 탁월한 추가 기능을 제공합니다. GPT(Generative Pre-trained Transformer) 제품군의 일부로 개발된 이 제품은 이전 제품의 놀라운 자연어 이해 및 생성 기능을 물려받았습니다. ChatGPT는 의미 있는 대화에 사용자를 참여시키도록 설계되었으므로 다음을 포함한 광범위한 애플리케이션에 이상적인 후보입니다. 고객 지원: ChatGPT는 고객 문의 처리, 문제 해결, 지원을 연중무휴 24시간 제공하여 고객 만족도를 높일 수 있습니다. 콘텐츠 생성: 기사 초안 작성부터 마케팅 자료 작성까지 콘텐츠 생성을 지원하여 시간과 노력을 절약할 수 있습니다. 언어 번역: ChatGPT는 언어 간 텍스트를 번역하고 문화 간 의사소통을 촉진함으로써 언어 장벽을 허물 수 있습니다. 가상 교사: 맞춤형 학습 경험과 교육 지원을 제공하는 가상 교사 역할을 할 수 있는 잠재력이 있습니다. 대화형 캐릭터: 게임 개발자는 ChatGPT를 활용하여 역동적인 대화와 개성을 지닌 실물 같은 캐릭터를 만들 수 있습니다. ChatGPT 작동 방식 ChatGPT의 핵심은 딥 러닝 아키텍처입니다. 이 모델은 인터넷의 광범위한 텍스트 데이터세트를 통해 훈련되어 언어 패턴과 맥락을 학습할 수 있습니다. 사용자의 입력이 제공되면 ChatGPT는 입력과 해당 지식을 기반으로 가장 가능성이 높은 다음 단어를 예측하여 응답을 생성합니다. 맥락을 이해하고, 대화를 유지하며, 일관성 있고 맥락에 맞는 응답을 제공하는 모델의 능력이 ChatGPT를 차별화하는 요소입니다. 다양한 입력을 처리하고 다양한 대화 상황에 적응할 수 있어 다재다능하고 적응력이 뛰어납니다. ChatGPT를 통한 대화형 AI의 미래 ChatGPT는 대화형 AI 개발에 있어 중요한 도약을 의미합니다. 계속해서 개선되고 확장됨에 따라 우리는 예상할 수 있습니다. 향상된 고객 경험: ChatGPT가 제공하는 향상된 챗봇은 보다 효과적이고 개인화된 고객 상호 작용을 제공하여 고객 만족도와 충성도를 높입니다. 생산성 향상: 기업과 개인은 AI 기반 콘텐츠 생성, 자동화된 응답, 더 많은 작업을 수행할 수 있는 가상 비서의 이점을 누릴 수 있습니다. 원활한 다문화 커뮤니케이션: ChatGPT가 번역 및 언어 지원에 더욱 능숙해짐에 따라 언어 장벽이 더욱 낮아질 것입니다. 고급 교육 도구: 가상 교사와 맞춤형 학습 경험은 우리가 지식과 기술을 습득하는 방식에 혁명을 일으킬 것입니다. 몰입형 가상 세계: 게임 개발자는 ChatGPT 기반 캐릭터를 통해 더욱 몰입감 있고 대화형인 게임 경험을 만들 수 있습니다. 결론 ChatGPT는 대화형 AI 세계의 획기적인 발전입니다. 놀라운 기능, 다용성 및 적응성은 인간과 컴퓨터의 상호 작용이 더욱 자연스럽고 매력적인 미래를 위한 큰 가능성을 제시합니다. 고객 서비스를 개선하려는 기업, 지원이 필요한 콘텐츠 제작자, 사용자 경험을 향상시키려는 게이머 등 ChatGPT는 기술과 커뮤니케이션의 미래를 형성하는 데 중추적인 역할을 할 준비가 되어 있습니다. ChatGPT와 대화형 AI의 세계에서 앞으로 펼쳐질 흥미로운 발전에 계속 관심을 가져주세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"대화형 AI","slug":"대화형-AI","permalink":"http://hgko1207.github.io/tags/%EB%8C%80%ED%99%94%ED%98%95-AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"}]},{"title":"다중 장치(Multi-Device)를 위한 반응형 디자인","slug":"web-design-3","date":"2023-12-13T02:39:42.000Z","updated":"2024-01-12T13:32:37.381Z","comments":true,"path":"2023/12/13/web-design-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/13/web-design-3/","excerpt":"","text":"오늘날의 디지털 환경에서 웹 페이지는 대형 데스크톱 모니터부터 소형 스마트폰에 이르기까지 다양한 장치에서 액세스됩니다. 웹 사이트가 이러한 모든 장치에서 멋지게 보이고 원활하게 작동하는지 확인하는 것은 현대 웹 디자인의 기본 측면입니다. 반응형 디자인이 중요한 역할을 하는 곳이 바로 여기입니다. 반응형 디자인이란 무엇입니까? 반응형 디자인은 웹 페이지를 다양한 화면 크기와 장치에 맞게 적절하게 적용하는 것을 목표로 하는 웹 디자인 접근 방식입니다. 이는 웹 사이트가 데스크톱 컴퓨터, 태블릿, 휴대폰 중 어느 기기에서 보이든 상관없이 원활한 사용자에 보이는 것입니다. 반응형 디자인을 사용하면 모든 기기에서 콘텐츠에 액세스할 수 있을 뿐만 아니라 사용자 친화적이기도 합니다. 미디어 쿼리(Media Query)의 역할 미디어 쿼리는 반응형 디자인의 초석입니다. 이는 화면 너비나 높이와 같은 특정 조건에서 웹 페이지가 표시되는 방법을 지정하는 CSS 규칙입니다. 미디어 쿼리를 사용하면 사용 중인 장치의 특성에 따라 다양한 스타일을 적용하거나 레이아웃을 조정할 수 있습니다. 미디어 쿼리 이해 미디어 쿼리의 작동 방식과 미디어 쿼리를 사용하여 반응형 웹 페이지를 만드는 방법을 분석해 보겠습니다. 1.미디어 쿼리 정의 미디어 쿼리는 CSS 파일의 @media 규칙을 사용하여 정의됩니다. 기본 구조는 다음과 같습니다. 123@media screen and (max-width: 768px) &#123; /* 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */&#125; 이 예에서 미디어 쿼리는 최대 너비가 768픽셀인 화면을 대상으로 합니다. 2. 조건 설정 미디어 쿼리 내에서 and, or, not과 같은 논리 연산자를 사용하여 조건을 지정합니다. 화면 너비, 높이, 방향 등 다양한 측면을 타겟팅할 수 있습니다. 123@media screen and (max-width: 768px) and (orientation: portrait) &#123; /* 세로 모드에서 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */&#125; 3. CSS 규칙 적용 미디어 쿼리 블록 내에서 조건이 충족될 때 적용되는 특정 CSS 규칙을 적용할 수 있습니다. 예를 들어 글꼴 크기를 변경하고, margin과 padding을 조정하고, 요소(element)를 숨기거나 표시하고, 레이아웃을 재구성할 수도 있습니다. 123456@media screen and (max-width: 768px) &#123; /* 작은 화면에 맞게 글꼴 크기 조정 */ body &#123; font-size: 16px; &#125;&#125; 반응형 디자인 원칙 미디어 쿼리 외에도 반응형 웹 페이지를 디자인할 때 명심해야 할 몇 가지 기본 원칙이 있습니다. 모바일 우선 접근 방식: 가장 작은 화면 크기를 염두에 두고 디자인을 시작한 다음 점차적으로 더 큰 화면에 맞게 향상시키세요. 이를 통해 사이트는 모바일 사용자에게 최적화됩니다. 유연한 그리드: 콘텐츠가 다양한 화면 크기에 맞게 조정되도록 하려면 백분율 기반 또는 유연한 그리드를 사용하세요. CSS Grid와 Flexbox는 이러한 목적을 위한 강력한 도구입니다. 이미지 최적화: 화면 크기에 맞게 조정되는 반응형 이미지를 사용하고 지연 로딩을 고려하여 모바일 장치의 페이지 로드 시간을 개선합니다. 콘텐츠 우선순위 지정: 작은 화면에 맞춰 콘텐츠의 우선순위를 지정하고 재구성하세요. 중요한 정보는 쉽게 접근할 수 있어야 하며, 필수적이지 않은 요소는 숨기거나 압축할 수 있어야 합니다. 테스트: 다양한 장치와 브라우저에서 웹사이트를 정기적으로 테스트하여 의도한 대로 모양과 기능이 작동하는지 확인합니다. 에뮬레이터와 브라우저 개발자 도구는 테스트에 매우 유용할 수 있습니다. 결론 반응형 디자인은 더 이상 있으면 좋은 기능이 아니라 오늘날의 다중 장치(Multi-Device) 세계에서 필수적인 기능입니다. 미디어 쿼리를 이해하고 반응형 디자인 원칙을 따르면 다양한 장치와 화면 크기에 맞게 최적의 사용자 경험을 제공하는 웹 페이지를 만들 수 있습니다. 사용자는 스마트폰, 태블릿, 노트북, 데스크톱 등 무엇을 사용하든 웹사이트를 접근성 있고 사용자 친화적으로 만들기 위해 기울이는 노력에 감사할 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"다중 장치","slug":"다중-장치","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%EC%A4%91-%EC%9E%A5%EC%B9%98/"}]},{"title":"웹 개발자를 위한 CSS Flexbox 기술","slug":"web-design-2","date":"2023-12-12T05:07:36.000Z","updated":"2024-01-12T13:30:17.341Z","comments":true,"path":"2023/12/12/web-design-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/12/web-design-2/","excerpt":"","text":"CSS Flexbox에 대해 자세히 알아보고 개념을 설명하는 몇 가지 코드 예제를 살펴보겠습니다. CSS Flexbox란 무엇입니까? CSS Flexbox(Flexible Box Layout)는 크기를 알 수 없거나 동적인 경우에도 컨테이너 내의 공간을 분배하고 항목을 정렬하여 복잡한 레이아웃의 디자인을 단순화하는 1차원 레이아웃 모델입니다. Flexbox는 내비게이션 메뉴(Navigation Menu), 카드 레이아웃(Card Layout), 콘텐츠 배포(Content Distribution) 등 반응성이 뛰어나고 유연한 디자인을 만드는 데 특히 유용합니다. CSS Flexbox의 기본 개념 Flex Container: Flex 항목을 포함하는 요소를 “Flex Container”라고 합니다. Flex 컨테이너(Container)를 만들려면 display: flex; HTML 요소에 속성을 적용합니다. 123.flex-container &#123; display: flex;&#125; Flex Items: Flex Container의 직계 하위 항목을 &quot;Flex Items&quot;이라고 합니다. 이러한 항목은 div, text, image 또는 기타 컨테이너와 같은 모든 HTML 요소가 될 수 있습니다. 12345&lt;div class=\"flex-container\"&gt; &lt;div class=\"flex-item\"&gt;Item 1&lt;/div&gt; &lt;div class=\"flex-item\"&gt;Item 2&lt;/div&gt; &lt;div class=\"flex-item\"&gt;Item 3&lt;/div&gt;&lt;/div&gt; Flex Container 속성 Flex 컨테이너의 동작을 제어하기 위한 몇 가지 필수 속성은 다음과 같습니다. flex-direction: 주축(행 또는 열)의 방향을 지정합니다. justify-content: 주축을 따라 항목이 배포되는 방식을 결정합니다. align-items: 항목이 교차축을 따라 정렬되는 방식을 정의합니다. flex-wrap: 플렉스 항목이 여러 줄로 줄 바꿈 되어야 하는지 여부를 지정합니다. align-content: 컨테이너 내에서 여러 줄의 정렬을 제어합니다( flex-wrap 활성화된 경우). 예제 코드 이러한 개념 중 일부를 설명하기 위해 간단한 예제를 만들어 보겠습니다. 1234567891011121314.flex-container &#123; display: flex; flex-direction: row; /* 행에 배치된 항목(기본값) */ justify-content: space-between; /* 항목이 고르게 분포됨 */ align-items: center; /* 항목을 수직으로 중앙에 배치 */&#125;.flex-item &#123; flex: 1; /* 각 항목은 동일한 공간을 차지합니다. */ padding: 10px; text-align: center; background-color: #007bff; color: white;&#125; 이 코드에서는 flex-container는 세 개의 Flex 항목이 있는 Flex 컨테이너를 정의합니다. flex-direction: row;는 항목을 일렬로 정렬합니다. justify-content: space-between; 주축을 따라 항목을 균등하게 분배합니다. align-items: center; 교차축을 따라 항목을 수직으로 중앙에 배치합니다. CSS Flexbox의 이점 복잡한 레이아웃을 단순화합니다. 알 수 없거나 동적 콘텐츠 크기를 적절하게 처리합니다. float 및 위치 지정의 필요성이 줄어듭니다. 정렬 및 분포 제어가 향상됩니다. 반응형 웹 디자인을 지원합니다. 결론 CSS Flexbox는 유연하고 반응이 빠른 웹 레이아웃을 간단하게 만들 수 있는 강력한 레이아웃 모델입니다. 웹 개발자는 개념을 이해하고 CSS를 통해 적용함으로써 컨테이너 내 요소의 배열과 정렬을 정밀하게 제어할 수 있습니다. Flexbox는 웹 레이아웃 코드의 효율성과 가독성을 향상시켜 최신 웹 개발에서 매우 유용한 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://hgko1207.github.io/tags/Flexbox/"}]},{"title":"자바스크립트 성능 최적화 기술 익히기","slug":"js-dev-11","date":"2023-12-12T02:20:25.000Z","updated":"2023-12-25T14:26:12.521Z","comments":true,"path":"2023/12/12/js-dev-11/","link":"","permalink":"http://hgko1207.github.io/2023/12/12/js-dev-11/","excerpt":"","text":"빠르고 반응이 빠른 웹 애플리케이션을 만들려면 자바스크립트 실행 시간을 줄이는 것이 중요합니다. 자바스크립트는 강력하고 다재다능한 프로그래밍 언어이지만 제대로 최적화되지 않으면 웹 페이지 속도가 느려질 수 있습니다. 자바스크립트 코드를 실행하는 데 시간이 너무 오래 걸리면 사용자 경험이 느려지고 페이지 렌더링이 지연되며 이탈률이 증가할 수 있습니다. 따라서 원활한 사용자 경험을 보장하기 위해서는 자바스크립트 실행 시간을 최적화하는 것이 중요합니다. 전략 다음은 이를 달성하기 위한 몇 가지 전략입니다 자바스크립트 최소화 및 압축: 불필요한 코드를 제거하고 축소 및 압축 도구를 사용하여 웹페이지가 로드되는 자바스크립트 양을 줄입니다. 축소 및 압축된 자바스크립트 파일은 크기가 더 작으므로 다운로드가 더 빠르고 실행 시간이 단축됩니다. 비동기 로딩: 가능하면 자바스크립트 파일을 비동기식으로 로드하세요. 이렇게 하면 웹페이지의 다른 요소들이 자바스크립트와 동시에 로드되어 장기 실행 스크립트에 의해 차단되는 것을 방지할 수 있습니다. 로딩 연기: 중요한 렌더링 경로가 완료될 때까지 필수적이지 않은 자바스크립트 로딩을 연기합니다. 이렇게 하면 웹페이지가 처음에 더 빠르게 로드되고 브라우저가 덜 바쁠 때 자바스크립트를 실행할 수 있습니다. 지연 로딩: 페이지 로드 시 즉시 필요하지 않은 자바스크립트 모듈에 대한 지연 로딩(Lazy Loading)을 구현합니다. 이는 대용량 자바스크립트 파일이나 특정 사용자 상호 작용에만 필요한 파일에 특히 유용합니다. 코드 분할: 자바스크립트 코드를 더 작고 관리하기 쉬운 모듈로 분할하세요. 현재 사용자 경험에 필요한 모듈만 로드합니다. 이렇게 하면 초기 실행 시간이 줄어들고 시스템 리소스 사용이 최소화됩니다. 루프 및 반복 최적화: 자바스크립트 코드 내의 루프(Loop) 및 반복(Iteration)에 주의를 기울이십시오. 비효율적인 루프는 실행 시간을 크게 늘릴 수 있습니다. 특정 사용 사례에 최적화된 알고리즘과 데이터 구조를 사용하세요. DOM 조작을 줄이세요: DOM(Document Object Model)을 과도하게 조작하면 심각한 병목 현상을 일으킬 수 있습니다. DOM에 대한 불필요한 업데이트를 최소화하고 일괄 처리 및 requestAnimationFrame과 같은 기술을 사용하여 애니메이션과 Transition을 원활하게 하세요. 캐싱: 자주 변경되지 않는 데이터와 계산을 저장하는 캐싱 메커니즘을 구현하세요. 캐싱은 반복적인 자바스크립트 실행의 필요성을 줄여 성능을 향상시킬 수 있습니다. Web Worker 사용: 계산 집약적인 작업을 Web Worker에게 오프로드합니다. Web Worker를 사용하면 메인 스레드를 차단하지 않고 백그라운드에서 스크립트를 실행할 수 있으므로 자바스크립트가 사용자 상호 작용에 영향을 미치는 것을 방지할 수 있습니다. 프로파일링 및 최적화: 브라우저 개발자 도구를 활용하여 자바스크립트 코드를 프로파일링하고 성능 병목현상을 파악하세요. Chrome 개발자도구와 같은 도구는 코드 실행 시간과 메모리 사용량을 분석하는 기능을 제공하므로 개선이 필요한 부분을 정확히 찾아내는 데 도움이 됩니다. CDN 호스팅: CDN(Content Delivery Network)을 사용하여 널리 사용되는 라이브러리 및 프레임워크를 호스팅하세요. CDN은 이러한 리소스를 보다 효율적으로 제공하여 다운로드 및 실행에 필요한 시간을 단축할 수 있습니다. ES6 이상 사용: 최신 ECMAScript 기능과 최적화를 활용하세요. 최신 자바스크립트 버전에는 성능이 향상되고 코드를 간소화하는 데 도움이 되는 새로운 기능이 포함되는 경우가 많습니다. 테스트 및 벤치마킹: 정기적으로 웹 애플리케이션의 성능을 테스트하고 벤치마킹 도구를 사용하여 실행 시간을 측정하세요. 이를 통해 회귀를 감지하고 변경 사항이 자바스크립트 실행에 미치는 영향을 모니터링할 수 있습니다. 이미지(Image) 및 자산(Asset) 최적화: 웹 애플리케이션에 사용되는 이미지 및 자산의 크기를 줄이면 전체 로딩 프로세스의 속도를 높여 자바스크립트 실행 시간을 간접적으로 개선할 수 있습니다. 콘텐츠 전달 전략: 장치 및 네트워크 상태에 따라 사용자에게 다양한 자바스크립트 번들을 제공하는 등 스마트한 콘텐츠 전달 전략을 구현하세요. 이를 통해 사용자는 자신의 상황에 가장 최적화된 코드를 받을 수 있습니다. 결론 자바스크립트 실행 시간 최적화는 지속적으로 해야하며 높은 수준의 성능을 유지하려면 전략 실행, 도구(Tool) 사용 및 지속적인 관심이 필요합니다. 이러한 기술을 사용하고 웹 애플리케이션의 성능을 지속적으로 모니터링하면 자바스크립트 코드가 효율적으로 실행되어 더 나은 사용자 경험을 제공할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"}]},{"title":"반응형 웹 디자인을 사용해야 하는 10가지 이유","slug":"info-6","date":"2023-12-11T05:28:33.000Z","updated":"2023-12-21T14:07:38.017Z","comments":true,"path":"2023/12/11/info-6/","link":"","permalink":"http://hgko1207.github.io/2023/12/11/info-6/","excerpt":"","text":"전 세계가 점점 더 모바일화됨에 따라 반응형 웹 디자인의 중요성은 아무리 강조해도 지나치지 않습니다. 반응형 디자인은 웹 사이트를 보는 데 사용되는 기기의 화면 크기에 맞게 웹 사이트가 조정되도록 하는 웹 디자인 접근 방식입니다. 즉, 데스크톱 컴퓨터, 태블릿, 스마트폰 등 어떤 기기에서 사이트를 탐색하든 최적의 보기 환경을 제공합니다. 이 글에서는 반응형 웹 디자인 사용을 고려해야 하는 10가지 이유를 살펴봅니다. 1. 사용자 경험 개선 반응형 웹 디자인은 사용자가 웹사이트에 액세스하는 기기에 관계없이 일관된 경험을 할 수 있도록 합니다. 따라서 사용자가 사이트를 더 쉽게 탐색하고 원하는 정보를 쉽게 찾을 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 사이트에 더 오래 머무르고 콘텐츠에 더 많이 참여할 가능성이 높아집니다. 2. 모바일 트래픽 증가 점점 더 많은 사람들이 스마트폰을 사용하여 인터넷에 접속하기 때문에 모바일 기기에 최적화된 웹사이트를 만드는 것이 중요합니다. 반응형 디자인은 모든 화면 크기에서 웹사이트가 멋지게 보이도록 하여 모바일 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성을 높입니다. 3. 더 나은 SEO Google 및 기타 검색 엔진은 반응형 디자인이 적용된 웹사이트가 더 나은 사용자 경험을 제공하기 때문에 우선순위를 둡니다. 즉, 웹사이트가 반응형이면 검색 엔진 결과 페이지(Search Engine Results Pages, SERPs)에서 더 높은 순위를 차지할 가능성이 높아져 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도할 수 있습니다. 4. 이탈률 감소 이탈률은 한 페이지만 보고 웹사이트를 떠나는 방문자의 비율을 말합니다. 반응형 웹 디자인은 더 나은 사용자 경험을 제공하여 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성이 높아지므로 이탈률을 낮추는 데 도움이 될 수 있습니다. 5. 더 빠른 웹사이트 로딩 시간 반응형 웹사이트는 동일한 콘텐츠의 여러 버전을 로드할 필요가 없기 때문에 일반적으로 비반응형 웹사이트보다 로딩 속도가 빠릅니다. 즉, 사용자가 느린 로딩 시간에 불만을 품고 사이트를 떠날 가능성이 줄어듭니다. 6. 손쉬운 유지 관리 반응형 웹사이트를 사용하면 사이트의 한 버전만 유지 관리하면 됩니다. 따라서 여러 버전의 사이트를 변경할 필요가 없으므로 콘텐츠를 업데이트하고 사이트를 변경하기가 더 쉬워집니다. 7. 비용 효율적 반응형 웹 디자인은 모든 기기에서 작동하는 하나의 버전의 웹 사이트만 만들면 되기 때문에 비용 효율적입니다. 즉, 여러 버전의 사이트를 만들거나 별도의 사이트 버전을 유지 관리하는 데 비용을 들일 필요가 없습니다. 8. 미래 보장 반응형 웹 디자인을 사용하면 웹 사이트는 시장에 출시되는 모든 새로운 장치에 대비할 수 있습니다. 즉, 새로운 기기가 대중화되어 사이트가 구식이 될까 봐 걱정할 필요가 없습니다. 9. 더 나은 분석 반응형 웹사이트를 사용하면 모든 기기에서 사용자 행동을 추적할 수 있습니다. 즉, 사용자가 사이트와 상호 작용하는 방식을 더 잘 이해하고 데이터에 기반한 의사 결정을 통해 사용자 경험을 개선할 수 있습니다. 10. 경쟁 우위 마지막으로 반응형 웹사이트는 경쟁 우위를 확보할 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 다른 사람에게 사이트를 추천할 가능성이 높아집니다. 이는 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도하는 데 도움이 될 수 있습니다. 결론 결론적으로 반응형 웹 디자인은 훌륭한 사용자 경험을 만들고 웹사이트의 가시성을 높이고자 하는 모든 사람에게 필수적입니다. 웹사이트가 모든 기기에서 멋지게 보이도록 하면 더 많은 방문자를 유치하고 참여도를 높이며 더 많은 전환을 유도할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"반응형 웹","slug":"반응형-웹","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"}]},{"title":"ChatGPT란 무엇인가요? ChatGPT로 어떻게 돈을 벌까?","slug":"chatgpt-1","date":"2023-12-06T13:52:22.000Z","updated":"2024-01-12T13:29:17.913Z","comments":true,"path":"2023/12/06/chatgpt-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/06/chatgpt-1/","excerpt":"","text":"ChatGPT는 다양한 질문에 답하고 사람들과 대화할 수 있도록 설계된 AI 기반 언어 모델입니다. AI 언어 모델로서 ChatGPT는 돈을 벌거나 금융 거래에 참여할 수 있는 능력이 없습니다. 하지만 ChatGPT를 사용하여 잠재적으로 수익을 창출할 수 있는 방법이 있습니다. 다음은 몇 가지 아이디어입니다. 사업 아이디어 조사 창업을 고려하고 있다면 ChatGPT를 사용하여 잠재적인 사업 아이디어를 조사할 수 있습니다. ChatGPT는 시장 동향, 소비자 행동 및 업계 모범 사례에 대한 통찰력을 제공할 수 있습니다. 잠재적인 사업 아이디어에 대해 ChatGPT에 질문을 하면 실행 가능하고 수익성 있는 옵션인지 더 잘 파악할 수 있습니다. 비즈니스를 위한 챗봇 구축하기 챗봇은 기업이 고객과 소통하고 고객 서비스 업무를 자동화하는 방법으로 점점 더 인기를 얻고 있습니다. 비즈니스에 챗봇을 구축하려는 경우 ChatGPT를 사용하여 매력적이고 유용한 대화형 인터페이스를 만들 수 있습니다. ChatGPT는 챗봇이 고객 문의에 응답하고 유용한 정보를 제공하도록 훈련시켜 고객 만족도를 높이고 판매를 촉진하는 데 도움이 될 수 있습니다. 글쓰기 실력 향상하기 작가나 콘텐츠 제작자라면 ChatGPT를 사용하여 글쓰기 실력을 향상할 수 있습니다. ChatGPT는 콘텐츠에 대한 아이디어를 생성하고, 글쓰기에 대한 피드백을 제공하며, 글쓰기 스타일을 개선할 수 있는 방법을 제안할 수 있습니다. ChatGPT를 사용하여 글쓰기 기술을 개선하면 잠재적으로 더 많은 고객을 유치하고 더 많은 수익을 올릴 수 있습니다. 새로운 기술 배우기 ChatGPT는 새로운 기술을 배우기 위한 도구로도 사용할 수 있습니다. 특정 주제나 관심 분야에 대해 ChatGPT에 질문할 수 있으며 관련 정보와 리소스를 제공받을 수 있습니다. ChatGPT를 통해 새로운 기술을 배우면 잠재적으로 취업 가능성을 높이거나 현재 직업에서 더 많은 돈을 벌 수 있습니다. 시간 절약하기 마지막으로, 많은 조사나 수작업이 필요한 작업의 시간을 절약하기 위해 ChatGPT를 사용할 수 있습니다. 예를 들어, 특정 주제에 대한 정보를 찾아야 하는 경우 인터넷 검색에 시간을 소비하는 대신 ChatGPT에 물어볼 수 있습니다. ChatGPT를 사용하여 워크플로우를 간소화하면 잠재적으로 수입을 창출하는 작업에 집중할 수 있는 시간을 더 많이 확보할 수 있습니다. 결론 결론적으로, ChatGPT 자체는 돈을 벌 수 있는 기능이 없지만, 잠재적으로 더 많은 돈을 벌 수 있는 방법이 있습니다. 연구, 글쓰기, 학습 및 자동화를 위한 기능을 활용하여 비즈니스 또는 경력 전망을 개선하고 재정적 목표를 달성할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"아이디어","slug":"아이디어","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"}]},{"title":"차세대 웹 앱을 위한 인기있는 상위 10개 Angular 라이브러리","slug":"angular-32","date":"2023-12-04T02:44:19.000Z","updated":"2024-01-12T13:28:47.078Z","comments":true,"path":"2023/12/04/angular-32/","link":"","permalink":"http://hgko1207.github.io/2023/12/04/angular-32/","excerpt":"","text":"차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것은 어려운 작업일 수 있습니다. 사용 가능한 옵션이 너무 많기 때문에 프로젝트에 가장 적합한 라이브러리를 결정하기가 어려울 수 있습니다. 하지만 프로젝트의 규모, 앱의 복잡성, 필요한 기능 등의 요소를 고려하면 선택의 폭을 좁히고 정보에 입각한 결정을 내릴 수 있습니다. 또한 라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려하는 것도 중요합니다. 이 글에서는 사용 가능한 라이브러리에 대한 개요와 프로젝트에 적합한 라이브러리를 선택할 때 고려해야 할 요소에 대해 설명합니다. Angular 무엇입니까? Angular는 Google에서 개발하고 유지 관리하는 오픈 소스 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션에서 자주 사용되는 구성 요소와 함께 클라이언트 측 MVC(Model-View-Controller) 및 MVVM(Model-View-View Model) 아키텍처를 위한 프레임워크를 제공함으로써 단일 페이지 애플리케이션을 구성하는 데도 사용되며 개발 및 테스트를 보다 쉽게 수행할 수 있도록 설계되었습니다. Angular 애플리케이션을 빌드할 때는 프로젝트의 성공을 보장하기 위해 올바른 라이브러리와 프레임워크를 선택하는 것이 중요합니다. 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하려면 필요한 기능, 프로젝트의 규모와 복잡성, 학습 및 구현에 투자해야 하는 시간 등을 신중하게 고려해야 합니다. 신뢰할 수 있고, 지원이 잘 제공되며, 정기적으로 업데이트되는 라이브러리를 선택하는 것이 중요합니다. 또한 서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택하는 것도 중요합니다. 시간을 들여 사용 가능한 라이브러리를 조사하고 비교하면 프로젝트에 적합한 라이브러리를 선택할 수 있습니다. 올바른 Angular 라이브러리를 선택하는 방법은 무엇입니까? 라이브러리를 선택할 때 고려해야 할 몇 가지 중요한 요소가 있습니다. 웹 앱에 필요한 기능을 고려합니다. 프로젝트의 규모와 복잡성을 평가합니다. 라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려합니다. 신뢰할 수 있고, 지원이 잘 되며, 정기적으로 업데이트되는 라이브러리를 선택합니다. 서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택합니다. 사용 가능한 라이브러리를 조사하고 비교하여 프로젝트에 적합한 라이브러리를 선택해야 합니다. Angular 웹 애플리케이션을 개발할 때 사용할 수 있는 몇 가지 인기 있는 라이브러리가 있습니다. 각 라이브러리에는 고유한 기능과 장점이 있으므로 프로젝트에 가장 적합한 라이브러리를 선택하는 것이 중요합니다. 다음은 가장 인기 있는 Angular 라이브러리 중 일부입니다. Angular Material GitHub Stars: 23.2k License: MIT Angular Material은 사용자 인터페이스 디자인을 위한 다양한 컴포넌트를 제공하는 Angular 애플리케이션용 UI 컴포넌트 라이브러리입니다. Google의 Material Design 언어를 기반으로 하며 반응형 및 접근성 높은 웹 애플리케이션을 만드는 데 사용됩니다. Material Design 시스템을 기반으로 재사용 가능하고 충분한 테스트를 거친 접근 가능한 UI 컴포넌트 세트를 제공합니다. 또한 Angular Material은 광범위한 테마 시스템을 제공하여 개발자가 웹 애플리케이션의 모양과 느낌을 쉽게 커스터마이징할 수 있습니다. Angular Material 라이브러리의 주요 기능은 다음과 같습니다. Material 디자인 시스템을 기반으로 재사용 가능하고 잘 테스트되었으며 액세스 가능한 UI 컴포넌트 세트입니다. 직관적이고 효율적인 방법으로 현대적인 대화형 웹 앱을 제작할 수 있습니다. 웹 앱의 모양과 느낌을 쉽게 커스터마이징 할 수 있는 광범위한 테마 시스템입니다. 완벽하게 반응하는 디자인으로 웹 앱이 모든 기기에서 멋지게 보입니다. 방대한 문서화 및 지원을 통해 필요한 경우 쉽게 도움을 받을 수 있습니다. button, card, input field, slider 등과 같은 구현하기 쉬운 컴포넌트입니다. AngularFire GitHub Stars: 7.5k License: MIT AngularFire는 Firebase 실시간 데이터베이스와 상호 작용하기 위한 사용하기 쉬운 API를 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 데이터 동기화, 인증 등과 같은 실시간 기능을 웹 앱에 더 쉽게 추가할 수 있도록 설계되었습니다. 또한 개발자가 Cloud Storage, Cloud Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스할 수 있는 인터페이스를 제공합니다. AngularFire는 개발자가 실시간 기능을 갖춘 웹 앱을 보다 쉽게 ​​구축할 수 있도록 하는 다양한 기능을 제공합니다. Firebase 실시간 데이터베이스와 상호작용하기 위한 사용하기 쉬운 API입니다. 여러 클라이언트에서 데이터의 실시간 동기화를 지원합니다. 사용자가 앱에 쉽게 가입하고 로그인할 수 있는 인증 시스템을 제공합니다. Cloud Storage, Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스합니다. 개발자가 프로젝트를 빠르게 시작하고 실행할 수 있는 간단하고 직관적인 인터페이스입니다. Angular, React, Vue 등 다양한 플랫폼을 지원합니다. Angular CLI GitHub Stars: 26.4k License: MIT Angular CLI는 Angular 애플리케이션을 생성, 구축 및 배포하기 위한 명령줄(Command line) 인터페이스입니다. 개발자가 앱을 빠르게 생성, 빌드 및 배포할 수 있도록 설계되었습니다. 새 프로젝트를 빠르게 설정할 수 있는 직관적인 스캐폴딩 시스템을 제공하며 라우팅, 테스트 및 컴포넌트와 같은 일반적인 작업을 위한 코드를 생성합니다. 또한 개발자는 한 번의 명령으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다. Angular CLI 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션을 생성, 구축, 배포하기 위한 명령줄 인터페이스입니다. 새로운 프로젝트를 빠르게 설정하기 위한 직관적인 스캐폴딩 시스템을 제공합니다. 라우팅, 테스트, 컴포넌트 등 일반적인 작업을 위한 코드를 생성합니다. 명령 한 번으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다. 다양한 타사 라이브러리를 지원하여 다른 도구와 프레임워크를 쉽게 통합할 수 있습니다. 개발자가 프로젝트를 빠르게 설정하는 데 도움이 되는 다양한 도구와 명령을 제공합니다. Angular UI Bootstrap GitHub Stars: 14.3k License: MIT Angular UI Bootstrap은 Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트를 제공하는 라이브러리입니다. 개발자가 반응형 모바일 친화적인 웹 애플리케이션을 더 쉽게 만들 수 있도록 설계되었습니다 Angular UI Bootstrap 라이브러리의 주요 기능은 다음과 같습니다. Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트입니다. 반응성이 뛰어나고 모바일 친화적인 웹 애플리케이션을 만들 수 있습니다. alert, button, carousel 등과 같은 다양한 컴포넌트를 사용하여 시각적으로 매력적인 대화형 사용자 인터페이스를 만들 수 있습니다. 웹 애플리케이션에 쉽게 통합할 수 있는 사전 구축된 컴포넌트입니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 시각적으로 매력적인 대화형 사용자 인터페이스를 만드는 직관적이고 효율적인 방법입니다. Angular Flex Layout GitHub Stars: 5.9k License: MIT Angular Flex-Layout은 Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공하는 라이브러리입니다. 개발자가 기기나 화면 크기에 관계없이 유연하고 반응이 빠른 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다. Angular Flex-Layout 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공합니다. fxLayout 및 fxFlex와 같은 다양한 Directive를 사용하여 유연하고 반응이 빠른 레이아웃을 만들 수 있습니다. 맞춤형 반응형 레이아웃 및 컴포넌트를 생성하기 위한 API입니다. 레이아웃 크기와 중단점을 쉽게 관리하는 기능을 제공합니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 개발자가 유연하고 반응이 빠른 사용자 인터페이스를 만들 수 있습니다. NgRx GitHub Stars: 7.8k License: MIT NgRx는 복잡한 애플리케이션에서 데이터를 관리하기 위한 상태 관리 시스템을 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 애플리케이션을 보다 쉽게 ​​생성, 유지 관리 및 테스트할 수 있도록 설계되었습니다. NgRx 라이브러리의 주요 기능은 다음과 같습니다. 복잡한 애플리케이션의 데이터를 관리하기 위한 상태 관리 시스템을 제공합니다. 예측 가능하고 일관되게 데이터를 관리하기 위한 API 및 도구 세트입니다. 애플리케이션 상태 업데이트를 쉽게 관리하기 위한 직관적인 인터페이스입니다. 상태 변경을 추적하고 추적하기 위한 강력한 디버깅 도구입니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 애플리케이션을 더욱 쉽게 생성, 유지 관리 및 테스트할 수 있습니다. Angular Charts GitHub Stars: 2.3k License: MIT Angular Charts 라이브러리는 Angular 팀에서 만든 오픈 소스 라이브러리로, Angular 애플리케이션에서 대화형 차트를 만들기 위한 선언형 API를 제공합니다. 선형, 막대형, 영역형, 원형, 도넛형, 분산형 차트를 포함한 다양한 차트 유형을 지원합니다. 또한 스타일과 애니메이션에 대한 다양한 커스터마이징 옵션도 제공합니다. Angular Charts 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션에서 차트를 생성하기 위한 선언형 API line, bar, area, pie, doughnut 및 scatter 차트를 포함한 다양한 차트 유형 지원 차트의 스타일, 애니메이션 및 기타 속성을 사용자에 맞게 설정하는 옵션 제공 확대/축소 및 hovering 과 같은 대화형 기능 지원 고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능 정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원 Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원 Angular2-Google-Maps GitHub Stars: 2k License: MIT Angular2-Google-Maps는 Angular 팀에서 만든 오픈 소스 라이브러리로, Google 지도를 Angular 애플리케이션에 통합하기 위한 사용하기 쉬운 인터페이스를 제공합니다. Angular2-Google-Maps 라이브러리의 주요 기능은 다음과 같습니다. Google 지도 컴포넌트 생성을 위한 선언형 API center, zoom level, marker 등과 같은 다양한 속성을 지정하는 기능 스타일링, 애니메이션 등 다양한 커스터마이징 옵션 지원 고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능 정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원 Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원 Angular-Draggable GitHub Stars: 132 License: MIT Angular-Draggable 라이브러리는 널리 사용되는 JavaScript 프레임워크인 Angular를 사용하여 드래그(draggable) 및 크기 조정(resizable)이 가능한 사용자 인터페이스를 만들기 위한 오픈 소스 라이브러리입니다. Angular-Draggable의 주요 기능 중 일부는 다음과 같습니다. 사용자 맞춤형 옵션이 포함된 드래그 앤 드롭 기능 스냅 옵션으로 크기 조정 가능한 요소 사용자 맞춤형 드래그 handle Placeholder 지원 맞춤형 스타일 다른 Angular 컴포넌트와 쉽게 통합 Ngx-datatable GitHub Stars: 4.6k License: MIT Ngx-datatable은 개발자가 Sorting, Filtering, Pagination과 같은 고급 기능을 사용하여 동적이고 반응이 빠른 테이블을 쉽게 만들 수 있는 오픈 소스 라이브러리입니다. 또한 성능에 최적화되어 개발자가 성능 저하 없이 대규모 데이터 세트를 신속하게 렌더링할 수 있습니다. Ngx-datatable은 JSON, CSV, OData를 포함한 광범위한 데이터 소스를 지원합니다. 또한 클라이언트 또는 서버 측 데이터 처리를 지원하며 사용자에 맞는 템플릿 및 스타일을 설정할 수 있습니다. Ngx-datatable 라이브러리의 주요 기능은 다음과 같습니다. 유연한 데이터 바인딩: Ngx-datatable은 로컬 및 원격 데이터 바인딩을 모두 지원하므로 다양한 데이터 소스의 데이터를 쉽게 바인딩할 수 있습니다. 고급 필터링 및 정렬: Ngx-datatable을 사용하면 데이터를 빠르게 필터링하고 정렬하여 필요한 정보를 더 쉽게 찾을 수 있습니다. 열 크기 조정: 테이블 너비에 맞게 열 크기를 조정하거나 다양한 데이터 유형을 수용할 수 있습니다. 행 가상화(Virtualization): Ngx-datatable은 행이 표시되는 경우에만 행을 렌더링하므로 성능 문제 없이 대규모 데이터 세트를 스크롤할 수 있습니다. 열 재정렬: 열을 재정렬하여 테이블 레이아웃을 커스터마이징 할 수 있습니다. 편집 가능한 cell: 테이블의 특정 셀을 편집 가능하게 만들어 사용자가 데이터를 빠르게 업데이트할 수 있습니다. 결론 성공적인 웹 애플리케이션을 제작하려면 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것이 필수적입니다. 올바른 라이브러리를 사용하면 개발에 많은 시간과 노력을 들이지 않고도 앱을 빠르게 구축할 수 있습니다. 라이브러리를 선택할 때는 라이브러리가 제공하는 기능뿐만 아니라 라이브러리의 성능과 확장성을 고려하는 것이 중요합니다. 또한 라이브러리의 비용과 라이브러리가 제공하는 지원 수준도 고려하세요. 요구 사항을 평가하고 사용 가능한 Angular 라이브러리를 조사하여 정보에 입각한 결정을 내리고 웹 애플리케이션에 가장 적합한 라이브러리를 선택할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"Angularjs","slug":"Angularjs","permalink":"http://hgko1207.github.io/tags/Angularjs/"},{"name":"차세대 웹 앱","slug":"차세대-웹-앱","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%84%B8%EB%8C%80-%EC%9B%B9-%EC%95%B1/"}]},{"title":"Vue 2와 Vue 3의 차이점","slug":"vue-3","date":"2023-12-01T06:15:09.000Z","updated":"2023-12-09T13:17:15.284Z","comments":true,"path":"2023/12/01/vue-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/01/vue-3/","excerpt":"","text":"프런트엔드 개발 세계에서는 Vue.js가 인기 있는 선택이 되었습니다. Vue.js는 최신 웹 애플리케이션 개발에 널리 사용되는 사용자 친화적인 JavaScript 프레임워크입니다. 그러나 Vue.js의 최신 버전인 Vue 3은 중요한 업데이트와 개선 사항을 도입한다는 점에서 Vue 2와 다릅니다. 이 글에서는 Vue 2와 Vue 3의 주요 차이점을 자세히 살펴보겠습니다. Virtual DOM Vue.js의 기초는 Virtual DOM(Document Object Model) 기술에 있습니다. Vue 2에서는 Virtual DOM이 Vue.js의 이벤트 루프에 완벽하게 통합됩니다. 그러나 Vue 3에서는 Virtual DOM이 재설계되어 더욱 효율적으로 만들어졌습니다. Vue 3에서는 Virtual DOM이 더 빠르게 처리되고 더 적은 메모리를 사용합니다. 이는 성능과 애플리케이션 응답 시간을 크게 향상시킵니다. Composition API Vue 3에서는 가장 주목할만한 기능 중 하나인 Composition API를 도입했습니다. Composition API는 Vue 2의 Options API와 다르며 코드를 더욱 체계화하고 유지 관리 및 재사용 가능하게 만듭니다. Vue 2에서 컴포넌트는 data, methods, computed 및 watch와 같은 옵션을 사용하여 정의됩니다. Vue 3에서는 코드를 보다 기능적으로 구성할 수 있습니다. Composition API를 사용하면 더 작고 재사용이 가능하며 사용자 맞춤형 기능을 만들 수 있습니다. TypeScript Integration Vue.js는 TypeScript와 같은 정적 유형 검사 도구를 사용하는 프로젝트에 널리 사용됩니다. Vue 2에서는 TypeScript 통합이 가능했지만 개발자는 몇 가지 어려움과 문제에 직면했을 수 있습니다. Vue 3에서는 TypeScript 통합이 크게 향상되었습니다. Vue 3에서 TypeScript를 사용하면 더 나은 정적 유형 제어와 더 부드러운 TypeScript 경험을 얻을 수 있습니다. Bundle Size 번들 크기는 대규모 프런트엔드 프로젝트에서 중요한 요소입니다. Vue 2에서는 번들 크기를 줄이기 위해 다양한 최적화 기술과 플러그인이 필요할 수 있습니다. 그러나 Vue 3에서는 최적화된 매칭 알고리즘 및 소스 코드 압축과 같은 개선으로 번들 크기가 크게 줄었습니다. 그 결과 번들 크기가 작아지고 로딩 시간이 빨라지며 성능이 향상됩니다. Compatibility Vue 3은 Vue 2 프로젝트에서 전환하는 개발자에게 호환성 문제를 일으킬 수 있습니다. Vue 3는 일부 API 또는 컴포넌트를 삭제하거나 다른 이름을 바꾸거나 변경할 수 있습니다. 따라서 기존 Vue 2 프로젝트를 Vue 3으로 업그레이드하려는 경우 몇 가지 호환성 문제가 발생할 수 있습니다. Vue 3에 대한 자세한 마이그레이션 가이드가 있으며, 이 가이드를 참조하면 전환 과정에서 지침을 얻을 수 있습니다. 결론 Vue 2와 Vue 3의 주요 차이점을 검토하는 이 글에서는 재설계된 Virtual DOM, Composition API 도입, 향상된 TypeScript 통합 및 더 작은 번들 크기와 같은 요소를 다루었습니다. 이러한 요소로 인해 Vue 3는 프런트엔드 개발을 위한 강력한 선택이 되었습니다. 새로운 기능과 개선 사항에도 불구하고 기존 프로젝트를 Vue 2에서 Vue 3으로 전환하면 호환성 문제가 발생할 수 있습니다. 따라서 Vue 3으로의 전환을 고려하고 있다면 신중한 계획과 호환성 문제에 대한 주의가 중요합니다. Vue.js는 빠르고 강력하며 사용자 친화적인 프레임워크로서 인기를 계속 유지하고 있으며 Vue 3을 사용하면 더 많은 유연성을 도입할 수 있습니다. 개발 프로세스에 성능을 추가합니다. 자세한 내용은 공식 Vue.js 설명서를 참조하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Vue 2","slug":"Vue-2","permalink":"http://hgko1207.github.io/tags/Vue-2/"},{"name":"Vue 3","slug":"Vue-3","permalink":"http://hgko1207.github.io/tags/Vue-3/"}]},{"title":"버전 관리 이해하기","slug":"info-5","date":"2023-12-01T05:41:14.000Z","updated":"2023-12-01T06:45:35.921Z","comments":true,"path":"2023/12/01/info-5/","link":"","permalink":"http://hgko1207.github.io/2023/12/01/info-5/","excerpt":"","text":"소개 끊임없이 진화하는 소프트웨어 개발 환경에서 버전 제어 개념은 초석이 됩니다. 단독 프로젝트를 진행하든 팀과 협업하든 관계없이 버전 제어 시스템(Version Control System, VCS)은 코드 변경을 관리하고 프로젝트 무결성을 유지하며 원활한 협업을 촉진하는 데 중요한 역할을 합니다. 이 글에서는 버전 제어의 세계에 대해 자세히 알아보고 버전 제어의 이점, 유형, 널리 사용되는 도구 및 모범 사례를 살펴보겠습니다. 버전 관리 이해 버전 제어는 시간이 지남에 따라 프로젝트(일반적으로 소스 코드)의 변경 사항을 관리하기 위한 체계적인 접근 방식입니다. 이는 개발자에게 수정 사항을 추적하고 효과적으로 협업하며 필요한 경우 이전 상태로 되돌릴 수 있는 기능을 제공합니다. 이 프로세스를 통해 프로젝트는 체계적으로 정리되고 기록이 보존되며 팀 구성원은 충돌 없이 동시에 작업할 수 있습니다. 버전 관리의 이점 변경 사항 추적(Change Tracking): 버전 제어 시스템은 코드베이스에 적용된 모든 변경 사항을 꼼꼼하게 기록합니다. 이 감사 추적을 통해 변경이 발생했을 때 변경한 사람과 변경 이유를 쉽게 식별할 수 있습니다. 협업(Collaboration): 개발자 팀은 프로젝트의 여러 부분에서 동시에 작업할 수 있습니다. 버전 제어 시스템을 사용하면 변경 사항을 원활하게 병합하고 충돌을 방지하며 효율적인 협업을 촉진할 수 있습니다. 롤백 및 복구(Rollback and Recovery): 실수는 발생하지만 버전 제어를 통해 코드베이스의 이전 상태로 되돌릴 수 있습니다. 이 기능은 위험을 완화하고 오류의 영향을 줄입니다. 분기 및 병합(Branching and Merging): 버전 제어 시스템은 개발의 병렬 라인인 분기를 생성하는 기능을 제공하므로 팀은 기본 코드베이스에 영향을 주지 않고 새로운 기능을 실험할 수 있습니다. 이러한 분기를 기본 코드베이스에 다시 병합하는 것은 원활한 프로세스입니다. 문서화 및 통신(Documentation and Communication): 버전 제어의 커밋 메시지는 문서 형식으로 작동하여 특정 변경 사항이 적용된 이유에 대한 통찰력을 제공합니다. 이는 팀 의사소통과 지식 공유에 도움이 됩니다. 버전 관리 시스템의 유형 중앙 버전 제어 시스템(Centralized Version Control System, CVCS): CVCS에는 전체 프로젝트 기록을 보관하는 중앙 저장소가 있습니다. 개발자는 이 저장소에서 코드를 체크아웃하고 작업한 다음 변경 사항을 다시 커밋합니다. 예로는 CVS 및 Subversion(SVN)이 있습니다. 분산 버전 제어 시스템(Distributed Version Control System, DVCS): Git 및 Mercurial과 같은 DVCS는 각 개발자의 컴퓨터에 저장소의 전체 복사본(클론)을 생성합니다. 이러한 중복성은 협업을 강화하고 변경 사항을 중앙 저장소에 동기화하기 전에 로컬 커밋을 허용합니다. 인기 있는 버전 관리 도구 Git: 가장 널리 사용되는 DVCS인 Git은 속도, 유연성 및 분기 기능으로 잘 알려져 있습니다. 개인 개발자부터 Linux와 같은 대규모 오픈 소스 프로젝트에 이르기까지 모든 규모의 프로젝트에서 사용됩니다. Subversion(SVN): SVN은 비교적 사용자 친화적인 중앙 집중식 버전 제어 시스템입니다. 단순성과 기존 인프라와의 원활한 통합으로 인해 종종 선택됩니다. Mercurial: Git과 유사하게 Mercurial은 또 다른 분산 버전 제어 시스템입니다. 사용하기 쉽고 학습 곡선이 간단한 것으로 알려져 있습니다. 버전 제어 모범 사례 설명이 포함된 커밋 메시지 사용: 커밋 메시지는 변경 목적을 간결하게 설명해야 합니다. 잘 작성된 커밋 메시지는 협업과 이해를 돕는 데 큰 도움이 됩니다. 빈번한 커밋(Commit): 특정 변경 사항에 초점을 맞춘 작고 논리적인 커밋을 만듭니다. 이렇게 하면 기록을 더 쉽게 이해하고 문제를 격리할 수 있습니다. 전략적으로 분기(Branch): 새로운 개발을 위한 기능 분기와 문제 해결을 위한 버그 수정 분기를 만듭니다. 이는 메인 브랜치를 안정적으로 유지합니다. 정기적으로 끌어오기(Pull) 및 푸시(Push): 로컬 저장소를 원격 저장소와 동기화하여 최신 변경 사항이 있는지 확인하고 차이를 방지합니다. 신중한 검토(Review) 및 병합(Merge): 분기를 병합하기 전에 코드 변경 사항을 철저히 검토하고 잠재적인 충돌이 있는지 테스트하십시오. 결론 버전 제어 시스템은 소프트웨어 개발 프로세스를 혁신하여 효율적인 협업, 변경 관리 및 프로젝트 구성을 가능하게 했습니다. 숙련된 개발자이든 이제 막 시작하는 개발자이든 버전 제어 방식을 수용하고 Git과 같은 도구를 활용하면 개발 워크플로우를 크게 향상시킬 수 있습니다. 프로젝트 발전에 대한 체계적인 기록을 유지함으로써 문제를 해결하고 진행 상황을 추적하며 고품질 소프트웨어를 제공할 수 있는 능력을 더 잘 갖추게 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"버전 관리","slug":"버전-관리","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"코드 관리","slug":"코드-관리","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%93%9C-%EA%B4%80%EB%A6%AC/"},{"name":"공동 개발","slug":"공동-개발","permalink":"http://hgko1207.github.io/tags/%EA%B3%B5%EB%8F%99-%EA%B0%9C%EB%B0%9C/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"작업 흐름","slug":"작업-흐름","permalink":"http://hgko1207.github.io/tags/%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84/"},{"name":"VCS","slug":"VCS","permalink":"http://hgko1207.github.io/tags/VCS/"}]},{"title":"Vue JS 기본 설명","slug":"vue-2","date":"2023-11-30T01:27:22.000Z","updated":"2024-01-12T13:27:44.963Z","comments":true,"path":"2023/11/30/vue-2/","link":"","permalink":"http://hgko1207.github.io/2023/11/30/vue-2/","excerpt":"","text":"Vue 애플리케이션을 시작하려면 명령어을 사용 하세요. 1npm create vue@latest 공식 Vue 프로젝트 스캐폴딩 도구인 create-vue를 설치하고 실행합니다. 설치 시 프로젝트 이름, TypeScript 설정, JSX 및 테스트 지원과 같은 몇 가지 선택적 기능에 대한 프롬프트가 표시됩니다: 123456789101112✔ Project name: … &lt;your-project-name&gt;✔ Add TypeScript? … No / Yes✔ Add JSX Support? … No / Yes✔ Add Vue Router for Single Page Application development? … No / Yes✔ Add Pinia for state management? … No / Yes✔ Add Vitest for Unit testing? … No / Yes✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright✔ Add ESLint for code quality? … No / Yes✔ Add Prettier for code formatting? … No / YesScaffolding project in ./&lt;your-project-name&gt;...Done. SPA(단일 페이지 애플리케이션)의 경우 Vue 라우터를 포함해야 합니다. SPA를 생성하라는 메시지가 표시되면 긍정적으로 응답합니다. 옵션에 대해 확신이 서지 않는다면 일단 엔터키를 눌러 No를 선택하면 됩니다. 프로젝트가 생성되면 지침에 따라 종속 패키지를 설치하고 개발 서버를 시작합니다. 123cd &lt;your-project-name&gt;npm installnpm run dev Single-Page Application(SPA) 폴더 구조 1234567891011121314151617181920212223my-vue-app&#x2F;|-- public&#x2F;| |-- index.html||-- src&#x2F;| |-- assets&#x2F;| | |-- logo.png|| |-- components&#x2F;| | |-- HelloWorld.vue|| |-- views&#x2F;| | |-- Home.vue| | |-- About.vue|| |-- App.vue| |-- main.js||-- .gitignore|-- babel.config.js|-- package.json|-- README.md|-- vue.config.js 일반적인 Vue SPA 구조에는 다음이 포함됩니다. public/: 웹 서버에서 직접 제공하는 index.html 및 기타 assets을 포함합니다. src/: assets, components, views, router, App.vue 및 main.js를 포함하여 Vue 애플리케이션의 소스 코드를 보유합니다. assets/: 이미지 및 글꼴과 같은 정적 리소스를 포함합니다. components/: 재사용 가능한 Vue 컴포넌트를 포함합니다. views/: 다양한 views 나 pages를 나타내는 다양한 컴포넌트가 포함되어 있습니다. router/: Vue Router 관련 파일 및 경로 정의를 포함합니다. store/: 상태 관리를 위해 Vuex를 사용하는 경우 이 폴더에는 Vuex 스토어 관련 파일이 저장됩니다. App.vue: 전체 애플리케이션의 루트 Vue 컴포넌트 및 진입점 역할을 합니다. main.js: Vue 앱을 초기화하고, 라우터를 구성하고, 앱을 DOM에 마운트 합니다. main.js 파일은 애플리케이션을 설정합니다. 1234567import &#123; createApp &#125; from 'vue';import App from './App.vue';import router from './router';const app = createApp(App);app.use(router);app.mount('#app'); App.vue 파일 12345&lt;template&gt; &lt;main&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/main&gt;&lt;/template&gt; Script 기본 포트를 변경하려면 package.json의 script 태그를 사용자 정의 스크립트로 수정하세요. 123\"scripts\": &#123; \"dev-local\": \"vite --port 3000 --host 0.0.0.0\"&#125; 업데이트된 포트에서 애플리케이션을 시작하려면 명령어를 실행하세요. 1npm run dev-local Navigation MPA(Multi-Page Application)와 SPA(Single Page Application)는 웹 애플리케이션 구축을 위한 두 가지 서로 다른 아키텍처 접근 방식입니다. 주요 차이점은 콘텐츠 탐색 및 렌더링을 처리하는 방법에 있습니다. MPA MPA에서 각 페이지는 일반적으로 별도의 HTML 파일에 해당합니다. 각 링크나 상호 작용이 서버에 대한 요청을 트리거하고 전체 페이지가 대체되므로 페이지 간 탐색에는 전체 페이지 다시 로드가 포함됩니다. 서버는 각 페이지의 HTML을 렌더링 하고 제공하는 일을 담당합니다. SPA SPA에는 애플리케이션의 진입점 역할을 하는 단일 HTML 파일이 있습니다. 애플리케이션 내 탐색은 일반적으로 Vue Router와 같은 클라이언트 측 라우터를 사용하여 JavaScript로 처리됩니다. 사용자가 애플리케이션과 상호 작용할 때 필요한 구성 요소만 DOM 안팎으로 동적으로 로드되고 교체됩니다. Performance MPA 전체 페이지를 다시 로드하면 특히 콘텐츠가 많은 페이지에서 성능이 느려질 수 있습니다. CSS 및 JavaScript와 같은 리소스는 각 페이지 요청마다 새로 로드됩니다. SPA SPA는 필요한 데이터만 서버에서 가져오고 전체 페이지를 다시 로드하지 않고도 페이지 전환이 더 원활해지기 때문에 더 빠르고 원활한 사용자 환경을 제공할 수 있습니다. 초기 페이지와 자산이 로드되면 후속 상호 작용에 추가 서버 요청이 필요하지 않으므로 사용자 경험이 더 빨라질 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"기본","slug":"기본","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8/"}]},{"title":"[Angular] 컴포넌트 데코레이터(Component Decorator) 사용 방법","slug":"angular-31","date":"2023-11-28T01:59:13.000Z","updated":"2024-01-12T13:27:08.843Z","comments":true,"path":"2023/11/28/angular-31/","link":"","permalink":"http://hgko1207.github.io/2023/11/28/angular-31/","excerpt":"","text":"Angular에서 @Component 데코레이터는 재사용 가능한 UI 컴포넌트(Component)를 구축하는 초석입니다. Angular 애플리케이션 내에서 컴포넌트를 처리하고, 인스턴스화하고, 사용하는 방법을 정의하는 메타데이터를 제공합니다. 이 글에서는 @Component 데코레이터를 심층적으로 살펴보고, 다양한 속성에 대해 논의하고, 이러한 속성을 사용하여 코드 복잡성을 관리하는 방법을 설명합니다. 기본 사항 @Component 데코레이터는 구성 개체를 인수로 사용하는 함수입니다. 메타데이터를 컴포넌트 클래스와 연결하는 데 사용되므로 Angular가 컴포넌트를 생성하고 렌더링 하는 방법을 이해할 수 있습니다. @Component 데코레이터를 사용하는 간단한 예는 다음과 같습니다. 12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.scss'],&#125;)export class ExampleComponent &#123; // Component logic&#125; 속성 @Component 데코레이터는 컴포넌트의 다양한 측면을 정의하는 다양한 속성을 허용합니다. 가장 일반적으로 사용되는 속성 중 일부를 살펴보겠습니다. selector: 템플릿에서 이 컴포넌트를 식별하는 CSS 선택자(selector)입니다. Angular는 템플릿에서 해당 선택자를 찾을 때마다 컴포넌트의 인스턴스를 생성하고 삽입합니다. templateUrl: 컴포넌트의 템플릿이 포함된 외부 HTML 파일의 URL입니다. template: 컴포넌트의 인라인 HTML 템플릿입니다. templateUrl 또는 template 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다. styleUrls: 컴포넌트의 템플릿에 적용할 외부 CSS 파일의 배열입니다. styles: 컴포넌트의 템플릿에 적용할 인라인 CSS 스타일의 배열입니다. styleUrls 또는 styles 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다. providers: 이 컴포넌트와 해당 하위 컴포넌트에 대한 종속성 주입 공급자의 배열입니다. encapsulation: 컴포넌트의 템플릿에 스타일이 적용되는 방식을 결정하는 속성입니다. ViewEncapsulation.None, ViewEncapsulation.Emulated 또는 ViewEncapsulation.ShadowDom으로 설정할 수 있습니다. changeDetection: 컴포넌트의 변경 감지 전략을 결정하는 속성입니다. ChangeDetectionStrategy.Default 또는 ChangeDetectionStrategy.OnPush 로 설정할 수 있습니다. 코드 복잡성 관리 @Component 데코레이터에서 사용할 수 있는 다양한 속성을 사용하면 문제를 명확하게 분리하고 컴포넌트의 리소스를 구성하여 코드 복잡성을 관리할 수 있습니다. 다음은 코드 복잡성 관리에 대한 몇 가지 팁입니다. 템플릿(templateUrl)과 스타일(styleUrls)에 별도의 파일 사용: HTML 템플릿과 CSS 스타일을 별도의 파일에 배치하면 컴포넌트 클래스를 로직에 집중하고 유지 관리하기 쉽게 할 수 있습니다. 캡슐화(encapsulation) 활용: ViewEncapsulation을 활용하면 컴포넌트 스타일의 범위를 제어하여 원치 않는 부작용을 방지하고 스타일을 더욱 모듈화할 수 있습니다. 변경 감지 최적화: 적절한 changeDetection 전략을 선택하면 특히 크고 복잡한 애플리케이션에서 컴포넌트의 성능을 향상시킬 수 있습니다. 예: 12345678910111213import &#123; Component, ViewEncapsulation, ChangeDetectionStrategy &#125; from '@angular/core';@Component(&#123; selector: 'app-complex', templateUrl: './complex.component.html', styleUrls: ['./complex.component.scss'], encapsulation: ViewEncapsulation.Emulated, changeDetection: ChangeDetectionStrategy.OnPush, providers: [CustomService],&#125;)export class ComplexComponent &#123; // Component logic&#125; 결론 강력하고 효율적인 Angular 컴포넌트를 생성하려면 @Component 데코레이터와 해당 속성을 이해하는 것이 필수적입니다. 다양한 속성을 활용하여 코드 복잡성을 관리하고, 성능을 개선하고, 유지 관리 가능한 모듈식 애플리케이션을 만들 수 있습니다. 계속해서 Angular를 탐색하고 컴포넌트로 작업하면서 코드를 최적화하고 원활한 사용자 경험을 만드는 새로운 방법을 발견하게 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular CLI] 명령어 사용 및 활용 방법","slug":"angular-30","date":"2023-11-23T05:40:39.000Z","updated":"2023-12-17T13:17:48.356Z","comments":true,"path":"2023/11/23/angular-30/","link":"","permalink":"http://hgko1207.github.io/2023/11/23/angular-30/","excerpt":"","text":"Angular CLI는 개발자가 Angular 애플리케이션을 쉽게 생성, 유지 및 관리하는 데 도움이 되는 강력한 명령줄 인터페이스입니다. 개발 워크플로우를 간소화하고 생산성을 향상시키는 다양한 기능을 제공합니다. 이 글에서는 필수 Angular CLI 명령어와 이 명령어가 복잡하고 정교한 Angular 애플리케이션을 개발하는 데 어떻게 도움이 되는지 살펴보겠습니다. Angular CLI 설치 Angular CLI를 사용하려면 시스템에 전역적으로 설치해야 합니다. Node.js와 npm이 설치되어 있는지 확인한 후 다음 명령어를 실행하세요. 1npm install -g @angular/cli 새로운 Angular 애플리케이션 생성 새로운 Angular 애플리케이션을 만들려면 ng new 명령어 뒤에 프로젝트 이름을 사용하세요. 1ng new my-app 이 명령어는 Angular 애플리케이션에 필요한 파일과 폴더를 포함하여 새 프로젝트 디렉터리를 생성합니다. 또한 필요한 종속성을 설치하고 로컬 개발 서버를 설정합니다. 실행 라이브 리로딩(live reloading)으로 로컬 개발 서버를 시작하려면 프로젝트의 루트 디렉터리로 이동하여 명령어를 실행하세요. 1ng serve 기본적으로 http://localhost:4200/ 주소로 애플리케이션이 실행됩니다. Component, Directive, Service 생성 Angular CLI를 사용하면 Component, Directive, Service, Pipe 및 Guard 와 같은 Angular 애플리케이션의 다양한 파일을 빠르게 생성할 수 있습니다. Component 생성 123ng generate component my-component# orng g c my-component Directive 생성 123ng generate directive my-directive# orng g d my-directive Service 생성 123ng generate service my-service# orng g s my-service Module 생성 123ng generate module my-module# orng g m my-module 이 명령어는 필요한 파일을 생성하고 해당 NgModule을 업데이트하여 새 요소를 등록합니다. 빌드 Angular 애플리케이션의 프로덕션 모드로 빌드를 하려면 다음 명령어를 실행하세요. 1ng build --prod 이 명령어는 dist/ 폴더에 최적화된 빌드를 생성합니다. 테스트 실행 및 Linting Angular CLI에는 테스트 실행 및 코드 Linting에 대한 지원이 내장되어 있습니다. 다음 명령어를 실행하세요. Karma로 단위 테스트 실행 1ng test Protractor를 사용하여 end-to-end 테스트 실행 1ng e2e TSLint로 코드 Lint 1ng lint Custom 빌드 구성 Angular CLI는 angular.json 파일을 사용하여 프로젝트 구성을 관리합니다. 이 파일을 수정하여 출력 경로, 파일 이름, 최적화 옵션과 같은 빌드 설정을 사용자에 맞게 설정할 수 있습니다. 예를 들어, outputPath 속성을 업데이트하여 프로덕션 모드 빌드의 출력 경로를 변경할 수 있습니다. 123456\"configurations\": &#123; \"production\": &#123; \"outputPath\": \"custom-output-folder\", ... &#125;&#125; 코드 복잡성 및 테마 Angular CLI를 사용하면 코드를 Component, Directive, Service로 모듈화하여 애플리케이션의 복잡성을 관리할 수 있습니다. 이는 깨끗하고 체계적인 코드베이스를 유지하는 데 도움이 되므로 애플리케이션을 더 쉽게 확장하고 수정할 수 있습니다. 테마 설정과 관련하여 Angular CLI는 테마를 직접 처리하지 않지만 CSS나 SCSS 또는 LESS와 같은 전처리기를 사용하여 테마를 프로젝트에 통합할 수 있습니다. Bootstrap, Bulma 또는 Angular Material과 같은 널리 사용되는 CSS 프레임워크를 사용하여 일관되고 시각적으로 매력적인 사용자 인터페이스를 만들 수도 있습니다. 결론 Angular CLI는 복잡하고 정교한 Angular 애플리케이션을 쉽게 개발하는 데 도움이 되는 강력한 도구입니다. 프로젝트 생성, 유지 관리를 위한 필수 명령어로 워크플로우를 간소화함으로써 고품질 코드를 작성하고 최고의 사용자 경험을 제공하는 데 집중할 수 있습니다. Angular CLI와 그 기능을 계속 탐색하면서 생산성을 향상하고 강력하고 확장 가능한 애플리케이션을 구축할 수 있는 더 많은 방법을 찾을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Angular CLI","slug":"Angular-CLI","permalink":"http://hgko1207.github.io/tags/Angular-CLI/"}]},{"title":"JavaScript 프레임워크 비교: Angular, React, Vue.js","slug":"js-dev-10","date":"2023-11-17T06:32:56.000Z","updated":"2023-12-01T06:13:09.819Z","comments":true,"path":"2023/11/17/js-dev-10/","link":"","permalink":"http://hgko1207.github.io/2023/11/17/js-dev-10/","excerpt":"","text":"웹 개발 세계에서 Angular, React 및 Vue.js와 같은 JavaScript 프레임워크는 개발자가 웹 애플리케이션을 구축할 수 있는 다양한 도구를 제공합니다. 그러나 각각은 서로 다른 디자인 철학, 학습 곡선(learning curve) 및 사용 사례를 가지고 있습니다. 다음은 이 세 가지 프레임워크를 비교한 것입니다. Angular 장점 모든 기능을 갖춘 프레임워크 Angular는 광범위한 기능들을 자랑하며 필요한 모든 도구를 포함합니다. 따라서 크고 복잡한 애플리케이션에 적합합니다. Type Safety TypeScript 사용 덕분에 컴파일 타임(compile-time) 오류 감지 기능을 제공하여 보다 안전한 코드를 보장합니다. 강력한 데이터 바인딩 Angular의 강력한 기능인 양방향 데이터 바인딩은 원활한 데이터 동기화를 촉진합니다. 단점 학습 곡선(Learning Curve) Angular는 학습 곡선이 더 가파르기 때문에 즉 초기에 습득해야 하는 기술 양이 많기 때문에 초보자에게는 다소 어려울 수 있습니다. 무게 Angular는 어떤 경우에는 다른 프레임워크에 비해 무거워서 성능 제한이 발생할 수 있습니다. React 장점 속도와 성능 React는 가상 DOM을 사용하여 신속하고 효율적으로 작동하여 애플리케이션 성능을 향상시킵니다. 모듈성 컴포넌트 기반 아키텍처를 통해 React는 모듈식 애플리케이션 구조를 허용합니다. 광범위한 생태계 React는 대규모 커뮤니티를 자랑하며 광범위한 도구 및 라이브러리 생태계의 지원을 받습니다. 단점 완전한 프레임워크가 아님 React는 오로지 사용자 인터페이스 라이브러리이므로 완전한 프레임워크를 형성하기 위해 다른 라이브러리나 도구와 함께 사용해야 합니다. 학습 곡선(Learning Curve) JSX 및 Virtual DOM과 같은 개념은 일부 개발자의 학습 곡선을 약간 증가시킬 수 있습니다. Vue.js 장점 경량 Vue.js는 가벼운 성능을 갖춘 작은 크기의 라이브러리입니다. 쉬운 통합 Vue.js는 기존 프로젝트에 쉽게 통합되고 점진적으로 채택될 수 있습니다. 문서 Vue.js는 사용자 친화적인 문서를 제공하여 학습 과정을 촉진합니다. 단점 소규모 커뮤니티 다른 두 프레임워크에 비해 커뮤니티가 더 작기 때문에 특정 영역에서는 리소스가 더 제한될 수 있습니다. 엔터프라이즈 수준 애플리케이션에는 적합하지 않습니다. Vue.js는 대규모의 복잡한 프로젝트에서 Angular 및 React에 비해 몇 가지 단점이 있을 수 있습니다. 결론 이 글에서는 각 프레임워크의 기능을 정리했습니다. 어떤 프레임워크를 사용할지는 프로젝트 요구 사항, 팀의 전문 지식, 선호도에 따라 선택됩니다. Angular, React 및 Vue.js는 모두 강력하고 효과적인 도구이므로 선택 시 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다. 참고 https://angular.io/ https://react.dev/ https://vuejs.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"}]},{"title":"[Visual Studio Code] 생산성 향상을 위한 팁","slug":"info-4","date":"2023-11-03T06:54:32.000Z","updated":"2023-12-04T07:20:48.723Z","comments":true,"path":"2023/11/03/info-4/","link":"","permalink":"http://hgko1207.github.io/2023/11/03/info-4/","excerpt":"","text":"Visual Studio Code(VS Code)는 개발 세계를 강타한 인기 있고 강력한 소스 코드 편집기입니다. 유연성, 확장성 및 풍부한 생태계 덕분에 많은 개발자가 선택합니다. 이 글에서는 코딩 경험을 향상하고 생산성을 높이는 데 도움이 되는 몇 가지 유용한 팁과 테마를 공유하겠습니다. 키보드 단축키 익히기 키보드 단축키를 사용하면 시간과 노력을 절약하여 효율성을 높일 수 있습니다. 시작하는 데 도움이 되는 몇 가지 필수 단축키는 다음과 같습니다. Ctrl+P 또는 Cmd+P: 작업 공간에서 파일을 빠르게 엽니다. Ctrl+Shift+F 또는 Cmd+Shift+F: 전체 프로젝트에서 검색합니다. Alt+Up 또는 Alt+Down: 현재 줄을 위나 아래로 이동합니다. Ctrl+D 또는 Cmd+D: 현재 단어의 다음 항목을 선택합니다. Ctrl+Shift+L 또는 Cmd+Shift+L: 현재 단어와 일치하는 항목을 모두 선택합니다. File &gt; Preferences &gt; Keyboard Shortcuts 로 이동하여 커스텀 키보드 단축키를 만들 수도 있습니다. 통합 터미널 활용 VS Code에는 워크플로우를 간소화하는 데 도움이 되는 통합 터미널이 함께 제공됩니다. 몇 가지 편리한 단축키가 포함되어 있습니다. Ctrl+ 또는 Cmd+: 터미널을 열거나 닫습니다. Ctrl+Shift+5 또는 Cmd+Shift+5: 터미널을 분할합니다. File &gt; Preferences &gt; Settings 으로 이동하여 &quot;terminal&quot;을 검색하여 터미널을 커스터 마이징할 수도 있습니다. 방해 없는 코딩을 위한 Zen 모드 Zen 모드는 모든 UI(상태 표시줄, 활동 표시줄, 패널 및 사이드바)를 숨기고 전체 화면에 편집기만 표시하는 VS Code의 기능입니다. Ctrl+K Z 또는 Cmd+K Z로 활성화하세요. Zen 모드를 종료하려면 Esc를 두 번 누릅니다. 더 빠른 개발을 위한 코드 조각(Snippets) 코드 조각(Snippets)은 자동으로 코드를 삽입하는 템플릿입니다. VS Code에는 널리 사용되는 언어에 대한 코드 조각이 내장되어 있으며 File &gt; Preferences &gt; Configure User Snippets 으로 이동하여 자신만의 코드 조각을 만들 수 있습니다. 다양한 언어 및 프레임워크에 대해 미리 만들어진 코드 조각을 사용하여 확장 프로그램을 설치할 수도 있습니다. 편안한 코딩 환경을 위한 테마(Theme) VS Code는 코딩 환경을 커스터 마이징 할 수 있는 다양한 테마를 제공합니다. 다음은 인기 있는 것들입니다. Dark+ (default dark theme) Light+ (default light theme) Monokai Solarized Dark Dracula File &gt; Preferences &gt; Theme &gt; Color Theme 로 이동하여 테마를 변경할 수 있습니다. 더 많은 테마를 탐색하려면 Visual Studio Code Marketplace를 방문하여 &quot;theme&quot;를 검색하세요. 향상된 기능을 위한 확장(Extension) Extension 은 VS Code의 기능을 크게 확장할 수 있습니다. 일부 인기 있는 확장 기능은 다음과 같습니다. Prettier: 일련의 규칙에 따라 코드 형식을 자동으로 지정하는 코드 포맷터입니다. ESLint: 코드 일관성을 유지하고 버그를 조기에 발견하는 데 도움이 되는 린터(linter)입니다. Live Server: 정적 및 동적 페이지에 대한 라이브 다시 로드를 통해 로컬 개발 서버를 시작합니다. GitLens: VS Code 내에서 Git 기능을 강화하세요. 확장 프로그램을 관리하려면 활동 표시줄에서 확장 프로그램(Extensions) 아이콘을 클릭하거나 Ctrl+Shift+X 또는 Cmd+Shift+X를 누르세요. 결론 Visual Studio Code는 생산성을 높이고 코딩 환경을 향상할 수 있는 수많은 방법을 제공합니다. 키보드 단축키를 익히고, 통합 터미널을 활용하고, Zen 모드를 사용하고, 코드 조각을 만들고, 테마를 커스터 마이징하고, 강력한 확장 기능을 설치함으로써 이 다재다능한 편집기의 잠재력을 진정으로 활용할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://hgko1207.github.io/tags/Visual-Studio-Code/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://hgko1207.github.io/tags/VS-Code/"},{"name":"편집기","slug":"편집기","permalink":"http://hgko1207.github.io/tags/%ED%8E%B8%EC%A7%91%EA%B8%B0/"}]},{"title":"[Angular] ChangeDetectorRef: 수동 변경 감지에 대해 자세히 알아보기","slug":"angular-29","date":"2023-11-02T00:54:27.000Z","updated":"2024-01-12T13:24:53.764Z","comments":true,"path":"2023/11/02/angular-29/","link":"","permalink":"http://hgko1207.github.io/2023/11/02/angular-29/","excerpt":"","text":"변경 감지(Change Detection)는 Angular 애플리케이션의 중요한 측면으로, UI가 애플리케이션 상태와 동기화된 상태를 유지하도록 보장합니다. Angular는 효율적인 기본(default) 변경 감지 전략을 제공하지만 성능 최적화나 복잡한 사용 사례에는 보다 세부적인 접근 방식이 필요한 경우가 있습니다. 이 글에서는 ChangeDetectorRef의 강력한 기능을 심층적으로 살펴보고 해당 방법을 검토하고 잠재력을 최대한 보여주는 예를 보여 드리겠습니다. ChangeDetectorRef 이해 ChangeDetectorRef는 변경 감지 메커니즘에 대한 직접적인 인터페이스를 제공하는 Angular 클래스입니다. 이를 통해 개발자는 변경 감지를 수동으로 트리거(trigger)하고, 변경 감지 트리에서 컴포넌트를 분리하거나 다시 연결하고, 향후 변경 감지를 위해 컴포넌트를 표시할 수 있습니다. ChangeDetectorRef를 사용하면 개발자는 변경 감지 프로세스를 더 효과적으로 제어할 수 있어 애플리케이션의 성능과 유연성이 향상됩니다. ChangeDetectorRef가 제공하는 주요 메서드는 다음과 같습니다. detectorChanges(): 현재 컴포넌트와 해당 하위 컴포넌트에 대한 변경 감지를 수동으로 트리거합니다. markForCheck(): 다음 변경 감지 주기 동안 현재 컴포넌트와 해당 상위 컴포넌트에 변경 감지가 필요한 것으로 표시합니다. detach(): 변경 감지 트리에서 현재 컴포넌트를 분리하여 이 컴포넌트와 해당 하위 컴포넌트에 대한 자동 변경 감지를 효과적으로 중지합니다. reattach(): 현재 컴포넌트를 변경 감지 트리에 다시 연결하여 자동 변경 감지를 다시 한번 활성화합니다. 예제 1: 동적 컴포넌트 로딩 및 변경 감지 사용자 상호 작용에 따라 컴포넌트가 동적으로 로드되는 애플리케이션을 상상해 보세요. 이러한 시나리오에서는 ChangeDetectorRef를 사용하여 변경 감지를 최적화하고 필요한 경우에만 UI가 업데이트되도록 할 수 있습니다. 먼저 컴포넌트를 동적으로 로드하는 디렉티브을 만들어 보겠습니다. 123456789101112131415import &#123; ComponentFactoryResolver, Directive, Input, OnInit, ViewContainerRef &#125; from '@angular/core';@Directive(&#123; selector: '[appDynamicComponentLoader]',&#125;)export class DynamicComponentLoaderDirective implements OnInit &#123; @Input('appDynamicComponentLoader') component: any; constructor(private viewContainerRef: ViewContainerRef, private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125; ngOnInit() &#123; const factory = this.componentFactoryResolver.resolveComponentFactory(this.component); this.viewContainerRef.createComponent(factory); &#125;&#125; 이제 사용자 입력에 따라 동적으로 다양한 컴포넌트를 로드하는 컨테이너 컴포넌트를 만들어 보겠습니다. 123456789101112131415161718192021import &#123; Component, ComponentRef, ViewChild &#125; from '@angular/core';import &#123; DynamicComponentLoaderDirective &#125; from './dynamic-component-loader.directive';@Component(&#123; selector: 'app-container', template: ` &lt;ng-container *appDynamicComponentLoader=\"selectedComponent\"&gt;&lt;/ng-container&gt; &lt;button (click)=\"loadComponent('A')\"&gt;Load Component A&lt;/button&gt; &lt;button (click)=\"loadComponent('B')\"&gt;Load Component B&lt;/button&gt; `,&#125;)export class ContainerComponent &#123; @ViewChild(DynamicComponentLoaderDirective, &#123; static: true &#125;) dynamicComponentLoader: DynamicComponentLoaderDirective; selectedComponent: any; loadComponent(type: string) &#123; this.selectedComponent = type === 'A' ? ComponentA : ComponentB; this.dynamicComponentLoader.detectChanges(); &#125;&#125; 이 예에서는 새 컴포넌트가 로드될 때 변경 감지를 수동으로 트리거하기 위해 discoverChanges() 메서드를 사용하고 있습니다. 예제 2: Observable을 사용한 고급 변경 감지 다양한 컴포넌트가 Observable을 통해 데이터 업데이트를 받는 애플리케이션을 생각해 보세요. 우리는 특정 컴포넌트가 새 데이터를 수신할 때만 발생하도록 변경 감지를 최적화하려고 합니다. 먼저 데이터 서비스를 만듭니다. 1234567891011import &#123; Injectable &#125; from '@angular/core';import &#123; BehaviorSubject &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class DataService &#123; private dataSubject = new BehaviorSubject&lt;any[]&gt;([]); data$ = this.dataSubject.asObservable();&#125; 이제 데이터 서비스를 사용하고 여러 하위 컴포넌트가 있는 상위 컴포넌트를 만들어 보겠습니다. 123456789101112131415161718192021import &#123; Component, OnInit &#125; from '@angular/core';import &#123; DataService &#125; from './data.service';@Component(&#123; selector: 'app-parent', template: ` &lt;h2&gt;Parent Component&lt;/h2&gt; &lt;app-child *ngFor=\"let item of items; index as i\" [data]=\"item\" [index]=\"i\"&gt;&lt;/app-child&gt; `,&#125;)export class ParentComponent implements OnInit &#123; items: any[] = []; constructor(private dataService: DataService) &#123;&#125; ngOnInit() &#123; this.dataService.data$.subscribe((data) =&gt; &#123; this.items = data; &#125;); &#125;&#125; 마지막으로 데이터 업데이트를 수신하고 ChangeDetectorRef를 사용하는 하위 컴포넌트를 만듭니다. 12345678910111213141516171819202122232425262728293031import &#123; Component, Input, OnInit, ChangeDetectorRef &#125; from '@angular/core';import &#123; DataService &#125; from './data.service';@Component(&#123; selector: 'app-child', template: ` &lt;div *ngIf=\"data\"&gt; &lt;h3&gt;Child Component &#123;&#123; index &#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123; data &#125;&#125;&lt;/p&gt; &lt;/div&gt; `,&#125;)export class ChildComponent implements OnInit &#123; @Input() data: any; @Input() index: number; constructor(private cdr: ChangeDetectorRef, private dataService: DataService) &#123;&#125; ngOnInit() &#123; this.cdr.detach(); this.dataService.data$.subscribe((data) =&gt; &#123; const newData = data[this.index]; if (newData !== this.data) &#123; this.data = newData; this.cdr.markForCheck(); &#125; &#125;); &#125;&#125; 이 예에서는 detach()를 사용하여 변경 감지 트리에서 하위 컴포넌트를 분리했습니다. 그런 다음 markForCheck()를 사용하여 새 데이터가 수신될 때 변경 사항 감지를 위한 컴포넌트를 표시했습니다. 결론 ChangeDetectorRef는 개발자에게 Angular의 변경 감지 프로세스를 수동으로 제어할 수 있는 강력한 방법을 제공합니다. 기능을 이해하고 방법을 활용하면 성능을 위해 애플리케이션을 최적화하고 복잡한 사용 사례를 쉽게 처리할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"ChangeDetectorRef","slug":"ChangeDetectorRef","permalink":"http://hgko1207.github.io/tags/ChangeDetectorRef/"},{"name":"변경감지","slug":"변경감지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80/"}]},{"title":"[Angular] Pipe 소개 및 사용방법","slug":"angular-28","date":"2023-11-01T06:33:00.000Z","updated":"2024-01-12T13:22:22.401Z","comments":true,"path":"2023/11/01/angular-28/","link":"","permalink":"http://hgko1207.github.io/2023/11/01/angular-28/","excerpt":"","text":"Angular 파이프(Pipe)는 Angular 애플리케이션의 필수 부분으로, 데이터를 변환하고 형식을 지정하는 간단한 방법을 제공합니다. 파이프를 사용하면 필요에 맞게 데이터를 쉽게 조작하고 이해하기 쉬운 형식으로 표시할 수 있습니다. 이 글에서는 AsyncPipe, CurrentPipe, DatePipe, DecimalPipe, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe 및 UpperCasePipe를 포함한 다양한 유형의 Angular 파이프를 살펴보겠습니다. 또한 Angular 파이프를 효과적으로 사용하기 위한 모범 사례에 대해서도 알아보겠습니다. AsyncPipe AsyncPipe는 Angular에서 비동기 데이터를 처리하는 데 사용됩니다. 이를 통해 HTTP 요청 또는 Promise와 같은 비동기 작업에서 반환된 데이터를 표시할 수 있습니다. AsyncPipe는 Observable 또는 Promise를 구독(subscribe)하고 데이터가 변경되면 자동으로 뷰를 업데이트합니다. 다음은 AsyncPipe를 사용하여 비동기 데이터를 처리하는 예입니다. 1&lt;p&gt;&#123;&#123; (data$ | async)?.name &#125;&#125;&lt;/p&gt; CurrencyPipe CurrencyPipe는 Angular에서 통화(currency) 값의 형식을 지정하는 데 사용됩니다. 통화 기호, 천 단위 및 소수 구분 기호를 사용하여 특정 통화 형식으로 숫자를 표시할 수 있습니다. 다음은 통화 값 형식을 지정하기 위해 CurrencyPipe를 사용하는 예입니다. 12&lt;p&gt;&#123;&#123; 10000 | currency:'USD':'symbol':'1.2-2' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '$10,000.00' --&gt; DatePipe DatePipe는 Angular에서 날짜 형식을 지정하는 데 사용됩니다. ‘short’, ‘medium’, ‘long’ 등 특정 형식으로 날짜를 표시할 수 있습니다. 커스텀(custom) 날짜 형식을 지정할 수도 있습니다. 다음은 DatePipe를 사용하여 날짜 형식을 지정하는 예입니다. 12&lt;p&gt;&#123;&#123; today | date:'shortDate' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '11/1/23' --&gt; DecimalPipe DecimalPipe는 Angular에서 십진수 값의 형식을 지정하는 데 사용됩니다. 소수 구분 기호와 천 단위 구분 기호를 사용하여 특정 소수 형식으로 숫자를 표시할 수 있습니다. 다음은 DecimalPipe를 사용하여 10진수 값의 형식을 지정하는 예입니다. 12&lt;p&gt;&#123;&#123; 1000.5 | number:'1.2-2' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '1,000.50' --&gt; I18nPluralPipe I18nPluralPipe는 Angular에서 복수형을 처리하는 데 사용됩니다. 항목 수에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nPluralPipe를 사용하여 복수화를 처리하는 예입니다. 1items = ['Message 1']; 12&lt;p&gt;&#123;&#123; items.length &#125;&#125; / &#123;&#123; items.length | i18nPlural : &#123; '=0': 'No items', '=1': '1 item', other: '# items' &#125; &#125;&#125;&lt;/p&gt;&lt;!-- Output: '1 / 1 item' --&gt; I18nSelectPipe I18nSelectPipe는 Angular에서 select 문을 처리하는 데 사용됩니다. 조건에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nSelectPipe를 사용하여 select 문을 처리하는 예입니다. 1&lt;p&gt;&#123;&#123; gender | select: &#123; 'male': 'He', 'female': 'She', 'other': 'They' &#125; &#125;&#125;&lt;/p&gt; JsonPipe JsonPipe는 Angular에서 JSON 데이터를 표시하는 데 사용됩니다. JSON 데이터를 읽을 수 있는 형식으로 표시할 수 있습니다. 다음은 JsonPipe를 사용하여 JSON 데이터를 표시하는 예입니다. 1&lt;p&gt;&#123;&#123; data | json &#125;&#125;&lt;/p&gt; LowerCasePipe LowerCasePipe는 문자열을 소문자로 변환하는 데 사용됩니다. 12&#123;&#123; 'HELLO WORLD' | lowercase &#125;&#125;&lt;!-- Output: hello world --&gt; PercentPipe PercentPipe는 숫자를 백분율로 형식화하는 데 사용됩니다. 12&#123;&#123; 0.25 | percent &#125;&#125;&lt;!-- Output: 25% --&gt; SlicePipe SlicePipe는 배열 또는 문자열의 조각을 추출하는 데 사용됩니다. 12&#123;&#123; 'abcdefghijk' | slice:0:5 &#125;&#125;&lt;!-- Output: abcde --&gt; TitleCasePipe TitleCasePipe는 문자열을 title 케이스로 변환하는 데 사용됩니다(각 단어의 첫 글자를 대문자로 표시). 12&#123;&#123; 'hello world' | titlecase &#125;&#125;&lt;!-- Output: Hello World --&gt; UpperCasePipe UpperCasePipe는 문자열을 대문자로 변환하는 데 사용됩니다. 12&#123;&#123; 'hello world' | uppercase &#125;&#125;&lt;!-- Output: HELLO WORLD --&gt; 결론 이 글에서는 다양한 Angular 파이프와 그 기능을 살펴보았습니다. 파이프는 애플리케이션에서 데이터를 쉽게 변환하고 형식을 지정할 수 있게 해주는 Angular의 중요한 기능입니다. 이러한 파이프를 이해하고 활용함으로써 Angular 애플리케이션을 보다 효율적이고 동적이고 사용자 친화적으로 만들 수 있습니다. 특정 사용 사례에 적합한 파이프를 사용하고 파이프를 철저히 테스트하는 것을 잊지 마세요. 이 글을 통해 Angular 파이프에 대한 더 나은 이해와 응용 프로그램에서 이를 효과적으로 사용하는 방법을 얻을 수 있기를 바랍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Pipe","slug":"Pipe","permalink":"http://hgko1207.github.io/tags/Pipe/"},{"name":"파이프","slug":"파이프","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84/"}]},{"title":"[Angular] 데코레이터(Decorator) 소개 및 사용방법(2)","slug":"angular-27","date":"2023-10-31T02:32:38.000Z","updated":"2024-01-12T13:21:46.390Z","comments":true,"path":"2023/10/31/angular-27/","link":"","permalink":"http://hgko1207.github.io/2023/10/31/angular-27/","excerpt":"","text":"Angular Decorator는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다. 이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다. @NgModule @NgModule은 Angular 모듈을 생성하고 구성하는 데 사용되는 데코레이터입니다. Angular 모듈은 components, services, directives, pipes 등과 같은 애플리케이션의 다양한 부분을 위한 컨테이너입니다. 이는 애플리케이션의 여러 부분 간의 종속성을 구성하고 관리하는 데 사용됩니다. @NgModule 데코레이터를 사용하는 방법의 예는 다음과 같습니다. 1234567891011import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 위의 예에서는 BrowserModule과 AppComponent를 가져오고 declarations 배열에서 AppComponent를 선언합니다. 또한 bootstrap 컴포넌트를 AppComponent로 지정합니다. @NgModule 데코레이터에는 구성할 수 있는 여러 속성이 있습니다. declarations: 이 모듈에 속하는 components, directives 및 pipes의 배열입니다. imports: 이 모듈이 의존하는 모듈의 배열입니다. exports: 다른 모듈에서 사용할 수 있는 components, directives 및 pipes의 배열입니다. providers: 이 모듈에서 제공하는 서비스 배열입니다. bootstrap: 이 모듈에 의해 부트스트랩되어야 하는 주요 컴포넌트입니다. @NgModule 데코레이터를 사용하면 Angular 애플리케이션에서 모듈을 쉽게 만들고 관리할 수 있습니다. @Optional @Optional 데코레이터는 종속성을 컴포넌트나 서비스에 주입할 때 종속성을 선택적으로 허용하는 데 사용됩니다. 종속성을 찾을 수 없는 경우 injector 는 오류를 발생시키지 않고 대신 종속성에 대해 null 값을 제공합니다. 예는 다음과 같습니다. 123456789101112131415161718import &#123; Component, Optional &#125; from '@angular/core';import &#123; MyService &#125; from './my.service';@Component(&#123; selector: 'my-component', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;',&#125;)export class MyComponent &#123; constructor(@Optional() private myService: MyService) &#123;&#125; get message(): string &#123; if (this.myService) &#123; return this.myService.getMessage(); &#125; else &#123; return 'MyService not available.'; &#125; &#125;&#125; 이 예에서 MyService 종속성은 @Optional 데코레이터를 사용하여 선택 사항으로 표시됩니다. 서비스를 찾을 수 없으면 message() 메서드는 오류를 발생시키는 대신 기본 문자열을 반환합니다. 선택 사항으로 표시된 종속성이 실제로 컴포넌트나 서비스의 올바른 작동을 위해 필요한 경우 @Optional 데코레이터를 사용해서는 안 된다는 점에 유의하는 것이 중요합니다. 대신 종속성을 필수로 표시하고 적절한 오류 처리를 구현해야 합니다. @Self @Self 데코레이터는 종속성 해결 범위를 현재 컴포넌트 또는 디렉티브 인스턴스로 제한하는 데 사용됩니다. 즉, Angular는 컴포넌트나 디렉티브의 자체 인젝터에서만 종속성을 찾고 상위 인젝터에서는 찾지 않습니다. @Self를 사용하는 방법의 예는 다음과 같습니다. 1234567891011121314151617import &#123; Component, OnInit, Self &#125; from '@angular/core';import &#123; MyService &#125; from './my-service';@Component(&#123; selector: 'my-component', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;', providers: [MyService],&#125;)export class MyComponent implements OnInit &#123; message: string; constructor(@Self() private myService: MyService) &#123;&#125; ngOnInit() &#123; this.message = this.myService.getMessage(); &#125;&#125; 이 예에서는 @Self 데코레이터를 사용하여 MyService 종속성을 MyComponent 컴포넌트에 주입합니다. MyService 종속성은 컴포넌트 수준에서 정의됩니다. 즉, 현재 컴포넌트에만 사용할 수 있고 상위 컴포넌트에는 사용할 수 없습니다. MyService 종속성이 AppModule 또는 상위 컴포넌트와 같이 더 높은 수준에서 정의된 경우 Angular는 이를 찾을 때까지 현재 컴포넌트의 인젝터, 그 다음 상위 인젝터 등에서 이를 찾습니다. 그러나 @Self데코레이터를 사용하면 종속성 해결 범위를 현재 컴포넌트로만 제한합니다. 요약하자면, @Self 데코레이터는 상위 컴포넌트나 디렉티브가 아닌 현재 컴포넌트나 디렉티브의 컨텍스트 내에서만 종속성을 확인하는 데 사용됩니다. @SkipSelf @SkipSelf 데코레이터는 Angular에서 컴포넌트 계층 내 서비스의 가시성과 주입을 제어하는 데 사용됩니다. 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 이를 찾기 시작하고 요청된 서비스를 찾거나 트리 상단에 도달할 때까지 인젝터 트리를 탐색합니다. 기본적으로 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 해당 서비스를 찾습니다. 즉, 컴포넌트와 모든 하위 컴포넌트에서 서비스를 사용할 수 있다는 뜻입니다. 그러나 어떤 경우에는 현재 인젝터를 건너뛰고 상위 인젝터에서 서비스를 찾을 수 있습니다. 이는 서비스가 동일한 상위를 가진 여러 컴포넌트 간에 공유된다는 의미입니다. @SkipSelf 데코레이터는 Angular에게 현재 인젝터를 건너뛰고 상위 인젝터에서 요청된 서비스를 찾도록 지시하는 데 사용됩니다. 이는 상위가 동일하지만 서로 직접적으로 관련되지 않은 여러 컴포넌트 간에 서비스를 공유하려는 경우에 유용합니다. @SkipSelf 데코레이터를 사용하는 방법의 예는 다음과 같습니다. 123456789101112131415import &#123; Component, Inject, SkipSelf &#125; from '@angular/core';import &#123; MyService &#125; from './my.service';@Component(&#123; selector: 'my-child-component', template: ` &lt;p&gt;My Child Component&lt;/p&gt; `, providers: [&#123; provide: MyService, useValue: &#123; message: 'Hello from child component!' &#125; &#125;],&#125;)export class MyChildComponent &#123; constructor(@SkipSelf() private myService: MyService) &#123;&#125; ngOnInit() &#123; console.log(this.myService.message); // Output: \"Hello from parent component!\" &#125;&#125; 이 예에서 MyChildComponent는 @SkipSelf 데코레이터를 사용하여 상위 인젝터에서 MyService를 요청합니다. 상위 컴포넌트는 providers 배열을 사용하여 MyService를 제공합니다. 이는 모든 하위 컴포넌트에서 서비스를 사용할 수 있음을 의미합니다. MyChildComponent가 초기화되면 상위 컴포넌트의 메시지를 기록합니다. 전반적으로 @SkipSelf 데코레이터는 동일한 부모를 가진 여러 컴포넌트 간에 서비스를 공유하고 동일한 컴포넌트 계층 내에서 동일한 서비스를 여러 번 주입하지 않으려는 경우에 유용합니다. @ViewChild @ViewChild 데코레이터는 컴포넌트의 템플릿 보기에서 element 또는 컴포넌트의 참조를 가져오는 데 사용됩니다. 하위 컴포넌트 또는 상위 컴포넌트에 있는 element의 속성 및 메서드에 액세스하는 데 사용할 수 있습니다. @ViewChild와 함께 사용할 수 있는 selectors에는 두 가지 유형이 있습니다. Component Selector가 사용되면 @ViewChild는 컴포넌트 인스턴스에 대한 참조를 반환합니다. 다음은 Component Selector와 함께 @ViewChild를 사용하는 예입니다. 1234567891011121314import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; ChildComponent &#125; from './child.component';@Component(&#123; selector: 'parent-component', template: '&lt;child-component&gt;&lt;/child-component&gt;',&#125;)export class ParentComponent &#123; @ViewChild(ChildComponent) childComponentRef: ChildComponent; ngAfterViewInit() &#123; this.childComponentRef.doSomething(); &#125;&#125; 이 예제에서는 @ViewChild를 사용하여 ChildComponent 인스턴스에 대한 참조를 가져온 다음 doSomething 메서드를 호출하는 데 사용합니다. 템플릿 참조 변수(Template Reference Variable): 템플릿 참조 변수가 사용되면 @ViewChild는 해당 변수와 연결된 요소 또는 컴포넌트에 대한 참조를 반환합니다. 다음은 템플릿 참조 변수와 함께 @ViewChild를 사용하는 예입니다. 1&lt;child-component #child&gt;&lt;/child-component&gt; 1234567891011121314import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; ChildComponent &#125; from './child.component';@Component(&#123; selector: 'parent-component', template: '&lt;child-component #child&gt;&lt;/child-component&gt;',&#125;)export class ParentComponent &#123; @ViewChild('child') childComponentRef: ChildComponent; ngAfterViewInit() &#123; this.childComponentRef.doSomething(); &#125;&#125; 이 예에서 @ViewChild는 템플릿 참조 변수 #child를 사용하여 ChildComponent 인스턴스에 대한 참조를 가져오는 데 사용됩니다. @ViewChild는 하위 컴포넌트가 상위 컴포넌트보다 먼저 렌더링되는 경우에만 작동한다는 점에 유의하는 것이 중요합니다. 상위 컴포넌트가 렌더링되기 전에 하위 컴포넌트에 액세스하려고 하면 결과가 정의되지 않습니다. 이를 방지하려면 ngAfterViewInit() 생명주기 훅 메소드를 사용하여 @ViewChild로 액세스를 시도하기 전에 하위 컴포넌트가 렌더링되었는지 확인할 수 있습니다. @ViewChildren @ViewChildren 데코레이터는 컴포넌트 또는 디렉티브의 템플릿에서 selector와 일치하는 요소의 QueryList를 가져오는 데 사용됩니다. 다음은 @ViewChildren을 사용하여 특정 디렉티브가 있는 하위 요소의 QueryList를 가져오는 방법에 대한 예입니다. 12345678910111213141516171819202122232425import &#123; Component, Directive, ViewChildren &#125; from '@angular/core';@Directive(&#123; selector: '[myDirective]',&#125;)export class MyDirective &#123;&#125;@Component(&#123; selector: 'my-component', template: ` &lt;div myDirective&gt;&lt;/div&gt; &lt;div myDirective&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; `,&#125;)export class MyComponent &#123; @ViewChildren(MyDirective) myDirectives: QueryList&lt;MyDirective&gt;; ngAfterViewInit() &#123; // Access the elements with MyDirective this.myDirectives.forEach((directive) =&gt; &#123; console.log(directive); &#125;); &#125;&#125; 이 예에서는 @ViewChildren을 사용하여 MyComponent 템플릿의 MyDirective 디렉티브가 있는 요소의 QueryList를 가져옵니다. ngAfterViewInit 생명주기 훅 메소드는 요소에 액세스하고 이를 콘솔에 기록하는 데 사용됩니다. @ViewChildren 데코레이터는 템플릿의 요소와 일치하도록 디렉티브 유형 대신 문자열 selector를 사용할 수도 있습니다. 결론 이러한 데코레이터를 적절하게 사용하면 Angular 컴포넌트, 디렉티브 및 서비스의 기능을 향상하고 필요한 상용구 코드의 양을 줄일 수 있습니다. 각 데코레이터는 고유한 목적을 수행하며 사용법을 익히면 강력하고 효율적인 Angular 애플리케이션을 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular] 데코레이터(Decorator) 소개 및 사용방법(1)","slug":"angular-26","date":"2023-10-30T03:24:03.000Z","updated":"2024-01-12T08:30:30.068Z","comments":true,"path":"2023/10/30/angular-26/","link":"","permalink":"http://hgko1207.github.io/2023/10/30/angular-26/","excerpt":"","text":"Angular Decorator는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다. 이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다. @Component @Component 데코레이터는 Angular에서 새 컴포넌트(Component)를 정의하는 데 사용됩니다. selector, template, styles 등과 같은 컴포넌트에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 12345@Component(&#123; selector: 'app-my-component', template: '&lt;h1&gt;Hello World!&lt;/h1&gt;',&#125;)export class MyComponent &#123;&#125; @Directive @Directive 데코레이터는 Angular에서 새로운 디렉티브(Directive)을 만드는 데 사용됩니다. selector, inputs, outputs 등과 같은 지시어에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 123456@Directive(&#123; selector: '[appMyDirective]',&#125;)export class MyDirective &#123; @Input() appMyDirective: string;&#125; @Injectable @Injectable 데코레이터는 Angular에서 새로운 서비스를 정의하는 데 사용됩니다. dependencies, scope 등과 같은 서비스에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 1234@Injectable(&#123; providedIn: 'root',&#125;)export class MyService &#123;&#125; @Pipe @Pipe 데코레이터는 Angular에서 새 파이프를 만드는 데 사용됩니다. name, pureness 등과 같은 파이프에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 123456789@Pipe(&#123; name: 'myPipe', pure: true,&#125;)export class MyPipe implements PipeTransform &#123; transform(value: any): any &#123; return value.toUpperCase(); &#125;&#125; @Input @Input 데코레이터는 컴포넌트나 디렉티브에서 입력 속성을 정의하는 데 사용됩니다. name, type 등 입력에 대한 메타데이터를 제공하는 데 사용됩니다. 입력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다. 1234567@Component(&#123; selector: 'app-my-component', template: '&lt;h1&gt;&#123;&#123;myInput&#125;&#125;&lt;/h1&gt;',&#125;)export class MyComponent &#123; @Input() myInput: string;&#125; @Output @Output 데코레이터는 컴포넌트나 디렉티브에서 출력 속성을 정의하는 데 사용됩니다. name, type 등 출력에 대한 메타데이터를 제공하는 데 사용됩니다. 출력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다. 1234567891011@Component(&#123; selector: 'app-my-component', template: '&lt;button (click)=\"onClick()\"&gt;Click Me&lt;/button&gt;',&#125;)export class MyComponent &#123; @Output() myOutput: EventEmitter&lt;any&gt; = new EventEmitter(); onClick() &#123; this.myOutput.emit(); &#125;&#125; @HostBinding @HostBinding 데코레이터는 디렉티브이나 컴포넌트의 host element 속성을 디렉티브이나 컴포넌트 클래스의 속성에 바인딩하는 데 사용됩니다. 바인딩할 host 속성의 이름을 지정하는 매개변수를 받는 속성 데코레이터입니다. 123456789101112131415161718@Directive(&#123; selector: '[appHighlight]',&#125;)export class HighlightDirective &#123; @Input('appHighlight') isHighlighted: boolean; @HostBinding('style.backgroundColor') backgroundColor: string; constructor() &#123;&#125; ngOnChanges() &#123; if (this.isHighlighted) &#123; this.backgroundColor = 'blue'; &#125; else &#123; this.backgroundColor = 'transparent'; &#125; &#125;&#125; 이 예에서 @HostBinding 데코레이터는 디렉티브의 backgroundColor 속성을 호스트 요소의 style.BackgroundColor 속성에 바인딩하는 데 사용됩니다. 이는 isHighlighted 입력이 변경되면 그에 따라 backgroundColor 속성이 업데이트된다는 의미입니다. @HostBinding 데코레이터를 사용하여 클래스 이름과 같은 호스트 요소의 다른 속성을 바인딩할 수도 있습니다. 1234567@Directive(&#123; selector: '[appButton]',&#125;)export class ButtonDirective &#123; @HostBinding('class.btn') isButton = true; @HostBinding('class.btn-primary') isPrimary = true;&#125; 이 예에서 @HostBinding 데코레이터는 isButton 속성을 호스트 요소의 btn 클래스에 바인딩하고 isPrimary 속성을 호스트 요소의 btn-primary 클래스에 바인딩하는 데 사용됩니다. 이 지시어는 모든 요소에 사용되어 부트스트랩 스타일 버튼 모양을 제공할 수 있습니다. @HostBinding을 다른 지시어 및 서비스와 함께 사용하면 Angular 애플리케이션에서 복잡하고 동적인 UI 요소를 쉽게 생성할 수 있습니다. @Attribute @Attribute 데코레이터는 호스트 요소의 속성 값을 디렉티브에 삽입하는 데 사용됩니다. 이 데코레이터는 HTML 요소에서 값을 가져와 디렉티브에 사용해야 할 때 사용됩니다. @Attribute를 사용하는 방법의 예는 다음과 같습니다. 12345678910111213import &#123; Directive, Input, Attribute &#125; from '@angular/core';@Directive(&#123; selector: '[myDirective]',&#125;)export class MyDirective &#123; @Input() myInput: string; myAttribute: string; constructor(@Attribute('my-attribute') myAttribute: string) &#123; this.myAttribute = myAttribute; &#125;&#125; 이 예에서 @Attribute 데코레이터는 호스트 요소의 my-attribute 속성 값을 디렉티브의 myAttribute 속성에 삽입하는 데 사용됩니다. 속성 값은 문자열로 삽입되므로 다른 형식의 값이 필요한 경우 추가 구문 분석이나 유형 변환을 수행해야 할 수도 있습니다. @Attribute 데코레이터는 HTML 요소에서 값을 가져와 디렉티브 로직에 사용해야 할 때 유용할 수 있습니다. 그러나 이 접근 방식은 앱의 HTML 구조가 변경되면 취약한 코드로 이어질 수 있다는 점을 명심하는 것이 중요합니다. @ContentChild @ContentChild 데코레이터를 사용하면 컴포넌트가 해당 콘텐츠에 투영되는 디렉티브 또는 컴포넌트의 단일 인스턴스를 쿼리 할 수 있습니다. 사용 @ContentChild 데코레이터는 두 가지 방법으로 사용할 수 있습니다. 유형별로 디렉티브나 컴포넌트를 쿼리합니다. 12@ContentChild(MyDirective) myDirective!: MyDirective;@ContentChild(MyComponent) myComponent!: MyComponent; 템플릿 참조 변수로 디렉티브나 컴포넌트를 쿼리합니다. 1&lt;my-component #myComponentRef&gt;&lt;/my-component&gt; 1@ContentChild('myComponentRef', &#123; static: true &#125;) myComponent!: MyComponent; Options @ContentChild 데코레이터는 다음 속성을 가진 옵션 개체를 사용할 수 있습니다. static (boolean): 변경 감지가 실행되기 전에 쿼리를 해결할지 여부(기본값은 false). Example 다음은 @ContentChild 데코레이터를 사용하여 투영된 컴포넌트를 쿼리하는 예입니다. 123&lt;my-component&gt; &lt;my-child-component&gt;&lt;/my-child-component&gt;&lt;/my-component&gt; 1234567@Component(&#123; selector: 'my-component', template: ` &lt;ng-content&gt;&lt;/ng-content&gt; `,&#125;)export class MyComponent &#123; @ContentChild(MyChildComponent) myChildComponent!: MyChildComponent;&#125; 이 예에서 MyComponent 컴포넌트는 해당 콘텐츠에 투영되는 MyChildComponent 인스턴스를 쿼리합니다. 사용 시기 컴포넌트의 콘텐츠에 프로젝션되는 디렉티브나 컴포넌트의 단일 인스턴스를 쿼리해야 하는 경우 @ContentChild 데코레이터를 사용하세요. Notes 쿼리된 디렉티브 또는 컴포넌트의 여러 인스턴스가 콘텐츠에 프로젝션되는 경우 발견된 첫 번째 인스턴스가 반환됩니다. 쿼리된 디렉티브나 컴포넌트의 인스턴스가 콘텐츠에 프로젝션되지 않으면 쿼리는 undefined를 반환합니다. 정적 옵션이 true로 설정된 경우 변경 감지가 실행되기 전에 쿼리가 해결됩니다. 이는 ngOnInit() 또는 ngAfterViewInit()에서 쿼리된 인스턴스에 액세스해야 하는 경우 유용할 수 있습니다. @ContentChildren @ContentChildren 데코레이터는 컴포넌트 또는 디렉티브의 하위 콘텐츠를 쿼리하고 액세스하는 데 사용됩니다. 이를 통해 컴포넌트는 콘텐츠 영역에 프로젝션된 하위 컴포넌트 및 디렉티브에 액세스할 수 있습니다. 데코레이터는 두 가지 인수를 사용합니다. 삽입할 디렉티브를 식별하는 selector 문자열입니다. injection에 대한 추가 옵션을 지정하는 선택적 구성 개체입니다. 다음은 @ContentChildren 데코레이터를 사용하여 투영된 하위 컴포넌트를 쿼리하고 액세스하는 예입니다. 1234567891011121314import &#123; Component, ContentChildren, QueryList &#125; from '@angular/core';import &#123; TabComponent &#125; from './tab.component';@Component(&#123; selector: 'app-tabs', template: ` &lt;ng-content&gt;&lt;/ng-content&gt; `,&#125;)export class TabsComponent &#123; @ContentChildren(TabComponent) tabs: QueryList&lt;TabComponent&gt;; ngAfterContentInit() &#123; console.log(this.tabs); &#125;&#125; 이 예에서 TabsComponent는 @ContentChildren 데코레이터를 사용하여 예상되는 모든 TabComponent 하위 항목을 쿼리합니다. 결과 QueryList는 컴포넌트의 tabs 속성에서 사용할 수 있습니다. ngAfterContentInit 생명주기 훅 메서드는 프로젝션된 콘텐츠가 초기화된 후 tabs 속성에 액세스하는 데 사용됩니다. 기본적으로 @ContentChildren 데코레이터는 요청된 하위 컴포넌트 또는 디렉티브가 처음으로 나타나는 경우만 반환합니다. 모든 항목을 얻으려면 read 옵션을 사용할 수 있습니다. 1@ContentChildren(TabComponent, &#123; read: ElementRef &#125;) tabs: QueryList&lt;ElementRef&gt;; 이 예제에서는 ElementRef가 읽기 토큰으로 지정되어 @ContentChildren 데코레이터가 TabComponent 대신 ElementRef를 반환하게 됩니다. 전반적으로 @ContentChildren 데코레이터는 Angular 컴포넌트 및 디렉티브의 하위 콘텐츠에 액세스하고 상호 작용하기 위한 강력한 도구입니다. @Host @Host 데코레이터는 주어진 토큰과 일치하는 가장 가까운 호스트 요소의 종속성을 주입하는 데 사용됩니다. 이는 하위 요소에 디렉티브를 적용했지만 상위 요소의 속성이나 서비스에 액세스하려는 경우에 특히 유용합니다. @Host 데코레이터의 사용 예는 다음과 같습니다. 123456789101112131415import &#123; Directive, Host, Optional &#125; from '@angular/core';import &#123; ParentDirective &#125; from './parent.directive';@Directive(&#123; selector: '[child]',&#125;)export class ChildDirective &#123; constructor(@Host() @Optional() private parentDirective?: ParentDirective) &#123;&#125; ngOnInit() &#123; if (this.parentDirective) &#123; this.parentDirective.doSomething(); &#125; &#125;&#125; 위의 예에는 ParentDirective가 적용된 요소의 하위 요소에 적용되는 child 디렉티브가 있습니다. @Host 데코레이터는 ParentDirective가 적용된 가장 가까운 호스트 요소에서 ParentDirective 인스턴스를 주입하는 데 사용됩니다. @Optional 데코레이터는 ParentDirective가 포함된 호스트 요소가 없는 경우 생성자가 오류를 발생시키지 않도록 하는 데 사용됩니다. @HostListener @HostListener 데코레이터는 디렉티브의 호스트 요소에 이벤트 리스너를 등록하는 데 사용됩니다. 이 데코레이터는 @Directive 데코레이터의 host 속성과 함께 사용됩니다. 12345678910111213import &#123; Directive, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[appMyDirective]', host: &#123; '(click)': 'onClick($event)', &#125;,&#125;)export class MyDirective &#123; onClick(event: MouseEvent) &#123; console.log('Clicked!', event); &#125;&#125; 이 예에서는 @HostListener 데코레이터가 명시적으로 사용되지 않지만 host 속성에 암시되어 있습니다. 'click' 이벤트는 (click) 구문을 사용하여 onClick() 메서드에 등록됩니다. @HostListener 데코레이터를 명시적으로 사용할 수도 있습니다. 1234567891011import &#123; Directive, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[appMyDirective]',&#125;)export class MyDirective &#123; @HostListener('click', ['$event']) onClick(event: MouseEvent) &#123; console.log('Clicked!', event); &#125;&#125; 이 예제에서는 @HostListener 데코레이터를 명시적으로 사용하여 onClick() 메서드에 'click' 이벤트를 등록합니다. '$event' 인수는 이벤트 객체를 메서드에 전달하는 데 사용됩니다. @HostListener 데코레이터는 클릭 이벤트뿐만 아니라 모든 호스트 요소 이벤트와 함께 사용할 수 있습니다. @Inject @Inject 데코레이터를 사용하면 클래스의 종속성을 해결하는 데 사용할 토큰을 지정할 수 있습니다.@Injectable 및 @InjectableProvider와 함께 사용하여 종속성에 대한 custom provider를 제공할 수 있습니다. 예는 다음과 같습니다. 12345678import &#123; Injectable, Inject &#125; from '@angular/core';import &#123; ConfigService &#125; from './config.service';import &#123; AppConfig &#125; from './app.config';@Injectable()export class MyService &#123; constructor(@Inject(ConfigService) private config: AppConfig) &#123;&#125;&#125; 이 예에서는 ConfigService 토큰과 함께 @Inject 데코레이터를 사용하여 ConfigService 인스턴스를 MyService에 주입합니다. 이는 Angular가 ConfigService 공급자를 사용하여 종속성을 해결하도록 지시합니다. 다음과 같이 문자열 토큰과 함께 @Inject 데코레이터를 사용할 수도 있습니다. 123456import &#123; Injectable, Inject &#125; from '@angular/core';@Injectable()export class MyService &#123; constructor(@Inject('MY_CONFIG') private config: any) &#123;&#125;&#125; 이 예에서는 'MY_CONFIG' 토큰과 함께 값을 주입합니다. 원하는 문자열 토큰을 사용할 수 있지만 오타를 방지하려면 상수 값을 사용하는 것이 가장 좋습니다. 전반적으로 @Inject 데코레이터는 애플리케이션의 종속성 주입 동작을 커스터 마이징할 수 있는 강력한 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular] ViewRef: 뷰(View) 변경 감지 및 업데이트 알아보기","slug":"angular-25","date":"2023-10-26T02:43:28.000Z","updated":"2024-01-12T08:29:13.962Z","comments":true,"path":"2023/10/26/angular-25/","link":"","permalink":"http://hgko1207.github.io/2023/10/26/angular-25/","excerpt":"","text":"Angular는 개발자가 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있는 강력한 프런트 엔드 프레임워크입니다. Angular의 주요 기능 중 하나는 데이터가 변경될 때마다 뷰를 자동으로 업데이트하는 변경 감지 시스템입니다. 이 글에서는 Angular의 ViewRef 클래스에 대해 자세히 알아보고 이 클래스를 사용하여 변경 감지 프로세스 및 뷰 업데이트를 제어하는 방법을 살펴보겠습니다. Angular의 변경 감지 이해 변경 감지는 뷰가 항상 데이터와 함께 최신 상태를 유지하도록 보장하므로 Angular 프레임워크의 중요한 부분입니다. Angular는 데이터 변경 사항을 자동으로 추적하고 그에 따라 뷰를 업데이트하는 영역 기반 변경 감지 시스템을 사용합니다. 이 변경 감지 프로세스는 사용자 입력이나 데이터 업데이트 등 애플리케이션에서 이벤트가 발생할 때마다 트리거 됩니다. 자동 변경 감지 프로세스 외에도 Angular는 개발자에게 ViewRef 클래스를 사용하여 수동 변경 감지를 트리거하는 기능도 제공합니다. ViewRef 클래스는 컴포넌트의 뷰에 대한 참조이며 보기와 상호 작용하고 변경 감지 프로세스를 제어하는 데 사용할 수 있습니다. ViewRef 클래스 이해 ViewRef 클래스는 Angular 변경 감지 시스템의 핵심 컴포넌트입니다. 이는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공합니다. ViewRef 클래스에는 개발자가 뷰를 관리하는 데 사용할 수 있는 몇 가지 주요 메서드와 속성이 있습니다. discoverChanges(): 이 메서드는 뷰에 대한 변경 감지 프로세스를 트리거합니다. 이는 Angular에게 데이터 변경 사항을 확인하고 그에 따라 뷰를 업데이트하도록 지시합니다. markForCheck(): 이 메서드는 Angular가 다음 변경 감지 주기 동안 변경 사항을 확인하도록 뷰에 표시합니다. detach(): 이 메서드는 변경 감지 시스템에서 뷰를 분리합니다. 이는 변경 감지를 트리거하지 않고 뷰를 수동으로 업데이트하려는 상황에서 유용할 수 있습니다. destroy(): 이 메서드는 뷰를 파괴하고 DOM에서 제거합니다. ViewRef를 사용하여 변경 감지 제어 ViewRef 클래스는 개발자에게 Angular의 변경 감지 프로세스를 제어하는 방법을 제공합니다. detectorChanges() 메서드를 사용하면 개발자가 수동으로 변경 감지를 트리거하고 뷰를 업데이트할 수 있습니다. 이는 사용자 입력을 기반으로 뷰를 업데이트하는 경우와 같이 자동 변경 감지 시스템이 충분하지 않은 상황에서 유용할 수 있습니다. 변경 감지를 수동으로 트리거하는 것 외에도 개발자는 markForCheck() 메서드를 사용하여 변경 감지 프로세스를 최적화할 수도 있습니다. 이 메서드가 호출되면 Angular는 전체 컴포넌트 트리를 확인하는 대신 뷰와 해당 하위 항목의 변경 사항만 확인합니다. 이는 대규모 애플리케이션의 성능을 크게 향상시킬 수 있습니다. 예제 다음은 Angular에서 ViewRef를 사용하기 위한 몇 가지 코드 예제입니다. 예 1) 현재 컴포넌트의 뷰에 대한 참조 가져오기 1234567891011121314import &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `,&#125;)export class AppComponent implements AfterViewInit &#123; @ViewChild('header', &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef; ngAfterViewInit() &#123; const viewRef = this.headerRef['_view']; console.log(viewRef); &#125;&#125; 예 2) 동적으로 뷰를 생성하고 컴포넌트에 연결 123456789101112131415161718192021222324252627import &#123; Component, OnInit, ViewContainerRef, ViewChild, ComponentFactoryResolver &#125; from '@angular/core';import &#123; ViewRef &#125; from '@angular/core';import &#123; CustomComponent &#125; from './custom.component';@Component(&#123; selector: 'app-root', template: ` &lt;div #container&gt;&lt;/div&gt; `,&#125;)export class AppComponent implements OnInit &#123; @ViewChild('container', &#123; read: ViewContainerRef &#125;) containerRef: ViewContainerRef; constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125; ngOnInit() &#123; // Create a reference to the custom component factory const customComponentFactory = this.componentFactoryResolver.resolveComponentFactory(CustomComponent); // Create a new instance of the custom component and attach it to the view const customComponentRef = customComponentFactory.create(this.containerRef.injector); this.containerRef.insert(customComponentRef.hostView); // Get a reference to the newly created view const viewRef = customComponentRef.hostView as ViewRef; console.log(viewRef); &#125;&#125; 예 3) 컴포넌트에서 뷰 분리 123456789101112131415161718192021import &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; from '@angular/core';import &#123; ViewRef &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `,&#125;)export class AppComponent implements AfterViewInit &#123; @ViewChild('header', &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef; ngAfterViewInit() &#123; const viewRef = this.headerRef['_view']; console.log(viewRef); // Detach the view from the component viewRef.detach(); // Check if the view is still attached to the component console.log(viewRef['_attached']); &#125;&#125; 결론 결론적으로 ViewRef 클래스는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공하는 Angular 프레임워크의 강력한 도구입니다. ViewRef 클래스를 사용하여 개발자는 수동으로 변경 감지를 트리거하고, 변경 감지 프로세스를 최적화하고, View 생명 주기를 제어할 수 있습니다. ViewRef 클래스를 사용하는 방법을 이해하는 것은 복잡하고 반응성이 뛰어난 Angular 애플리케이션을 개발하는 데 필수적인 부분입니다. 이 글에 설명된 모범 사례를 따르면 ViewRef 클래스를 사용하여 변경 감지 프로세스를 최적화하고 뷰를 최신 데이터로 최신 상태로 유지할 수 있습니다. Angular의 변경 감지 시스템을 손쉽게 활용하면 원활한 사용자 경험을 제공하는 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"ViewRef","slug":"ViewRef","permalink":"http://hgko1207.github.io/tags/ViewRef/"},{"name":"뷰","slug":"뷰","permalink":"http://hgko1207.github.io/tags/%EB%B7%B0/"}]},{"title":"[Angular] ViewEncapsulation: 다양한 모드 및 사용 방법 알아보기","slug":"angular-24","date":"2023-10-25T05:35:34.000Z","updated":"2023-12-11T04:28:52.307Z","comments":true,"path":"2023/10/25/angular-24/","link":"","permalink":"http://hgko1207.github.io/2023/10/25/angular-24/","excerpt":"","text":"Angular는 개발자에게 ViewEncapsulation을 포함하여 컴포넌트를 빌드하고 스타일을 지정할 수 있는 여러 도구를 제공합니다. 이 글에서는 ViewEncapsulation이 무엇인지, ViewEncapsulation이 제공하는 다양한 모드와 각 모드를 언제 사용하는지 살펴보겠습니다. ViewEncapsulation 이란 ViewEncapsulation은 컴포넌트의 스타일을 캡슐화하는 Angular 기능입니다. 즉, 원치 않는 스타일 충돌을 방지하기 위해 컴포넌트의 스타일을 애플리케이션의 다른 부분과 분리합니다. 또한 ViewEncapsulation을 사용하면 컴포넌트가 다른 컴포넌트에 영향을 주지 않는 자체 비공개 스타일을 가질 수 있습니다. Angular는 Emulated, None 및 Shadow DOM의 세 가지 ViewEncapsulation 모드를 제공합니다. 각 모드를 자세히 살펴보고 각 모드를 언제 사용해야 하는지 알아보겠습니다. Emulated Emulated는 Angular의 기본 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 스타일 범위를 해당 요소에만 적용하기 위해 컴포넌트의 HTML 요소에 고유한 속성을 추가합니다. 예는 다음과 같습니다. 123456789101112@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ],&#125;)export class ExampleComponent &#123;&#125; Emulated 모드에서 Angular는 위 컴포넌트의 HTML과 CSS를 다음과 같이 변환합니다. 123&lt;app-example _ngcontent-abc&gt; &lt;h1 _ngcontent-abc&gt;Hello World!&lt;/h1&gt;&lt;/app-example&gt; 123h1[_ngcontent-abc] &#123; color: red;&#125; h1 요소의 스타일 범위를 해당 컴포넌트로만 지정하는 _ngcontent-abc 속성이 추가되었습니다. 컴포넌트의 스타일을 캡슐화하고 원치 않는 스타일 충돌을 방지하려면 Emulated 모드를 사용하십시오. None None은 캡슐화를 완전히 제거하는 Angular의 또 다른 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 HTML 요소에 속성을 추가하지 않으므로 스타일이 컴포넌트 밖으로 누출되어 애플리케이션의 다른 부분에 영향을 미칠 수 있습니다. 예는 다음과 같습니다. 12345678910111213@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ], encapsulation: ViewEncapsulation.None,&#125;)export class ExampleComponent &#123;&#125; None 모드에서 Angular는 컴포넌트의 HTML과 CSS를 어떤 방식으로든 변환하지 않습니다. 전역 스타일을 적용해야 하거나 다른 컴포넌트의 스타일을 재정의하려는 경우 None 모드를 사용하세요. Shadow DOM Shadow DOM은 Angular의 최종 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 스타일을 캡슐화합니다. Shadow DOM은 컴포넌트의 HTML 및 CSS에 대해 별도의 DOM 트리를 생성하여 컴포넌트의 스타일을 애플리케이션의 다른 부분과 격리합니다. 예는 다음과 같습니다. 12345678910111213@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ], encapsulation: ViewEncapsulation.ShadowDom,&#125;)export class ExampleComponent &#123;&#125; Shadow DOM 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 HTML 및 CSS에 대한 별도의 DOM 트리를 생성합니다. 최고 수준의 캡슐화를 원하고 컴포넌트 스타일이 애플리케이션의 나머지 부분에 영향을 받는 것을 원하지 않을 때 Shadow DOM 모드를 사용하세요. 결론 Angular의 ViewEncapsulation을 이해하면 재사용 및 유지 관리가 가능한 컴포넌트를 만드는 능력이 크게 향상될 수 있습니다. ViewEncapsulation을 적절하게 사용하면 컴포넌트 간의 스타일 및 레이아웃 충돌을 방지하고 일관된 사용자 인터페이스를 유지할 수 있습니다. Emulated, Native 또는 None ViewEncapsulation 중 무엇을 사용하든 각 옵션과 관련된 장단점을 염두에 두고 프로젝트 요구 사항에 가장 적합한 옵션을 선택하는 것이 중요합니다. 전반적으로 ViewEncapsulation은 간과해서는 안 되는 Angular 개발의 중요한 측면입니다. 모범 사례를 따르고 정보에 입각한 결정을 내리면 확장 가능하고 유지 관리 가능한 고품질 Angular 애플리케이션을 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"캡슐화","slug":"캡슐화","permalink":"http://hgko1207.github.io/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"ViewEncapsulation","slug":"ViewEncapsulation","permalink":"http://hgko1207.github.io/tags/ViewEncapsulation/"}]},{"title":"[Angular] 생명주기(Lifecycle) 와 훅(Hook) 메서드 이해","slug":"angular-23","date":"2023-10-24T02:00:01.000Z","updated":"2024-01-12T08:28:29.764Z","comments":true,"path":"2023/10/24/angular-23/","link":"","permalink":"http://hgko1207.github.io/2023/10/24/angular-23/","excerpt":"","text":"Angular는 개발자가 동적이고 반응성이 뛰어난 웹 애플리케이션을 구축할 수 있는 강력한 프레임워크입니다. Angular의 주요 기능 중 하나는 각 컴포넌트가 고유한 생명주기(Lifecycle)를 갖는 컴포넌트 기반 아키텍처입니다. 이러한 생명주기를 이해하는 것은 효율적이고 성능이 뛰어난 애플리케이션을 구축하는 데 중요합니다. 이 글에서는 Angular에서 사용할 수 있는 다양한 생명주기 훅(Hook) 메서드와 차이점, 그리고 이를 사용하는 모범 사례를 살펴보겠습니다. 생명주기 훅 메서드이란 무엇입니까? Angular 생명주기 훅 메서드는 컴포넌트 생명 주기 중 특정 지점에서 호출되는 메서드입니다. 이러한 훅 메서드를 사용하면 컴포넌트(component)의 초기화, 생성 및 삭제와 같은 특정 시점에 작업을 수행할 수 있습니다. Angular에는 8개의 생명주기 메서드가 있습니다. ngOnChanges(): 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다. ngOnInit(): 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다. ngDoCheck(): 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다. ngAfterContentInit(): 컴포넌트의 콘텐츠가 해당 뷰에 투영된 후에 호출됩니다. ngAfterContentChecked(): 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다. ngAfterViewInit(): 컴포넌트의 뷰가 초기화된 후에 호출됩니다. ngAfterViewChecked(): 컴포넌트 뷰를 확인할 때마다 호출됩니다. ngOnDestroy(): 컴포넌트가 파괴되기 직전에 호출됩니다. 이러한 각 메서드는 컴포넌트 생명 주기에서 특정 목적을 수행하므로 특정 시점에 작업을 수행할 수 있습니다. 차이점 이러한 생명 주기 훅 메서드 간의 몇 가지 차이점을 자세히 살펴보겠습니다. ngOnChanges() vs ngOnInit() ngOnChanges() 메서드는 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다. 컴포넌트 입력 데이터의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. 반면에 ngOnInit()은 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다. 초기화 작업을 수행하거나 서비스에서 데이터를 검색해야 할 때 유용합니다. ngDoCheck() vs ngAfterContentChecked() ngDoCheck() 메서드는 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다. 사용자 정의(Custom) 변경 감지를 수행해야 하거나 사용자 정의 변경 감지 전략을 구현해야 할 때 유용합니다. 반면에 ngAfterContentChecked()는 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 콘텐츠의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. ngAfterViewInit() vs ngAfterViewChecked() ngAfterViewInit() 메서드는 컴포넌트의 뷰가 초기화된 후에 호출됩니다. 컴포넌트의 뷰에 액세스해야 하는 초기화 작업을 수행해야 할 때 유용합니다. 반면에 ngAfterViewChecked()는 컴포넌트 뷰를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 뷰의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. 모범사례 ngOnInit() 메서드에서 복잡한 논리를 피하십시오. 컴포넌트 속성을 초기화하고 기본 설정 작업을 수행하는 데에만 사용해야 합니다. 더 복잡한 로직을 수행해야 하는 경우 별도의 서비스나 기능으로 이동하는 것을 고려해 보세요. 반응형 입력 처리를 위해 ngOnChanges()를 사용하세요. 입력 속성에 대한 변경 사항을 처리하기 위해 특별히 설계되었습니다. 이를 사용하여 컴포넌트 상태를 업데이트하거나 입력 값의 변경 사항에 따라 다른 작업을 수행합니다. DOM 조작을 위해 ngAfterViewInit() 메서드를 사용하세요. 뷰가 초기화된 후에 호출되며 DOM을 조작하기에 적합한 위치입니다. 이를 사용하여 이벤트 리스너를 설정하고 요소를 추가 또는 제거하거나 기타 DOM 관련 작업을 수행합니다. 정리를 위해 ngOnDestroy()를 사용하지 마세요. 컴포넌트 리소스를 정리하도록 설계되었지만 항상 신뢰할 수 있는 것은 아닙니다. 대신 서비스를 사용하거나 컴포넌트의 ngOnDestroy 이벤트를 구독하여 정리 작업을 수행하는 것을 고려해 보세요. 다음은 ngOnDestroy()에만 의존하는 대신 서비스를 사용하여 정리 작업을 수행하는 방법에 대한 예입니다. 1234567891011121314151617import &#123; Injectable &#125; from '@angular/core';import &#123; Subscription &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class CleanupService &#123; private subscriptions: Subscription[] = []; addSubscription(subscription: Subscription): void &#123; this.subscriptions.push(subscription); &#125; cleanup(): void &#123; this.subscriptions.forEach((subscription) =&gt; subscription.unsubscribe()); &#125;&#125; 그런 다음 컴포넌트에 CleanupService를 삽입하고 이를 사용하여 Subscription(구독)을 관리할 수 있습니다. 123456789101112131415161718192021222324252627import &#123; Component, OnInit, OnDestroy &#125; from '@angular/core';import &#123; interval, Subscription &#125; from 'rxjs';import &#123; CleanupService &#125; from './cleanup.service';@Component(&#123; selector: 'app-example', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;',&#125;)export class ExampleComponent implements OnInit, OnDestroy &#123; message: string; private subscription: Subscription; constructor(private cleanupService: CleanupService) &#123;&#125; ngOnInit(): void &#123; this.subscription = interval(1000).subscribe(() =&gt; &#123; this.message = 'Hello, world!'; &#125;); this.cleanupService.addSubscription(this.subscription); &#125; ngOnDestroy(): void &#123; // Don't use ngOnDestroy for cleanup! // Instead, use the CleanupService to perform cleanup tasks. this.cleanupService.cleanup(); &#125;&#125; 위의 예에서는 CleanupService를 사용하여 컴포넌트의 Subscription을 관리합니다. addSubscription() 메서드는 Subscription 배열에 추가하고 cleanup() 메서드는 배열의 각 Subscription에 대해 unsubscribe()를 호출합니다. 그런 다음 컴포넌트의 ngOnDestroy() 메서드에서 ngOnDestroy()에만 의존하는 대신 CleanupService를 사용하여 정리 작업을 수행합니다. 이렇게 하면 어떤 이유로 ngOnDestroy()가 호출되지 않더라도 컴포넌트의 리소스가 적절하게 정리됩니다. 이러한 사례를 따르면 일반적인 함정을 피하고 성능을 향상시키면서 컴포넌트가 현재 작업에 적합한 생명 주기를 사용하고 있는지 확인할 수 있습니다. 결론적으로, 고품질의 고성능 Angular 애플리케이션을 구축하려면 Angular 생명 주기를 이해하는 것이 중요합니다. 각 훅 메서드 간의 차이점을 살펴보고 사례를 따르면 Angular 프레임워크를 최대한 활용하고 강력하고 유지 관리가 가능한 애플리케이션을 구축할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"http://hgko1207.github.io/tags/Lifecycle/"},{"name":"생명주기","slug":"생명주기","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"},{"name":"Hook","slug":"Hook","permalink":"http://hgko1207.github.io/tags/Hook/"},{"name":"훅","slug":"훅","permalink":"http://hgko1207.github.io/tags/%ED%9B%85/"}]},{"title":"[.NET Core] 코드 예제를 통해 멀티스레딩 마스터하기","slug":"csharp-6","date":"2023-10-23T01:09:59.000Z","updated":"2023-11-10T12:32:50.178Z","comments":true,"path":"2023/10/23/csharp-6/","link":"","permalink":"http://hgko1207.github.io/2023/10/23/csharp-6/","excerpt":"","text":"C# .NET Core의 멀티스레딩과 관련하여 최적의 성능을 달성하고 일반적인 함정을 피하기 위해 명심해야 할 몇 가지 모범 사례가 있습니다. 몇 가지 코드 예제를 통해 각각에 대해 자세히 살펴보겠습니다. 과도한 잠금 방지 다중 스레드 코드로 작업할 때 흔히 저지르는 실수 중 하나는 너무 많은 잠금을 사용하는 것입니다. 여러 스레드가 동시에 액세스하지 못하도록 공유 리소스를 보호하려면 잠금이 필요하지만 과도한 잠금은 스레드 경합 및 성능 저하를 초래할 수 있습니다. 대신 필요한 경우에만 잠금을 사용하고 적절한 경우 Interlocked 작업 또는 Concurrent 컬렉션 클래스와 같은 다른 동기화 메커니즘을 사용하는 것을 고려하십시오. 12345678910private readonly object _lock = new object();private int _count;public void IncrementCount()&#123; lock (_lock) &#123; _count++; &#125;&#125; Thread-Safe 데이터 구조 사용 공유 데이터 구조로 작업할 때 데이터 손상이나 경합 조건을 방지하기 위해 thread-safe 컬렉션을 사용하는 것이 중요합니다. .NET Core 라이브러리는 스레드 간에 데이터를 안전하게 공유하는 데 사용할 수 있는 ConcurrentDictionary 및 ConcurrentQueue 와 같은 여러 스레드로부터 안전한 컬렉션을 제공합니다. 123456private readonly ConcurrentDictionary&lt;string, int&gt; _dict = new ConcurrentDictionary&lt;string, int&gt;();public void AddOrUpdateDict(string key, int value)&#123; _dict.AddOrUpdate(key, value, (k, v) =&gt; v + value);&#125; ThreadPool 사용 스레드를 만들고 관리하는 작업은 비용이 많이 들 수 있으므로 가능하면 .NET Core ThreadPool을 사용하는 것이 가장 좋습니다. ThreadPool은 재사용할 수 있는 스레드 풀을 관리하므로 스레드 생성 및 삭제에 따른 오버헤드를 줄여 성능을 향상시킬 수 있습니다. 123ThreadPool.QueueUserWorkItem((state) =&gt; &#123; // Do some work on a background thread&#125;); 교착상태 주의 교착 상태는 두 개 이상의 스레드가 서로 리소스를 해제할 때까지 기다리면서 차단되어 더 이상 진행이 불가능한 상황이 발생하는 경우에 발생합니다. 교착 상태를 방지하려면 잠금을 올바른 순서로 획득 및 해제하고 장기간 잠금을 유지하지 않는 것이 중요합니다. 1234567891011121314private readonly object _lock1 = new object();private readonly object _lock2 = new object();public void DoWork()&#123; lock (_lock1) &#123; // Do some work lock (_lock2) &#123; // Do some more work &#125; &#125;&#125; 비동기 프로그래밍 사용 비동기 프로그래밍은 다중 스레드 코드로 작업할 때 호출 스레드를 차단하지 않고 여러 작업을 동시에 수행할 수 있는 강력한 도구가 될 수 있습니다. async 및 await 키워드를 사용하면 동기적인 것처럼 보이지만 실제로는 별도의 스레드에서 비동기적으로 실행되는 코드를 작성할 수 있습니다. 12345678public async Task&lt;string&gt; DownloadAsync(string url)&#123; using (var client = new HttpClient()) &#123; var response = await client.GetAsync(url); return await response.Content.ReadAsStringAsync(); &#125;&#125; 모범 사례 이러한 모범 사례를 따르면 C# .NET Core에서 확장 가능한 고성능 다중 스레드 코드를 작성할 수 있습니다. 다음은 .NET Core의 다중 스레딩에 대한 모범 사례를 사용하는 몇 가지 실제 예입니다. 비동기식 HTTP 요청 웹 애플리케이션에서는 다른 서비스에 HTTP 요청을 보내는 것이 일반적입니다. 기본 스레드를 차단하지 않으려면 이러한 요청은 HttpClient를 사용하여 비동기적으로 이루어져야 합니다. 123456public async Task&lt;string&gt; GetApiDataAsync(string apiUrl)&#123; using var client = new HttpClient(); var response = await client.GetAsync(apiUrl); return await response.Content.ReadAsStringAsync();&#125; CPU 바인딩된 작업 병렬화 CPU 바인딩된(CPU-bound) 작업을 수행할 때 여러 스레드에 걸쳐 작업을 병렬화하여 성능을 향상시키는 것이 유용한 경우가 많습니다. .NET Core의 Parallel 클래스는 루프를 병렬화하는 쉬운 방법을 제공합니다. 123Parallel.For(0, 100000, (i) =&gt; &#123; // Perform CPU-bound work here&#125;); 경쟁 조건을 피하기 위해 잠금 사용 여러 스레드가 공유 리소스에 액세스하면 한 스레드가 리소스를 읽거나 수정하는 동안 다른 스레드도 리소스에 액세스하는 경쟁 조건이 발생할 위험이 있습니다. 이를 방지하기 위해 잠금을 사용하여 한 번에 하나의 스레드만 공유 리소스에 액세스할 수 있도록 할 수 있습니다. 12345678910private readonly object _lock = new object();private int _sharedResource = 0;public void IncrementSharedResource()&#123; lock (_lock) &#123; _sharedResource++; &#125;&#125; 메인 스레드에서 blocking 방지 UI 애플리케이션에서는 기본 스레드를 blocking하고 애플리케이션이 응답하지 않게 만드는 것을 방지하기 위해 파일 I/O 또는 데이터베이스 쿼리와 같은 blocking 작업을 백그라운드 스레드에서 수행해야 합니다. 12345678910public async Task LoadDataAsync()&#123; var data = await GetDataFromDatabaseAsync(); // Update UI with data on the main thread await Task.Run(() =&gt; &#123; // Perform file I/O or other blocking operation on a background thread &#125;); // Continue updating UI with more data on the main thread&#125; 예제 제품 정보, 가격 및 가용성에 대한 대량의 동시 요청을 처리하는 대규모 전자 상거래 웹 사이트용 애플리케이션을 구축한다고 가정해 보겠습니다. 웹사이트는 각 제품 카테고리에 대해 별도의 서비스를 제공하는 마이크로서비스 아키텍처를 사용하며, 각 서비스는 여러 클라이언트의 요청을 처리합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProductService&#123; private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(); private readonly ConcurrentDictionary&lt;int, Product&gt; _products = new ConcurrentDictionary&lt;int, Product&gt;(); public async Task&lt;Product&gt; GetProductAsync(int productId) &#123; // Use a read lock to allow multiple threads to read from the dictionary simultaneously _lock.EnterReadLock(); try &#123; if (_products.TryGetValue(productId, out Product product)) &#123; return product; &#125; else &#123; // If the product is not found in the dictionary, use a write lock to add it _lock.ExitReadLock(); _lock.EnterWriteLock(); try &#123; product = await GetProductFromServiceAsync(productId); _products.TryAdd(productId, product); return product; &#125; finally &#123; _lock.ExitWriteLock(); _lock.EnterReadLock(); &#125; &#125; &#125; finally &#123; _lock.ExitReadLock(); &#125; &#125; private async Task&lt;Product&gt; GetProductFromServiceAsync(int productId) &#123; // Use async/await to make an asynchronous API call using (HttpClient client = new HttpClient()) &#123; string url = $\"https://api.example.com/products/&#123;productId&#125;\"; HttpResponseMessage response = await client.GetAsync(url); string json = await response.Content.ReadAsStringAsync(); return JsonConvert.DeserializeObject&lt;Product&gt;(json); &#125; &#125;&#125; 이 예에서는 여러 스레드가 _products에서 동시에 읽을 수 있도록 ReaderWriterLockSlim을 사용하고 있습니다. Dictionary에 없는 제품이 요청되면 write lock을 사용하여 추가합니다. 또한 제품 데이터를 검색하기 위해 비동기 API 호출을 만들기 위해 async/await를 사용하고 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"스레드","slug":"스레드","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"}]},{"title":"Node.js, Express를 사용하여 간단한 웹 크롤러 만들기","slug":"nodejs-6","date":"2023-10-19T02:49:28.000Z","updated":"2023-12-14T14:38:53.252Z","comments":true,"path":"2023/10/19/nodejs-6/","link":"","permalink":"http://hgko1207.github.io/2023/10/19/nodejs-6/","excerpt":"","text":"스파이더라고도 알려진 웹 크롤러(Web crawler)는 인터넷을 탐색하고, 웹사이트를 방문하고, 다양한 목적으로 데이터를 추출하는 자동화된 프로그램입니다. 웹 크롤러를 구축하는 것은 복잡한 작업일 수 있지만 올바른 도구와 지침을 사용하면 보람 있는 경험이 될 수 있습니다. 이 글에서는 Node.js, Express 및 TypeScript를 사용하여 간단한 웹 크롤러를 구축하는 방법을 살펴보겠습니다. 1. 프로젝트 설정 시작하려면 새 Node.js 프로젝트를 만들고 필요한 종속성을 설치해야 합니다. 우리는 다음 패키지를 사용할 것입니다. Express — 쉽게 서버를 생성하고 HTTP 요청을 처리할 수 있게 해주는 인기 있는 Node.js 웹 프레임워크입니다. Cheerio — HTML 및 XML 문서를 탐색하고 조작할 수 있게 해주는 jQuery와 유사한 Node.js용 라이브러리입니다. Request — HTTP 요청을 쉽게 보내고 응답을 처리할 수 있게 해주는 간단한 Node.js용 HTTP 클라이언트입니다. 새 Node.js 프로젝트를 생성한 후 다음 명령을 사용하여 패키지를 설치할 수 있습니다. 1npm install express cheerio request 다음을 실행하여 TypeScript를 dev 종속성(devDependencies)으로 설치할 수도 있습니다. 1npm install -D typescript @types/node @types/express @types/cheerio @types/request 2. 서버 설정 이 섹션에서는 HTTP 요청을 수신하고 응답을 반환하는 간단한 Express 서버를 만듭니다. 또한 웹 크롤러가 크롤링을 시작할 수 있는 경로를 추가할 것입니다. 먼저 server.ts라는 새 파일을 만들고 다음 코드를 추가하겠습니다. 12345678910111213141516import express, &#123; Request, Response &#125; from 'express';const app = express();const port = 3000;app.get('/', (req: Request, res: Response) =&gt; &#123; res.send('Welcome to the Web Crawler');&#125;);app.get('/crawl', (req: Request, res: Response) =&gt; &#123; // Add code for crawling here&#125;);app.listen(port, () =&gt; &#123; console.log(`Server running on port $&#123;port&#125;`);&#125;); 이 코드는 새로운 Express 애플리케이션을 생성하고 / 및 /crawl이라는 두 가지 경로를 정의합니다. / 경로는 단순히 사용자에게 환영 메시지를 반환하는 반면 /crawl 경로는 크롤링 프로세스를 시작하는 데 사용됩니다. 3. 웹사이트 크롤링 이제 서버를 설정했으므로 웹사이트 크롤링을 시작할 수 있습니다. 이 예에서는 Google 홈페이지를 크롤링하고 페이지 제목을 추출합니다. /crawl 경로 내에 다음 코드를 추가합니다. 12345678910111213141516import request from 'request';import cheerio from 'cheerio';app.get('/crawl', (req: Request, res: Response) =&gt; &#123; const url = 'https://www.google.com'; request(url, (error, response, html) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; const $ = cheerio.load(html); const title = $('title').text(); res.send(`The title of $&#123;url&#125; is: $&#123;title&#125;`); &#125; else &#123; res.send(`Error crawling $&#123;url&#125;`); &#125; &#125;);&#125;); 이 코드는 HTTP GET 요청을 지정된 URL로 보내고 HTML 응답을 Cheerio 개체에 로드합니다. 그런 다음 Cheerio를 사용하여 페이지 제목을 추출하고 이를 사용자에게 응답으로 다시 보낼 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Express","slug":"Express","permalink":"http://hgko1207.github.io/tags/Express/"},{"name":"웹 크롤러","slug":"웹-크롤러","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC/"},{"name":"Cheerio","slug":"Cheerio","permalink":"http://hgko1207.github.io/tags/Cheerio/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"}]},{"title":"[Angular] Tree Shaking: 애플리케이션 크기 최적화","slug":"angular-22","date":"2023-10-16T07:03:12.000Z","updated":"2024-01-12T08:27:11.891Z","comments":true,"path":"2023/10/16/angular-22/","link":"","permalink":"http://hgko1207.github.io/2023/10/16/angular-22/","excerpt":"","text":"Angular는 단일 페이지 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 애플리케이션이 복잡해지면 크기도 커지며 이로 인해 로드 시간이 느려지고 성능이 저하될 수 있습니다. Angular 애플리케이션의 크기를 최적화하는 한 가지 기술은 트리 쉐이킹(Tree Shaking)을 이용하는 것입니다. 이 글에서는 트리 쉐이킹이 무엇인지, 어떻게 작동하는지, Angular 프로젝트에서 구현하는 방법을 살펴보겠습니다. 트리 쉐이킹(Tree Shaking)이란 무엇입니까? 트리 쉐이킹은 애플리케이션에서 사용되지 않는 코드를 제거하는 프로세스입니다. 코드와 해당 종속성을 분석하고 사용되지 않는 부분을 식별한 다음 안전하게 제거할 수 있는 방식으로 작동합니다. 트리 쉐이킹은 모듈과 종속성이 많은 대규모 애플리케이션에 특히 유용합니다. 트리 쉐이킹은 어떻게 작동하나요? 트리 쉐이킹은 JavaScript 모듈의 정적 특성에 의존합니다. 모듈을 임포트 하면 모듈 전체가 로드되지만 실제로 사용되는 부분만 실행됩니다. 사용되지 않은 코드는 실행되지 않으므로 최종 번들에 포함되지 않습니다. 이렇게 하면 애플리케이션의 크기가 크게 줄어들고 성능이 향상될 수 있습니다. Angular에서 트리 쉐이킹 구현 Angular 애플리케이션에서 트리 쉐이킹을 구현하려면 Webpack과 같은 이를 지원하는 빌드 도구를 사용해야 합니다. 애플리케이션을 빌드할 때 Webpack은 코드를 분석하고 사용되지 않는 코드를 제거하여 번들 크기를 더 작게 만듭니다. 지연 로딩을 사용하여 필요한 모듈만 로드하고, 전역 변수를 피하고, 실제로 사용되는 모듈 부분만 가져오는 등 Angular 개발에 대한 모범 사례를 따르면 트리 쉐이킹 프로세스에 도움이 될 수도 있습니다. 트리 쉐이킹 검증 응용 프로그램에서 트리 쉐이킹이 실제로 작동하는지 확인하는 것이 중요합니다. 트리 쉐이킹을 구현하기 전과 후에 번들로 제공되는 JavaScript 파일의 크기를 분석하여 이를 수행할 수 있습니다. 또한 사용되지 않더라도 여전히 포함되어 있는 애플리케이션 부분을 식별하려면 Webpack Bundle Analyser와 같은 도구를 사용해야 합니다. 일반적인 함정 및 팁 트리 쉐이킹을 구현할 때 흔히 발생하는 함정 중 하나는 트리 쉐이킹에 최적화되지 않은 타사 라이브러리에 너무 많이 의존한다는 것입니다. 트리 쉐이킹을 지원하는 라이브러리를 사용하거나 이 기술에 최적화된 대체 라이브러리를 사용하십시오. 또 다른 팁은 Webpack이 코드를 분석하고 트리 쉐이킹을 적절하게 적용하기 어렵게 만들 수 있는 동적 가져오기를 사용하지 않는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Tree Shaking","slug":"Tree-Shaking","permalink":"http://hgko1207.github.io/tags/Tree-Shaking/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"트리 쉐이킹","slug":"트리-쉐이킹","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9/"}]},{"title":"[Angular] Zone.js 파일: 성능 향상을 위해 이해하고 사용하기","slug":"angular-21","date":"2023-10-08T14:01:36.000Z","updated":"2023-12-14T14:39:06.353Z","comments":true,"path":"2023/10/08/angular-21/","link":"","permalink":"http://hgko1207.github.io/2023/10/08/angular-21/","excerpt":"","text":"Angular는 가장 널리 사용되는 JavaScript 프레임워크 중 하나이며 개발을 보다 효율적으로 만들어주는 많은 도구와 기능을 갖추고 있습니다. 그러한 도구 중 하나가 개발자가 애플리케이션의 변경 사항을 추적하고 성능을 향상시키는 데 도움이 되는 라이브러리인 Zone.js입니다. 이 글에서는 Zone.js가 무엇인지, 어떻게 작동하는지, 그리고 이를 사용하여 Angular 애플리케이션을 최적화할 수 있는 방법에 대해 자세히 살펴보겠습니다. Zone.js 란 무엇입니까? Zone.js는 개발자가 애플리케이션의 변경 사항을 추적하는 데 도움이 되는 JavaScript 라이브러리입니다. 타이머, 이벤트, XHR 요청과 같은 브라우저의 API에 연결하여 이를 수행합니다. Zone.js가 설치되면 추적하려는 코드 주위에 “zone” 이 생성됩니다. 이 영역은 그 안에서 발생하는 모든 변경 사항을 추적하며 성능을 최적화하는 데 사용될 수 있습니다. Zone.js는 어떻게 작동하나요? Zone.js는 코드 주위에 &quot;zone&quot;이라고 하는 wrapper를 생성하여 작동합니다. 이 영역에는 변경 사항을 포함하여 애플리케이션 상태에 대한 정보가 포함되어 있습니다. 영역 내에서 변경 사항이 발생할 때마다 Zone.js는 이를 기록하고 그에 따라 애플리케이션을 업데이트합니다. 예를 들어, HTTP 요청을 하는 Angular 컴포넌트가 있는 경우 Zone.js는 컴포넌트의 코드 주위에 영역을 만듭니다. HTTP 요청이 이루어지면 Zone.js는 이를 추적하고 그에 따라 컴포넌트의 상태를 업데이트합니다. 성능 최적화를 위해 Zone.js 사용 Zone.js는 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키는 등 다양한 성능 최적화 작업에 사용할 수 있습니다. Zone.js를 사용하는 한 가지 방법은 HTTP 요청을 그룹화하여 HTTP 요청 수를 줄이는 것입니다. 예를 들어 zone.runOutsideAngular() 메서드를 사용하여 Angular 영역 외부에서 HTTP 요청을 실행할 수 있습니다. 이렇게 하면 요청이 Zone.js에 의해 추적되지 않고 성능 향상을 위해 다른 요청과 함께 그룹화될 수 있습니다. 성능 최적화를 위해 Zone.js를 사용하는 또 다른 방법은 애플리케이션의 응답성을 향상시키는 것입니다. zone.run() 메서드를 사용하여 영역 내에서 애플리케이션의 상태를 업데이트할 수 있습니다. 이렇게 하면 다음 변경 감지 주기를 기다리지 않고 즉시 변경이 이루어집니다. 고급 Zone.js 기술 Zone.js에는 보다 복잡한 성능 최적화 작업에 사용할 수 있는 몇 가지 고급 기능이 있습니다. 그러한 기능 중 하나는 사용자 정의 영역(custom zone)을 생성하는 기능입니다. 사용자 정의 영역을 사용하면 전체 애플리케이션이 아닌 애플리케이션의 특정 부분의 변경 사항을 추적할 수 있습니다. 또 다른 고급 기술은 Zone.js를 사용하여 변경 감지를 제어하는 ​​기능입니다. 기본적으로 Angular는 NgZone 클래스를 사용하여 변경 감지를 처리합니다. 그러나 Zone.js를 사용하여 변경 감지를 제어하고 특정 애플리케이션에 맞게 최적화할 수 있습니다. 결론 결론적으로 Zone.js는 Angular 애플리케이션의 성능 최적화를 위한 강력한 도구입니다. 코드 주위에 영역을 생성하여 변경 사항을 추적하고 그에 따라 애플리케이션을 업데이트하는 방식으로 작동합니다. Zone.js를 사용하면 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키며 성능 향상을 위해 변경 감지를 제어할 수 있습니다. 이 글에서 다루는 기술을 사용하면 Zone.js를 사용하여 더 나은 성능을 위해 Angular 애플리케이션을 최적화할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Zone.js","slug":"Zone-js","permalink":"http://hgko1207.github.io/tags/Zone-js/"},{"name":"성능향상","slug":"성능향상","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81/"}]},{"title":"[.NET Core] RabbitMQ 사용 가이드","slug":"csharp-5","date":"2023-09-13T01:06:18.000Z","updated":"2023-11-17T06:28:00.005Z","comments":true,"path":"2023/09/13/csharp-5/","link":"","permalink":"http://hgko1207.github.io/2023/09/13/csharp-5/","excerpt":"","text":"RabbitMQ는 안정적이고 확장 가능한 메시징을 위해 최신 분산 시스템에서 널리 사용되는 오픈 소스 메시지 브로커 소프트웨어입니다. Erlang으로 작성되었으며 AMQP, MQTT, STOMP와 같은 여러 프로토콜을 지원합니다. RabbitMQ는 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다. 이 글에서는 크로스 플랫폼 웹 애플리케이션 구축을 위한 인기 있고 강력한 프레임워크인 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보겠습니다. RabbitMQ의 기본 사항, 아키텍처 및 개념, .NET Core 애플리케이션과 통합하는 방법을 다룹니다. 1. RabbitMQ란 무엇입니까? RabbitMQ는 다양한 소프트웨어 애플리케이션 간의 통신을 가능하게 하는 메시지 브로커 소프트웨어입니다. 이는 AMQP(Advanced Message Queuing Protocol)를 기반으로 하며 최신 분산 시스템을 위한 안정적이고 확장 가능한 메시징 솔루션을 제공합니다. RabbitMQ는 다양한 애플리케이션과 서비스 간의 비동기 통신을 허용합니다. 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다. 2. RabbitMQ 아키텍처 및 개념 RabbitMQ는 서버가 메시지 저장 및 전달을 담당하고 클라이언트가 메시지 생성 및 소비를 담당하는 client-server 모델을 따릅니다. 이는 메시지가 대기열에 배치된 다음 클라이언트에서 사용되는 대기열 기반 모델을 사용합니다. RabbitMQ는 AMQP, MQTT, STOMP와 같은 여러 메시징 프로토콜을 지원합니다. 또한 메시지 라우팅, 메시지 확인, 메시지 지속성과 같은 고급 기능도 지원합니다. 3. RabbitMQ 서버 설치 .NET Core에서 RabbitMQ를 사용하려면 먼저 RabbitMQ 서버를 설치해야 합니다. RabbitMQ는 Windows, macOS, Linux 등 다양한 플랫폼에서 사용할 수 있습니다. Windows에 RabbitMQ를 설치하려면 공식 웹사이트에서 설치 프로그램을 다운로드하고 실행합니다. Linux에서는 패키지 관리자를 사용하여 RabbitMQ를 설치할 수 있습니다. 4. .NET Core에서 RabbitMQ 설정 .NET Core에서 RabbitMQ를 사용하려면 RabbitMQ.Client NuGet 패키지를 설치해야 합니다. 이 패키지에는 RabbitMQ와 상호 작용하는 데 필요한 클래스와 메서드가 포함되어 있습니다. 또한 RabbitMQ에 대한 연결 설정을 구성해야 합니다. 연결 설정에는 RabbitMQ 서버의 호스트 이름(hostname), 포트(port), 사용자 이름(username) 및 비밀번호(password)가 포함됩니다. 5. 메시지 Publishing 및 Consuming .NET Core 애플리케이션에서 RabbitMQ를 설정하고 나면 메시지 게시(Publishing) 및 소비(Consuming)를 시작할 수 있습니다. 메시지를 게시하려면 RabbitMQ에 대한 연결을 만든 다음 채널을 만들어야 합니다. 그런 다음 채널을 사용하여 메시지를 대기열에 게시할 수 있습니다. 메시지를 소비하려면 대기열을 수신하고 메시지를 처리하는 소비자(Consumers)를 생성해야 합니다. BasicConsume 메서드 또는 EventingBasicConsumer 클래스와 같은 다양한 메시지 소비 전략을 사용할 수 있습니다. 6. .NET Core와 함께 RabbitMQ를 사용하는 모범 사례 .NET Core와 함께 RabbitMQ를 사용할 때 최고의 성능과 안정성을 보장하려면 몇 가지 모범 사례를 따라야 합니다. 여기에는 연결 풀링 설정, 메시지 승인 사용, 메시지 재시도 구성이 포함됩니다. 또한 오류나 문제가 있는지 RabbitMQ 서버를 모니터링하고 적절한 로깅 및 오류 처리를 구성해야 합니다. 결론 RabbitMQ는 최신 분산 시스템을 위한 강력하고 안정적인 메시징 솔루션입니다. 이 글에서는 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보았습니다. 다음은 .NET Core에서 RabbitMQ를 사용하기 위한 몇 가지 코드 예제입니다. RabbitMQ 클라이언트 라이브러리 설치 1dotnet add package RabbitMQ.Client RabbitMQ에 연결 12345678910using RabbitMQ.Client;var factory = new ConnectionFactory() &#123; HostName = \"localhost\" &#125;;using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; // Do something with the channel &#125;&#125; 대기열 선언 1234using RabbitMQ.Client;var queueName = \"my-queue\";channel.QueueDeclare(queueName, false, false, false, null); 메시지 게시 12345678using RabbitMQ.Client;using System.Text;var queueName = \"my-queue\";var message = \"Hello, World!\";var body = Encoding.UTF8.GetBytes(message);channel.BasicPublish(\"\", queueName, null, body); 메시지 소비 1234567891011121314151617using RabbitMQ.Client;using RabbitMQ.Client.Events;using System.Text;var queueName = \"my-queue\";var consumer = new EventingBasicConsumer(channel);consumer.Received += (model, ea) =&gt;&#123; var body = ea.Body.ToArray(); var message = Encoding.UTF8.GetString(body); // Do something with the message channel.BasicAck(ea.DeliveryTag, false);&#125;;channel.BasicConsume(queueName, false, consumer); 참고: 이러한 코드 예제는 시작점일 뿐이며 특정 사용 사례에 맞게 조정해야 할 수도 있습니다. .NET Core에서 RabbitMQ를 사용하는 방법에 대한 자세한 내용은 공식 RabbitMQ 설명서를 참조하는 것이 좋습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://hgko1207.github.io/tags/RabbitMQ/"},{"name":"메시지","slug":"메시지","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%8B%9C%EC%A7%80/"}]},{"title":"OAuth와 JWT 차이점 및 사용 사례","slug":"backend-1","date":"2023-09-10T12:33:10.000Z","updated":"2024-01-12T08:26:04.177Z","comments":true,"path":"2023/09/10/backend-1/","link":"","permalink":"http://hgko1207.github.io/2023/09/10/backend-1/","excerpt":"","text":"OAuth와 JWT는 웹 애플리케이션에서 일반적으로 사용되는 두 가지 보안 메커니즘입니다. 둘 다 인증 기능을 제공하지만 접근 방식과 사용 사례가 다릅니다. 이 글에서는 OAuth와 JWT의 차이점과 각각을 언제 사용하는지 살펴보겠습니다. Section 1: OAuth OAuth는 자격 증명을 노출하지 않고 타사 애플리케이션이 사용자의 리소스에 액세스 할 수 있도록 하는 개방형 인증 표준입니다. OAuth 흐름에는 리소스 소유자(사용자), 클라이언트(애플리케이션) 및 권한 부여 서버 이 세 가지가 관련됩니다. 클라이언트는 Authorization Server를 통해 리소스 소유자에게 Authorization(권한부여)을 요청하고, 승인이 나면 클라이언트는 리소스에 접근하기 위한 Access Token을 받습니다. OAuth는 일반적으로 사용자가 Facebook 또는 Google 자격 증명을 사용하여 애플리케이션에 로그인할 수 있는 소셜 미디어 로그인에 사용됩니다. Section 2: JWT JWT(JSON Web Token)는 두 당사자 간에 전송될 클레임(claim)을 표현하는 URL 안전의 컴팩트한 수단입니다. 헤더(header), 페이로드(payload), 서명(signature)의 세 부분으로 구성됩니다. 헤더는 토큰 유형과 서명 알고리즘을 지정하고, 페이로드에는 클레임이 포함되며, 서명은 토큰의 무결성을 확인하는 데 사용됩니다. JWT는 일반적으로 사용자가 애플리케이션에 로그인하고 JWT를 응답으로 받는 인증에 사용됩니다. 그런 다음 JWT를 사용하여 애플리케이션 내의 보호된 리소스에 액세스 할 수 있습니다. Section 3: OAuth와 JWT의 차이점 OAuth와 JWT는 서로 다른 목적으로 사용되며 사용 사례도 다릅니다. OAuth는 권한부여(authorization)에 사용되고 JWT는 인증(authentication)에 사용됩니다. OAuth는 타사 애플리케이션에 리소스에 대한 액세스 권한을 부여하는 데 사용되는 반면, JWT는 애플리케이션 내의 보호된 리소스에 액세스 하는 데 사용됩니다. OAuth에는 인증 서버가 필요하지만 JWT에는 그렇지 않습니다. OAuth 흐름에는 여러 단계와 당사자가 포함되는 반면, JWT 흐름은 더 간단하고 두 당사자만 포함합니다. Section 4: OAuth를 사용해야 하는 경우 OAuth는 자격 증명을 노출하지 않고 사용자 리소스에 대한 액세스 권한을 타사 애플리케이션에 부여해야 할 때 유용합니다. 예를 들어 소셜 미디어 앱을 구축하는 경우 사용자가 Facebook 또는 Google 계정으로 로그인하도록 허용할 수 있습니다. 이 경우 OAuth를 사용하면 자격 증명을 입력하지 않고도 사용자를 인증할 수 있습니다. Section 5: JWT를 사용해야 하는 경우 JWT는 사용자를 인증하고 애플리케이션 내의 보호된 리소스에 대한 액세스 권한을 부여해야 할 때 유용합니다. 예를 들어 사용자가 로그인해야 하는 웹 애플리케이션을 구축하는 경우 JWT를 사용하여 사용자를 인증하고 애플리케이션의 특정 부분에 대한 액세스를 보호할 수 있습니다. JWT를 사용하여 당사자 간에 데이터를 안전하게 전송할 수도 있습니다. 결론 OAuth와 JWT는 모두 웹 애플리케이션 보안을 위한 강력한 도구입니다. 유사해 보일 수도 있지만 용도가 다르며 사용 사례도 다릅니다. OAuth와 JWT의 차이점을 이해하면 특정 사용 사례에 적합한 도구를 선택하고 애플리케이션의 보안을 보장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"}],"tags":[{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"},{"name":"OAuth","slug":"OAuth","permalink":"http://hgko1207.github.io/tags/OAuth/"},{"name":"JWT","slug":"JWT","permalink":"http://hgko1207.github.io/tags/JWT/"},{"name":"인증","slug":"인증","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"보안","slug":"보안","permalink":"http://hgko1207.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"}]},{"title":".NET Core에서 Swagger를 사용하는 방법","slug":"csharp-4","date":"2023-09-07T02:41:41.000Z","updated":"2024-01-12T08:25:34.860Z","comments":true,"path":"2023/09/07/csharp-4/","link":"","permalink":"http://hgko1207.github.io/2023/09/07/csharp-4/","excerpt":"","text":"Swagger는 RESTful API를 문서화하고 테스트하는 데 널리 사용되는 오픈 소스 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다. 이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보겠습니다. Endpoint는 API가 RESTful API를 인터페이스를 통해 서버의 리소스에 액세스 할 수 있도록 해주는 URL입니다. 전제 조건 🛠️ 컴퓨터에 .NET Core 3.1 이상이 설치되어 있어야 함 RESTful API 아키텍처에 대한 기본 이해 Visual Studio Code 또는 Visual Studio 2019 이상 시작하기 🚀 1단계: .NET Core 웹 API 프로젝트 만들기 첫 번째 단계는 새 .NET Core Web API 프로젝트를 만드는 것입니다. Visual Studio 또는 Visual Studio Code를 열고 새 .NET Core Web API 프로젝트를 만듭니다. 2단계: Swashbuckle.AspNetCore NuGet 패키지 설치 Swagger는 .NET Core용 NuGet 패키지로 제공됩니다. 설치하려면 IDE에서 NuGet 패키지 관리자를 열고 Swashbuckle.AspNetCore를 검색하세요. 최신 버전의 패키지를 설치하십시오. 3단계: 애플리케이션 파이프라인에 Swagger 미들웨어 추가 Startup.cs 파일의 구성 메서드에 다음 코드를 추가하여 Swagger 미들웨어를 애플리케이션 파이프라인에 추가합니다. 12345app.UseSwagger();app.UseSwaggerUI(c =&gt;&#123; c.SwaggerEndpoint( \"/swagger/v1/swagger.json\" , \"My API V1\" );&#125;); 그러면 미들웨어 파이프라인에 Swagger가 추가되고 개발자가 API를 테스트할 수 있는 UI가 생성됩니다. 4단계: Swagger 구성 SwaggerGenOptions 클래스를 사용하여 Swagger를 구성할 수 있습니다. 이 클래스는 Swagger에서 생성된 문서를 커스터마이징 하는 메서드를 제공합니다. Swagger를 구성하려면 Startup.cs 파일의 ConfigureServices 메서드에 다음 코드를 추가하세요. 1234services.AddSwaggerGen(c =&gt;&#123; c.SwaggerDoc( \"v1\" , new OpenApiInfo &#123; Title = \"My API\" , Version = \"v1\" &#125;);&#125;); 그러면 SwaggerGen 미들웨어가 애플리케이션 파이프라인에 추가되고 Swagger UI가 구성됩니다. 5단계: API Endpoint 문서 생성 Swagger는 XML 문서 주석을 사용하여 API Endpoint에 대한 문서를 생성합니다. API Endpoint에 XML 주석을 추가하여 문서화하세요. 다음은 GET 엔드포인트에 XML 문서 주석을 추가하는 방법의 예입니다. 123456789/// &lt;summary&gt;/// Gets all items./// &lt;/summary&gt;/// &lt;returns&gt;All items.&lt;/returns&gt;[HttpGet]public IEnumerable&lt;Item&gt; GetAll ()&#123; return repository.GetAll();&#125; 6단계: Swagger UI를 사용하여 API Endpoint 테스트 애플리케이션을 실행하고 Swagger UI Endpoint로 이동합니다. 그러면 개발자가 API Endpoint를 테스트할 수 있는 사용자 친화적인 인터페이스를 제공하는 Swagger UI가 열립니다. 결론 Swagger는 RESTful API를 문서화하고 테스트하기 위한 강력한 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다. 이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보았습니다. Swagger를 사용하면 API가 잘 문서화되고 테스트되어 개발자가 더 쉽게 API를 사용할 수 있도록 보장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"}]},{"title":"웹 개발자를 위한 AWS 소개 🚀","slug":"aws-1","date":"2023-09-06T14:28:39.000Z","updated":"2024-01-12T08:25:13.024Z","comments":true,"path":"2023/09/06/aws-1/","link":"","permalink":"http://hgko1207.github.io/2023/09/06/aws-1/","excerpt":"","text":"Amazon Web Services(AWS)는 웹 애플리케이션 구축, 배포 및 관리를 위한 다양한 서비스를 제공하는 클라우드 기반 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 네트워킹 기능을 포함한 다양한 서비스를 제공합니다. 이 글에서는 AWS의 기본 사항과 AWS가 웹 개발자에게 어떤 이점을 줄 수 있는지 살펴보겠습니다. AWS 서비스 📦 AWS는 웹 애플리케이션을 구축하는 데 사용할 수 있는 다양한 서비스를 제공합니다. 가장 인기 있는 서비스 중 일부는 다음과 같습니다. EC2(Elastic Compute Cloud): 클라우드에서 크기 조정 가능한 컴퓨팅 용량을 제공하는 서비스입니다. S3(Simple Storage Service): 안전하고 내구성이 뛰어나며 확장성이 뛰어난 객체 스토리지를 제공하는 서비스입니다. RDS(관계형 데이터베이스 서비스): MySQL, PostgreSQL, Oracle 및 Microsoft SQL Server에 관리형 데이터베이스 서비스를 제공하는 서비스입니다. Lambda: 서버를 프로비저닝 하거나 관리하지 않고도 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다. API 게이트웨이: API를 쉽게 생성, 게시, 관리할 수 있게 해주는 서비스입니다. CloudFront: 웹 콘텐츠를 사용자에게 빠르게 전달하는 콘텐츠 전달 네트워크(CDN)입니다. AWS 배포 🚀 AWS는 웹 애플리케이션을 클라우드에 배포하기 위한 다양한 도구를 제공합니다. 가장 널리 사용되는 도구는 다음과 같습니다. Elastic Beanstalk: 웹 애플리케이션 배포 및 확장을 위한 완전관리형 서비스입니다. CodeDeploy: Amazon EC2 인스턴스 및 온프레미스에서 실행되는 인스턴스를 포함하여 모든 인스턴스에 대한 코드 배포를 자동화하는 서비스입니다. CloudFormation: Amazon Web Services 리소스를 모델링하고 설정하여 해당 리소스를 관리하는 데 드는 시간을 줄이고 AWS에서 실행되는 애플리케이션에 더 많은 시간을 집중할 수 있도록 도와주는 서비스입니다. OpsWorks: 애플리케이션 배포, 확장 및 관리 자동화를 위해 Chef 및 Puppet의 관리형 인스턴스를 제공하는 서비스입니다. AWS 보안 🔒 AWS는 웹 애플리케이션을 보호하는 데 도움이 되는 다양한 보안 서비스와 기능을 제공합니다. 가장 중요한 보안 기능 중 일부는 다음과 같습니다. IAM(Identity and Access Management): AWS 리소스에 대한 액세스를 안전하게 제어하는 ​​데 도움이 되는 서비스입니다. WAF(웹 애플리케이션 방화벽): 일반적인 웹 공격으로부터 웹 애플리케이션을 보호하는 데 도움이 되는 웹 애플리케이션 방화벽입니다. 키 관리 서비스(KMS): 데이터를 암호화하는 데 사용되는 암호화 키를 쉽게 생성하고 제어할 수 있게 해주는 서비스입니다. 결론🔑 AWS는 웹 애플리케이션을 구축, 배포 및 관리하기 위한 강력한 플랫폼을 제공합니다. 다양한 서비스와 기능을 통해 애플리케이션을 빠르고 쉽게 구축하고 확장할 수 있습니다. 이 글에서는 AWS 서비스, 배포 도구 및 보안 기능에 대한 개요를 제공했습니다. 이러한 지식을 바탕으로 AWS를 시작하고 강력한 클라우드 기반 플랫폼을 활용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"},{"name":"Amazon Web Services","slug":"Amazon-Web-Services","permalink":"http://hgko1207.github.io/tags/Amazon-Web-Services/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"}]},{"title":"효율적인 버전 제어를 위한 Git 명령","slug":"git-2","date":"2023-09-05T08:21:34.000Z","updated":"2024-01-12T08:24:43.511Z","comments":true,"path":"2023/09/05/git-2/","link":"","permalink":"http://hgko1207.github.io/2023/09/05/git-2/","excerpt":"","text":"Git은 코드베이스를 효율적으로 관리할 수 있는 강력한 버전 제어 시스템입니다. 이는 협업, 디버깅 및 깔끔한 코드베이스 유지에 필수적입니다. 이 글에서는 효율적인 버전 관리를 위해 알아야 할 몇 가지 필수 Git 명령을 다룰 것입니다. 🚀 1. Git 시작하기 Git은 일반적으로 대부분의 시스템에 사전 설치되어 있지만, 그렇지 않은 경우 공식 웹사이트에서 다운로드할 수 있습니다. 설치가 완료되면 다음 명령을 사용하여 사용자 이름과 이메일을 구성해야 합니다. 12git config --global user.name \"Your Name\"git config --global user.email \"youremail@domain.com\" Git이 올바르게 설치 및 구성되었는지 확인하려면 다음 명령을 실행하십시오. 1git --version 그러면 시스템에 설치된 Git의 현재 버전이 반환됩니다. 🚀 2. Git 저장소 만들기 새 Git 리포지토리를 생성하려면 코드가 포함된 디렉터리로 이동하여 다음 명령을 실행하세요. 1git init 그러면 현재 디렉터리에 새 Git 저장소가 생성됩니다. 이제 코드 변경 사항 추적을 시작할 수 있습니다. 🚀 3. 코드 변경 Git 리포지토리를 생성한 후에는 코드 변경을 시작할 수 있습니다. 준비 영역에 변경 사항을 추가하려면 다음 명령을 실행하십시오. 1git add &lt;filename&gt; 그러면 지정된 파일이 준비 영역에 추가됩니다. 다음 명령을 사용하여 모든 변경 사항을 추가할 수도 있습니다. 1git add . 변경 사항을 저장소에 커밋하려면 다음 명령어를 실행하세요. 1git commit -m \"Commit message\" 그러면 지정된 커밋 메시지를 사용하여 저장소에 대한 변경 사항이 커밋됩니다. 🚀 4. 분기 및 병합 분기(Branch) 및 병합(Merge)은 코드베이스의 다양한 기능을 동시에 작업할 수 있게 해주는 Git의 필수 기능입니다. 새 분기를 만들려면 다음 명령을 실행합니다. 1git branch &lt;branch명&gt; 그러면 지정된 이름을 가진 새 분기가 생성됩니다. 새 분기로 전환하려면 다음 명령을 실행합니다. 1git checkout &lt;branch명&gt; 한 분기의 변경 사항을 다른 분기에 병합하려면 다음 명령을 실행하세요. 1git merge &lt;branch명&gt; 그러면 지정된 분기의 변경 사항이 현재 분기에 병합됩니다. 🚀 5. 원격으로 작업하기 원격 저장소는 협업에 필수적이며 코드베이스를 다른 사람과 공유할 수 있게 해 줍니다. 원격 저장소를 추가하려면 다음 명령을 실행하세요. 1git remote add origin &lt;원격 저장소 URL&gt; 그러면 지정된 이름과 URL을 가진 새 원격 저장소가 추가됩니다. 변경 사항을 원격 저장소에 푸시하려면 다음 명령어를 실행하세요. 1git push origin &lt;branch명&gt; 그러면 지정된 분기의 변경 사항이 지정된 원격 저장소로 푸시됩니다. 🚀 6. 고급 Git 명령 Git에는 코드베이스를 효율적으로 관리할 수 있는 다양한 고급 명령이 있습니다. 가장 유용한 명령 중 일부는 다음과 같습니다. git log: 저장소의 모든 커밋 목록을 표시합니다. git reset: 스테이징 영역에서 변경 사항을 제거합니다. git stash: 커밋할 준비가 되지 않은 변경 사항을 임시로 저장합니다. 결론 Git은 코드베이스를 효율적으로 관리하는 데 도움이 되는 강력한 버전 제어 시스템입니다. 이러한 필수 Git 명령을 익히면 효과적으로 협업하고 효율적으로 디버그 하며 깔끔한 코드베이스를 유지할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"Git 명령","slug":"Git-명령","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9/"},{"name":"버전 제어","slug":"버전-제어","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EC%A0%9C%EC%96%B4/"}]},{"title":"소프트웨어 개발에서 테스트의 중요성","slug":"info-3","date":"2023-09-04T01:49:32.000Z","updated":"2023-11-02T00:58:13.185Z","comments":true,"path":"2023/09/04/info-3/","link":"","permalink":"http://hgko1207.github.io/2023/09/04/info-3/","excerpt":"","text":"테스트는 소프트웨어 개발의 필수적인 부분으로, 개발자가 오류를 파악하고 코드 품질을 보장할 수 있도록 해줍니다. 이 글에서는 테스트의 중요성을 살펴보고 다양한 테스트 유형의 예를 제공합니다. ¶테스트가 중요한 이유 테스트를 통해 코드가 의도한 대로 작동하고 이해관계자가 설정한 요구 사항을 충족하는지 확인합니다. 테스트하지 않으면 오류와 버그가 쉽게 빠져나가 사용자에게 문제를 일으키고 소프트웨어의 평판을 손상시킬 수 있습니다. 또한 테스트를 통해 개발 초기에 문제를 파악하고 장기적으로 시간과 리소스를 절약할 수 있습니다. ¶테스트 유형 ¶단위 테스트 단위 테스트는 메서드나 함수와 같은 단일 코드 단위의 기능을 확인하는 자동화된 테스트입니다. 이는 일반적으로 개발자가 작성하며 개발 프로세스 초기에 오류를 포착할 수 있습니다. ¶통합 테스트 통합 테스트는 서로 다른 코드 단위 또는 시스템 간의 상호 작용을 확인합니다. 이는 다양한 구성 요소의 통합으로 인해 발생할 수 있는 문제를 파악하는 데 유용합니다. ¶승인 테스트 end-to-end 테스트라고도 알려진 승인 테스트는 전체 시스템이 사용자 관점에서 예상대로 작동하는지 확인합니다. 일반적으로 테스터나 품질 보증 전문가가 작성합니다. ¶Test-Driven Development(TDD) TDD(테스트 중심 개발)는 코드를 작성하기 전에 테스트 작성을 강조하는 소프트웨어 개발 방식입니다. 이 접근 방식을 사용하면 모든 기능에 대한 테스트가 작성되고 개발 프로세스 초기에 오류를 포착할 수 있습니다. ¶지속적인 통합 및 제공 CI(지속적 통합) 및 CD(지속적 전달)는 코드 변경 사항이 의도한 대로 작동하는지 확인하기 위해 정기적으로 코드 변경 사항을 구축하고 테스트하는 방식입니다. CI/CD 파이프라인은 코드 변경 사항을 빌드, 테스트 및 배포하는 프로세스를 자동화하여 더 빠르고 빈번한 릴리스를 가능하게 합니다. ¶결론 테스트는 소프트웨어 개발의 중요한 부분이므로 처음부터 개발 프로세스에 통합되어야 합니다. 자동화된 테스트를 작성하고 이를 CI/CD 파이프라인에 통합함으로써 개발자는 오류를 조기에 포착하고 코드 변경 사항이 사용자에게 빠르고 안전하게 전달되도록 할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"소프트웨어","slug":"소프트웨어","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"},{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"}]},{"title":"[HTTP] POST와 GET 차이점 및 사용 시기","slug":"info-2","date":"2023-09-03T13:37:45.000Z","updated":"2023-12-18T14:38:05.855Z","comments":true,"path":"2023/09/03/info-2/","link":"","permalink":"http://hgko1207.github.io/2023/09/03/info-2/","excerpt":"","text":"HTTP(Hypertext Transfer Protocol)는 인터넷을 통해 데이터를 전송하는 데 사용되는 프로토콜입니다. 다양한 HTTP 방법이 있지만 가장 일반적으로 사용되는 두 가지 방법은 HTTP POST와 HTTP GET입니다. 이러한 방법에는 서로 다른 목적이 있으므로 효과적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 필수적입니다. 이 글에서는 HTTP POST와 HTTP GET의 차이점을 살펴보고 각 방법을 사용하는 경우의 예를 제공합니다. 또한 웹 애플리케이션에서 이러한 방법을 사용하는 몇 가지 모범 사례에 대해서도 알아보겠습니다. HTTP POST와 GET이란 무엇입니까? HTTP POST 및 HTTP GET은 웹 서버에 데이터를 보내는 데 사용되는 두 가지 방법입니다. 두 방법의 주요 차이점은 데이터가 전송되는 방식입니다. HTTP GET은 URL의 일부로 데이터를 보내는 반면, HTTP POST는 HTTP 요청 본문의 일부로 데이터를 보냅니다. 다음은 HTTP GET 요청의 예입니다. 1https://example.com?param1=value1&amp;param2=value2 다음은 HTTP POST 요청의 예입니다. 123456POST /submit-form HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 33param1=value1&amp;param2=value2&amp;param3=value3 HTTP GET 요청에서 데이터는 URL의 일부로 전송됩니다. HTTP POST 요청에서 데이터는 요청 본문에 key-value 쌍 집합으로 전송됩니다. HTTP GET을 사용하는 경우 HTTP GET은 일반적으로 서버가 데이터 검색만 예상하고 서버에 데이터를 보낼 필요가 없을 때 사용됩니다. 요청된 데이터가 민감하지 않거나 비공개인 경우에도 유용합니다. 다음은 HTTP GET을 사용하는 경우에 대한 몇 가지 예입니다. 서버에서 데이터 검색 데이터 필터링 데이터 페이지 매기기 데이터 검색 중 정적 리소스 가져오기(예: 이미지, CSS) HTTP POST를 사용하는 경우 HTTP POST는 일반적으로 서버가 데이터를 생성, 업데이트 또는 삭제해야 할 때 사용됩니다. URL에 표시되어서는 안 되는 대량의 데이터나 민감한 정보를 보낼 때도 유용합니다. 다음은 HTTP POST를 사용하는 경우에 대한 몇 가지 예입니다. 서버에 새 리소스 생성 서버의 기존 리소스 업데이트 서버에서 리소스 삭제 많은 양의 데이터가 포함된 양식 제출 파일 업로드 모범 사례 HTTP GET 또는 HTTP POST를 사용할 때 웹 애플리케이션이 안전하고 효율적인지 확인하기 위해 몇 가지 모범 사례를 따르는 것이 중요합니다. 따라야 할 몇 가지 모범 사례는 다음과 같습니다. 안전한 멱등성 작업을 위해 HTTP GET을 사용하세요. 서버의 데이터를 수정하는 안전하지 않은 작업에는 HTTP POST를 사용합니다. HTTPS를 사용하여 인터넷을 통해 전송되는 데이터를 암호화합니다. 단일 요청으로 전송되는 데이터의 양을 제한합니다. 주입 공격을 방지하기 위해 모든 사용자 입력을 검증합니다. SQL 삽입 공격을 방지하려면 매개변수화된 쿼리를 사용하세요. 멱등법칙 또는 멱등성은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. 위키백과 결론 HTTP POST 및 HTTP GET은 웹 애플리케이션에서 사용되는 두 가지 중요한 HTTP 방법입니다. 안전하고 효율적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 중요합니다. 모범 사례를 따르고 이러한 방법을 적절하게 사용하면 안정적이고 확장 가능하며 안전한 웹 애플리케이션을 만들 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://hgko1207.github.io/tags/HTTP/"},{"name":"POST","slug":"POST","permalink":"http://hgko1207.github.io/tags/POST/"},{"name":"GET","slug":"GET","permalink":"http://hgko1207.github.io/tags/GET/"},{"name":"Https","slug":"Https","permalink":"http://hgko1207.github.io/tags/Https/"}]},{"title":"Angular 패키지 생성 및 NPM에 게시","slug":"angular-20","date":"2023-09-02T05:13:46.000Z","updated":"2023-11-02T00:56:58.364Z","comments":true,"path":"2023/09/02/angular-20/","link":"","permalink":"http://hgko1207.github.io/2023/09/02/angular-20/","excerpt":"","text":"Angular 패키지를 만드는 것은 여러 프로젝트에서 코드를 재사용하는 효율적인 방법이므로 시간과 노력을 절약할 수 있습니다. 이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명합니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 진행하겠습니다. ¶1단계: 프로젝트 설정 첫 번째 단계는 프로젝트를 설정하는 것입니다. Angular CLI를 사용하여 새 프로젝트를 생성하겠습니다. 터미널을 열고 다음 명령을 실행하십시오. 1ng new my-package --create-application=false 그러면 애플리케이션 없이 새로운 Angular 프로젝트가 생성됩니다. 이제 다음 명령을 사용하여 프로젝트 폴더로 이동할 수 있습니다. 1cd my-package ¶2단계: 새 모듈 만들기 다음 단계는 패키지에 대한 새 모듈을 만드는 것입니다. 다음 명령을 실행하여 새 모듈을 만듭니다. 1ng g module my-module 그러면 프로젝트에 새 모듈이 생성됩니다. 이제 모듈에 코드를 추가할 수 있습니다. ¶3단계: 모듈에 코드 추가 이제 모듈에 코드를 추가할 수 있습니다. 다음 명령을 사용하여 새 컴포넌트를 만듭니다. 1ng g component my-component 그러면 모듈에 새 컴포넌트가 생성됩니다. 이제 컴포넌트에 코드를 추가할 수 있습니다. ¶4단계: 패키지 빌드(Build) 다음 단계는 패키지를 빌드하는 것입니다. 다음 명령을 실행하여 패키지를 빌드합니다. 1ng build my-package 그러면 프로젝트 디렉터리에 dist 라는 새 폴더가 생성됩니다. ¶5단계: 패키지 게시(Publish) 마지막 단계는 NPM에 패키지를 게시하는 것입니다. NPM 계정이 없다면 무료로 만들 수 있습니다. 다음 명령을 실행하여 NPM 계정에 로그인하세요. 1npm login NPM 사용자 이름, 비밀번호, 이메일 주소를 입력하세요. 로그인한 후 다음 명령을 실행하여 패키지를 게시합니다. 1npm publish dist/my-package-0.0.1.tgz 그러면 NPM 레지스트리에 패키지가 게시됩니다. ¶결론 이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명했습니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 거쳤습니다. NPM에 패키지를 게시한 후에는 여러 프로젝트에서 코드를 재사용하여 시간과 노력을 절약할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"Package","slug":"Package","permalink":"http://hgko1207.github.io/tags/Package/"},{"name":"Creating","slug":"Creating","permalink":"http://hgko1207.github.io/tags/Creating/"},{"name":"Publishing","slug":"Publishing","permalink":"http://hgko1207.github.io/tags/Publishing/"}]},{"title":"사용자 정의 스크립트로 Angular 워크플로우(Workflow) 자동화","slug":"angular-19","date":"2023-09-01T02:27:04.000Z","updated":"2023-12-18T14:37:59.763Z","comments":true,"path":"2023/09/01/angular-19/","link":"","permalink":"http://hgko1207.github.io/2023/09/01/angular-19/","excerpt":"","text":"Angular는 확장 가능한 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 이를 사용하는 것은 때로는 시간이 많이 걸리고 지루할 수 있습니다. 특히 반복적인 작업의 경우 더욱 그렇습니다. 다행히 약간의 자동화를 통해 작업 흐름을 간소화하고 일반적인 작업에 소요되는 시간을 절약할 수 있습니다. 이 글에서는 사용자 정의 스크립트(Custom Scripts)를 사용하여 Angular 워크플로를 자동화하는 방법을 살펴보겠습니다. 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 알아보겠습니다. 환경 설정 사용자 정의 스크립트를 시작하기 전에 환경을 설정해야 합니다. 먼저 시스템에 Node.js와 NPM이 설치되어 있는지 확인하세요. 공식 웹사이트에서 최신 버전의 Node.js를 다운로드할 수 있습니다. 다음으로 Angular 프로젝트를 생성해야 합니다. 아직 수행하지 않은 경우 터미널에서 다음 명령을 실행하여 새 프로젝트를 생성할 수 있습니다. 1ng new my-app 프로젝트를 설정한 후에는 사용자 정의 스크립트를 생성하여 작업 흐름을 자동화할 수 있습니다. 일반적인 사용 사례 다음은 Angular 프로젝트의 사용자 정의 스크립트에 대한 몇 가지 일반적인 사용 사례입니다. 1. 애플리케이션 구축 및 배포 애플리케이션을 구축하고 배포하는 것은 시간이 많이 걸리는 프로세스일 수 있으며, 특히 수동으로 수행하는 경우 더욱 그렇습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 시간을 절약할 수 있습니다. 다음은 애플리케이션을 빌드하고 원격 서버에 배포하는 예제 스크립트입니다. 1234#!/bin/bashng build --prodscp -r dist/my-app/* user@remote-server:/usr/share/nginx/html 이 스크립트는 production 모드에서 Angular 애플리케이션을 구축한 다음 **SCP(Secure Copy)**를 사용하여 원격 서버에 배포합니다. 시큐어 카피(Secure copy) 또는 SCP는 로컬 호스트와 원격 호스트 간 또는 두 개의 원격 호스트 간에 컴퓨터 파일을 안전하게 전송하는 수단이다. 시큐어 셸 프로토콜 기반이다. SCP라는 용어는 SCP 프로토콜 또는 SCP 프로그램 중 하나를 가리킬 수 있다. 위키백과 2. Linters and Code Formatters 실행 린터와 코드 포맷터는 코드 품질과 일관성을 유지하는 데 필수적인 도구입니다. 그러나 수동으로 실행하는 것은 번거로울 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 코드가 항상 올바른 형식으로 지정되고 린트되도록 할 수 있습니다. 다음은 프로젝트에서 Prettier 코드 포맷터와 ESLint 린터를 실행하는 예제 스크립트입니다. 1234#!/bin/bashnpm run formatnpm run lint 이 스크립트는 npm run format 및 npm run lint 명령을 실행합니다. 이 명령은 각각 Prettier로 코드 형식을 지정하고 ESLint로 lint합니다. 3.테스트 실행 테스트 실행은 개발 프로세스에서 중요한 부분이지만 수동으로 수행해야 하는 경우 시간이 많이 걸릴 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 단일 명령으로 테스트를 실행할 수 있습니다. 다음은 테스트를 실행하고 결과를 콘솔에 출력하는 예제 스크립트입니다. 123#!/bin/bashng test --watch=false --code-coverage=true 이 스크립트는 ng test 명령을 사용하여 테스트를 실행하고 결과를 콘솔에 출력합니다. 또한 프로젝트에 대한 코드 적용 범위 보고서도 생성됩니다. 결론 사용자 정의 스크립트를 사용하면 Angular 프로젝트의 일반적인 작업을 자동화하고 많은 시간과 번거로움을 줄일 수 있습니다. 이 문서에서는 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 제공했습니다. 항상 스크립트를 철저히 테스트하고 주의해서 사용하세요. 약간의 자동화를 통해 Angular 워크플로를 한 단계 더 발전시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Script","slug":"Script","permalink":"http://hgko1207.github.io/tags/Script/"},{"name":"Workflow","slug":"Workflow","permalink":"http://hgko1207.github.io/tags/Workflow/"},{"name":"사용자 정의 스트립트","slug":"사용자-정의-스트립트","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8/"},{"name":"워크플로우 자동화","slug":"워크플로우-자동화","permalink":"http://hgko1207.github.io/tags/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9E%90%EB%8F%99%ED%99%94/"}]},{"title":"[Angular] Http Client 사용 방법","slug":"angular-18","date":"2023-08-31T08:06:13.000Z","updated":"2024-01-12T08:21:53.089Z","comments":true,"path":"2023/08/31/angular-18/","link":"","permalink":"http://hgko1207.github.io/2023/08/31/angular-18/","excerpt":"","text":"Angular의 HttpClient 모듈은 HTTP 요청을 만들고 응답을 처리하는 간단한 방법을 제공합니다. @angular/common/http 패키지의 일부이며 XMLHttpRequest API 위에 구축되었습니다. 이 글에서는 HttpClient 모듈의 다양한 기능을 자세히 살펴보고 이를 사용하여 Angular에서 HTTP 요청을 만드는 방법을 알아봅니다. Getting started Angular 애플리케이션에서 HttpClient 모듈을 사용하려면 루트 모듈(일반적으로 app.module.ts)에서 HttpClientModule을 가져와야 합니다. 12345678import &#123; NgModule &#125; from '@angular/core';import &#123; HttpClientModule &#125; from '@angular/common/http';@NgModule(&#123; imports: [HttpClientModule], // ...&#125;)export class AppModule &#123;&#125; HttpClientModule을 가져오면 이제 HttpClient 서비스를 사용하여 HTTP 요청을 할 수 있습니다. HTTP 요청하기 HttpClient 서비스를 사용하여 HTTP 요청을 만들려면 get(), post(), put(), delete() 및 patch() 메서드 중 하나를 호출하면 됩니다. 이 메서드는 요청 완료 시 응답을 내보내는 Observable을 반환합니다. 다음은 HttpClient 서비스를 사용하여 GET 요청을 만드는 방법에 대한 예입니다. 123456789101112import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; return this.http.get&lt;any&gt;('https://api.example.com/data'); &#125;&#125; 위의 예에서는 HttpClient 서비스를 ApiService 라는 서비스에 주입합니다. 그런 다음 any 유형의 Observable 을 반환하는 getData() 라는 메서드를 정의합니다. HttpClient 서비스의 get() 메서드는 지정된 URL에 대한 GET 요청을 만드는 데 사용됩니다. 마찬가지로, 다른 HTTP 메서드를 사용하여 요청을 수행하고 적절한 데이터를 메서드의 두 번째 인수로 전달할 수 있습니다. HTTP 응답 처리 HttpClient 서비스는 도착 시 응답을 내보내는 Observable 을 반환합니다. 응답을 처리하기 위해 Observable 의 subscribe() 메서드를 사용할 수 있습니다. 다음은 getData() 메서드의 응답을 처리하는 방법에 대한 예입니다. 12345678this.apiService.getData().subscribe( (response) =&gt; &#123; // handle the response here &#125;, (error) =&gt; &#123; // handle the error here &#125;); 위의 예에서는 ApiService 서비스의 getData() 메서드를 호출하고 Observable 의 subscribe() 메서드를 사용하여 응답을 구독합니다. subscribe() 메서드의 첫 번째 콜백은 응답이 도착할 때 호출되고, 두 번째 콜백은 오류가 있을 때 호출됩니다. HTTP 헤더 HttpHeaders 클래스의 set() 메서드를 사용하여 요청에 대한 HTTP 헤더를 설정할 수도 있습니다. Authorization 헤더를 설정하는 방법의 예는 다음과 같습니다. 12345678910111213141516import &#123; HttpClient, HttpHeaders &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; const headers = new HttpHeaders(&#123; Authorization: 'Bearer my-token', &#125;); return this.http.get&lt;any&gt;('https://api.example.com/data', &#123; headers &#125;); &#125;&#125; 위의 예에서는 HttpHeaders 클래스의 새 인스턴스를 생성하고 Authorization 헤더를 Bearer my-token 으로 설정합니다. 그런 다음 헤더 개체를 HttpClient 서비스의 get() 메서드에 대한 두 번째 인수로 전달합니다. Query parameters HttpParams 클래스를 사용하여 HTTP 요청에 쿼리 매개변수를 전달할 수도 있습니다. 쿼리 매개변수를 전달하는 방법의 예는 다음과 같습니다. 12345678910111213141516import &#123; HttpClient, HttpParams &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(page: number, limit: number): Observable&lt;any&gt; &#123; let params = new HttpParams(); params = params.append('page', page.toString()); params = params.append('limit', limit.toString()); return this.http.get&lt;any&gt;('https://api.example.com/data', &#123; params &#125;); &#125;&#125; 위의 예에서는 HttpParams 클래스의 새 인스턴스를 만들고 append() 메서드를 사용하여 page 및 limit 매개변수를 여기에 추가합니다. 그런 다음 params 개체를 HttpClient 서비스의 get() 메서드에 대한 두 번째 인수로 전달합니다. 오류 처리 HTTP 요청을 할 때 오류를 적절하게 처리하는 것이 중요합니다. HttpClient 서비스는 rxjs 라이브러리의 catchError() 연산자를 사용하여 오류를 처리하는 방법을 제공합니다. 다음은 getData() 메서드에서 오류를 처리하는 방법에 대한 예입니다. 1234567891011121314151617181920212223242526272829import &#123; HttpClient, HttpErrorResponse &#125; from '@angular/common/http';import &#123; catchError &#125; from 'rxjs/operators';import &#123; throwError &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; return this.http.get&lt;any&gt;('https://api.example.com/data').pipe( catchError((error: HttpErrorResponse) =&gt; &#123; let errorMessage = ''; if (error.error instanceof ErrorEvent) &#123; // client-side error errorMessage = `Error: $&#123;error.error.message&#125;`; &#125; else &#123; // server-side error errorMessage = `Error Code: $&#123;error.status&#125;\\nMessage: $&#123;error.message&#125;`; &#125; console.error(errorMessage); return throwError(errorMessage); &#125;) ); &#125;&#125; 위의 예에서는 rxjs 라이브러리의 catchError() 연산자를 사용하여 오류를 처리합니다. 오류가 발생하면 catchError() 연산자는 오류를 발생시키고 Observable 체인을 중지합니다. 그런 다음 rxjs 라이브러리의 throwError() 함수를 사용하여 오류를 내보내고 Observable 체인을 계속합니다. 다음은 HttpClient 모듈의 많은 기능을 사용하는 예입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpHeaders, HttpErrorResponse &#125; from '@angular/common/http';import &#123; Observable, throwError &#125; from 'rxjs';import &#123; catchError &#125; from 'rxjs/operators';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; private baseUrl = 'https://example.com/api'; private headers = new HttpHeaders(&#123; 'Content-Type': 'application/json', &#125;); constructor(private http: HttpClient) &#123;&#125; private handleError(error: HttpErrorResponse) &#123; if (error.error instanceof ErrorEvent) &#123; console.error('An error occurred:', error.error.message); &#125; else &#123; console.error(`Backend returned code $&#123;error.status&#125;, ` + `body was: $&#123;error.error&#125;`); &#125; return throwError('Something bad happened; please try again later.'); &#125; private getAuthHeaders() &#123; return new HttpHeaders(&#123; 'Content-Type': 'application/json', Authorization: `Bearer $&#123;localStorage.getItem('access_token')&#125;`, &#125;); &#125; public get&lt;T&gt;(path: string): Observable&lt;T&gt; &#123; return this.http .get&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public post&lt;T&gt;(path: string, data: any): Observable&lt;T&gt; &#123; return this.http .post&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, data, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public put&lt;T&gt;(path: string, data: any): Observable&lt;T&gt; &#123; return this.http .put&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, data, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public delete&lt;T&gt;(path: string): Observable&lt;T&gt; &#123; return this.http .delete&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125;&#125; HTTP 요청 테스트 @angular/common/http/testing 모듈은 HttpClient 서비스로 생성된 HTTP 요청을 테스트하기 위한 유틸리티 세트를 제공합니다. 이 모듈에서 제공하는 주요 클래스는 HttpTestingController 입니다. 이 클래스를 사용하여 HTTP 요청 및 응답을 모의하고 테스트 중인 애플리케이션에서 올바른 요청이 이루어졌는지 확인할 수 있습니다. HttpTestingController 를 사용하려면 먼저 테스트 케이스에 삽입해야 합니다. 123456789101112131415import &#123; TestBed &#125; from '@angular/core/testing';import &#123; HttpClientTestingModule, HttpTestingController &#125; from '@angular/common/http/testing';describe('MyComponent', () =&gt; &#123; let httpTestingController: HttpTestingController; beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [HttpClientTestingModule], providers: [MyComponent], &#125;); httpTestingController = TestBed.inject(HttpTestingController); &#125;);&#125;); Mocking HTTP Requests HTTP 요청을 모의하려면 HttpTestingController 인스턴스에서 ExpectOne() 메서드를 호출하여 URL 또는 HttpRequest 객체를 전달할 수 있습니다. 이 메서드는 요청에 대한 응답을 제어하는 데 사용할 수 있는 TestRequest 객체를 반환합니다. 다음은 ExpectOne() 을 사용하여 HTTP GET 요청을 모의하는 방법에 대한 예입니다. 123456789101112it('should make an HTTP GET request', () =&gt; &#123; const expectedData = &#123; id: 1, name: 'John Doe' &#125;; const url = '/api/user/1'; myComponent.getUser(1).subscribe((data) =&gt; &#123; expect(data).toEqual(expectedData); &#125;); const req = httpTestingController.expectOne(url); expect(req.request.method).toEqual('GET'); req.flush(expectedData);&#125;); 이 예에서는 MyComponent 인스턴스에서 getUser() 메서드를 테스트하고 있습니다. 이 메서드는 /api/user/1 에 대한 HTTP GET 요청을 만들고 응답 데이터를 내보내는 Observable 을 반환합니다. 이 메서드를 테스트하기 위해 getUser() 를 호출하고 그것이 반환하는 Observable 을 구독합니다. 그런 다음 요청과 동일한 URL을 사용하여 httpTestingController.expectOne() 을 호출하고 반환된 TestRequest 객체를 사용하여 예상 데이터가 포함된 응답을 flush 합니다. HTTP 요청 확인 HttpTestingController 를 사용하여 HTTP 요청을 모의한 후 해당 메서드를 사용하여 예상되는 요청이 테스트 중인 애플리케이션에서 이루어졌는지 확인할 수 있습니다. 예를 들어, verify() 메서드를 사용하여 예기치 않은 요청이 발생하지 않았는지 확인할 수 있습니다. 12345678910it('should make an HTTP GET request', () =&gt; &#123; myComponent.getUser(1).subscribe((data) =&gt; &#123; expect(data).toEqual(expectedData); &#125;); const req = httpTestingController.expectOne('/api/user/1'); req.flush(expectedData); httpTestingController.verify();&#125;); 이 예에서는 httpTestingController.verify() 를 사용하여 테스트 중인 애플리케이션에서 다른 요청이 이루어지지 않았는지 확인합니다. 다른 요청이 이루어진 경우 이 메서드는 오류를 발생시킵니다. expectNone() 메서드를 사용하여 요청이 이루어지지 않았는지 확인할 수도 있습니다. 1234567it('should not make an HTTP GET request with incorrect ID', () =&gt; &#123; myComponent.getUser(2).subscribe((data) =&gt; &#123; expect(data).toBeUndefined(); &#125;); httpTestingController.expectNone('/api/user/2');&#125;); 이 예에서는 getUser() 메서드가 /api/user/2 에 HTTP 요청을 하지 않는지 테스트하고 있습니다. 요청과 동일한 URL로 httpTestingController.expectNone() 을 호출하고 요청이 없으므로 테스트가 통과됩니다. 결론 Angular의 HttpClient 모듈의 다양한 기능을 살펴보았습니다. HTTP 요청을 작성하고 응답을 처리하고, HTTP 헤더 및 쿼리 매개변수를 설정하고, 오류를 처리하는 방법을 배웠습니다. HttpClient 모듈은 Angular 애플리케이션에서 HTTP 요청을 만들기 위한 강력하고 사용하기 쉬운 API를 제공합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"}]},{"title":"[JavaScript] Array Methods","slug":"js-dev-9","date":"2023-08-30T04:43:21.000Z","updated":"2024-01-12T08:20:20.051Z","comments":true,"path":"2023/08/30/js-dev-9/","link":"","permalink":"http://hgko1207.github.io/2023/08/30/js-dev-9/","excerpt":"","text":"JavaScript는 배열 작업을 위한 많은 강력한 도구를 제공하는 다용도 언어입니다. 가장 일반적으로 사용되는 도구 중 하나는 배열을 조작하고 변환하기 위한 다양한 메서드를 제공하는 Array 개체입니다. 이 글에서는 JavaScript에서 가장 중요하고 유용한 배열 메서드 중 일부를 자세히 살펴보겠습니다. forEach() forEach() 메서드는 배열을 반복하고 각 요소에 대해 콜백 함수를 실행합니다. 예는 다음과 같습니다. 12345const numbers = [1, 2, 3, 4, 5];numbers.forEach((number) =&gt; &#123; console.log(number);&#125;); 그러면 다음이 출력됩니다. 1234512345 map() map() 메서드는 배열의 각 요소에 콜백 함수를 적용하여 새 배열을 만듭니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const doubledNumbers = numbers.map((number) =&gt; &#123; return number * 2;&#125;);console.log(doubledNumbers); 그러면 다음이 출력됩니다. 1[2, 4, 6, 8, 10] filter() filter() 메서드는 특정 테스트를 통과한 모든 요소가 포함된 새 배열을 만듭니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const evenNumbers = numbers.filter((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(evenNumbers); 그러면 다음이 출력됩니다. 1[2, 4] reduce() reduce() 메서드는 배열의 각 요소에 콜백 함수를 적용하여 배열을 단일 값으로 줄입니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const sum = numbers.reduce((accumulator, currentValue) =&gt; &#123; return accumulator + currentValue;&#125;, 0);console.log(sum); 그러면 다음이 출력됩니다. 115 find() find() 메서드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 값을 반환합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const firstEvenNumber = numbers.find((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(firstEvenNumber); 그러면 다음이 출력됩니다. 12 findIndex() findIndex() 메서드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const firstEvenNumberIndex = numbers.findIndex((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(firstEvenNumberIndex); 그러면 다음이 출력됩니다. 11 some() some() 메서드는 배열의 요소 중 하나 이상이 특정 조건을 만족하는지 확인합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const hasEvenNumbers = numbers.some((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(hasEvenNumbers); 그러면 다음이 출력됩니다. 1true every() every() 메서드는 배열의 모든 요소가 특정 기준을 충족하는지 확인합니다. 예는 다음과 같습니다. 1234567const numbers = [2, 4, 6, 8, 10];const allEven = numbers.every((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(allEven); sort() sort() 메서드는 배열의 요소를 정렬합니다. 예는 다음과 같습니다. 12345const fruits = ['apple', 'orange', 'banana'];const sortedFruits = fruits.sort();console.log(sortedFruits); 그러면 다음이 출력됩니다. 1[\"apple\", \"banana\", \"orange\"] includes() include() 메서드는 배열에 특정 값이 포함되어 있는지 확인합니다. 예는 다음과 같습니다. 12345const numbers = [1, 2, 3, 4, 5];const hasNumberThree = numbers.includes(3);console.log(hasNumberThree); 그러면 다음이 출력됩니다. 1true flat() flat() 메서드는 모든 하위 배열 요소가 지정된 깊이까지 반복적으로 연결되어 있는 새 배열을 만듭니다. 예는 다음과 같습니다. 12345const numbers = [1, [2, 3], [4, [5, 6]]];const flattenedNumbers = numbers.flat(2);console.log(flattenedNumbers); 그러면 다음이 출력됩니다. 1[1, 2, 3, 4, 5, 6] flatMap() flatMap() 메서드는 먼저 매핑 함수를 사용하여 각 요소를 매핑한 다음 결과를 새 배열로 평면화합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const doubledAndFlattenedNumbers = numbers.flatMap((number) =&gt; &#123; return [number * 2];&#125;);console.log(doubledAndFlattenedNumbers); 그러면 다음이 출력됩니다. 1[2, 4, 6, 8, 10] from() from() 메서드는 배열 유사 객체 또는 반복 가능 객체에서 새 배열을 만듭니다. 예는 다음과 같습니다. 12345const arrayLikeObject = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3 &#125;;const newArray = Array.from(arrayLikeObject);console.log(newArray); 그러면 다음이 출력됩니다. 1[\"a\", \"b\", \"c\"] Array Destructuring Array Destructuring를 사용하면 배열에서 값을 추출하여 변수에 할당할 수 있습니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3];const [a, b, c] = numbers;console.log(a);console.log(b);console.log(c); 그러면 다음이 출력됩니다. 123123 결론 이 글에서는 JavaScript 에서 가장 중요하고 유용한 Array 메소드 중 일부를 살펴보았습니다. 이러한 메서드는 배열 작업을 위한 강력한 도구를 제공하며 코드를 더욱 간결하고 표현력있게 만들 수 있습니다. 이러한 방법을 익히면 더욱 효율적이고 효과적인 JavaScript 개발자가 될 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"http://hgko1207.github.io/tags/Array/"},{"name":"Array Methods","slug":"Array-Methods","permalink":"http://hgko1207.github.io/tags/Array-Methods/"}]},{"title":"[Angular] Error Handling","slug":"angular-17","date":"2023-08-29T00:42:08.000Z","updated":"2024-01-12T08:18:42.281Z","comments":true,"path":"2023/08/29/angular-17/","link":"","permalink":"http://hgko1207.github.io/2023/08/29/angular-17/","excerpt":"","text":"Error Handling는 모든 애플리케이션의 필수적인 부분이며 Angular도 예외는 아닙니다. Angular 프레임워크는 다양한 시나리오에서 오류를 처리할 수 있는 강력한 도구 세트를 제공합니다. 이번 글에서는 Angular의 다양한 오류 유형과 이를 효과적으로 처리하는 방법을 살펴보겠습니다. Types of Errors in Angular Angular 애플리케이션에서 발생할 수 있는 오류에는 주로 두 가지 유형이 있습니다. 컴파일 시간 오류: 이러한 오류는 Angular 애플리케이션이 빌드되는 컴파일 단계에서 발생합니다. 컴파일 시간 오류는 일반적으로 코드의 구문 또는 논리적 오류를 나타내며 애플리케이션이 실행되지 못하게 합니다. 런타임 오류: 이러한 오류는 Angular 애플리케이션을 실행하는 동안 발생합니다. 런타임 오류는 네트워크 문제, 서버 오류, 코드의 논리적 오류 등 다양한 원인으로 인해 발생할 수 있습니다. Handling Compile-time Errors 컴파일 시간 오류는 일반적으로 쉽게 수정할 수 있으며 Angular CLI는 개발자가 문제를 신속하게 식별하는 데 도움이 되는 자세한 오류 메시지를 제공합니다. 오류 메시지에는 오류가 발생한 줄 번호와 파일 이름이 포함됩니다. 개발자는 오류 메시지를 사용하여 문제를 해결하고 애플리케이션을 다시 빌드할 수 있습니다. Handling Runtime Errors 런타임 오류는 컴파일 타임 오류보다 처리하기가 더 복잡합니다. 이러한 오류는 네트워크 문제나 서버 오류 등 다양한 이유로 인해 발생할 수 있습니다. 이러한 시나리오에서 애플리케이션은 오류를 적절하게 처리하고 사용자에게 유용한 피드백을 제공해야 합니다. Angular는 ErrorHandler 클래스와 같은 런타임 오류를 처리하기 위한 내장 오류 처리기 세트를 제공합니다. ErrorHandler 클래스는 오류 처리를 위한 기본 구현을 제공하는 추상 클래스입니다. 개발자는 ErrorHandler 클래스를 확장하고 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다. Custom Error Handling 개발자는 ErrorHandler 클래스를 사용하여 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다. ErrorHandler 클래스에는 응용 프로그램에서 오류가 발생할 때 호출되는 handlerError(error: any)라는 단일 메서드가 있습니다. 이 메서드는 오류 개체를 매개 변수로 사용하고 개발자에게 오류를 처리할 수 있는 기회를 제공합니다. 다음은 커스텀 오류 처리기 구현의 예입니다. 12345678import &#123; ErrorHandler &#125; from '@angular/core';export class CustomErrorHandler implements ErrorHandler &#123; handleError(error: any) &#123; // Implement custom error handling logic here console.error(error); &#125;&#125; 위의 예에서는 ErrorHandler 클래스를 implements 하고 handlerError() 메서드를 재정의하는 CustomErrorHandler 클래스를 만들었습니다. 이 예에서는 단순히 오류를 콘솔에 기록하지만 개발자는 사용자에게 친숙한 오류 메시지를 표시하는 등 사용자 지정 오류 처리 로직을 구현할 수 있습니다. Error Interceptors Angular는 인터셉터를 사용하여 HTTP 응답을 가로채고 전역적으로 오류를 처리하는 메커니즘을 제공합니다. 인터셉터를 사용하면 개발자는 HTTP 응답이 호출 컴포넌트에 반환되기 전에 이를 가로챌 수 있습니다. 개발자는 인터셉터를 사용하여 오류를 전체적으로 처리하고 일관된 사용자 경험을 제공할 수 있습니다. 다음은 HTTP 오류 인터셉터의 예입니다. 123456789101112131415161718192021222324import &#123; Injectable &#125; from '@angular/core';import &#123; HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse &#125; from '@angular/common/http';import &#123; catchError &#125; from 'rxjs/operators';import &#123; throwError &#125; from 'rxjs';@Injectable()export class HttpErrorInterceptor implements HttpInterceptor &#123; intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler) &#123; return next.handle(request).pipe( catchError((error: HttpErrorResponse) =&gt; &#123; let errorMessage = ''; if (error.error instanceof ErrorEvent) &#123; // client-side error errorMessage = `Error: $&#123;error.error.message&#125;`; &#125; else &#123; // server-side error errorMessage = `Error Code: $&#123;error.status&#125;\\nMessage: $&#123;error.message&#125;`; &#125; console.error(errorMessage); return throwError(errorMessage); &#125;) ); &#125;&#125; 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpClientModule, HTTP_INTERCEPTORS &#125; from '@angular/common/http';import &#123; AppComponent &#125; from './app.component';import &#123; HttpErrorInterceptor &#125; from './http-error.interceptor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, HttpClientModule], providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true &#125;], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Component(&#123; selector: 'app-root', template: ` &lt;button (click)=\"makeRequest()\"&gt;Make Request&lt;/button&gt; &lt;div *ngIf=\"error\"&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt; `,&#125;)export class AppComponent &#123; error: string; constructor(private http: HttpClient) &#123;&#125; makeRequest() &#123; this.http.get('https://someURL.con/posts/1').subscribe( (data) =&gt; console.log(data), (error) =&gt; (this.error = error) ); &#125;&#125; 위 코드에서는 HttpClient 서비스를 사용하여 API 에 GET 요청을 보냅니다. 요청이 성공하면 응답 데이터가 콘솔에 기록됩니다. 오류가 있는 경우 템플릿에 오류 메시지가 표시됩니다. HttpErrorInterceptor를 사용하면 요청 중에 발생하는 모든 오류가 인터셉터에 의해 차단되어 처리됩니다. 오류 메시지는 콘솔에 기록되고 관찰 가능한 오류로 발생하며 컴포넌트에서 이를 포착하고 처리할 수 있습니다. Angular 앱에서 오류 인터셉터를 사용하면 오류 처리 로직을 중앙 집중화하고 모든 HTTP 요청에서 오류를 처리하는 일관된 방법을 제공할 수 있습니다. 이를 통해 코드 유지 관리가 더 용이해지고 앱에 대한 사용자 경험이 더 좋아질 수 있습니다. 결론 오류 처리는 강력하고 안정적인 애플리케이션을 구축하는 데 필수적인 부분입니다. Angular에는 try/catch 블록 사용, 컴포넌트 수준에서 오류 처리, 오류 인터셉터 사용 등 오류를 처리하는 다양한 방법이 있습니다. 포괄적인 오류 처리 전략을 구현하면 애플리케이션이 사용자에게 원활하고 오류 없는 환경을 제공하도록 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"},{"name":"Handling","slug":"Handling","permalink":"http://hgko1207.github.io/tags/Handling/"},{"name":"오류처리","slug":"오류처리","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"}]},{"title":"Node.js 와 TypeScript 콜백(callback) 지옥 피하는 방법","slug":"nodejs-5","date":"2023-08-28T04:16:12.000Z","updated":"2024-01-12T08:17:58.628Z","comments":true,"path":"2023/08/28/nodejs-5/","link":"","permalink":"http://hgko1207.github.io/2023/08/28/nodejs-5/","excerpt":"","text":"Node.js는 Chrome의 V8 JavaScript 엔진을 기반으로 구축된 이벤트 중심의 non-blocking I/O 플랫폼입니다. 웹 서버를 포함하여 확장 가능한 네트워크 애플리케이션을 구축하는 데 널리 사용됩니다. 이러한 애플리케이션을 구축할 때 콜백 지옥(callback hell) 문제가 발생할 수 있습니다. 이는 여러 개의 중첩된 콜백이 있어 코드를 읽고 유지 관리하기 어렵게 만드는 문제를 의미합니다. 이 글에서는 Express 웹 프레임워크와 TypeScript를 사용하여 Node.js 애플리케이션을 구축할 때 콜백 지옥을 피하는 방법에 대해 설명합니다. Promises Promises 은 보다 읽기 쉽고 관리하기 쉬운 방식으로 비동기 작업을 처리하는 방법입니다. 이는 아직 사용할 수 없지만 미래에는 사용할 수 있는 값을 나타냅니다. Promise를 서로 연결하면 여러 비동기 작업을 순차적으로 처리할 수 있습니다. Node.js에서 Promise를 사용하는 예는 다음과 같습니다. 123456789101112131415function getData() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Data received!'); &#125;, 1000); &#125;);&#125;getData() .then((data) =&gt; &#123; console.log(data); &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); 이 예에서 getData 는 1초 후에 해결되는 약속을 반환합니다. 그런 다음 .then 메서드를 사용하여 확인된 값을 처리하고 .catch 메서드를 사용하여 오류를 처리할 수 있습니다. Async/Await Async/await 는 Promise 위에 추가되는 Syntatic Sugar(문법 설탕) 으로, 비동기 작업 작업을 더 쉽게 만듭니다. 이를 통해 동기적으로 보이는 비동기 코드를 작성할 수 있으므로 읽고 유지하기가 더 쉬워집니다. 컴퓨터 과학에서 Syntactic sugar(구문 설탕)은 더 쉽게 읽거나 표현하도록 설계된 프로그래밍 언어 내의 구문입니다. 그것은 인간이 사용하기에 언어를 &quot;더 달콤&quot;하게 만듭니다. 사물을 더 명확하고 간결하게 표현하거나 일부 사람들이 선호하는 대체 스타일로 표현할 수 있습니다. 위키백과 Node.js에서 async/await를 사용하는 예는 다음과 같습니다. 123456789101112131415161718function getData() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Data received!'); &#125;, 1000); &#125;);&#125;async function main() &#123; try &#123; const data = await getData(); console.log(data); &#125; catch (error) &#123; console.error(error); &#125;&#125;main(); 이 예에서 main 은 wait 키워드를 사용하여 getData 함수의 확인된 값을 기다리는 비동기 함수입니다. try/catch 블록을 사용하여 오류를 처리할 수 있습니다. Promisify Promisify는 callback-based 함수를 promise-based 함수로 변환할 수 있도록 Node.js에서 제공하는 유틸리티 함수입니다. 이는 Promise를 사용하지 않는 오래된 라이브러리나 모듈로 작업할 때 유용할 수 있습니다. Node.js에서 promisify를 사용하는 예는 다음과 같습니다. 123456789101112131415const fs = require('fs');const &#123; promisify &#125; = require('util');const readFile = promisify(fs.readFile);async function main() &#123; try &#123; const data = await readFile('file.txt', 'utf8'); console.log(data); &#125; catch (error) &#123; console.error(error); &#125;&#125;main(); 예에서는 util.promisify 를 사용하여 Node.js의 fs.readFile 함수를 promise-based 함수로 변환합니다. 그런 다음 Promise 기반 함수를 사용하여 file.txt 파일의 내용을 읽습니다. Use Control Flow Libraries 복잡한 비동기 코드로 작업하는 경우 Promise와 async/await 만으로는 코드를 깔끔하고 유지 관리하기 쉽도록 유지하는 데 충분하지 않다는 것을 알 수 있습니다. 이 경우 제어 흐름(flow library) 라이브러리를 사용하여 비동기 코드를 관리하는 데 도움을 받을 수 있습니다. 제어 흐름 라이브러리는 비동기 작업의 흐름을 관리하는 방법을 제공하여 해당 작업이 올바른 순서로 실행되고 오류가 적절하게 처리되도록 합니다. Node.js의 인기 있는 제어 흐름 라이브러리로는 Async, Bluebird 및 Q가 있습니다. 다음은 Async 라이브러리를 사용하여 일련의 비동기 작업을 관리하는 방법에 대한 예입니다. 1234567891011121314151617181920212223const async = require('async');const fs = require('fs');async.series( [ (callback) =&gt; &#123; fs.readFile('file1.txt', 'utf8', callback); &#125;, (callback) =&gt; &#123; fs.readFile('file2.txt', 'utf8', callback); &#125;, (callback) =&gt; &#123; fs.readFile('file3.txt', 'utf8', callback); &#125;, ], (error, results) =&gt; &#123; if (error) &#123; console.error(error); &#125; else &#123; console.log(results); &#125; &#125;); 이 예에서는 async.series 메서드를 사용하여 일련의 비동기 작업(이 경우 세 파일의 내용 읽기)을 순서대로 실행합니다. 모든 작업이 완료되면 최종 콜백이 호출되고 결과 배열을 받습니다. 결론 콜백 지옥은 Node.js에서 비동기 코드 작업을 어렵고 실망스럽게 만들 수 있지만, 이를 방지하기 위해 사용할 수 있는 많은 전략은 위과 같습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"callback","slug":"callback","permalink":"http://hgko1207.github.io/tags/callback/"},{"name":"Promise","slug":"Promise","permalink":"http://hgko1207.github.io/tags/Promise/"},{"name":"Async/Await","slug":"Async-Await","permalink":"http://hgko1207.github.io/tags/Async-Await/"},{"name":"콜백","slug":"콜백","permalink":"http://hgko1207.github.io/tags/%EC%BD%9C%EB%B0%B1/"}]},{"title":"C# and .NET Core 멀티스레딩(multithreading)","slug":"csharp-3","date":"2023-08-27T12:44:48.000Z","updated":"2024-01-12T08:17:04.156Z","comments":true,"path":"2023/08/27/csharp-3/","link":"","permalink":"http://hgko1207.github.io/2023/08/27/csharp-3/","excerpt":"","text":"멀티스레딩은 프로그램을 여러 스레드로 나누는 방식을 의미하며, 각 스레드는 독립적으로 동시에 실행될 수 있습니다. 이로 인해 특히 I/O 또는 네트워크 통신과 같은 작업의 경우 성능과 응답성이 향상될 수 있습니다. C# 및 .NET Core에서는 System.Threading 네임스페이스를 사용하여 스레드를 만들고 관리할 수 있습니다. 다음은 Thread 클래스를 사용하여 C#에서 새 스레드를 만드는 예입니다. 12345678910111213141516using System;using System.Threading;class Program &#123; static void Main(string[] args) &#123; Thread thread = new Thread(new ThreadStart(Worker)); thread.Start(); Console.WriteLine(\"Main thread is running.\"); Console.ReadLine(); &#125; static void Worker() &#123; Console.WriteLine(\"Worker thread is running.\"); &#125;&#125; 이 예제에서는 Thread 클래스를 사용하여 새 스레드를 만들고 Worker 메서드에 대리자를 전달합니다. 그런 다음 Start 메서드를 사용하여 스레드를 시작하고 Worker 메서드는 Main 메서드와 동시에 실행됩니다. 이 프로그램을 실행하면 다음과 같은 출력이 표시됩니다. 12Main thread is running.Worker thread is running. .NET Core는 다중 스레드 코드 작업을 위한 다양한 클래스와 구문도 제공합니다. 그중 하나는 병렬 작업을 실행하는 간단한 방법을 제공하는 TPL(작업 병렬 라이브러리)입니다. 다음은 TPL을 사용하여 병렬 루프를 실행하는 예입니다. 1234567891011using System;using System.Threading.Tasks;class Program &#123; static void Main(string[] args) &#123; Parallel.For(0, 10, i =&gt; &#123; Console.WriteLine(\"Processing item &#123;0&#125; on thread &#123;1&#125;\", i, Task.CurrentId); &#125;); Console.ReadLine(); &#125;&#125; 이 예제에서는 Parallel.For 메서드를 사용하여 루프를 병렬로 실행하며 각 반복은 별도의 스레드에서 실행됩니다. Task.CurrentId 속성을 사용하여 현재 반복을 실행하는 스레드의 ID를 표시합니다. 이 프로그램을 실행하면 다음과 유사한 출력이 표시됩니다. 12345678910Processing item 0 on thread 4Processing item 1 on thread 6Processing item 2 on thread 5Processing item 3 on thread 7Processing item 4 on thread 8Processing item 5 on thread 4Processing item 6 on thread 6Processing item 7 on thread 5Processing item 8 on thread 7Processing item 9 on thread 8 이는 C# 및 .NET Core가 다중 스레드 프로그래밍을 지원하는 다양한 방식 중 작은 예일뿐입니다. 이미지 처리 또는 비디오 트랜스코딩과 같이 CPU를 많이 사용하는 장기 실행 작업을 수행해야 하는 웹 API가 있는 시나리오를 생각해 보세요. 메인 스레드에서 이 작업을 수행하면 다른 수신 요청이 차단되고 API의 응답 속도가 느려집니다. 이 문제를 해결하려면 멀티스레딩을 사용하여 별도의 스레드에서 작업을 수행하고 기본 스레드가 들어오는 요청을 처리할 수 있도록 남겨둘 수 있습니다. 다음은 작업 병렬 라이브러리를 사용하여 .NET Core 웹 API에서 이를 달성할 수 있는 방법의 예입니다. 12345678910111213141516171819202122using System.Threading.Tasks;using Microsoft.AspNetCore.Mvc;[ApiController][Route(\"[controller]\")]public class ImageController : ControllerBase &#123; [HttpPost] public async Task&lt;IActionResult&gt; ProcessImage() &#123; // Parse incoming request and extract image data // ... // Start processing on a separate thread Task&lt;byte[]&gt; task = Task.Run(() =&gt; &#123; // Perform CPU-intensive image processing // ... return processedImageData; &#125;); // Return a response immediately, while the image is being processed return await task; &#125;&#125; 이 예에서는 이미지 데이터가 포함된 수신 HTTP POST 요청을 처리하는 웹 API 컨트롤러에 ProcessImage 작업 메서드를 정의합니다. 그런 다음 별도의 스레드에서 지정된 대리자를 실행하는 새 Task을 만드는 Task.Run 메서드를 사용하여 별도의 스레드에서 이미지 처리를 시작합니다. 처리가 완료될 때까지 기다리고 처리된 이미지 데이터를 반환하기 위해 wait 키워드를 사용하여 Task를 응답으로 즉시 반환합니다. 이 방식을 사용하면 웹 API의 기본 스레드가 들어오는 요청에 계속 응답하는 동시에 이미지 처리가 별도의 스레드에서 수행됩니다. 이는 API의 전반적인 성능과 확장성을 향상시키는 데 도움이 될 수 있습니다. 첫 번째 예에서는 System.Threading 네임스페이스를 사용하여 C# 및 .NET Core에서 스레드를 만들고 관리하는 방법을 살펴보았습니다. 우리는 새로운 스레드를 생성하고 해당 스레드에서 별도의 메서드를 실행하는 간단한 프로그램을 만들었습니다. 이를 통해 두 개의 별도 코드 조각을 동시에 실행할 수 있어 특정 시나리오에서 성능과 응답성을 향상시킬 수 있습니다. 두 번째 예에서는 .NET Core 웹 API에서 고급 멀티스레딩 기술을 사용하는 방법을 살펴보았습니다. 우리는 Task Parallel 라이브러리를 사용하여 별도의 스레드에서 long-running, CPU-intensive 작업을 시작하는 동시에 기본 스레드는 들어오는 요청을 처리할 수 있도록 자유롭게 유지했습니다. 이는 특히 long-running 작업으로 인해 들어오는 요청이 차단될 수 있는 시나리오에서 API의 전반적인 성능과 확장성을 개선하는 데 도움이 될 수 있습니다. 전반적으로 멀티스레딩은 C# 및 .NET Core 애플리케이션의 성능과 응답성을 향상시키는 강력한 도구가 될 수 있습니다. 그러나 이를 현명하게 사용하고 복잡성 증가, 잠재적 경합 조건 또는 동기화 문제, 리소스 사용량 증가와 같은 잠재적인 절충안을 이해하는 것이 중요합니다. 특정 시나리오에 적합한 스레딩 구성 및 기술을 사용하면 이러한 잠재적 위험을 피하면서 멀티스레딩의 이점을 활용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"multithreading","slug":"multithreading","permalink":"http://hgko1207.github.io/tags/multithreading/"},{"name":"Thread","slug":"Thread","permalink":"http://hgko1207.github.io/tags/Thread/"}]},{"title":"[Angular] 재사용 가능한 컴포넌트(Component)","slug":"angular-16","date":"2023-08-26T06:33:52.000Z","updated":"2024-01-12T08:15:56.431Z","comments":true,"path":"2023/08/26/angular-16/","link":"","permalink":"http://hgko1207.github.io/2023/08/26/angular-16/","excerpt":"","text":"웹 애플리케이션 구축에 Angular를 사용하는 주요 이점 중 하나는 재사용 가능한 컴포넌트를 생성할 수 있다는 것입니다. 이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보겠습니다. 1. Component Structure Angular에서 재사용 가능한 컴포넌트를 만들려면 다양한 상황에서 쉽게 사용할 수 있는 방식으로 컴포넌트를 구성하는 것이 중요합니다. 컴포넌트에는 입력 및 출력 속성이 잘 정의된 명확한 API가 있어야 하며 다양한 사용 사례를 처리할 수 있을 만큼 유연해야 합니다. 다음은 항목 목록을 표시하는 재사용 가능한 간단한 컴포넌트의 예입니다. 12345678910111213import &#123; Component, Input &#125; from '@angular/core';@Component(&#123; selector: 'app-item-list', template: ` &lt;ul&gt; &lt;li *ngFor=\"let item of items\"&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; `,&#125;)export class ItemListComponent &#123; @Input() items: string[];&#125; 이 예에서 ItemListComponent 에는 문자열 배열인 항목이라는 Single Input 속성이 있습니다. 컴포넌트는 *ngFor 지시문을 사용하여 items 배열을 반복하고 목록의 각 항목을 표시합니다. 2. Input and Output Properties 입력 및 출력 속성은 Angular에서 재사용 가능한 컴포넌트를 만드는 데 중요한 부분입니다. Input 속성을 사용하면 상위 컴포넌트에서 데이터를 컴포넌트로 전달할 수 있고, Output 속성을 사용하면 컴포넌트에서 상위 컴포넌트로 이벤트를 내보낼 수 있습니다. 다음은 사용자가 목록에서 값을 선택할 수 있도록 하는 재사용 가능한 컴포넌트의 예입니다. 123456789101112131415import &#123; Component, Input, Output, EventEmitter &#125; from '@angular/core';@Component(&#123; selector: 'app-select', template: ` &lt;select [ngModel]=\"selectedValue\" (ngModelChange)=\"selectValue.emit($event)\"&gt; &lt;option *ngFor=\"let option of options\" [value]=\"option\"&gt;&#123;&#123; option &#125;&#125;&lt;/option&gt; &lt;/select&gt; `,&#125;)export class SelectComponent &#123; @Input() options: string[]; @Input() selectedValue: string; @Output() selectValue = new EventEmitter&lt;string&gt;();&#125; 이 예에서 SelectComponent 에는 두 개의 입력 속성인 options 와 selectedValue 와 하나의 출력 속성인 selectValue 가 있습니다. 컴포넌트는 ngModel 지시문을 사용하여 선택한 값을 selectedValue 속성에 바인딩하고 사용자가 목록에서 새 값을 선택할 때 selectValue 이벤트를 발생시킵니다. 3. Content Projection 콘텐츠 프로젝션은 Angular에서 재사용 가능한 컴포넌트를 구축하는 또 다른 주요 기능입니다. 콘텐츠 프로젝션을 통해 컴포넌트는 상위 항목의 임의 콘텐츠를 허용할 수 있으며, 이는 컴포넌트의 모양이나 동작을 사용자 지정하는 데 사용할 수 있습니다. 콘텐츠 프로젝션의 예는 다음과 같습니다. 1234567891011121314151617181920212223242526import &#123; Component, Input &#125; from '@angular/core';@Component(&#123; selector: 'app-section', template: ` &lt;div class=\"section\"&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/div&gt; `, styles: [ ` .section &#123; border: 1px solid black; padding: 10px; margin-bottom: 20px; &#125; h2 &#123; margin-bottom: 10px; &#125; `, ],&#125;)export class SectionComponent &#123; @Input() title: string;&#125; 123456789101112131415161718import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-parent', template: ` &lt;app-section title=\"Section 1\"&gt; &lt;p&gt;Content for section 1 goes here.&lt;/p&gt; &lt;/app-section&gt; &lt;app-section title=\"Section 2\"&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; &lt;/app-section&gt; `,&#125;)export class ParentComponent &#123;&#125; title 이 상위 컴포넌트에서 전달될 수 있도록 title 속성에 @Input 데코레이터를 추가했습니다. SectionComponent 템플릿은 보간을 사용하여 제목을 표시하고 ng-content 지시문은 상위 컴포넌트의 임의 콘텐츠를 투영하는 데 사용됩니다. 각 SectionComponent 인스턴스에 대한 입력으로 제목을 전달하고 있으며, 각 섹션의 콘텐츠는 ng-content 지시어를 사용하여 상위 컴포넌트에서 투영됩니다. 결론 이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보았습니다. 또한 이러한 기능을 사용하여 다양한 상황에서 사용할 수 있는 간단한 재사용 가능한 컴포넌트를 만드는 방법에 대한 몇 가지 예도 살펴보았습니다. 이러한 사례를 따르면 사용 및 유지 관리가 쉽고 Angular 애플리케이션의 전반적인 품질을 향상하는 데 도움이 되는 컴포넌트를 만들 수 있습니다. Angular에서 재사용 가능한 컴포넌트를 사용하는 주요 이점 중 하나는 코드 중복을 줄이고 코드 유지 관리성을 높이는 기능입니다. 잘 설계되고 잘 문서화된 컴포넌트 세트를 만들면 다른 개발자가 우리 애플리케이션에서 더 쉽게 작업할 수 있을 뿐만 아니라 시간이 지남에 따라 코드를 더 쉽게 유지 관리하고 업데이트할 수도 있습니다. 전반적으로 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하는 것은 웹 애플리케이션의 품질과 유지 관리성을 향상시키는 강력한 기술입니다. 이러한 사례를 따르고 다양한 컴포넌트 디자인을 실험함으로써 다양한 웹 애플리케이션을 구축하는 데 사용할 수 있는 강력하고 유연한 컴포넌트 세트를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"}]},{"title":"[Angular] 애니메이션(Animation) 설명","slug":"angular-15","date":"2023-08-25T13:36:44.000Z","updated":"2023-12-04T07:21:38.585Z","comments":true,"path":"2023/08/25/angular-15/","link":"","permalink":"http://hgko1207.github.io/2023/08/25/angular-15/","excerpt":"","text":"Angular는 동적 웹 애플리케이션을 생성하기 위한 다양한 도구와 기능을 제공하는 강력한 JavaScript 프레임워크입니다. Angular의 주요 기능 중 하나는 애니메이션을 만드는 기능입니다. Angular 애니메이션은 움직임, 전환 및 기타 시각 효과를 추가하여 웹 애플리케이션에 생기를 불어넣는 방법을 제공합니다. 이 글에서는 interfaces, functions, classes, type aliases 및 lifecycle hooks 등을 포함하여 Angular 애니메이션의 다양한 측면을 다룰 것입니다. Animations Module Angular 애니메이션 모듈은 Angular 애플리케이션에서 애니메이션을 정의하고 관리하는 기본 모듈입니다. 복잡하고 아름다운 애니메이션을 만드는 데 사용할 수 있는 다양한 인터페이스, 클래스 및 기능을 제공합니다. Animation Metadata AnimationMetadata 인터페이스는 애니메이션 메타데이터를 정의하는 데 사용되는 기본 인터페이스입니다. AnimationStyleMetadata, AnimationKeyframesSequenceMetadata 및 AnimationAnimateMetadata를 포함한 여러 하위 인터페이스가 있습니다. 이러한 인터페이스는 생성할 수 있는 다양한 유형의 애니메이션을 정의하는 데 사용됩니다. AnimationStyleMetadata AnimationStyleMetadata 인터페이스는 애니메이션 스타일을 정의하는 데 사용됩니다. 여기에는 애니메이션의 타이밍과 모양을 정의하는 데 사용할 수 있는 offset, style 및 animateChild 와 같은 속성이 있습니다. AnimationKeyframesSequenceMetadata AnimationKeyframesSequenceMetadata 인터페이스는 애니메이션 키프레임 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 키프레임과 옵션을 정의하는 데 사용할 수 있는 steps 및 options 과 같은 속성이 있습니다. AnimationAnimateMetadata AnimationAnimateMetadata 인터페이스는 애니메이션 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 스타일, 키프레임 및 옵션을 정의하는 데 사용할 수 있는 style, keyframes 및 options 과 같은 속성이 있습니다. AnimationTriggerMetadata AnimationTriggerMetadata 인터페이스는 애니메이션 트리거를 정의하는 데 사용됩니다. 여기에는 트리거 이름, 애니메이션 정의 및 트리거 옵션을 정의하는 데 사용할 수 있는 name, definitions 및 options 과 같은 속성이 있습니다. AnimationBuilder AnimationBuilder 클래스는 애니메이션을 생성하고 구성하는 데 사용됩니다. 여기에는 애니메이션 시퀀스를 사용자에 맞게 사용할 수 있는 build, before, after 및 delay 과 같은 메서드가 있습니다. AnimationFactory AnimationFactory 클래스는 애니메이션 팩토리를 만드는 데 사용됩니다. 여기에는 새 애니메이션 팩토리를 만드는 데 사용할 수 있는 create 와 같은 메서드가 있습니다. AnimationPlayer AnimationPlayer 클래스는 애니메이션을 관리하는 데 사용됩니다. 여기에는 애니메이션 수명주기를 관리하는 데 사용할 수 있는 play, pause, reset, finish 와 같은 메서드가 있습니다. AnimationEvent AnimationEvent 클래스는 애니메이션 이벤트를 나타내는 데 사용됩니다. 여기에는 애니메이션 이벤트에 대한 정보를 검색하는 데 사용할 수 있는 fromState, toState 및 totalTime 과 같은 속성이 있습니다. AnimationDriver AnimationDriver 인터페이스는 애니메이션 드라이버를 정의하는 데 사용됩니다. 여기에는 애니메이션을 생성하고 관리하는 데 사용할 수 있는 animate, Listen 및 Flush 와 같은 메서드가 있습니다. Animation Types Angular는 역동적이고 매력적인 웹 애플리케이션을 만드는 데 사용할 수 있는 다양한 유형의 애니메이션을 제공합니다. 이러한 애니메이션 유형은 다음과 같습니다. Transition Animation Transition Animation은 상태나 뷰 간의 원활한 전환을 만드는 데 사용됩니다. fades, slides, rotations 과 같은 애니메이션을 만드는 데 사용할 수 있습니다. Animation Sequencing Animation Sequencing은 특정 순서로 발생하는 애니메이션을 만드는 데 사용됩니다. 여러 단계나 시퀀스가 포함된 복잡한 애니메이션을 만드는 데 사용할 수 있습니다. Keyframe Animation Keyframe Animation은 특정 키프레임이나 시점에 발생하는 애니메이션을 만드는 데 사용됩니다. 진동하는 버튼이나 깜박이는 배너와 같은 애니메이션을 만드는 데 사용할 수 있습니다. State Change Animation 상태 변경 애니메이션은 상태가 변경될 때 발생하는 애니메이션을 만드는 데 사용됩니다. 확인란을 전환하거나 패널을 확장하는 등의 애니메이션을 만드는 데 사용할 수 있습니다. Animations Interfaces 앞서 설명한 AnimationMetadata 및 AnimationTriggerMetadata 인터페이스 외에도 Angular에서 애니메이션을 만드는 데 사용할 수 있는 다른 인터페이스가 몇 가지 있습니다. 이러한 인터페이스에는 다음이 포함됩니다. AnimationStateMetadata AnimationStateMetadata 인터페이스는 애니메이션 상태를 정의하는 데 사용됩니다. 여기에는 상태 이름과 스타일을 정의하는 데 사용할 수 있는 name 및 style 과 같은 속성이 있습니다. AnimationTransitionMetadata AnimationTransitionMetadata 인터페이스는 애니메이션 전환을 정의하는 데 사용됩니다. 여기에는 한 상태에서 다른 상태로의 전환을 정의하는 데 사용할 수 있는 fromState, toState 및 animation 과 같은 속성이 있습니다. AnimationQueryMetadata AnimationQueryMetadata 인터페이스는 애니메이션 쿼리를 정의하는 데 사용됩니다. 여기에는 쿼리에 대한 선택기, 애니메이션 및 제한을 정의하는 데 사용할 수 있는 selector, animation 및 limit 과 같은 속성이 있습니다. AnimationStaggerMetadata AnimationStaggerMetadata 인터페이스는 애니메이션 스태거를 정의하는 데 사용됩니다. 여기에는 애니메이션 순서와 타이밍을 정의하는 데 사용할 수 있는 animate, start, interval 및 by 과 같은 속성이 있습니다. AnimationGroupMetadata AnimationGroupMetadata 인터페이스는 애니메이션 그룹을 정의하는 데 사용됩니다. 여기에는 애니메이션 그룹의 단계를 정의하는 데 사용할 수 있는 steps 와 같은 속성이 있습니다. Animation Functions Angular는 애니메이션을 만드는 데 사용할 수 있는 여러 내장 함수를 제공합니다. 이러한 기능에는 다음이 포함됩니다. animate() animate() 함수는 키프레임 애니메이션을 만드는 데 사용됩니다. 지속 시간과 일련의 키프레임을 매개변수로 사용합니다. transition() transition() 함수는 전환 애니메이션을 생성하는 데 사용됩니다. 두 가지 상태, 스타일 세트, 선택적 타이밍 기능을 매개변수로 사용합니다. trigger() trigger() 함수는 애니메이션 트리거를 정의하는 데 사용됩니다. 이름과 일련의 애니메이션 정의를 매개변수로 사용합니다. Animation Enums Angular는 애니메이션을 구성하는 데 사용할 수 있는 여러 열거형도 제공합니다. 이러한 열거형에는 다음이 포함됩니다. AnimationStyleMetadata AnimationStyleMetadata 열거형은 애니메이션의 타이밍과 모양을 정의하는 데 사용됩니다. 여기에는 애니메이션의 모양과 타이밍을 정의하는 데 사용할 수 있는 opacity, transform 및 display 와 같은 속성이 있습니다. AnimationMetadataType AnimationMetadataType 열거형은 애니메이션 메타데이터 유형을 정의하는 데 사용됩니다. 여기에는 다양한 유형의 애니메이션 메타데이터에 해당하는 Style, Keyframes, Animate 과 같은 값이 있습니다. Animation Consts 마지막으로 Angular는 애니메이션을 구성하는 데 사용할 수 있는 몇 가지 내장 상수를 제공합니다. 이러한 상수에는 다음이 포함됩니다. AUTO_STYLE AUTO_STYLE 상수는 요소의 스타일을 자동 스타일로 설정하는 데 사용됩니다. 요소의 자연 상태에 적응하는 동적 애니메이션을 만드는 데 사용할 수 있습니다. TIME TIME 상수는 애니메이션의 타이밍을 설정하는 데 사용됩니다. 특정 기간 동안 발생하는 애니메이션을 만드는 데 사용할 수 있습니다. Animation Lifecycle Hooks Angular는 애니메이션을 제어하는 데 사용할 수 있는 여러 수명 주기 후크를 제공합니다. 이러한 후크에는 다음이 포함됩니다. AnimationStart AnimationStart Hook 는 애니메이션 재생이 시작될 때 호출됩니다. AnimationDone AnimationDone Hook 는 애니메이션이 완료되면 호출됩니다. AnimationDestroy AnimationDestroy Hook 는 애니메이션이 삭제될 때 호출됩니다. 이러한 Hook 를 사용하면 애니메이션이 완료될 때 다른 애니메이션을 시작하거나 중지하는 등의 추가 작업을 수행할 수 있습니다. Animation Testing Angular는 단위 및 통합 테스트에서 애니메이션을 테스트하기 위한 여러 도구를 제공합니다. 이러한 도구에는 다음이 포함됩니다. MockAnimationPlayer MockAnimationPlayer 클래스는 테스트에 사용할 수 있는 모의 애니메이션 플레이어를 만드는 데 사용됩니다. 애니메이션 재생, 일시정지, 완료 등 애니메이션을 시뮬레이션하는 방법을 제공합니다. NoopAnimationsModule NoopAnimationsModule은 테스트에서 애니메이션을 비활성화하는 데 사용됩니다. 실제로 애니메이션을 실행하지 않고 애니메이션을 사용하는 컴포넌트를 테스트하는 데 사용할 수 있습니다. 다음은 Angular 애니메이션의 사용을 보여주는 예입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component, OnInit &#125; from '@angular/core';import &#123; trigger, state, style, transition, animate, AnimationEvent, AnimationBuilder, AnimationFactory, AnimationPlayer,&#125; from '@angular/animations';@Component(&#123; selector: 'app-animation-example', template: ` &lt;div (click)=\"toggleState()\" [@myTrigger]=\"currentState\"&gt; &#123;&#123; currentState &#125;&#125; &lt;/div&gt; `, animations: [ trigger('myTrigger', [ state('one', style(&#123; transform: 'translateX(0)' &#125;)), state('two', style(&#123; transform: 'translateX(100%)' &#125;)), transition('one =&gt; two', animate('500ms ease-in')), transition('two =&gt; one', animate('500ms ease-out')), ]), ],&#125;)export class AnimationExampleComponent implements OnInit &#123; currentState = 'one'; private player: AnimationPlayer; constructor(private builder: AnimationBuilder) &#123;&#125; ngOnInit(): void &#123; this.createPlayer(); &#125; toggleState(): void &#123; this.currentState = this.currentState === 'one' ? 'two' : 'one'; this.player.play(); &#125; private createPlayer(): void &#123; const factory: AnimationFactory = this.builder.build([style(&#123; opacity: 0 &#125;), animate('1s', style(&#123; opacity: 1 &#125;))]); this.player = factory.create(document.querySelector('div')); this.player.play(); &#125; onAnimationStart(event: AnimationEvent): void &#123; console.log(`Animation started: $&#123;event.triggerName&#125;`); &#125; onAnimationDone(event: AnimationEvent): void &#123; console.log(`Animation ended: $&#123;event.triggerName&#125;`); &#125;&#125; 이 예에는 [@myTrigger] 애니메이션 트리거를 사용하여 두 상태 간을 전환하는 간단한 컴포넌트가 있습니다. 트리거 이름과 상태 및 전환 배열을 사용하는 trigger() 함수를 사용하여 트리거를 정의합니다. 또한 컴포넌트에 대한 페이드인 애니메이션을 생성하는 AnimationBuilder 클래스를 사용하여 두 번째 애니메이션을 정의합니다. 컴포넌트가 초기화되면 AnimationFactory 클래스와 AnimationBuilder 를 사용하여 AnimationPlayer 클래스의 인스턴스를 만듭니다. 이 플레이어를 사용하여 컴포넌트가 로드될 때 페이드인 애니메이션을 재생합니다. 사용자가 컴포넌트를 클릭하면 현재 상태를 전환하고 AnimationPlayer 를 사용하여 전환 애니메이션을 재생합니다. 마지막으로 애니메이션이 시작되고 끝날 때 각각 호출되는 onAnimationStart 및 onAnimationDone 이라는 두 개의 수명 주기 Hook 를 정의합니다. 이 예에서는 이러한 Hook 가 호출될 때 콘솔에 메시지를 기록합니다. 다음은 Angular 애니메이션을 사용하여 커스터마이징 애니메이션 로딩 스피너를 만드는 방법을 보여주는 좀 더 복잡한 예입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import &#123; Component, Input, OnInit &#125; from '@angular/core';import &#123; trigger, style, animate, transition, keyframes, AnimationBuilder, AnimationFactory, AnimationPlayer,&#125; from '@angular/animations';@Component(&#123; selector: 'app-spinner', template: ` &lt;div class=\"spinner\" *ngIf=\"show\"&gt; &lt;div class=\"bar\" *ngFor=\"let bar of bars; let i = index\" [@loadingState]=\"i + 1\"&gt;&lt;/div&gt; &lt;/div&gt; `, styles: [ ` .spinner &#123; display: flex; justify-content: center; align-items: center; height: 100%; &#125; .bar &#123; width: 5px; height: 20px; margin: 0 5px; border-radius: 2px; &#125; `, ], animations: [ trigger('loadingState', [ transition( '* =&gt; 1', animate( '&#123;&#123;duration&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 2', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 3', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 4', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 5', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), ]), ],&#125;)export class SpinnerComponent implements OnInit &#123; @Input() duration = '500ms'; @Input() delay = '100ms'; @Input() count = 5; show = false; bars: number[] = []; constructor(private builder: AnimationBuilder) &#123;&#125; ngOnInit(): void &#123; this.bars = new Array(this.count).fill(0); this.show = true; this.createPlayer(); &#125; private createPlayer(): void &#123; const factory: AnimationFactory = this.builder.build([ style(&#123; opacity: 0 &#125;), animate('1s', style(&#123; opacity: 1 &#125;)), animate('1s', style(&#123; opacity: 0 &#125;)), ]); this.player = factory.create(document.querySelector('.spinner')); this.player.onDone(() =&gt; (this.show = false)); this.player.play(); &#125;&#125; 이 예에는 사용자에 맞게 애니메이션 로딩 스피너를 표시하는 컴포넌트가 있습니다. 스피너는 순차적으로 펄스 및 크기 증가 및 감소하는 5개의 수직 막대로 구성됩니다. 애니메이션 키프레임을 지정하기 위해 trigger() 함수와 keyframes() 함수를 사용하여 애니메이션을 정의합니다. 결론 요약하면 Angular는 웹 애플리케이션에서 애니메이션을 생성, 제어 및 테스트하기 위한 포괄적인 도구 세트를 제공합니다. 이러한 도구에는 사용자 경험을 향상하고 애플리케이션에 생명을 불어넣는 복잡하고 매력적인 애니메이션을 만드는 데 사용할 수 있는 interfaces, functions, classes, type aliases 및 lifecycle hooks 가 포함됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"애니메이션","slug":"애니메이션","permalink":"http://hgko1207.github.io/tags/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/"}]},{"title":"[Angular] 성능 최적화(Performance optimization)","slug":"angular-14","date":"2023-08-25T05:31:23.000Z","updated":"2024-01-12T08:14:29.301Z","comments":true,"path":"2023/08/25/angular-14/","link":"","permalink":"http://hgko1207.github.io/2023/08/25/angular-14/","excerpt":"","text":"Angular는 개발자가 고성능 웹 애플리케이션을 구축하는 데 도움을 줄 수 있는 강력한 프런트 엔드 프레임워크입니다. 그러나 애플리케이션이 복잡해짐에 따라 원하는 수준의 성능을 유지하는 것이 더욱 어려워질 수 있습니다. 이 글에서는 Angular 성능을 최적화하는 몇 가지 기술을 살펴보겠습니다. 1. 지연 로딩 모듈(Lazy Loading Modules) 애플리케이션 성능이 저하되는 주요 이유 중 하나는 애플리케이션을 로드하는 데 걸리는 시간입니다. 이 문제를 해결하는 한 가지 방법은 지연 로딩을 사용하는 것입니다. 지연 로딩은 특정 경로에 필요한 모듈만 로드하는 기술입니다. 즉, 초기 로드 시간이 줄어들고 애플리케이션의 응답 속도가 빨라집니다. 다음은 Angular 애플리케이션에서 지연 로딩을 구현하는 방법에 대한 예입니다. 123456const routes: Routes = [ &#123; path: 'admin', loadChildren: () =&gt; import('./admin/admin.module').then((m) =&gt; m.AdminModule), &#125;,]; 이 예에서는 admin 경로에 액세스할 때 AdminModule 모듈을 지연 로딩합니다. 이 모듈은 필요할 때만 로드되므로 애플리케이션의 초기 로드 시간을 줄이는 데 도움이 됩니다. 2. 변화 감지 전략(Change Detection Strategies) Angular는 변경 감지를 사용하여 데이터 변경 사항을 추적하고 그에 따라 뷰를 업데이트합니다. 기본적으로 Angular는 모든 변경 감지 주기에서 모든 컴포넌트를 확인하는 Default 라는 전략을 사용합니다. 특히 컴포넌트가 많은 대규모 애플리케이션의 경우 비용이 매우 많이 들 수 있습니다. 이 문제를 해결하기 위해 Angular는 몇 가지 변경 감지 전략을 제공합니다. 가장 일반적으로 사용되는 전략은 OnPush 입니다. 이 전략을 사용하면 컴포넌트의 입력 속성이 변경되거나 이벤트가 트리거 될 때만 변경 감지가 실행됩니다. 이를 통해 불필요한 변경 감지 주기 수를 크게 줄일 수 있습니다. 다음은 OnPush 변경 감지 전략을 사용하는 방법에 대한 예입니다. 123456789101112@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html', changeDetection: ChangeDetectionStrategy.OnPush,&#125;)export class MyComponentComponent implements OnInit &#123; @Input() myData: any; constructor() &#123;&#125; ngOnInit(): void &#123;&#125;&#125; 이 예에서는 MyComponentComponent 에 대한 OnPush 변경 감지 전략을 사용하고 있습니다. 즉, 변경 감지는 myData 입력 속성이 변경되거나 이벤트가 트리거 될 때만 실행됩니다. 3. 변경 감지 최적화(Change Detection Optimization) OnPush 변경 감지 전략을 사용하더라도 불필요한 변경 감지 주기로 인해 성능 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해 여러 가지 최적화 기술을 사용할 수 있습니다. a. Immutable Objects 불변 객체(Immutable Objects)는 생성된 후에는 변경할 수 없는 객체입니다. 애플리케이션에서 불변 객체를 사용함으로써 불필요한 변경 감지 주기 수를 줄일 수 있습니다. 변경 감지는 기존 객체가 업데이트될 때가 아니라 새 객체가 생성될 때만 실행되어야 하기 때문입니다. 다음은 Angular 애플리케이션에서 불변 객체를 사용하는 방법에 대한 예입니다. 12345export interface User &#123; readonly id: number; readonly name: string; readonly email: string;&#125; 이 예에서는 readonly 키워드를 사용하여 User 인터페이스의 속성을 변경할 수 없게 만듭니다. b. TrackBy Function trackBy 함수는 Angular에 내장된 최적화 기술입니다. 항목 목록의 변경 사항을 추적하는 방법을 Angular에 알려주는 데 사용됩니다. 기본적으로 Angular는 목록에 있는 각 항목의 ID를 비교하여 변경 사항을 추적합니다. 그러나 이는 특히 큰 목록의 경우 비용이 매우 많이 들 수 있습니다. 다음은 Angular 애플리케이션에서 trackBy 함수를 사용하는 방법에 대한 예입니다. 12345&lt;ul&gt; &lt;li *ngFor=\"let user of users; trackBy: trackByUserId\"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 이 예에서는 trackBy 함수를 사용하여 Angular 에 id 속성으로 users 목록의 변경 사항을 추적하도록 지시합니다. 이는 목록에 있는 항목의 id 속성이 변경될 때만 변경 감지가 실행되어야 함을 의미합니다. 123trackByUserId(index: number, user: User): number &#123; return user.id;&#125; 이 예제에서는 인덱스와 사용자 개체를 가져와 사용자 개체의 id 속성을 반환하는 trackByUserId 함수를 구현합니다. 4. NgZone NgZone 은 Angular 영역 외부에서 코드를 실행하는 방법을 제공하는 Angular 에 내장된 서비스입니다. Angular 영역은 변경 감지 및 기타 Angular 관련 작업을 담당하는 실행 컨텍스트입니다. Angular 영역 외부에서 코드를 실행하면 애플리케이션 성능을 향상시킬 수 있습니다. 다음은 Angular 애플리케이션에서 NgZone을 사용하는 방법에 대한 예입니다. 123456789101112131415import &#123; Component, NgZone &#125; from '@angular/core';@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html',&#125;)export class MyComponentComponent &#123; constructor(private ngZone: NgZone) &#123;&#125; runOutsideAngular(): void &#123; this.ngZone.runOutsideAngular(() =&gt; &#123; // Code to run outside of the Angular zone &#125;); &#125;&#125; 이 예에서는 NgZone 서비스를 사용하여 Angular 영역 외부에서 코드를 실행합니다. runOutsideAngular 메서드를 호출하고 Angular 영역 외부에서 실행되는 코드가 포함된 콜백 함수를 전달하여 이를 수행합니다. 외부 API 에서 일부 데이터를 가져와서 화면에 표시하는 컴포넌트가 있다고 가정해 보겠습니다. API 호출을 완료하는 데 오랜 시간이 걸릴 수 있으며, 이로 인해 애플리케이션이 정지되고 응답하지 않게 될 수 있습니다. 이러한 일이 발생하지 않도록 하려면 NgZone을 사용하여 Angular 영역 외부에서 API 호출을 실행하면 애플리케이션이 계속해서 원활하게 실행될 수 있습니다. 컴포넌트의 코드는 다음과 같습니다. 123456789101112131415161718192021222324252627282930import &#123; Component, NgZone &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html',&#125;)export class MyComponentComponent &#123; data: any; constructor(private http: HttpClient, private ngZone: NgZone) &#123;&#125; fetchData(): void &#123; // Run the API call outside of the Angular zone this.ngZone.runOutsideAngular(() =&gt; &#123; // Make the API call this.http.get('https://api.example.com/data').subscribe( (data) =&gt; &#123; // Update the data property with the fetched data this.ngZone.run(() =&gt; &#123; this.data = data; &#125;); &#125;, (error) =&gt; &#123; console.error(error); &#125; ); &#125;); &#125;&#125; 이 예에서는 HttpClient 서비스를 사용하여 https://api.example.com/data에 대한 API 호출을 만듭니다. 또한 NgZone 서비스를 사용하여 Angular 영역 외부에서 API 호출을 실행한 다음 Angular 영역 내부에서 가져온 데이터로 data 속성을 업데이트합니다. 이렇게 하면 API 호출이 진행되는 동안 애플리케이션의 응답성이 유지됩니다. 또한 API 호출 중에 발생할 수 있는 모든 오류를 콘솔에 기록하여 처리하고 있습니다. 템플릿에서 이 컴포넌트를 사용하려면 다음과 같이 할 수 있습니다. 123456789&lt;button (click)=\"fetchData()\"&gt;Fetch Data&lt;/button&gt;&lt;div *ngIf=\"data\"&gt; &lt;ul&gt; &lt;li *ngFor=\"let item of data\"&gt; &#123;&#123; item.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 결론 Angular 성능을 최적화하기 위한 몇 가지 기술을 살펴보았습니다. 지연 로딩, 변경 감지 전략, 변경 감지 최적화 기술 및 NgZone을 사용하여 애플리케이션 성능을 향상하고 더 나은 사용자 경험을 제공할 수 있습니다. 성능 최적화는 지속적인 프로세스라는 점을 명심하는 것이 중요하며 잠재적인 개선 영역이 있는지 애플리케이션을 지속적으로 평가해야 합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Performance","slug":"Performance","permalink":"http://hgko1207.github.io/tags/Performance/"}]},{"title":"[C#] 콘솔 프로그램 백그라운드(창 없이) 실행 방법","slug":"csharp-2","date":"2023-07-31T13:25:39.000Z","updated":"2024-01-12T08:13:50.514Z","comments":true,"path":"2023/07/31/csharp-2/","link":"","permalink":"http://hgko1207.github.io/2023/07/31/csharp-2/","excerpt":"","text":"일반적으로 C#에서 외부 프로그램(.exe 등)을 실행시킬 때 Process를 많이 사용합니다. 콘솔(Console; 도스 커맨드 창)로 실행되는 프로그램을 실행하는 경우 콘솔 창이 화면에 나타나서 UI 상으로 불편한 경우가 있습니다. Process로 콘솔 창을 띄우는 외부 프로그램을 실행 시 콘솔 창을 백그라운드로 실행해 안보이도록 하려면 아래와 같이 합니다. 1234567891011121314151617181920212223using System;using System.Diagnostics;namespace Test.Utils&#123; public class Program &#123; public static void Main(string[] args) &#123; string arg = \"...\"; Process process = new Process(); process.StartInfo.FileName = @\".\\ffmpeg.exe\"; process.StartInfo.Arguments = arg; process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; // 윈도우 속성을 windows hidden 으로 지정 process.StartInfo.CreateNoWindow = true; // hidden 을 시키기 위해서 이 속성도 true 로 체크해야 함 process.Start(); process.WaitForExit(); // 종료시까지 대기 &#125; &#125;&#125; 추가로 외부 프로그램에서 출력한 값을 읽어와서 출력하는 방법은 아래와 같습니다. 12345678910111213141516171819202122232425262728using System;using System.Diagnostics;namespace Test.Utils&#123; public class Program &#123; public static void Main(string[] args) &#123; string arg = \"...\"; Process process = new Process(); process.StartInfo.FileName = @\".\\ffmpeg.exe\"; process.StartInfo.Arguments = arg; process.StartInfo.UseShellExecute = false; // 스트림을 읽는데 필요 process.StartInfo.CreateNoWindow = false; process.StartInfo.RedirectStandardOutput = true; // 실행한 프로그램의 출력을 얻는다. process.Start(); process.WaitForExit(); // 종료시까지 대기 string result = process.StandardOutput.ReadToEnd(); // 실행한 프로그램의 출력을 읽는다. Console.WriteLine(\"result =&gt; \" + result); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"콘솔","slug":"콘솔","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%EC%86%94/"},{"name":"백그라운드","slug":"백그라운드","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C/"},{"name":"백그라운드 실행","slug":"백그라운드-실행","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89/"}]},{"title":"[Eclipse] 프로젝트에 jar 파일 추가하는 방법","slug":"eclipse-1","date":"2023-07-29T04:48:04.000Z","updated":"2024-01-12T08:12:40.542Z","comments":true,"path":"2023/07/29/eclipse-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/29/eclipse-1/","excerpt":"","text":"이클립스에서 라이브러리(jar 파일)를 추가하는 방법입니다. 일반적인 자바 프로젝트와 웹 프로젝트일 경우 두 가지로 방법으로 나눠집니다. 자바 프로젝트 1. 프로젝트 우클릭 &gt; properties 2. Java Build Path &gt; Libraries &gt; Add External JARs 3. 폴더에서 jar 파일 선택 4. 라이브러리 추가 후 [Apply and Close] 클릭 웹 프로젝트(Maven) 1. 아래와 같이 src/main/web/WEB-INF/lib 폴더를 생성하고 lib 폴더에 라이브러리 파일을 넣어준다. 2. 프로젝트 우클릭 &gt; properties 3. Java Build Path &gt; Libraries &gt; Add Library 4. Web App Libraries 선택 후 [Next] 클릭 5. 프로젝트 선택 후 [Finish] 클릭 6. Web App Libraries 추가 확인 후 [Apply and Close] 클릭 결론 라이브러리(jar 파일) 추가 후 코드에서 import 해서 사용하시면 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"jar 파일","slug":"jar-파일","permalink":"http://hgko1207.github.io/tags/jar-%ED%8C%8C%EC%9D%BC/"}]},{"title":"자동가입 방지문자(SimpleCaptcha) 사용 방법","slug":"web-1","date":"2023-07-29T04:25:33.000Z","updated":"2024-01-12T08:13:10.946Z","comments":true,"path":"2023/07/29/web-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/29/web-1/","excerpt":"","text":"로그인 또는 회원가입 시 자동 등록 방지가 필요할 경우가 있다. 이를 구현하기 위해 여러 가지가 있는데 CATPCHA를 사용하는 방법을 사용하였다. CAPTCHA는 HIP 기술의 일종으로, 어떠한 사용자가 실제 사람인지 컴퓨터 프로그램인지를 구별하기 위해 사용되는 방법이다. 사람은 구별할 수 있지만 컴퓨터는 구별하기 힘들게 의도적으로 비틀거나 덧칠한 그림을 주고 그 그림에 쓰여 있는 내용을 물어보는 방법이 자주 사용된다. 위키백과 다운로드 CATPCHA를 사용하기 위해선 https://sourceforge.net/projects/simplecaptcha/ 사이트로 이동해서 jar 파일을 다운로드 받는다. jar 파일 추가 사용하는 툴이 이클립스 일 경우 jar 파일을 프로젝트에 포함시켜야 한다. [Eclipse] 프로젝트에 jar 파일 추가하는 방법 사이트를 참고해서 추가합니다. 사용 HTML 먼저 자동입력 방지 기능을 넣기 위한 화면 코드다. CATPCHA 이미지를 보여주고 이미지 안의 숫자들을 새로고침 할 수 있는 버튼을 만들었다. 12345678910&lt;div class=\"mt-3\"&gt; &lt;label class=\"form-label fw-bold\"&gt;자동입력 방지문자&lt;/label&gt; &lt;div class=\"d-flex\"&gt; &lt;img id=\"captchaImg\" src=\"captchaImg\" title=\"캡차 이미지\" alt=\"캡차 이미지\" /&gt; &lt;button type=\"button\" id=\"refresh_btn\" class=\"btn btn-sm btn-gray w-50 ms-2\"&gt;새로고침&lt;/button&gt; &lt;/div&gt; &lt;div class=\"d-flex mt-1\"&gt; &lt;input id=\"captcha\" type=\"text\" class=\"form-control input-control\" /&gt; &lt;/div&gt;&lt;/div&gt; Controller 부분 html에서 /captchaImg 경로를 호출하면 아래 컨트롤러가 호출된다. Captcha 이미지 설정을 한 후 세션에 값을 저장하고 이미지를 그려준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * captchaImg * @param request * @param response * @throws IOException */@GetMapping(\"captchaImg\")public void captchaImg(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; try &#123; // 폰트 설정 ========================================================= List&lt;Font&gt; fontList = new ArrayList&lt;Font&gt;(); fontList.add(new Font(\"\", Font.HANGING_BASELINE, 28)); fontList.add(new Font(\"Courier\", Font.ITALIC, 28)); fontList.add(new Font(\"\", Font.PLAIN, 28)); List&lt;Color&gt; colorList = new ArrayList&lt;Color&gt;(); colorList.add(Color.black); Captcha captcha = new Captcha.Builder(200, 36) // 이미지 크기 설정 .addText(new NumbersAnswerProducer(6), new DefaultWordRenderer(colorList, fontList)) //.gimp(new DropShadowGimpyRenderer()).gimp() // 그림자 효과 추가 .addNoise().addNoise() // 한번 호출할 떄마다 하나의 라인이 추가된다 .addBackground(new GradiatedBackgroundProducer()) // Gradiated백그라운드 효과 추가 .addBorder() // 검정 테두리 선 생성 .build(); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setHeader(\"Pragma\", \"no-cache\"); // 캐쉬를 지우기 위해 헤더값을 설정 response.setDateHeader(\"Expires\", 0); response.setDateHeader(\"Max-Age\", 0); // 리턴값을 image형태로 설정 response.setContentType(\"image/png\"); // 세션에 자동가입방지 문자를 저장한다. request.getSession().setAttribute(Captcha.NAME, captcha); // Image를 write 한다 CaptchaServletUtil.writeImage(response, captcha.getImage()); &#125; catch (Exception e) &#123; response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; &#125;&#125; 다음은 현재 보이는 자동입력 방지문자와 입력한 문자가 일치하는 하는지 확인하는 코드다. 1234567891011121314/** * 자동입력 방지문자 확인 */@GetMapping(\"isCorrect\")public ResponseEntity&lt;?&gt; isCorrect(HttpServletRequest request, String answer) &#123; boolean result = false; Captcha captcha = (Captcha) request.getSession().getAttribute(Captcha.NAME); if (captcha.isCorrect(answer)) &#123; result = true; &#125; return new ResponseEntity&lt;&gt;(result, HttpStatus.OK);&#125; JavaScript 화면단에서 자등입력 방지문자를 잘 입력했는지 확인하는 코드다. 12345678910111213141516171819202122232425262728293031// 자동입력 방지문자가 일치하는지 확인const isCaptCha = () =&gt; &#123; const answer = $('#captcha').val(); if (answer == '') &#123; alert('자동입력 방지문자를 입력해주세요.'); return; &#125; let result = false; $.ajax(&#123; url: `$&#123;contextPath&#125;/signup/isCorrect`, type: 'GET', data: &#123; answer: answer &#125;, async: false, success: function (response) &#123; result = response; &#125;, &#125;); return result;&#125;;if (!isCaptCha()) &#123; alert('자동입력 방지문자가 일치하지 않습니다.', function () &#123; $('#captcha').focus(); &#125;); return;&#125; else &#123; alert('자동입력 방지문자가 일치합니다.');&#125; 새로고침 버튼을 누를 경우 자동입력 방지문자 이미지 안의 숫자가 바뀐다. 123456/** * 자동입력 방지문자 새로고침 */$('#refresh_btn').click(function () &#123; $('#captchaImg').attr('src', 'captchaImg');&#125;); 화면 성공적으로 자동입력 방지문자 이미지를 가져왔다! 위의 방법처럼 쉽게 구현할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Captcha","slug":"Captcha","permalink":"http://hgko1207.github.io/tags/Captcha/"},{"name":"SimpleCptcha","slug":"SimpleCptcha","permalink":"http://hgko1207.github.io/tags/SimpleCptcha/"},{"name":"자동가입방지문자","slug":"자동가입방지문자","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%8F%99%EA%B0%80%EC%9E%85%EB%B0%A9%EC%A7%80%EB%AC%B8%EC%9E%90/"}]},{"title":"[Angular] DI 수명(lifetime)","slug":"angular-13","date":"2023-07-21T12:07:55.000Z","updated":"2024-01-12T08:12:16.869Z","comments":true,"path":"2023/07/21/angular-13/","link":"","permalink":"http://hgko1207.github.io/2023/07/21/angular-13/","excerpt":"","text":"Transient Transient 서비스는 주입될 때마다 생성됩니다. 즉, 컴포넌트(component)가 서비스를 주입할 때마다 서비스의 새 인스턴스가 생성됩니다. Transient 서비스의 예는 다음과 같습니다. 1234567891011121314import &#123; Injectable &#125; from '@angular/core';@Injectable()export class TransientService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 컴포넌트가 TransientService를 주입하면 매번 서비스의 새 인스턴스가 생성됩니다. Scoped Scoped 서비스는 Angular 모듈당 한 번 생성됩니다. 이는 동일한 모듈 내의 컴포넌트(component)가 서비스를 주입할 때마다 동일한 서비스 인스턴스가 사용됨을 의미합니다. Scoped 서비스의 예는 다음과 같습니다. 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'my-module',&#125;)export class ScopedService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 동일한 모듈 내의 컴포넌트가 ScopedService를 주입하면 동일한 서비스 인스턴스가 사용됩니다. Singleton Singleton 서비스는 한 번 생성되고 동일한 인스턴스가 애플리케이션 전체에서 사용됩니다. 다음은 Singleton 서비스의 예입니다. 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class SingletonService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 컴포넌트가 SingletonService를 주입하면 애플리케이션 전체에서 동일한 서비스 인스턴스가 사용됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"DI","slug":"DI","permalink":"http://hgko1207.github.io/tags/DI/"},{"name":"의존성","slug":"의존성","permalink":"http://hgko1207.github.io/tags/%EC%9D%98%EC%A1%B4%EC%84%B1/"},{"name":"수명","slug":"수명","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EB%AA%85/"},{"name":"lifetime","slug":"lifetime","permalink":"http://hgko1207.github.io/tags/lifetime/"}]},{"title":"[Angular] OpenLayers로 지도 생성","slug":"angular-12","date":"2023-07-18T05:05:29.000Z","updated":"2024-01-12T08:09:48.669Z","comments":true,"path":"2023/07/18/angular-12/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/angular-12/","excerpt":"","text":"OpenLayers는 개인 또는 상업 프로젝트에 지도를 추가해야 하는 경우 광범위한 사용 사례에 적합한 오픈 소스 라이브러리입니다. 아래 단계를 따라 하면 몇 분 안에 빠르게 실행할 수 있습니다. Angular 프로젝트를 한 번도 해본 적이 없는 경우 새 프로젝트를 만드는 방법을 보여 드리겠습니다. 하지만 해당 부분을 건너뛰고 OpenLayers를 기존 프로젝트에 추가할 수 있습니다. 새 Angular 프로젝트 만들기 이 시점에서 첫 번째 Angular 프로젝트를 설정하는 방법을 보여 드리겠습니다. 모든 컴퓨터 운영 체제를 사용할 수 있으며 Angular는 macOS, Linux 및 Windows에서 작동합니다. 이것은 지금 사용하는 설정입니다. 1234Angular CLI: 16.1.0Node: 18.15.0Package Manager: npm 9.5.0OS: win32 x64 먼저 Angular를 처음 사용하는 경우 로컬 환경을 설정해야 합니다. Node.js 와 npm이 필요합니다. 설치된 버전을 확인하려면 다음 명령을 실행하십시오. 12node -vnpm -v 자, 새 프로젝트를 만들어 봅시다. command line interface(터미널, 명령 프롬프트)를 열고 새 Angular 프로젝트에 사용하려는 디렉토리로 이동합니다. Angular CLI를 설치하려면 다음을 실행합니다. 1npm install -g @angular/cli 이제 작업 공간을 만듭니다. 1ng new openlayers-demo 그리고 앱을 실행할 수 있는지 확인하십시오. 12cd openlayers-demong serve — open 잘하셨습니다. 이제 OpenLayers 설정을 시작할 준비가 되었습니다. Angular 프로젝트에 OpenLayers 추가 최신 버전의 OpenLayers를 설치합니다. 1npm install --save ol 이 시점에서 앱을 제공하려고 하면 앱이 컴파일되지 않는 것을 알 수 있습니다. 이 문제는 Openlayers 6.6 이상 버전에 존재하므로 위의 명령에 @6.5를 추가하여 Openlayers 6.5 버전을 사용하도록 결정할 수도 있습니다. 그러나 이후 버전에 존재하는 문제를 해결하는 방법을 살펴보겠습니다. 아래와 같이 ol 라이브러리와 관련된 오류가 표시됩니다. 1234Error: node_modules/ol/source/Cluster.d.ts:136:31 - error TS2314: Generic type 'Feature&lt;Geometry&gt;' requires 1 type argument(s).136 protected features: Array&lt;Feature&gt;;Error: node_modules/ol/source/Cluster.d.ts:152:23 - error TS2314: Generic type 'VectorSource&lt;Geometry&gt;' requires 1 type argument(s).152 protected source: VectorSource; 오류를 해결하려면 tsconfig.json 파일을 열고 compilerOptions 안에 &quot;skipLibCheck&quot;:true 옵션을 추가합니다. 123456789101112131415161718192021222324252627&#123; \"compileOnSave\": false, \"compilerOptions\": &#123; \"baseUrl\": \"./src\", \"outDir\": \"./dist/out-tsc\", \"sourceMap\": true, \"declaration\": false, \"module\": \"es2020\", \"moduleResolution\": \"node\", \"experimentalDecorators\": true, \"allowSyntheticDefaultImports\": true, \"importHelpers\": true, \"target\": \"es2020\", \"typeRoots\": [\"node_modules/@types\"], \"lib\": [\"es2018\", \"dom\"], \"paths\": &#123; \"@core\": [\"@core/\"], \"environments\": [\"environments/\"] &#125;, \"resolveJsonModule\": true, \"skipLibCheck\": true &#125;, \"angularCompilerOptions\": &#123; \"fullTemplateTypeCheck\": false, \"strictInjectionParameters\": false &#125;&#125; 이제 OpenLayers CSS Style을 프로젝트에 추가하십시오. angular.json 파일을 열고 기존 CSS Style 옆에 &quot;node_modules/ol/ol.css&quot; 를 추가합니다. 123456789101112131415161718192021222324252627282930&#123; \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", \"version\": 1, \"newProjectRoot\": \"projects\", \"projects\": &#123; \"openlayers-demo\": &#123; \"projectType\": \"application\", \"schematics\": &#123; \"@schematics/angular:component\": &#123; \"style\": \"scss\" &#125; &#125;, \"root\": \"\", \"sourceRoot\": \"src\", \"prefix\": \"app\", \"architect\": &#123; \"build\": &#123; \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": &#123; ... \"styles\": [ \"src/styles.scss\", \"node_modules/ol/ol.css\" ], &#125; &#125; &#125; &#125; &#125;&#125; 이제 지도를 넣을 수 있는 컴포넌트를 만들 차례입니다. 1ng generate component map 컴포넌트의 콘텐츠를 추가합니다. map.component.html 1&lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; map.component.scss 1234.map &#123; width: 100%; height: 500px;&#125; map.component.ts 12345678910111213141516171819202122232425262728293031import &#123; Component, OnInit &#125; from '@angular/core';import 'ol/ol.css';import Map from 'ol/Map';import View from 'ol/View';import &#123; OSM &#125; from 'ol/source';import TileLayer from 'ol/layer/Tile';@Component(&#123; selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'],&#125;)export class MapComponent implements OnInit &#123; public map!: Map; ngOnInit(): void &#123; this.map = new Map(&#123; layers: [ new TileLayer(&#123; source: new OSM(), &#125;), ], target: 'map', view: new View(&#123; center: [0, 0], zoom: 2, maxZoom: 18, &#125;), &#125;); &#125;&#125; OSM 은 OpenStreetMaps를 의미하며 여기서는 표준 지도를 사용하지만 OpenLayers는 다양한 지도 Tile Servers, 이미지 등과 함께 작동하며 사용자 고유의 레이어를 만들고 사용자 지정할 수도 있습니다. 마지막 단계는 지도 컴포넌트의 내용을 포함하도록 루트 html 파일 app.component.html의 내용을 바꾸는 것입니다. 1&lt;app-map&gt;&lt;/app-map&gt; 이제 작동하는 웹사이트를 확인할 시간입니다! 이 글에서는 OpenLayers 라이브러리로 Angular 프로젝트를 설정하여 웹사이트에서 지도를 사용하는 방법을 배웠습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"지도","slug":"지도","permalink":"http://hgko1207.github.io/tags/%EC%A7%80%EB%8F%84/"}]},{"title":"[C#] FileSystemWatcher 파일 감시 모니터링","slug":"csharp-1","date":"2023-07-18T04:49:39.000Z","updated":"2024-01-12T08:10:51.529Z","comments":true,"path":"2023/07/18/csharp-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/csharp-1/","excerpt":"","text":"FileSystemWatcher는 특정 폴더 경로(디렉터리)의 모든 파일이 생성되거나 변경되면 함수 호출을 해줍니다. 사용 방법 사용 방법 순서입니다. FileSystemWatcher 생성자 호출 감시할 폴더 설정(디렉토리) 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) 감시할 이벤트 설정 (생성, 변경, 삭제 등) FIleSystemWatcher 감시 모니터링 활성화 감시할 폴더 내부 변경 시 event 호출 구현 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;namespace Test.Utils&#123; public class FileWatcher &#123; public void initWatcher() &#123; string filePath = $\"D:\\\\files\\\\\"; // 1. FileSystemWatcher 생성자 호출 FileSystemWatcher watcher = new FileSystemWatcher(); // 2. 감시할 폴더 설정(디렉토리) watcher.Path = filePath; // 3. 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) watcher.NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size | NotifyFilters.LastAccess | NotifyFilters.CreationTime | NotifyFilters.LastWrite; //감시할 파일 유형 선택 예) *.* 모든 파일 watcher.Filter = \"*.*\"; watcher.IncludeSubdirectories = true; // 4. 감시할 이벤트 설정 (생성, 변경..) watcher.Created += new FileSystemEventHandler(Changed); watcher.Changed += new FileSystemEventHandler(Changed); watcher.Renamed += new RenamedEventHandler(Renamed); // 5. FIleSystemWatcher 감시 모니터링 활성화 watcher.EnableRaisingEvents = true; &#125; // 6. 감시할 폴더 내부 변경 시 event 호출 private void Changed(object source, FileSystemEventArgs e) &#123; Console.Write(e.FullPath); &#125; // 이름 변경 시 event 호출 private void Renamed(object source, RenamedEventArgs e) &#123; MessageBox.Show(e.FullPath); &#125; &#125;&#125; FileSystemWatcher은 using System.IO를 선언해 주어야 합니다. initWatcher() 함수를 실행시키면 D:\\files\\ 해당 경로에 파일이 생기면 바로 Changed() 이벤트가 호출됩니다. 호출될 때 담기는 파라미터 FileSystemEventArgs e에서 e.Fullpath를 통해 생성된 파일의 전체 경로를 가져옵니다. 12# 예)D:\\files\\새 텍스트 문서.txt 이렇게 FileSystemWatcher를 사용해서 해당 폴더를 실시간으로 감지 모니터링하는 기능을 구현했습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"}]},{"title":"[Angular] cross-fetch 사용 방법","slug":"angular-11","date":"2023-07-11T02:48:34.000Z","updated":"2024-01-12T08:09:00.973Z","comments":true,"path":"2023/07/11/angular-11/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-11/","excerpt":"","text":"Angular 개발 시 api 통신을 하기 위한 Fetch API에 대해 알아보겠습니다. Fetch API 란 Fetch API는 HTTP 파이프라인을 구성하는 요청과 응답 등의 요소를 JavaScript에서 접근하고 조작할 수 있는 인터페이스를 제공합니다. Fetch API가 제공하는 전역 fetch() 메서드로 네트워크의 리소스를 쉽게 비동기적으로 취득할 수도 있습니다. 설치 Fetch API를 사용하기 위해 cross-fetch 패키지를 설치한다. 12345# npm 을 사용하여 설치하는 경우npm install --save cross-fetch# yarn 을 사용하여 설치하는 경우yarn add cross-fetch ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; http 메서드 설정 HTTP 요청 메소드에서 자주 사용하는 GET, POST, PUT, DELETE 를 사용하는 함수를 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable &#125; from '@angular/core';import fetch from 'cross-fetch';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125; public get(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'GET', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public post(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'POST', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public put(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'PUT', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public delete(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'DELETE', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125;&#125; fetch의 return 타입은 Promise 이기 때문에 then 함수를 사용하거나 async await 를 사용한다. 12345678910111213141516171819202122// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; ApiService &#125; from 'app/services/api.service';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; private BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private api: ApiService) &#123; this.api.get(`$&#123;BASE_URL&#125;/today`).then((response: any) =&gt; &#123; if (response.ok) &#123; console.log(response.json()); &#125; &#125;); &#125; ngOnInit(): void &#123;&#125;&#125; 참고 Fetch API 사용하기 https://github.com/lquixada/cross-fetch","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"}]},{"title":"[Angular] HttpClient 사용 방법","slug":"angular-10","date":"2023-07-11T02:13:24.000Z","updated":"2024-01-12T08:07:32.234Z","comments":true,"path":"2023/07/11/angular-10/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-10/","excerpt":"","text":"Angular 개발 시 프로젝트 초기에 api 통신에 대해 설정 파일을 생성하고 설정해 두면 작업하기가 편합니다. Angluar는 @angular/common 안에 존재하는 http 패키지를 사용하면 됩니다. import http 작업을 하기 위해 src/app.module.ts 파일에 HttpClientModule을 import 해야 합니다. 12345678910111213141516// src/app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpClientModule &#125; from '@angular/common/http';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], // BrowserModule 다음에 HttpClientModule를 작성해야 한다 imports: [BrowserModule, HttpClientModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; Injectable 이기 때문에 다른 module 에서 import 하지 않아도 바로 사용할 수 있다. baseUrl 설정 이제 불러 올 api의 baseUrl을 설정해준다. 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125;&#125; 보통 BASE_URL은 각 프로젝트의 환경 별로 다르게 설정 가능하다. 12345// src/environments/environments.tsexport const environment = &#123; production: false, baseUrl: 'https://test.api.example.com',&#125;; 12345// src/environments/environment.prod.tsexport const environment = &#123; production: true, baseUrl: 'https://api.example.com',&#125;; 위의 처럼 설정한 후 src/api/api.service.ts에 다음과 같이 불러와 사용하면 된다. 12345import &#123; environment &#125; from 'environments/environment';// ...생략export class ApiService &#123; public BASE_URL = environment.baseUrl;&#125; http 메서드 설정 HTTP 요청 메서드에서 자주 사용하는 GET, POST, PUT, DELETE를 사용하는 함수를 생성한다. 123456789101112131415161718192021222324252627// src/api/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';import &#123; Observable &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125; post&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.post&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; put&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.put&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; delete&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.delete&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125;&#125; Angular의 http의 return 타입은 모두 Observable 이기 때문에, 할당할 변수의 타입도 Observable로 지정해야 한다. 1234567891011121314151617181920212223242526// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs';import &#123; ApiService &#125; from 'app/services/api.service';interface WebToonInfo &#123; id: string; title: string; thumb: number;&#125;@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; webToons$: Observable&lt;WebToonInfo[]&gt;; constructor(private api: ApiService) &#123; this.webToons$ = this.api.get('/today'); this.webToons$.subscribe(console.log); // console 확인 &#125; ngOnInit(): void &#123;&#125;&#125; Error 처리 만약 에러를 처리하고 싶다면, 각 api 요청마다 설정할 수도 있지만 api.service.ts 에서 설정 해줘도 된다. 1234567891011121314151617181920212223// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpErrorResponse &#125; from '@angular/common/http';import &#123; Observable, throwError &#125; from 'rxjs';import &#123; catchError &#125; from 'rxjs/operators';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; // ... 생략 private handleError(error: HttpErrorResponse) &#123; if (error.status === 0) &#123; console.error('Error:', error.error); &#125; else &#123; console.error(`Backend error $&#123;error.status&#125;, $&#123;error.error&#125;`); &#125; return throwError('예기치 못한 에러가 발생했습니다. 다시 시도해주세요.'); &#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`).pipe(catchError(this.handleError)); &#125;&#125; 참고 Understanding communicating with backend services using HTTP","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"}]},{"title":"Flutter 업그레이드 방법","slug":"flutter-2","date":"2023-05-30T05:14:11.000Z","updated":"2024-01-12T08:02:43.807Z","comments":true,"path":"2023/05/30/flutter-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/30/flutter-2/","excerpt":"","text":"Flutter 버전 오류 Flutter 프로젝트를 진행하면서 http 패키지를 설치하려고 flutter pub get 명령어를 실행했을 때 다음과 같은 오류가 발생했습니다. 123456[flutter\\example] flutter pub getResolving dependencies...The current Dart SDK version is 3.0.0-431.0.devBecause example depends on http &gt;=1.0.0 which requires SDK version ^3.0.0, version solving failed.exit code 1 http 패키지의 1.0.0 버전을 설치하는데 현재 Dart SDK 버전이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되지 않아 발생한 오류였습니다. 현재 Dart SDK 버전 3.0.0-431.0.dev 이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되는 것 같지만 실제로는 조건에 충족하지 않습니다. 오류 해결 Dart SDK 버전을 올려주면 해결됩니다. 버전을 올리기 위해 Dart를 새로 설치를 해도 되지만 번거롭습니다. flutter 명령어로 Flutter와 Dart의 버전을 올릴 수 있기 때문에 flutter CLI 명령어로 버전을 변경합니다. 1flutter upgrade 위의 명령어를 실행하면 다음와 같이 업그레이드를 진행합니다. 12345678910111213141516171819202122232425Upgrading engine...Downloading android-arm-profile/windows-x64 tools... 387msDownloading android-arm-release/windows-x64 tools... 101msDownloading android-arm64-profile/windows-x64 tools... 132msDownloading android-arm64-release/windows-x64 tools... 97msDownloading android-x64-profile/windows-x64 tools... 101msDownloading android-x64-release/windows-x64 tools... 103msDownloading android-x86 tools... 639msDownloading android-x64 tools... 628msDownloading android-arm tools... 521msDownloading android-arm-profile tools... 216msDownloading android-arm-release tools... 142msDownloading android-arm64 tools... 526msDownloading android-arm64-profile tools... 261msDownloading android-arm64-release tools... 201msDownloading android-x64-profile tools... 258msDownloading android-x64-release tools... 214msDownloading android-x86-jit-release tools... 337msDownloading Web SDK... 1,662ms...Flutter 3.11.0-15.0.pre.48 • channel master • https://github.com/flutter/flutter.gitFramework • revision c5f45d7121 (54 minutes ago) • 2023-05-30 00:15:34 -0400Engine • revision b5f60d2b33Tools • Dart 3.1.0 (build 3.1.0-155.0.dev) • DevTools 2.23.1 flutter 업그레이드가 끝나고 다시 flutter pub get 명령어를 실행하면 정상적으로 dependency를 가지고 오는 것을 확인할 수 있습니다. 1234567891011[flutter\\example] flutter pub getResolving dependencies...&gt; collection 1.17.2 (was 1.17.1)+ http 1.0.0+ http_parser 4.0.2 matcher 0.12.15 (0.12.16 available)&gt; material_color_utilities 0.5.0 (was 0.3.0)&gt; test_api 0.5.2 (was 0.5.1) (0.6.0 available)+ typed_data 1.3.2Changed 6 dependencies!exit code 0","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"}]},{"title":"[NestJS] End-to-end 테스트","slug":"nest-7","date":"2023-05-15T07:11:20.000Z","updated":"2024-01-12T08:01:02.809Z","comments":true,"path":"2023/05/15/nest-7/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-7/","excerpt":"","text":"End-to-end 테스트 개별 모듈과 클래스에 중점을 두는 Unit 테스트와 달리 end-to-end(e2e) 테스트는 보다 종합적인 수준에서 클래스와 모듈의 상호 작용을 다룹니다. 애플리케이션이 성장함에 따라 각 API endpoint의 E2E 동작을 수동으로 테스트하기가 어려워집니다. 자동화된 E2E 테스트는 시스템의 전반적인 동작이 정확하고 프로젝트 요구 사항을 충족하는지 확인하는 데 도움이 됩니다. Nest를 사용하면 SuperTest 라이브러리를 사용하여 HTTP request를 쉽게 시뮬레이션할 수 있습니다. SuperTest는 superagent를 기반으로 하는 HTTP 검증 라이브러리입니다. request() SuperTest 의 request(app.getHttpServer()) 함수를 사용하여 HTTP 테스트를 시뮬레이션합니다. 1234// localhost:3000/ 으로 라우팅될 때 Hello World!가 출력되는지 확인it('/ (GET)', () =&gt; &#123; return request(app.getHttpServer()).get('/').expect(200).expect('Hello World!');&#125;); 이러한 HTTP request 가 실행 중인 Nest 앱으로 라우팅 되기를 원하므로 request() 함수에 Nest 의 기반이 되는 HTTP 리스너에 대한 참조를 전달합니다. 사용 예시 기본적인 CRUD (Create/Read/Update/Delete) 에 대한 테스트를 하기 위해 다음과 같이 작성할 수 있습니다. 1234567891011121314151617181920212223242526272829describe('/users', () =&gt; &#123; it('GET', () =&gt; &#123; return request(app.getHttpServer()).get('/users').expect(200).expect([]); &#125;); it('POST', () =&gt; &#123; return request(app.getHttpServer()) .post('/users') .send(&#123; name: 'hgko', age: 30, hobbies: ['soccer'], &#125;) .expect(201); &#125;); it('PATCH', () =&gt; &#123; return request(app.getHttpServer()) .patch('/users/1') .send(&#123; age: 35, &#125;) .expect(200); &#125;); it('DELETE', () =&gt; &#123; return request(app.getHttpServer()).delete('/users/1').expect(200); &#125;);&#125;); 참고 https://docs.nestjs.com/fundamentals/testing#end-to-end-testing https://github.com/visionmedia/supertest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"}]},{"title":"[NestJS] Jest 사용 방법","slug":"nest-6","date":"2023-05-15T01:55:57.000Z","updated":"2024-01-12T07:22:39.918Z","comments":true,"path":"2023/05/15/nest-6/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-6/","excerpt":"","text":"NestJS에서 Jest를 사용하는 방법에 대해 간략하게 알아보겠습니다. Jest Jest는 단순함에 초점을 맞춘 유쾌한 JavaScript 테스팅 프레임워크입니다. Babel, TypeScript, Node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동합니다. 시작하기 describe() describe() 함수를 사용하면 작은 단위의 테스트 코드를 그룹화할 수 있습니다. 작성하는 테스트 코드가 특정 component 에 속하는 테스트 코드라면 다음과 같이 describe() 함수를 사용해서 해당 테스트 코드들을 그룹화하는 것이 좋습니다. 테스트 결과를 확인할 때 가시적으로 보기 편하게 테스트 케이스들을 확인할 수 있습니다. 12345678910111213describe('StudentService', () =&gt; &#123; test('getAll', () =&gt; &#123; ... &#125;); test('getOne', () =&gt; &#123; ... &#125;); test('create', () =&gt; &#123; ... &#125;);&#125;); it(), test() 테스트 케이스를 생성합니다. it() 함수 대신 test()도 사용 가능합니다. 123it('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 123test('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); expect() 값을 테스트할 때마다 expect() 함수가 사용됩니다. 테스트할 때 expect() 함수를 여러개 사용할 수 있습니다. 1234567function bestJuiceFlavor() &#123; return 'apple';&#125;test('the best flavor is apple', () =&gt; &#123; expect(bestJuiceFlavor()).toBe('apple');&#125;); Using Matchers Common Matchers toBe() 함수는 Object.is를 사용하여 정확한 동등성을 테스트합니다. 객체의 값을 확인하려면 대신 toEqual() 함수를 사용하세요. 123it('two plus two is four', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 12345it('object assignment', () =&gt; &#123; const data = &#123; one: 1 &#125;; data['two'] = 2; expect(data).toEqual(&#123; one: 1, two: 2 &#125;);&#125;); Strings toMatch() 함수를 사용하여 정규 표현식에 대해 문자열을 확인할 수 있습니다. 123it('but there is a \"ko\" in hgko', () =&gt; &#123; expect('hgko').toMatch(/ko/);&#125;); Arrays and iterables toContain() 함수를 사용하여 배열 또는 iterable에 특정 항목이 포함되어 있는지 확인할 수 있습니다. 123456789const shoppingList = ['egg', 'coffee', 'tissue', 'milk'];it('the shopping list has milk on it', () =&gt; &#123; // array expect(shoppingList).toContain('milk'); // iterable expect(new Set(shoppingList)).toContain('milk');&#125;); Exceptions 특정 함수가 호출될 때 오류가 발생하는지 테스트하려면 toThrow() 함수를 사용합니다. 예외를 발생시키는 함수는 래핑 함수 내에서 호출해야 합니다. 그렇지 않으면 toThrow assertion 이 실패합니다. 123456789101112131415describe('getOne', () =&gt; &#123; it('shoule find a student', () =&gt; &#123; const student = service.getOne(1); expect(student).toBeDefined(); &#125;); it('should throw 404 error', () =&gt; &#123; try &#123; service.getOne(999); &#125; catch (e) &#123; expect(e).toBeInstanceOf(NotFoundException); expect(e.message).toEqual(`Student with ID: 999 not found.`); &#125; &#125;);&#125;); toBeInstanceOf(Class) 함수를 사용하여 객체가 클래스의 인스턴스인지 확인할 수 있습니다. 테스트 전/후 처리 beforeEach 각각의 테스트가 실행되기 전에 매번 함수를 실행합니다. 각각의 테스트 전에 각 테스트에서 사용할 전역 상태를 재설정하려는 경우에 유용합니다. 함수가 promise을 반환하거나 generator 인 경우 Jest는 테스트를 실행하기 전에 해당 promise가 해결될 때까지 기다립니다. 밀리초로 대기할 시간을 지정할 수 있습니다. (기본 시간 5초) 1234567891011121314let users: User[];// test() 함수들이 실행될때마다 beforeEach()에서 설정한, users 데이터를 사용하게 된다.beforeEach(async () =&gt; &#123; users.push(&#123; id: 1, name: 'hgko' &#125;, &#123; id: 2, name: 'eden' &#125;);&#125;);test('find all users', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;);test('create a user', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;); afterEach 각각의 테스트가 완료된 후 함수를 실행합니다. beforeAll 모든 테스트가 실행되기 전에 딱 한 번 함수를 실행합니다. 123456let connection;beforeAll(() =&gt; &#123; // 테스트 실행하기전에 데이터베이스에 접속할 연결(Connection) 개체를 만든다. conection = openConnection(&#123; host: '...', port: '...' &#125;);&#125;); afterAll 모든 테스트가 완료된 후 함수를 실행합니다. 1234afterAll(() =&gt; &#123; // 데이터베이스 Connection을 종료한다. conection.close();&#125;); 실행 NestJS 개발환경에서 package.json 파일에 Testing 하는 명령어가 정의되어 있습니다. 123456789101112// package.json&#123; ... \"scripts\": &#123; ... \"test\": \"jest\", \"test:watch\": \"jest --watch\", \"test:cov\": \"jest --coverage\", \"test:debug\": \"node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand\", \"test:e2e\": \"jest --config ./test/jest-e2e.json\" &#125;,&#125; 다음과 같이 테스트 하려는 방식에 따라 명령어를 실행해서 테스트합니다. 1234567# Unit 테스트npm run testnpm run test:watchnpm run test:cov# E2E 테스트npm rum test:e2e 참고 https://jestjs.io/ https://jestjs.io/docs/getting-started https://jestjs.io/docs/expect","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"}]},{"title":"[NestJS] Mapped types의 Partial 사용 방법","slug":"nest-5","date":"2023-05-13T12:46:39.000Z","updated":"2024-01-12T07:21:40.161Z","comments":true,"path":"2023/05/13/nest-5/","link":"","permalink":"http://hgko1207.github.io/2023/05/13/nest-5/","excerpt":"","text":"Mapped types CRUD(Create/Read/Update/Delete)와 같은 기능을 구축할 때 기본 엔터티 클래스를 기능에 맞게 변형하는 것이 필요한 경우가 많습니다. Nest는 이 작업을 보다 편리하게 만들기 위해 클래스 변환을 수행하는 여러 유틸리티 기능을 제공합니다. Partial input validation types(DTO라고도 함)을 빌드할 때 동일한 클래스에 대한 create 및 update 클래스로 변형하는 것이 필요한 경우가 많습니다. 예를 들어, create 에는 모든 필드가 필요할 수 있지만 update는 모든 필드를 선택 사항으로 만들 수 있습니다. Nest는 이 작업을 더 쉽게 만들고 보일러플레이트(Boilerplate) 코드를 최소화하기 위해 PartialType() 유틸리티 함수를 제공합니다. PartialType() 함수는 입력 클래스의 모든 속성이 선택 사항으로 설정된 클래스를 반환합니다. 설치 Mapped types 설치를 통해 PartialType을 가져올 수 있습니다. 1npm i @nestjs/mapped-types 사용 예시 이전 글 [NestJS] ValidationPipe 사용 방법 에서 생성한 사용자 등록 DTO 클래스를 이용합니다. 사용자 등록 DTO 클래스의 필드들은 모두 필수 항목입니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 DTO 클래스와 동일한 필드를 가지지만 각 필드가 선택 사항인 사용자 수정 DTO 클래스를 생성하려면 PartialType() 함수를 상속받고 사용자 등록 DTO 클래스인 CreateUserDto를 인수로 전달합니다. 12345// update-user.dto.tsimport &#123; PartialType &#125; from '@nestjs/mapped-types';import &#123; CreateUserDto &#125; from './create-user.dto';export class UpdateUserDto extends PartialType(CreateUserDto) &#123;&#125; 사용자 수정 요청을 받기 위해 컨트롤러 클래스를 생성합니다. update 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Patch &#125; from '@nestjs/common';import &#123; UpdateUserDto &#125; from './dto/update-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 수정 * @param userData * @returns */ @Patch() update(@Body() userData: UpdateUserDto) &#123; return '사용자 수정 성공'; &#125;&#125; 사용자 수정 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 PATCH 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12// 서버에서 응답사용자 수정 성공 사용자 등록과 달리 모든 필드가 선택 사항으로 설정되어 있어 요청할 때 속성들을 입력하지 않아도 잘 동작하는 것을 확인할 수 있습니다. 참고 https://docs.nestjs.com/openapi/mapped-types#partial https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"}]},{"title":"[NestJS] ValidationPipe 사용 방법","slug":"nest-4","date":"2023-05-11T03:10:18.000Z","updated":"2024-01-12T07:20:45.231Z","comments":true,"path":"2023/05/11/nest-4/","link":"","permalink":"http://hgko1207.github.io/2023/05/11/nest-4/","excerpt":"","text":"Validation 웹 애플리케이션으로 전송되는 데이터의 검증을 도와줍니다. 들어오는 요청을 자동으로 검증하기 위해 Nest는 즉시 사용할 수 있는 여러 파이프를 제공합니다. ValidationPipe ValidationPipe는 강력한 클래스 유효성 검사기 패키지와 선언적 유효성 검사 데코레이터를 사용합니다. ValidationPipe는 들어오는 모든 클라이언트 페이로드에 대해 유효성 검사 규칙을 적용하는 편리한 접근 방식을 제공합니다. ValidationPipe 사용을 위한 class-validator, class-transformer 패키지를 설치합니다. 1npm i --save class-validator class-transformer 사용 예시 ValidationPipe 를 사용하기 위해 main.ts 파일에 다음과 같이 추가합니다. 123456789101112// main.tsimport &#123; NestFactory &#125; from '@nestjs/core';import &#123; AppModule &#125; from './app.module';import &#123; ValidationPipe &#125; from '@nestjs/common';async function bootstrap() &#123; const app = await NestFactory.create(AppModule); // ValidationPipe 추가 app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);&#125;bootstrap(); 유효성 검사를 위해 사용자 등록을 예시로 작성했습니다. 먼저 사용자 등록을 위한 DTO(Data Transfer Object) 클래스를 생성합니다. 그리고 validation decorator(IsString, IsNumber 등)를 유효성 검사하기 위한 필드에 추가합니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 요청을 받기 위해 컨트롤러 클래스를 생성합니다. create 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Post &#125; from '@nestjs/common';import &#123; CreateUserDto &#125; from './dto/create-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 등록 * @param userData * @returns */ @Post() create(@Body() userData: CreateUserDto) &#123; return '사용자 등록 성공!!'; &#125;&#125; 사용자 등록 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 POST 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12345678910// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [ \"name must be a string\", \"age must be a number conforming to the specified constraints\", \"each value in hobbies must be a string\" ], \"error\": \"Bad Request\"&#125; 요청하는 데이터가 “name”, “age”, “hobbies” 필드가 존재하지 않으므로 예외를 응답합니다. 즉, ValidationPipe를 사용하면 모든 엔드포인트가 잘못된 데이터를 수신하지 못하도록 보호됩니다. 간단한 설정만으로 유효성 체크를 할 수 있습니다. 옵션 whitelist whitelist: true로 설정하면 유효성 검사기는 class-validator의 유효성 검사 데코레이터를 적어도 하나라도 사용하지 않은 모든 속성 객체를 제거합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, &#125;)); forbidNonWhitelisted forbidNonWhitelisted: true로 설정하면 화이트리스트에 없는 속성을 제거하는 대신 유효성 검사기가 예외를 발생합니다. 123456app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, forbidNonWhitelisted: true, &#125;)); whitelist 와 forbidNonWhitelisted 옵션을 true로 설정하면 &quot;height&quot;이라는 속성은 화이트리스트에 존재하지 않으므로 HttpException을 응답합니다. 1234567// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"name\": \"hgko\", \"age\": 35, \"hobbies\": [\"soccer\"], \"height\": 180&#125; 123456// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [\"property height should not exist\"], \"error\": \"Bad Request\"&#125; transform (자동 형변환) 네트워크를 통해 들어오는 payload는 일반 JavaScript 객체입니다. ValidationPipe는 payload를 DTO 클래스에 따라 유형이 지정된 객체로 자동 변환할 수 있습니다. 자동 변환을 활성화하려면 transform을 true로 설정하십시오. 이 동작을 전역적으로 활성화하려면 전역 파이프에서 옵션을 설정합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; transform: true, &#125;)); 참고 https://docs.nestjs.com/techniques/validation https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"}]},{"title":"[NestJS] Param decorators","slug":"nest-3","date":"2023-05-10T03:05:36.000Z","updated":"2024-01-12T07:19:33.891Z","comments":true,"path":"2023/05/10/nest-3/","link":"","permalink":"http://hgko1207.github.io/2023/05/10/nest-3/","excerpt":"","text":"Param decorators Nest는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 매개변수 데코레이터 세트를 제공합니다. 다음은 제공된 데코레이터와 이들이 나타내는 일반 Express(또는 Fastify) 객체의 목록과 사용 예시입니다. @Param Param은 Path Variable 을 받아올 때 사용합니다. (예, /users/123) 12345// NestJS@Param(param?: string)// ExpressJSreq.params / req.params[param] 123456789import &#123; Controller, Get, Param &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('/:id') getOne(@Param('id') userId: string) &#123; return `This will return one user with the id: $&#123;userId&#125;`; &#125;&#125; @Body Body는 JSON 형식으로 받아올 때 사용합니다. 12345// NestJS@Body(param?: string)// ExpressJSreq.body / req.body[param] 1234567891011121314151617import &#123; Body, Controller, Param, Patch, Post &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Post() create(@Body() userData) &#123; return userData; &#125; @Patch('/:id') update(@Param('id') userId: string, @Body() updateData) &#123; return &#123; updateData: userId, ...updateData, &#125;; &#125;&#125; @Query Query는 Query Parameter를 받아올 때 사용합니다. (예, /users?id=123) 12345// NestJS@Query(param?: string)// ExpressJSreq.query / req.query[param] 123456789import &#123; Controller, Get, Query &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('search') search(@Query('id') userId: string) &#123; return `We are searching for a user made after: $&#123;userId&#125;`; &#125;&#125; 참고 https://docs.nestjs.com/custom-decorators#param-decorators","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"}]},{"title":"[NestJS] Controller, Provider, Module 이란?","slug":"nest-2","date":"2023-05-08T02:40:07.000Z","updated":"2024-01-12T07:18:58.542Z","comments":true,"path":"2023/05/08/nest-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-2/","excerpt":"","text":"NestJS에서 사용하는 Controller, Provider, Module에 대한 간략한 내용을 정리하였습니다. Controllers 컨트롤러는 들어오는 요청을 처리하고 클라이언트에 응답을 반환하는 역할을 합니다. express의 라우터 같은 역할을 합니다. 1234567891011121314151617import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125; @Get('/hello') sayHello(): string &#123; return 'Hello everyone'; &#125;&#125; @Controller(): express의 app.use('/', router) 에서 '/'와 같은 역할을 합니다. @Controller('req') 이렇게 인자로 string을 넘겨주면 express에서 app.use('/req', router) 처럼 코드를 작성한 것과 같습니다. @Get(): Route 핸들러(메서드) 데코레이터입니다. HTTP GET 요청을 지정된 경로로 라우팅 합니다. @Get('hello') 이렇게 인자로 string을 넘겨주면 express 에서 router.get('/hello', sayHello) 처럼 코드를 작성한 것과 같습니다. Providers Provider는 Nest의 기본 개념입니다. 대부분의 기본 Nest Class 인 services, repositories, factories, helpers 등은 provider로 취급될 수 있습니다. provider는 단순히 @Injectable() 데코레이터가 달린 클래스입니다. 12345678import &#123; Injectable &#125; from '@nestjs/common';@Injectable()export class AppService &#123; getHello(): string &#123; return 'Hello World!'; &#125;&#125; provider 의 주요 아이디어는 의존성을 주입할 수 있다는 것입니다. 즉, 개체가 서로 다양한 관계를 만들 수 있으며 개체 인스턴스를 &quot;연결&quot;하는 기능은 대부분 Nest 런타임 시스템에 위임할 수 있습니다. 123456789101112import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125;&#125; 위의 AppController 생성자에 변수의 타입을 AppService 로 지정해 줌으로써 Nest Injector 가 appService 변수를 AppService의 인스턴스로 만들어줍니다(인스턴스화한다). Modules NestJS 에는 모듈이 있습니다. @Module() 데코레이터로 모듈을 만들 수 있습니다. Nest 어플리케이션을 만들면 최소 하나의 모듈, 루트 모듈(AppModule)이 있습니다. 이 루트 모듈은 Nest가 Module 및 Provider 관계와 의존성을 해결하는 데 사용하는 내부 데이터 구조를 구축하는 시작점입니다. 모듈을 만들면 루트 모듈과 연결되어야 합니다. 12345678910import &#123; Module &#125; from '@nestjs/common';import &#123; AppController &#125; from './app.controller';import &#123; AppService &#125; from './app.service';@Module(&#123; imports: [], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; @Module() 데코레이터는 하나의 객체를 인자로 가지며, 객체가 가질 수 있는 프로퍼티는 다음과 같습니다. providers: Nest injector에 의해 인스턴스화되고, 인스턴스들은 모듈 안에서 최소한으로 공유됩니다. controllers: 해당 모듈에서 정의된, 인스턴스화되어야 하는 Controller의 집합입니다. imports: 임포트 된 모듈들의 리스트입니다. 이 리스트의 모듈들은 데코레이터에 사용 중인 모듈에서 필요한 providers를 export 하고 있어야 합니다. exports: providers의 하위 집합으로, 데코레이터를 사용 중인 모듈이 제공받은 Provider의 일부를 내보낼 수 있습니다. 이는 다른 모듈에서 import 할 때 사용됩니다. 파일 생성 Module 생성 1nest g mo module-name Controller 생성 1nest g co controller-name Service 생성 1nest g s service-name Provider 생성 1nest g pr provider-name 참고 https://docs.nestjs.com/controllers#controllers https://docs.nestjs.com/controllers#routing https://docs.nestjs.com/providers#providers https://docs.nestjs.com/modules#modules","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"}]},{"title":"[NestJS] 설치 및 프로젝트 생성","slug":"nest-1","date":"2023-05-08T02:22:59.000Z","updated":"2024-01-12T07:17:27.853Z","comments":true,"path":"2023/05/08/nest-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-1/","excerpt":"","text":"설치 Nest CLI를 사용하면 새 프로젝트를 설정하는 것이 매우 간단합니다. npm이 설치된 상태에서 터미널에서 다음 명령을 사용하여 Nest CLI를 설치합니다. 1npm i -g @nestjs/cli 프로젝트 생성 nest new 명령어로 새 Nest 프로젝트를 만들 수 있습니다. 1nest new project-name nest new로 프로젝트 생성이 안된다면 npx nest new로 진행합니다. 예시로 프로젝트를 생성해 보겠습니다. 1234567D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? (Use arrow keys)&gt; npm yarn pnpm 기본적으로 npm을 선택합니다. 123456789101112131415161718192021222324252627282930313233D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? npmCREATE test-nestjs/.eslintrc.js (663 bytes)CREATE test-nestjs/.prettierrc (51 bytes)CREATE test-nestjs/nest-cli.json (171 bytes)CREATE test-nestjs/package.json (1942 bytes)CREATE test-nestjs/README.md (3340 bytes)CREATE test-nestjs/tsconfig.build.json (97 bytes)CREATE test-nestjs/tsconfig.json (546 bytes)CREATE test-nestjs/src/app.controller.spec.ts (617 bytes)CREATE test-nestjs/src/app.controller.ts (274 bytes)CREATE test-nestjs/src/app.module.ts (249 bytes)CREATE test-nestjs/src/app.service.ts (142 bytes)CREATE test-nestjs/src/main.ts (208 bytes)CREATE test-nestjs/test/app.e2e-spec.ts (630 bytes)CREATE test-nestjs/test/jest-e2e.json (183 bytes)✔ Installation in progress... ☕🚀 Successfully created project test-nestjs👉 Get started with the following commands:$ cd test-nestjs$ npm run start Thanks for installing Nest 🙏 Please consider donating to our open collective to help us maintain this package. 🍷 Donate: https://opencollective.com/nest 프로젝트에 필요한 파일과 폴더를 생성하고, 패키지들을 설치합니다. Nest CLI를 사용하면 직접 파일을 만들 필요 없어 편리합니다. 프로젝트 시작 파일의 변경 사항을 감시하려면 다음 명령를 실행하여 프로젝트를 시작할 수 있습니다. 이 명령은 파일을 감시하여 자동으로 서버를 다시 컴파일하고 다시 로드합니다. 1npm run start:dev http://localhost:3000/ 주소로 접속해서 정상적으로 시작됐는지 확인합니다. 참고 https://docs.nestjs.com/first-steps","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"}]},{"title":"[Git] detached HEAD 문제 해결 방법","slug":"git-1","date":"2023-05-04T06:22:00.000Z","updated":"2024-01-12T07:16:53.877Z","comments":true,"path":"2023/05/04/git-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/04/git-1/","excerpt":"","text":"git을 사용할 때 add와 commit 까진 실행이 잘 되는데 다음과 같이 detached HEAD 문제로 push 가 안 될 때 해결 방법을 정리하였습니다. 123456D:\\project\\Study\\react&gt; git pushfatal: You are not currently on a branch.To push the history leading to the current (detached HEAD)state now, use git push origin HEAD:&lt;name-of-remote-branch&gt; Detached Head 란, 말 그대로 head가 (branch로부터) 떨어져 있는 상태를 뜻한다. 즉, branch 를 통해서가 아니라 직접 다이렉트로 commit을 참조하고 있는 상태를 뜻한다. git branch 명령어를 사용하여 살펴보니 지금 현재 브랜치는 HEAD detached from bdcfe3d8 로 설정되어 있습니다. 123D:\\project\\Study\\react&gt; git branch -a* (HEAD detached from 537d4a3) master 해결 방법 임시로 새로운 브랜치를 만들어 main 브랜치와 병합하여 해결하는 방법입니다. 브랜치 생성 현재 Head 분기를 참조하게끔 임시 브랜치를 생성합니다. 12git branch tempgit checkout temp 또는 12# -b 명령어 사용git checkout -b temp 이렇게 하면 temp 라는 브랜치가 만들어지고, temp로 checkout을 하게 됩니다. master 브랜치로 이동 1git checkout master 병합 새로운 브랜치와 master 브랜치를 병합합니다. 1git merge temp 새로운 브랜치 삭제 임시로 만든 temp 라는 브랜치를 삭제합니다. 1git branch -d temp push 마지막으로 push 를 실행하면 됩니다. 1git push push를 실행했을 때 다음과 같이 내용이 보이면 git push --set-upstream origin master 명령어를 사용해서 기본 브랜치를 설정합니다. 12345678D:\\project\\Study\\react&gt; git pushfatal: The current branch master has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin masterTo have this happen automatically for branches without a trackingupstream, see 'push.autoSetupRemote' in 'git help config'.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"}]},{"title":"Chocolatey를 이용한 Flutter 설치 방법","slug":"flutter-1","date":"2023-04-25T01:58:13.000Z","updated":"2024-01-12T07:15:39.242Z","comments":true,"path":"2023/04/25/flutter-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/25/flutter-1/","excerpt":"","text":"윈도우 환경에서 Chocolatey를 이용해서 Flutter를 설치하고 안드로이드 기기와 연결하는 방법에 대해 알아보겠습니다. 1. Chocolatey 설치 이전 글 **Chocolatey 설치**를 참고해서 Chocolatey를 먼저 설치를 합니다. 2. Flutter 설치 관리자 권한으로 PowerShell 을 열고 다음 명령어를 실행하여 설치를 합니다. 1choco install flutter 설치가 완료되면 flutter 명령어를 실행하였을 때 다음과 같이 메시지가 나옵니다. 12345678910111213C:\\Windows\\system32&gt; flutterCommon commands: flutter create &lt;output directory&gt; Create a new Flutter project in the specified directory. flutter run [options] Run your Flutter application on an attached device or in an emulator....Run \"flutter help &lt;command&gt;\" for more information about a command.Run \"flutter help -v\" for verbose help output, including less commonly used options. 3. 안드로이드 연결 안드로이드 앱을 개발하려고 한다면 Android setup 사이트에 접속해서 가이드대로 Android 에뮬레이터를 설치하고 연결하면 됩니다. 설치 방법은 아래 기술하였습니다. 1) Android Studio 설치 https://developer.android.com/studio 사이트에 접속해서 Android Studio 를 다운로드합니다. 다운로드가 완료되면 설치를 진행합니다. 2) Android SDK 빌드 도구 설치 Android Studio 를 시작하고 **‘Android Studio Setup Wizard’**를 진행합니다. 이렇게 하면 Android 용으로 개발할 때 Flutter에 필요한 최신 Android SDK, Android SDK Command-line Tools 및 Android SDK Build-Tools 가 설치됩니다. PowerShell에서 flutter doctor 명령어를 실행해서 Flutter 가 설치된 Android Studio를 찾았는지 확인합니다. 1234567891011121314151617C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[!] Android toolchain - develop for Android devices (Android SDK version 33.0.2) X cmdline-tools component is missing Run `path/to/sdkmanager --install \"cmdline-tools;latest\"` See https://developer.android.com/studio/command-line for more details. X Android license status unknown. Run `flutter doctor --android-licenses` to accept the SDK licenses. See https://flutter.dev/docs/get-started/install/windows#android-setup for more details.[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (3 available)[√] Network resources 3) Android 에뮬레이터 설정 Android 에뮬레이터에서 Flutter 앱을 실행하고 테스트할 준비를 하려면 다음 단계를 진행합니다. Machine에서 VM acceleration를 활성화합니다. Android Studio를 실행하고 Tools &gt; Device Manager 메뉴를 클릭하거나 Device Manager 아이콘을 클릭한 다음 Virtual 탭 에서 Create Device를 선택합니다. 이전 버전의 Android Studio에서는 대신 Android Studio &gt; Tools &gt; Android &gt; AVD Manager를 실행하고 Create Virtual Device를 선택해야 합니다. (Android 하위 메뉴는 Android 프로젝트 내부에만 있습니다.) 열려 있는 프로젝트가 없으면 점 3개 Menu / More Actions &gt; Virtual Device Manager 메뉴를 클릭한 다음 Create Device 를 선택할 수 있습니다. Visual Device Configuration 창에서 장치를 선택하고 Next 버튼을 클릭합니다. (저는 Pixel 3 XL 모델을 선택했습니다.) 에뮬레이션 하려는 Android 버전의 시스템 이미지를 하나 이상 선택하고 Next 버튼을 클릭합니다. x86 또는 x86_64 이미지를 권장합니다. Verify Configuration에서 하단에 Emulated Performance에서 Graphics 를 Hardware-GLES 2.0으로 선택 후 Finish 버튼을 클릭하여 하드웨어 가속을 활성화합니다. Android Virtual Device Manager의 도구 모음에서 실행(▶)을 클릭합니다. 에뮬레이터가 시작되고 선택한 OS 버전 및 장치에 대한 기본 캔버스를 표시합니다. 4) Android 라이선스에 동의 Flutter를 사용하려면 먼저 Android SDK 플랫폼의 라이선스에 동의해야 합니다. 이 단계는 위에 나열된 도구를 설치한 후에 수행해야 합니다. 자바 8 버전 이상이 설치되어 있고 JDK의 폴더가 환경 변수 설정되어 있는지 확인합니다. PowerShell 또는 명령 프롬프트에서 다음 명령어를 실행하여 라이언스 서명을 시작합니다. 1flutter doctor --android-licenses 에러 발생 해결 방법 123C:\\WINDOWS\\system32&gt; flutter doctor --android-licensesAndroid sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed toresolve this. 만약 cmdline-tools 가 없으므로 설치하라는 빨간 메시지가 출력된다면 다음의 절차를 진행합니다. Android Studio에서 SDK Manager를 실행합니다. 좌측의 System Settings 에서 Android SDK 를 선택하고 우측 화면에서 SDK Tools 탭을 선택합니다. Android SDK Command-line Tools(latest) 를 체크한 후 OK 버튼을 클릭해 설치를 진행합니다. 설치가 완료되었다면 Finish 를 클릭하고 flutter doctor --android-licenses 명령어를 다시 입력합니다. 이때 동의에 대해 묻는데 y 입력해주시면 됩니다. All SDK package licenses accepted 메시지가 출력 되면 라이센스 동의가 끝났습니다. 1234C:\\WINDOWS\\system32&gt; flutter doctor --android-licenses...Accept? (y/N): yAll SDK package licenses accepted 5) 확인 라이선스 동의가 완료되면 flutter doctor 명령어를 다시 입력하여 Flutter 를 사용할 준비가 되었는지 확인합니다. 1234567891011C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[√] Android toolchain - develop for Android devices (Android SDK version 33.0.2)[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (4 available)[√] Network resources 에러 발생 해결 방법 flutter doctor 명령어를 실행하였을 때 Windows 10 SDK 이 없다고 하는 메시지가 출력될 경우 해결 방법입니다. https://visualstudio.microsoft.com/ko/downloads/ 사이트에서 Visual Studio 2022 버전의 무료 다운로드를 클릭하여 다운로드하고 설치해줍니다. Visual Studio Installer 창이 열리면 데스크톱 및 모바일에서 C++를 이용한 데스크톱 개발을 선택 후 설치합니다. 결론 Chocolatey를 사용해서 Flutter를 설치하면 zip 파일을 다운로드하고, 열어서 설치하고, path 설정하고, 여러 가지 설정하는 것보다 훨씬 쉬운 방법입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"}]},{"title":"[Dart] 클래스(Class) 사용 방법","slug":"dart-6","date":"2023-04-18T04:55:52.000Z","updated":"2024-01-12T07:12:44.322Z","comments":true,"path":"2023/04/18/dart-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/18/dart-6/","excerpt":"","text":"Dart에서 클래스(Class) 사용 방법에 대해 알아보겠습니다. Class 클래스 안에서 property를 선언할 때는 타입을 사용해서 정의합니다. 1234567891011121314class Player &#123; final String name = 'eden'; final int age = 3; void sayName() &#123; print(\"Hi my name is $name\"); &#125;&#125;void main() &#123; // new 를 꼭 붙이지 않아도 됩니다. var player = Player(); player.sayName();&#125; 클래스 메서드 안에서는 this 를 붙이지 않는 것을 Dart에서는 권장하나, 어쩔 수 없이 같은 변수명이 있을 때는 this를 붙여서 사용해야 합니다. Constructor 생성자(constructor) 함수는 클래스 이름과 같아야 합니다. 123456789101112131415class Player &#123; // late 사용 late final String name; late final int age; Player(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;void main() &#123; // Player 클래스의 인스턴스 생성 var player = Player(\"eden\", 3);&#125; 위의 생성자 함수는 다음과 같이 줄일 수 있습니다. 1234567class Player &#123; // late 사용 안함 final String name; final int age; Player(this.name, this.age);&#125; 위의 코드는 late 를 사용하였지만 아래 코드에서 사용하지 않은 이유는 생성자 함수를 만들 때 변수에 값을 할당하지 않았기 때문입니다. 이전 생성자 함수를 만들 때에는 this.name = name; 식으로 값을 할당했기 때문에 먼저 선언한 변수에 late 를 붙여야 오류가 발생하지 않습니다. Named Constructor Parameters 클래스가 거대해질 경우 다음과 같이 생성자 함수를 만드는 것은 비효율적일 것입니다. 많은 파라미터를 받아야 하고 각 파라미터의 의미를 알 수가 없습니다. 123456789101112class Team &#123; final String name; int members; int ranking; String description; Team(this.name, this.members, this.ranking, this.description);&#125;void main() &#123; var team = Team(\"Tottenham\", 25, 5, \"Tottenham Hotspur Football Club\");&#125; 문제를 해결하려면 너무 간단합니다. 생성자 함수 생성할 때 중괄호({})를 사용하는 것입니다. 그리고 클래스를 정의할 때 Named Paramaters를 사용합니다. 12345678910111213141516class Team &#123; final String name; int members; int ranking; String description; Team(&#123;this.name, this.members, this.ranking, this.description&#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; 하지만 여기에는 큰 문제가 있습니다. 변수가 null 일 수도 있기 때문에 기본 값(default value)을 주거나 required 파라미터 앞에 붙여 사용합니다. 다음의 코드는 required를 사용하였습니다. 123456789101112131415161718192021class Team &#123; final String name; int members; int ranking; String description; Team(&#123; required this.name, required this.members, required this.ranking, required this.description &#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; Named Constructor 콜론(:)을 사용하면 특별한 생성자 함수를 만들 수 있습니다. 콜론을 넣음으로써 dart에게 객체를 초기화하라고 명령할 수 있습니다. 12345678910111213141516171819class Team &#123; String name; int members; String description; Team(&#123;required this.name, required this.members, required this.description&#125;); Team.createTeam(&#123;required String name, required int members&#125;) : this.name = name, this.members = members, this.description = \"$name team is good.\";&#125;void main() &#123; var team = Team.createTeam( name: \"Tottenham\", members: 25, );&#125; Enum Enum 은 우리가 코드를 작성할 때 실수를 하지 않게 도와줍니다. enum type 의 변수들은 해당 enum type에 생성된 값들 중에서만 값이 할당될 수 있습니다. 123456789101112enum Team &#123; red, blue &#125;class Player &#123; String name; Team team; Player(&#123;required this.name, required this.team&#125;);&#125;void main() &#123; var player = Player(name: 'eden', team: Team.red);&#125; Abstract Class 추상 클래스는 다른 클래스들이 직접 구현해야 하는 필드와 메서드들을 모아놓은 클래스입니다. 추상 클래스는 아직 메소드와 내용이 추상적이므로 객체를 생성할 수 없습니다. 추상 클래스를 상속받는 클래스들은 추상 클래스의 메서드들을 구현해야 합니다. 12345678910111213141516171819abstract class Person &#123; void walk();&#125;class Player extends Person &#123; String name; String team; Player(&#123;required this.name, required this.team&#125;); void walk() &#123; print(\"Player is walking\"); &#125;&#125;void main() &#123; var player = Player(name: 'eden', team: 'red'); player.walk();&#125; Mixin Mixin은 생성자가 없는 클래스를 의미합니다. Mixin은 클래스에 코드를 재사용하기 위해 사용되며, 다중 상속의 일부 단점을 보완합니다. Mixin은 extends가 아닌 with 키워드를 사용하여 클래스에 적용합니다. 1234567891011121314151617181920212223242526mixin Strong &#123; final double strengthLevel = 100.5;&#125;mixin Tall &#123; final double height = 180;&#125;mixin QuickRunner &#123; void run() &#123; print(\"run!!\"); &#125;&#125;class Player with Strong, Tall, QuickRunner &#123; final String name; Player(&#123;required this.name&#125;);&#125;void main() &#123; var player = Player( name: \"eden\", ); player.run(); // run!! 출력&#125; 상속과 Mixin 의 차이점 extends를 사용하여 상속받은 클래스는 자식 클래스, 상속한 클래스는 부모클래스가 되는 것이고, 자식 클래스는 부모 클래스를 super 를 통해서 접근할 수 있습니다. Mixin with 라는 키워드를 통해서 단순히 Mixin 내부의 프로퍼티와 메서드들을 가져오는 것뿐입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"}]},{"title":"[Dart] 함수(Function) 사용 방법","slug":"dart-5","date":"2023-04-17T05:57:34.000Z","updated":"2024-01-12T07:11:12.996Z","comments":true,"path":"2023/04/17/dart-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-5/","excerpt":"","text":"Dart에서 함수(Function) 사용 방법에 대해 알아보겠습니다. Functions Dart는 진정한 객체 지향 언어이므로 함수도 객체이며 타입이 Function입니다. 이는 함수를 변수에 할당하거나 다른 함수에 인수로 전달할 수 있음을 의미합니다. 12345678// 하나의 표현식만 포함하는 함수의 경우 아래와 같이 단축 구문을 사용할 수 있습니다.String sayHello(String name) =&gt; \"Hello $&#123;name&#125; nice to meet you!\";num plus(num a, num b) =&gt; a + b;void main() &#123; print(sayHello(\"eden\")); // Hello eden nice to meet you!&#125; Positional Paramaters 함수을 호출할 때 필요한 매개변수와 매개변수의 위치를 정확하게 알아야 합니다. 함수의 매개변수가 많아질수록 함수 호출할 때 다 기억해야 하므로 사용하기 어렵습니다. 1234567String sayHello(String name, int age, String country) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello('eden', 30, 'Korea'));&#125; Named Paramaters 위의 Positional Paramaters 방식은 함수를 호출할 때 사용자가 요소들의 순서를 잊어버릴 수도 있고, 코드를 봤을 때 인자가 뜻하는 것이 무엇인지 바로 이해를 못 할 수도 있습니다. 이 문제를 해결하기 위해 Dart 에서는 Named Paramaters를 지원합니다. 다음과 같이 매개변수 앞뒤로 중괄호를 붙여주면 함수를 호출할 때 매개변수의 이름과 값을 함께 입력할 수 있어 사용자에게 훨씬 편리합니다. 이때 매개변수들의 순서는 지키지 않아도 됩니다. 1234567String sayHello(&#123;String name, int age, String country&#125;) &#123; return \"$&#123;name&#125; / $&#123;age&#125; / $&#123;country&#125;\";&#125;void main() &#123; print(sayHello(name: \"eden\", age: 30, country: \"Korea\"));&#125; 하지만 여기서 또 문제가 발생합니다. Dart는 null safety가 적용되는데, 매개변수 중 하나가 null 일 수도 있기 때문입니다. 다시 말해, 사용자가 name과 age, country 3개의 매개변수 중 하나라도 빼고 보낼 수 있습니다. 이때는 두 가지 옵션이 있습니다. default value 1234567891011String sayHello(&#123; String name = 'ko', int age = 99, String country = 'Italy',&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello());&#125; 함수를 호출할 때 아무것도 전달하지 않아도 default value가 이미 있으므로 null safety에 걸릴 일이 없습니다. required 다음과 같이 매개변수 앞에 required를 적어주면, 함수가 호출될 때 반드시 required가 적힌 매개변수가 포함되어야 한다는 것입니다. 123456789101112String sayHello(&#123; required String name, required int age, required String country&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(🚫sayHello()); // name, country, age가 모두 포함되어야 하기 때문에 dart에서 컴파일하지 않음&#125; Optional Positional Paramaters Dart에서 []은 optional, positional parameter를 명시할 때 사용됩니다. name, age 는 필수값이고 []를 통해 country를 optional 값으로 지정해 줄 수 있습니다. 12345678String sayHello(String name, int age, [String? country = \"Korea\"]) &#123; return 'Hello $&#123;name&#125;, You are $&#123;age&#125; from the $&#123;country&#125;';&#125;void main() &#123; var result = sayHello(\"eden\", 3); print(result); // Hello eden, You are 3 from the Korea&#125; QQ Operator ?? 연산자를 이용하면 왼쪽 값이 null 인지 체크해서 null 이 아니면 왼쪽 값을 리턴하고 null 이면 오른쪽 값을 리턴합니다. 12345678String capitalizeName(String? name) &#123; return name?.toUpperCase() ?? \"NONE\";&#125;void main() &#123; print(capitalizeName(\"eden\")); // EDEN; print(capitalizeName(null)); // NONE&#125; 위의 코드를 더욱 간략하게 만들 수 있습니다. 1String capitalizeName(String? name) =&gt; name?.toUpperCase() ?? \"NONE\"; ??= 연산자를 이용하면 변수 안에 값이 null 일 때를 체크해서 값을 할당해줄 수 있습니다. 1234567void main() &#123; String? name; name ??= \"eden\"; name = null; name ??= \"ko\"; print(name); // ko&#125; TypeDef 자료형에 사용자가 원하는 alias 를 붙일 수 있게 해 줍니다. (자료형 이름의 별명을 만들 때 사용) 12345// 사용 전List reverseListOfNumbers(List list) &#123; var reversed = list.reversed; return reversed.toList();&#125; 1234567891011// 사용 후typedef ListOfInts = List;ListOfInts reverseListOfNumbers(ListOfInts list) &#123; var reversedList = list.reversed.toList(); return reversedList;&#125;void main() &#123; print(reverseListOfNumbers([1, 2, 3])); // [3, 2, 1]&#125; 참고 https://dart.dev/guides/language/language-tour#functions https://dart.dev/guides/language/language-tour#parameters https://dart.dev/guides/language/language-tour#typedefs","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"}]},{"title":"[Dart] Data Types","slug":"dart-4","date":"2023-04-17T05:07:53.000Z","updated":"2024-01-12T07:09:13.930Z","comments":true,"path":"2023/04/17/dart-4/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-4/","excerpt":"","text":"Dart에서 데이터 타입 사용 방법에 대해 알아보겠습니다. 기본 데이터 타입 Dart에는 대표적으로 String, bool, int, double, num 타입이 있습니다. 중요한 점은 이 모든 게 객체(object)라는 것입니다. Dart가 진정한 객체 지향 언어로 불리는 이유입니다. 12345678void main() &#123; String name = \"eden\"; bool isPlay = true; int age = 3; double money = 59.99; num x = 12; num y = 1.2;&#125; String Interpoldation String Interpoldation은 텍스트에 변수를 추가하는 방법입니다. 단순히 변수의 값을 넣고 싶다면 $달러 기호 뒤에 사용할 변수를 적어주면 됩니다. 변수의 값을 계산하고 싶다면 $와 함께 중괄호(`${ })내에 계산할 내용을 적어주면 됩니다. 123456void main() &#123; var name = \"eden\"; var age = 3; var greeting = \"hello $name, I'm $&#123;age + 5&#125; years old.\"; print(greeting);&#125; Lists Dart에서 List를 선언하는 것은 두 가지 방법이 있습니다. 123456void main() &#123; List&lt;int&gt; numbers = [1, 2, 3]; numbers.add(4); var number2 = [4, 5, 6];&#125; Dart에서 List의 유용한 점은 collection if와 collection for를 지원합니다. collection if collection if는 List를 만들 때, if를 통해 존재할 수도 안 할 수도 있는 요소를 가지고 만들 수 있습니다. 1234567891011void main() &#123; var giveMeFive = true; var item = [ 1, 2, 3, 4, if (giveMeFive) 5, // giveMeFive가 true이면 5가 추가됨 ]; print(item);&#125; Collection For Dart에서는 반복(for)을 사용하여 컬렉션을 구축하는 데 사용할 수 있는 Collection for를 제공합니다. 12345678910void main() &#123; var oldFriends = [\"ko\", \"lee\"]; var newFriends = [ \"eden\", \"woorim\", for (var friend in oldFriends) \"🥰 $friend\" ]; print(newFriends); // [eden, woorim, 🥰 ko, 🥰 lee]&#125; Maps 일반적으로 Map은 key와 value를 연결하는 객체입니다. 키와 값 모두 모든 유형의 객체가 될 수 있습니다. 각 키는 한 번만 발생하지만 동일한 값을 여러 번 사용할 수 있습니다. Map을 정의하는 방법은 두 가지가 있습니다. 첫 번째는 var 를 이용한 방법입니다. 두 번째는 var 대신 Map 을 사용하고, 자료형을 명시하는 것입니다. 1234567891011121314// 첫 번째var gifts = &#123; // Key: Value 'first': 'smartphone', 'second': 'laptop', 'third': 'bicycle'&#125;;// 두 번째Map players = &#123; 1 : true, 2 : false, 3 : true,&#125;; 12345// Map 생성자를 사용하여 동일한 객체를 만들 수 있습니다.var gifts = Map();gifts['first'] = 'smartphone';gifts['second'] = 'laptop';gifts['third'] = 'bicycle'; Sets Set에 속한 모든 아이템들이 유니크해야 될 때 사용합니다. 유니크할 필요가 없다면 List를 사용하면 됩니다. Set도 두 가지 방법으로 정의할 수 있습니다. 12345678910void main() &#123; var numbers1 = &#123;1, 2, 3&#125;; Set numbers2 = &#123;1, 2, 3&#125;; Set&lt;int&gt; numbers3 = &#123;1, 2, 3&#125;; numbers3.add(1); numbers3.add(2); numbers3.add(4); print(numbers3) // &#123;1, 2, 3, 4&#125;&#125; List는 대괄호를 쓰며 Set은 중괄호를 쓴다는 점이 다릅니다. List는 같은 요소가 여러 개 반복될 수 있지만, Set은 중복이 허용되지 않습니다. 참고 https://dart.dev/guides/language/language-tour#collection-operators https://dart.dev/guides/language/language-tour#maps https://dart.dev/guides/language/language-tour#sets","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"}]},{"title":"[Dart] Null Safety","slug":"dart-3","date":"2023-04-14T05:10:05.000Z","updated":"2024-01-12T07:07:10.075Z","comments":true,"path":"2023/04/14/dart-3/","link":"","permalink":"http://hgko1207.github.io/2023/04/14/dart-3/","excerpt":"","text":"Null Safety는 개발자가 null 값을 참조할 수 없게 하는 것입니다. 다음 코드를 봅시다. 123456bool isEmpty(String string) =&gt; string.length == 0;main()&#123; // [오류] isEmpty(🚫null);&#125; 다음과 같은 코드는 어떻게 실행될까요? 정답은 NoSuchMethodError를 실행합니다. 왜 이렇게 실행될까요? 바로 String을 보내야 할 곳에 null을 보냈기 때문입니다. null 에는 length 라는 속성이 없기 때문이기도 합니다. 이와 같은 에러는 컴파일러에서 잡을 수 있는 에러가 아닙니다. 이런 상황이 발생하지 않도록 null 를 삭제하기에는 null 값은 유용합니다. 그럼 어떻게 null 값을 참조하는 것을 dart 는 어떻게 보호할까요? dart에서는 변수가 null이 될 수 있음을 명확히 표시해야 합니다. 다음 코드를 봅시다. 1234void main() &#123; String name = \"eden\"; 🚫name = null;&#125; 이 코드는 에러가 납니다. name 이 null 값을 참조할 수 있다고 알려주지 않고 null 값을 참조하기 때문입니다. 그러면 다음 코드를 봅시다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; 이 코드는 에러가 나지 않습니다. 차이점이 뭘까요? 바로 변수 뒤에 ?를 사용해 이 변수에는 null 이 참조될 수 있음을 알려주는 것입니다. 만약 ?를 붙인 변수는 이 변수가 null 인지 아닌지 확인해야 합니다. 12345678void main() &#123; String? name = \"eden\"; name = null; if (name != null) &#123; print(name.length); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"}]},{"title":"[Dart] 변수(Variable) 사용 방법","slug":"dart-2","date":"2023-04-13T02:09:29.000Z","updated":"2024-01-12T07:06:15.658Z","comments":true,"path":"2023/04/13/dart-2/","link":"","permalink":"http://hgko1207.github.io/2023/04/13/dart-2/","excerpt":"","text":"Dart에서 변수 사용 방법에 대해 알아보겠습니다. 변수를 만드는 2가지 방법 dart에서는 변수를 var 키워드 또는 명시적으로 변수의 타입을 지정해서 사용합니다. 다른 타입의 변수는 서로 대입할 수 없습니다. 1234567// 방법 1void main() &#123; var name = \"car\"; name = \"bus\"; // [오류] 🚫 name = 1;&#125; 12345// 방법 2void main() &#123; String name = \"car\"; name = \"bus\";&#125; var를 사용하는 게 dart 스타일가이드의 권장 방식입니다. 함수나 메소드 내부에 지역변수를 선언할 때는 var를 사용하고 class에서 변수나 property를 선언할 때는 타입을 지정해 줍니다. Dynamic 타입 여러 가지 타입을 가질 수 있는 변수에 쓰는 키워드입니다. 변수를 선언할 때 dynamic을 쓰거나 값을 지정하지 않으면 dynamic 타입을 가집니다. 1234void main() &#123; dynamic name; var name2;&#125; 123456void main() &#123; var name; name = 'car'; name = 1; name = true;&#125; dynamic 타입은 언제 사용될까? 해당 변수의 타입을 알 수 없을 때 주로 사용합니다. 예를 들어 json을 작업할 경우입니다. 하지만 dynamic 타입은 다양한 타입을 가질 수 있기 때문에 정말 필요할 때만 사용해야 합니다. (위험 방지) Null Safety null safety는 개발자가 null 값을 참조할 수 없도록 하는 것입니다. String 뒤에 ?를 붙여줌으로써 name 이 String 또는 null 이 될 수 있다고 명시해 준 것입니다. 기본적으로 모든 변수는 non-nullable(null이 될 수 없음)입니다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; final 변수 var 대신 final로 변수를 만들게 되면 이 변수는 수정할 수 없게 됩니다. (딱 한 번만 설정될 수 있음) 자바스크립트의 const 랑 비슷합니다. 1234567void main() &#123; final name = \"pizza\"; 🚫name = \"ham\"; // 수정 불가 final String username = \"eden\"; 🚫name = \"eden2\"; // 수정 불가&#125; late 변수 초기 데이터 없이 먼저 변수를 생성하고 추후에 데이터를 넣을 때 주로 사용합니다. flutter로 data fecthing을 할 때 유용합니다. late 변수를 만들고, API에 요청을 보낸 뒤에 API에서 값을 보내주면 그 응답 값을 late 변수에 넣어 사용할 수 있습니다. 123456789void main() &#123; late final String name; 🚫print(name); // 값을 넣기 전에는 name 변수에 접근 불가 // do something, go to api name = 'api'; // 한번만 할당해 줄 수 있음 🚫name = 'test';&#125; const 변수 dart에서 const는 compile-time constant를 만들어줍니다. const는 컴파일할 때 알고 있는 값을 사용해야 합니다. 만약 어떤 값인지 모르고, 그 값이 API로부터 오거나 사용자가 화면에서 입력해야 하는 값이라면 그건 const가 아닌 final이나 var가 되어야 합니다. 1234567void main() &#123; // 컴파일 시점에 바뀌지 않는 값 const API_KEY = \"********\"; // 컴파일 시점에 바뀌는 값 final API = fetchAPI();&#125; const: 컴파일 시점에 바뀌지 않는 값 (상수) final: 컴파일 시점에 바뀌는 값 (API에서 받아온 값, 사용자 입력값)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"}]},{"title":"[Dart] 시작하기","slug":"dart-1","date":"2023-04-12T01:35:46.000Z","updated":"2024-01-12T07:04:33.093Z","comments":true,"path":"2023/04/12/dart-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/12/dart-1/","excerpt":"","text":"Dart 란 Dart는 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다. UI 최적화용 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발합니다. 생산적인 개발 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인 가능합니다. 모든 플랫폼에서 빠름 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript 로 컴파일합니다. Why Dart Dart 의 컴파일러 기술을 사용하면 다양한 방식으로 코드를 실행할 수 있습니다. 기본 플랫폼(Dart Native): 모바일 및 데스크톱 장치를 대상으로 하는 앱의 경우 Dart에는 JIT(Just-In-Time) 컴파일 기능이 있는 Dart VM과 기계 코드 생성을 위한 AOT(Ahead-of-Time) 컴파일러가 모두 포함되어 있습니다. 웹 플랫폼(Dart Web): 웹을 대상으로 하는 앱의 경우 Dart 는 개발 또는 프로덕션 목적으로 컴파일할 수 있습니다. 웹 컴파일러는 Dart를 JavaScript로 변환합니다. 또 다른 특징 null safety 특성을 가집니다. c 또는 java 에서 null 참조하면 오류가 발생합니다. flutter, dart 둘 다 구글에서 개발한 것입니다. 즉 flutter의 성능 향상을 위해 dart를 최적화할 수 있습니다. flutter가 dart에 대해 뭔가 필요한 게 있으면, flutter를 위해 dart를 수정할 수 있습니다. react-native, django, flask 등 다른 프레임워크들은 사용하는 언어를 수정할 수 없다는 점이 다릅니다. main 함수 main 함수는 모든 Dart 프로그램의 Entry point 입니다. main 함수에서 쓴 코드가 호출됩니다. (만약 main 함수가 없다면 실행이 되지 않음) dart는 자동으로 세미콜론을 붙여주지 않기 때문에 직접 붙여야 합니다. (일부러 세미콜론을 안 쓸 때가 있기 때문입니다.) 123void main() &#123; print(\"hello world\");&#125; Flutter Flutter 프레임워크는 인기 있는 다중 플랫폼 UI 툴킷으로 Dart 플랫폼으로 구동되며 iOS, Android, macOS, Windows, Linux 및 웹에서 실행되는 UI 경험을 빌드하기 위한 도구 및 UI 라이브러리를 제공합니다. 참고 https://dart.dev/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"}]},{"title":"[TypeScript] JSDoc Reference 사용 방법","slug":"typescript-7","date":"2023-04-11T05:53:58.000Z","updated":"2024-01-12T07:03:21.079Z","comments":true,"path":"2023/04/11/typescript-7/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-7/","excerpt":"","text":"JavaScript 파일에서 TypeScript처럼 코드를 보호받을 수 있도록 하는 방법에 대해 알아보겠습니다. @ts-check JavaScript 파일에서 오류를 활성화하려면 // @ts-check를 .js 파일의 첫 번째 줄에 추가하여 TypeScript가 오류를 발생시키도록 합니다. TypeScript는 여러 오류를 제공할 수 있습니다. 아래 코드는 TypeScript와 같이 함수 파라미터에 정의가 되어 있지 않아 오류가 발생합니다. 1234567891011// @ts-check// [오류]export function init(🚫 config) &#123; return true;&#125;// [오류]export function exit(🚫 code) &#123; return code + 1;&#125; 이러한 오류를 무시하고 싶다면 // @ts-ignore 또는 // @ts-expect-error를 추가하여 특정 줄의 오류를 무시할 수 있습니다. JSDoc Reference JSDoc 주석을 사용하여 JavaScript 파일에 type 정보를 제공할 수 있습니다. (자바스크립트 파일에서 타입 정보를 제공할 수 있습니다.) 123456789101112131415161718192021// @ts-check/** * Initializes the project * @param &#123;object&#125; config * @param &#123;boolean&#125; config.debug * @param &#123;string&#125; config.url * @returns &#123;boolean&#125; */export function init(config) &#123; return true;&#125;/** * Exits the program * @param &#123;number&#125; code * @returns &#123;number&#125; */export function exit(code) &#123; return code + 1;&#125; JSDoc 주석을 통해 타입을 정의하고 TypeScript 파일에서 다음과 같이 함수를 사용할 수 있습니다. 123456init(&#123; debug: false, url: 'true',&#125;);exit(1); 주의 사항 @ts-check를 사용하면 JavaScript 파일 내에서 타입 검사를 허용합니다. @ts-check를 사용하지 않고 JSDoc 만 사용하면 TypeScript 파일에서는 JavaScript의 타입을 검사 하지만, JavaScript 내에서는 단순 주석이나 타입을 명시하는 정도로만 사용할 수 있는 것 같습니다 참고 https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"}]},{"title":"[TypeScript] 설치 및 설정 방법","slug":"typescript-6","date":"2023-04-11T02:10:23.000Z","updated":"2024-01-12T07:02:38.035Z","comments":true,"path":"2023/04/11/typescript-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-6/","excerpt":"","text":"NextJS, Create React App(CRA)를 사용하지 않고 초기 프로젝트에 TypeScript를 설치하고 설정하는 방법에 대해 알아보겠습니다. 프로젝트 시작 프로젝트 디렉터리를 생성합니다. 12$ mkdir typescripttest$ cd typescripttest 다음 명령어를 실행하여 package.json을 초기화합니다. 1$ npm init -y TypeScript 설치 다음 명령어를 실행하여 TypeScript 설치합니다. 1$ npm i -D typescript tsconfig.json 설정 TypeScript 설정은 tsconfig.json 파일에서 합니다. 디렉터리에 tsconfig.json 파일이 있으면 해당 디렉터리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일과 컴파일러 옵션을 지정합니다. tsconfig.json 파일을 생성합니다. 다음과 같이 기본적인 설정을 작성합니다. 1234567// tsconfig.json&#123; \"include\": [\"src\"], // 자바스크립트로 컴파일 하고 싶은 모든 디렉터리 \"compilerOptions\": &#123; \"outDir\": \"build\" // 자바스크립트 파일로 생성될 디렉터리(빌드 디렉터리) &#125;&#125; 다음 명령어로도 기본적인 tsconfig.json 파일 생성이 가능합니다. 12$ npm i -g typescript$ tsc --init Target (기본값: ES3) 최신 브라우저는 모든 ES6 기능을 지원하므로 ES6는 좋은 선택입니다. 코드가 이전 환경에 배포된 경우 더 낮은 target을 설정하거나 최신 환경에서 코드 실행이 보장되는 경우 더 높은 target을 설정하도록 선택할 수 있습니다. 12345678// tsconfig.json&#123; \"include\": [\"src\"], \"compilerOptions\": &#123; \"outDir\": \"build\", \"target\": \"ES6\" &#125;&#125; Lib(라이브러리) 타입스크립트에게 어떤 API를 사용하고 어떤 환경에서 코드를 실행하는 지를 지정할 수 있습니다. (target 런타임 환경이 무엇인지를 지정합니다.) 프로그램이 브라우저에서 실행되면 lib에 “DOM” 유형 정의를 할 수 있습니다. DOM: window, document 등 123456// ex)&#123; \"compilerOptions\": &#123; \"lib\": [\"ES6\", \"DOM\"] &#125;&#125; strict 모든 엄격한 타입 검사 옵션을 활성화합니다. strict 플래그는 프로그램 정확성을 더 강력하게 보장하는 광범위한 타입 검사 동작을 가능하게 합니다. tsconfig.json 에서 &quot;strict&quot;: true를 통해 strict mode로 해주면, Declaration Files 가 없는 경우에 대해서도 에러를 띄워줍니다. 12345&#123; \"compilerOptions\": &#123; \"strict\": true &#125;&#125; 참고 https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content https://www.typescriptlang.org/tsconfig#target https://www.typescriptlang.org/tsconfig#lib https://www.typescriptlang.org/tsconfig#strict","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"}]},{"title":"[TypeScript] 인터페이스(Interface) 사용 방법","slug":"typescript-5","date":"2023-04-06T14:20:26.000Z","updated":"2024-01-12T07:01:14.780Z","comments":true,"path":"2023/04/06/typescript-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/06/typescript-5/","excerpt":"","text":"TypeScript에서 인터페이스(Interface)를 생성하고 사용하는 방법에 대해 알아보겠습니다. Interfaces 객체의 모양을 특정해 주기 위해 사용합니다. 여기서는 firstName 및 lastName 필드가 있는 객체를 설명하는 인터페이스를 사용합니다. 1234interface Person &#123; firstName: string; lastName: string;&#125; 다른 인터페이스를 상속 받아 사용할 수 있습니다. 123456789interface User &#123; name: string;&#125;interface Player extends User &#123;&#125;const eden: Player = &#123; name: 'eden',&#125;; 인터페이스 이름이 같도록 3번 각각 만들어도 타입스크립트는 알아서 하나로 합쳐줍니다. Type과 차이점입니다. 1234567891011121314151617interface User &#123; name: string;&#125;interface User &#123; nickname: string;&#125;interface User &#123; age: number;&#125;const eden: User = &#123; name: 'eden', nickname: 'ko', age: 30,&#125;; implements implements 을 사용하여 클래스가 특정 인터페이스를 충족하는지 확인할 수 있습니다. 클래스를 올바르게 구현하지 못하면 오류가 발생합니다. implements 절은 클래스가 인터페이스 유형으로 처리될 수 있는지 확인하는 것입니다. 클래스의 유형이나 메서드는 전혀 변경하지 않습니다. 또한 클래스는 여러 인터페이스를 구현할 수도 있습니다. 12// ex) 클래스 C 는 A, B 를 구현합니다.class C implements A, B &#123;&#125; 1234567891011interface Pingable &#123; ping(): void;&#125;// Sonar 클래스는 Pingable 인터페이스를 implement 했기 때문에// Pingable 가 가진 ping 메서드를 구현해줘야 합니다.class Sonar implements Pingable &#123; ping() &#123; console.log('ping!'); &#125;&#125; 여러 개의 인터페이스를 상속받아 사용할 수 있습니다. 123456789101112interface User &#123; firstName: string; lastName: string;&#125;interface Human &#123; health: number;&#125;class Player implements User, Human &#123; constructor(public firstName: string, public lastName: string, public health: number) &#123;&#125;&#125; Type Aliases 과 Interfaces의 차이점 Type Aliases 과 인터페이스는 매우 유사하며 많은 경우 자유롭게 선택할 수 있습니다. 인터페이스의 거의 모든 기능은 type에서 사용할 수 있으며, 주요 차이점은 type을 다시 열어 새 속성을 추가할 수 없는 것입니다. 반면 인터페이스는 항상 확장 가능합니다. 참고 https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[TypeScript] 클래스(Class) 사용 방법","slug":"typescript-4","date":"2023-03-29T05:20:34.000Z","updated":"2024-01-12T07:00:38.265Z","comments":true,"path":"2023/03/29/typescript-4/","link":"","permalink":"http://hgko1207.github.io/2023/03/29/typescript-4/","excerpt":"","text":"TypeScript에서 클래스(Class)를 생성하고 사용하는 방법에 대해 알아보겠습니다. 클래스(Class) 가장 기본적인 클래스입니다. 1class Player &#123;&#125; 필드를 선언해서 사용 가능합니다. 12345678class Player &#123; firstname: string; lastname: string;&#125;const eden = new Player();eden.firstname = 'ko';eden.lastname = 'eden'; 생성자에 매개변수를 추가해서 선언할 수 있습니다. 1234567891011121314class Player &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123;&#125;&#125;const eden = new Player(\"ko\", \"eden\", \"고수\");// [오류]// firstname는 private 이기 때문에 접근 불가// javascript 에서는 아무 문제없이 작동함🚫 eden.firstname; public: 모든 클래스에서 접근 가능 private: 해당 클래스 내에서만 접근 가능 (자식 클래스에서도 접근 불가) protected: 해당 클래스와 자식 클래스에서 접근 가능 추상 클래스(Abstract Class) TypeScript와 객체지향 프로그램이 가지고 있는 엄청 훌륭한 것은 추상 클래스(Abstract Class)라고 생각됩니다. 추상클래스는 다른 클래스가 상속받을 수 있는 클래스입니다. 하지만 이 클래스는 직접 새로운 인스턴스를 만들 수는 없습니다. 1234567891011121314151617abstract class User &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123; abstract getNickname(): void getFullName() &#123; return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;`; &#125; &#125;&#125;// [오류]// TypeScript 가 추상 클래스의 인스턴스를 만들 수 없다고 경고함🚫 const eden = new User(\"ko\", \"eden\", \"고수\"); 12345678910class Player extends User &#123; // 추상 메서드는 추상 클래스를 상속받는 클래스들이 반드시 구현(implement)해야하는 메서드입니다. getNickname() &#123; console.log(this.nickname); &#125;&#125;const eden = new Player('ko', 'eden', '고수');eden.getNickname();eden.getFullName(); 추상 클래스를 사용하기 위해서는 상속을 받아 사용합니다. Static Members 클래스에는 static 멤버가 있을 수 있습니다. 이 멤버는 클래스의 특정 인스턴스와 연결되지 않습니다. 클래스 생성자 객체 자체를 통해 액세스 할 수 있습니다. static 멤버는 동일한 public, protected 및 private과 함께 사용할 수도 있습니다. 12345678910class MyClass &#123; static x = 0; static printX() &#123; console.log(MyClass.x); &#125;&#125;console.log(MyClass.x);MyClass.printX(); 참고 https://www.typescriptlang.org/docs/handbook/2/classes.html https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"}]},{"title":"[TypeScript] 다형성(Polymorphism)","slug":"typescript-3","date":"2023-03-16T05:59:01.000Z","updated":"2024-01-12T06:59:18.061Z","comments":true,"path":"2023/03/16/typescript-3/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-3/","excerpt":"","text":"다형성(Polymorphism) 다형성이란, 여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미합니다. poly: many, serveral, much, multi 등과 같은 뜻 morphos: form, structure 등과 같은 뜻 polymorphos = poly + morphos: 여러 다른 구조 예시 123456789101112type SuperPrint = &#123; (arr: T[]): T;&#125;;const superPrint: SuperPrint = (arr) =&gt; &#123; return arr[0];&#125;;const a = superPrint([1, 2, 3]);const b = superPrint([true, false, true]);const c = superPrint(['a', 'b']);const d = superPrint([1, 2, 'a', 'b', true]); any, generics 차이점 any를 사용하는 것은 어떤 타입이든 받을 수 있다는 점에서 generics과 같지만 함수를 반환하는 데 있어 any는 받았던 인수들의 타입을 활용하지 못합니다. 즉, generics 은 어떤 타입이든 받을 수 있다는 점에서 any와 같지만 해당 정보를 잃지 않고 타입에 대한 정보를 다른 쪽으로 전달할 수 있다는 점이 다릅니다. Generics 제네릭은 C#이나 Java와 같은 언어에서 재사용 가능한 컴포넌트를 만들기 위해 사용하는 기법입니다. 단일 타입이 아닌 다양한 타입에서 작동할 수 있는 컴포넌트를 생성할 수 있습니다. (구체적인 타입을 지정하지 않고 다양한 인수와 리턴 값에 대한 타입을 처리할 수 있습니다.) 타입스크립트에서 제네릭을 통해 인터페이스, 함수 등의 재사용성을 높일 수 있습니다. 1234567891011function identity&lt;Type&gt;(arg: Type): Type &#123; return arg;&#125;// 제네릭 화살표 함수 (tsx기준)const identity = &lt;Type extends &#123;&#125;&gt;(arg: Type): Type =&gt; &#123; return arg;&#125;;let output = identity&lt;string&gt;('myString'); // 첫 번째 방법let output = identity('myString'); // 두 번째 방법 위에서 두 번째 방법은 type argument inference(타입 인수 유추)를 사용합니다. 즉, 컴파일러가 전달하는 인수 유형에 따라 자동으로 Type 값을 설정하기를 원합니다. 참고 https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"}]},{"title":"[TypeScript] Function Overloads","slug":"typescript-2","date":"2023-03-16T05:47:52.000Z","updated":"2024-01-12T06:54:18.471Z","comments":true,"path":"2023/03/16/typescript-2/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-2/","excerpt":"","text":"Function Overloads 동일한 이름에 매개 변수와 매개 변수 타입 또는 리턴 타입이 다른 여러 버전의 함수를 만드는 것을 말합니다. TypeScript에서는 오버로드 signatures을 작성하여 **“다양한 방식으로 호출할 수 있는 함수”**를 지정할 수 있습니다. 사용 예제 매개변수의 데이터 타입이 다른 경우 매개변수의 데이터 타입이 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: string): number;&#125;;const add: Add = (a, b) =&gt; &#123; if (typeof b === 'string') return a; return a + b;&#125;;add(1, '2');add(1, 2); 매개변수의 수가 다른 경우 매개변수의 수가 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: number, c: number): number;&#125;;const add2: Add = (a, b, c?: number) =&gt; &#123; if (c) return a + b + c; return a + b;&#125;;add(1, 2);add(1, 2, 3); 참고 https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"}]},{"title":"[WPF] 문자열(string)의 가로 세로 길이 계산","slug":"wpf-10","date":"2023-03-16T01:53:23.000Z","updated":"2024-01-12T06:59:58.582Z","comments":true,"path":"2023/03/16/wpf-10/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/wpf-10/","excerpt":"","text":"WPF에서 글꼴 크기(FontSize)와 폰트(FontFamily)를 통해 문자열의 크기를 계산하는 방법에 대해 알아보겠습니다. FormattedText를 사용하여 텍스트의 서식을 지정한 후 크기를 계산할 수 있습니다. 소스코드 TextBlock 컨트롤을 사용할 경우 다음과 같이 작성하여 문자열의 크기를 구합니다. 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"textBlock\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(TextBlock textBlock)&#123; FormattedText formattedText = new FormattedText ( textBlock.Text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( textBlock.FontFamily, textBlock.FontStyle, textBlock.FontWeight, textBlock.FontStretch ), textBlock.FontSize, textBlock.Foreground, VisualTreeHelper.GetDpi(textBlock).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; TextBlock 컨트롤을 사용하지 않고 string 문자열과 글꼴 크기, 폰트를 입력하여 길이를 구할 수 있습니다. 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"text\"&gt;&lt;/param&gt;/// &lt;param name=\"fontSize\"&gt;&lt;/param&gt;/// &lt;param name=\"fontFamily\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(string text, int fontSize, FontFamily fontFamily)&#123; FormattedText formattedText = new FormattedText ( text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( fontFamily, FontStyles.Normal, FontWeights.Bold, FontStretches.Normal ), fontSize, Brushes.Black, VisualTreeHelper.GetDpi(this).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; 사용 방법 TextBlock 컨트롤을 사용할 경우 사용 방법입니다. 123456789101112TextBlock textBlock = new TextBlock&#123; Text = \"test\", FontFamily = new FontFamily(\"Arial\"), FontSize = 16, Foreground = Brushes.Red&#125;;Size textSize = MeasureString(textBlock);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); TextBlock 컨트롤을 사용하지 않을 경우 사용 방법입니다. 12345678string text = \"hello eden\";int fontSize = 32;FontFamily fontFamily = new FontFamily(\"Arial\");Size textSize = MeasureString(text, fontSize, fontFamily);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); 참고 https://learn.microsoft.com/ko-kr/dotnet/api/system.windows.media.formattedtext?view=netframework-4.7.2","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"}]},{"title":"[TypeScript] Types","slug":"typescript-1","date":"2023-03-13T04:56:29.000Z","updated":"2024-01-12T06:50:13.257Z","comments":true,"path":"2023/03/13/typescript-1/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/typescript-1/","excerpt":"","text":"타입스크립트란? TypeScript는 JavaScript에 추가적인 구문을 추가하여 editor 와의 단단한 통합을 지원합니다. editor에서 초기에 오류를 잡을 수 있습니다. TypeScript 코드는 JavaScript가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript로 변환될 수 있습니다. TypeScript는 JavaScript를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다. Types(기본) ✅ 배열: 자료형[] ✅ 숫자: number ✅ 문자열: string ✅ 논리: boolean 123456type Player = &#123; name: string; age: number; weapons: string[]; attack: bool;&#125;; optional 사용 ?를 :앞에 붙이면 optional 사용 가능합니다. 123456const player: &#123; name: string; age?: number;&#125; = &#123; name: 'eden',&#125;; 위와 같이 player.age를 optional로 설정할 경우 Typescript는 player.age가 undefined 일수도 있다고 오류를 알려줍니다. 123// ❌ player.age 가 undefined 일 가능성 알림if (player.age &lt; 10) &#123;&#125; player.age가 존재하는지 확인을 거쳐야 오류 알림이 사라집니다. 123// ⭕ player.age 가 undefined 일 가능성 체크if (player.age &amp;&amp; player.age &lt; 10) &#123;&#125; Alias(별칭) 타입 12345678type Player = &#123; name: string; age?: number;&#125;;const player: Player = &#123; name: 'eden',&#125;; readonly 사용 변수 또는 별칭 앞에 readonly를 붙이면 readonly 사용 가능합니다. 1234type Player = &#123; readonly name: string; age?: number;&#125;; readonly가 있으면 최초 선언 후 수정 불가합니다. 불변성(immutability)이 부여됩니다. 하지만 javascript에서는 그냥 배열로 인식하여 수정이 됩니다. 123456789const playerMaker = (name: string): Player =&gt; (&#123; name &#125;);const player = playerMaker('eden');// [오류]🚫 player.name = \"khk\"const numbers: readonly number[] = [1, 2, 3, 4];// [오류]🚫 numbers.push(5) Tuple 타입 정해진 개수와 순서에 따라 배열 선언이 가능합니다. 123const player: [string, number, boolean] = ['eden', 1, true];// [오류]🚫 player[0] = 1 // 바꿀 수 없습니다. string으로 지정됨 readonly도 사용 가능 합니다. 1const player: readonly [string, number, boolean] = ['eden', 1, true]; any / undefined / null 타입 ✅ any: 어떠한 타입도 허용 12const a: any[] = [1, 2, 3, 4];const b: any = true; ✅ undefined: undefined 값만 가질 수 있음 ✅ null: null 값만 가질 수 있음 123456let nullable: null = null;let undefinedable: undefined = undefined;// [오류]// 'undefined' 형식은 'null' 형식에 할당할 수 없습니다.🚫 nullable = undefined; void 타입 void는 값을 반환하지 않는 함수의 반환 값을 나타냅니다. 함수에 return 문이 없거나 해당 return 문에서 명시적 값을 반환하지 않을 때 항상 유추되는 타입입니다. 1234// The inferred return type is voidfunction noop() &#123; return;&#125; 1234567function test() &#123; console.log('x')&#125;const a = test()// [오류]🚫 a.toUpperCase() unknown 타입 unknown 타입은 모든 값을 나타냅니다. 이것은 any 타입과 비슷하지만 any 보다 unknown 이 더 안전합니다. 이유는 unknown 값으로 작업을 수행하는 것은 합법적이지 않기 때문입니다. 1234567function test(a: any) &#123; a.b(); // OK&#125;function test2(a: unknown) &#123; 🚫 a.b(); // 에러: Object is of type 'unknown'.&#125; never 타입 never 타입은 모든 타입에 할당 가능한 하위 타입이나, never 타입에는 본인 외에 다른 타입이 할당될 수는 없습니다. never 타입은 절대 발생할 수 없는 타입을 나타냅니다. 가장 흔한 예제로는 에러를 발생시킬 때 사용됩니다. 123function fail(msg: string): never &#123; throw new Error(msg);&#125; 사용법에 대해 좀 더 찾아봐야겠지만 그 외에도 특정 타입 값을 할당받지 않도록 하거나, 매개변수의 제한을 건다거나 뭐 그런 곳들에 사용된다는데, 사실 많이 사용하는 타입은 아니라고 봐도 무방합니다. 참고 타입스크립트 코드 테스트 타입스크립트 핸드북","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"}]},{"title":"[WPF] Grid를 Bitmap 이미지로 변환 후 저장하기","slug":"wpf-9","date":"2023-03-13T01:49:24.000Z","updated":"2024-01-12T06:53:56.071Z","comments":true,"path":"2023/03/13/wpf-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/wpf-9/","excerpt":"","text":"WPF의 Grid를 사용하여 사용자의 입력을 받는 문서를 작성하거나 여러 이미지를 가시화할 시, 이를 이미지로 저장하는 기능이 필요할 경우가 있습니다. 따라서 Grid 컨트롤을 하위 요소들과 함께 Bitmap으로 변환하고 이미지를 저장하는 방법에 대해 알아보겠습니다. 소스코드 먼저 Grid 컨트롤 내용들을 Bitmap으로 변환합니다. 1234567891011121314151617181920212223/// &lt;summary&gt;/// Grid를 Bitmap이미지로 변환/// &lt;/summary&gt;/// &lt;param name=\"element\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static RenderTargetBitmap GetBitmapFromControl(FrameworkElement element)&#123; Size size = new Size(element.ActualWidth, element.ActualHeight); if (size.IsEmpty) return null; DrawingVisual drawingVisual = new DrawingVisual(); using (DrawingContext context = drawingVisual.RenderOpen()) &#123; context.DrawRectangle(new VisualBrush(element), null, new Rect(new Point(), size)); context.Close(); &#125; RenderTargetBitmap result = new RenderTargetBitmap((int)size.Width, (int)size.Height, 96, 96, PixelFormats.Pbgra32); result.Render(drawingVisual); return result;&#125; 변환된 Bitmap을 PNG 또는 TIF 이미지 파일로 저장하는 코드입니다. 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// Bitmap을 이미지로 저장/// &lt;/summary&gt;/// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;/// &lt;param name=\"filePath\"&gt;파일 경로&lt;/param&gt;public static void SaveImage(RenderTargetBitmap bitmap, string filePath)&#123; string ext = System.IO.Path.GetExtension(filePath); using (FileStream stream = new FileStream(filePath, FileMode.Create)) &#123; if (ext == \".png\") &#123; PngBitmapEncoder encoder = new PngBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; else if (ext == \".tif\") &#123; TiffBitmapEncoder encoder = new TiffBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; stream.Close(); &#125;&#125; 사용 방법 123456789101112131415&lt;Window x:Class=\"TestProject.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Width=\"800\" Height=\"600\" Title=\"이미지 저장하기\"&gt; &lt;Grid Name=\"grid\"&gt; &lt;Canvas&gt; ... &lt;/Canvas&gt; &lt;StackPanel&gt; ... &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; GetBitmapFromControl 함수를 사용하여 이미지로 저장하려는 Grid를 Bitmap으로 변환합니다. 그리고 SaveImage 함수의 파라미터에 bitmap, 파일경로를 넣어 이미지를 저장합니다. 123456789/// &lt;summary&gt;/// 이미지 저장/// &lt;/summary&gt;private void Capture()&#123; RenderTargetBitmap bitmap = GetBitmapFromControl(this.grid); string filePath = \"d:\\\\test.png\"; SaveImage(bitmap, filePath);&#125; Grid 컨트롤 뿐만 아니라 FrameworkElement을 상속받는 모든 컨트롤들을 위의 함수를 사용하여 이미지를 저장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"}]},{"title":"[Angular] FormGroup 관련 에러","slug":"angular-9","date":"2023-03-08T14:12:56.000Z","updated":"2024-01-12T06:48:54.999Z","comments":true,"path":"2023/03/08/angular-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/08/angular-9/","excerpt":"","text":"Angular에서 FormGroup 사용 시 다음과 같이 에러가 발생할 경우 해결 방법에 대해 알아보겠습니다. Error 1234567891011121314151617181920212223ERROR Error: NG01350: ngModel cannot be used to register form controls with a parent formGroup directive. Try using formGroup's partner directive \"formControlName\" instead. Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;/div&gt; In your class: this.myGroup = new FormGroup(&#123; firstName: new FormControl() &#125;); Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions: Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt; &lt;/div&gt; 해결 방법 에러 메시지 내용은 formGroup을 사용하려면 formControlName을 사용하거나 [(ngModel)] 사용 시 [ngModelOptions]=&quot;{standalone: true}를 추가하라고 합니다. 다음과 같이 formGroup 속성이 있는 태그의 자식 중에 ngModel 속성을 사용하는 모든 태그에 formControlName 또는 [ngModelOptions]=&quot;{standalone: true}이 있어야 에러를 해결할 수 있습니다. 12345this.myForm = new FormGroup(&#123; id: new FormControl(''), name: new FormControl(''), title: new FormControl(''),&#125;); 12345&lt;form [formGroup]=\"myForm\"&gt; &lt;input type=\"text\" formControlName=\"id\"&gt; &lt;input type=\"text\" formControlName=\"name\"&gt; &lt;input type=\"text\" [(ngModel)]=\"myForm.value.title\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt;&lt;/fom&gt; 그리고 추가적으로 Typescript에서 FormBuilder를 통해 Group을 생성할 때 formControlName에 있는 값들을 전부 넣어줘야 됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"}]},{"title":"[Next.js] Dynamic Routes 사용 방법","slug":"nextjs-6","date":"2023-02-23T07:28:30.000Z","updated":"2024-01-12T06:48:05.521Z","comments":true,"path":"2023/02/23/nextjs-6/","link":"","permalink":"http://hgko1207.github.io/2023/02/23/nextjs-6/","excerpt":"","text":"Next.js에서 Dynamic Routes 사용 방법에 대해 알아보겠습니다. Dynamic Routes Next.js에서는 page에 대괄호([param])를 추가하여 Dynamic Route를 생성할 수 있습니다. pages/movies 경로에 [id].js 파일을 생성하면 /movies/1, /movies/abc 등과 같은 경로로 접속할 수 있습니다. 다음 예제처럼 useRouter()의 query를 통해 /movies 다음의 하위 경로를 확인할 수 있습니다. 123456789// pages/movies/[id].jsimport &#123; useRouter &#125; from 'next/router';export default function Detail() &#123; const router = useRouter(); const &#123; id &#125; = router.query; return 'detail';&#125; 생성한 경로로 이동을 원한다면 다음과 같이 next/link를 사용하여 작성합니다. 12345678910111213141516import Link from 'next/link';function Home() &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link href=\"/movies/abc\"&gt;Go to movies/movies/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=\"/movies/abc?foo=bar\"&gt;Also goes to movies/post/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;export default Home; Catch all routes 대괄호 안에 세 개의 점(…)을 추가하여 모든 경로를 포착하도록 Dynamic Routes를 확장할 수 있습니다. pages/movies/[…id].js는 /movies/1와 일치하지만 /movies/1/2, /movies/1/ab/cd 등과도 일치합니다. 일치하는 매개변수는 페이지에 쿼리 매개변수로 전송되며 항상 배열이므로 /movies/a 또는 /movies/a/b 경로일 경우 다음과 같이 조회가 됩니다. 12345// /movies/a&#123; \"id\": [\"a\"] &#125;// /movies/a/b&#123; \"id\": [\"a\", \"b\"] &#125; 참고 https://nextjs.org/docs/routing/dynamic-routes","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"}]},{"title":"엘라스틱 스택 개발부터 운영까지","slug":"book-3","date":"2023-02-22T01:12:03.000Z","updated":"2024-01-12T06:47:24.925Z","comments":true,"path":"2023/02/22/book-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/22/book-3/","excerpt":"","text":"책 정보 책 소개 데이터를 처리하는 데 서로 잘 맞지도 않는 오픈소스 기술들을 굳이 동원해야 할까? 제각각인 오픈소스들을 통합하고 운영하느라 지친 개발자와 운영자들을 위한 솔루션! 이제 엘라스틱 스택 기술 하나면 OK! 어느덧 엘라스틱 스택은 검색 엔진을 넘어서 데이터 처리 시스템의 최강자로 자리 잡았다. 이 책에서는 빠르게 변화하는 세상에서 엘라스틱 스택을 지렛대로 삼아 기업의 생존 능력을 극대화하는 방법을 체계적으로 정리한다. 엔터프라이즈 빅데이터 파이프라인을 만들어 기업의 데이터를 처리하고 싶다면? 기업 내에 검색 엔진을 구축해서 빠르게 자료를 검색하고 싶다면? 방대한 데이터를 잘 가공해서 저장한 후에 멋진 시각화로 인사이트를 얻고 싶다면? 여러 서버에서 데이터들을 가져와 하나로 통합한 다음에 추이를 보거나 통계를 내고 싶다면? 바로 이럴 때 엘라스틱 스택이 정답이다. 실습을 위한 물리적인 컴퓨터나 가상 머신만 준비한다면 나머지는 모두 이 책이 책임져줄 것이다. 이 책에서는 엘라스틱 스택을 사용해 데이터 중심 애플리케이션을 설계하고, 개발하며, 운영하는 과정에서 꼭 알아야 할 필수 지식을 구체적인 사례와 함께 설명한다. 리뷰 데이터 검색과 분석을 위해서 엘라스틱 서치를 공부하려고 찾던 중 엘라스틱 스택을 알게 되었고 궁금함을 못 참고 바로 구입하게 되었습니다. 엘라스틱 스택 개념과 구성요소(엘라스틱 서치, 로그스태시, 비트, 키바나 등)들이 잘 정리되어 있어 이해가 쉬웠고 참고가 많이 되었습니다. 엘라스틱 스택의 구성요소를 통해 데이터 수집부터 변환, 분석, 검색, 시각화까지 하는 내용들이 구성되어 있어 응용 학습에 많은 도움이 될 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"}]},{"title":"[Next.js] Redirect and Rewrite","slug":"nextjs-5","date":"2023-02-21T02:25:34.000Z","updated":"2024-01-12T06:46:56.386Z","comments":true,"path":"2023/02/21/nextjs-5/","link":"","permalink":"http://hgko1207.github.io/2023/02/21/nextjs-5/","excerpt":"","text":"Next.js에서 Redirect와 Rewrite 설정 방법에 대해 알아보겠습니다. Redirect와 Rewrite 설정은 next.config.js 파일에서 설정하게 됩니다. next.config.js Next.js에서 커스텀 설정을 하기 위해서는 프로젝트 디렉터리의 루트에 next.config.js 또는 next.config.mjs 파일을 만들 수 있습니다. next.config.js는 JSON 파일이 아닌 일반 Node.js 모듈입니다. 123456/** @type &#123;import('next').NextConfig&#125; */const nextConfig = &#123; reactStrictMode: true,&#125;;module.exports = nextConfig; Next.js 서버 및 빌드 단계에서 사용되며 브라우저 빌드에는 포함되지 않습니다. Redirects (URL변경됨) Redirect 을 사용하면 들어오는 request 경로를 다른 destination 경로로 Redirect 할 수 있습니다. Redirect 을 사용하려면 next.config.js 에서 redirects 키를 설정합니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/contact', destination: '/form', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; redirects은 source, destination 및 permanent 속성이 있는 객체를 포함하는 배열을 반환하는 비동기 함수입니다. source: 들어오는 request 경로 (request 경로) destination: 라우팅 하려는 경로 (redirect 할 경로) permanent: true 인 경우 클라이언트와 search 엔진에 redirect를 영구적으로 cache 하도록 지시하는 308 status code를 사용하고, false 인 경우 일시적이고 cache 되지 않은 307 status code를 사용합니다. request 경로에 요청되는 모든 쿼리 값도 destination 으로 전달됩니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/old-blog/:path*', destination: '/blog/:path*', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 예를 들어 /old-blog/post-1?hello=world 요청이 들어오면 /blog/post-1?hello=world 경로로 Redirect 됩니다. Rewrites (URL변경되지 않음) Rewrites를 사용하면 들어오는 request 경로를 다른 destination 경로에 매핑할 수 있습니다. Rewrites은 URL 프록시 역할을 하고 destination 경로를 mask 하여 사용자가 사이트에서 위치를 변경하지 않은 것처럼 보이게 합니다. 반대로 redirects은 새 페이지로 reroute 되고 URL 변경 사항을 표시합니다. 1234567891011121314const API_KEY = process.env.API_KEY;const nextConfig = &#123; reactStrictMode: true, async rewrites() &#123; return [ &#123; source: '/api/movies', destination: `https://api.themoviedb.org/3/movie/popular?api_key=$&#123;API_KEY&#125;`, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 12// 사용const &#123; results &#125; = await (await fetch(`/api/movies`)).json(); API를 통해 데이터를 조회할 때 API Key가 필요한 경우가 있습니다. 그럴 경우 API Key가 노출되어 위험할 수 있습니다. 위의 내용처럼 Rewrites를 사용하여 API 주소로 매핑을 하여 노출되지 않도록 해결하였습니다. 참고 https://nextjs.org/docs/api-reference/next.config.js/introduction https://nextjs.org/docs/api-reference/next.config.js/redirects https://nextjs.org/docs/api-reference/next.config.js/rewrites","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"}]},{"title":"[Next.js] Head 사용 방법","slug":"nextjs-4","date":"2023-02-07T07:19:38.000Z","updated":"2024-01-12T06:45:16.177Z","comments":true,"path":"2023/02/07/nextjs-4/","link":"","permalink":"http://hgko1207.github.io/2023/02/07/nextjs-4/","excerpt":"","text":"Next.js에서 Head 사용 방법에 대해 알아보겠습니다. Title 설정 Next.js에는 페이지 헤더의 제목을 변경하고 meta를 추가할 수 있는 내장 컴포넌트를 가지고 있습니다. 123456789101112import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 태그 중복 방지 head에 태그가 중복되는 것을 방지하려면 다음 예제와 같이 태그가 한 번만 렌더링 되도록 하는 key 속성을 사용할 수 있습니다. 12345678910111213141516import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;meta property=\"og:title\" content=\"My page title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;Head&gt; &lt;meta property=\"og:title\" content=\"My new title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 이 경우 두 번째 meta property=&quot;og:title&quot;만 렌더링 됩니다. 중복 키 속성이 있는 meta 태그는 자동으로 처리됩니다. key를 지정해주지 않으면 meta property=&quot;og:title&quot;가 중복해서 2번 랜더링 됩니다. Title 은 지정하지 않아도 2번 랜더링 되지 않습니다. 공통 컴포넌트 공통으로 사용할 컴포넌트 파일(예: Seo.js)을 생성합니다. title prop을 받아서 화면마다 제목을 설정할 수 있습니다. 123456789import Head from 'next/head';export default function Seo(&#123; title &#125;) &#123; return ( &lt;Head&gt; &lt;title&gt;&#123;`$&#123;title&#125; | Title`&#125;&lt;/title&gt; &lt;/Head&gt; );&#125; 12345678910import Seo from '@/components/Seo';export default function Home() &#123; return ( &lt;div&gt; &lt;Seo title=\"Home\" /&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 참고 https://nextjs.org/docs/api-reference/next/head","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"}]},{"title":"[Next.js] Styles 사용 방법","slug":"nextjs-3","date":"2023-02-06T06:22:16.000Z","updated":"2024-01-12T06:44:18.215Z","comments":true,"path":"2023/02/06/nextjs-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/06/nextjs-3/","excerpt":"","text":"Next.js에서 스타일 적용하는 방법에 대해 알아보겠습니다. 1. CSS-in-JS 가장 간단한 방법은 인라인 스타일입니다. 1234567export default function Home() &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123; color: 'red' &#125;&#125;&gt;Hello&lt;/div&gt; &lt;/div&gt; );&#125; 2. CSS Modules Next.js는 [name].module.css 파일 명명 규칙을 사용하여 CSS Module을 지원합니다. Common.module.css파일을 생성하고 스타일을 다음과 같이 작성합니다. 중요한 것은 .module.css 패턴을 사용하는 것입니다. 123456789.nav &#123; display: flex; justify-content: space-between; background-color: red;&#125;.text &#123; color: blue;&#125; 생성된 module을 import 해서 사용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;styles.nav&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 여러 개의 스타일을 적용할 수 있습니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;`$&#123;styles.nav&#125; $&#123;styles.text&#125;`&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 또는 join() 함수를 사용해 적용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;[styles.nav, styles.text].join(' ')&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 3. Styled JSX 격리된 범위 CSS 에 대한 지원을 제공하기 위해 styled-jsx를 번들로 제공합니다. styled-jsx를 사용하는 컴포넌트는 다음과 같습니다. style에 jsx prop 을 넣고 중괄호({})와 백틱(`)을 사용하여 작성합니다. 123&lt;style jsx&gt;&#123;` CSS 스타일..`&#125;&lt;/style&gt; 12345678910111213141516export default function Home() &#123; return ( &lt;div&gt; &lt;nav&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;style jsx&gt;&#123;` nav &#123; background-color: red; &#125; h1 &#123; color: blud; &#125; `&#125;&lt;/style&gt; &lt;/div&gt; );&#125; Global Styles 설정하는 방법은 global Prop 을 추가하면 됩니다. 12345&lt;style jsx global&gt;&#123;` body &#123; background: black; &#125;`&#125;&lt;/style&gt; VSCode 익스텐션 Styled JSX 사용 시 추천 VSCode 익스텐션입니다. styled-jsx : 하이라이팅, 코드 가독성에 도움이 됨 styled-jsx Language Server : 자동완성 참고 https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js https://github.com/vercel/styled-jsx","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"}]},{"title":"[Next.js] Routing 사용 방법","slug":"nextjs-2","date":"2023-02-03T07:36:02.000Z","updated":"2024-01-12T06:43:38.567Z","comments":true,"path":"2023/02/03/nextjs-2/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-2/","excerpt":"","text":"Next.js에서 Rouing 하는 방법에 대해 알아보겠습니다. &lt;a&gt; 사용 &lt;a&gt; 태그를 사용해서 페이지 이동을 할 수 있습니다. 하지만 페이지 이동 시 전체 페이지 새고로침이 되는 문제가 발생했습니다. 12345678export default function NavBar() &#123; return ( &lt;nav&gt; &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;a href=\"/about\"&gt;About Us&lt;/a&gt; &lt;/nav&gt; );&#125; Link 사용 single-page app 환경의 페이지 전환을 하려면 Link 컴포넌트를 사용해야 합니다. 12345678910import Link from 'next/link';export default function NavBar() &#123; return ( &lt;nav&gt; &lt;Link href=\"/\"&gt;Home&lt;/Link&gt; &lt;Link href=\"/about\"&gt;About Us&lt;/Link&gt; &lt;/nav&gt; );&#125; useRouter() 컴포넌트에서 router 객체 내부에 접근하려면 userRouter() hook 을 사용할 수 있습니다. useRouter는 React Hook입니다. 즉, 클래스와 함께 사용할 수 없습니다. withRouter를 사용하거나 클래스를 함수 컴포넌트로 래핑 할 수 있습니다. 다음 내용은 useRouter() hook을 사용해서 메뉴의 색상을 변경하는 예제입니다. 1234567891011121314151617import Link from 'next/link';import &#123; useRouter &#125; from 'next/router';export default function NavBar() &#123; const router = useRouter(); return ( &lt;nav&gt; &lt;Link href=\"/\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/' ? 'red' : 'blue' &#125;&#125;&gt;Home&lt;/span&gt; &lt;/Link&gt; &lt;Link href=\"/about\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/about' ? 'red' : 'blue' &#125;&#125;&gt;About Us&lt;/span&gt; &lt;/Link&gt; &lt;/nav&gt; );&#125; 참고 https://nextjs.org/docs/messages/no-html-link-for-pages https://nextjs.org/docs/api-reference/next/router#userouter","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"}]},{"title":"라이브러리와 프레임워크 차이점","slug":"info-1","date":"2023-02-03T06:50:35.000Z","updated":"2024-01-12T06:42:28.266Z","comments":true,"path":"2023/02/03/info-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/info-1/","excerpt":"","text":"라이브러리와 프레임워크의 주요 차이점에 대해 알아보겠습니다. 라이브러리 사용자가 파일 이름이나 구조 등을 정하고, 모든 결정을 내립니다. 우리 프로젝트에 가져와서 쓰는 방식 예) React: 렌더링 할 때 ReactDOM.render()를 불러와서 사용합니다. 프레임워크 파일 이름이나 구조 등을 정해진 규칙에 따라 만들고 따릅니다. 정해진 틀 안에서 커스터마이징 방식 예) NextJS: 정해진 규칙에 따라 코드를 작성하면 렌더링됩니다. 차이점 라이브러리와 프레임워크의 주요 차이점은 “Inversion of Control”(통제의 역전) 입니다. 라이브러리에서 메서드를 호출하면 사용자가 제어할 수 있습니다. 그러나 프레임워크에서는 제어가 역전되어 프레임워크가 사용자를 호출합니다. 참고 https://www.youtube.com/watch?v=t9ccIykXTCM","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"}]},{"title":"[Next.js] 프로젝트 생성 및 시작 방법","slug":"nextjs-1","date":"2023-02-03T00:48:16.000Z","updated":"2024-01-12T06:42:51.230Z","comments":true,"path":"2023/02/03/nextjs-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-1/","excerpt":"","text":"Next.js를 사용하는 프로젝트 생성 하는 방법에 대해 알아보겠습니다. 시스템 요구 사항 Node.js 14.6.0 이상 MacOS, Windows(WSL 포함) 및 Linux 가 지원됩니다. 프로젝트 생성 리액트 프로젝트를 생성하는 방법과 비슷하게 create-next-app 명령어를 사용합니다. @latest 를 추가하면 최신 버전으로 프로젝트를 생성합니다. 123npx create-next-app@latest# oryarn create next-app TypeScript 프로젝트로 시작하려면 --typescript 옵션을 추가합니다. 123npx create-next-app@latest --typescript# oryarn create next-app --typescript 위의 방법으로 프로젝트를 생성해 보겠습니다. 123456789101112131415161718192021222324252627282930D:\\project\\Study&gt;npx create-next-app@latest√ What is your project named? ... nextjs-intro√ Would you like to use TypeScript with this project? ... No / Yes√ Would you like to use ESLint with this project? ... No / Yes√ Would you like to use `src/` directory with this project? ... No / Yes√ Would you like to use experimental `app/` directory with this project? ... No / Yes√ What import alias would you like configured? ... @/*Creating a new Next.js app in D:\\project\\Study\\nomadcoders\\nextjs-intro.Using npm.Installing dependencies:- react- react-dom- next- @next/font- eslint- eslint-config-nextadded 264 packages, and audited 265 packages in 25s102 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesInitializing project with template: defaultSuccess! Created nextjs-intro at D:\\project\\Study\\nextjs-intro 프로젝트 이름을 입력하고 TypeScript와 ESLint 사용 여부를 선택하면 프로젝트가 성공적으로 생성됩니다. 시작 프로젝트 기본 구조입니다. 다음 명령어를 실행하여 개발 서버를 시작합니다. 123npm run dev# oryarn dev 개발 서버가 구동되면 http://localhost:3000에 접속하여 확인합니다. 참고 https://nextjs.org/docs/getting-started","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"}]},{"title":"WPF에서 Windows Forms(WinForm) Control 사용하기","slug":"wpf-8","date":"2023-02-01T07:33:44.000Z","updated":"2023-03-14T02:27:21.817Z","comments":true,"path":"2023/02/01/wpf-8/","link":"","permalink":"http://hgko1207.github.io/2023/02/01/wpf-8/","excerpt":"","text":"WPF에서 Windows Forms(WinForm) Control 사용하는 방법에 대해 알아보겠습니다. 참조 추가 프로젝트에 다음 어셈블리에 대한 참조를 추가합니다. WindowsFormsIntegration System.Windows.Forms XAML에 추가 WinForm 컨트롤을 사용하려는 XAML 파일을 열고 아래 네임스페이스 매핑을 추가합니다. wf 네임스페이스 매핑은 Windows Forms 컨트롤이 포함된 어셈블리에 대한 참조를 설정합니다. 1xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" 123456&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt;... 사용 WindowsFormsHost 컨트롤을 사용하고 자식으로는 WinForm 컨트롤을 사용합니다. 123&lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\"/&gt;&lt;/WindowsFormsHost&gt; 전체 소스 123456789101112&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt; &lt;Grid&gt; &lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\" /&gt; &lt;/WindowsFormsHost&gt; &lt;/Grid&gt;&lt;/Window&gt; 참고 WindowsFormsHost 클래스 연습: XAML을 사용하여 WPF에서 Windows Forms 컨트롤 호스팅","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"}]},{"title":"[Kibana] 사용 방법","slug":"elasticsearch-4","date":"2023-01-06T07:41:51.000Z","updated":"2024-01-12T06:42:01.405Z","comments":true,"path":"2023/01/06/elasticsearch-4/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-4/","excerpt":"","text":"키바나(Kibana) 사용 방법에 대해 알아보겠습니다. 운영환경 Windows Kibana Version: 7.17.8 키바나를 실행합니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 서버 상태 확인 키바나의 서버 상태는 http://localhost:5601/status 에서 확인할 수 있습니다. 키바나 콘솔 사용법 키바나 Dev Tools에 있는 콘솔을 이용해 엘라스틱서치 REST API를 호출합니다. 키바나 왼쪽 상단의 토글 메뉴를 클릭하면 키바나 메뉴를 확인할 수 있는데 Management -&gt; Dev Tools를 선택하면 됩니다. 왼쪽 입력창에서 엘라스틱서치에서 제공하는 REST API를 입력하고 실행 버튼을 누르면 오른쪽 출력창에서 HTTP의 응답을 확인할 수 있습니다. 또한 키바나 콘솔은 엘라스틱서치 API 자동 완성 기능이 지원됩니다. 샘플 데이터 불러오기 엘라스틱 스택은 세 가지 샘플 데이터를 기본으로 제공합니다. 키바나에서 아주 쉽게 가능합니다. 샘플 데이터를 불러와서 검색 테스트를 할 수 있습니다. 키바나의 홈 화면에서 Try sample data 링크를 클릭합니다. 샘플 데이터를 추가할 수 있는 화면입니다. 총 3개의 심플 데이터(Sample eCommerce orders, Sample flight data, Sample web logs)가 있고, 각 샘플 데이터마다 Add data 버튼을 클릭해서 샘플을 추가할 수 있습니다. 샘플 데이터를 추가하면 키바나의 Visualize(시각화)와 Daashboard(대시보드) 등에도 샘플들이 함께 추가됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Kibana] 윈도우에 설치 및 실행 방법","slug":"elasticsearch-3","date":"2023-01-06T05:18:22.000Z","updated":"2024-01-12T06:41:22.805Z","comments":true,"path":"2023/01/06/elasticsearch-3/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-3/","excerpt":"","text":"Kibana(키바나): 시각화와 엘라스틱서치 관리 도구 키바나는 오픈서치의 자유-오픈 소스 후계자가 오픈서치 대시보드인 일래스틱서치용의 소스 이용이 가능한 데이터 시각화 대시보드 소프트웨어이다. 일래스틱서치 클러스터에 색인된 내용 기반의 시각화 기능을 제공한다. 사용자는 막대, 선, 산점도 플롯, 원 그래프, 지도를 다량의 데이터에 맞추어 만들 수 있다. 위키백과 엘라스틱서치는 REST API가 잘 설계된 제품이긴 하지만 복잡한 요청을 일일이 작성하기 에는 다소 불편할 수 있습니다. 키바나는 이런 불편함을 해소해 줍니다. 엘라스틱서치에 대한 대부분의 관리 기능, API를 실행할 수 있는 콘솔, 솔루션 페이지들, 모니터링 페이지 등이 모두 카바나에 포함되어 있습니다. 개요 윈도우 환경에서 Kibana 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 엘라스틱서치와 동일하게 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/kibana 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치할 것이므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드 받습니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 kibana-7.17.8-windows-x86_64 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치 같은 실행 관련 파일들이 있습니다. config 폴더에는 설정 파일(kibana.yml)과 기타 설정 관련 파일들이 있습니다. 실행하기 키바나를 실행해 봅니다. 키바나를 실행하기 전에 반드시 엘라스틱서치를 먼저 실행하고 나서 실행해야 합니다. bin 폴더에 있는 kibana.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\kibana-7.17.8-windows-x86_64&gt; .\\bin\\kibana.bat 기본적으로 포그라운드로 실행됩니다. 확인하기 키바나가 정상적으로 실행되면 동작 여부를 웹 브라우저에서 확인할 수 있습니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 다음과 같이 키바나 웹 페이지가 나왔다면 정상 동작하는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(8.X 버전)","slug":"elasticsearch-2","date":"2023-01-06T01:08:14.000Z","updated":"2024-01-12T06:40:48.579Z","comments":true,"path":"2023/01/06/elasticsearch-2/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-2/","excerpt":"","text":"윈도우 환경에서 Elasticsearch 8.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 8.X 대 버전을 설치하므로 Windows 버튼을 클릭하여 다운로드합니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-8.5.3 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. 실행하기 엘라스틱서치를 실행해 봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch.bat 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 12C:\\elasticsearch-8.5.3&gt; curl -X GET \"localhost:9200/?pretty\"curl: (52) Empty reply from server 명령을 실행했지만 Elasticsearch 7.X 대 버전과는 다르게 연결이 되지 않습니다. Elasticsearch 8.X 대 버전으로 업데이트되면서 https를 사용하는 방식으로 변경되었습니다. 해결하기 엘라스틱서치를 실행하면 명령 프롬프트 마지막에 다음과 같이 출력된 것을 확인할 수 있습니다. curl을 사용하여 확인하기 위해서는 user와 password를 추가로 입력하면 됩니다. 1curl -u [user]:[password] https://localhost:9200 -k user는 기본적으로 elastic이고, password는 위에서 나온 정보를 입력하여 실행합니다. 123456789101112131415161718C:\\elasticsearch-8.5.3&gt; curl -u elastic:yJ454NS-=mdaBI9bBVM= https://localhost:9200 -k&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Ne40oBP9Td2u-XLohcOFxQ\", \"version\" : &#123; \"number\" : \"8.5.3\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"4ed5ee9afac63de92ec98f404ccbed7d3ba9584e\", \"build_date\" : \"2022-12-05T18:22:22.226119656Z\", \"build_snapshot\" : false, \"lucene_version\" : \"9.4.2\", \"minimum_wire_compatibility_version\" : \"7.17.0\", \"minimum_index_compatibility_version\" : \"7.0.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치가 잘 실행된 것을 확인할 수 있습니다. 브라우저에서 http가 아닌 https로 변경된 https://localhost:9200 로 접속해서 확인할 수 있습니다. “고급” 버튼을 눌러 안전하지 않은 사이트로 이동하여 접속합니다. elatic 계정과 비밀번호를 입력하면 아래 그림과 같이 정보를 확인할 수 있습니다. 비밀번호 변경 elastic 계정의 비밀번호를 변경하려면 다음의 명령을 실행합니다. 12345678C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch-reset-password -u elasticThis tool will reset the password of the [elastic] user to an autogenerated value.The password will be printed in the console.Please confirm that you would like to continue [y/N]yPassword for the [elastic] user successfully reset.New value: ubj9aU+XNNsqV0VKkWLx 명령을 실행하고 y를 입력하면 새로운 비밀번호가 생성됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(7.X 버전)","slug":"elasticsearch-1","date":"2023-01-05T06:50:51.000Z","updated":"2024-01-12T06:39:32.952Z","comments":true,"path":"2023/01/05/elasticsearch-1/","link":"","permalink":"http://hgko1207.github.io/2023/01/05/elasticsearch-1/","excerpt":"","text":"Elasticsearch(엘라스틱서치): 분산 검색 엔진 루씬 기반의 검색 엔진이다. HTTP 웹 인터페이스와 스키마에서 자유로운 JSON 문서와 함께 분산 멀티테넌트 지원 전문 검색 엔진을 제공한다. 일래스틱서치는 자바로 개발되어 있으며 아파치 라이선스 조항에 의거하여 오픈 소스로 출시되어 있다. 위키백과 엘라스틱서치는 모든 레코드를 JSON 도큐먼트 형태로 입력하고 관리하고 있으며, 일반적인 데이터베이스와 마찬가지로, 쿼리 한 결과에 대해 일치하는 원본 도큐먼트를 반환합니다. 또한 엘라스틱서치는 텍스트 외에도 숫자, 날짜, IP 주소, 지리 정보 등 다양한 데이터 타입에 대해 최적화되어 있습니다. 또한 엘라스틱서치는 사용자의 모든 입력을 REST API 형태로 받아들이기 때문에 별도의 드라이버 라이브러리가 없더라도 웹 브라우저나 curl 명령어를 이용해 기능을 활용할 수 있습니다. 개요 윈도우 환경에서 Elasticsearch 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치하므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드합니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-7.17.8 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치나 키 생성 등의 실행 작업을 위한 파일들이 있습니다. config 폴더에는 설정 파일(elasticsearch.yml)을 포함하여 설정에 관한 파일들이 있습니다. 실행하기 엘라스틱서치를 실행해 봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-7.17.8&gt; .\\bin\\elasticsearch.bat 기본적으로 포그라운드로 실행되고 로그를 출력합니다. 백그라운드로 실행을 원할 경우 실행 명령문 뒤에 -d를 추가하면 됩니다. 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 123456789101112131415161718C:\\elasticsearch-7.17.8&gt; curl -X GET \"localhost:9200/?pretty\"&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Qd8gx2FzSnyFb4zCvx9C6Q\", \"version\" : &#123; \"number\" : \"7.17.8\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"120eabe1c8a0cb2ae87cffc109a5b65d213e9df1\", \"build_date\" : \"2022-12-02T17:33:09.727072865Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.11.1\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치는 기본적으로 9200 포트를 사용하는데, localhost:9200 주소에 GET 메서드 요청을 해서 응답이 있다면 엘라스틱서치가 정상적으로 실행된 것입니다. 응답 결과를 JSON 형태로 보여주는데, URL 뒤에 ?pretty를 추가하면 가독성 좋은 형태로 결과를 보여줍니다. 브라우저에서 http://localhost:9200 로 접속해서 확인 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Gatsby] Page Query","slug":"react-17","date":"2023-01-04T14:45:56.000Z","updated":"2024-01-12T06:37:13.039Z","comments":true,"path":"2023/01/04/react-17/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-17/","excerpt":"","text":"gatsby-source-filesystem 로컬 파일 시스템에서 Gatsby 애플리케이션으로 데이터를 sourcing 하기 위한 Gatsby 소스 플러그인입니다. 플러그인은 파일에서 파일 노드를 생성합니다. 다양한 “transformer” 플러그인은 파일 노드를 다양한 다른 유형의 데이터로 변환할 수 있습니다. Markdown, JSON, 이미지, YAML, CSV 및 기타 수집 가지 데이터 유형이 지원됩니다. 설치 1npm install gatsby-source-filesystem 사용 방법 예시로 blog-posts 디렉토리를 생성하고 디렉터리 안에 post1.md, post2.md 파일을 생성합니다. gatsby-config.ts 파일의 plugin 부분을 다음과 같이 수정합니다. path 속성 값에는 생성한 blog-posts 디렉토리를 입력합니다. 12345678910111213141516// gatsby-config.jsimport type &#123; GatsbyConfig &#125; from 'gatsby';const config: GatsbyConfig = &#123; ... plugins: [ &#123; resolve: `gatsby-source-filesystem`, options: &#123; path: `$&#123;__dirname&#125;/blog-posts`, &#125;, &#125;, ],&#125;;export default config; GraphQL 쿼리를 해보면 nodes에 생성한 파일명들이 조회됩니다. 1234567query MyQuery &#123; allFile &#123; nodes &#123; name &#125; &#125;&#125; 12345678910111213141516// 결과&#123; \"data\": &#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125; &#125;, \"extensions\": &#123;&#125;&#125; index.tsx 파일에서 쿼리를 추가하고 별다른 작성 없이 props에 data를 선언하기만 하면 Gatsby 가 자동으로 쿼리 결과를 가져올 수 있도록 도와줍니다. TypeScript를 사용한다면 PageProps&lt;Queries.BlogTitlesQuery&gt; 타입을 지정합니다. 1234567891011121314151617181920212223import &#123; graphql, PageProps &#125; from 'gatsby';import React from 'react';export default function IndexPage(&#123; data &#125;: PageProps&lt;Queries.BlogTitlesQuery&gt;) &#123; console.log(data); return ( &lt;ul&gt; &#123;data.allFile.nodes.map((file, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;file.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export const query = graphql` query BlogTitles &#123; allFile &#123; nodes &#123; name &#125; &#125; &#125;`; 12345678910111213// data object&#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125;&#125; 결론 위와 같이 gatsby-source-filesystem 플러그인을 사용하여 Gatsby 가 생성한 파일들을 관찰할 수 있게 허용해 주고 쿼리를 통해 더 많은 정보를 조회할 수 있도록 도와줍니다. 참고 https://www.gatsbyjs.com/plugins/gatsby-source-filesystem","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"}]},{"title":"[Gatsby] useStaticQuery(정적 쿼리 사용)","slug":"react-16","date":"2023-01-04T14:09:13.000Z","updated":"2024-01-12T06:36:24.020Z","comments":true,"path":"2023/01/04/react-16/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-16/","excerpt":"","text":"useStaticQuery useStaticQuery는 빌드 시 리액트 훅을 사용하여 Gatsby의 GraphQL 데이터 계층을 쿼리 하는 기능을 제공합니다. 이를 통해 React 컴포넌트는 구문 분석, 평가 및 컴포넌트에 삽입될 GraphQL 쿼리를 통해 데이터를 검색할 수 있습니다. useStaticQuery 훅은 모든 컴포넌트 또는 페이지에서 사용할 수 있습니다. 123456789const data = useStaticQuery(graphql` query HeaderQuery &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 사용 방법 TypeScript를 사용하고 gatsby-config.ts 파일에서 GraphQL 타입 생성에 관한 항목인 graphqlTypegen 값이 true로 설정되어 있다면 Gatsby가 쿼리를 읽고서 자동적으로 맞는 타입을 생성합니다. gatsby-types.d.ts 파일을 열어서 보면 정의한 쿼리를 읽고 자동 타입 생성을 해버렸음을 확인 할 수 있습니다. 12345678910// useStaticQuery 정의const data = useStaticQuery(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 12// gatsby-types.d.tstype SeoDataQuery = &#123; readonly site: &#123; readonly siteMetadata: &#123; readonly title: string | null &#125; | null &#125; | null &#125;; 이렇게 자동 타입이 생성되었다면 Queries를 사용하여 SeoDataQuery를 찾아 타입을 부여합니다. TypeScript 자동완성이 제공됩니다. 123456789101112const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;( graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `);console.log(data.site?.siteMetadata?.title); 전체 코드 GraphQL 쿼리를 통해 조회해서 Title를 설정하는 코드입니다. 1234567891011121314151617181920212223import &#123; graphql, useStaticQuery &#125; from 'gatsby';import React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `); return ( &lt;title&gt; &#123;title&#125; | &#123;data.site?.siteMetadata?.title&#125; &lt;/title&gt; );&#125; 참고 https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/ https://www.gatsbyjs.com/docs/reference/graphql-data-layer/graphql-api/#usestaticquery GraphQL Typegen","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"}]},{"title":"SHACL(Shapes Constraint Language) 란","slug":"shacl","date":"2023-01-04T06:47:24.000Z","updated":"2024-01-12T06:38:05.336Z","comments":true,"path":"2023/01/04/shacl/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/shacl/","excerpt":"","text":"데이터를 검증하는 데 사용되는 SHACL(Shapes Constraint Language)에 대해 공부하고 정리한 내용입니다. SHACL(Shapes Constraint Language) 란 Shapes Constraint Language(SHACL)는 RDF(Resource Description Framework) 그래프를 설명하기 위한 W3C(World Wide Web Consortium) 표준 언어입니다 . SHACL은 RDF 그래프로 표현되는 온톨로지의 의미 체계 및 기술 상호 운용성 계층을 향상하도록 설계되었습니다. SHACL 모델은 그래프의 내용, 구조 및 의미에 대한 제약 조건으로 정의됩니다. SHACL은 표현력이 뛰어난 언어입니다. 무엇보다도 속성이 가질 수 있는 값의 수, 이러한 값의 유형, 숫자 범위, 문자열 일치 패턴 및 이러한 제약 조건의 논리적 조합을 제한하는 조건을 표현하는 기능이 포함되어 있습니다. SHACL에는 SPARQL 및 JavaScript 와 같은 언어로 보다 복잡한 조건을 표현하는 확장 메커니즘도 포함되어 있습니다 . SHACL 규칙은 SHACL에 추론 기능을 추가하여 사용자가 기존(어설션된) 문에서 추론할 수 있는 새 문을 정의할 수 있도록 합니다. 위키백과 2017년 7월 20일 이후 W3C 권장 사항(https://www.w3.org/TR/shacl/) RDF 언어 사용 RDF의 검증을 허용하도록 생성되었습니다. SHACL은 데이터를 검증하는 데 사용되는 &quot;Shapes Graph&quot;를 정의합니다. RDF(Resource Description Framework) 란 RDF는 자원의 정보를 표현하고 상호 연결 및 교환하기 위하여 월드 와이드 웹 컨소시움(W3C)에 의해 개발되고 있는 언어 규격이다. 여기서 말하는 자원이란 웹상에 존재하는 대부분의 객체를 의미하는 것으로, 사람이나 웹페이지, 저작물과 같은 특정 지을 수 있는 개체들이 해당된다. RDF는 이러한 자원들의 메타데이터를 표현하기 위하여 개발된 규격으로, 예를 들어 웹페이지라면 제목, 저자, 수정날짜와 같은 정보가 RDF로 서술하는 대상이 된다. 나무위키 SHACL Validation SHACL Processor 두 개의 입력 데이터를 넣고 검증합니다. shapes graph(확인하는 방법), data graph(검증 대상) SHACL Processor는 graph를 변경해서는 안됩니다. 즉, 유효성 검사 종료 시 data 및 shapes graph는 유효성 검사 시작 시 graph와 동일해야 합니다. 결과 graph를 생성합니다. Shape 이란 targets(대상) 및 contraints(제약 조건) 모음입니다. Targets: data graph에서 어떤 노드가 shape을 준수해야 하는지 정의합니다. Constraint: 노드를 검증하는 방법을 정의합니다. Shapes and Constraints Targets (of a shape) Data Graph에서 어떤 노드가 형태를 따라야 하는지 정의합니다. Target 선언은 어떤 리소스(RDF 그래프 노드)가 Shape의 &quot;Focus Node&quot;가 될 것인지를 정의합니다. Property Description sh:targetClass 지정된 클래스의 인스턴스인 모든 리소스를 대상으로 합니다. 예) sh:targetClass schema:Person; sh:targetNode 특정 리소스(예: 주어진 인스턴스)를 대상으로 합니다. 예) sh:targetNode ex:John; Node Shapes 노드(클래스)에 대한 제약 조건을 지정합니다. Property Shapes을 그룹화하는데 사용됩니다. sh:NodeShape의 SHACL 인스턴스로 선언하는 것이 권장되지만 필수는 아닙니다. sh:NodeShape의 SHACL 인스턴스는 sh:path 속성 값을 가질 수 없습니다. 12345schema:ExampleNodeShape e a sh:NodeShape sh:targetClass schema:Example ; sh:property [ ... ] Property Shapes 속성 및 해당 값에 대한 제약 조건을 지정합니다. 1234567sh:property [ sh:path schema:name ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string ; sh:maxLength 20 ;] ; Core Constraint Components SHACL 프로세서에서 지원해야 하는 기본 제공 SHACL Core 제약 조건 구성 요소를 정의합니다. Type Constraints Types of values class, datatype, nodeKind Cardinality minCount, maxCount Values node, in, hasValue Range of values minInclusive, maxInclusive, minExclusive, maxExclusive String based minLength, maxLength, pattern, languageIn, uniqueLang Logical constraints not, and, or, xone Closed shapes closed, ignoredProperties Property pair constraints equals, disjoint, lessThan, lessThanOrEquals Non-validating constraints name, description, group, order, defaultValue Qualified shapes qualifiedValueShape, qualifiedMinCount, qualifiedMaxCount Value Type Constraint Components Value 노드의 유형을 제한하는 데 사용합니다. Property Description sh:class 주어진 클래스의 인스턴스인 노드로 제한합니다. sh:datatype 노드의 데이터 유형을 주어진 값으로 제한합니다. (예: xsd:integer) sh:nodeKind 각 값 노드의 RDF 노드 종류가 만족할 조건을 지정합니다. 가능한 값: BlankNode, IRI, Literal, BlankNodeOrIRI, BlankNodeOrLiteral, IRIOrLiteral 123456&lt;!-- sh:class --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:class :Person; ] . 123456&lt;!-- sh:datatype --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:birthDate ; sh:datatype xsd:date; ] . sh:datatype 에 대한 데이터 유형은 XMLSchema를 참고하여 지정합니다. The XML Schema Built-in Datatypes 1234567891011&lt;!-- sh:nodeKind --&gt;schema:Person a sh:NodeShape ; sh:nodeKind sh:IRI ; sh:property [ sh:path schema:knows ; sh:nodeKind sh:BlankNodeOrIRI; ]; sh:property [ sh:path schema:name ; sh:nodeKind sh:BlankNodeOrLiteral; ] . Cardinality Constraint Components Value 노드 수에 대한 제한을 나타냅니다. Property Description minCount 지정된 속성의 최소 발생 횟수를 제한합니다. 기본값: 0 maxCount 지정된 속성의 최대 발생 횟수를 제한합니다. 기본값: 0 123456schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:minCount 1; sh:maxCount 2; ] . Value Range Constraint Components &lt;, &lt;=, &gt; 및 &gt;= 와 같은 연산자를 통해 비교할 수 있는 값 노드가 충족할 값 범위 조건을 지정합니다. Property Description minInclusive 최소 포함(Inclusive) 값, &lt;= maxInclusive 최대 포함(Inclusive) 값, &gt;= minExclusive 최소 독점(Exclusive) 값, &lt; maxExclusive 최대 독점(Exclusive) 값, &gt; 1234567schema:Rating a sh:NodeShape; sh:property [ sh:path schema:ratingValue ; sh:minInclusive 1; sh:maxExclusive 6; sh:datatype xsd:integer; ] ;. String-based Constraint Components Value 노드의 문자열 표현에 대한 조건을 지정한다는 공통점이 있습니다. Property Description minLength 최소 문자열 길이를 제한합니다. maxLength 최대 문자열 길이를 제한합니다. pattern 문자열 값이 정규 표현식과 일치하는지 확인합니다. uniqueLang 동일한 언어 태그를 사용하는 노드 쌍이 없는지 확인합니다. languageIn 속성 값이 주어진 언어 목록으로 표현되는지 확인합니다. 1234567&lt;!-- sh:minLength, sh:maxLength --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:name ; sh:minLength 4; sh:maxLength 15; ] . 123456&lt;!-- sh:pattern --&gt;schema:Product a sh:NodeShape; sh:property [ sh:path schema:productID ; sh:pattern \"^P\" ; &lt;!-- P or p로 시작하는지 확인 --&gt; ] . 1234567&lt;!-- sh:uniqueLang, sh:languageIn --&gt;schema:Country a sh:NodeShape; sh:property [ sh:path schema:name ; sh:languageIn (\"en\" \"ex\") ; sh:uniqueLang true ; ] . Property Pair Constraint Components 다른 속성과 관련하여 값 노드 집합에 대한 조건을 지정합니다. Property Description equals 지정된 Focus 노드에서 두 속성의 값 집합은 동일해야 합니다. disjoint 지정된 Focus 노드에서 두 속성의 값 집합은 달라야 합니다. lessThan 값은 다른 속성 값보다 작아야 합니다. lessThanOrEquals 값은 다른 속성의 값보다 작거나 같아야 합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:givenName ; sh:equals foaf:firstName ; ] ; sh:property [ sh:path schema:givenName ; sh:disjoint schema:lastName ; ] . Logical Constraint Components 공통 논리 연산자 and, or 및 not과 xor(Exclusive-OR)을 구현합니다. Property Description not 각 노드가 주어진 Shape을 따를 수 없다는 조건을 준수하는지 확인합니다. and 각 노드가 제공된 모든 Shape을 준수하는 조건을 준수하는지 확인합니다. or 각 노드가 제공된 Shape 중 하나 이상 또는 둘 다를 준수하는지 확인합니다. xone 각 노드가 제공된 Shape 중 정확히 하나를 준수한다는 조건을 준수하는지 확인합니다 1234567&lt;!-- sh:not --&gt;schema:Person a sh:NodeShape; sh:not [ sh:path foaf:name ; sh:minCount 1; ] . 12345678910111213141516&lt;!-- sh:and --&gt;schema:Person a sh:NodeShape; sh:and ( [ sh:property [ sh:path schema:name ; sh:minCount 1; ] ] [ sh:property [ sh:path schema:affiliation ; sh:MinCount 1; ] ] ) . 123456789101112&lt;!-- sh:or --&gt;schema:Person a sh:NodeShape; sh:or ( [ sh:path foaf:name ; sh:minCount 1 ; ] [ sh:path schema:name ; sh:minCount 1 ; ] ) . 1234567891011121314151617181920&lt;!-- sh:xone --&gt;schema:Person a sh:NodeShape; sh:xone ( [ sh:property [ sh:path ex:fullName ; sh:minCount 1; ] ] [ sh:property [ sh:path ex:firstName ; sh:minCount 1 ; ] ; sh:property [ sh:path ex:lastName ; sh:minCount 1 ; ] ] ). Shape-based Constraint Components 특정 Shape에 대해 Value 노드의 유효성을 검사하여 복잡한 조건을 지정하는 데 사용할 수 있습니다. Property Description node 주어진 속성의 모든 값은 주어진 Shape을 준수해야 합니다. qualifiedValueShape 지정된 노드 수가 준수해야 하는 Shape을 정의합니다. qualifiedMinCount Shape에 맞는 최소 노드 수 qualifiedMaxCount Shape에 맞는 최대 노드 수 123456789101112&lt;!-- sh:node --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:node schema:Company; ].schema:Company a sh:Shape ; sh:property [ sh:path schema:name ; sh:datatype xsd:string ; ] . 12345678910111213&lt;!-- sh:qualifiedValueShape, sh:qualifiedMinCount --&gt;schema:QualifiedExampleShape a sh:NodeShape; sh:targetNode :Offspring ; sh:property [ sh:path :parent; sh:minCount 2; sh:maxCount 2; sh:qualifiedValueShape [ sh:path :gender ; sh:hasValue :Female ; ] ; sh:qualifiedMinCount 1 ; ] . Closed Constraint Components Shape에 명시적으로 열거된 속성에 대한 값만 갖는 조건을 지정합니다. Property Description closed true로 설정하면 Shape에 명시적으로 설명되지 않은 속성은 허용되지 않습니다. ignoredProperties Shape에 명시적으로 열거된 속성 외에 허용되는 속성의 Optional 목록입니다. 123456789schema:Person a sh:NodeShape; sh:closed true ; sh:ignoredProperties (rdf:type) ; sh:property [ sh:path ex:firstName ; ] ; sh:property [ sh:path ex:lastName ; ] . Non-Validating Constraint 유효성 검사 조건에서 무시되는 속성입니다. Property Description name 속성 라벨명을 정의합니다. description 속성에 대한 설명을 정의합니다. order 속성의 상대적 순서를 정의합니다. group 그룹을 정의합니다. 12345678910111213schema:Person a sh:NodeShape; sh:property [ sh:path schema:url; sh:name \"URL\"; sh:description \"User URL\"; sh:order 1; ] ; sh:property [ sh:path schema:name; sh:name \"Name\"; sh:description \"Person name\"; sh:order 2; ] . Other Constraint Components Property Description hasValue Focus 노드에 주어진 값이 있는지 확인합니다. in 속성이 가질 수 있는 값 옵션을 열거합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:hasValue :OurCompany; ]; sh:property [ sh:path schema:gender ; sh:in (schema:Male schema:Female); ] . 참고 Shapes Constraint Language (SHACL) Informatiemodellering met SHACL SHAPES CONSTRAINT LANGUAGE – SHACL SHACL validation with pySHACL","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"}]},{"title":"[Gatsby] Head API","slug":"react-15","date":"2023-01-03T14:26:44.000Z","updated":"2024-01-12T06:36:01.705Z","comments":true,"path":"2023/01/03/react-15/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-15/","excerpt":"","text":"Gatsby Head API Gatsby 에는 페이지의 문서 헤드에 요소를 추가할 수 있는 내장 head가 포함되어 있습니다. react-helmet 또는 기타 유사한 솔루션과 비교할 때 Gatsby Head는 사용하기 쉽고 성능이 우수하며 번들 크기가 더 작고 최신 React 기능을 지원합니다. 12// ex)export const Head = () =&gt; &lt;title&gt;Home Page&lt;/title&gt;; SEO Component 를 사용하여 Head 함수를 정의할 수 있습니다. 12345678910// src/components/Seo.tsximport React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; return &lt;title&gt;&#123;title&#125; | Hello!&lt;/title&gt;;&#125; 123456789// index.tsximport * as React from 'react';import Seo from '../components/Seo';export default function IndexPage() &#123; return &lt;div&gt;Welcome&lt;/div&gt;;&#125;export const Head = () =&gt; &lt;Seo title=\"Home Page\" /&gt;; Usage notes Gatsby Head를 사용할 때 다음 사항에 유의해야 합니다. 컴포넌트가 아닌 페이지 내부에서만 Head export 를 정의할 수 있습니다. Gatsby Head 의 내용은 페이지 마운트 해제 시 지워지므로 각 페이지가 &lt;head&gt;에 필요한 내용을 정의하는지 확인해야 합니다. Head 함수는 유효한 JSX를 반환해야 합니다. Head 함수 내부의 유효한 태그는 link, meta, style, title, base, script 및 noscript 입니다. 참고 https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/ https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-seo-component","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"}]},{"title":"[Gatsby] Layout Components","slug":"react-14","date":"2023-01-03T14:08:22.000Z","updated":"2024-01-12T06:35:43.154Z","comments":true,"path":"2023/01/03/react-14/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-14/","excerpt":"","text":"Layout Components Gatsby는 기본적으로 레이아웃을 페이지에 자동으로 적용하지 않습니다. 대신 Layout Component를 사용하면 Header 및 Footer, 그리고 일부 페이지에서 사용하는 사이드바와 같은 여러 가지 레이아웃을 만들 수 있습니다. 또한 레이아웃과 페이지 컴포넌트 간에 데이터를 전달할 수 있습니다. 즉, Layout Component를 사용하여 여러 페이지에서 일반적으로 사용하는 Header 및 Footer의 레이아웃을 공유하도록 구성할 수 있습니다. 예제 src/components/ 디렉터리를 생성하고 Layout.tsx 파일을 생성합니다. 다음과 같이 Gatsby 의 Link를 사용하여 페이지를 이동하는 Layout Component를 구성합니다. 12345678910111213141516171819202122232425// src/components/Layout.tsximport &#123; Link &#125; from 'gatsby';import React from 'react';interface ILayoutProps &#123; children: any;&#125;export default function Layout(&#123; children &#125;: ILayoutProps) &#123; return ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/blog\"&gt;Blog&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;/div&gt; );&#125; 페이지에 레이아웃을 적용하려면 Layout Component 를 포함하고 그 안에 페이지 내용을 넣어야 합니다. 레이아웃을 페이지에 적용하는 방법은 다음과 같습니다. 12345678910111213// src/pages/index.tsximport * as React from 'react';import Layout from '../components/Layout';export default IndexPage = () =&gt; &#123; return ( &lt;Layout&gt; &lt;div&gt; &lt;h1&gt;Welcome to Home&lt;/h1&gt; &lt;/div&gt; &lt;/Layout&gt; );&#125;; 이 레이아웃이 필요한 모든 페이지와 템플릿에 대해 반복을 합니다. 참고 https://www.gatsbyjs.com/docs/how-to/routing/layout-components/ https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-link/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"}]},{"title":"[Gatsby] Routing","slug":"react-13","date":"2023-01-03T13:56:08.000Z","updated":"2024-01-12T06:34:51.144Z","comments":true,"path":"2023/01/03/react-13/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-13/","excerpt":"","text":"Routing 리액트 라우터를 사용하여 페이지를 생성하는 것과 달리 Gatsby는 src/pages 안에 각 .tsx 파일에 대한 페이지를 생성합니다. 예를 들어 src/pages/contact.tsx는 yoursite.com/contact 페이지를 생성하고 src/pages/home.tsx는 yoursite.com/home 페이지를 생성합니다. Gatsby로 Routing 하는 것은 간단하고 리액트 라우터도, 스크린도 만들 필요 없고 그 경로와 요소들을 일일이 설명할 필요도 없다는 장점이 있습니다. 123456// src/pages/index.tsximport React from 'react';export default function Index() &#123; return &lt;div&gt;Hello world&lt;/div&gt;;&#125; 참고 https://www.gatsbyjs.com/docs/reference/routing/creating-routes/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"}]},{"title":"[MySQL] 5분 단위로 그룹핑하여 평균값 계산","slug":"mysql-8","date":"2023-01-02T01:14:53.000Z","updated":"2024-01-12T06:34:32.563Z","comments":true,"path":"2023/01/02/mysql-8/","link":"","permalink":"http://hgko1207.github.io/2023/01/02/mysql-8/","excerpt":"","text":"MYSQL을 사용하여 5분 단위로 그룹핑하여 평균값 계산하는 방법에 대해 알아보겠습니다. 테이블 생성 먼저 분 단위로 그룹핑과 평균값 계산을 위해 DATETIME, FLOAT 타입이 포함된 테이블을 생성합니다. 123456CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, sensor_value FLOAT, log_time DATETIME, PRIMARY KEY(id),) ENGINE=MYISAM CHARSET=utf8; 테이블이 생성되면 값을 입력합니다. 첫 번째 방법 시간 단위로 먼저 그룹핑한 후 분단위를 5로 나누어 그룹핑합니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 1, 10), FLOOR(SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 11, 2) / 5)ORDER BY log_time; 또는 다음과 같이 SUBSTR 함수를 빼고 format을 다르게 해서 할 수 있습니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY date_format(log_time, '%Y%m%d%H'), FLOOR(date_format(log_time, '%i') / 5);ORDER BY log_time; FLOOR 함수는 가장 가까운 정수로 버림하여 반환합니다. 두 번째 방법 시간 및 분 단위로 분리하는 함수를 사용합니다. 1234SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY DATE(log_time), HOUR(log_time), FLOOR(MINUTE(log_time) / 5)ORDER BY log_time; DATE, HOUR, MINUTE 함수는 날짜, 시간, 분의 값을 반환합니다. 5분 단위 데이터 출력 123SELECT *FROM testWHERE MOD(date_format(log_time, '%i'), 5) = 0 또는 123SELECT *FROM testWHERE date_format(log_time, '%i') % 5 = 0 MOD 함수는 첫 번째 값을 두 번째 값으로 나눈 나머지를 반환합니다. 참고 date_format 함수의 두 번째 항목인 format 내용은 아래 사이트에서 자세하게 확인해 볼 수 있습니다. https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_date-format","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Gatsby] 설치 및 사용 방법","slug":"react-12","date":"2022-12-29T07:03:34.000Z","updated":"2024-01-12T06:33:25.879Z","comments":true,"path":"2022/12/29/react-12/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/react-12/","excerpt":"","text":"Gatsby 설치 및 사용 방법에 대해 알아보겠습니다. Gatsby(개츠비) 란 개츠비는 리액트 기반의 프레임워크입니다. 리액트를 이용하면서도 리액트에 새로운 규칙 몇 가지를 추가해 주면서 아주 약간의 복잡함을 더해주고 있습니다. 주로 서버사이드 렌더링을 위해 사용하는 Next.js 와는 달리 개츠비는 서버 없이, 오로지 정적 웹사이트 생성을 위해 사용하는 오픈소스 프레임워크입니다. 정적 웹 페이지, 플랫 페이지는 저장된 그대로 사용자에게 전달되는 웹 페이지로서, 이는 웹 애플리케이션에 의해 생성되는 동적 웹 페이지와 반대되는 용어이다. 즉, 정적 웹 페이지는 모든 상황에서 모든 사용자에게 동일한 정보를 표시하며, 콘텐츠 타입이나 문서 언어의 협상(negotiate)을 위해 웹 서버의 현대적 기능에 종속된다. 위키백과 서비스 및 블로그, 포트폴리오 등에서 많이 사용됩니다. 설치 Gatsby를 사용하기 위해 gatsby-cli를 설치합니다. 1$ npm install -g gatsby-cli 12Gatsby requires Node.js 18.0.0 or higher (you have v14.17.5).Upgrade Node to the latest stable release: https:&#x2F;&#x2F;gatsby.dev&#x2F;upgrading-node-js 개츠비를 사용하려면 Node.js 18 이상 버전이 필요합니다. 버전이 낮다면 위와 같은 에러가 발생합니다. 프로젝트 생성 Gatsby CLI를 사용하여 프로젝트를 만듭니다. 1$ npm init gatsby 또는 1$ gatsby new 위의 명령어를 실행하면 프로젝트 생성을 위한 여러 가지 입력하는 부분이 있습니다. 순서대로 입력하면 프로젝트가 생성됩니다. 프로젝트 명을 입력합니다. 디렉터리를 확인합니다. JavaScript 쓸 건지 TypeScript 쓸 건지 선택합니다. 사용할 CMS를 선택합니다. 사용하지 않을 경우 No를 선택합니다. 사용할 styling system(Sass, Emotion, styled-components 등…)을 선택합니다. 구글 애널리틱스, 반응형 이미지나 사이트맵 등을 추가할 것인지 묻습니다. 없다면 Done을 선택합니다. CMS 는 비개발자인 사람들이 콘텐츠를 계속 올리는 웹사이트 혹은 앱입니다. 실행 다음 명령어를 실행합니다. 12$ cd my-gatsby-site/$ npm run develop 완료가 되면 사이트를 접속해서 확인합니다. 1234...You can now view dev-stickers in the browser. http://localhost:8000/ 빌드 빌드를 진행하면 축소된 파일, 변환된 이미지, 페이지별 정보와 데이터가 있는 JSON 파일, 페이지별 정적 HTML 등이 모두 포함됩니다. 최적화가 잘되어 있어 빠르게 로드되는 정적 웹사이트를 배포할 수 있습니다. 1$ npm run build 결론 개츠비 설치와 기본적인 사용 방법에 대해서 정리하였습니다. 나만의 블로그를 만들고 싶을 때 사용하면 좋을 것 같습니다. Gatsby Plugin Library Gatsby 사이트나 앱을 커스텀할 수 있는 기능을 제공하는 라이브러리들입니다. https://www.gatsbyjs.com/plugins 참고 Documentation Tutorials Guides","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"}]},{"title":"[Spring Boot] MultipartFile transferTo() 사용 파일 저장시 주의사항","slug":"spring-4","date":"2022-12-29T04:50:03.000Z","updated":"2024-01-12T06:33:57.644Z","comments":true,"path":"2022/12/29/spring-4/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/spring-4/","excerpt":"","text":"multipart 기본 경로 Spring Boot 설정에서 spring.servlet.multipart.location를 특정 경로로 설정하지 않을 경우 기본적으로 tmp 폴더로 지정됩니다. 각 운영체제 tmp 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp Linux: \\tmp 각 운영체제 basedir 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT Linux: \\tmp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT 위와 같이 눈으로 보기에도 많이 지저분한 경로에 저장이 되므로 작업과 관리가 용이하도록 경로를 직접 설정해 주는 것이 좋습니다. 주의사항 경로 설정시 주의사항은 파일 저장 경로를 /upload로 할 경우 리눅스는 절대경로로 인식하여 /upload로 인식하지만 윈도우는 상대경로로 인식하여 basedir을 포함한 경로를 만듭니다. 결과는 C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT\\upload 입니다. 만약 C:/upload에 저장하고 싶다면 /upload가 아닌 C:/upload로 상세하게 입력해야 합니다. 1spring.servlet.multipart.location=C:/upload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"}]},{"title":"[Spring Boot] MultipartFile + Modal 사용 파일 업로드","slug":"spring-3","date":"2022-12-26T14:01:16.000Z","updated":"2023-03-14T02:26:44.705Z","comments":true,"path":"2022/12/26/spring-3/","link":"","permalink":"http://hgko1207.github.io/2022/12/26/spring-3/","excerpt":"","text":"Spring Boot에서 MultipartFile와 Bootstrap의 Modal을 사용하여 이미지 파일을 업로드하는 방법에 대해 알아보겠습니다. Spring Boot 2.6.11 버전과 Bootstrap 5를 사용하였습니다. MultipartFile MultipartFile이란 스프링에서 업로드한 파일을 표현할 때 사용되는 인터페이스입니다. 파일 내용은 메모리에 저장되거나 임시로 디스크에 저장됩니다. 요청 처리가 끝나면 임시 저장소는 지워집니다. 설정 Spring Boot application.properties 설정 파일에 파일 업로드 경로와 파일 사이즈를 설정합니다. 윈도우 기준으로 d:/upload/ 경로로 파일을 업로드합니다. 12345# 지도 파일 업로드 경로spring.servlet.multipart.location=d:/upload/spring.servlet.multipart.max-file-size=512MBspring.servlet.multipart.max-request-size=512MB spring.servlet.multipart.location: 업로드된 파일의 임시 저장 공간 spring.servlet.multipart.max-file-size: 파일의 최대 사이즈 (default: 1MB) spring.servlet.multipart.max-request-size: 요청의 최대 사이즈 (default: 10MB) html CDN을 통해 Bootstrap CSS와 JS를 포함합니다. 파일 업로드하는 모달 팝업 코드를 작성합니다. 파일 업로드 시 form 태그에 enctype=&quot;multipart/form-data&quot;를 추가하고 input 태그 타입을 file로 작성해야 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;파일 업로드 예제&lt;/title&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD\" crossorigin=\"anonymous\" /&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN\" crossorigin=\"anonymous\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#uploadModal\"&gt; 파일 업로드 &lt;/button&gt; &lt;!-- Modal --&gt; &lt;div id=\"uploadModal\" class=\"modal fade\" tabindex=\"-1\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header bg-primary text-white border-0\"&gt; &lt;h5 class=\"modal-title\"&gt;지도 등록&lt;/h5&gt; &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;form id=\"uploadForm\" method=\"POST\" action=\"/file/upload\" class=\"form-horizontal\" enctype=\"multipart/form-data\" &gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"form-group row mb-2\"&gt; &lt;label class=\"col-form-label col-md-3\"&gt;파일 &lt;/label&gt; &lt;div class=\"col-md-8\"&gt; &lt;input type=\"file\" class=\"form-control\" name=\"file\" accept=\"image/*\" required /&gt; &lt;span class=\"text-muted\"&gt; ※ 이미지 파일만 업로드 가능합니다. &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary me-2\"&gt;등록&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-light\" data-bs-dismiss=\"modal\"&gt;닫기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /Modal --&gt; &lt;/body&gt;&lt;/html&gt; JavaScript Modal와 Form을 제어하는 JavaScript 코드를 추가합니다. 12345678910111213141516171819202122232425262728// modal 닫기const modalHide = (modalId) =&gt; &#123; const modalEl = document.getElementById(modalId); const modal = bootstrap.Modal.getInstance(modalEl); modal.hide();&#125;;$('#uploadForm').submit(function (e) &#123; e.preventDefault(); const form = $(this); const url = form.attr('action'); const formData = new FormData($('#uploadForm')[0]); $.ajax(&#123; url: url, type: 'POST', data: formData, processData: false, contentType: false, success: function (response) &#123; modalHide('uploadModal'); alert('파일 업로드 성공'); &#125;, error: function (response) &#123; alert('파일 업로드 실패'); &#125;, &#125;);&#125;); Java Controller 파일을 생성합니다. 파일을 입력받고 저장하는 코드를 작성합니다. MultipartFile의 transferTo() 함수를 사용하여 파일을 저장합니다. 123456789101112131415161718192021public class FileController &#123; @PostMapping(\"file/upload\") @ResponseBody public ResponseEntity&lt;?&gt; upload(MultipartFile file) &#123; if (file != null) &#123; writeFile(file); return new ResponseEntity&lt;&gt;(HttpStatus.OK); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); &#125; /** * 파일 저장 */ private void writeFile(MultipartFile multipartFile) throws IOException &#123; File file = new File(filePath); multipartFile.transferTo(file); &#125;&#125; 파일을 업로드하는 코드를 작성해봤습니다. 파일 업로드에 대한 간략한 코드이므로 응용해서 사용할 수 있을 것 같습니다. 참고 https://getbootstrap.com/docs/5.0/components/modal/ https://www.baeldung.com/spring-multipartfile-to-file","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"}]},{"title":"[리눅스] mount --bind 사용 방법","slug":"linux-28","date":"2022-12-16T01:00:04.000Z","updated":"2024-01-12T06:32:22.563Z","comments":true,"path":"2022/12/16/linux-28/","link":"","permalink":"http://hgko1207.github.io/2022/12/16/linux-28/","excerpt":"","text":"mount 명령어는 디스크 드라이브와 같은 블록 디바이스(Block Device)만 마운트가 가능합니다. --bind 옵션을 추가하면 특정 디렉터리를 다른 디렉터리에 마운트(mount)해서 양쪽 디렉터리가 같은 곳으로 연결되도록 할 수 있습니다. 1$ mount --bind [원본 디렉토리] [붙일 디렉토리] 사용 예시 먼저 두 개의 디렉토리를 생성합니다. 12$ mkdir src$ mkdir dest --bind 또는 -B 옵션을 사용해서 src 디렉토리를 dest 디렉토리에 연결합니다. 1$ mount --bind src dest dest 디렉토리 하위에 파일을 생성을 하면 src 디렉토리에도 반영이 됩니다. 1$ touch dest/test 변경된 내용을 양쪽 모두 확인이 가능합니다. 1234$ ls desttest$ ls srctest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"}]},{"title":"[리눅스] 네트워크 설정","slug":"linux-27","date":"2022-12-14T02:41:21.000Z","updated":"2024-01-12T06:31:46.975Z","comments":true,"path":"2022/12/14/linux-27/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-27/","excerpt":"","text":"리눅스 환경에서 ifconfig를 이용하여 네트워크 설정하는 방법을 알아보겠습니다. ifconfig 란 TCP/IP를 사용하여 네트워크의 네트워크 인터페이스 매개변수를 구성 또는 표시합니다. ifconfig 명령을 사용하여 네트워크 인터페이스에 주소를 지정하고 현재 네트워크 인터페이스 구성 정보를 구성 또는 표시할 수 있습니다. IP 주소 확인 옵션 없이 ifconfig 명령어만 실행하면 서버에 할당된 IP 주소를 확인합니다. 12345678910$ ifconfigenp5s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.0.19 netmask 255.255.255.0 broadcast 192.168.0.255 inet6 fe80::d487:3f17:d845:654b prefixlen 64 scopeid 0x20&lt;link&gt; ether 1c:1b:0d:7d:36:6f txqueuelen 1000 (Ethernet) RX packets 11943615 bytes 5682003196 (5.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8140188 bytes 2132065829 (1.9 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0... IPv4주소(inet), 서브넷마스트(netmask), 브로드캐스트주소(broadcast)가 표기되고 있고, MAC주소(ether)도 표시됩니다. 네트워크 설정 IP 주소, 서브넷마스크 주소, 브로드캐스트 주소를 모두 할당하려면 다음과 같이 모든 인수와 함께 ifconfig 명령을 사용하면 됩니다. 1$ ifconfig [이더넷명] [주소] netmask [주소] broadcast [주소] 추가로 up 옵션을 추가하여 이더넷을 활성화합니다. 1$ ifconfig [이더넷명] up 다음 예제는 eth0 에 IP 주소를 192.168.0.250, 서브넷마스크 주소를 255.255.255.0, 브로드캐스트 주소를 192.168.0.255 설정하고 활성화하는 명령어입니다. 1$ ifconfig eth0 192.168.0.250 netmask 255.255.255.0 broadcast 192.168.0.255 up 위의 방법으로 설정을 하면 물리적으로 변경된 것이 아니라 시스템 메모리상에서 로딩된 리눅스 커널이 사용하고 있는 랜카드 드라이브의 네트워크 설정이 바뀌는 것입니다. 따라서 시스템을 재부팅하고 나면 설정이 사라집니다. 고정 네트워크 설정 IP 주소를 고정하기 위해 설정을 해야 합니다. /etc/sysconfig/network 시스템 전체에 대한 Global 한 기본 게이트웨이 주소 설정과 호스트네임, 네트워킹 연결 허용 여부를 설정합니다. 123456$ vi /etc/sysconfig/networkNETWORKING=yesNETWORKING_IPV6=noHOSTNAME=hgko.comGATEWAY=192.168.0.1 /etc/resolv.conf 네임서버 설정과 기본적으로 사용할 도메인명을 설정합니다. 호스트명만 지정하였을 경우에 호스트명을 search 항목에 지정하여 도메인명으로 사용합니다. 1$ vi /etc/resolv.conf 1234# Generated by NetworkManagersearch hgko.comnameserver 168.126.63.1nameserver 168.126.63.2 /etc/sysconfig/network-script/ 시스템에서 사용하는 모든 이더넷 설정파일은 /etc/sysconfig/network-script/ 디렉토리에 존재합니다. 시스템에 설치되어 있는 기본 이더넷카드의 파일을 열고 고정 IP 부여를 위해 수정합니다. 1$ vi /etc/sysconfig/network-script/ifcfg-eth0 123456789101112131415161718192021222324# 장치명, 첫번째 이더넷카드DEVICE=eth0# IP 부여 방식 결정, static 은 고정IPBOOTPROTO=static# 이더넷카드의 MAC 주소HWADDR=XX:XX:XX:XX:XX:XX# 고유ID를 부여하는 것으로 자동으로 부여됨UUID=XXXXXXX-XXX-XXX-XXX-XXXXXXX# Ethernet 에 대한 설정TYPE=Ethernet# IP 주소 지정IPADDR=192.168.0.250# 서브넷마스크 지정NETMASK=255.255.255.0# 브로드캐스트 지정BROADCAST=192.168.0.255# 네트워크 지정NETWORK=192.168.0.0# 일반사용자의 eth0 제어 가능여부USERCTL=no# IPV6 사용여부IPV6INIT=no# 시스템 시작시 자동으로 활성화ONBOOT=yes 설정 적용 시스템을 재부팅하거나 재부팅하지 않고 변경사항을 적용하는 명령어를 실행합니다. 1$ /etc/rc.d/init.d/network restart 또는 1$ service network restart 참고 https://www.ibm.com/docs/ko/aix/7.2?topic=i-ifconfig-command","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"}]},{"title":"[CentOS] netstat 사용 포트 확인","slug":"linux-26","date":"2022-12-14T01:35:12.000Z","updated":"2024-01-12T06:30:58.009Z","comments":true,"path":"2022/12/14/linux-26/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-26/","excerpt":"","text":"리눅스 환경에서 netstat 명령어를 사용하여 네트워크 정보를 확인하는 방법에 대해 알아보겠습니다. netstat 란 netstat는 전송 제어 프로토콜, 라우팅 테이블, 수많은 네트워크 인터페이스, 네트워크 프로토콜 통계를 위한 네트워크 연결을 보여주는 명령 줄 도구이다. 위키백과 netstat는 네트워크 관련한 정보를 보는 유틸리티로 오래전부터 Unix 계열의 운영체제에서 사용되어 왔으며 현재 LISTEN 중인 포트, 모든 내외부/연결 정보 등을 확인할 수 있습니다. 자주 사용하는 netstat 옵션 -a : 모든 소켓보기, 이 옵션이 없으면 상태가 ESTABLISHED 인 것만 나옵니다. --all 옵션과 동일합니다. -n : 도메인 주소를 읽어들이지 않고 숫자로 출력합니다. -p : PID(프로세스 ID) 와 사용 중인 프로그램명이 출력됩니다. netstat 옵션 -c : 현재 실행 명령을 매 초마다 실행 -l : listen 하고 있는 포트만 보여줌 -i : 내트워크 트래픽정보 모니터링 -t : tcp 로 연결된 내용 출력 -u : udp 로 연결된 내용 출력 -r : 라우팅 테이블을 출력 -s : 프로토콜별 통계 정보 netstat State LISTEN : 서버에 프로세스가 실행되어 있으며 클라이언트의 접속 요청을 기다리는 상태 ESTABLISED : 서버와 클라이언트간에 세션 연결이 성립되어 통신이 이루어지는 상태 CLOSE_WAIT : TCP 연결이 상위 레벨로부터 연결 종료를 기다리는 상태 TIME_WAIT : 연결은 종료 되었지만 특정시간 동안 소켓을 열어놓은 상태 CLOSE : 연결이 종료된 상태 모든 소켓 확인 12345678910111213141516$ netstat -aActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:sunrpc 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:wap-wsp 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:vrace 0.0.0.0:* LISTENtcp 0 0 localhost.locald:domain 0.0.0.0:* LISTEN...Active UNIX domain sockets (servers and established)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ] DGRAM 41808 @000f7unix 2 [ ACC ] STREAM LISTENING 46336 @/tmp/.ICE-unix/2446unix 2 [ ACC ] STREAM LISTENING 40451 /var/run/docker/metrics.sockunix 2 [ ACC ] STREAM LISTENING 42868 @/tmp/dbus-i51dyYJlx0... TCP 포트 목록 특정 문자열이 포함된 포트를 확인할 수 있습니다. 다음의 예시는 0 0.0.0.0 또는 0 ::: 문자열이 포함된 TCP 포트 목록을 출력하는 명령어입니다. 12345678910$ netstat -nlpt | egrep \"0 (0.0.0.0|:::)\"or$ netstat -anp | grep ^tcp | egrep \"0 (0.0.0.0|:::)\"tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 951/sshdtcp 0 0 :::22 :::* LISTEN 951/sshdtcp6 0 0 :::8080 :::* LISTEN 6959/javatcp6 0 0 :::8009 :::* LISTEN 6959/javatcp6 0 0 :::3306 :::* LISTEN 2025/mariadbd... 포트 &amp; 프로세스 목록 LISTEN 중인 포트 및 프로세스명만 확인하려면 다음과 같은 명령을 사용합니다. 1234567$ netstat -anp | grep \"LISTEN \" | grep -v 127.0.0.1 | sed 's/:::/0 /g' | sed 's/[:\\/]/ /g' | awk '&#123;print $5\"\\t\"$10&#125;' | sort -ug22 sshd8009 java8080 java3306 mysqld...","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"}]},{"title":"[CentOS] PM2 서비스 등록","slug":"linux-25","date":"2022-12-09T08:23:14.000Z","updated":"2024-01-12T06:29:03.302Z","comments":true,"path":"2022/12/09/linux-25/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/linux-25/","excerpt":"","text":"리눅스 환경에서 PM2 서비스 등록하는 방법에 대해 알아보겠습니다. PM2에서는 시스템이 부팅되고 나서 자동으로 실행되도록 하는 서비스를 등록해 주는 startup 명령어가 있습니다. pm2 등록 12$ pm2 start [파일명] --name test$ pm2 list 서비스 등록 pm2 startup 명령어를 사용하여 PM2 서비스를 등록합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142$ pm2 startup[PM2] Init System found: systemdPlatform systemdTemplate[Unit]Description=PM2 process managerDocumentation=https://pm2.keymetrics.io/After=network.target[Service]Type=forkingUser=rootLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityEnvironment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/binEnvironment=PM2_HOME=/root/.pm2PIDFile=/root/.pm2/pm2.pidRestart=on-failureExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrectExecReload=/usr/lib/node_modules/pm2/bin/pm2 reload allExecStop=/usr/lib/node_modules/pm2/bin/pm2 kill[Install]WantedBy=multi-user.targetTarget path/etc/systemd/system/pm2-root.serviceCommand list[ 'systemctl enable pm2-root' ][PM2] Writing init configuration in /etc/systemd/system/pm2-root.service[PM2] Making script booting at startup...[PM2] [-] Executing: systemctl enable pm2-root...Created symlink from /etc/systemd/system/multi-user.target.wants/pm2-root.service to /etc/systemd/system/pm2-root.service.[PM2] [v] Command successfully executed.+---------------------------------------+[PM2] Freeze a process list on reboot via:$ pm2 save[PM2] Remove init script via:$ pm2 unstartup systemd pm2 save 명령어를 통해 재부팅 시 프로세스 목록을 고정시킵니다. 123$ pm2 save[PM2] Saving current process list...[PM2] Successfully saved in /root/.pm2/dump.pm2 PM2 서비스를 시작합니다. 12345678910111213$ sudo systemctl start pm2-root.service$ systemctl status pm2-root.service● pm2-root.service - PM2 process manager Loaded: loaded (/etc/systemd/system/pm2-root.service; enabled; vendor preset: disabled) Active: active (running) since 금 2022-12-09 17:14:27 KST; 5min ago Docs: https://pm2.keymetrics.io/ Process: 18456 ExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrect (code=exited, status=0/SUCCESS) Main PID: 13515 (PM2 v5.2.0: God) Tasks: 0 Memory: 0B CGroup: /system.slice/pm2-root.service ‣ 13515 PM2 v5.2.0: God Daemon (/root/.pm2)... 시스템 재부팅 후 서비스를 확인합니다. 1$ sudo reboot 1$ pm2 list","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"메타마스크(MetaMask) 설치 및 사용 방법","slug":"blockchain-2","date":"2022-12-09T03:59:18.000Z","updated":"2024-01-12T06:28:43.382Z","comments":true,"path":"2022/12/09/blockchain-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/blockchain-2/","excerpt":"","text":"메타마스크 설치 및 사용 방법에 대해 알아보겠습니다. 메타마스크(MetaMask) 란 Ethereum 블록체인과 상호 작용하는 데 사용되는 소프트웨어 암호 화폐 지갑입니다. 이를 통해 사용자는 브라우저 확장 프로그램이나 모바일 앱을 통해 이더리움 지갑에 액세스 할 수 있으며, 이를 통해 분산 애플리케이션과 상호 작용할 수 있습니다. 위키백과 이더리움 지갑 중 메타마스크는 커뮤니티에서 사용죄는 가장 인기 있는 지갑 중 하나입니다. 설치 및 사용 방법 설치 메타마스크 웹사이트에서 크롬 플러그인으로 설치 할 수 있습니다. 사이트로 접속하여 Download 버튼을 클릭합니다. 크롬 웹 스토어 창이 열리게 되고 “Chrome에 추가” 버튼을 클릭합니다. 크롬 확장프로그램에 MetaMask가 추가됩니다. Mnemonic 복구 크롬 확장프로그램에서 MetaMask를 선택하고 “시작하기” 버튼을 클릭합니다. 처음 사용하는 사용자라면 비밀 복구 구문을 사용하여 기존 지갑 가져오기와 새 지갑과 비밀 복구 구문 생성을 선택하는 화면이 보입니다. 지갑 생성을 해서 MetaMask를 사용할 수 있지만 이전 글 [Ethereum] ganache-cli 설치 및 실행에서 생성된 Mnemonic을 사용하여 지갑을 가져오도록 하겠습니다. &quot;지갑 가져오기&quot;를 클릭하면 비밀 복구 구문으로 계정 가져오기 화면이 보입니다. 생성된 Mnemonic과 비밀번호를 입력하고 “가져오기” 버튼을 클릭합니다. 메타마스크 접속 시 화면입니다. 네트워크 추가 ganache로 실행한 네트워크를 연결하기 위해 메타마스크에서 네트워크 추가를 합니다. 메타마스크 화면에서 우측 네트워크를 클릭하고 “네트워크 추가” 버튼을 클릭합니다. 설정화면에서 &quot;네트워크 수동 추가&quot;를 클릭합니다. 네트워크 이름, 새 RPC URL(ip 주소와 포트), 체인 ID(url을 입력하면 자동으로 찾아줌), 통화 기호를 입력하고 “저장” 버튼을 클릭합니다. 추가된 네트워크가 보이며 선택 시 계정 정보가 보입니다. 결론 메타마스크 설치와 사용 방법에 대해 알아보았습니다. 이더리움 지갑에 쉽게 액세스 할 수 있어 블록체인 기반 웹이나 앱개발 시 도움이 많이 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"}]},{"title":"[Spring Boot] WebSocket & STOMP 사용 방법","slug":"spring-2","date":"2022-12-09T00:58:32.000Z","updated":"2024-01-12T06:30:10.129Z","comments":true,"path":"2022/12/09/spring-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/spring-2/","excerpt":"","text":"WebSocket 이란 웹소켓(WebSocket)은 하나의 TCP 접속에 전이중 통신 채널을 제공하는 컴퓨터 통신 프로토콜이다. 웹소켓 프로토콜은 2011년 IETF에 의해 RFC 6455로 표준화되었으며 웹 IDL의 웹소켓 API는 W3C에 의해 표준화되고 있다. 위키백과 HTTP 프로토콜과 호환되며, 실시간 양방향 통신을 제공하기 위한 프로토콜이며 Spring 4.0에서 등장한 네트워크 서비스입니다. (접속까지는 HTTP 프로토콜을 사용하지만 이후 WebSocket 프로토콜로 변경) Spring Boot로 구현하기 Spring Boot에서 WebSocket과 자바스크립트에서 STOMP을 사용하여 메시지를 주고받는 예제를 구현해 보려고 합니다. 의존성 추가 pom.xml에 spring-boot-starter-websocket를 추가합니다. 12345&lt;!-- 웹소켓 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; WebSocketConfig 설정 웹 소켓을 사용하기 위한 설정 파일이 필요합니다. @Configuration을 통해 해당 파일이 Bean 설정을 할 것을 나타냅니다. @EnableWebSocketMessageBroker 을 통해 WebSocket 사용을 나타냅니다. 1234567891011121314151617181920212223242526@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; /** * 클라이언트가 웹 소켓 서버에 연결하는데 사용할 웹 소켓 엔드포인트 등록 * withSockJS 를 통해 웹 소켓을 지원하지 않는 브라우저에 대해 웹 소켓을 대체한다. * +)메소드명에 STOMP가 들어가는 경우 통신 프로토콜인 STOMP구현에서 작동된다. */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(\"/websocket\").setAllowedOriginPatterns(\"*\").withSockJS(); &#125; /** * 한 클라이언트에서 다른 클라이언트로 메시지를 라우팅하는데 사용될 메시지 브로커 */ @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; // topic으로 시작되는 요청을 구독한 모든 사용자들에게 메시지를 전달한다. registry.enableSimpleBroker(\"/topic\"); // 클라이언트에서 보낸 메세지를 받을 prefix registry.setApplicationDestinationPrefixes(\"/app\"); &#125;&#125; MessageDTO 생성 메시지 내용을 담아줄 MessageDTO를 생성합니다. 1234567@Datapublic class MessageDTO &#123; private String content; private String sender;&#125; MessageController 생성 /app/sendMessage 경로를 통해 전송되면 @MessageMapping과 매핑되어 메서드를 호출합니다. 그리고 @SendTo를 통해 /topic/message를 구독하고 있는 사용자에게 MessageDTO를 JSON 형식으로 전달합니다. 123456789101112131415@Controllerpublic class MessageController &#123; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message * @return */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public MessageDTO message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); return message; &#125;&#125; @SendTo Annotation이 아닌 SimpMessagingTemplate을 사용해서 메세지를 전달할 수 있습니다. 1234567891011121314151617@Controller@RequiredArgsConstructorpublic class MessageController &#123; private final SimpMessagingTemplate simpMessagingTemplate; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public void message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); simpMessagingTemplate.convertAndSend(\"/topic/message\", message); &#125;&#125; STOMP 사용 STOMP는 Simple Text Oriented Messaging Protocol의 약자입니다. 클라이언트와 서버가 서로 통신하는 데 있어 메시지의 형식, 유형, 내용 등을 정의해 주는 프로토콜이라고 할 수 있습니다. STOMP를 사용하게 되면 단순한 Binary, Text가 아닌 규격을 갖춘 메시지를 보낼 수 있습니다. 라이브러리 추가 sockjs와 stomp 라이브러리를 추가합니다. 1234&lt;!-- sock js --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.2/sockjs.min.js\"&gt;&lt;/script&gt;&lt;!-- STOMP --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js\"&gt;&lt;/script&gt; 메시지 받기 클라이언트에서는 다음과 같이 연결하고 구독을 합니다. 12345678910function subscribeMessage() &#123; let socket = new SockJS('/websocket'); let stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; stompClient.subscribe('/topic/message', function (message) &#123; console.log(message.body); &#125;); &#125;);&#125; 메시지 전송 메세지 전송 시 실행되는 함수입니다. 12345678910111213function sendMessage() &#123; const socket = new SockJS('/websocket'); const stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; const message = &#123; content: 'test', sender: 'hgko', &#125;; stompClient.send('/app/sendMessage', &#123;&#125;, JSON.stringify(message)); stompClient.disconnect(); &#125;);&#125; 결론 Spring Boot 환경에서 WebSocket과 STOMP를 활용한 메시지 전송 기능 구현에 대해 알아보았습니다. 쉽게 구현할 수 있어 적용이 빠를 것 같습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"}]},{"title":"[OpenLayers] Feature Drag and Drop","slug":"js-dev-8","date":"2022-12-07T15:29:35.000Z","updated":"2024-01-12T06:27:46.376Z","comments":true,"path":"2022/12/08/js-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-8/","excerpt":"","text":"이전 글 [OpenLayers] Custom Icon Feature 추가 에서 추가된 Icon Feature를 Drag and Drop 하는 예제입니다. Script ol.interaction.Modify 을 이용해서 Drag and Drop 기능을 구현합니다. modifystart, modifyend 이벤트를 등록하여 Icon을 선택하거나 이동 시 커서가 변경되도록 하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;;// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// var dragInteraction = new ol.interaction.Modify(&#123; features: new ol.Collection([iconFeature]), &#125;); const target = document.getElementById('map'); dragInteraction.on('modifystart', function (event) &#123; target.style.cursor = 'grabbing'; &#125;); dragInteraction.on('modifyend', function (event) &#123; target.style.cursor = 'pointer'; event.features.forEach(function (feature) &#123; const name = feature.get('name'); console.log(name); // Drop 완료 시 프로세스 진행 &#125;); &#125;, iconFeature); const overlaySource = dragInteraction.getOverlay().getSource(); overlaySource.on(['addfeature', 'removefeature'], function (evt) &#123; target.style.cursor = evt.type === 'addfeature' ? 'pointer' : ''; &#125;); this.addInteraction(dragInteraction); /////////////////////////////////////////////////////// &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); Drop 이 되었을 때 feature.get() 함수를 이용해서 설정한 값을 가져와 다음 프로세스를 처리합니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Custom Icon Feature 추가","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"}]},{"title":"[OpenLayers] Custom Icon Feature 추가","slug":"js-dev-7","date":"2022-12-07T15:19:40.000Z","updated":"2024-01-12T06:27:12.315Z","comments":true,"path":"2022/12/08/js-dev-7/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-7/","excerpt":"","text":"이전 글 [OpenLayers] Static Image에서 설정한 Static Image 위에 주어진 위치의 아이콘을 표시하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. Script 기존 코드에서 addVectorLayer 함수와 styles 객체가 추가되었습니다. 먼저 ol.style.Icon 을 이용해서 아이콘 경로를 설정합니다. 12345678const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;; ol.Feature, ol.layer.Vector 이용해서 Vector Layer를 생성하고 지도에 레이어를 추가합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); &#125;, ///////////////////////////////////////////////////////&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); 결과 [100, 100] 위치에 아이콘이 표시됩니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Static Image","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"}]},{"title":"[OpenLayers] Static Image 사용 방법","slug":"js-dev-6","date":"2022-12-07T12:10:10.000Z","updated":"2024-01-12T06:26:23.353Z","comments":true,"path":"2022/12/07/js-dev-6/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/js-dev-6/","excerpt":"","text":"OpenLayers 사용하여 OSM(OpenStreetMap)으로 지도를 가시화하는 것이 아닌 Static Image를 Layer Source로 사용하여 이미지를 가시화하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. HTML 12345678910111213141516171819202122232425&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Static Map Example&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.css\" /&gt; &lt;style&gt; .map &#123; width: 100%; height: 600px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.js\"&gt;&lt;/script&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Script 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// main.js// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName);&#125;); OpenLayers 활용 라이브러리입니다. ol.proj.Projection ol.View ol.layer.Image ol.source.ImageStatic ol.Map 결과 Static Image 가 지정한 크기의 지도 중앙에 가시화됩니다. 참고 https://openlayers.org/en/latest/examples/static-image.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"}]},{"title":"[CentOS] Node.js 및 NPM 설치","slug":"linux-24","date":"2022-12-07T03:47:28.000Z","updated":"2024-01-12T06:26:52.978Z","comments":true,"path":"2022/12/07/linux-24/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/linux-24/","excerpt":"","text":"리눅스 환경에서 Node.js 와 NPM 설치하는 방법에 대해 알아보겠습니다. 운영환경 Centor 7.6 저장소 추가 설치하려는 Node.js 버전을 확인하여 NodeSource yum 저장소를 추가합니다. NodeSource Node.js Binary Distributions 사이트에 다음과 같은 내용이 정리되어 있습니다. Node.js v19.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_19.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_19.x | sudo bash - Node.js v18.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash - Node.js v16.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_16.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash - Node.js v14.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_14.x | sudo bash - Node.js LTS (18.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo bash - Node.js Current (19.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_current.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_current.x | sudo bash - 설치 yum을 사용하여 Node.js 및 npm을 설치합니다. Node.js 14 버전을 설치해 보도록 하겠습니다. 12$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -$ yum install -y nodejs 설치 확인 다음 명령어를 통해 설치된 버전을 확인할 수 있습니다. 12$ node --versionv14.20.0 12$ npm --version6.14.17 참고 https://github.com/nodesource/distributions","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[Ethereum] ganache-cli 설치 및 실행 방법","slug":"blockchain-1","date":"2022-12-07T01:20:28.000Z","updated":"2024-01-12T06:25:45.807Z","comments":true,"path":"2022/12/07/blockchain-1/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/blockchain-1/","excerpt":"","text":"ganache-cli를 설치하고 실행하는 방법에 대해 알아보겠습니다. Ganache &quot;가나슈&quot;라고 읽으면 되고, 가상의 이더리움 네트워크를 생성해서 Smart Contract를 실행할 수 있도록 해주는 프로그램입니다. 이런 가상 환경을 TestRPC라고 합니다. Ganache CLI Ganache CLI는 빠르고 커스터마이징 가능한 블록체인 에뮬레이터인 TestRPC의 최신 버전입니다. 실제 이더리움 노드를 실행하는 오버헤드 없이 블록체인을 호출할 수 있습니다. Transactions are “mined” instantly. No transaction cost. Accounts can be re-cycled, reset and instantiated with a fixed amount of Ether (no need for faucets or mining). Gas price and mining speed can be modified. A convenient GUI gives you an overview of your testchain events. NPM 설치 Ganache는 NPM을 통해 설치할 수 있습니다. 먼저 NPM이 설치되어 있어야 합니다. 이전 글 Node.js 및 NPM 설치 을 참고해서 설치를 합니다. Ganache 설치 1$ npm install -g ganache-cli 실행 1$ ganache-cli &lt;options&gt; ganache-cli 명령어를 통해 실행합니다. 옵션 없이 실행 시 다음과 같은 결과를 볼 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ ganache-cliGanache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x3F82D42b4b946aA53fF069cF931d940872C3f675 (100 ETH)(1) 0x0912b4EdD5279FEE8362257adD75715424C51a39 (100 ETH)(2) 0x668fF7BD1fe9ffe6758B9d1f71fcdA22c56f68ce (100 ETH)(3) 0xD74Dd2D769763B78009a67b6b87c7810a7eb7E6d (100 ETH)(4) 0x6Ec7b0A1f88f482711f4C8b378c8B4c6dCB863EB (100 ETH)(5) 0xa7eed29620A49ca13F780b740d597Cc79092E2D9 (100 ETH)(6) 0xfE7f9A8E6c147A07bd1b0601431dc74468456174 (100 ETH)(7) 0x0b3a29F6174631a97fe9B9289c66456ddD27D069 (100 ETH)(8) 0x89b626bAF633fAb58986499195b4F98d15D09252 (100 ETH)(9) 0xA42521a288fD576f59E1F7A7461Dfe88A52cAF99 (100 ETH)Private Keys==================(0) 0xe7c964a0050a9c8c79008eab74502ea7c105a425b5e6b8ffe57d72eef4165c20(1) 0x098196b42d262985b0f0b43edc4a51919d8dd9925e0feee485859c5987b4af9c(2) 0x23738d8fc442fd26c7a802423868bbfc0c0d930f15baef50531483a1e9f7cecd(3) 0xa67eaa626df00109e219b5f94d33535d536b19d362fbf0eff08e7143383fd95e(4) 0xede8027c26a03ec63d6b9c404216fe6328936cc6584f93b3389901bfe34efef0(5) 0x30541fc3cac5dbe9e96a482dcd4100930270f9759d1e15494bbf26932fd6e873(6) 0xa8ed660d43f2c775efff16732088e34ab23775fa56375f491c8bec3123bde75c(7) 0x5cf88b19ce7be57320c2a89bf03a9ea5a512a5dc07f9e14f4a752fb1a021deac(8) 0x557ae7917ca63f17fbb947933c3ad13cc699f42293aafbebe24729f91708eabe(9) 0xbe44643a2507aa8fc13893f4052edd154e6753d74bec3f8a8ec6a88fda645c19HD Wallet==================Mnemonic: convince have junior clean bomb fluid gossip surprise build twenty urban swordBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;Gas Price==================20000000000Gas Limit==================6721975Call Gas Limit==================9007199254740991Listening on 127.0.0.1:8545 기존 Mnemonic 을 가지고 있다면 -m 옵션을 추가하여 설정할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435$ ganache-cli -d -m \"taxi\"Ganache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1 (100 ETH)(1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0 (100 ETH)(2) 0x22d491Bde2303f2f43325b2108D26f1eAbA1e32b (100 ETH)(3) 0xE11BA2b4D45Eaed5996Cd0823791E0C93114882d (100 ETH)(4) 0xd03ea8624C8C5987235048901fB614fDcA89b117 (100 ETH)(5) 0x95cED938F7991cd0dFcb48F0a06a40FA1aF46EBC (100 ETH)(6) 0x3E5e9111Ae8eB78Fe1CC3bb8915d5D461F3Ef9A9 (100 ETH)(7) 0x28a8746e75304c0780E011BEd21C72cD78cd535E (100 ETH)(8) 0xACa94ef8bD5ffEE41947b4585a84BdA5a3d3DA6E (100 ETH)(9) 0x1dF62f291b2E969fB0849d99D9Ce41e2F137006e (100 ETH)Private Keys==================(0) 0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d(1) 0x6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1(2) 0x6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c(3) 0x646f1ce2fdad0e6deeeb5c7e8e5543bdde65e86029e2fd9fc169899c440a7913(4) 0xadd53f9a7e588d003326d1cbf9e4a43c061aadd9bc938c843a79e7b4fd2ad743(5) 0x395df67f0c2d2d9fe1ad08d1bc8b6627011959b79c53d7dd6a3536a33ab8a4fd(6) 0xe485d098507f54e7733a205420dfddbe58db035fa577fc294ebd14db90767a52(7) 0xa453611d9419d0e56f499079478fd72c37b251a94bfde4d19872c44cf65386e3(8) 0x829e924fdf021ba3dbbc4225edfece9aca04b929d6e75613329ca6f1d31c0bb4(9) 0xb0057716d5917badaf911b193b12b910811c1497b5bada8d7711f758981c3773HD Wallet==================Mnemonic: taxiBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;... 실행 옵션 옵션들을 확인하여 환경에 맞게 실행합니다. -a or --accounts: 시작 시 생성할 계정 수를 지정합니다. -b or --blocktime: 자동 마이닝을 위한 블록 타임을 초 단위로 지정합니다. 기본값은 0이며 자동 마이닝이 없습니다. -d or --deterministic: 미리 정의된 니모닉을 기반으로 결정적 주소를 생성합니다. -n or --secure: 기본적으로 사용 가능한 계정 잠금(제3자 트랜잭션 서명에 적합) -m or --mnemonic: 특정 HD 지갑 니모닉을 사용하여 초기 주소를 생성합니다. -p or --port: 포트 번호 설정. 기본값은 8545 입니다. -h or --hostname: 호스트 이름. 기본값은 노드의 server.listen() 입니다. -s or --seed: 임의의 데이터를 사용하여 사용할 HD 지갑 니모닉을 생성합니다. -g or --gasPrice: 사용자 지정 가스 가격 설정(기본값은 20000000000) -l or --gasLimit: 사용자 지정 가스 한도 설정(기본값은 90000) -f or --fork: 주어진 블록에서 현재 실행 중인 다른 이더리움 클라이언트에서 분기합니다. 입력은 다른 클라이언트의 HTTP 주소 및 포트여야 합니다.(예: http://localhost:8545) -i or --networkId: ganache-cli가 자신을 식별하는 데 사용할 네트워크 ID를 지정합니다. --db: 체인 데이터베이스를 저장할 디렉터리 경로를 지정합니다. 데이터베이스가 이미 존재하는 경우 ganache-cli는 새 체인을 생성하는 대신 해당 체인을 초기화합니다. --debug: Output VM opcodes for debugging --mem: ganache-cli 메모리 사용량 통계를 출력합니다. --e: 사용자 계정별 가스를 설정합니다.(기본값은 100) 참고 https://www.npmjs.com/package/ganache-cli https://docs.nethereum.com/en/latest/ethereum-and-clients/ganache-cli/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"}]},{"title":"[CentOS] 사용자 계정 관리","slug":"linux-23","date":"2022-12-05T01:15:46.000Z","updated":"2024-01-12T06:24:36.794Z","comments":true,"path":"2022/12/05/linux-23/","link":"","permalink":"http://hgko1207.github.io/2022/12/05/linux-23/","excerpt":"","text":"리눅스 환경에서 사용자 계정 조회, 추가, 수정, 삭제하는 방법에 대해 알아보겠습니다. 사용자 조회 모든 사용자를 출력합니다. 123456$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin... 사용자 계정 확인 root와 useradd 또는 adduser 명령어를 통해 생성한 사용자 계정을 출력합니다. 123$ grep /bin/bash /etc/passwdroot:x:0:0:root:/root:/bin/bashhgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 사용자 계정 확인 입력한 특정 사용자 계정을 출력합니다. 1$ cat /etc/passwd | grep [사용자계정] 12$ cat /etc/passwd | grep hgkohgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 조건(ID 500 이상)을 통해 사용자 목록을 조회합니다. 123456$ awk -F':' '&#123;if($3 &gt;= 500)print $1&#125;' /etc/passwdpolkitdunboundlibstoragemgmtcolord... 사용자 추가 useradd 1$ useradd [사용자계정] test 사용자를 생성합니다. 1$ useradd test 사용자 홈 디렉터리도 같이 만들고 싶다면 -m 또느 -d 옵션을 사용합니다. 12345# 홈 디렉토리를 지정할 때 사용하고 디렉토리가 없으면 생성$ useradd test -m# 홈 디렉토리 지정$ useradd test -d /home/test test 사용자의 비밀번호를 생성합니다. passwd는 리눅스 사용자 계정의 비밀번호를 변경하는 명령어입니다. 12345$ passwd testChanging password for user test.New password: ****Retype new password: ****passwd: all authentication tokens updated successfully. adduser adduser 명령어는 useradd 명령어와 달리 사용자 홈 디렉터리를 자동으로 만들고, 비밀번호 설정 등로 한 번에 할 수 있습니다. 1234567891011121314151617$ adduser testAdding user `test' ...Adding new group `test' (1000) ...Adding new user `test' (1000) with group `test' ...Creating home directory `/home/test' ...Copying files from `/etc/skel' ...New password: ****Retype new password: ****passwd: password updated successfullyChanging the user information for testEnter the new value, or press ENTER for the default Full Name []: test Room Number []: Work Phone []: Home Phone []: Other []:Is the information correct? [Y/n] 사용자 수정 1$ usermod [option] [사용자계정] test 사용자의 홈 디렉터리를 변경합니다. 1$ usermod -d /home/test1 test 사용자 삭제 1$ userdel [사용자계정] test 사용자를 삭제합니다. 1$ userdel test test 사용자를 강제로 삭제합니다. 1$ userdel -f test test 사용자와 함께 사용자 디렉터리도 같이 삭제합니다. 1$ userdel -r test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"}]},{"title":"리눅스 명령어","slug":"linux-22","date":"2022-11-30T02:05:43.000Z","updated":"2023-03-14T02:26:09.998Z","comments":true,"path":"2022/11/30/linux-22/","link":"","permalink":"http://hgko1207.github.io/2022/11/30/linux-22/","excerpt":"","text":"자주 사용하는 리눅스 명령어에 대해 알아보겠습니다. 명령어 설명 cdcd …cd -cd ~cd /cd [path] 디렉토리 이동 cp [path] [target] -R 파일 복사 tar cvfz backup.tar.gz [target] tar 로 압축 tar cvfz backup.tar.gz /test --exclude “/test/backup” 특정 디렉토리 제외하고 tar 로 압축 tar xvfz backup.tar.gz 압축 풀기 which [command]예) which find 특정 명령어의 위치 source /etc/profile 환경 설정 적용 find / -name [파일명]예) find / -name ‘test’ 파일 찾기 ls -al 디렉토리 조회 du -skh 디렉토리 용량 확인 df -h 디스크 용량 확인 ps -ef | grep [실행프로세스]예) ps -ef | grep tomcat 실행 프로세스 확인 kill -9 [pid] 프로세스 강제 종료 grep -nR [단어] * 예) grep -nR ‘/test/’ * 특정 단어 존재 여부 검사 mkdir [디렉토리명] 디렉토리 생성 rmdir [디렉토리명] 디렉토리 삭제 rm [파일명] 파일 삭제 pwd 현재 디렉토리 위치 catcat [파일명] 파일 내용 출력 id 사용자 로그인명 useradd [id] 계정 추가 userdel [id] 계정 삭제 usermod [id] 계정 수정 passwod [id] 비밀번호 변경 chmod 실행 권한 clear 화면 내용 지우기 free 메모리 확인 w 사용자 로그인 정보 top 시스템 운용상황 점검","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[JPA] CascadeType 정리","slug":"spring-jpa-6","date":"2022-11-29T04:51:38.000Z","updated":"2024-01-12T06:23:37.757Z","comments":true,"path":"2022/11/29/spring-jpa-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/29/spring-jpa-6/","excerpt":"","text":"동일 트랜잭션 내부 연관 엔티티가 수정되었을 경우 CascadeType과 상관없이 자동으로 수정됩니다. 같은 트랜젝션이라 하더라도 해당 엔티티가 CasecadeType.PERSIST 로 설정 되어 있지 않으면 연관 엔티티를 추가하더라도 반영되지 않습니다. (CascadeType.MERGE로 설정 되어도 추가는 되지 않음) CascadeType 별 동작 CascadeType.ALL 상위 엔티티에서 하위 엔티티로 모든 작업을 전파합니다. 모든 Cascade 설정을 적용합니다. CascadeType.PERSIST 상위 엔티티를 생성하고, 하위 엔티티를 추가하였을 때 persist()를 수행하면 하위 엔티티도 같이 persist()가 수행됩니다. 만약, 하위 엔티티가 DB에 등록된 키값을 가졌다면 detached entity passed to persist 예외가 발생합니다. CascadeType.MERGE 트랜젝션이 종료되고 detach 상태에서 하위 엔티티를 추가하거나 변경된 이후에 상위 엔티티가 merge()를 수행하게 되면 변경 사항이 적용됩니다. 하위 엔티티의 추가 및 수정 모두 반영됩니다. CascadeType.REMOVE 삭제 시 연관된 하위 엔티티들도 같이 삭제됩니다. CascadeType.DETACH 상위 엔티티가 detech()를 수행하게 되면 연관된 하위 엔티티도 detach() 상태가 되어 변경 사항이 반영되지 않습니다. 고려사항 부모/자식 간의 관계를 설정하는 과정에서 부모가 데이터베이스에 존재하지 않는 경우 데이터 무결성의 문제가 발생합니다. 자식 레코드를 삭제하지 않은 상태에서 부모 레코드를 먼저 삭제하려 시도하는 경우 참조 무결성 위반이 발생합니다. 참고 https://www.baeldung.com/jpa-cascade-types","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"}]},{"title":"[Spring] QuerydslRepositorySupport 사용","slug":"spring-querydsl-2","date":"2022-11-28T02:45:08.000Z","updated":"2024-01-12T06:22:34.853Z","comments":true,"path":"2022/11/28/spring-querydsl-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-2/","excerpt":"","text":"QueryDslPredicateExecutor를 이용하는 findAll, findOne 등은 where, Sort, Limit 등의 조건만 넣을 수 있습니다. 하지만 Join이나 Group by 등의 기능을 사용하려면 인터페이스 선언만으로는 기능을 구현하기 힘듭니다. 이를 해결하기 위해서 Spring Data JPA에서 제공하는 QuerydslRepositorySupport 추상 클래스가 있습니다. QuerydslRepositorySupport는 개발자에게 querydsl 객체를 직접 제공합니다. 예를 들어 권한별 사용자 수에 대한 데이터가 필요하다면, 다음과 같이 할 수 있습니다. 사용자 클래스와 DTO 클래스를 생성합니다. 1234567891011121314151617@Data@Entity@Tablepublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column(nullable = false, length = 50) private String username; @Column(nullable = false, length = 50) private String password; private int role;&#125; 123456789101112@Datapublic class UserRoleCountDTO &#123; private int role; private long count; public UserRoleCountDTO(int role, long count) &#123; this.role = role; this.count = count; &#125;&#125; 권한별 사용자 수를 얻어오는 인터페이스를 생성하고 메소드를 선언합니다. 123public interface UserRepositoryCustom &#123; List&lt;UserRoleCountDTO&gt; getUserRoleCount();&#125; UserRepository에 상속 시킵니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt;, UserRepositoryCustom &#123;&#125; QuerydslRepositorySupport를 이용해서 UserRepositoryCustom를 구현하는 클래스를 작성합니다. UserRepository 이름 뒤에 Impl이라는 Postfix 가 붙으면 자동으로 Spring Data JPA의 AOP 주입 대상이 됩니다. 12345678910111213public class UserRepositoryImpl extends QuerydslRepositorySupport implements UserRepositoryCustom &#123; public UserRepositoryImpl() &#123; super(User.class); &#125; @Override public List&lt;UserRoleCountDTO&gt; getUserRoleCount() &#123; QUser user = QUser.user; return from(user).groupBy(user.role) .list(Projections.constructor(UserRoleCountDTO.class, user.role, user.role.sum)); &#125;&#125; 위의 예제를 통해 JpaRepository의 기능과 추가로 구현한 UserRepositoryCustom의 추가 기능까지 사용할 수 있습니다. 1234567891011@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public void testQuery() &#123; List&lt;UserRoleCountDTO&gt; userRoleCountDTOs = userRepository.getUserRoleCount(); System.out.println(\"result =&gt;\" + userRoleCountDTOs); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"}]},{"title":"[Spring] JPA with Querydsl","slug":"spring-querydsl-1","date":"2022-11-28T01:57:14.000Z","updated":"2024-01-12T06:21:05.213Z","comments":true,"path":"2022/11/28/spring-querydsl-1/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-1/","excerpt":"","text":"Query DSL JPA, JDO, SQL 같은 백엔드를 위해 type-safe SQL을 만드는 프레임워크 Domain Specific Language 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어 특징 type-safe 조회에 특화된 프로그래밍 언어 단순, 간결 다양한 저장소 조회 기능 통합 (데이터 조회 기능 추상화) 동작 방식 Member java or Member table의 메타 데이터를 참조하여 코드 생성기를 통해 QMember.java를 생성합니다. APT: Annotation Processing Tool Table Meta: Querydsl-maven-plugin 기능 Query: from, where, join Path: QMember, Qmember.name Expression: name.eq, name.qt 세부기능 from innerJoin, join, leftJoin, fetchJoin, fullJoin, on where (and, or, allOf, anyOf) groupBy having order By (desc, asc) limit, offset, restrict(limit + offset) (Paging) list listResults (list + Paging Info(totalCount)) iterate count singleResult, uniqueResult 사용 방법 설정 Spring Boot 프로젝트의 pom.xml 에 의존성과 플러그인을 추가합니다. QueryDSL을 사용하기 위해서는 com.querydsl에서 제공하는 querydsl-jpa와 querydsl-apt에 대한 의존성이 필요합니다. 123456789101112131415&lt;!-- dependencies 에 추가 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jdo&lt;/artifactId&gt;&lt;/dependency&gt; com.mysema.maven에서 제공하는 apt-maven-plugin을 설치합니다. 123456789101112131415161718&lt;!-- build - plugins 에 추가 --&gt;&lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;sourceEncoding&gt;UTF-8&lt;/sourceEncoding&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 이제 프로젝트 우클릭 후 maven -&gt; Update Project… 수행하면 Entity에 대한 Q 클래스들이 target/generated-sources/java 경로에 생성된 것을 확인할 수 있습니다. 도메인 클래스 생성 테이블 도메인 클래스를 생성합니다. 1234567891011@Entity@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 인터페이스를 작성합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123;&#125; Querydsl 사용 예 Repository 인터페이스에 QuerydslPredicateExecutor 를 확장합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt;, QuerydslPredicateExecutor&lt;Team&gt; &#123;&#125; 1234567891011@Service@RequiredArgsConstructorpublic class TeamService &#123; private final TeamRepository teamRepository; public void testQuerydsel &#123; teamRepository.findAll(QTeam.team.name.eq(\"test\"1)); teamRepository.findOne(QTeam.team.rating.loe(100)); &#125;&#125; JPAQuery 사용 예 JPAQuery을 Bean 등록 후 사용 가능합니다. 1234567891011@SpringBootApplicationpublic class TestWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestWebApplication.class, args); &#125; @Bean public JPAQueryFactory jpaQueryFactory(EntityManager em) &#123; return new JPAQueryFactory(em); &#125;&#125; 123456789101112131415@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl() &#123; QTeam team = QTeam.team; List&lt;Team&gt; teams = query.from(team) .where(team.name.eq(\"test1\").or(team.name.like(\"hgko%\"))) .list(team); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125; BooleanBuilder 사용 예 상황에 따라 동적으로 변경되는 쿼리를 작성할 경우 BooleanBuilder 를 사용하면 간편하게 쿼리를 작성할 수 있습니다. 12345678910111213141516171819@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl(String name) &#123; QTeam team = QTeam.team; // 검색 조건에 따른 동적 쿼리 작성 BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(name)) &#123; builder.and(team.name.contains(name)); &#125; List&lt;Team&gt; teams = factory.selectFrom(team).where(builder).fetch(); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"}]},{"title":"[JPA] NamedQuery","slug":"spring-jpa-5","date":"2022-11-25T01:10:56.000Z","updated":"2024-01-12T06:19:56.059Z","comments":true,"path":"2022/11/25/spring-jpa-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/25/spring-jpa-5/","excerpt":"","text":"NamedQuery 란 Entity에 @NamedQuery 어노테이션을 통해 쿼리를 지정해 줍니다. 쉽게 말하면 미리 이름을 부여해서 재활용할 수 있는 JPQL입니다. 사용 방법 도메인 클래스에 @NamedQuery 또는 @NamedNativeQuery를 정의합니다. 2개 이상의 Query를 정의하려면 @NamedQueries 또는 @NamedNativeQueries를 사용하면 됩니다. Primary Key 가 되는 칼럼은 @Id를 사용하여 지정합니다. 테이블의 칼럼명과 도메인 클래스의 필드명이 다를 경우 @Column을 이용하여 지정할 수 있습니다. 클래스 생성 위의 설명의 어노테이션을 사용하여 도메인 클래스를 생성합니다. 12345678910111213141516171819@Entity@NamedQueries(&#123; @NamedQuery(name = \"Team.query1\", query = \"select t.id from Team t where t.name = 'test1'\"), @NamedQuery(name = \"Team.query2\", query = \"select t.name from Team t where t.name = ?1\"),&#125;)@NamedNativeQueries(&#123; @NamedNativeQuery(name = \"Team.nativeQuery1\", query = \"select t.id from tb_team t where t.name = 'test1'\"), @NamedNativeQuery(name = \"Team.nativeQuery2\", resultClass = Team.class, query = \"select * from tb_team t where t.name = '?1\")&#125;)@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 생성 Repository 인터페이스에 직접 @Query를 이용하여 SQL문을 사용할 수 있습니다. nativeQuery를 사용하려면 해당 필드를 true로 설정하면 됩니다. @Param을 사용하여 Query문의 파라미터와 연결할 수 있습니다. entityName을 사용하면 도메인 타입이 자동으로 설정됩니다. 12345678910111213141516public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123; @Query(value = \"select * from tb_team t where t.name = 'test1'\", nativeQuery = true) List&lt;Team&gt; testNativeQuery(); @Query(value = \"select t.id from #&#123;#entityName&#125; t where t.name like :name%\", nativeQuery = true) List&lt;String&gt; testNativeQuery(@Param(\"name\") String name); List&lt;Integer&gt; query1(); List&lt;String&gt; query2(String name); List&lt;Integer&gt; nativeQuery1(); List&lt;Team&gt; nativeQuery2(String name);&#125; 위와 같이 클래스에 Native 쿼리문을 작성하고 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"}]},{"title":"[JPA] 쿼리 메서드","slug":"spring-jpa-4","date":"2022-11-24T06:24:06.000Z","updated":"2024-01-12T06:18:42.077Z","comments":true,"path":"2022/11/24/spring-jpa-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-4/","excerpt":"","text":"Spring Data JPA 쿼리 메서드는 가장 강력한 메서드이며, SQL 쿼리를 작성하지 않고도 데이터베이스에서 레코드를 선택하는 쿼리 메서드를 만들 수 있습니다. 백그라운드에서 Spring Data JPA는 쿼리 메서드를 기반으로 SQL 쿼리를 생성하고 쿼리를 실행합니다. Entity 필드를 사용하여 Repository에 대한 쿼리 메서드를 생성할 수 있으며 쿼리 메서드 생성을 finder methods(findBy, findAll …)라고도 합니다. 예 findByEmailAddressAndName() 이 쿼리 메서드인 UserRepository 가 있다고 가정합니다. 123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndName(String emailAddress, String name);&#125; 백그라운드에서 Spring Data JPA 는 위의 메서드(findByEmailAddressAndName)에서 JPA 기준 API를 사용하여 쿼리를 생성하지만 기본적으로 다음과 같은 JPQL 쿼리로 변환됩니다. 1select u from User u where u.emailAddress = ?1 and u.name = ?2 키워드들 JPA에 대해 지원되는 키워드와 해당 키워드를 포함하는 메서드가 무엇을 의미하는지 설명합니다. Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname, findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstname) = UPPER(?1) 참고 https://www.javaguides.net/2018/11/spring-data-jpa-query-creation-from-method-names.html https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"}]},{"title":"[JPA] @ElementCollection 사용 예","slug":"spring-jpa-3","date":"2022-11-24T06:05:52.000Z","updated":"2024-01-12T06:18:23.611Z","comments":true,"path":"2022/11/24/spring-jpa-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-3/","excerpt":"","text":"RDB(Relational DataBase) 에는 Collection 형태의 데이터를 칼럼에 저장할 수 있는 방법이 없습니다. 그래서 별도의 테이블을 생성하고 Collection을 관리해야 합니다. JPA의 @ElementCollection 사용하여 별도의 테이블을 생성하고 Collection 을 관리할 수 있습니다. ElementCollection 특징은 부모 Entity에 의해 관리되고, 항상 부모와 함께 저장되고 삭제됩니다. casecade 옵션이 default입니다. 예 Collection 대상이 되는 객체는 @Entity 가 아닌 Embeddable Class로 생성하여 One-To-Many 관계를 맺습니다. 12345678910@Embeddable@Datapublic class Address &#123; @Column(length = 50) public String address; @Column(length = 50) public String detailAddress;&#125; @ElementCollection 생성하여 Collection 테이블을 생성합니다. 1234567891011121314@Entity@Datapublic class User &#123; @ElementCollection(fetch = FetchType.LAZY) @CollectionTable( name = \"user_address\", joinColumns = @JoinColumn(name = \"userId\") ) @ForeignKey(name = \"fk_user_address\") private List&lt;Address&gt; addresses; ...&#125; 결과 다음과 같은 DDL 스크립트가 만들어집니다. 1234567CREATE TABLE `user_address` ( `user_id` int(11) NOT NULL, `address` varchar(50) DEFAULT NULL, `detail_address` varchar(50) DEFAULT NULL, KEY `fk_user_address` (`user_id`), CONSTRAINT `fk_user_address` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 참고 https://prohannah.tistory.com/133","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"}]},{"title":"[MySQL] 스토리지 엔진(Storage Engine)","slug":"mysql-7","date":"2022-11-23T04:49:27.000Z","updated":"2024-01-12T06:17:50.644Z","comments":true,"path":"2022/11/23/mysql-7/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-7/","excerpt":"","text":"MySQL 스토리지 엔진 종류 및 간단 비교 내용입니다. MyISAM 정적인 테이블, 로그 테이블 쓰기 작업이 별로 없는 select 위주의 테이블 다수의 세션이 동시 작업을 하는 경우 성능이 저하됨 InnoDB 민감한 정보를 갖는 테이블 (회원 등) 갱신 (읽기 / 쓰기) 위주의 트랜잭션이 요구되는 테이블 인덱스가 많이 걸린 대량의 테이블 Archive 로그 수집에 적합 데이터가 메모리상에서 압축된 후 압축된 상태로 디스크에 저장 Memory 일시적으로만 사용되는 임시 테이블","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"}]},{"title":"[MySQL] 유용 명령어","slug":"mysql-6","date":"2022-11-23T04:32:58.000Z","updated":"2024-01-12T06:17:35.238Z","comments":true,"path":"2022/11/23/mysql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-6/","excerpt":"","text":"Help 1234HELP SHOW;HELP &#123;SELECT | DELETE | UPDATE&#125;;HELP ALTER;HELP ALTER &#123;DATABASE | TABLE&#125;; Show 123SHOW PRIVILEGES;SHOW OPEN TABLES;SHOW TABLE STATUS; 테이블 칼럼 조회 명령어입니다. (코멘트 포함) 1SHOW FULL COLUMNS FROM 테이블명; Select 12345-- 왜래키 규약SELECT * FROM information_schema.REFERENTIAL_CONSTRAINTS;-- PRIMARY KEY, UNIQUE 규악 등SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_schema = 데이터베이스명; 백업 1$ mysqldump &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &gt; 백업파일명.sql 복구 1$ mysql &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &lt; 백업파일명.sql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[MySQL] ALTER TABLE 구문 정리","slug":"mysql-5","date":"2022-11-23T02:06:21.000Z","updated":"2024-01-12T05:52:59.560Z","comments":true,"path":"2022/11/23/mysql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-5/","excerpt":"","text":"MySQL에서 사용하는 ALTER TABLE 구문에 대해 알아보겠습니다. 테이블 관련 테이블 생성 테이블 2개를 생성합니다. 1234567891011CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, age INT, name VARCHAR(50), jumin VARCAHR(15), PRIMARY KEY(id), UNIQUE(age), INDEX(name), KEY(jumin), INDEX(name, jumin)); 12345CREATE TABLE test2 ( id INT, parent_id INT, FOREIGN KEY (parent_id) REFERENCES test(id) ON DELETE CASCADE ON UIPDATE CASCADE); INDEX를 KEY로 바꿔도 됩니다. INDEX(name, jumin) 과 INDEX(name), INDEX(jumin) 은 다릅니다. 테이블 속성 변경 [] 에 들어가 있는 내용은 생략 가능합니다. 1. 필드 추가 12ALTER TABLE 테이블명 ADD [COLUMN] 추가할필드명 필드타입 [FIRST | AFTER 필드명];ALTER TABLE 테이블명 ADD [COLUMN] (추가할필드명 필드타입, ...); 2. 필드명 및 타입 변경 1ALTER TABLE 테이블명 CHANGE [COLUMN] 기존필드명 변경할필드명 변경할필드타입 [FIRST | AFTER 필드명]; 3. 필드 타입 변경 1ALTER TABLE 테이블명 MODIFY [COLUMN] 기존필드명 변경할필드명 [FIRST | AFTER 필드명]; 4. 필드 삭제 1ALTER TABLE 테이블명 DROP [COLUMN] 제거할필드명; 5. 필드 디폴트 정의 1ALTER TABLE 테이블명 ALTER [COLUMN] 필드명 &#123;SET DEFAULT 'XXX' | DROP DEFAULT&#125;; 6. 테이블명 변경 1ALTER TABLE 테이블명 RENAME 변경할테이블명; 7. COMMENT 추가 12ALTER TABLE 테이블명 COMMENT '내용';ALTER TABLE 테이블명 MODIFY 필드명 필드타입 [DEFAULT 'XXX'] COMMENT '내용'; 인덱스 관련 인덱스 생성 INDEX 123CREATE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD INDEX [인덱스명] [인덱스타입] (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD KEY [인덱스명 ] [인덱스타입] (필드1, 필드2, ...); UNIQUE 12CREATE UNIQUE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] UNIQUE [인덱스명] [인덱스타입] (필드1, 필드2, ...); PRIMARY KEY 1ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] PRIMARY KEY [인덱스타입] (필드1, 필드2, ...); FOREIGN KEY 외래키 생성 시 제약 조건과 INDEX 가 같이 생성되며, 외래키를 삭제하더라도 INDEX는 남게 됩니다. 만약 인덱스도 삭제가 필요하다면 같이 삭제해야 합니다. 123ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] FOREIGN KEY [인덱스명] (필드1, 필드2, ...) [레퍼런스조건] ON UPDATE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT] ON DELETE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT]; FULLTEXT 12CREATE FULLTEXT INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD FULLTEXT [인덱스명 ] (필드1, 필드2, ...); 인덱스 보기 1SHOW INDEX FROM 테이블명 인덱스 삭제 1234DROP INDEX 인덱스명 ON 테이블명;ALTER TABLE 테이블명 DROP INDEX 인덱스명;ALTER TABLE 테이블명 DROP INDEX PRIMARY KEY;ALTER TABLE 테이블명 DROP INDEX FOREIGN KEY [fk_symbol]; 기타 키 활성화 12ALTER TABLE 테이블명 ENABLE KEYS;ALTER TABLE 테이블명 DISABLE KEYS; 정렬 1ALTER TABLE 테이블명 ORDER BY 필드명; 캐릭터 셋 12ALTER TABLE 테이블명 CONVER TO CHARACTER SET 캐릭터셋ALTER TABLE 테이블명 CHARACTER SET 캐릭터셋 데이터베이스 엔진 변경 1ALTER TABLE 테이블명 ENGINE=&#123;InnoDB | MyISAM&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"}]},{"title":"[MySQL] 인덱스(INDEX) 정리","slug":"mysql-4","date":"2022-11-17T06:57:35.000Z","updated":"2024-01-12T05:52:21.269Z","comments":true,"path":"2022/11/17/mysql-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-4/","excerpt":"","text":"인덱스(index)란? 인덱스(index)는 테이블에서 원하는 데이터를 쉽고 빠르게 찾기 위해 사용합니다. 이러한 인덱스는 자주 사용되는 필드 값으로 만들어진 원본 테이블의 사본이라고 생각할 수 있습니다. MySQL은 데이터를 검색할 때 첫 번째 필드부터 차례대로 테이블 전체를 검색합니다. 따라서 테이블이 크면 클수록 데이터를 탐색하는 시간도 많이 늘어나게 됩니다. 장점 MIN(), MAX() 등의 함수를 사용하는 쿼리에 대해 해당 필드에 인덱스가 있는 경우 빠르게 찾을 수 있습니다. ORDER BY와 GROUP BY를 빠르게 수행할 수 있습니다. 단점 ISAM, MyISAM 테이블 인덱스를 무겁게 만들면 인덱스 파일이 데이터 파일보다 더 빠르게 최대 크기에 도달됩니다. BDB(Berkeley DB) 테이블은 동일한 파일 내에 데이터와 인덱스 값을 함께 저장하며, 인덱스를 추가하게 되면 해당 테이블의 최대 파일 크기에 빠르게 도달하게 됩니다. InnoDB 테이블은 테이블 스페이스 안에 모든 공간을 공유하는 구조이며, 인덱스를 추가하면 테이블 스페이스 내의 공산을 빠르게 소모합니다. 검색속도는 향상되지만 삽입, 삭제, 갱신 속도는 느려집니다. 고려사항 인덱스를 위한 칼럼을 선택하는 가장 좋은 기준은 WHERE 절 안에 나오는 칼럼, 조인 절에 명명된 칼럼, ORDER BY, GROUP BY 절에 나오는 칼럼 등이 된다는 것입니다. SELECT 키워드 뒤에 나오는 출력 칼럼, 목록에만 나오는 칼럼은 좋은 선택이 아닙니다. 유일한 인덱스 사용: 유일한 값을 가지고 있는 칼럼들에 대해 효과가 좋고, 중복된 값들이 많은 칼럼들에 대해 효과가 나쁩니다. 짧은 값으로 인덱스를 만듭니다. 가장 왼쪽의 접두어를 활용합니다. 인덱스 생성 CREATE 문을 사용하여 인덱스를 생성할 수 있습니다. 1CREATE INDEX 인덱스명 ON 테이블명 (필드명1, 필드명2, ...) 이때 쉼표(,)를 사용하여 여러 필드를 가지는 인덱스를 생성할 수도 있습니다. 12-- 예CREATE INDEX NameIdx On Test (Name); 인덱스 추가 기본 인덱스에서 필드의 값은 같은 값이 여러 번 저장될 수 있으며, NULL 값을 가질 수도 있습니다. 1ALTER TABLE 테이블명 ADD INDEX 인덱스명 (필드명) 12-- 예ALTER TABLE Test ADD INDEX NameIdx (Name); 인덱스 삭제 ALTER 문으로 삭제 ALTER 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1ALTER TABLE 테이블명 DROP INDEX 인덱스명 12-- 예ALTER TABLE Test DROP INDEX NameIdx; DROP 문으로 삭제 DROP 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1DROP INDEX 인덱스명 ON 테이블명 12-- 예DROP INDEX NameIdx ON Test; 인덱스 정보 보기 생성한 인덱스를 확인할 수 있습니다. 1SHOW INDEX FROM 테이블명 이때 반환되는 인덱스 정보의 필드 값은 다음과 같습니다. Table : 테이블의 이름을 표시함. Non_unique : 인덱스가 중복된 값을 저장할 수 있으면 1, 저장할 수 없으면 0을 표시함. Key_name : 인덱스의 이름을 표시하며, 인덱스가 해당 테이블의 기본 키라면 PRIMARY로 표시함. Seq_in_index : 인덱스에서의 해당 필드의 순서를 표시함. Column_name : 해당 필드의 이름을 표시함. Collation : 인덱스에서 해당 필드가 정렬되는 방법을 표시함. Cardinality : 인덱스에 저장된 유일한 값들의 수를 표시함. Sub_part : 인덱스 접두어를 표시함. Packed : 키가 압축되는(packed) 방법을 표시함. Null : 해당 필드가 NULL을 저장할 수 있으면 YES를 표시하고, 저장할 수 없으면 ''를 표시함. Index_type : 인덱스에 사용되는 메서드(method)를 표시함. Comment : 해당 필드를 설명하는 것이 아닌 인덱스에 관한 기타 정보를 표시함. Index_comment : 인덱스에 관한 모든 기타 정보를 표시함. 참고 http://www.tcpschool.com/mysql/mysql_index_create","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"}]},{"title":"[MySQL] 계정 관리","slug":"mysql-3","date":"2022-11-17T04:34:33.000Z","updated":"2024-01-12T05:50:39.361Z","comments":true,"path":"2022/11/17/mysql-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-3/","excerpt":"","text":"MySQL에서 계정 생성 및 권한 부여와 계정 정보 수정하는 방법에 대해 알아보겠습니다. 로그인 root의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MySQL [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MySQL [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 123456789MySQL [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+ 계정 생성 사용자 계정을 생성하는 방법입니다. CREATE 문으로 생성 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; INSERT 문으로 생성 1INSERT INTO user (host, user, password) VALUES ('localhost', '계정명', password('비밀번호')); **‘localhost’**를 **’%’**로 변경하면 원격에서 접속 가능합니다. 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. GRANT 문으로 권한 부여 1grant all privileges on *.* to 'USERNAME'@'%' identified by 'PASSWORD'; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; INSERT 문으로 권한 부여 12INSERT INTO db (Host, Db, USer, select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv)VALUES ('localhost', 'DB명', '계정명', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'); DB명에 ‘%’ 를 넣으면 모든 DB를 나타냅니다. 계정 정보 변경 계정의 비밀번호 변경 하는 방법입니다. UPDATE 문으로 변경 1UPDATE user SET password=password('비밀번호') where user='계정명'; SET 문으로 변경 1SET PASSWORD FOR '계정명'@'localhost' = PASSWORD('비밀번호'); 계정 삭제 DELETE 문으로 삭제 12DELETE FROM user WHERE user = '계정명';DELETE FROM db WHERE user = '계정명'; DROP 문으로 삭제 1DROP USER '계정명'@'localhost'; 권한 삭제 1REVOKE ALL ON *.* FROM '계정명'; 권한 확인 1234567MySQL [mysql]&gt; SHOW GRANTS FOR root;+--------------------------------------------------------------------------------------------------------------+| Grants for root@% |+--------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO `root`@`%` IDENTIFIED BY PASSWORD '*D08D94B3E46A8CCDA5F1682F57F8BE24F5FD1C79' |+--------------------------------------------------------------------------------------------------------------+1 row in set (0.002 sec) 설정 적용 위의 설정 명령어들을 실행 후 다음 명령어를 실행해야 적용이 됩니다. 1flush privileges;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[MySQL] 접속 에러 해결 방법","slug":"mysql-2","date":"2022-11-15T06:35:01.000Z","updated":"2024-01-12T05:49:56.746Z","comments":true,"path":"2022/11/15/mysql-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/mysql-2/","excerpt":"","text":"MySQL 서버에 접속 시도 시 다음과 같은 에러가 발생할 경우 해결 방법입니다. 123$ sudo mysql -u rootERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (111) MySQL 사용자로 접속 시도 시 /var/lib/mysql/ 경로에서 mysql.sock 파일을 찾을 수 없어서 나오는 오류입니다. 먼저 mysql.sock 파일을 찾습니다. 12$ find / -name \"mysql.sock\"/db/mysql_data/mysql.sock 해결 1 my.cnf 파일을 열고 다음 항목을 추가합니다. 12345$ vi /etc/my.cnf[client]socket=/db/mysql_data/mysql.sock[mysqld]socket=/db/mysql_data/mysql.sock 해결 2 심볼릭 링크를 사용합니다. 1$ ln -s /db/mysql_data/mysql.sock /var/lib/mysql/mysql.sock","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Java] Iteration 예","slug":"java-dev-11","date":"2022-11-15T06:20:43.000Z","updated":"2023-03-14T02:25:28.271Z","comments":true,"path":"2022/11/15/java-dev-11/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-11/","excerpt":"","text":"Iteration 람다(Lambda)의 forEach 함수를 사용하는 예제입니다. 사용 예 1List&lt;String&gt; friends = Arrays.asList(\"Brian\", \"Nate\", \"Neal\", \"Raju\", \"Sara\", \"Scott\"); 기존 for 문 1234567for (int i = 0; i &lt; friends.size(); i++) &#123; System.out.println(friends.get(i));&#125;for (String name : friends) &#123; System.out.println(name);&#125; 1234567# 결과BrianNateNealRajuSaraScott forEach 사용 forEach 함수를 사용한 예제입니다. 첫 번째부터 마지막까지 점점 코드가 간략해지는 것을 볼 수 있습니다. 12345678910111213141516// 1)friends.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String name) &#123; System.out.println(name); &#125;&#125;);// 2)friends.forEach((final String name) -&gt; System.out.println(name));// 3)friends.forEach(name -&gt; System.out.println(name));// 4)friends.forEach(System.out::println); 결과는 모두 같습니다. 1234567# 결과BrianNateNealRajuSaraScott","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"}]},{"title":"[Java] 스트림(Stream) 사용 방법","slug":"java-dev-10","date":"2022-11-15T05:08:03.000Z","updated":"2024-01-12T05:48:48.859Z","comments":true,"path":"2022/11/15/java-dev-10/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-10/","excerpt":"","text":"스트림(stream) Java 8 버전부터 추가되었고 특정 요소 형식으로 이루어진 연속된 값에 대한 집합 인터페이스를 제공합니다. filter, map, reduce, sort, find 등의 함수들을 제공합니다. 사용 예 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String name; private String age;&#125; 123456List&lt;Person&gt; people = Arrays.asList( new Person(\"Eden\", 20), new Person(\"Ko\", 21), new Person(\"Lee\", 21), new Person(\"Kang\", 25)); Mutable 21살 이상의 사람을 찾는 코드입니다. filter를 사용하여 20살 초과인 사람만 찾고 List에 값을 넣는 예제입니다. 123456List&lt;Person&gt; olderThan20 = new ArrayList&lt;&gt;();people.stream() .filter(person -&gt; person.getAge() &gt; 20) .forEach(person -&gt; olderThan20.add(person));System.out.println(\"People older than 20: \" + olderThan20); 12# 결과People older than 20: [Person(name=Ko, age=21), Person(name=Lee, age=21), Person(name=Kang, age=25)] Collect collect를 사용하여 ArrayList 형식의 List를 반환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);System.out.println(\"People older than 20: \" + olderThan20); Collect To List Collectors.toList()를 사용하여 Collect 형식을 List로 변환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(Collectors.toList());System.out.println(\"People older than 20: \" + olderThan20); Group By(1) 나이를 Key로 해서 Map을 생성하는 예제입니다. 1234Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge));System.out.println(\"Grouped by age: \" + peopleByAge); 12# 결과Grouped by age: &#123;20=[Person(name=Eden, age=20)], 21=[Person(name=Ko, age=21), Person(name=Lee, age=21)], 25=[Person(name=Kang, age=25)]&#125; Group By(2) 값을 Person 객체가 아닌 이름으로 구성하는 예제입니다. 12345Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge, Collectors.mapping(Person::getName, Collectors.toList())));System.out.println(\"People grouped by age: \" + nameOfPeopleByAge); 12# 결과People grouped by age: &#123;20=[Eden], 21=[Ko, Lee], 25=[Kang]&#125; reducing 이름의 첫글자가 같은 사람 중 나이가 많은 사람만 찾는 예제입니다. 12345678// 나이 비교Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge);Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = people.stream() .collect(Collectors.groupingBy(person -&gt; person.getName().charAt(0), Collectors.reducing(BinaryOperator.maxBy(byAge))));System.out.println(\"Oldest person of each letter: \" + oldestPersonOfEachLetter); 12# 결과Oldest person of each letter: &#123;E=Optional[Person(name=Eden, age=20)], K=Optional[Person(name=Kang, age=25)], L=Optional[Person(name=Lee, age=21)]&#125; 예제들을 통해 스트림(Stream) 사용하는 방법을 알아봤습니다. 제공하는 함수들을 잘 사용하면 좋은 결과 값을 얻을 수 있습니다. 참고 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"}]},{"title":"Java 8 람다(Lambda) 적용 예","slug":"java-dev-9","date":"2022-11-09T01:17:47.000Z","updated":"2024-01-12T05:48:04.114Z","comments":true,"path":"2022/11/09/java-dev-9/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-9/","excerpt":"","text":"람다(Lamdba) 란 람다식, 또는 람다 함수라 부른다. 프로그래밍 언어에서 사용되는 개념으로, 익명 함수(Anonymous functions)를 지칭하는 용어이다. 나무위키 예제 Map에서 특정한 값을 가지는 entry에 대해서 삭제하는 코드입니다. 1234567891011121314Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"XXX\", \"111\");map.put(\"YYY\", \"222\");map.put(\"ZZZ\", \"333\");map.put(\"AAA\", \"444\");map.put(\"BBB\", \"555\");map.entrySet().stream() .filter(entry -&gt; entry.getValue().equals(\"111\")) .map(entry -&gt; entry.getKey()) .collect(Collectors.toList()) .forEach(map::remove);System.out.println(map); 실행 결과입니다. 1&#123;YYY=222, ZZZ=333, AAA=444, BBB=555&#125; 만약, collect 함수를 삭제할 경우 컴파일 에러는 없지만 다음과 같은 예외를 발생합니다. 12Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:20) 삭제하는 코드를 간략하게 구현할 수 있지만 위의 예제는 람다식의 다양한 함수를 보여주기 위해 사용하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"}]},{"title":"Java 8 스트림 적용시 성능 변화","slug":"java-dev-8","date":"2022-11-09T01:02:33.000Z","updated":"2024-01-12T05:47:45.390Z","comments":true,"path":"2022/11/09/java-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-8/","excerpt":"","text":"for 문 1234567891011121314int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = 0;for (long i = startIndex; i &lt; endIndex; i++) &#123; sum += i;&#125;long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 11919ms Stream 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 33446ms parallel 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).parallel().sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 9407ms 결과 기존 for 문으로 구현한 방식을 자바의 stream 형태로 변경했을 때 성능은 저하되나 병렬 처리를 사용하면 성능 향상을 할 수 있습니다. for 문은 병렬 처리를 하려면 여러 스레드에 공유 자원에 대한 접근을 고려하여 구현해야 하기 때문에 쉽지 않은데 자바의 stream을 사용할 경우 병렬 처리로 변경하는 과장이 parallel() 메소드만 호출하면 가능합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"}]},{"title":"[PostgreSQL] 사용자, 그룹 관리","slug":"postgresql-6","date":"2022-11-08T05:03:30.000Z","updated":"2024-01-12T05:47:11.425Z","comments":true,"path":"2022/11/08/postgresql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-6/","excerpt":"","text":"실행 파일을 통합 방법 사용자 생성 1$ createuser hgko --createdb --no-superuser --no-createrole 사용자 삭제 1$ dropuser hgko DB 접속을 통한 방법 GROUP 생성, 수정, 삭제 SYSID: 내부의 GROUP ID 구분용 숫자 코드이며, 설정하지 않으면 자동으로 100부터 1씩 증가합니다. (1~99는 핵심적인 그룹을 위함) 자동으로 설정되게 하면 됩니다. GROUP 생성 1234CREATE GROUP [그룹명];CREATE GROUP [그룹명] WITH USER user1, user2, user3;CREATE GROUP [그룹명] WITH SYSID 100 USER user1;CREATE GROUP [그룹명] WITH SYSID 100; GROUP 수정 123ALTER GROUP [그룹명] ADD USER user4, user5;ALTER GROUP [그룹명] DROP USER user3;ALTER GROUP [그룹명] RENAME TO [새로운 그룹명]; GROUP 삭제 1DROP GROUP [그룹명]; GROUP 조회 123456-- 1)postgres=# \\dgpostgres=# \\du-- 2)select * from pg_group; 사용자 생성, 수정, 삭제 사용자 생성 1CREATE USER test_user CREATEDB CREATEUSER IN GROUP test_group UNENCRYPTED PASSWORD '1234'; 사용자 생성에 사용되는 옵션들입니다. [ SUPERUSER | NOSUPERUSER ] [ CREATEDB | NOCREATEDB ] [ CREATEROLE | NOCREATEROLE ] [ CREATEUSER | NOCREATEUSER ] [ LOGIN | NOLOGIN ] [ ENCRYPTED | UNENCRYPTED ] PASSOWRD ‘password’ VALID UNTIL ‘timestamp’ IN ROLE role_name [,…] IN GROUP group_name [,…] ROLE role_name [,…] ADMIN role_name [,…] USER role_name [,…] SYSID uid 사용자 수정 1ALTER USER [사용자명] RENAME TO [새로운 사용자명]; 사용자 삭제 1DROP USER [사용자명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"}]},{"title":"[PostgreSQL] 사용자 인증","slug":"postgresql-5","date":"2022-11-08T04:39:56.000Z","updated":"2024-01-12T05:46:13.533Z","comments":true,"path":"2022/11/08/postgresql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-5/","excerpt":"","text":"사용자 인증 Postgresql을 처음 설치하게 되면 비밀번호를 묻지 않고 로그인을 할 수 있습니다. 인증과정을 포함하려면 pg_hba.conf 에서 설정해야 합니다. pg_hba.conf 파일은 initdb 에서 생성된 클러스터 폴더에 위치합니다. Authentication Method 필드의 값에 따라서 인증처리가 됩니다. trust: 패스워드 없이 접근 가능 (local 이외에는 비추천) reject: 거부 md5: 패스워드를 md5 로 암호화해서 전송 password: text 로 패스워드를 사용 (스니핑에 바로 보임) 사용 예제 TCP/IP로 127.0.0.1에 접근 시 모든 DB, 사용자로의 접근에 패스워드가 필요 없는 예제입니다. 1host all all 127.0.0.1/32 trust TCP/IP로 192.168.0.1에 접근 시 hgko 계정으로 모든 DB에 대한 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host all hgko 192.168.0.1/32 md5 TCP/IP로 192.168.0.1에 접근 시 hgko 계정으로 mydb, test DB에 대한 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host mydb,test hgko 192.168.0.1/32 md5 원격 어디서든지 remotegroup의 SYSID로 설정된 계정들로 remotedb의 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host remotedb +remotegroup 0.0.0.0/0 md5 모든 호스트로 부터 접속 허용 postgresql.conf 파일을 수정합니다. 1listen_addresses = '*' pg_hba.conf 파일을 수정합니다. 12# TYPE DATABASE USER CIDR-ADDRESS METHODhost all all 0.0.0.0/0 md5 참고 https://www.postgresql.kr/docs/9.5/auth-methods.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"}]},{"title":"[Oracle] 사용자 및 테이블 조회","slug":"oracle-5","date":"2022-11-04T07:57:39.000Z","updated":"2024-01-12T05:44:56.309Z","comments":true,"path":"2022/11/04/oracle-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-5/","excerpt":"","text":"테이블 스페이스 남은 공간 조회 현재 접속한 사용자의 DEFAULT_TABLESPACE 남은 공간을 조회합니다. 123456789101112SELECT ts.tablespace_name, TO_CHAR(SUM(NVL(fs.bytes, 0)) / 1024 / 1024, '99,999,990.99') AS MB_FREEFROM user_free_space fs, user_tablespace ts, user_users usWHERE fs.tablespace_name(+) = ts.tablespace_name AND ts.tablespace_name(+) = us.default_tablespaceGROUP BY ts.tablespace_name; ‘user_’ prefix가 붙게 되면 로그인한 계정에 관련된 내용이 출력됩니다. 사용자 조회 123SQL&gt; SELECT * FROM user_users;SQL&gt; SELECT username, user_id, default_tablespace FROM dba_users;SQL&gt; SELECT * FROM all_users; 테이블 조회 1234SQL&gt; SELECT * FROM tab;SQL&gt; SELECT table_name, tablespace_name FROM user_tables;SQL&gt; SELECT owner, table_name, tablespace_nsme, cluster_name FROM dba_tables;SQL&gt; SELECT * FROM all_tables;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"}]},{"title":"[Oracle] 계정 관리","slug":"oracle-4","date":"2022-11-04T06:44:12.000Z","updated":"2024-01-12T05:19:57.328Z","comments":true,"path":"2022/11/04/oracle-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-4/","excerpt":"","text":"Oracle에서 계정 생성, 삭제 및 권한을 부여하는 방법입니다. 계정 생성 및 권한 부여 12345SQL&gt; CREATE USER [계정] IDENTIFIED BY [비밀번호] DEFAULT TABLESPACE [테이블스페이스명] QUOTA unlimited ON [테이블스페이스명] -- 테이블 스페이스의 내용을 모두 쓸 수 있다. TEMPORARY TABLESPACE [임시테이블스페이스명]; 123456-- 예SQL&gt; CREATE USER test IDENTIFIED BY 123!@#QWE DEFAULT TABLESPACE users QUOTA unlimited ON users TEMPORARY TABLESPACE temp; 계정 기본 테이블 스페이스 변경 12SQL&gt; ALTER USER [계정] DEFAULT TABLESPACE [테이블스페이스명];SQL&gt; ALTER USER [계정] TEMPORARY TABLESPACE [임시테이블스페이스명]; 계정 삭제 CASCADE를 명시하면 계정과 관련된 모든 데이터베이스 스키마가 삭제되고 모든 스키마 객체도 물리적으로 삭제됩니다. 1SQL&gt; DROP USER [계정] CASCADE; 계정별 Lock 상태 조회 12SQL&gt; SELECT username, account_status, to_char(lock_date, 'YYYY-MM-DD HH24:MI') lock_date FROM dba_users; Lock 해제 1SQL&gt; ALTER USER [계정] IDENTIFIED BY [비밀번호] ACCOUNT UNLOCK;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[Oracle] 테이블 스페이스 사용 방법","slug":"oracle-3","date":"2022-11-04T06:44:12.000Z","updated":"2024-01-12T05:19:36.343Z","comments":true,"path":"2022/11/04/oracle-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-3/","excerpt":"","text":"테이블 스페이스(Table Space)란 테이블스페이스(Tablespace)는 데이터베이스 오브젝트 내 실제 데이터를 저장하는 공간이다. 이것은 데이터베이스의 물리적인 부분이며, 세그먼트로 관리되는 모든 DBMS에 대해 저장소(세그먼트)를 할당한다. 테이블스페이스는 단지 데이터베이스 저장소 위치를 지정할 뿐이며, 논리적 데이터베이스 구조나 스키마를 지정하지 않는다. 예를 들면, 동일한 스키마 내의 다른 오브젝트는 서로 다른 테이블스페이스에 놓일 수 있다. 마찬가지로, 하나의 테이블스페이스는 여러 세그먼트들을 서비스할 수 있다. 위키백과 테이블 스페이스 조회 12SQL&gt; SELECT * FROM dba_tablespaces;SQL&gt; SELECT * FROM dba_data_files; 테이블 스페이스 생성 오라클 DBMS는 테이블스페이스 생성을 위해 CREATE TABLESPACE 명령어를 사용합니다. 123SQL&gt; CREATE TABLESPACE [테이블스페이스명] DATAFILE '/db/oracle_data/ts.dbf' SIZE 200M autoextent on next 100M; DATAFILE: 파일 경로 SIZE: 초기 데이터 파일 크기 설정 autoextent on next: 초기 크기 공간을 모두 사용하는 경우 자동으로 파일의 크기가 커지는 기능 테이블 스페이스 삭제 123SQL&gt; DROP TABLESPACE [테이블스페이스명] INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS; INCLUDING CONTENTS: 테이블 스페이스의 모든 세그먼트 삭제 INCLUDING CONTENTS AND DATAFILES: 테이블 스페이스의 물리적파일까지 삭제 CASCADE CONSTRAINTS: 제약 조건 삭제 테이블 스페이스 이동 12SQL&gt; ALTER TABLE [테이블명] MOVE TABLESPACE [테이블스페이스명];SQL&gt; ALTER INDEX [인덱스명] REBUILD TABLESPACE [테이블스페이스명];","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[CentOS] Service 등록 및 실행 방법","slug":"linux-21","date":"2022-11-03T08:07:08.000Z","updated":"2024-01-12T05:18:34.961Z","comments":true,"path":"2022/11/03/linux-21/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/linux-21/","excerpt":"","text":"리눅스 환경에서 Tomcat을 구동하는 서비스를 등록하고 실행하는 방법에 대해 알아보겠습니다. Service 파일 생성 /etc/systemd/system/ 위치에 service 파일을 생성합니다. 1$ sudo vi /etc/systemd/system/tomcat-server.service 1234567891011121314[Unit]Description=TOMCAT SERVER ServiceAfter=network.target syslog.target[Service]Type=forkingUser=rootGroup=rootExecStart=/usr/local/tomcat-server/bin/startup.shExecStop=/usr/local/tomcat-server/bin/shutdown.sh[Install]WantedBy=multi-user.target Description: 서비스 설명 ExecStart: 실행할 서버 및 프로그램이 위치한 전체 경로 ExecStop: 종료할 서버 및 프로그램이 위치한 전체 경로 WantedBy: systemctl enable 명령어로 유닛을 등록할 때 등록에 필요한 유닛 지정 Service 등록 생성한 서비스를 등록합니다. 1$ sudo systemctl enable tomcat-server.service Service 비활성화 1$ sudo systemctl disable tomcat-server.service Service 시작 1$ sudo systemctl start tomcat-server.service Service 재시작 1$ sudo systemctl restart tomcat-server.service Service 종료 1$ sudo systemctl stop tomcat-server.service Service 실행 확인 1$ sudo systemctl status tomcat-server.service Service 목록 확인 1$ sudo systemctl list-unit-files","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"WGS84 - 도분초 변환","slug":"satellite-wgs84","date":"2022-11-03T07:58:10.000Z","updated":"2024-01-12T05:18:54.908Z","comments":true,"path":"2022/11/03/satellite-wgs84/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/satellite-wgs84/","excerpt":"","text":"세계 지구 좌표 시스템(World Geodetic System, WGS) 1984년에 제정된 범 지구적 측위 시스템으로 지도학, 측지학, 항법에 많이 사용된다. GPS측량 시 WGS84 타원체를 사용한다. 통칭 및 약칭은 WGS 84 (aka WGS 1984, EPSG:4326, WGS84)라고 부르며, 2004년에 마지막으로 개정되었다. 이전에 쓰던 초안으로 WGS 72, WGS 66, 그리고 WGS 60이 있다. 위키백과 3735.0079는 위도로서 37도 35.0079분을 뜻합니다. 도(degree) 단위로 환산 시, 대략 37.5도가 됩니다. 12701.6446은 경도로서 127도 1.6446분을 뜻합니다. 도(degree) 단위로 환산 시, 대략 127.0도가 됩니다. DDMM.MMMM , DDDMM.MMMM 형식입니다. 일반적으로 WGS84 좌표라고 하면서 37.494961 , 127.030380 이런식으로 이용하면 그냥 37점494961도 라고 읽으면 됩니다. 도분초 변환 도를 도 분 초로 변환하는 자바 소스 코드입니다. 12345678910float lat = 37.494961;float lon = 127.030380;lat_do = (int)lat;lat_min = (lat - (int)lat) * 60;lat_sec = ((lat - (int)lat) * 60 - lat_min) * 60;lon_do = (int)lon;lon_min = (lon - (int)lon) * 60;lon_sec = ((lon - (int)lon) * 60 - lon_min) * 60;","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"}]},{"title":"Angular Development with TypeScript","slug":"book-2","date":"2022-11-02T03:40:45.000Z","updated":"2024-01-12T05:18:09.868Z","comments":true,"path":"2022/11/02/book-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/02/book-2/","excerpt":"","text":"책 정보 책 소개 Angular는 Google이 주관하는 웹 애플리케이션 프레임워크다. 개발자들에게 큰 인기를 끌었던 이전 버전의 AngularJS는 이제 새로운 구조와 철학을 도입해서 완전히 새로운 프레임워크가 되어 돌아왔다. 새로운 버전의 Angular에서 제공하는 훌륭한 기능과 웹 컴포넌트 기반 철학을 깊이 있게 알아보고, 데이터를 뷰에 표시하는 방법, 사용자가 입력한 폼 데이터 처리, 서버와 통신, 테스트와 배포까지 애플리케이션의 모든 개발 단계를 다룬다. 더불어 현업에 바로 적용할 수 있도록 다양한 예제와 함께 설명하며, 중대형 규모의 애플리케이션 개발에 적합한 TypeScript와 ES6에 대해서도 알아본다. 이 책을 마지막까지 읽고 나면, 실무에 바로 도입할 수준이 될 것이다. 리뷰 최근 Angular로 프로젝트를 진행할 일이 생겨서 읽게 되었습니다. 예전에 나온 책이라 최근 Angular 버전과는 차이가 있지만 각 핵심 내용이 잘 정리가 되어 있고 번역서임에도 불구하고 번역이 굉장히 깔끔하였습니다. 분량이 많아 필요한 부분을 정독했는데 좋은 예제들로 쉽게 이해시켜 줘서 프로젝트를 진행하는데 도움이 많이 된 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[MariaDB] 계정 생성 및 권한 부여","slug":"mariadb-1","date":"2022-10-28T08:19:20.000Z","updated":"2024-01-12T05:17:00.520Z","comments":true,"path":"2022/10/28/mariadb-1/","link":"","permalink":"http://hgko1207.github.io/2022/10/28/mariadb-1/","excerpt":"","text":"MariaDB에서 계정을 생성하고 권한을 부여하는 방법입니다. 로그인 root의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MariaDB [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 12345678910MariaDB [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+4 rows in set (0.002 sec) 계정 생성 로컬에서만 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'localhost' IDENTIFIED BY 'test!@'; 로컬 및 원격에서 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'%' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'%' IDENTIFIED BY 'test!@'; 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. 1grant all privileges on *.* to '계정명'@'%' identified by '비밀번호'; 1234-- 예MariaDB [mysql]&gt; grant all privileges on *.* to 'test'@'%' identified by 'test!@';-- 변경된 권한 적용MariaDB [mysql]&gt; flush privileges; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; 123-- 예)MariaDB [mysql]&gt; grant all privileges on test_db.* to 'test'@'%' identified by 'test!@';MariaDB [mysql]&gt; flush privileges; 확인 계정 생성이 완료되면 생성된 계정으로 로그인합니다. 1$ sudo mysql -u test -p","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"}]},{"title":"[CentOS] MariaDB 설치","slug":"linux-20","date":"2022-10-26T04:32:16.000Z","updated":"2024-01-12T05:14:16.404Z","comments":true,"path":"2022/10/26/linux-20/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/linux-20/","excerpt":"","text":"리눅스 환경에서 MariaDB 설치 방법에 대해 알아보겠습니다. MariaDB 란 MariaDB는 오픈 소스의 관계형 데이터베이스 관리 시스템이다. MySQL과 동일한 소스 코드를 기반으로 하며, GPL v2 라이선스를 따른다. 오라클 소유의 현재 불확실한 MySQL의 라이선스 상태에 반발하여 만들어졌으며, 배포자는 몬티 프로그램 AB와 저작권을 공유해야 한다. 위키백과 MariaDB 저장소 추가 yum 저장소에는 MariaDB 라이브러리가 없기 때문에 저장소를 추가합니다. MariaDB Server 다운로드 사이트에 연결한 후에 MariaDB Repositories 탭을 클릭합니다. 사용하는 배포판을 선택합니다. 설치할 버전을 선택합니다. 미러 사이트를 선택합니다. 4번에 있는 내용을 아래 명령어를 실행한 후에 복사합니다. 1[root@localhost ~]$ vi /etc/yum.repos.d/MariaDB.repo 1234567891011# MariaDB 10.4 CentOS repository list - created 2023-06-02 08:54 UTC# https://mariadb.org/download/[mariadb]name = MariaDB# rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details.# baseurl = https://rpm.mariadb.org/10.4/centos/$releasever/$basearchbaseurl = https://tw1.mirror.blendbyte.net/mariadb/yum/10.4/centos/$releasever/$basearchmodule_hotfixes = 1# gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDBgpgkey = https://tw1.mirror.blendbyte.net/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck = 1 설치 저장소를 추가하였다면 설치를 합니다. 1[root@localhost ~]$ sudo yum install MariaDB-server MariaDB-client 설치 확인 잘 설치가 되었는지 확인합니다. 12345[root@localhost ~]$ rpm -qa | grep MariaDBMariaDB-common-10.4.26-1.el7.centos.x86_64MariaDB-client-10.4.26-1.el7.centos.x86_64MariaDB-server-10.4.26-1.el7.centos.x86_64MariaDB-compat-10.4.26-1.el7.centos.x86_64 서비스 시작 부팅 시 자동시작되도록 서비스를 등록하고 시작합니다. 12[root@localhost ~]$ systemctl enable mariadb[root@localhost ~]$ systemctl start mariadb 패스워드 변경 패스워드를 변경합니다. 1[root@localhost ~]$ /usr/bin/mysqladmin -u root password '패스워드' 접속 확인 다음 명령어를 실행한 후 패스워드를 입력하면 접속이 됩니다. 1234567891011[root@localhost ~]$ mysql -u root -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.4.26-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; 모든 IP 허용 외부에서 접속을 하기 위해 모든 IP가 허용가능하도록 설정합니다. 12MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '패스워드';MariaDB [(none)]&gt; FLUSH PRIVILEGES; 방화벽 포트 개방 12[root@localhost ~]$ netstat -anp | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 12596/mysqld Mariadb 포트는 3306입니다. 외부에서 접속하기 위해 3306 포트를 개방합니다. 123456# 포트 개방[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3306/tcp# 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload# 개방된 포트 목록 확인[root@localhost ~]$ firewall-cmd --list-ports 참고 https://zetawiki.com/wiki/CentOS7_MariaDB_%EC%84%A4%EC%B9%98","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"}]},{"title":"NVM 설치 및 사용 방법","slug":"nodejs-4","date":"2022-10-26T01:44:59.000Z","updated":"2024-01-12T05:14:48.256Z","comments":true,"path":"2022/10/26/nodejs-4/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/nodejs-4/","excerpt":"","text":"Windows 환경에서 NVM를 설치하고 Node 버전을 관리하는 방법에 대해 알아보겠습니다. NVM(Node Version Manager) NVM 은 Node.js의 버전을 관리하는 도구입니다. 여러 개의 Node.js 버전을 설치할 수 있고 설치된 모든 버전을 확인할 수 있습니다. 그리고 필요에 따라 버전 변경도 할 수 있습니다. 설치 NVM Github Repository 사이트에 접속합니다. nvm-setup.zip 또는 nvm-setup.exe 을 선택하여 다운로드하고 설치를 합니다. 사용 NPM 버전 조회 현재 최신의 사용가능한 Node.js 버전이 조회됩니다. 1$ nvm list available NPM 설치 원하는 버전을 입력하여 설치합니다. 1$ nvm install [node version] 예시입니다. 12$ nvm install 19.0.0$ nvm install 18.11.0 설치 확인 설치되어 있는 Node.js 버전들이 조회됩니다. 1$ nvm list 버전 변경 설치된 Node.js 버전들 중에서 사용하려는 버전으로 변경할 수 있습니다. 1$ nvm use [node version] 예시입니다. 1$ nvm use 18.11.0 Node.js 버전 확인 Node.js 버전이 설치 또는 변경되었는지 확인합니다. 1$ node -v 여기까지 NVM 설치 및 사용 포스팅을 마치겠습니다. 참고 https://github.com/nvm-sh/nvm","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"}]},{"title":"[JavaScript] 주민등록번호 유효성 검사","slug":"js-dev-5","date":"2022-10-23T08:26:18.000Z","updated":"2024-01-12T05:13:56.237Z","comments":true,"path":"2022/10/23/js-dev-5/","link":"","permalink":"http://hgko1207.github.io/2022/10/23/js-dev-5/","excerpt":"","text":"JavaScript에서 주민등록번호 유효성 검사 방법에 대해 알아보겠습니다. 주민등록번호란 주민등록번호는 “주민의 거주관계를 파악하고 상시로 인구의 동태를 명확히 하여 행정사무의 적정하고 간이 한 처리를 도모함”(1962년 주민등록법) 등을 목적으로 만든 일련번호로서, 개개인의 신원을 명확하게 구분하는 역할을 한다. 나무위키 내국인과 외국인 주민등록번호 유효성을 검사하는 소스코드입니다. 내국인 주민등록번호와 달리 외국인 등록번호는 뒤 7자리 숫자의 첫 숫자가 2000년 이전 출생 외국인에게는 남자는 5, 여자는 6, 2000년 이후 출생 외국인에게는 남자는 7, 여자는 8로 부여하고 있습니다. 내국인 주민등록번호 숫자는 1, 2, 3, 4 로 시작됩니다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;label class=\"font-weight-bold\"&gt;주민등록번호 입력 :&lt;/label&gt; &lt;div class=\"d-flex align-items-center\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"jumin1\" required /&gt; &lt;span class=\"font-weight-bold mx-2\"&gt;-&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" id=\"jumin2\" required /&gt; &lt;/div&gt; &lt;button type=\"button\" onclick=\"validate()\"&gt;검증&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const CommonUtil = (function () &#123; // 내국인/외국인 주민등록번호 유효성 검사 const validRegistrationNumber = function (rn, type) &#123; rn = rn.split('-').join(''); if (rn.length !== 13) return false; let checkSum = 0; for (let i = 0; i &lt; 12; i++) &#123; checkSum += (rn.substr(i, 1) &gt;&gt; 0) * ((i % 8) + 2); &#125; const korMatch = (11 - (checkSum % 11)) % 10 == rn.substr(12, 1); const frnMatch = (13 - (checkSum % 11)) % 10 == rn.substr(12, 1); if (type === 'local') return korMatch; else if (type === 'foreigner') return frnMatch; else return korMatch || frnMatch; &#125;; return &#123; // 주민등록번호가 내국민인지 외국인인지 분류 // 뒤 7자리의 첫번째 숫자가 1,2,3,4 일경우 내국인 / 5,6,7,8 일경우 외국인 validateJumin: function (ssn1, ssn2) &#123; const ssnType = ssn2.substr(0, 1); const rn = ssn1 + ssn2; if (ssnType == '5' || ssnType == '6' || ssnType == '7' || ssnType == '8') &#123; const type = 'foreigner'; &#125; else &#123; const type = 'local'; &#125; return validRegistrationNumber(rn, type); &#125;, &#125;;&#125;)();document.addEventListener('DOMContentLoaded', function () &#123; // 주민등록번호 검증 확인 function validate() &#123; const jumin1 = document.getElementById('jumin1'); const jumin2 = document.getElementById('jumin2'); const ssn1 = jumin1.value; const ssn2 = jumin2.value; return CommonUtil.validateJumin(ssn1, ssn2); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"}]},{"title":"[Python] OpenCV Sharpening","slug":"python-3","date":"2022-10-22T14:41:19.000Z","updated":"2024-01-12T05:13:33.036Z","comments":true,"path":"2022/10/22/python-3/","link":"","permalink":"http://hgko1207.github.io/2022/10/22/python-3/","excerpt":"","text":"Python에서 OpenCV를 사용하여 Sharpening 하는 방법에 대해 알아보겠습니다. Sharpening Sharpening 기법은 Bluring과 반대되는 개념으로, 초점이 잘 맞은 사진처럼 사물의 윤곽이 뚜렷하고 선명한 느낌이 나도록 하는 것이다. 설치 Python 에서 OpenCV 를 사용하기 위해 패키지를 설치합니다. 1$ pip install opencv-python 예제 원본 이미지에 여러가지의 커널을 적용하여 선명하게 표현하였습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import cv2import numpy as npimport matplotlib.pyplot as pltimage = cv2.imread('images/lenna.png', cv2.IMREAD_GRAYSCALE)# 커널 생성(대상이 있는 픽셀을 강조)kernel_sharpen_1 = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])kernel_sharpen_2 = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])kernel_sharpen_3 = np.array([[1, 1, 1], [1, -7, 1], [1, 1, 1]])kernel_sharpen_4 = np.array([[-1, -1, -1, -1, -1], [-1, 2, 2, 2, -1], [-1, 2, 8, 2, -1], [-1, 2, 2, 2, -1], [-1, -1, -1, -1, -1]]) / 8.0smoothed = cv2.GaussianBlur(image, (5, 5), 1)unsharped = cv2.addWeighted(image, 1.5, smoothed, -0.5, 0)# 커널 적용image_sharp1 = cv2.filter2D(image, 0, kernel_sharpen_1)image_sharp2 = cv2.filter2D(image, 0, kernel_sharpen_2)image_sharp3 = cv2.filter2D(image, 0, kernel_sharpen_3)image_sharp4 = cv2.filter2D(image, 0, kernel_sharpen_4)fig, ax = plt.subplots(2, 3, figsize=(10, 5))ax[0][0].imshow(image, cmap='gray')ax[0][0].set_title('Original Image')ax[0][1].imshow(unsharped, cmap='gray')ax[0][1].set_title('addWeighted')ax[0][2].imshow(image_sharp1, cmap='gray')ax[0][2].set_title('image_sharp1')ax[1][0].imshow(image_sharp2, cmap='gray')ax[1][0].set_title('image_sharp2')ax[1][1].imshow(image_sharp3, cmap='gray')ax[1][1].set_title('image_sharp3')ax[1][2].imshow(image_sharp4, cmap='gray')ax[1][2].set_title('image_sharp4')plt.show(); 결과 필터에 따라 Sharpening 적용된 이미지를 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"}]},{"title":"[Angular] Cytoscape 사용 방법","slug":"angular-8","date":"2022-10-12T06:53:50.000Z","updated":"2024-01-12T05:12:39.088Z","comments":true,"path":"2022/10/12/angular-8/","link":"","permalink":"http://hgko1207.github.io/2022/10/12/angular-8/","excerpt":"","text":"Cytoscape 소개 Cytoscape은 점 (node)과 선 (edge)으로 이루어진 네트워크의 가시화, 통합, 분석을 가능하게 하는 프리 오픈소스 소프트웨어입니다. 자바로 구현되어 있어 윈도우, 맥, 리눅스등에서 자유롭게 구동합니다. Cytoscape 라이브러리를 사용하여 노드 간의 절차를 시각화하는 그래프를 구현하는 방법에 대해 알아보겠습니다. 설치 cytoscape 패키지를 설치합니다. 1$ npm install --save cytoscape cytoscape-klay TypeScript 사용 시 추가로 설치합니다. 1$ npm install --save-dev @types/cytoscape 설정 angular.json 파일에서 다음의 내용을 추가합니다. 1\"scripts\": [\"./node_modules/cytoscape/dist/cytoscape.min.js\"], 예제 app.component.html 1&lt;div id=\"cy\"&gt;&lt;/div&gt; 그래프의 스타일을 정의합니다. app.component.scss 12345#cy &#123; height: 300px; width: 100%; display: block;&#125; cytoscape 패키지를 import 합니다. 기본적으로 container, elements, style 및 layout 옵션을 설정합니다. 노드 간의 연결을 시각화 하기 위해 layout 에 klay를 정의합니다. app.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import &#123; Component, OnInit &#125; from '@angular/core';import cytoscape from 'cytoscape';import klay from 'cytoscape-klay';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; /** * constructor */ constructor() &#123;&#125; /** * ngOnInit */ ngOnInit(): void &#123; cytoscape.use(klay); const cy = cytoscape(&#123; container: document.getElementById('cy'), // container to render in elements: [ // node &#123; data: &#123; id: 'step1', name: 'step1' &#125; &#125;, &#123; data: &#123; id: 'step2', name: 'step2' &#125; &#125;, &#123; data: &#123; id: 'step3', name: 'step3' &#125; &#125;, &#123; data: &#123; id: 'step4', name: 'step4' &#125; &#125;, // edge &#123; data: &#123; id: '1', source: 'step1', target: 'step2' &#125; &#125;, &#123; data: &#123; id: '2', source: 'step1', target: 'step3' &#125; &#125;, &#123; data: &#123; id: '3', source: 'step2', target: 'step4' &#125; &#125;, &#123; data: &#123; id: '4', source: 'step3', target: 'step4' &#125; &#125;, ], style: [ // the stylesheet for the graph &#123; selector: 'node', style: &#123; content: 'data(name)', shape: 'rectangle', 'text-wrap': 'wrap', 'text-halign': 'center', 'text-valign': 'center', 'background-color': '#6FB1FC', width: '40px', height: '40px', color: 'black', 'font-size': '10px', &#125;, &#125;, &#123; selector: 'edge', style: &#123; 'curve-style': 'bezier', 'line-color': '#000000', 'target-arrow-shape': 'triangle', 'target-arrow-fill': 'filled', 'target-arrow-color': '#000000', width: '1px', 'line-style': 'solid', opacity: 0.666, &#125;, &#125;, ], layout: &#123; name: 'klay', &#125;, &#125;); const options = &#123; name: 'klay', nodeDimensionsIncludeLabels: true, klay: &#123; borderSpacing: 100, fixedAlignment: 'BALANCED', edgeRouting: 'POLYLINE', edgeSpacingFactor: 10, inLayerSpacingFactor: 2.0, layoutHierarchy: true, linearSegmentsDeflectionDampening: 3.0, spacing: 30, mergeEdges: false, &#125;, &#125;; cy.layout(options).run(); &#125;&#125; 아래 참고 사이트에서 예제 및 옵션 설정에 대해 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://js.cytoscape.org/ https://github.com/cytoscape/cytoscape.js","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"}]},{"title":"[Angular] Markdown 사용 방법","slug":"angular-7","date":"2022-09-29T04:30:09.000Z","updated":"2024-01-12T05:12:00.606Z","comments":true,"path":"2022/09/29/angular-7/","link":"","permalink":"http://hgko1207.github.io/2022/09/29/angular-7/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular에서 ngx-markdown 패키지를 사용하여 Markdown 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown 패키지를 설치합니다. 1$ npm install ngx-markdown --save 설정 angular.json 파일에서 다음의 내용을 추가합니다. 123456789101112131415&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"scripts\": [ \"node_modules/marked/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; 예제 MarkdownModule을 import 합니다. 1234567891011121314// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; MarkdownModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, MarkdownModule.forRoot()], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; markdown 태그를 사용하여 작성합니다. 1234567&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;markdown [data]=\"markdownText\"&gt;&lt;/markdown&gt; &lt;/div&gt;&lt;/div&gt; markdownText에 임시로 데이터를 입력합니다. 123456789101112131415161718// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; constructor() &#123; this.markdownText = `# Test`; &#125; ngOnInit(): void &#123;&#125;&#125; 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://www.npmjs.com/package/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"}]},{"title":"[Angular] Markdown Editor 사용 방법","slug":"angular-6","date":"2022-09-28T01:07:39.000Z","updated":"2024-01-12T05:08:34.220Z","comments":true,"path":"2022/09/28/angular-6/","link":"","permalink":"http://hgko1207.github.io/2022/09/28/angular-6/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular에서 ngx-markdown-editor 패키지를 사용하여 Markdown Editor 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown-editor와 ace-builds, bootstrap, font-awesome 패키지도 필수로 설치합니다. 12$ npm install ngx-markdown-editor --save$ npm install ace-builds bootstrap font-awesome --save 설정 angular.json 파일에서 다음 내용을 추가합니다. 12345678910111213141516171819202122232425262728&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"assets\": [ &#123; \"glob\": \"**/*\", \"input\": \"node_modules/ace-builds/src-min\", \"output\": \"./assets/ace-builds/\" &#125; ], \"styles\": [ \"node_modules/bootstrap/dist/css/bootstrap.min.css\", \"node_modules/font-awesome/css/font-awesome.min.css\", \"node_modules/ngx-markdown-editor/assets/highlight.js/agate.min.css\" ], \"scripts\": [ \"node_modules/ngx-markdown-editor/assets/highlight.js/highlight.min.js\", \"node_modules/ngx-markdown-editor/assets/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; index.html 파일에서 아래 내용을 추가합니다. 123456&lt;html&gt; &lt;head&gt; &lt;script src=\"/assets/ace-builds/ace.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 예제 LMarkdownEditorModule을 import 합니다. 12345678910111213141516// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; LMarkdownEditorModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, FormsModule, AppRoutingModule, LMarkdownEditorModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; md-editor 태그를 사용하여 작성합니다. 123456789101112131415161718&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;md-editor id=\"description\" name=\"description\" [upload]=\"doUpload\" [(ngModel)]=\"markdownText\" [mode]=\"mode\" [options]=\"options\" required height=\"400px\" &gt;&lt;/md-editor&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Option, Text, Mode, Upload 설정을 합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; UploadResult, MdEditorOption &#125; from 'ngx-markdown-editor';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; public mode: string = 'editor'; public options: MdEditorOption; constructor() &#123;&#125; /** * 이미지 파일 Upload * @param files * @returns */ doUpload(files: Array&lt;File&gt;): Promise&lt;Array&lt;UploadResult&gt;&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result: Array&lt;UploadResult&gt; = []; for (let file of files) &#123; result.push(&#123; name: file.name, url: `https://avatars3.githubusercontent.com/$&#123;file.name&#125;`, isImg: file.type.indexOf('image') !== -1, &#125;); &#125; resolve(result); &#125;, 3000); &#125;); &#125; ngOnInit(): void &#123; // markdown editor option 설정 this.options = &#123; showPreviewPanel: false, enablePreviewContentClick: false, resizable: true, customRender: &#123; image: function (href: string, title: string, text: string) &#123; let out = `&lt;img style=\"max-width: 100%; border: 20px solid red;\" src=\"$&#123;href&#125;\" alt=\"$&#123;text&#125;\"`; if (title) &#123; out += ` title=\"$&#123;title&#125;\"`; &#125; out += (&lt;any&gt;this.options).xhtml ? '/&gt;' : '&gt;'; return out; &#125;, &#125;, &#125;; &#125;&#125; Markdown Editor 구현된 이미지입니다. 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://openbase.com/js/ngx-markdown-editor https://openbase.com/js/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"}]},{"title":"[Angular] Can't resolve crypto 오류 해결 방법","slug":"angular-5","date":"2022-09-21T06:42:48.000Z","updated":"2024-01-12T05:07:54.201Z","comments":true,"path":"2022/09/21/angular-5/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-5/","excerpt":"","text":"Angular에서 Web3를 사용할 경우 다음과 같은 오류가 발생할 경우가 있습니다. 1234Module not found: Error: Can't resolve 'crypto' in ...Module not found: Error: Can't resolve 'stream' in ...Module not found: Error: Can't resolve 'fs' in ...Module not found: Error: Can't resolve 'os' in ... 12345678[NG_SERVE] BREAKING CHANGE: webpack &lt; 5 used to include polyfills for node.js core modules by default.[NG_SERVE] This is no longer the case. Verify if you need this module and configure a polyfill for it.[NG_SERVE][NG_SERVE] If you want to include a polyfill, you need to:[NG_SERVE] - add a fallback 'resolve.fallback: &#123; \"stream\": require.resolve(\"stream-browserify\") &#125;'[NG_SERVE] - install 'stream-browserify'[NG_SERVE] If you don't want to include a polyfill, you can use an empty module like this:[NG_SERVE] resolve.fallback: &#123; \"stream\": false &#125; polyfill.ts 파일에 내용을 추가하는 방법도 있지만 Webpack을 구성하여 해결하였습니다. 해결 방법 설치 사용자 지정 웹팩 구성을 하여 빌드 및 실행할 수 있도록 custom-webpack 패키지를 설치합니다. 1$ npm install --save-dev @angular-builders/custom-webpack 오류가 발생하는 모듈의 패키지를 설치합니다. 1$ npm install --save-dev stream-http https-browserify 생성 custom-webpack.config.js 파일을 생성하고 다음 내용을 추가합니다. 123456789101112131415const webpack = require('webpack');module.exports = &#123; resolve: &#123; fallback: &#123; http: require.resolve('stream-http'), https: require.resolve('https-browserify'), fs: false, crypto: false, os: false, stream: false, assert: false, &#125;, &#125;,&#125;; 적용 angular.json 파일의 내용을 수정합니다. builder 와 options 부분을 custom-webpack으로 수정합니다. 1234567891011121314151617181920\"architect\": &#123; ... \"build\": &#123; \"builder\": \"@angular-builders/custom-webpack:browser\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"customWebpackConfig\": &#123; \"path\": \"./custom-webpack.config.js\", // 생성한 파일 적용 \"replaceDuplicatePlugins\": true &#125;, ... &#125;, ... &#125;, \"serve\": &#123; \"builder\": \"@angular-builders/custom-webpack:dev-server\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"browserTarget\": \"test-project:build\" &#125; &#125;&#125; Angular를 재실행하면 오류들이 없어진 것을 확인할 수 있습니다. 참고 https://www.npmjs.com/package/@angular-builders/custom-webpack","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Angular] process is not defined 해결 방법","slug":"angular-4","date":"2022-09-21T00:34:20.000Z","updated":"2023-07-20T14:30:35.135Z","comments":true,"path":"2022/09/21/angular-4/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-4/","excerpt":"","text":"Angular 14 버전을 사용하면서 ERROR ReferenceError: process is not defined 오류가 발생할 경우 해결 방법입니다. 설치 process 패키지를 설치합니다. 1$ npm install --save-dev process 내용 추가 src/polyfill.ts 파일을 열고 다음 내용을 추가합니다. 123(window as any).global = window;global.Buffer = global.Buffer || require('buffer').Buffer;global.process = require('process');","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"node-gyp 설치 오류 해결 방법","slug":"nodejs-3","date":"2022-09-16T00:30:27.000Z","updated":"2024-01-12T05:07:04.698Z","comments":true,"path":"2022/09/16/nodejs-3/","link":"","permalink":"http://hgko1207.github.io/2022/09/16/nodejs-3/","excerpt":"","text":"node-gyp 설치 과정 중 오류가 발생하였을 때 해결 방법입니다. npm 버전 확인 npm 버전을 확인하고 버전에 맞게 수행합니다. 1$ npm --version Windows PowerShell 또는 명령 프롬프트(cmd.exe)를 &quot;관리자 권한으로 실행&quot;으로 실행합니다. 먼저 node 가 설치된 디렉토리로 이동합니다. 1$ cd \"C:\\Program Files\\nodejs\" npm 버전이 7 미만인 경우 12$ cd node_modules\\npm\\node_modules\\npm-lifecycle$ npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 12$ cd node_modules\\npm\\node_modules\\@npmcli\\run-script$ npm install node-gyp@latest Linux, MacOS 다음 명령어를 실행하면 됩니다. 권한 오류가 나서 실패하면 앞에 sudo 명령어를 추가합니다. npm 버전이 7 미만인 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/npm-lifecycle -g -- npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/@npmcli/run-script -g -- npm_config_global=false npm install node-gyp@latest 참고 https://github.com/nodejs/node-gyp/blob/main/docs/Updating-npm-bundled-node-gyp.md","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"node-gyp","slug":"node-gyp","permalink":"http://hgko1207.github.io/tags/node-gyp/"}]},{"title":"npm install 시 gyp ERR! 해결 방법","slug":"nodejs-2","date":"2022-09-05T04:39:40.000Z","updated":"2024-01-12T01:40:07.197Z","comments":true,"path":"2022/09/05/nodejs-2/","link":"","permalink":"http://hgko1207.github.io/2022/09/05/nodejs-2/","excerpt":"","text":"npm install 시 **gyp ERR!**로 시작하는 설치 에러가 발생할 경우 해결 방법을 정리하였습니다. 첫 번째 방법 Microsoft 의 windows-build-tools 설치합니다. 관리자 권한으로 PowerShell 또는 터미널을 열고 다음 명령어를 실행하여 설치합니다. npm 버전이 8 이상 설치가 되어 있어야 합니다. 1$ npm install --global windows-build-tools 두 번째 방법 1) Visual Studio Download https://visualstudio.microsoft.com/ko/downloads/ 사이트를 접속해서 Visual Studio를 다운로드합니다. 2) C++ 설치 Visual Studio Installer에서 Desktop development with C++ 선택 후 설치 3) msvs_version, msbuild_path 설정 12$ npm config set msvs_version 2022$ npm config set msbuild_path \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\Msbuild\\Current\\Bin\\MSBuild.exe\" msvs_version, msbuild_path를 설정할 때 다른 버전이 설치되어 있으면 변경합니다. 설치 1$ npm install -g node-gyp 프로젝트에서 설치합니다. 1$ npm install 참고 https://exerror.com/errerr-find-vsfind-vs-msvs_version-not-set-from-command-line-or-npm-config-vcinstalldir-not-set/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[React] Animations 사용 방법","slug":"react-11","date":"2022-08-28T13:50:48.000Z","updated":"2024-01-12T01:37:52.737Z","comments":true,"path":"2022/08/28/react-11/","link":"","permalink":"http://hgko1207.github.io/2022/08/28/react-11/","excerpt":"","text":"Framer Motion을 사용하여 애니메이션을 간편하고 쉽게 만드는 방법을 알아보겠습니다. Framer Motion Framer는 디자이너들을 위해 프로토타입 등을 만들어 주는 회사입니다. Framer Motion은 React 용 production-ready 모션 라이브러리입니다. 설치 1$ npm install framer-motion 사용 Animation Framer Motion의 애니메이션은 모션 컴포넌트의 유연한 animate 속성을 통해 제어됩니다. 간단한 애니메이션의 경우 animate props에서 직접 값을 설정할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 360 &#125;&#125; transition=&#123;&#123; duration: 2 &#125;&#125; initial initial: boolean | Target | VariantLabels (애니메이션의 초기값 지정) 속성, 변형 레이블 또는 시작할 변형 레이블의 배열입니다. animate의 값으로 초기화하려면 false로 설정합니다(마운트 애니메이션 비활성화).https://www.framer.com/docs/component/###initial Transition Transition은 값이 한 상태에서 다른 상태로 움직이는 방식을 정의합니다. 또한 Tween, Spring 또는 Inertia를 사용할 애니메이션 유형을 정의하는 소품을 허용할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 180 &#125;&#125; transition=&#123;&#123; type: 'spring' &#125;&#125; 예제 initial, animate, transition을 사용하여 사각형이 회전하고 튕기는 애니메이션을 구현하였습니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';import &#123; motion &#125; from 'framer-motion';const Wrapper = styled.div` display: flex; max-width: 680px; width: 100vw; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Box = styled(motion.div)` width: 200px; height: 200px; background-color: white; border-radius: 15px; box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.06);`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box transition=&#123;&#123; type: 'spring', delay: 0.5 &#125;&#125; initial=&#123;&#123; scale: 0 &#125;&#125; animate=&#123;&#123; scale: 1, rotate: 360 &#125;&#125; /&gt; &lt;/Wrapper&gt; );&#125;export default App; 참고 https://www.framer.com/motion https://www.framer.com/docs/animation https://www.framer.com/docs/transition","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"Framer Motion","slug":"Framer-Motion","permalink":"http://hgko1207.github.io/tags/Framer-Motion/"}]},{"title":"[CentOS] alias 등록 방법","slug":"linux-19","date":"2022-08-23T04:40:33.000Z","updated":"2024-01-12T01:36:36.643Z","comments":true,"path":"2022/08/23/linux-19/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-19/","excerpt":"","text":"alias 란 alias는 별칭이라는 뜻으로 리눅스에서 alias는 사용자가 명령어를 다른 이름으로 바꿔서 사용할 수 있는 쉘 내부 명령어를 말합니다. 이 alias를 통해서 일일이 입력하기 번거로운. 길이가 긴 명령어를 간단한 이름으로 바꿔서 등록하여 업무 효율을 높일 수 있습니다. alias 확인 현재 등록된 alias 리스트를 확인할 수 있습니다. 1234567891011$ aliasalias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l.='ls -d .* --color=auto'alias ll='ls -l --color=auto'alias ls='ls --color=auto'alias mv='mv -i'alias rm='rm -i'... alias 등록 명령어 별칭은 alias 명령어별칭='명령어'의 형식으로 등록합니다. 다음의 예제처럼 등록하면 run_tomcat 라는 명령어를 실행할 경우 tomcat 이 실행됩니다. 12# alias 명령어별칭 = '명령어'$ alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start' alias 해제 unalias 명령어를 사용하여 등록된 alias를 삭제할 수 있습니다. 1$ unalias run_tomcat alias 영구 등록 위에서 등록된 alias 들은 시스템을 재부팅하고 나면 다시 초기화가 되어 매번 재 설정해줘야 한다는 불편함이 있습니다. 이러한 문제를 방지하려면 alias 를 ./bashrc이나 .bash_aliases 파일에 등록해서 사용해야 합니다. 재부팅이 되더라도 등록해 둔 alias가 영구 지속됩니다. 1$ vi ~/.bashrc ./bashrc 파일을 열고 alias를 추가합니다. 123alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start'alias stop_tomcat='/usr/local/tomcat8/bin/catalina.sh stop'alias tomcat_logs='tail -n 150 -f /usr/local/tomcat8/logs/catalina.out' bashrc 파일을 수정하면 바로 적용되지 않고 source 명령어를 사용하여 동기화를 해야 합니다. 1$ source ~/.bashrc 위의 방법으로 alias 별칭을 편리하게 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"}]},{"title":"[CentOS] Tomcat 다중 설치 및 운영 방법","slug":"linux-18","date":"2022-08-23T04:13:31.000Z","updated":"2024-01-12T01:35:37.710Z","comments":true,"path":"2022/08/23/linux-18/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-18/","excerpt":"","text":"리눅스 환경에서 Tomcat을 다중 설치하고 운영하는 방법에 대해 알아보겠습니다. 1. Tomcat 설치 이전 글 [CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법 을 보면서 Tomcat 을 설치합니다. 설치된 Tomcat 폴더를 서로 다른 이름의 폴더로 복사합니다. 12- tomcat1 : /usr/local/tomcat_1- tomcat2 : /usr/local/tomcat_2 2. catalina.sh 파일 수정 /bin/catalina.sh 파일을 열고 다음 내용을 추가합니다. 1234export CATALINA_HOME=[Tomcat Path]export TOMCAT_HOME=[Tomcat Path]export CATALINA_BASE=[Tomcat Path]CATALINA_PID=[Tomcat Path]/bin/tomcat.pid tomcat1 1234export CATALINA_HOME=/usr/local/tomcat_1export TOMCAT_HOME=/usr/local/tomcat_1export CATALINA_BASE=/usr/local/tomcat_1CATALINA_PID=/usr/local/tomcat_1/bin/tomcat.pid tomcat2 1234export CATALINA_HOME=/usr/local/tomcat_2export TOMCAT_HOME=/usr/local/tomcat_2export CATALINA_BASE=/usr/local/tomcat_2CATALINA_PID=/usr/local/tomcat_2/bin/tomcat.pid 3. 포트 변경 /conf/server.xml 파일에서 포트를 수정합니다. Tomcat 마다 포트 3개를 다르게 입력해야 합니다. 다음과 같이 tomcat1 은 80XX, tomcat2 은 81XX 포트로 변경합니다. 123Server Port 는 8005, 8105Connector Port 는 8080, 8180AJP/1.3 Port 는 8009, 8109 tomcat1 12345678910...&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... tomcat2 12345678910...&lt;Server port=\"8105\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8180\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8109\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... 4. 방화벽 해제 설정된 HTTP 포트의 방화벽을 해제합니다. 123$ sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent$ sudo firewall-cmd --zone=public --add-port=8180/tcp --permanent$ sudo firewall-cmd --reload 서비스를 시작 시킨 후 각각의 서비스 포트로 접속해서 제대로 동작하는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"}]},{"title":"[React] reference 사용 방법","slug":"react-10","date":"2022-08-21T13:58:27.000Z","updated":"2024-01-12T01:35:13.373Z","comments":true,"path":"2022/08/21/react-10/","link":"","permalink":"http://hgko1207.github.io/2022/08/21/react-10/","excerpt":"","text":"reference는 react 코드를 이용해 HTML 요소를 지정하고 가져올 수 있는 방법입니다. 다시 말해서 자바스크립트로부터 HTML 요소를 가져오고 수정할 수 있도록 해줍니다. 사용 useRef를 사용하여 HTML 요소를 가져옵니다. 다음 코드는 button 클릭 시 input을 포커싱하고 해제하는 예제입니다. 1234567891011121314151617181920import &#123; useRef &#125; from 'react';function RefEx() &#123; const inputRef = useRef&lt;HTMLInputElement&gt;(null); const onClick = () =&gt; &#123; inputRef.current?.focus(); // 5초 뒤에 focus 사라짐 setTimeout(() =&gt; &#123; inputRef.current?.blur; &#125;, 5000); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputRef&#125; type=\"text\" placeholder=\"input\" /&gt; &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;export default RefEx; typescript 사용하므로 HTMLInputElement를 지정하였습니다. useRef를 사용하여 HTML 요소를 가져왔지만 수정할 경우에는 HTMLInputElement 지정한 것 처럼 일반 자바스크립트를 이용합니다. useRef() useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 반환된 객체는 컴포넌트의 전 life cycle을 통해 유지될 것입니다. 일반적인 사용 사례는 자식에게 접근하는 경우입니다. 본질적으로 useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 &quot;상자&quot;와 같습니다. 참고 https://ko.reactjs.org/docs/hooks-reference.html#useref HTMLInputElement methods","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"}]},{"title":"[Spring] Swagger Header 설정 방법","slug":"spring-1","date":"2022-08-19T07:48:58.000Z","updated":"2024-01-12T01:33:57.342Z","comments":true,"path":"2022/08/19/spring-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/spring-1/","excerpt":"","text":"Spring에서 Swagger Header 설정 방법에 대해 알아보겠습니다. API 마다 설정 각 API 마다 @ApiImplicitParam을 통해 인증 정보(토큰)를 입력하도록 설정합니다. 1234567@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"Authorization\", value = \"JWT Token\", required = true, dataType = \"string\", paramType = \"header\") &#125;)@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 이 방법은 API 개수가 많아질 경우 코드 양이 늘어나고 가독성이 나빠집니다. 그리고 Swagger를 통해 테스트 진행 시 각 API 마다 인증 정보를 입력해야 한다는 번거로움이 생기게 됩니다. Authroize 버튼 활성화 SWagger Version 2.9.2부터는 번거로움을 없애주는 기능이 생겼습니다. Swagger 화면 상단 부분에 Autorize 버튼이 생겼습니다. Autorize 버튼을 클릭하면 모든 API에 일괄 인증 할 수 있도록 해주는 인증 정보를 입력받는 창이 뜹니다. 설정 먼저 maven 또는 gradle 설정을 합니다. 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 1234dependencies &#123; compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' implementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2'&#125; SwaggerConfig 클래스를 생성하고 코드들을 추가합니다. 중요한 것은 ApiKey 를 유의해야 합니다. 프로젝트마다 사용하는 인증 key가 다르므로 확인해서 입력합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Arrays;import java.util.List;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.ApiKey;import springfox.documentation.service.AuthorizationScope;import springfox.documentation.service.SecurityReference;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger.web.DocExpansion;import springfox.documentation.swagger.web.ModelRendering;import springfox.documentation.swagger.web.OperationsSorter;import springfox.documentation.swagger.web.TagsSorter;import springfox.documentation.swagger.web.UiConfiguration;import springfox.documentation.swagger.web.UiConfigurationBuilder;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger 자동 문서화 웹 생성을 위한 Spring MVC 설정 * @author hgko * */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .useDefaultResponseMessages(false) // 웹 페이지에서 디폴트 설정되는 ResponseMessages 부분 표시하지 않음 .select() .apis(RequestHandlerSelectors.basePackage(\"com.hgko.controller\")) // Controller에서 api 추출 .paths(PathSelectors.any()) .build() .apiInfo(swaggerInfo()) .securityContexts(Arrays.asList(securityContext())) .securitySchemes(Arrays.asList(apiKey())); &#125; public ApiInfo swaggerInfo() &#123; return new ApiInfoBuilder() .title(\"Server API Documentation\") .description(\"서버 API에 대한 연동 문서입니다\") .version(\"0.0.1\") .build(); &#125; private ApiKey apiKey() &#123; return new ApiKey(\"Authorization\", \"Authorization\", \"header\"); &#125; private SecurityContext securityContext() &#123; return SecurityContext.builder() .securityReferences(defaultAuth()) .build(); &#125; private List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Arrays.asList(new SecurityReference(\"Authorization\", authorizationScopes)); &#125;&#125; 기존 API 코드에서 @ApiImplicitParams 부분을 제거합니다. 12345@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 설정은 다 끝났습니다. Swagger 화면에서 정상적으로 동작하는지 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"}]},{"title":"[Angular] 기능 구현 방식","slug":"angular-3","date":"2022-08-19T00:59:13.000Z","updated":"2024-01-12T01:32:44.240Z","comments":true,"path":"2022/08/19/angular-3/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/angular-3/","excerpt":"","text":"Angular 프레임워크로 특정 기능을 구현할 때 어떤 방식으로 사용하는지에 대해 알아보겠습니다. UI Component 구현 클래스에 @Component Annotation을 붙여서 생성합니다. HTML 템플릿 정의 인라인 HTML 코드를 사용할 때는 @Component 어노테이션 template 항목을 사용하고, 외부 파일에서 불러올 때는 templateUrl 항목을 사용합니다. 컴포넌트 Property 를 UI에 표시 템플릿의 이중 중괄호 안에 Property를 사용합니다. 1&lt;span&gt;&#123;&#123; customValue &#125;&#125;)&lt;/span&gt; 컴포넌트 Property 바인딩 대괄호를 사용해서 Property를 바인딩합니다. 1&lt;input [value]=\"inputValue\" /&gt; 이벤트 처리 이벤트 이름을 괄호로 감싸고 핸들러를 지정합니다. 1&lt;button (click)=\"onClickEvent\"&gt;Click&lt;/button&gt; 양방향 바인딩 [()] 표기를 사용합니다. 1&lt;input [(ngModel)]=\"componentProperty\" /&gt; HTML 일부를 자식 컴포넌트에 전달하기 자식 컴포넌트의 템플릿에 &lt;ng-content&gt; 태그를 사용합니다. 내비게이션 구현 라우터를 사용해서 컴포넌트와 URL을 연결하고 컴포넌트의 템플릿이 렌더링될 위치를 &lt;router-outlet&gt; 태그로 지정합니다. 컴포넌트에서 데이터 받기 컴포넌트 프로퍼티를 선언할 때 @Input 어노테이션을 사용해서 외부 값과 연결합니다. 컴포넌트에 데이터 전달하기 컴포넌트 프로퍼티를 선언할 때 @Output 어노테이션을 사용하고 EventEmitter를 이용해서 이벤트를 발생시킵니다. HTTP 요청 컴포넌트에 Http 객체를 주입하고 HTTP 함수를 사용합니다. 1this.http.get('/users'); HTTP 응답 처리 subscribe() 함수를 사용해서 옵저버블 스트림을 처리합니다. 123this.http.get('/users').subscribe(() =&gt; &#123; ...&#125;); 컴포넌트 상태가 변경되는 것을 가로채기 컴포넌트 생성주기 함수를 사용합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[React] memo 사용 방법","slug":"react-9","date":"2022-08-12T13:50:38.000Z","updated":"2024-01-12T01:31:45.775Z","comments":true,"path":"2022/08/12/react-9/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-9/","excerpt":"","text":"React에서 memo 사용 방법에 대해 알아보겠습니다. 컴포넌트가 동일한 props로 동일한 결과를 렌더링 해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑 하여 경우에 따라 성능 향상을 누릴 수 있습니다. 즉, React는 컴포넌트를 렌더링 하지 않고 마지막으로 렌더링 된 결과를 재사용합니다. 1234567import React from 'react';function MyComponent(props) &#123; /* props를 사용하여 렌더링 */&#125;export default React.memo(MyComponent, areEqual); 사용 이전 포스트 [React] Drag and Drop에서 드래그, 드롭 시 바뀐 부분이 아닌 전체가 리랜더링이 되어 텍스트의 흔들림이 가끔씩 발생하는 문제가 있었습니다. Card 부분을 DraggableCard Component로 새로 만들었습니다. DraggableCard에게 동일한 index와 todo prop을 주고 불필요한 리랜더링을 하지 않도록 하기 위해 memo를 사용하였습니다. 123456789101112131415161718192021222324252627282930// DraggableCard.tsximport React from 'react';import &#123; Draggable &#125; from 'react-beautiful-dnd';import styled from 'styled-components';const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;interface IDraggableCardProps &#123; toDo: string; index: number;&#125;function DraggableCard(&#123; toDo, index &#125;: IDraggableCardProps) &#123; return ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; );&#125;export default React.memo(DraggableCard); 실제로 바뀐 것들만 리렌더링 되어 텍스트가 흔들리는 문제를 해결함으로써 최적화 할 수 있었습니다. 주의 React.memo는 props 변화에만 영향을 줍니다. React.memo로 감싸진 함수 컴포넌트 구현에 useState, useReducer 또는 useContext 훅을 사용한다면, 여전히 state나 context가 변할 때 다시 렌더링 됩니다. 이 메서드는 오직 성능 최적화를 위하여 사용됩니다. 렌더링을 방지하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다. 참고 https://ko.reactjs.org/docs/react-api.html#reactmemo","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"}]},{"title":"[React] Drag and Drop 사용 방법","slug":"react-8","date":"2022-08-12T13:21:15.000Z","updated":"2024-01-12T01:30:23.092Z","comments":true,"path":"2022/08/12/react-8/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-8/","excerpt":"","text":"react-beautiful-dnd을 사용하여 React에서 깔끔하고 사용하기 쉬운 드래그, 드롭, 애니메이션을 적용하는 방법에 대해 알아보겠습니다. 설치 1$ npm i react-beautiful-dnd TypeScript 사용 시 추가로 설치합니다. 1$ npm i --save-dev @types/react-beautiful-dnd 사용 임시 데이터 **[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]**를 사용하여 카드 형태의 드래그, 드롭을 구현해 봤습니다. 1234567// atoms.tsximport &#123; atom &#125; from 'recoil';export const toDoState = atom(&#123; key: 'toDo', default: ['a', 'b', 'c', 'd', 'e', 'f'],&#125;); DragDropContext, Draggable, Droppable 를 사용하여 구성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// App.tsximport &#123; DragDropContext, Draggable, Droppable, DropResult &#125; from 'react-beautiful-dnd';import &#123; useRecoilState &#125; from 'recoil';import styled from 'styled-components';import &#123; toDoState &#125; from './atoms';const Wrapper = styled.div` display: flex; max-width: 480px; width: 100%; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Boards = styled.div` display: grid; width: 100%; grid-template-columns: repeat(3, 1fr);`;const Board = styled.div` padding: 20px 10px; padding-top: 30px; background-color: gray; border-radius: 5px; min-height: 200px;`;const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;function App() &#123; const [toDos, setToDos] = useRecoilState(toDoState); const onDragEnd = (&#123; draggableId, destination, source &#125;: DropResult) =&gt; &#123; if (!destination) return; setToDos((oldToDos) =&gt; &#123; const copyToDos = [...oldToDos]; // 1) Delete item on source.index copyToDos.splice(source.index, 1); // 2) Put back the item on the destination.index copyToDos.splice(destination?.index, 0, draggableId); return copyToDos; &#125;); &#125;; return ( &lt;DragDropContext onDragEnd=&#123;onDragEnd&#125;&gt; &lt;Wrapper&gt; &lt;Boards&gt; &lt;Droppable droppableId=\"one\"&gt; &#123;(provided) =&gt; ( &lt;Board ref=&#123;provided.innerRef&#125; &#123;...provided.droppableProps&#125;&gt; &#123;toDos.map((toDo, index) =&gt; ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; ))&#125; &#123;provided.placeholder&#125; &lt;/Board&gt; )&#125; &lt;/Droppable&gt; &lt;/Boards&gt; &lt;/Wrapper&gt; &lt;/DragDropContext&gt; );&#125;export default App; Draggable의 draggableProps는 모든 영역을 dragHandleProps는 특정 영역을 통해서만 드래그할 수 있도록 설정할 수 있습니다. Draggable list를 렌더링 하는 경우 각 Draggable에 key prop을 추가하는 것이 중요합니다. key는 list 내에서 고유해야 합니다. key에 item의 index가 포함되어서는 안 되기 때문에 일반적으로 draggableId를 key로 사용합니다. 참고 react-beautiful-dnd 테스트해 보기 react-beautiful-dnd 예시 코드 react-beautiful-dnd-kr","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"},{"name":"Drag","slug":"Drag","permalink":"http://hgko1207.github.io/tags/Drag/"},{"name":"Drop","slug":"Drop","permalink":"http://hgko1207.github.io/tags/Drop/"}]},{"title":"[React] React Hook Form","slug":"react-7","date":"2022-08-08T14:40:32.000Z","updated":"2024-01-12T01:28:14.233Z","comments":true,"path":"2022/08/08/react-7/","link":"","permalink":"http://hgko1207.github.io/2022/08/08/react-7/","excerpt":"","text":"React에서 React Hook Form 사용 방법에 대해 알아보겠습니다. 기본적으로 Form을 사용할 때 작성하는 코드입니다. 하나의 input 이지만 여러 개의 input 을 사용할 경우 useState 와 onChange 이벤트가 많이 생성됩니다. 그리고 Validation Check 하는 코드도 복잡해집니다. 123456789101112131415161718192021222324252627282930313233// InputForm.tsximport React, &#123; useState &#125; from 'react';function InputForm() &#123; const [toDo, setTodo] = useState(''); const [toDoError, setTodoError] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setTodoError(''); setTodo(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); if (toDo.length &lt; 10) &#123; return setTodoError('To do should be longer'); &#125; console.log(toDo); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input onChange=&#123;onChange&#125; value=&#123;toDo&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &#123;toDoError !== '' ? toDoError : null&#125; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; react-hook-form 라이브러리를 사용하면 위의 코드들을 간략하게 줄일 수 있습니다. 그리고 Validation(검증)도 쉽게 관리할 수 있습니다. 설치 1$ npm install react-hook-form 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add react-hook-form 사용 먼저 useForm 을 import 합니다. 1import &#123; useForm &#125; from 'react-hook-form'; register useForm, register을 사용한 단 한줄의 코드가 onChange 이벤트와 value, useState 를 모두 대체했습니다. 사용법은 {...register(name)}를 input 태그 안에 작성합니다. register 함수는 Validation을 보다 쉽게 관리할 수 있도록 해줍니다. required: true처럼 조건을 작성할 수 있습니다. 123456789101112131415// InputForm.tsxfunction InputForm() &#123; const &#123; register &#125; = useForm(); return ( &lt;div&gt; &lt;form&gt; &lt;input &#123;...register('toDo', &#123; required: true &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; watch watch는 form의 입력 값들의 변화를 관찰할 수 있게 해줍니다. 12const &#123; register, watch &#125; = useForm();console.log(watch); handleSubmit handleSubmit는 form 데이터의 Validation Check를 해결해 줍니다. 파라미터는 Validation을 통과했을 때 호출되는 함수입니다. handleSubmit를 사용하면 키보드랑 마우스를 조건이 유효하지 않은 항목으로 바로 focus 시켜줍니다. 123456789101112131415161718192021222324252627// InputForm.tsxfunction InputForm() &#123; const &#123; register, handleSubmit &#125; = useForm(); const onValid = (data: any) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('toDo', &#123; required: true, minLength: &#123; value: 5, message: 'Your todo is too short.', &#125;, &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; formState formState 을 통해 에러메시지를 출력해 보겠습니다. 먼저 email 은 정규식을 통해 검증하도록 pattern을 작성하였습니다. 조건을 입력할 때 메시지도 작성하여 에러메시지가 출력되도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344type IForm = &#123; errors: &#123; email: &#123; message: string; &#125;; &#125;; email: string;&#125;;function InputForm() &#123; const &#123; register, handleSubmit, formState: &#123; errors &#125;, &#125; = useForm&lt;IForm&gt;(&#123; defaultValues: &#123; email: '@gmail.com', &#125;, &#125;); const onValid = (data: IForm) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('email', &#123; required: '이메일을 입력하세요.', pattern: &#123; value: /^[A-Za-z0-9._%+-]+@gmail.com$/, message: '이메일 형식이 맞지 않습니다.', &#125;, &#125;)&#125; placeholder=\"Email\" /&gt; &lt;span&gt;&#123;errors?.email?.message&#125;&lt;/span&gt; &lt;button&gt;등록&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; email을 입력하지 않았을 경우 이메일을 입력하세요. 에러메시지가 출력되고 email 형식이 맞지 않을 경우 이메일 형식이 맞지 않습니다. 에러메시지가 출력됩니다. SetValue submit 하고 난 후 값을 초기화할 수 있습니다. Custom Validation setError 를 통해 직접 에러를 발생시키도록 할 수 있습니다. shouldFocus 옵션을 사용하면 form의 커서가 자동으로 옮겨집니다. 12// 예setError('password1', &#123; message: '비밀번호가 다릅니다.' &#125;, &#123; shouldFocus: true &#125;); 참고 https://react-hook-form.com/ https://react-hook-form.com/kr/get-started/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"}]},{"title":"[Angular] Angular 시작","slug":"angular-2","date":"2022-08-07T12:51:25.000Z","updated":"2024-01-12T01:26:04.818Z","comments":true,"path":"2022/08/07/angular-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/07/angular-2/","excerpt":"","text":"Angular는 구글이 만든 단일 페이지 웹 애플리케이션 개발을 위한 자바스크립트 프레임워크입니다. 다양한 플랫폼에서 동작할 수 있게 하는 개발 툴과 기능들을 제공합니다. Module 컴포넌트, 파이프, 서비스 등과 같은 앵귤러 애플리케이션의 주요 부분을 기능단위로 그룹핑하게 해 줍니다. 모든 앵귤러 애플리케이션은 하나의 Root Module을 가집니다. 여러 Feature Module을 가질 수 있습니다. 재사용할 수 있는 기능을 외부에 배포하기 위해 사용되기도 합니다. Component 빌딩 블록 형식 HTML 요소들의 그룹 뷰와 로직으로 구성 1$ ng g component todo/todos --module todo/todo.module.ts --export 컴포넌트 내부에서 html, css 코드를 작성하도록 생성할 수 있습니다. 1$ ng g component todos/todo --inline-template --inline-style Template HTML 코드로서 템플릿을 표현합니다. Template 표현식(Expression)과 Template 문장(Statement)을 가집니다. 바인딩 바인딩의 대상: 속성, 이벤트, ngModel, class, style 123456789101112&lt;!-- &#123;&#123; 템플릿 표현식 &#125;&#125; --&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;!-- [속성]=\"템플릿 표현식\" --&gt;&lt;todo [todo]=\"work\"&gt;&lt;/todo&gt;&lt;!-- (이벤트)=\"템플릿 문장(함수)\" --&gt;&lt;button (click)=\"handle()\"&gt;&lt;/button&gt;&lt;!-- [(ngModel)]=\"템플릿 문장\" --&gt;&lt;!-- 양방향 바인딩을 사용할 수 있음 --&gt;&lt;input type=\"text\" [(ngModel)]=\"name\" /&gt; 컴포넌트 간 커뮤니케이션 부모 컴포넌트 -&gt; 자식 컴포넌트 @input() 사용 ES6 setter 사용 가능 @ViewChild() 사용 자식 컴포넌트 -&gt; 부모 컴포넌트 @Output() 사용 EventEmitter 사용하여 부모에게 이벤트 전달 부모 컴포넌트는 $event로 이벤트의 데이터를 전달받음 자식이 부모 컴포넌트를 직접 주입받을 수 있음 파이프(Pipe) 템플릿(HTML)에서 보이는 데이터를 변환해 줍니다. AngularJs 1.x에서는 필터로 제공되었습니다. 실제 값을 변경하는 것이 아니라 보여주는 값만 바꿔 보여주기 위해 사용합니다. 123456789// 사용법&#123;&#123; express | pipeName: paramValue &#125;&#125;// 예today: Date = new Date();&#123;&#123; today | date &#125;&#125;&#123;&#123; today | date:\"yy/mm/dd\" &#125;&#125; // 날짜 포맷 변환&#123;&#123; today | date | uppercase &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Python] 기초(2)","slug":"python-2","date":"2022-08-02T14:47:28.000Z","updated":"2024-01-12T01:24:54.287Z","comments":true,"path":"2022/08/02/python-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-2/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본편)을 보면서 작성하였습니다. 기본 시작 함수 123456789101112131415161718192021222324def open_account(): print(\"새로운 계좌가 생성되었습니다.\")def deposit(balance, money): # 입금 print(\"입금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance + money)) return balance + moneydef withdraw(balance, money): # 출금 if balance &gt;= money: # 잔액이 출금보다 많으면 print(\"출금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance - money)) return balance - money else: print(\"출금이 완료되지 않았습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance)) return balancedef withdraw_night(balance, money): # 저녁에 출금 commission = 100 # 수수료 100원 return commission, balance - money - commissionbalance = 0balance = deposit(balance, 1000)# balance = withdraw(balance, 500)commission, balance = withdraw_night(balance, 500)print(\"수수료 &#123;0&#125; 원이며, 잔액은 &#123;1&#125; 원입니다.\".format(commission, balance)) 함수 기본값 12345678910def profile(name, age, main_lang): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\", 35, \"파이썬\")# 같은 학교 같은 학년 같은 반 같은 수업def profile(name, age=17, main_lang=\"파이썬\"): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\") 가변인자 123456789101112# def profile(name, age, lang1, lang2, lang3, lang4, lang5):# print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \")# print(lang1, lang2, lang3, lang4, lang5)def profile(name, age, *language): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \") for lang in language: print(lang, end=\" \") print()profile(\"고형균\", 35, \"Python\", \"Java\", \"C\", \"C++\", \"C#\", \"JavaScript\")profile(\"김태호\", 40, \"Kotlin\", \"Swift\", \"\", \"\", \"\") 지역변수와 전역변수 12345678910111213141516gun = 10def checkpoint(soldiers): # 경계근무 global gun # 전역 공간에 있는 gun 사용 gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun))def checkpoint_ret(gun, soldiers): gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun)) return gunprint(\"전체 총 : &#123;0&#125;\".format(gun))#checkpoint(2) # 2명이 경계 근무 나감gun = checkpoint_ret(gun, 2)print(\"남은 총 : &#123;0&#125;\".format(gun)) 표준 입출력 1234567891011121314import sysprint(\"Python\", \"Java\", file=sys.stdout)print(\"Python\", \"Java\", file=sys.stderr)# 시험 성적scores = &#123;\"수학\":0, \"영어\":50, \"코딩\":100&#125;for subject, score in scores.items(): #print(subject, score) print(subject.ljust(8), str(score).rjust(4), sep=\":\")# 은행 대기순번표# 001, 002, 003, ...for num in range(1, 21): print(\"대기번호 : \" + str(num).zfill(3)) 다양한 출력포맷 123456789101112131415161718# 빈 자리는 빈공간으로 두고, 오른쪽 정렬을 하되, 총 10자리 공간을 확보print(\"&#123;0: &gt;10&#125;\".format(500))# 양수일 땐 +로 표시, 음수일 땐 -로 표시print(\"&#123;0: &gt;+10&#125;\".format(500))print(\"&#123;0: &gt;+10&#125;\".format(-500))# 왼쪽 정렬하고, 빈칸으로 _로 채움print(\"&#123;0:_&lt;+10&#125;\".format(500))# 3자리 마다 콤마를 찍어주기print(\"&#123;0:,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이기print(\"&#123;0:+,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이고, 자릿수 확보하기# 돈이 많으면 행복해지니까 빈 자리는 ^ 로 채워주기print(\"&#123;0:^&lt;+30,&#125;\".format(1000000000))# 소수점 출력print(\"&#123;0:f&#125;\".format(5/3))# 소수점 특정 자리수 까지만 표시 (소수점 3째 자리에서 반올림)print(\"&#123;0:.2f&#125;\".format(5/3)) 파일 입출력 12345678910111213141516171819202122232425262728293031323334score_file = open(\"score.txt\", \"w\", encoding=\"utf8\") # writeprint(\"수학 : 0\", file=score_file)print(\"영어 : 50\", file=score_file)score_file.close()score_file = open(\"score.txt\", \"a\", encoding=\"utf8\") # updatescore_file.write(\"과학 : 80\")score_file.write(\"\\n코딩 : 100\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\") # readprint(score_file.read())score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")print(score_file.readline(), end=\"\") # 줄별로 읽기, 한 줄 읽고 커서는 다음 줄로 이동print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")while True: line = score_file.readline() if not line: break print(line, end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")lines = score_file.readlines() # list 형태로 저장for line in lines: print(line, end=\"\")score_file.close() pickle 1234567891011import pickleprofile_file = open(\"profile.pickle\", \"wb\") # b: 바이너리profile = &#123;\"이름\":\"고형균\", \"나이\":36, \"취미\":[\"축구\", \"볼링\", \"코딩\"]&#125;print(profile)pickle.dump(profile, profile_file) # profile 에 있는 정보를 file 에 저장profile_file.close()profile_file = open(\"profile.pickle\", \"rb\")profile = pickle.load(profile_file) # file 에 있는 정보를 profile 에 불러오기print(profile)profile_file.close() with 12345with open(\"study.txt\", \"w\", encoding=\"utf8\") as study_file: study_file.write(\"파이썬을 열심히 공부하고 있어요\")with open(\"study.txt\", \"r\", encoding=\"utf8\") as study_file: print(study_file.read()) 클래스 1234567891011class Unit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage print(\"&#123;0&#125; 유닛이 생성되었습니다.\".format(self.name)) print(\"체력 &#123;0&#125;, 공격력 &#123;1&#125;\\n\".format(self.hp, self.damage))marine1 = Unit(\"마린\", 40, 5)marine2 = Unit(\"마린\", 40, 5)tank = Unit(\"탱크\", 150, 35) 메서드 12345678910111213141516171819202122class AttackUnit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage def attack(self, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 적군을 공격합니다. [공격력 &#123;2&#125;]\".format(self.name, location, self.damage)) def damaged(self, damage): print(\"&#123;0&#125; : &#123;1&#125; 데미지를 입었습니다.\".format(self.name, damage)) self.hp -= damage print(\"&#123;0&#125; : 현재 체력은 &#123;1&#125; 입니다.\".format(self.name, self.hp)) if self.hp &lt;= 0: print(\"&#123;0&#125; : 파괴되었습니다.\".format(self.name))firebat1 = AttackUnit(\"파이어뱃\", 50, 16)firebat1.attack(\"5시\")# 공격 2번 받는다고 가정firebat1.damaged(25)firebat1.damaged(25) 상속 123456789class Unit: def __init__(self, name, hp): self.name = name self.hp = hpclass AttackUnit(Unit): def __init__(self, name, hp, damage): Unit.__init__(self, name, hp) self.damage = damage 다중 상속 1234567891011121314151617# 날 수 있는 기능을 가진 클래스class Flyable: def __init__(self, flying_speed): self.flying_speed = flying_speed def fly(self, name, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 날아갑니다. [속도 &#123;2&#125;]\".format(name, location, self.flying_speed))# 공중 공격 유닛 클래스class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, damage) Flyable.__init__(self, flying_speed)# 발키리 : 공중 공격 유닛, 한번에 14발 미사일 발사.valkrie = FlyableAttackUnit(\"발키리\", 200, 6, 5)valkrie.fly(valkrie.name, \"3시\"); 메서드 오버라이딩 1234567class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, 0, damage) Flyable.__init__(self, flying_speed) def move(self, location): self.fly(self.name, location) # &lt;= 메서드 오버라이딩 pass 12345678def game_start(): print(\"[알림] 새로운 게임을 시작합니다.\")def game_over(): passgame_start()game_over() super 12345class BuildingUnit(Unit): def __init__(self, name, hp, location): #Unit.__init__(self, name, hp, 0) super().__init__(name, hp, 0) self.location = location 예외처리 1234567891011121314try: print(\"나누기 전용 계산기입니다.\") nums = [] nums.append(int(input(\"첫 번째 숫자를 입력하세요 : \"))) nums.append(int(input(\"두 번째 숫자를 입력하세요 : \"))) nums.append(int(nums[0] / nums[1])) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(nums[0], nums[1], nums[2]))except ValueError: print(\"에러! 잘못된 값을 입력하였습니다.\")except ZeroDivisionError as err: print(err)except Exception as err: print(\"알 수 없는 에러가 발생하였습니다.\") print(err) 예외 발생시키기 12345678910111213141516171819class BigNumberError(Exception): def __init__(self, msg): self.msg = msg def __str__(self): return self.msgtry: print(\"한 자리 숫자 나누기 전용 계산기입니다.\") num1 = int(input(\"첫 번째 숫자를 입력하세요 : \")) num2 = int(input(\"두 번째 숫자를 입력하세요 : \")) if num1 &gt;= 10 or num2 &gt;= 10: raise BigNumberError(\"입력값 : &#123;0&#125;, &#123;1&#125;\".format(num1, num2)) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(num1, num2, int(num1 / num2)))except ValueError: print(\"잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.\")except BigNumberError as err: print(\"에러가 발생하였습니다. 한 자리 숫자만 입력하세요.\") print(err) 모듈 모듈을 사용하기 위해 theater_module.py 파일을 생성합니다. 1234567891011# 일반 가격def price(people): print(\"&#123;0&#125;명 가격은 &#123;1&#125;원 입니다.\".format(people, people * 10000))# 조조 할인 가격def price_morning(people): print(\"&#123;0&#125;명 조조 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 6000))# 군인 할인 가격def price_soldier(people): print(\"&#123;0&#125;명 군인 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 4000)) 생성한 모듈을 사용하기 위한 5가지 방법입니다. 1234567891011121314151617181920212223242526# 1) 기본import theater_moduletheater_module.price(3) # 3명이서 영화 보러 갔을 때 가격theater_module.price_morning(4) # 4명이서 조조 할인 영화 보러 갔을 때theater_module.price_soldier(5) # 5명의 군인이 영화 보러 갔을 때# 2) 별칭 사용import theater_module as mvmv.price(3)mv.price_morning(4)mv.price_soldier(5)# 3) 전체 사용from theater_module import *price(3)price_morning(4)price_soldier(5)# 4) 특정한 함수 사용from theater_module import price, price_morningprice(5)price_morning(6)# 5) 함수에 별칭 사용from theater_module import price_soldier as priceprice(5) all 1__all__ = [\"vietnam\"] 모듈 직접 실행 1234567891011class ThailandPackage: def detail(self): print(\"[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원\")if __name__ == \"__main__\": print(\"Thailand 모듈을 직접 실행\") print(\"이 문장은 모듈을 직접 실행할 때만 실행돼요\") trip_to = ThailandPackage() trip_to.detail()else: print(\"Thailand 외부에서 모듈 호출\") 패키지, 모듈 위치 123import inspectimport randomprint(inspect.getfile(random)) pip install https://pypi.org/search/ pip install beautifulsoup4 pip list pip show beautifulsoup4 pip install --upgrade beautifulsoup4 pip uninstall beautifulsoup4 내장 함수 Built-in Functions 사이트는 파이썬의 내장 함수 목록을 확인할 수 있습니다. 12345678910111213# input : 사용자 입력을 받는 함수language = input(\"무슨 언어를 좋아하세요?\")print(\"&#123;0&#125;은 아주 좋은 언어입니다!\".format(language))# dir : 어떤 객체를 넘겨줬을 때 그 객체가 어떤 변수와 함수를 가지고 있는지 표시import random # 외장 함수print(dir(random))lst = [1, 2, 3]print(dir(lst))name = \"Ko\"print(dir(name)) 외장 함수 Python Module Index 사이트는 파이썬의 외장 함수 목록을 확인할 수 있습니다. 123456789101112131415161718192021# glob : 경로 내의 폴더 / 파일 목록 조회 (윈도우 dir)import globprint(glob.glob(\"*.py\")) # 확장자가 py 인 모든 파일# os : 운영체제에서 제공하는 기본 기능import osprint(os.getcwd()) # 현재 디렉토리print(os.listdir())# time : 시간 관련 함수import timeprint(time.localtime())print(time.strftime(\"%Y-%m-%d %H:%M:%S\"))import datetimeprint(\"오늘 날짜는 \", datetime.date.today())# timedelta : 두 날짜 사이의 간격today = datetime.date.today() # 오늘 날짜 저장td = datetime.timedelta(days=100) # 100일 저장print(\"우리가 만난지 100일은\", today + td) # 오늘부터 100일 후","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Python] 기초(1)","slug":"python-1","date":"2022-08-02T14:40:29.000Z","updated":"2024-01-12T01:24:09.754Z","comments":true,"path":"2022/08/02/python-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-1/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본 편)을 보면서 작성하였습니다. 환경설정 Python 설치 https://www.python.org/downloads/ 홈페이지 접속 후 다운로드 탭을 선택하고, 현재 버전(3.10.2) 다운로드를 합니다. 다운로드 완료 후 설치를 시작한다. Customize installation 클릭하고, install location 란에 c:\\Python310 입력 후 설치 버튼을 클릭합니다. Visual Studio Code 설치 https://code.visualstudio.com/ 홈페이지 접속 후 다운로드 후 설치합니다. python 익스텐션 설치 기본 시작 주석 1234567print(\"주석\")#print(\"주석\")'''여러문장주석입니다.''' 숫자처리함수 12345678910print(abs(-5)) #5print(pow(4, 2)) # 4^2 = 4*4 = 16print(max(5, 12)) # 12print(min(5, 12)) # 5print(round(3.14)) # 3from math import *print(floor(4.99)) # 내림. 4print(ceil(3.14)) # 올림. 4print(sqrt(16)) # 제곱근. 4 랜덤함수 123456789from random import *print(random()) # 0.0 ~ 1.0 미만의 임의의 값 생성print(random(10)) # 0.0 ~ 10.0 미만의 임의의 값 생성print(int(random() * 10)) # 0 ~ 10 미만의 임의의 값 생성print(int(random() * 10) + 1) # 1 ~ 10 이하의 임의의 값 생성print(int(random() * 45) + 1) # 1 ~ 45 이하의 임의의 값 생성print(randrange(1, 46)) # 1 ~ 46 미만의 임의의 값 생성print(randint(1, 45)) # 1 ~ 45 이하의 임의의 값 생성 문자열 123456789sentence = '나는 소년입니다'print(sentence)sentence2 = \"파이썬은 쉬워요\"print(sentence2)sentence3 = \"\"\"나는 소년이고,파이썬은 쉬워요\"\"\"print(sentence3) 슬라이싱 1234567891011jumin = \"990101-1234567\"print(\"성별 : \" + jumin[7])print(\"연 : \" + jumin[0:2]) # 0 부터 2 직전까지 (0, 1)print(\"월 : \" + jumin[2:4])print(\"일 : \" + jumin[4:6])print(\"생년월일 : \" + jumin[:6]) # 처음부터 6 직전까지print(\"뒤 7자리 : \" + jumin[7:]) # 7 부터 끝까지print(\"뒤 7자리 (뒤에부터) : \" + jumin[-7:])# 맨 뒤에서 7번째부터 끝까지 문자열 처리 함수 1234567891011121314python = \"Python is Amazing\"print(python.lower()) # 소문자로print(python.upper()) # 대문자로print(python[0].isupper())print(len(python)) # 길이print(python.replace(\"Python\", \"Java\")) # 문자열 바꿈index = python.index(\"n\") # 문자열 위치 찾기index = python.index(\"n\", index + 1) # 두번째 n의 위치 찾기print(python.find(\"Java\")) # 문자를 찾지 못할 경우 -1 출력print(python.index(\"Java\")) # 문자를 찾지 못할 경우 오류남print(python.count(\"n\")) # 문자열 n이 나오는 개수 문자열 포맷 123456789101112131415161718192021# 방법 1print(\"나는 %d살입니다.\" % 35) # 정수만print(\"나는 %s을 좋아해요\" % \"파이썬\") # 문자열만print(\"Apple 은 %c로 시작해요.\" % \"A\") # 한글자만 받겠다는 의미# %sprint(\"나는 %s살입니다.\" % 35)print(\"나는 %s색과 %s색을 좋아해요.\" % (\"파란\", \"빨간\"))# 방법 2print(\"나는 &#123;&#125;살입니다.\".format(35))print(\"나는 &#123;&#125;색과 &#123;&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;0&#125;색과 &#123;1&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;1&#125;색과 &#123;0&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))# 방법 3print(\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\".format(age=35, color=\"빨간\"))# 방법 4 (v3.6 이상~)age = 35color = \"빨간\"print(f\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\") 탈출 문자 1234567891011121314151617181920# \\n : 줄바꿈print(\"백문이 불여일견\\n백견이 불여일타\")# \\\" \\' : 문장 내에서 따옴표# 저는 \"고고고\" 입니다.print(\"저는 '고고고' 입니다.\")print('저는 \"고고고\" 입니다.')print(\"저는 \\\"고고고\\\" 입니다.\")# \\\\ : 문장 내에서 \\print(\"C:\\\\Users\\\\hgko\\\\Desktop\\\\project\\\\Python\\\\PythonStudy\")# \\r : 커서를 맨 앞으로 이동print(\"Red Apple\\rPine\")# \\b : 백스페이스 (한 글자 삭제)print(\"Redd\\bApple\")# \\t : 탭print(\"Red\\tApple\") 리스트 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 리스트 []# 지하철 칸별로 10명, 20명, 30명subway1 = 10subway2 = 20subway3 = 30subway = [10, 20, 30]print(subway)subway = [\"유재석\", \"조세호\", \"박명수\"]# 조세호 씨가 몇 번째 칸에 타고 있는지?print(subway.index(\"조세호\"))# 하하 씨가 다음 정류장에서 다음 칸에 탐subway.append(\"하하\")# 정형돈 씨를 유재석 / 조세호 사이에 태워봄subway.insert(1, \"정형돈\")# 지하철에 있는 사람을 한 명 씩 뒤에서 꺼냄print(subway.pop())# 같은 이름의 사람이 몇 명 있는지 확인subway.append(\"유재석\")print(subway.count(\"유재석\"))# 정렬num_list = [5,2,4,3,1]num_list.sort()# 순서 뒤집기num_list.reverse()# 모두 지우기num_list.clear()# 다양한 자료형 함께 사용num_list = [5,2,4,3,1]mix_list = [\"유재석\", 20, True]# 리스트 확장num_list.extend(mix_list) 사전 1234567891011121314151617181920212223242526272829303132cabinet = &#123;3:\"유재석\", 100:\"김태호\"&#125;print(cabinet[3])print(cabinet[100])print(cabinet.get(3))print(cabinet.get(5, \"사용 가능\"))print(3 in cabinet) # Trueprint(5 in cabinet) # Falsecabinet = &#123;\"A-3\":\"유재석\", \"B-100\":\"김태호\"&#125;print(cabinet[\"A-3\"])print(cabinet[\"B-100\"])# 새 손님cabinet[\"A-3\"] = \"김종국\" # 업데이트cabinet[\"C-20\"] = \"조세호\" # 추가# 간 손님del cabinet[\"A-3\"]# key 들만 출력print(cabinet.keys())# value 들만 출력print(cabinet.values())# key, value 쌍으로 출력print(cabinet.items())# 전체 삭제cabinet.clear() 튜플 1234menu = (\"돈까스\", \"치즈까스\")(name, age, hobby) = (\"김종국\", 20, \"코딩\")print(name, age, hobby) 세트 12345678910111213141516171819202122232425# 집합 (set)# 중복 안됨, 순서 없음my_set = &#123;1,2,3,3,3&#125;print(my_set)java = &#123;\"유재석\", \"김태호\", \"양세형\"&#125;python = set([\"유재석\", \"박명수\"])# 교집합 (java 와 python 을 모두 할 수 있는 개발자)print(java &amp; python)print(java.intersection(python))# 합집합 (java 할 수 있거나 python 도 할 수 있는 개발자)print(java | python)print(java.union(python))# 차집합 (java 할 수 있지만 python 은 할 줄 모르는 개발자)print(java - python)print(java.difference(python))# python 할 줄 아는 사람이 늘어남python.add(\"김태호\")# java 를 잊어버림java.remove(\"김태호\") 자료구조의 변경 123456789101112# 커피숍menu = &#123;\"커피\", \"우유\", \"주소\"&#125;print(menu, type(menu)) # &#123;'커피', '주소', '우유'&#125; &lt;class 'set'&gt;menu = list(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'list'&gt;menu = tuple(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'tuple'&gt;menu = set(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'set'&gt; if 1234567891011121314151617weather = input(\"오늘 날씨는 어때요?\")if weather == \"비\" or weather == \"눈\": print(\"우산을 챙기세요\")elif weather == \"미세먼지\": print(\"마스크를 챙기세요\")else: print(\"준비물 필요 없어요\")temp = int(input(\"기운은 어때요?\"))if 30 &lt;= temp: print(\"너무 더워요. 나가지 마세요\")elif 10 &lt;= temp and temp &lt; 30: print(\"괜찮은 날씨에요\")elif 0 &lt;= temp &lt; 10: print(\"외투를 챙기세요\")else: print(\"너무 추워요. 나가지 마세요\") for 123# randrange()for waiting_no in range(1, 6): # 1, 2, 3, 4, 5 print(\"대기번호 : &#123;0&#125;\".format(waiting_no)) while 12345customer = \"토르\"person = \"Unknown\"while person != customer: print(\"&#123;0&#125;, 커피가 준비 되었습니다.\".format(customer)) person = input(\"이름이 어떻게 되세요?\") 한 줄 for 123456students = [1,2,3,4,5]students = [i+100 for i in students]# 학생 이름을 길이도 반환students = [\"Iron man\", \"Thor\", \"I am groot\"]students = [len(i) for i in students]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Angular] Angular Cli 설치 및 사용 방법","slug":"angular-1","date":"2022-07-28T11:31:14.000Z","updated":"2024-01-12T01:23:28.767Z","comments":true,"path":"2022/07/28/angular-1/","link":"","permalink":"http://hgko1207.github.io/2022/07/28/angular-1/","excerpt":"","text":"Angular는 Angular CLI를 이용해 프로젝트 관리의 복잡도를 낮추고 Angular 개발에만 집중할 수 있게 합니다. 설치 Angular CLI를 설치하려면 다음과 같은 npm 명령어를 실행합니다. 1$ npm install -g @angular/cli 설치가 완료되면 ng 명령어를 사용할 수 있습니다. ng 명령어는 Angular CLI에서 제공하는 기능들을 실행하는 역할을 담당합니다. Angular CLI 도움말 옵션을 사용해 확인해 봅니다. 1234567891011121314151617181920212223242526272829303132$ ng --helpng &lt;command&gt;Commands: ng add &lt;collection&gt; Adds support for an external library to your project. ng analytics Configures the gathering of Angular CLI usage metrics. ng build [project] Compiles an Angular application or library into an output directory named dist/ at the given output path. [aliases: b] ng cache Configure persistent disk cache and retrieve cache statistics. ng completion Set up Angular CLI autocompletion for your terminal. ng config [json-path] [value] Retrieves or sets Angular configuration values in the angular.json file for the workspace. ng deploy [project] Invokes the deploy builder for a specified project or for the default project in the workspace. ng doc &lt;keyword&gt; Opens the official Angular documentation (angular.io) in a browser, and searches for a given keyword. [aliases: d] ng e2e [project] Builds and serves an Angular application, then runs end-to-end tests. [aliases: e] ng extract-i18n [project] Extracts i18n messages from source code. ng generate Generates and/or modifies files based on a schematic. [aliases: g] ng lint [project] Runs linting tools on Angular application code in a given project folder. ng new [name] Creates a new Angular workspace. [aliases: n] ng run &lt;target&gt; Runs an Architect target with an optional custom builder configuration defined in your project. ng serve [project] Builds and serves your application, rebuilding on file changes. [aliases: s] ng test [project] Runs unit tests in a project. [aliases: t] ng update [packages..] Updates your workspace and its dependencies. See https://update.angular.io/. ng version Outputs Angular CLI version. [aliases: v]Options: --help Shows a help message for this command in the console. [boolean]For more information, see https://angular.io/cli/. 프로젝트 생성 Angular 프로젝트를 생성하려면 ng new 명령어를 사용합니다. 1$ ng new [프로젝트명] ng new 명령어 다음에 프로젝트 이름을 지정하면 프로젝트 이름과 일치하는 새로운 프로젝트 폴더가 생성되고 스캐폴딩(프로젝트 기본 골격)이 작성됩니다. 프로젝트 이름을 my-app로 지정하여 프로젝트를 생성합니다. 1$ $ ng new my-app 프로젝트가 생성되면 아래와 같은 파일 구조의 스캐폴딩이 생성됩니다. 12345678910111213my-app&#x2F;├── .git&#x2F;├── node_modules&#x2F;├── src&#x2F;├── .editorconfig├── .gitignore├── angular.json├── package-lock.json├── package.json├── README.md├── tsconfig.app.json├── tsconfig.json└── tsconfig.spec.json 시작 프로젝트 폴더로 이동한 후 실행합니다. 1$ npm start 또는 ng serve 명령어를 사용합니다. 1$ ng serve 이미 포트 4200번을 사용하고 있다면 Angular CLI 내장 서버를 실행할 수 없습니다. 포트번호를 변경해 실행하려면 다음과 같이 --port(축약형 -p) 옵션을 추가한다. 1$ ng serve --port 4201 Build 빌드 결과는 기본적으로 dist/ 폴더에 저장됩니다. 1$ ng build 컴포넌트 생성 1$ ng generate component [component-name] 간략하게 명령어를 사용할 수 있습니다. 1$ ng g c [component-name] 사용 예시입니다. 123$ ng g c section$ ng g m section$ ng g c section/card ng generate directive|pipe|service|class|guard|interface|enum|module 명령어를 통해 컴포넌트 외에 다른 파일들을 생성할 수 있습니다. Running unit tests Karma를 통해 단위 테스트를 할 수 있습니다. 1$ ng test Running end-to-end tests 선택한 플랫폼을 통해 end-to-end 테스트를 실행합니다. 이 명령을 사용하려면 먼저 end-to-end 테스트 기능을 구현하는 패키지를 추가해야 합니다. 1$ ng e2e 참고 Angular CLI https://angular.io/cli https://angular.io/tutorial https://material.angular.io/ https://angular.io/guide/devtools https://blog.angular.io/ vscode 플러그인 Angular Files Angular Language Service TypeScript Hero: 소스 코드 관리에 필요한 TypeScript 코드 정렬을 도와주는 Plugin","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"}]},{"title":"[React] Recoil 사용 방법","slug":"react-6","date":"2022-07-25T13:54:57.000Z","updated":"2024-01-12T01:22:15.595Z","comments":true,"path":"2022/07/25/react-6/","link":"","permalink":"http://hgko1207.github.io/2022/07/25/react-6/","excerpt":"","text":"Recoil 사용 방법에 대해 알아보겠습니다. Recoil Recoil는 페이스북에서 만든 React를 위한 상태 관리 라이브러리입니다. Recoil을 사용하면 atoms (공유 상태)에서 selectors (순수 함수)를 거쳐 React 컴포넌트로 내려가는 data-flow graph를 만들 수 있습니다. 설치 Recoil 패키지는 npm에 존재합니다. 안정한 최신 버전을 설치하기 위해서는 다음의 명령어를 실행하면 됩니다. 1$ npm install recoil 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add recoil RecoilRoot 루트에 RecoilRoot를 감싸줍니다. 12345678910111213// index.tsximport &#123; RecoilRoot &#125; from 'recoil';import ToggleOutput from './ToggleOutput';import ToggleButton from './ToggleButton';function App() &#123; return ( &lt;RecoilRoot&gt; &lt;ToggleOutput /&gt; &lt;ToggleButton /&gt; &lt;/RecoilRoot&gt; );&#125; 사용 Atoms Atoms는 상태(state)의 일부를 나타냅니다. Atoms는 어떤 컴포넌트에서나 읽고 쓸 수 있습니다. atoms.ts 파일을 생성하고 Recoil의 atom function 을 사용하여 필요한 데이터를 설정합니다. atom 은 두 가지를 요구하는데 첫 번째는 key 로 unique ID 이고 두 번째는 default value입니다. 1234567// atoms.tsimport &#123; atom &#125; from 'recoil';export const isToggleAtom = atom(&#123; key: 'isToggle', default: false,&#125;); 컴포넌트가 atom을 읽게 하기 위해서는 useRecoilValue()를 다음과 같이 사용하면 됩니다. 123456789// ToggleOutput.tsximport &#123; useRecoilValue &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleOutput() &#123; const isToggle = useRecoilValue(isToggleAtom); return &lt;div&gt;Toggle state: &#123;isToggle&#125;&lt;/div&gt;;&#125; 컴포넌트가 atom을 쓰게 하기 위해서는 useSetRecoilState()를 다음과 같이 사용하면 됩니다. atom을 읽고 쓰게 하기 위해서는 useRecoilState()를 사용하면 됩니다. 12345678910111213141516// ToggleButton.tsximport &#123; useSetRecoilState &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleButton() &#123; const setToggleAtom = useSetRecoilState(isToggleAtom); const toggle = () =&gt; setToggleAtom((prev) =&gt; !prev); return ( &lt;div&gt; &lt;br /&gt; &lt;button onClick=&#123;toggle&#125;&gt;Toggle Mode&lt;/button&gt; &lt;/div&gt; );&#125; Selectors Selectors는 devived state를 나타냅니다. devived state 란 state 를 입력받아서 그걸 변형해 반환하는 순수 함수를 거쳐 반환된 값을 말합니다. atom의 output은 한 가지 형태이므로 조금 더 잘 써먹을 수 있는 형태로 변형해 줍니다. 12345678910111213141516171819202122export interface IToDo &#123; text: string; id: number; category: 'TO_DO' | 'DOING' | 'DONE';&#125;export const toDoState = atom&lt;IToDo[]&gt;(&#123; key: 'toDo', default: [],&#125;);export const toDoSelector = selector(&#123; key: 'toDoSelector', get: (&#123; get &#125;) =&gt; &#123; const toDos = get(toDoState); return [ toDos.filter((toDo) =&gt; toDo.category === 'TO_DO'), toDos.filter((toDo) =&gt; toDo.category === 'DOING'), toDos.filter((toDo) =&gt; toDo.category === 'DONE'), ]; &#125;,&#125;); category 값을 3개의 타입 형태로 사용할 경우 타입 별로 값을 반환하고 싶을 때 selector를 사용하여 atom에서 각각의 타입 별로 값을 분류하고 합쳐서 하나의 값으로 반환합니다. 참고 https://recoiljs.org/ko/docs/introduction/getting-started https://recoiljs.org/docs/basic-tutorial/selectors/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"}]},{"title":"[React] ApexCharts 사용 방법","slug":"react-5","date":"2022-07-24T13:16:30.000Z","updated":"2024-01-12T01:20:31.691Z","comments":true,"path":"2022/07/24/react-5/","link":"","permalink":"http://hgko1207.github.io/2022/07/24/react-5/","excerpt":"","text":"ApexCharts는 데이터를 시각화해주는 차트 라이브러리입니다. 무료로 사용할 수 있고, Js, Angular, React, Vue를 지원합니다. ApexCharts를 사용하여 React.js 에서 간단하게 차트 만드는 방법에 대해 알아보겠습니다. 설치 apexcharts 와 react-apexcharts 라이브러리를 같이 설치합니다. 1$ npm install --save react-apexcharts apexcharts 사용 코인 정보를 조회하여 차트를 구성하였습니다. Line Chart를 예제로 사용하였습니다. 1234567891011// api.tsconst BASE_URL = `https://api.coinpaprika.com/v1`;// 코인 정보 조회export function fetchCoinHistory(coinId: string) &#123; const endDate = Math.floor(Date.now() / 1000); const startDate = endDate - 60 * 60 * 23; // 하루치 조회 return fetch(`$&#123;BASE_URL&#125;/coins/$&#123;coinId&#125;/ohlcv/historical?start=$&#123;startDate&#125;&amp;end=$&#123;endDate&#125;`).then((reponse) =&gt; reponse.json() );&#125; https://apexcharts.com/docs/options/# 페이지를 참고하여 옵션을 커스텀합니다. 테마, x축, y축, 색상, 툴바 감추기, 크기, 툴팁 설정 등 세세한 부분까지 커스텀할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Chart.tsximport &#123; useQuery &#125; from 'react-query';import &#123; useOutletContext &#125; from 'react-router';import &#123; fetchCoinHistory &#125; from '../api';import ApexChart from 'react-apexcharts';interface IHistorical &#123; time_open: string; time_close: string; open: number; high: number; low: number; close: number; volume: number; market_cap: number;&#125;function Chart() &#123; const coinId = useOutletContext() as string; const &#123; isLoading, data &#125; = useQuery&lt;IHistorical[]&gt;(['ohlcv', coinId], () =&gt; fetchCoinHistory(coinId)); return ( &lt;div&gt; &#123;isLoading ? ( 'Loading chart...' ) : ( &lt;ApexChart type=\"line\" series=&#123;[ &#123; name: 'Price', data: data?.map((price) =&gt; price.close) as number[], &#125;, ]&#125; options=&#123;&#123; theme: &#123; mode: 'dark', &#125;, chart: &#123; height: 300, width: 500, toolbar: &#123; show: false, &#125;, background: 'transparent', &#125;, grid: &#123; show: false, &#125;, stroke: &#123; curve: 'smooth', width: 4, &#125;, yaxis: &#123; show: false, &#125;, xaxis: &#123; type: 'datetime', categories: data?.map((price) =&gt; price.time_close), labels: &#123; style: &#123; colors: '#9c88ff', &#125;, &#125;, &#125;, fill: &#123; type: 'gradient', gradient: &#123; gradientToColors: ['blue'], stops: [0, 100], &#125;, &#125;, colors: ['red'], tooltip: &#123; y: &#123; formatter: (value) =&gt; `$$&#123;value.toFixed(2)&#125;`, &#125;, &#125;, &#125;&#125; /&gt; )&#125; &lt;/div&gt; );&#125;export default Chart; 참고 https://apexcharts.com/docs/react-charts/ https://apexcharts.com/docs/options/# https://api.coinpaprika.com/#tag/Coins/paths/1coins1{coin_id}1ohlcv1historical/get","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"}]},{"title":"[React] React Query","slug":"react-4","date":"2022-07-22T15:07:58.000Z","updated":"2024-01-12T01:19:53.638Z","comments":true,"path":"2022/07/23/react-4/","link":"","permalink":"http://hgko1207.github.io/2022/07/23/react-4/","excerpt":"","text":"React Query는 데이터 Fetching, 캐싱, 동기화, 업데이트, 에러핸들링 등 비동기 과정을 쉽게 만들어 주는 React 라이브러리입니다. React Query를 사용하면 기존의 서버 데이터를 가져오거나 업데이트하는 코드를 축약할 수 있고 캐싱 처리가 간단해졌습니다. 간단하게 useQuery를 사용하여 코인들의 정보를 조회하는 코드를 통해 React Query 사용 전 후를 비교하였었습니다. 설치 123$ npm i react-queryor$ yarn add react-query useQuery 서버에서 데이터를 가져오기 위해 모든 Promise 기반 메서드(GET 및 POST 포함)와 함께 사용할 수 있습니다. 첫 번째 파라미터는 unique Key이고, 두 번째는 비동기 함수(api호출 함수)입니다. return 개체에는 api의 로딩상태, 성공, 실패여부, 결과 데이터를 포함한 객체입니다. React Query 사용 전 코인들의 정보를 조회하는 코드입니다. useState를 사용하여 코인 데이터와 조회 상태를 따로 관리하였었습니다. 12345678910111213141516171819202122232425262728293031// Coins.tsximport &#123; useEffect, useState &#125; from 'react';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;function Coins() &#123; const [coins, setCoins] = useState&lt;ICoin[]&gt;([]); const [loading, setLoading] = useState(true); useEffect(() =&gt; &#123; (async () =&gt; &#123; const response = await fetch('https://api.coinpaprika.com/v1/coins'); const json = await response.json(); setCoins(json.slice(0, 100)); setLoading(false); &#125;)(); &#125;, []); return ( ... );&#125;export default Coins; React Query 사용 후 먼저 React Query를 사용하도록 세팅합니다. 12345678910111213141516// index.tsximport React from 'react';import ReactDOM from 'react-dom';import App from './App';import &#123; QueryClient, QueryClientProvider &#125; from 'react-query';const queryClient = new QueryClient();ReactDOM.render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 코인들의 정보를 조회하는 코드를 별도 파일을 생성하여 관리합니다. 1234// api.tsexport function fetchCoins() &#123; return fetch('https://api.coinpaprika.com/v1/coins').then((reponse) =&gt; reponse.json());&#125; React Query를 사용하기 전과 비교하면 많은 코드가 제거된 것을 확인할 수 있습니다. 12345678910111213141516171819202122import &#123; useQuery &#125; from 'react-query';import &#123; fetchCoins &#125; from '../api';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;// coins.tsxfunction Coins() &#123; const &#123; isLoading, isError, data &#125; = useQuery&lt;ICoin[]&gt;('allCoins', fetchCoins); return ( ... );&#125;export default Coins; useQuery 파라미터와 결과 값을 다음과 같이 변형해서 사용할 수 있습니다. 123const &#123; isLoading: infoLoding, data: infoData &#125; = useQuery&lt;InfoData&gt;(['info', coinId], () =&gt; fetchCoinInfo(coinId as string)); Devtools React Query는 query 데이터를 시각화 하기 위해서 Devtools(Developer Tools, 개발자도구)를 기능을 가지고 있습니다. 1234567891011// App.tsximport &#123; ReactQueryDevtools &#125; from 'react-query/devtools';function App() &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &#123;/* The rest of your application */&#125; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; /&gt; &lt;/QueryClientProvider&gt; );&#125; initialIsOpen: 개발자도구가 기본적으로 열려 있도록 하려면 true로 설정 참고 https://react-query-v3.tanstack.com/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"}]},{"title":"[React] Nested Routes","slug":"react-3","date":"2022-07-21T15:59:11.000Z","updated":"2024-01-12T01:18:32.004Z","comments":true,"path":"2022/07/22/react-3/","link":"","permalink":"http://hgko1207.github.io/2022/07/22/react-3/","excerpt":"","text":"Nested Routes는 route 안에 있는 또 다른 route입니다. React Router 가 v6로 바뀌면서 Nested Routes 만 아니라 Route 사용하는 방법이 바뀌었습니다. 전 5 버전과 현재 6 버전 사용법을 비교하였습니다. React Router v5 nested routes 구현하는 방법은 자식 route를 부모 route의 element 내부에 작성하는 것입니다. 1234567891011121314151617181920// Router.tsximport &#123; BrowserRouter, Switch, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/:coinId\"&gt; &lt;Coin /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Coins /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 12345678910111213141516171819202122// Coin.tsximport &#123; Switch, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Switch&gt; &lt;Route path=\"price\"&gt; &lt;Price /&gt; &lt;/Route&gt; &lt;Route path=\"chart\"&gt; &lt;Chart /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Container&gt; );&#125;export default Coin; React Router v6 nested routes를 구현하는 방법은 두 가지가 있습니다. 6 버전에서는 Switch 가 Routes로 변경됐습니다. 첫 번째 부모 route의 path 마지막에 /*를 적어 명시적으로 이 route의 내부에서 nested route 가 render 될 수 있음을 표시하고 자식 route를 부모 route의 element 내부에 작성하는 방법입니다. 1234567891011121314151617// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId/*\" element=&#123;&lt;Coin /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415161718// Coin.tsximport &#123; Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Routes&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/Container&gt; );&#125;export default Coin; 두 번째 자식 route 를 부모 element의 내부가 아닌 Router 내부에 작성하는 방법입니다. 그리고 이 자식 Route들이 어디에 render 될지 부모의 element 안에 Outlet을 이용해 표시해 주면 됩니다. 12345678910111213141516171819202122// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Chart from './routes/Chart';import Coin from './routes/Coin';import Coins from './routes/Coins';import Price from './routes/Price';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId\" element=&#123;&lt;Coin /&gt;&#125;&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125; /&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125; /&gt; &lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415// Coin.tsximport &#123; Outlet, Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Outlet /&gt; &lt;/Container&gt; );&#125;export default Coin; 참고 https://ui.dev/react-router-nested-routes https://reactrouter.com/docs/en/v6/getting-started/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"}]},{"title":"[JPA] 복합키 사용","slug":"spring-jpa-2","date":"2022-07-13T10:21:50.000Z","updated":"2024-01-12T01:17:15.844Z","comments":true,"path":"2022/07/13/spring-jpa-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/13/spring-jpa-2/","excerpt":"","text":"서론 복합키는 기본키가 되지 못하는 칼럼들을 서로 묶어서 기본키처럼 사용하는 것입니다. Entity 예를 들어 사용자명과 이메일을 복합키로 사용한다고 가정합니다. 복합키로 묶는 CompositePK 클래스를 생성하고, @IdClass 어노테이션을 사용하여 설정합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = \"tb_user\")@IdClass(CompositePK.class) //이름과 이메일을 primary key로 사용@Datapublic class User &#123; @Data @AllArgsConstructor @NoArgsConstructor public static class CompositePK implements Domain &#123; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 이메일 */ @Column(length = 45) private String email; &#125; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Repository 인터페이스를 생성하고 JpaRepository 를 상속받습니다. 12public interface UserRepository extends JpaRepository&lt;User, CompositePK&gt; &#123;&#125; 사용 Service 클래스를 생성하고 Repository 인터페이스를 불러와서 사용합니다. 1234567891011@Service@Transactionalpublic class UserService &#123; @Autowired private UserRepository userRepository; public User get(CompositePK id) &#123; return userRepository.findById(id).orElse(null); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"}]},{"title":"[React] TypeScript 사용 방법","slug":"react-2","date":"2022-07-03T14:52:45.000Z","updated":"2024-01-12T01:16:06.112Z","comments":true,"path":"2022/07/03/react-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/03/react-2/","excerpt":"","text":"React에서 TypeScript를 적용하고 사용 방법에 대해 알아보겠습니다. 설치 create-react-app 명령어에 typescript 옵션을 추가합니다. 1$ npx create-react-app typescript --template typescript Typescript를 추가하지 않은 기존 프로젝트가 있다면 다음 명령어를 실행하여 설치합니다. 1$ npm install --save typescript @types/node @types/react @types/react-dom @types/jest Typescript 사용 시 styled-components 부분에서 에러가 날 경우 다음 명령어를 실행하여 설치합니다. 1$ npm i --save-dev @types/styled-components Typing the Props Prop Types는 코드를 실행한 후 에만 브라우저의 콘솔에 경고 표시로 확인이 가능합니다. TypeScript를 사용하는 이유는 코드가 실행되기 전에 오류를 확인하기 위해서입니다. interface는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있습니다. 123456789101112import Circle from './Circle';function App() &#123; return ( &lt;div&gt; &lt;Circle bgColor=\"teal\" /&gt; &lt;Circle bgColor=\"tomato\" /&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718import styled from 'styled-components';interface CircleProps &#123; bgColor: string;&#125;const Container = styled.div&lt;CircleProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;;`;function Circle(&#123; bgColor &#125;: CircleProps) &#123; return &lt;Container bgColor=&#123;bgColor&#125; /&gt;;&#125;export default Circle; Optional Props props는 기본으로 required 이지만 interface의 object 뒤에 ?를 추가하여 optional 될 수 있도록 변경 가능합니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';interface ContainerProps &#123; bgColor: string; borderColor: string;&#125;const Container = styled.div&lt;ContainerProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;; border: 1px solid $&#123;(props) =&gt; props.borderColor&#125;;`;interface CircleProps &#123; bgColor: string; borderColor?: string; // object뒤에 ?를 추가 =&gt; Option props text?: string;&#125;function Circle(&#123; bgColor, borderColor, text = 'default text' &#125;: CircleProps) &#123; return ( &lt;Container bgColor=&#123;bgColor&#125; borderColor=&#123;borderColor ?? 'white'&#125;&gt; &#123;text&#125; &lt;/Container&gt; );&#125;export default Circle; State State 사용 시 number, string 타입을 같이 쓰고 싶다면 다음과 같이 정의합니다. 1234const [value, setValue] = useState&lt;number | string&gt;(0);setValue(1);setValue('hello');setValue(true); // error Event https://reactjs.org/docs/events.html SyntheticEvent는 기본적으로 ReactJS 버전의 이벤트입니다. 이벤트들의 정보를 확인하는 사이트입니다. Form React.FormEvent&lt;HTMLInputElement&gt; 또는 React.FormEvent&lt;HTMLFormElement&gt;와 같은 Element를 사용함으로써 event를 보호하고 어떤 event 를 받는지 알 수 있습니다. 12345678910111213141516171819202122232425import React, &#123; useState &#125; from 'react';function App() &#123; const [value, setValue] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setValue(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); console.log(value); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; type=\"text\" placeholder=\"username\" /&gt; &lt;button&gt;Log in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default App; Theme https://styled-components.com/docs/api#typescript styled.d.ts 파일을 생성합니다. 12345678910// styled.d.tsimport 'styled-components';declare module 'styled-components' &#123; export interface DefaultTheme &#123; textColor: string; bgColor: string; btnColor: string; &#125;&#125; thmem.ts 파일을 생성하고 테마를 정의합니다. 1234567891011121314// thmem.tsimport &#123; DefaultTheme &#125; from 'styled-components';export const lightTheme: DefaultTheme = &#123; bgColor: 'white', textColor: 'black', btnColor: 'tomato',&#125;;export const darkTheme: DefaultTheme = &#123; bgColor: 'black', textColor: 'white', btnColor: 'teal',&#125;; React에서 테마 사용하는 것과 똑같은 방식입니다. 123456789101112131415// index.tsximport React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';import &#123; lightTheme &#125; from './theme';ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;lightTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 참고 https://create-react-app.dev/docs/adding-typescript/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[React] Styled Components 사용 방법","slug":"react-1","date":"2022-06-28T14:36:34.000Z","updated":"2024-01-12T01:15:07.134Z","comments":true,"path":"2022/06/28/react-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/28/react-1/","excerpt":"","text":"React에서 Styled Components를 사용하는 방법에 대해 알아보겠습니다. 설치 Visual Studio Code를 사용 시 Styled-Component 자동 완성을 위해 vscode-styled-components 플러그인을 설치합니다. 1$ npm i styled-components https://styled-components.com/ 사용 예 123456789101112131415161718192021222324252627282930import styled from 'styled-components';const Father = styled.div` display: flex;`;const BoxOne = styled.div` background-color: teal; width: 100px; height: 100px;`;const BoxTwo = styled.div` background-color: tomato; width: 100px; height: 100px;`;const Text = styled.span` color: white;`;function App() &#123; return ( &lt;Father&gt; &lt;BoxOne&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/BoxOne&gt; &lt;BoxTwo /&gt; &lt;/Father&gt; );&#125;export default App; 확장 컴포넌트를 확장하는 방법입니다. 12345678const Box = styled.div` background-color: $&#123;(props) =&gt; props.bgColor&#125;; width: 100px; height: 100px;`;const Circle = styled(Box)` border-radius: 50px;`; ‘As’ and Attrs 다음과 같이 as 속성을 사용하여 값을 a로 지정하면 button 태그가 a 태그로 변경됩니다. 12345678const Btn = styled.button` color: white; background-color: tomato; border: 0; border-radius: 15px;`;&lt;Btn as=\"a\"&gt;Log in&lt;/Btn&gt;; 속성 값 설정 attrs을 사용하여 HTML 태그에 속성 값을 설정할 수 있습니다. 123const Input = styled.input.attrs(&#123; require: true, minLength: 10 &#125;)` background-color: tomato;`; Animation keyframes를 추가하고, Animation 을 설정합니다. 그리고 styled components에 ${}를 통해 설정된 변수를 지정합니다. 123456789101112131415161718192021222324252627282930313233343536import styled, &#123; keyframes &#125; from 'styled-components';const rotationAnimation = keyframes` 0% &#123; transform: rotate(0deg); border-radius: 0px; &#125; 50% &#123; border-radius: 100px; &#125; 100% &#123; transform: rotate(360deg); border-radius: 0px; &#125;`;const Wrapper = styled.div` display: flex;`;const Box = styled.div` height: 200px; width: 200px; background-color: tomato; animation: $&#123;rotationAnimation&#125; 1s linear infinite;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box /&gt; &lt;/Wrapper&gt; );&#125;export default App; Theme index.js 파일에서 ThemeProvider를 styled-components로 부터 Import 한 후 App 태그를 감쌉니다. Theme에 어떤 색을 사용할 건지 설정합니다. 1234567891011121314151617181920212223import React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';const darkTheme = &#123; textColor: 'whitesmoke', backgroundColor: '#111',&#125;;const lightTheme = &#123; textColor: '#111', backgroundColor: 'whitesmoke',&#125;;ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;darkTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 위에서 설정한 Theme 변수를 사용합니다. Theme가 변경되면 Title이나 Wrapper 안의 글자 색상과 배경색이 변화되는 것을 확인할 수 있습니다. 123456789101112131415161718192021222324import styled from 'styled-components';const Title = styled.h1` color: $&#123;(props) =&gt; props.theme.textColor&#125;;`;const Wrapper = styled.div` display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; background-color: $&#123;(props) =&gt; props.theme.backgroundColor&#125;;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Title&gt;Hello&lt;/Title&gt; &lt;/Wrapper&gt; );&#125;export default App;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"}]},{"title":"[WPF] ffmpeg을 활용한 동영상 만들기","slug":"wpf-7","date":"2022-06-24T14:06:59.000Z","updated":"2024-01-12T01:13:51.939Z","comments":true,"path":"2022/06/24/wpf-7/","link":"","permalink":"http://hgko1207.github.io/2022/06/24/wpf-7/","excerpt":"","text":"FFmpeg Build 다운로드하기 https://ffmpeg.org/download.html#build-windows 사이트에서 Windows EXE Files 항목의 원하는 형식으로 다운로드를 합니다. 다운로드한 후 압축해제 합니다. 프로젝트의 ffmpeg 폴더를 생성 후 실행에 사용되는 exe, dll 파일들을 복사합니다. Bitmap들을 동영상으로 만들기 FFmpegLoader ffmpeg를 사용하기 위해 FFMediaToolkit 패키지를 Nuget을 이용하여 설치합니다. FFmpegLoader를 사용하여 Path를 지정합니다. 12// 예FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; 동영상에 프레임 추가 아래는 예제코드입니다. StartRecordVideo 함수에 저장될 경로를 지정하여 mediaFile을 생성합니다. 그리고 AddRecordFrame 함수를 통해 Bitmap 이미지를 설정한 30fps로 동영상에 추가합니다. 이렇게 생성된 동영상은 MPEG2 형식이므로 MPEG4 형식으로 변경합니다. MPEG2 형식의 동영상은 가끔 윈도우 환경에서 오류가 발생하는 경우가 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using FFMediaToolkit;using FFMediaToolkit.Encoding;using FFMediaToolkit.Graphics;namespace Hgko.Utils&#123; public class ImageService &#123; private bool ffmpegInit = false; private MediaOutput mediaFile = null; /// &lt;summary&gt; /// Start Record video /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public void StartRecordVideo(string path) &#123; if (mediaFile == null) &#123; if (!ffmpegInit) &#123; FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; ffmpegInit = true; &#125; int width = 1024; int heigth = 1024; VideoEncoderSettings settings = new VideoEncoderSettings(width, heigth, 30, VideoCodec.MPEG2); settings.EncoderPreset = EncoderPreset.Medium; mediaFile = MediaBuilder.CreateContainer(path).WithVideo(settings).Create(); &#125; &#125; /// &lt;summary&gt; /// Add RecordFrame /// &lt;/summary&gt; /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt; public void AddRecordFrame(Bitmap bitmap) &#123; if (bitmap == null) return; if (mediaFile == null) return; System.Drawing.Imaging.BitmapData bdata = bitmap.LockBits(new Rectangle(System.Drawing.Point.Empty, bitmap.Size), System.Drawing.Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat); ImageData imgdata = ImageData.FromPointer(bdata.Scan0, ImagePixelFormat.Bgra32, bitmap.Size); mediaFile.Video.AddFrame(imgdata); bitmap.UnlockBits(bdata); &#125; /// &lt;summary&gt; /// Stop Record Video /// &lt;/summary&gt; public void StopRecordVideo() &#123; if (mediaFile != null) &#123; mediaFile.Video.Dispose(); mediaFile.Dispose(); mediaFile = null; &#125; &#125; &#125;&#125; 동영상 포맷 변환 임시로 빌드되는 경로에 display/video 경로의 폴더를 생성합니다. 포맷 변환하는 방법은 많습니다. 다음 코드는 여러 이미지 또는 동영상을 합쳐서 새로운 동영상으로 만드는 형식의 방법을 활용하여 포맷 변환을 진행합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.IO;/// &lt;summary&gt;/// End Record Video/// &lt;/summary&gt;/// &lt;param name=\"mp2Path\"&gt;mp2 형식으로 저장된 파일경로&lt;/param&gt;public void EndRecordVideo(string mp2Path)&#123; string videoWorkingPath = @\".\\display\\video\\\"; string vedeoWorkingFolder = Directory.GetCurrentDirectory() + videoWorkingPath.Replace(\".\", \"\"); string outputVeideoPath = vedeoWorkingFolder + Path.GetFileNameWithoutExtension(mp2Path) + \".mp4\" // if exist video working directory, clean up. if (Directory.Exists(videoWorkingPath)) ClearFolder(videoWorkingPath); // remake working dir. Directory.CreateDirectory(videoWorkingPath); Task.Run(() =&gt; &#123; string lstPath = vedeoWorkingFolder + \"lst.txt\"; // 텍스트 파일에 앞에서 생성된 mp2 동영상 파일 경로 추가 using (StreamWriter writer = File.CreateText(lstPath)) &#123; writer.WriteLine(\"file '&#123;0&#125;'\", mp2Path); &#125; // h264 or mpeg4 string codec = \"h264\"; // 동영상 포맷 변환(mp2 -&gt; mp4) string arg = $@\"-safe 0 -f concat -i \"\"&#123;lstPath&#125;\"\" -c copy -vcodec \"\"&#123;codec&#125;\"\" \"\"&#123;outputVeideoPath&#125;\"\"\"; using (Process process = Process.Start(@\".\\ffmpeg\\ffmpeg.exe\", arg)) &#123; process.WaitForExit(); &#125; &#125;);&#125;/// &lt;summary&gt;/// Clear Folder/// &lt;/summary&gt;/// &lt;param name=\"path\"&gt;삭제할 경로&lt;/param&gt;public static void ClearFolder(string path)&#123; DirectoryInfo dir = new DirectoryInfo(path); // remove all files foreach (FileInfo fi in dir.GetFiles()) fi.Delete(); // remove dir recursive foreach (DirectoryInfo di in dir.GetDirectories()) &#123; ClearFolder(di.FullName); di.Delete(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"}]},{"title":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"book-1","date":"2022-06-22T07:05:37.000Z","updated":"2024-01-12T01:13:06.706Z","comments":true,"path":"2022/06/22/book-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/22/book-1/","excerpt":"","text":"책 정보 책 소개 이 책은 제목 그대로 스프링 부트와 AWS로 웹 서비스를 구현합니다. JPA와 JUnit 테스트, 그레이들, 머스테치, 스프링 시큐리티를 활용한 소셜 로그인 등으로 애플리케이션을 개발하고, 뒤이어 AWS 인프라의 기본 사용법과 AWS EC2와 RDS를 사용해 서비스가 가능하도록 합니다. 이렇게 점진적으로 스프링 부트 프로젝트를 개선해서 배포 자동화하고 무중단 배포까지 경험합니다. 실무 현장에서의 노하우와 테스트 방법, 객체지향 프로그래밍 등을 소개하고 다룹니다. 리뷰 스프링 부트와 AWS로 웹 서비스 구현에 대한 설명이 잘 정리 되어있고, 코드만 따라 해도 완성품을 만들 수 있어 도움이 되었습니다. 다만 스프링 부트와 자바에 대한 경험이 필요합니다. 책의 예제 중에서 시간이 지나면서 안 되는 기능, 부분들은 GitHub에 오류 수정으로 설명되어 있어 찾으면서 진행하면 좋습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"}]},{"title":"[WPF] 이미지 자르기","slug":"wpf-6","date":"2022-06-20T02:02:13.000Z","updated":"2023-06-05T00:38:17.382Z","comments":true,"path":"2022/06/20/wpf-6/","link":"","permalink":"http://hgko1207.github.io/2022/06/20/wpf-6/","excerpt":"","text":"사각형, 타원, 삼각형으로 이미지를 자르기 위해 다음처럼 정의합니다. 123456public enum ShapeType&#123; Rectangle, Ellipse, Triangle,&#125; 이미지 자르기 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 자릅니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public Bitmap CreateCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; RectangleF srcRect = new Rectangle((int)left, (int)top, (int)width, (int)height); switch (shapeType) &#123; case ShapeType.Rectangle: g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); break; case ShapeType.Ellipse: &#123; int x = (int)width / 2; int y = (int)height / 2; g.SmoothingMode = SmoothingMode.AntiAlias; g.TranslateTransform(result.Width / 2, result.Height / 2); GraphicsPath gp = new GraphicsPath(); gp.AddEllipse(0 - x, 0 - y, result.Width, result.Height); Region rg = new Region(gp); g.SetClip(rg, CombineMode.Replace); g.DrawImage(image, new Rectangle(-x, -y, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Replace); g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; &#125; &#125; return result;&#125; 이미지 제외 나머지 부분 제거 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 제외한 나머지 부분을 제거합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Bitmap CreateInvertCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; switch (shapeType) &#123; case ShapeType.Rectangle: Rectangle rect = new Rectangle((int)left, (int)top, (int)width, (int)height); g.SetClip(rect, CombineMode.Exclude); break; case ShapeType.Ellipse: &#123; GraphicsPath gp = new GraphicsPath(); gp.AddEllipse((int)left, (int)top, (float)width, (float)height); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; &#125; Rectangle destRect = new Rectangle(0, 0, result.Width, result.Height); Rectangle srcRect = new Rectangle(0, 0, result.Width, result.Height); g.DrawImage(image, destRect, srcRect, GraphicsUnit.Pixel); &#125; return result;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"}]},{"title":"[WPF] 이미지 불러오기","slug":"wpf-5","date":"2022-06-18T13:03:19.000Z","updated":"2023-03-14T02:23:28.017Z","comments":true,"path":"2022/06/18/wpf-5/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-5/","excerpt":"","text":"이미지 로드 이미지 파일 경로를 통해 이미지를 로드합니다. 123456789using System.Drawing.Imaging;public Bitmap LoadImage(string path)&#123; using (Bitmap bitmap = new Bitmap(path)) &#123; return bitmap.Clone(new Rectangle(0, 0, bitmap.Width, bitmap.Height), PixelFormat.Format32bppArgb); &#125;&#125; BitmapSource 변환 주어진 비트맵을 WPF 이미징 프레임워크에서 사용 가능한 BitmapSource 형식으로 변환합니다. 1234567891011121314151617181920212223242526using System.Drawing.Imaging;using System.Windows;using System.Windows.Media.Imaging;public BitmapSource ConvertGDIBitmapToWPF(Bitmap image)&#123; if (image == null) return null; Rectangle rect = new Rectangle(0, 0, image.Width, image.Height); BitmapData bitmapData = image.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb); try &#123; int size = rect.Width * rect.Height * 4; BitmapSource result = BitmapSource.Create(image.Width, image.Height, image.HorizontalResolution, image.VerticalResolution, PixelFormats.Bgra32, null, bitmapData.Scan0, size, bitmapData.Stride); result.Freeze(); return result; &#125; finally &#123; image.UnlockBits(bitmapData); &#125;&#125; 빈 비트맵 생성 주어진 크기를 갖는 빈 비트맵을 생성합니다. 123456using System.Drawing.Imaging;public Bitmap MakeEmptyImage(int width, int height)&#123; return new Bitmap(width, height, PixelFormat.Format32bppArgb);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[Devexpress] GridControl 자동 번호 매기기","slug":"wpf-4","date":"2022-06-18T02:33:14.000Z","updated":"2024-01-12T01:12:27.487Z","comments":true,"path":"2022/06/18/wpf-4/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-4/","excerpt":"","text":"Devexpress GridControl의 TableView에서 행이 추가될 때마다 컬럼의 숫자가 자동 증가하도록 구현한 코드입니다. Converter 생성 IValueConverter 인터페이스를 상속받아 IndexFromOneConverter 클래스를 생성합니다. 12345678910111213141516171819202122232425using System;using System.Globalization;using System.Windows.Data;/// &lt;summary&gt;/// GridControl의 자동 생성 인덱스를 1 부터로 변환하는 컨버터/// &lt;/summary&gt;namespace IVM.Studio.Utils&#123; public class IndexFromOneConverter : IValueConverter &#123; /// &lt;summary&gt; /// 자동 증가되도록 1을 더해준다. /// &lt;/summary&gt; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; return (int)value + 1; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; return value; &#125; &#125;&#125; 적용 위에서 만든 Converter를 불러와서 GridControl에 적용합니다. 123456789101112131415161718192021222324252627282930313233343536&lt;Window x:Class=\"Test.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"d\" xmlns:util=\"clr-namespace:Test.Utils\" xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\" Title=\"Test\" Height=\"600\" Width=\"560\"&gt; &lt;Window.Resources&gt; &lt;utils:IndexFromOneConverter x:Key=\"IndexFromOneConverter\"/&gt; &lt;/Window.Resources&gt; &lt;Grid Margin=\"10\"&gt; &lt;dxg:GridControl ItemsSource=\"&#123;Binding TestInfos&#125;\" SelectedItem=\"&#123;Binding SelectedTestInfo&#125;\" SelectionMode=\"Row\" ShowBorder=\"True\" RenderOptions.EdgeMode=\"Aliased\"&gt; &lt;dxg:GridControl.View&gt; &lt;dxg:TableView AutoWidth=\"True\"/&gt; &lt;/dxg:GridControl.View&gt; &lt;dxg:GridControl.Columns&gt; &lt;dxg:GridColumn Header=\"#\" Width=\"40\"&gt; &lt;dxg:GridColumn.CellTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=\"&#123;Binding RowData.RowHandle.Value, Converter=&#123;StaticResource IndexFromOneConverter&#125;&#125;\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; &lt;/DataTemplate&gt; &lt;/dxg:GridColumn.CellTemplate&gt; &lt;/dxg:GridColumn&gt; &lt;dxg:GridColumn Header=\"Note\" Width=\"100\" FieldName=\"Note\"/&gt; &lt;dxg:GridColumn Header=\"Content\" Width=\"200\" FieldName=\"Content\"/&gt; &lt;dxg:GridColumn Header=\"Area\" Width=\"200\" FieldName=\"Area\"/&gt; &lt;/dxg:GridControl.Columns&gt; &lt;/dxg:GridControl&gt; &lt;/Grid&gt;&lt;/Window&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"}]},{"title":"CE, LE 계산","slug":"satellite-ce-le","date":"2022-06-17T12:56:43.000Z","updated":"2024-01-12T01:10:36.612Z","comments":true,"path":"2022/06/17/satellite-ce-le/","link":"","permalink":"http://hgko1207.github.io/2022/06/17/satellite-ce-le/","excerpt":"","text":"관측값 즉, 지상기준점과 측정점의 차이에 대해 CE 및 LE 결과를 내기 위해 구현을 하게 되었고 참고자료를 바탕으로 정리하였습니다. 소스 코드는 CE, LE 계산 사이트에 있습니다. CE(Circular Error) X, Y 축의 값에 대한 2차원 오차를 측정합니다. 원형오차라고 부르며, CE 50, CE 90, CE 95 등의 형식으로 표현합니다. 예) CE90 5m는 오차들이 실제 값에서 5m 반경 안에 90% 있음을 나타냄. CE 90 계산 1) 관측값 평균이 0일 경우 CE_XX = R * 𝜎𝑚𝑎𝑥 2x2 공분산 행렬을 계산하고, 공분산 행렬에 대해 고유값(Eigenvalue) 계산 최소, 최대 고유값에 대해 제곱근으로 𝜎𝑚𝑖𝑛, 𝜎𝑚𝑎𝑥 값을 구함 예) MATLAB은 eig(A) 함수를 사용 r = 𝜎𝑚𝑖𝑛/𝜎𝑚𝑎𝑥, p=90/100 두 개의 값과 아래 표의 값을 통해 선형 보간하여 확률 계수 R을 구함 예) r = 0.509, p = 0.9 일 때, R = 0.041/0.05 * 1.7371 + 0.009/0.05 * 1.7621 = 1.7416 확률 계수와 𝜎𝑚𝑎𝑥를 곱함 2) 관측값 평균이 0이 아닐 경우 X, Y 축에 대해 각각 공분산 값을 구하고 2x2 공분산 행렬을 계산 i 수만큼 위의 수식으로 2x1(X, Y)의 Si를 계산 Si의 크기를 가장 작은 것부터 가장 큰 것 순으로 정렬(크기는 아래 수식과 같음) RExx는 xx% 가장 큰 크기, RE*xx는 다음으로 큰 크기를 지정. CE_XX 계산은 아래 수식으로 계산. LE(Linear Error) Z 축(고도)에 대한 오차를 측정합니다. 지형의 수직 정확도를 측정합니다.(TIN, DEM, DSM 등) 선형오차라고 부르며, LE 50, LE 90, LE 95 등의 형식으로 표현합니다. LE 90 계산 1) 관측값 평균이 0일 경우 LE_XX = P(확률계수) * 𝜎𝑧 (표준편차) 관측값에 대한 표준편차를 구함 다음의 표에서 p=90/100(0.90)에 대한 확률 계수인 1.6449를 구함 표준편차와 확률 계수를 곱함 LE_90 = 1.6449 * (표준편차) 2) 관측값 평균이 0이 아닐 경우 기준점과 측정점을 통해 표준편차와 평균을 구함 위의 식(누적분포함수)에서 p 값을 계산 p 값에 대해 오차 역함수(Inverse Error Function)를 구함 다음의 식을 통해 LE를 계산 참고내용 1) 분산(Variance) 관측값에 대한 분산 2) 공분산(Covariance) 관측값에 대한 공분산 3) 공분산 행렬 두 개의 확률 변수의 공분산 행렬은 각 변수 쌍에 대해 계산된 공분산 값으로 구성된 행렬 4) 표준편차(Standard Deviation) 관측값에 대한 표준편차 참고자료 Computation of scalar accuracy metrics LE, CE, and SE as both predictive and samplebased statistics (NGA) Geopositional Statistical Methods (NASA)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"}]},{"title":"DEM","slug":"satellite-dem","date":"2022-06-14T15:39:52.000Z","updated":"2024-01-12T01:11:57.819Z","comments":true,"path":"2022/06/15/satellite-dem/","link":"","permalink":"http://hgko1207.github.io/2022/06/15/satellite-dem/","excerpt":"","text":"Digital Elevation Models 수치표고모형(DEM)은 수치지형 또는 수심측량 데이터에 관한 일반적인 용어로써, 일반적으로 식생과 인공지물을 포함하지 않는 지형만의 높이를 의미하며, 강, 호수의 DEM 높이 값은 수표면을 나타냅니다. DEM은 일반적으로 **DTM(Digital Terrain Model)**과 비슷한 의미로 사용됩니다. **USGS(U.S. Geological Survey)**의 정의 : DEM은 보통 높이의 기준면으로부터 측정한 z값을 사용하여 x, y 방향으로 일정한 간격의 지형에 대한 높이 값을 수치지도 형식으로 표현한 것입니다. 이 정의는 **NIMA(National Imagery and Mapping Agency)**에서 작성한 **DTED(Digital Terrain Elevation Data)**의 정의와 유사합니다. DEM의 기하학적 구조는 규칙격자망(Regular Grid, Elevation Matrix)과 불규칙삼각망(Triangular Irregular Network, TIN)이 있으며 각각 장단점을 가지고 있습니다. DTM(Digital Terrain Model) DEM과 유사한 뜻으로 사용되며, 동일한 간격의 z값을 가집니다. DTM은 DEM과 비슷하지만 지형을 좀 더 정확하게 묘사하기 위해 불규칙적으로 간격을 갖는 불연속성(breakline)이 존재한다는 것이 다릅니다. DTM의 최종적인 결과는 특정 지형을 명확히 묘사하는 것이며, 등고선은 지형의 실제 형태에 가깝도록 DTM으로부터 생성하곤 합니다. DSM(Digital Surface Mode) DEM에 식생, 건물, 도로 등 자연 및 인공 지형지물의 표고 값이 포함된 것을 나타냅니다. 원거리통신관리, 산림관리, 3D 시뮬레이션 등에 이용됩니다. 규칙격자망 일정 크기 사각형 격자지점의 표고행렬로 지형기복 변화를 표현하는 방법입니다. 규칙적인 격자의 교차점에서의 고도를 저장하며, 보통 불규칙한 기준점 집합으로부터 정교한 보간 기법을 거쳐 계산됩니다. 일반적으로 격자의 크기는 기준점 사이의 거리보다 더 작으며, 불연속선이나 높이를 나타내는 점에 의해 표현된 지질학적 정보도 규칙적인 격자로 형성됩니다. 장점 고도만 저장되므로 자료의 구조가 간단함 등고선, 경사각, 경사 방향 계산, 음영이나 분지를 표현 하는데 유용 행렬 처리를 적용함에 있어서 계산 시간이 빠름 단점 복잡한 지형의 표현 시 격자 간격을 좁게 해야 함 표면을 표현하기 위해 높은 밀도의 점들을 저장해야 함 규칙적인 격자에서 불연속선을 표현하는 데 따르는 문제점 불규칙삼각망(TIN) 불규칙삼각망은 원래의 자료 점들을 Delaunay 삼각망을 활용하여 불규칙한 형태의 연속적인 삼각형을 연결시켜 지형의 기복을 표현합니다. 장점 기복이 심한 지역에서 효과적으로 사용될 수 있음 자료의 중복을 줄일 수 있으므로 지형을 효과적으로 표현 최소한의 표고점을 이용하여 능선이나 곡선과 같은 지형 구조 특성을 반영한 보간을 할 수 있다는 점 단점 점들의 불규칙한 구조로 인해 각각의 점들을 저장하려면 대상에 대한 더 많은 정보가 필요함 등고선, 능선, 합수선, 인공구조물 등을 가로질러 TIN이 구성되면 실제 지형 특성을 반영하기 못함 수치등고선으로 TIN을 구성할 때 동일 등고선 상의 꼭짓점들 안으로 TIN이 구성되면 그 TIN 내부는 평지로 표현이 됨 원천 자료에 따른 DEM 구축 방법 별 특성 구분 소요 장비 경제성 정확성 현시성 지상 측량 Total Station, GPS 시간경비과다 우수 우수 종이 지도 Digitizer 수동, 시간 과다 지도에 달림 지도에 달림 Scanner GEOVEC 자동, 기술적 애로 지도에 달림 지도에 달림 수치 지도 MAP 지도 S/W 우수 지도에 달림 지도에 달림 기존 사진(사진 측량) 해석도화기 양호 우수 사진에 달림 신규 촬영(사진 측량) 수치도화기 촬영비 추가 우수 우수 원격 탐사 Image Processor 우수 개선 중 우수 레이저 측량 레이저 고도계 우수 우수 우수 DEM 추출 방법 – 수치 지도 활용 이미 제작된 수치지도를 이용하여 DEM을 구축하는 방법으로 수치지도의 등고선 및 고도점의 좌표를 추출하여 DEM을 생성합니다. DEM 생성 시 고려해야 할 사항 수치지도 제작 시기가 오래되었을 경우 현재의 지표 및 지물의 정보가 부족 인공지물 밀집 지역일 경우 고도 추출점이 표기되어 있지 않을 수 있음 따라서, 수치지도로 DEM을 작성할 때에는 항공사진 혹은 보다 대축척의 수치지도, 지상측량 등의 보조 자료를 이용하여 등고선 및 고도점을 보완해야 합니다. 등고선 데이터는 제한된 범위의 정확도를 가진 DEM을 구축합니다. 기대할 수 있는 최대의 정확도는 등고선 간격의 1/2 정보 등고선으로부터 DEM을 생성하는 것은 대부분의 상용 소프트웨어(PCI, Erdas Imagine) 등에서 지원합니다. DEM 추출 방법 – 항공사진 측량 항공사진(또는 항공영상)을 이용한 DEM 구축 방법은 현재 실용화된 방법 중 가장 정확하고 최신의 수치 고도 자료를 얻을 수 있습니다. 항공사진측량용 카메라로 촬영된 입체 항공사진을 이용하여 해석도화기와 도화사의 작업을 통해 수동으로 DEM을 추출하는 방법 항공사진을 스캐닝하거나 항공사진 측량용 디지털카메라로 획득한 항공 영상을 이용하여 수치도화기에서 자동으로 DEM을 추출하는 방법 항공사진(또는 항공영상)을 이용하면 지형은 물론이고 지물에 대한 DEM 구축이 가능합니다. DEM 추출 방법 – 위성 영상 위성영상의 해상력이 높아지고 이동한 위치에서 반복 촬영한 동일 지점의 영상을 획득할 수 있게 됨으로써 위성영상으로부터 DEM 구축이 가능해집니다. 위성영상은 항공사진에 비하여 포함면적이 넓고, 주기적으로 영상을 얻을 수 있으므로 최신의 정보를 획득하는데 소요되는 시간과 비용을 절감할 수 있습니다. 위성영상에 항공사진의 수치사진측량기법을 적용하여 자동으로 DEM을 생성할 수 있습니다. DEM의 정확도 수치표고모델의 정확도는 선형적으로 보간 된 DEM과 지도나 GPS 자료와 같은 참조자료와의 비교를 통한 RMSE(root-mean square error) 값을 이용합니다. DEM의 정확도는 데이터의 스케일과 공간 해상도, 격자 간격에 영향을 많이 받습니다. DEM의 수평정확도는 표고행렬의 수평간격에 영향을 많이 받음 DEM의 수직정확도는 원시 데이터의 질과 공간 해상도, 자료의 수집과 처리과정에 많은 영향을 받음 등고선으로부터 구축된 DEM의 평가 기준(Carrara, 1997) 수치 지도의 등고선 근처에 배치된 격자점의 표고는 그 등고선의 표고와 일치하거나 큰 차이가 없어야 함 두 등고선으로 포위된 영역 내에 있는 격자점의 표고는 두 등고선 표고 사이의 표고이며, 두 등고선 사이에서 선형 변화함 경사 변화가 완만한 지역에서도 DEM은 지형을 현실적으로 묘사하여야 함 일정 규모이상의 인공 지물에 대한 정보를 DEM으로부터 추출할 수 있어야 함 DEM 자동 제작 방법","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"}]},{"title":"DPPDB","slug":"satellite-dppdb","date":"2022-06-14T12:36:15.000Z","updated":"2022-09-02T14:49:52.097Z","comments":true,"path":"2022/06/14/satellite-dppdb/","link":"","permalink":"http://hgko1207.github.io/2022/06/14/satellite-dppdb/","excerpt":"","text":"Digital Point Positioning Database 네이버 백과사전 정밀영상위치제공 지형정보로서 미(美) 국가영상지도국(NIMA)이 1970년대 베트남전 중 미 공군의 B-52와 F-111에서 정밀항법 유도무기를 사용하기 위해 개발했다가 1995년 IT 발달에 따라 디지털로 전환시켰습니다. 3차원 지형데이터에 각종 건물 등 지상 구조물 데이터를 통합해 매우 정밀한 위치정보를 제공합니다. 이 데이터와 미군용 GPS를 결합하면 수십km 밖에서도 미사일 등 유도 무기를 1m의 오차로 공격할 수 있습니다. DPPDB는 스테레오 이미지 쌍 및 관련 보조 데이터의 모음으로, 이미지에서 식별할 수 있는 모든 점 또는 특징에 대한 정확한 위치 데이터를 신속하게 확인할 수 있는 기능을 제공합니다. 이 데이터는 스테레오 이미지를 분할, 방사 보정, 합리적인 다항식 구성 및 압축 등의 추가 처리를 함으로써 얻을 수 있습니다. 일반적으로 1도 면적(60 x 60 NM)을 커버하며 NITF 파일로 제공됩니다. 참고로 DPPDB는 NITF(National Imagery Transmission Format ) 2.0 사양의 제품입니다. DPPDB 제품은 세 가지 주요 구성 요소로 구성된 디지털 제품입니다. 1. imagery support data : Master Product File(MPF) 2. a map graphic for reference(참고 용 지도) : CADRG 프레임 파일 3. stereo imagery(입체 영상) : 전체 해상도 및 Overview 이미지 파일 NITF 란 National Imagery Transmission Format Standard (국가 영상정보 전송 포맷 표준) NITF는 공중에서 영상을 획득하는 플랫폼들로부터 얻어진 원본 영상을 기반으로 영상, 서브-영상(sub-images), 그래픽, 심볼, 텍스트 뿐 아니라 영상과 관련된 정보를 담을 수 있는 하나의 패키지(package)로서 2차 디지털 영상(secondary digital imagery)의 배포 또는 유통을 지원하기 위한 포맷입니다. 따라서 단순히 영상 자체만을 저장하는 일반 영상 포맷과 차별화됩니다. NITF에 대한 개발은 1987년 미국 정부에 의하여 시작되었으며, 1991년 미국 국방부(DoD) 내에서 영상 파일에 대한 표준인 MIL-STD-2500B로 지정되었으며, 현재 MIL-STD-2500C로 발전되었습니다. NITF는 영상유통포맷의 최초 개발로 1989년 NITF 1.1 발표 이후, 1991년 국방부 표준으로 지정되면서 이름을 NITFS(National Imagery Transmission Format Standard)로 개명하게 되었습니다. DPPDB 구조 DPPDB 제품 파일은 아래 그림과 같이 순차적으로 배열됩니다. 첫 번째 파일은 MPF(Master Product File)이며 DPPDB 및 참조 그래픽에 대한 정보를 제공하는 수많은 서브 헤더 파일이 있습니다. MPF 다음에는 참조 그래픽 프레임을 구성하는 파일이 있습니다. DPPDB에 포함 된 나머지 파일은 이미지 파일입니다. 1) MPF (Master Product File) 정확도, 세그먼트간 이격점 데이터, 진단점, 불량 지역 정보, 풋 프린트 및 이미지 파일과 참조 그래픽에 대한 정보와 같은 보조 데이터를 포함하고 있습니다. 그림은 기본 구성 요소만 보여주는 MPF의 파일 구조입니다. 2) Reference Graphic files MPF 다음으로 구성된 그래픽 파일은 사용자가 지정한 영역에 대한 디지털 맵을 제공합니다. 다양한 벡터 오버레이를 표시하고 대상의 대략적인 위치를 식별하기 위해 사용됩니다. DPPDB 제품의 사각형보다 약간 큰 영역을 포함하는 8 비트 컬러 래스터 이미지입니다. 그래픽의 소스는 CADRG(Compressed ARC Digitized Raster Graphics) 데이터입니다. 3) Image Files 이미지 파일은 전체 해상도 및 overview(전체 해상도 이미지의 1/8x 또는 1/4x 축소 된 이미지) 세그먼트 이미지 세트로 구성되어 있습니다. 각 전체 해상도 및 overview 이미지 파일에는 해당 이미지에 대한 정보 및 함수 계수도 포함되어 있습니다. 이미지 파일은 4 개의 그룹 (왼쪽과 오른쪽의 전체 해상도 및 overview 이미지)으로 구성되며 각 그룹은 단일 DPPDB 모델에 포함됩니다. 아래 그림은 전체 해상도 및 overview 이미지 세그먼트의 파일 구조를 보여줍니다. DPPDB 생성 NITF 영상 및 위치결정자료 생성 절차를 설명합니다. 세그먼트 분할 입체시 영상에 대한 세그먼트 이미지를 분할합니다. 불량지역 생성 불량지역 생성 기능을 통해 영상에서 유효하지 않는 영역을 식별 또는 추가합니다. 불량지역은 구름으로 관측이 어려운 지역이나, 바다, 호수와 같이 수계지역을 의미합니다. 정확도 평가 각 세그먼트간 측정오차, 절대정확도, 상대정확도를 계산합니다. 세그먼트간 이격점 생성 각 세그먼트 간 중복지역에서 특징점을 추출하고, 매칭을 통해 자동으로 점을 생성합니다. 참고문헌 미국 군사규격서 MIL-PRF-89034 : Digital Point Positioning Data Base(DPPDB) MIL-STD-2500A: National Imagery Transmission Format(NITF) for NITFS MIL-STD-2301A : Computer Graphics Metafile(CGM) Implementation Standard for the National Imagery Transmission Format Standard(NITFS) MIL-PRF-89038 : Compressed ARC Digitized Raster Graphics(CARRG) MIL-PRF-89041: Controlled Image Base(CIB) NITF NITFS : https://terms.naver.com/entry.nhn?docId=3480012&amp;cid=58439&amp;categoryId=58439 NITF/NSIF Background : https://www.harrisgeospatial.com/docs/BackgroundNITFNSIFFormat.html#Main","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"}]},{"title":"CSM","slug":"satellite-csm","date":"2022-06-13T11:01:13.000Z","updated":"2024-01-12T01:09:45.521Z","comments":true,"path":"2022/06/13/satellite-csm/","link":"","permalink":"http://hgko1207.github.io/2022/06/13/satellite-csm/","excerpt":"","text":"Community Sensor Model(CSM) NGA(국가지리정보국, National Geospatial Intelligence Agency)에서는 센서 모델을 동일한 방법으로 접근할 필요성에 따라 CSM(Community Sensor Model)을 개발하여 통일된 인터페이스를 제공합니다. CSM은 현재 운용되고 있거나 추후 운용이 예상되는 위성 센서의 모델, 알고리즘, 소프트웨어에 대한 개발, 시험, 평가를 지원하는 플러그인 소프트웨어 라이브러리입니다. CSM은 WGS84 타원체의 ECEF(Earth Centered Earth Fixed) 좌표계를 사용하고 있습니다. 따라서 모든 함수에서 지상 좌표의 입력과 출력 값은 ECEF 좌표로 구성해야 합니다. CSM 사용 소프트웨어 ENVI, ERDAS, SOCET GXP 등 CSM 장단점 장점 센서모델링을 수행하기 위한 소프트웨어 개발 시 모델링에 사용되는 행렬과 반복 알고리즘만 구현하면 되므로 소프트웨어의 개발비용 절감효과가 큽니다. 새로운 센서나 모델들이 개발되면, 센서모델에 대한 플러그인만 개발하여 배포하고 응용 소프트웨어에서 호출하여 모델링을 수행하므로 센서모델의 확장성이 뛰어납니다. 단점 ECEF 좌표계 사용을 위해 경우에 따라 중복된 좌표 변환 작업을 수행하게 되어 효율성이 다소 저하됩니다. CSM Context Diagram CSM API CSM은 CSMPlugin 클래스와 CSMSensorModel 클래스로 구분됩니다. CSMPlugin 클래스 플러그인 제조사, 배포 일자와 같은 기본적인 정보를 제공합니다. 센서 모델 선택, Image Support Data(ISD) 처리, 센서 모델 생성과 같은 기능을 하는 함수들로 구성됩니다. SMSensorModel 클래스 영상좌표에서 지상좌표의 상호 간 변환, 편미분, 공분산, 파라미터 설정 등 사진 측량에 필요한 함수들로 구성됩니다. Sensor Model Download Github Page - Community Sensor Model API Build 다운로드가 완료되면 압축을 풀어줍니다. 빌드에 필요한 CMake를 설치합니다. 설치가 완료되면 CMake gui를 실행합니다. 빌드를 하기 전 CSM 폴더 안에 build 폴더를 생성합니다. CMake gui에서 Source 및 Build(생성한 build 폴더 경로) 경로를 입력하고 Configure 버튼을 클릭합니다. 오류 없이 설정이 완료되면 Generate 버튼을 클릭합니다. CMake Build가 완료되면 다음과 같이 프로젝트가 생성됩니다. 프로젝트를 실행하여 빌드를 실행하면 csmapi.dll, csmapi.lib 파일이 생성됩니다. CSM 은 공통 인터페이스를 제공하기 때문에 csmapi.dll, csmapi.lib, 헤더 파일을 참조 및 로드하여 위성에 대한 센서 모델을 구현합니다. 기본적으로 Plugin, RasterGM을 상속받아 구현합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"}]},{"title":"개발 시 도움이 될 도구들","slug":"util-2","date":"2022-06-11T13:31:16.000Z","updated":"2024-01-11T15:28:47.284Z","comments":true,"path":"2022/06/11/util-2/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/util-2/","excerpt":"","text":"1. 댓글 게시판, 커뮤니티, 블로그 등 콘텐츠 위주의 서비스면 댓글은 필수입니다. 댓글 기능이 메인은 아니지만 필요한 기능 중 하나이며, 구현하기에는 시간도 많이 듭니다. 그래서 다음 서비스들로 대체해서 사용합니다. Disqus Disqus(https://disqus.com/)는 소셜 댓글 서비스입니다. 자바스크립트 코드만 사이트에 등록하면 위젯 형태로 서비스에서 바로 사용이 가능한 댓글 전문 서비스입니다. LiveRe LiveRe(https://www.livere.com/)는 국내에서 만든 소셜 댓글 서비스입니다. 별도의 가입이 필요하지 않고, SNS(카카오톡, 네이버, 페이스북 등) 계정이 있으면 언제든 댓글을 남길 수 있는 편의성이 있습니다. Utterances Utterances(https://rtterances.es/)는 깃허브 댓글입니다. 깃허브의 이슈 기능을 이용했기 때문에 무료로 사용 가능합니다. 깃허브의 마크다운 에디터를 그래도 사용하고 있어 댓글을 마크다운으로 작성할 수 있다는 장점이 있습니다. 2. 외부 서비스 연동 SNS 연동 서비스들입니다. Zapier Zapier(https://zapier.com/)는 수많은 클라우드와 SNS 서비스들의 오픈 API를 이용하여 서로 간의 연동을 지원하는 서비스입니다. IFTTT IFTTT(https://ifttt.com/)는 IF This Then That의 약자로, 만약 A를 하면 B를 하라는 의미로 클라우드와 SNS 연동을 지원하는 서비스입니다. 3. 방문자 분석 사이트 운영에 필요한 여러 정보들을 분석하는 기능을 무료로 지원하는 도구들입니다. 구글 애널리틱스 구글 애널리틱스는 구글에서 지원하는 사이트 분석 도구입니다. 국내에도 많은 자료가 공유되어 있어 사용하기 편하고 다른 구글 서비스들과의 연동도 잘 되어 있습니다. 4. CDN CDN은 Content Delivery Network의 약자로 전 세계에 분산되어 있는 서버 네트워크입니다. 정적 콘텐츠라고 불리는 JS, CSS, 이미지 등을 전 세계에 퍼진 서버에 전달하여 사용자가 서비스에 접속할 때 가장 가까운 서버에서 가져가도록 지원하는 서비스입니다. CDN의 목적은 트래픽 분산을 위함입니다. 클라우드플레어 클라우드플레어(https://www.cloudflare.com/)는 해외뿐만 아니라 국내에서도 가장 많이 사용되는 CDN 서비스입니다. 정적 파일들을 캐싱하여 제공하는 CDN의 기능은 무료로 사용할 수 있습니다. 5. 이메일 마케팅 뉴스레터와 같은 이메일 마케팅 기능을 지원하는 서비스입니다. Mailchimp Mailchimp(https://mailchimp.com/)는 해외에서 서비스 중인 이메일 마케팅 서비스입니다. 회원 2000명에게 월 12000개의 메일을 무료로 보낼 수 있어 초기에 사용하기 좋습니다. 반응형을 고려한 뉴스레터나 구독자 관리, 통계 등의 기능을 지원합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"}]},{"title":"지리공간자료 정확도","slug":"satellite-accuracy","date":"2022-06-11T13:29:25.000Z","updated":"2024-01-11T15:28:26.089Z","comments":true,"path":"2022/06/11/satellite-accuracy/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/satellite-accuracy/","excerpt":"","text":"지리공간자료 정확도의 형태 Spatial (position, geometry, topology) Attributional (correctness of attributes) Spectral (band depth) Temporal (appropriate date) Radiometric (capture piece of electromagnetic spectrum) 지리공간자료 기하보정된 위성영상 정사영상(Orthoimagery) DTM(Digital Terrain Model) DEM(Digital Elevation Model) DSM(Digital Surface Model) TIN(Triangulated Irregular Network) 정확도(Accuracy) 과학, 산업, 공업, 통계학 분야에서 재거나 계산된 양이 실제 값과 얼마큼 가까운지를 나타내는 기준이며, 관측의 정교성이나 균질성과는 무관합니다. 측정에 의해 얻은 최고 추정 값과 측정 된 수량의 &quot;참&quot;값에 대한 근접성입니다. 위치 정확도(Position Accuracy) 두 지리 공간 레이어 사이 또는 지리 공간 레이어와 현실 사이의 위치 차이를 나타내는 정량화 가능한 값입니다. Root Mean Square Error(RMSE) 평균 제곱근 편차(Root Mean Square Deviation; RMSD) 또는 평균 제곱근 오차(Root Mean Square Error; RMSE)는 추정 값 또는 모델이 예측한 값과 실제 환경에서 관찰되는 값의 차이를 다룰 때 흔히 사용하는 측도이다. 정밀도를 표현하는데 적합합니다. 각각의 차이 값은 잔차(residual)라고도 하며, 평균 제곱근 편차는 잔차들을 하나의 측도로 종합할 때 사용됩니다. 잔차 값 간의 분산을 통계적으로 측정한 것입니다. Standard Deviation(StDev) : 표준 편차 자료의 산포도를 나타내는 수치로, 분산의 양의 제곱근으로 정의됩니다. Circular Error(CE) : 원형 오차 CE는 X, Y 모두에 대한 2차원 오차를 측정합니다. CE90, CE95, CE99 형식으로 표현합니다. 원형 분포에서 모든 오차가 n%를 초과하지 않는 반경 오차 예) CE 90 = 2미터인 경우 : 오차들이 반지름 2미터인 원 안에 있을 확률이 90%라는 것을 나타낸다. Linear Error(LE) : 선형 오차 Z축(고도)에 대한 오차 측정을 합니다. 측정된 값과 실제 또는 알려진 값과의 차이를 계산합니다. 지형의 수직 정확도 측정(예: DEM 또는 TIN) LE90, LE95, LE99 형식으로 표현합니다. 예) LE 95 = 10m인 경우: 오차들이 10 미터 내에 있을 확률이 90%라는 것을 나타낸다. Circular Error Probable(CEP) Circular Error Probability 또는 Circular Error Probable, 원형 공산 오차 라고 하며 탄도학에서 무장의 정밀도를 측정하는 단위. CEP는 폭탄 등이 투하되었을 경우, 그중의 반수가 명중하는 원의 반경을 가리킵니다. 즉 10발 공격했을 때 5발이 들어가는 원을 그렸을 때 그 반경이 5m이라고 하면 CEP는 5m라고 합니다. 2차원의 수평방향 성분에 대해 50%의 원형 확률 오차(CEP)의 수치는 원의 반경과 같으며, 측점들의 각각의 계산 값에 포함되는 잔차들 중 50%는 이 원안에 들어오고 나머지는 원 밖에 존재합니다. 항해 시의 위치정밀도 측정치로, 실제 수평자표에서 오차 타원에서 그 반경을 나타냅니다. 이 값은 현재 위치가 실제 위치에 있을 확률이 50% 임을 나타냅니다. 실제위치를 중심으로 한 위치추정값의 50%를 함유하는 원의 반경 수치입니다. CE50 형식과 같습니다. 참고자료 GPS 기초 GCP 용어정리 Introduction to GPS","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"}]},{"title":"[CentOS] nohup 사용 방법","slug":"linux-17","date":"2022-05-29T13:11:12.000Z","updated":"2024-01-11T15:26:46.689Z","comments":true,"path":"2022/05/29/linux-17/","link":"","permalink":"http://hgko1207.github.io/2022/05/29/linux-17/","excerpt":"","text":"리눅스 환경에서 nohup 사용 방법에 대해 알아보겠습니다. nohup nohup 은 No Hang Ups의 약자로 백그라운드로 지속적으로 실행하는 프로세스를 의미합니다. nohup 은 실행을 현재 사용자 세션이 아닌 운영체제가 제공하는 백그라운드 공간에서 실행을 한다. &amp; 는 사용자 세션에서 실행되며, 화면 출력만 백그라운드로 전환한 상태입니다. 즉 &amp; 로 실행된 프로세스는 사용자 세션이 로그아웃되는 시점에 같이 종료되는 것입니다. 애플리케이션 실행할 때 터미널을 종료해도 애플리케이션은 계속 구동될 수 있도록 nohup 명령어를 사용합니다. 실행 기본 실행 nohup 명령어를 사용하여 실행합니다. nohup 으로 실행시킬 파일은 반드시 755 퍼미션을 가지고 있어야 합니다. 1$ nohup [실행파일명] 예시입니다. 1$ nohup ./run.sh 실행을 하면 “nohup: ignoring input and appending output to ‘nohup.out’” 메세지와 함께 해당 프로그램의 nohup 을 실행시킨 경로에 nohup.out 파일이 생성되고 표준출력 내용이 출력됩니다. 백그라운드 실행 &amp; 명령어를 맨 끝에 불여서 사용하면 백그라운드로 실행됩니다. 1$ nohup [실행파일명] &amp; 예시입니다. 1$ nohup ./run.sh &amp; 파일 저장 표준출력과 표준에러 같은 파일 저장 2&gt;&amp;1을 추가하면 표준 출력(1)과 표준 에러(2)를 한 파일에 저장됩니다. 1$ nohup [실행파일명] 2&gt;&amp;1 예시입니다. 1$ nohup ./run.sh 2&gt;&amp;1 표준출력과 표준에러 다른 파일 저장 표준 출력(1)은 run_output.out 파일로 저장하고, 표준 에러(2)는 run_output.err 파일로 저장됩니다. 1$ nohup ./run.sh 1 &gt; run_output.out 2 &gt; run_output.err 표준출력 다른 위치에 저장 표준 출력을 nohup.out이 아닌 다른 이름의 파일이나 다른 위치에 저장하려면 다음 명령어를 사용합니다. 1$ nohup [실행파일명] &gt; [파일위치] 예시입니다. 1$ nohup ./run.sh &gt; /data/run_output.out 표준출력 남지기 않도록 표준 출력을 별도로 남기고 싶지 않다면 /dev/null를 추가합니다. 1$ nohup [실행파일명] &gt; /dev/null 예시입니다. 1$ nohup ./run.sh &gt; /dev/null 실행 프로세스 확인 백그라운드 실행의 경우 다음 명령어를 통해 실행 중인 프로세스 상태를 확인할 수 있습니다. 1$ ps -ef | grep run.sh 프로세스 종료 백그라운드로 실행 중인 프로세스를 종료하는 방법입니다. 먼저 프로세스 아이디를 찾고 종료를 합니다. 1$ ps -ef | grep run.sh 프로세스 아이디를 입력하여 종료합니다. 1$ kill -9 [프로세스 아이디] 여기까지 nohup 사용 방법에 대해 알아보았습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"}]},{"title":"[CentOS] Hostname 변경 방법","slug":"linux-16","date":"2022-05-28T01:32:02.000Z","updated":"2024-01-11T15:25:41.575Z","comments":true,"path":"2022/05/28/linux-16/","link":"","permalink":"http://hgko1207.github.io/2022/05/28/linux-16/","excerpt":"","text":"HOSTNAME 등록 각 서버가 어느 서비스 인지 표현하기 위해 HOSTNAME을 변경합니다. 다음 명령어로 편집 파일을 엽니다. 1$ sudo vim /etc/sysconfig/network 편집 화면에서 HOSTNAME 항목을 본인이 원하는 서비스명으로 추가합니다. 123NETWORKING=yesHOSTNAME=hgko-webserviceNOZEROCONF=yes 변경한 후 서버를 재부팅합니다. 1$ sudo reboot 재부팅이 끝나고 나서 ssh 명령어를 사용하여 다시 접속해 보면 HOSTNAME이 잘 변경됐는지 확인할 수 있습니다. 1$ ssh hgko-webservice 다른 HOSTNAME 등록 리눅스 버전에 따라 명령어가 다르기 때문에 위의 내용으로 등록이 안될 시 다음 명령어를 통해 HOSTNAME을 등록합니다. 1$ sudo hostnamectl set-hostname [변경할 호스트명] 1234567$ sudo hostnamectl set-hostname hgko-webservice# 확인hostname# 결과 출력hgko-webservice hosts 추가 호스트 주소를 찾을 때 먼저 검색해 보는 /etc/hosts 에 추가한 hostname을 등록합니다. 다음 명령어로 /etc/hosts 파일을 엽니다. 1$ sudo vim /etc/hosts 편집 화면에서 등록한 HOSTNAME을 추가합니다. 1127.0.0.1 hgko-webservice 저장하고 종료한 뒤 정상적으로 등록되었는지 다음 명령어로 확인합니다. 1$ curl hgko-webservice 잘 등록하였다면 다음과 같이 80 포트로 접근이 안 된다는 에러가 발생합니다. 1curl: (7) Failed to connect to hgko-webservice port 80 after 0 ms: Connection refused 아직 80 포트로 실행된 서비스가 없음을 의미입니다. curl 호스트 이름 명령어로 실행이 잘 되었음을 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"}]},{"title":"[CentOS] 타임존 변경","slug":"linux-15","date":"2022-05-26T23:14:00.000Z","updated":"2024-01-11T15:24:40.642Z","comments":true,"path":"2022/05/27/linux-15/","link":"","permalink":"http://hgko1207.github.io/2022/05/27/linux-15/","excerpt":"","text":"타임존 변경 리눅스 서버 타임존이 UTC인 경우가 있습니다. 이는 세계 표준 시간으로 한국의 시간대가 아닙니다. 한국의 시간과는 9시간 차이가 발생하므로 서버에서 수행되는 애플리케이션에서 생성되는 시간도 모두 9시간씩 차이가 나기 때문에 수정이 필요합니다. 서버의 타임존을 한국 시간(KST)으로 변경하겠습니다. 12$ sudo rm /etc/localtime$ sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime 타임존 확인 date 명령어로 타임존이 KST로 변경된 것을 확인 할 수 있습니다. 1$ date 결과입니다. 1Fri May 27 08:18:19 KST 2022","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"}]},{"title":"[CentOS] Java 8 설치 및 환경변수 설정 방법","slug":"linux-14","date":"2022-05-26T13:06:50.000Z","updated":"2024-01-11T15:23:14.891Z","comments":true,"path":"2022/05/26/linux-14/","link":"","permalink":"http://hgko1207.github.io/2022/05/26/linux-14/","excerpt":"","text":"리눅스 환경에서 Java 8 버전 설치 및 환경변수 설정 방법에 대해 알아보겠습니다. JAVA 설치 yum을 이용해서 설치를 합니다. 1[root@localhost ~]# sudo yum install -y java-1.8.0-openjdk-devel.x86_64 버전 변경 설치가 완료되었으면 Java 버전을 8로 변경합니다. 다음 명령어를 실행하면 선택 화면이 나옵니다. 선택 화면에서 Java8을 선택합니다(1 입력). 1[root@localhost ~]# sudo /usr/sbin/alternatives --config java 확인 현재 버전이 Java8로 되었는지 확인합니다. 12[root@localhost ~]# java -versionopenjdk version \"1.8.0_312\" 12[root@localhost ~]# rpm -qa java*jdk-develjava-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 제거 만약 사용하지 않는 Java 가 설치되었으면 삭제를 합니다. 1[root@localhost ~]# sudo yum remove java-1.7.0-openjdk 환경변수 설정 환경변수 확인 일단 현재 JAVA_HOME 환경변수가 설정 되어 있는지 확인합니다. 123[root@localhost ~]# echo $JAVA_HOME[root@localhost ~]# JAVA_HOME 환경변수가 설정이 안되어 있는 것을 확인했습니다. 설치위치 확인 1234[root@localhost ~]# which javac/usr/bin/javac[root@localhost ~]# readlink -f /usr/bin/javac/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64/bin/javac which javac 명령어는 javac 명령어의 위치를 알려줍니다. /usr/bin/javac 는 심볼릭 링크이므로 원본 파일의 위치를 찾기 위해 readlink -f /usr/bin/javac 명령어를 사용하였습니다. readlink -f 는 심볼릭 링크에서 원본파일을 추출하는 명령어입니다. 설정 환경변수를 설정할 수 있는 profile 파일을 엽니다. 1[root@localhost ~]# vi /etc/profile 해당 파일 하단에 다음의 내용을 추가한 후 저장합니다. 1export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 다음 명령어를 이용하여 수정한 파일을 적용합니다. 1[root@localhost ~]# source /etc/profile 설정 확인 JAVA_HOME 환경변수가 제대로 설정되었는지 확인합니다. 1234[root@localhost ~]# echo $JAVA_HOME/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64[root@localhost ~]# $JAVA_HOME/bin/javac -versionjavac 1.8.0_312","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"}]},{"title":"[MyBatis] 동적 쿼리","slug":"mybatis-2","date":"2021-09-17T12:49:15.000Z","updated":"2024-01-11T15:22:35.739Z","comments":true,"path":"2021/09/17/mybatis-2/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-2/","excerpt":"","text":"검색 조건에 따라 비교하면서 동적 쿼리를 사용하는 방법에 대해 알아보겠습니다. MyBatis와 데이터베이스는 Oracle을 사용하였습니다. 조건문 조건문에는 단일(if), 다중(choose, when, otherwise) 조건문이 있습니다. 1. 단일 조건문 123456789&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 LIKE %'||#&#123;parameter2&#125;||'%' &lt;/if&gt;&lt;/select&gt; 2. 다중 조건문 1234567891011121314&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;choose&gt; &lt;when test=\"parameter2 != null and parameter2 == ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/when&gt; &lt;otherwise&gt; AND column3 = #&#123;parameter3&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 비교 형식 123456789&lt;!-- 문자열 비교 --&gt;&lt;if test=\"parameter != null and (parameter eq 'all'.toString())\"&gt;&lt;/if&gt;&lt;if test=\"!parameter.equals('all')\"&gt;&lt;/if&gt;&lt;!-- 공백 비교 --&gt;&lt;if test=\"parameter == ' '\"&gt;&lt;/if&gt;&lt;!-- 값 비교 --&gt;&lt;if test=\"uesYn == 'Y'\"&gt;&lt;/if&gt; for 문 foreach를 사용하여 조건을 만들 수 있습니다. 12345678&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; column1 IN $&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; where 절 123456789101112&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"parameter1 != null and parameter1 != ''\"&gt; AND column1 = #&#123;parameter1&#125; &lt;/if&gt; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"}]},{"title":"[MyBatis] 페이징 처리","slug":"mybatis-1","date":"2021-09-17T12:44:53.000Z","updated":"2024-01-11T15:21:44.933Z","comments":true,"path":"2021/09/17/mybatis-1/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-1/","excerpt":"","text":"웹 개발 시 페이징 처리는 필수입니다. MyBatis를 사용하여 페이징 처리하는 방법에 대해 알아보겠습니다. 데이터베이스는 Oracle을 사용하였습니다. 1. 기본 페이징 공지사항 조회 시 페이징을 예제로 만들었습니다. Class 생성 공지사항 관련 Class와 페이징을 위한 Class를 생성하였습니다. 12345678910111213141516171819// Notice.java@Datapublic class Notice &#123; /** 작성사용자ID */ private String userId; /** 작성사용자명 */ private String userName; /** 제목 */ private String title; /** 내용 */ private String content; /** 조회수 */ private int hit;&#125; 12345678910// Pagination.java@Datapublic class Pagination &#123; /** 페이지 번호 */ private int pageNo; /** 한 페이지당 데이터 수 */ private int amount;&#125; Mapper 생성 123456// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination);&#125; 쿼리 작성 CDATA 태크는 XML에서 부등호를 사용하기 위함입니다. 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.hgko.test.repository.NoticeMapper\"&gt; &lt;select id=\"getListWithPaging\" resultType=\"Notice\" parameterType=\"Pagination\"&gt; &lt;![CDATA[ SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM TB_NOTICE WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ) WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt; &lt;/select&gt;&lt;/mapper&gt; 테스트 123456789101112131415161718@RunWith(SpringRunner.class)@MybatisTestpublic class NoticeMapperTest &#123; @Autowired private NoticeMapper noticeMapper; @Test public void getListTest() &#123; Pagination pagination = new Pagination(); pagination.setPageNo(1); pagination.SetAmount(10); List&lt;Notice&gt; notices = noticeMapper.getListWithPaging(pagination); System.out.println(notices); &#125;&#125; 2. 조회 조건 추가 위의 기본 페이징 형식에서 조회 조건을 추가하였습니다. 조회 조건 Class 생성 조회 조건 Class 를 생성하고, Pagination Class 를 상속받았습니다. 12345678910// SearchParam.java@Datapublic class SearchParam extends Pagination &#123; /** 작성사용자명 */ private String userName; /** 제목 */ private String title;&#125; Mapper 수정 Mapper Class에 조회 조건으로 조회하는 함수를 추가하였습니다. 123456789// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination); /** 조회조건을 통해 조회 */ public List&lt;Notice&gt; getListWithCondition(SearchParam searchParam);&#125; 조회 쿼리 추가 123456789101112131415161718192021222324252627&lt;!-- NoticeMapper.xml --&gt;&lt;select id=\"getListWithCondition\" resultType=\"Notice\" parameterType=\"SearchParam\"&gt; SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM ( SELECT * FROM TB_NOTICE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"userName != null and userName != ''\"&gt; AND USER_NAME LIKE %'||#&#123;userName&#125;||'%' &lt;/if&gt; &lt;if test=\"title != null and title != ''\"&gt; AND TITLE LIKE %'||#&#123;title&#125;||'%' &lt;/if&gt; &lt;/trim&gt; ) &lt;![CDATA[ WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ]]&gt; ) &lt;![CDATA[ WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt;&lt;/select&gt; MyBatis 와 Oracle DB를 이용하여 페이징 처리를 해봤습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"}]},{"title":"[Vue] 설치와 세팅","slug":"vue-1","date":"2021-08-22T09:46:02.000Z","updated":"2024-01-11T15:17:00.273Z","comments":true,"path":"2021/08/22/vue-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/22/vue-1/","excerpt":"","text":"Vue 쓰는 이유 Web app(Single Page Application) 만들 때 사용합니다. 코드 작성할 때 방법이 정해져 있습니다. React는 방법이 다양한 방면 Vue는 v-for, v-if, v-else 등 방법이 하나로 정해져 있어 개발 초보에게도 쉽습니다. 물론 Vue 도 React처럼 자유도 높은 개발도 가능합니다. HTML 렌더링이 React 보다 빠르다고 합니다.(크게 영향을 주지 않음) 업데이트가 잘 됩니다. 결론은 React 보다 학습 곡선이 낮아 쉽고, 가볍고 빠르며, 누구나 빨리 배울 수 있어 접근성이 뛰어나 많이 쓰이고 있습니다. 설치하기 1. Nodejs 설치 Node.js 공식 다운로드 페이지에서 운영체제에 맞게 다운로드하고 설치합니다. 현재 최신 버전은 14.17.5 입니다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인합니다. 12$ node -vv14.17.5 2. 에디터 설치 VS Code 공식 다운로드 페이지에서 운영체제에 맞는 버전을 설치합니다. 여기서는 Windows 버전을 설치합니다. 이 에디터는 macOS, Window, 리눅스를 모두 지원합니다. VS Code 설치가 완료되었으면 Vue 개발을 효율적으로 하기 위해 Extension을 설치합니다. Vetur html css support Vue 3 Snippets Vue-cli 설치 Vue 개발환경 세팅을 도와주는 프로그램을 설치합니다. 명령어를 실행하고 vue 버전 선택을 하면 설치가 완료됩니다. 1$ npm install -g @vue/cli 프로젝트 생성 프로젝트를 생성할 때는 vue create &lt;프로젝트명&gt; 명령어를 사용합니다. 1$ vue create exapmle-vue 실행 터미널에 npm run serve 명령어를 실행합니다. 실행하여 완료했다면 http://localhost:8080/ 로 접속하여 웹 페이지를 확인합니다. 12$ cd example-vue$ npm run serve 정리 Vue에 대한 설명부터 설치, 프로젝트 실행까지 진행했습니다. 프로젝트를 진행하면서 중요한 부분을 정리할 예정입니다. 참고 https://kr.vuejs.org/v2/guide/index.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"}]},{"title":"[CentOS] 압축 및 해제","slug":"linux-13","date":"2021-08-20T05:17:29.000Z","updated":"2024-01-11T14:50:14.393Z","comments":true,"path":"2021/08/20/linux-13/","link":"","permalink":"http://hgko1207.github.io/2021/08/20/linux-13/","excerpt":"","text":"압축 tar 파일 압축 123tar -cvf [파일명.tar] [압축할 파일 또는 폴더명]예) tar -cvf test.tar test/ tar.gz 파일 압축 123tar -zcvf [파일명.tar.gz] [압축할 파일 또는 폴더명]예) tar -zcvf test.tar.gz test/ 압축 해제 zip 파일 압축 풀기 1234unzip [파일명]unzip [파일명] -d [폴더경로]예) unzip test.zip tar 파일 압축 풀기 123tar -xvf [파일명.tar]예) tar -xvf test.tar tar.gz 파일 압축 풀기 123tar -zxvf [파일명.tar.gz]예) tar -zxvf test.tar.gz tar 압축 옵션 옵션 설명 -c tar로 묶기 -v 묶거나 파일을 풀 때 과정을 화면으로 출력 -f 파일을 묶도록 지정 (반드시 추가되어야 함) -x tar를 풀기 -z gzip(gz)으로 압축 또는 해제 -p 심볼릭 링크 설정 -C 경로를 지정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"}]},{"title":"[Go] 설치 및 기본 사용 방법","slug":"go-1","date":"2021-08-19T00:38:09.000Z","updated":"2024-01-11T14:49:41.917Z","comments":true,"path":"2021/08/19/go-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/19/go-1/","excerpt":"","text":"서론 노마드 코더에서 무료인 쉽고 빠른 Go 시작하기 강의 내용을 코딩하며 정리하였습니다. 시작 https://go.dev/ 페이지에서 Go를 다운로드 합니다. 다운로드 완료 시 설치파일을 실행하여 설치합니다. 그리고 폴더를 다음과 같이 생성합니다. mkdir github.com/hgko1207 cd github.com/hgko1207 mkdir learngo cd learngo go mod init github.com/hgko1207/learngo 코딩 main.go 는 컴파일을 위한 파일 export 함수를 만들 경우 함수명 맨 앞에 대문자로 작성 function -&gt; func null -&gt; nil 상수와 변수 12// Constantsconst name string = \"eden\" 12345678// Variablesfunc main() &#123; var name string = \"eden\" // 변수를 아래와 같이 축약형으로 사용 가능 // 축약형은 함수 안에서만 동작 name := \"eden\"&#125; For 문 1234people := [2]string&#123;\"eden\", \"haeun\"&#125;for _, person := range people &#123; fmt.Println(person);&#125; 함수 1234567891011121314// naked returnfunc lenAndUpper(name string) (length int, uppercase string) &#123; // 'derfer' function이 끝난 후에 실행되는 코드 defer fmt.Println(\"I'm done\") length = len(name) uppercase = strings.ToUpper(name) return&#125;// Go가 내부적으로 호출하는 method를 사용하는 방법func (a Account) String() string &#123; return fmt.Sprint(a.Owner(), \"'s account.\\nHas: \", a.Balance())&#125; 배열 선언 123func main() &#123; data := [2]string&#123;\"test1\", \"test2\"&#125;&#125; Map 사용 12345678// empty map을 초기화하고 싶을때// map 끝에 중괄호(&#123;&#125;)를 작성하여 초기화 해야 함var results = map[string]string&#123;&#125;// 또는 make 사용var results = make(map[string]string)results[\"hello\"] = \"Hello\" Goroutines Goroutines 이란 기본적으로 다른 함수와 동시에 실행시키는 함수입니다. Goroutines는 프로그램이 작동하는 동안(메인함수가 실행하는 동안)만 유효합니다. 123456789101112131415161718// 함수 앞에 go를 붙입니다.func main() &#123; go count() count()&#125;func count() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) time.Sleep(time.Second) &#125;&#125;// 이 경우는 main함수가 바로 종료되기 때문에 동작하지 않습니다.func main() &#123; go count() go count()&#125; Channels Channel 은 Goroutines 이랑 메인함수 사이에 정보를 전달하기 위한 방법입니다. 채널로부터 뭔가를 받을 때 메인 함수가 어떤 결과가 올 때까지 기다립니다. 채널의 타입은 chan 입니다. 채널은 데이터를 받을 순 없고 보낼 수만 있도록 작성할 수 있습니다.(send-only) 12345678910111213141516func main() &#123; c := make(chan bool) go channelTest(c) result := &lt;- c fmt.Println(result)&#125;func channelTest(c chan bool) &#123; time.Sleep(time.Second * 5) c &lt;- true&#125;// send-onlyfunc sendOnlyTest(c chan&lt;- bool) &#123; c &lt;- true&#125; Error errors.New()를 사용하여 에러를 정의하고 호출합니다. 123456789var err = errors.New(\"error content\")func main() &#123; fmt.PrintLn(errTest())&#125;func errTest() error &#123; return err&#125; goquery HTML을 navigate하고 필요한 걸 HTML에서 찾아내기 위해서 사용 JQuery와 유사한 go를 위한 라이브러리입니다. https://github.com/PuerkitoBio/goquery 1$ go get github.com/PuerkitoBio/goquery 참고 go lang std library https://golang.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"}]},{"title":"[CentOS] yum을 이용한 rpm 패키지 다운로드","slug":"linux-12","date":"2021-07-23T08:50:03.000Z","updated":"2023-03-14T02:22:58.983Z","comments":true,"path":"2021/07/23/linux-12/","link":"","permalink":"http://hgko1207.github.io/2021/07/23/linux-12/","excerpt":"","text":"yum-downloadonly 패키지 이용 yum-downloadonly 패키지를 설치합니다. 1$ yum install yum-downloadonly 1$ yum install [패키지명] -y --downloadonly --downloaddir=[다운로드 경로] 사용 예제입니다. 1$ yum install dotnet-sdk-5.0 -y --downloadonly --downloaddir=/home/rpm/download yumdownloader 이용 yumdownloader 명령어가 있는 yum-utils 패키지를 설치합니다. 1$ yum install yum-utils 1$ yumdownloader --downloadonly --resolve --destdir=[다운로드 경로] [패키지명] 사용 예제입니다. 1$ yumdownloader --downloadonly --resolve --destdir=/home/rpm/download dotnet-sdk-5.0 패키지 의존성 정보 확인 12$ yum deplist [패키지명]$ yum deplist dotnet-sdk-5.0 패키지 설치 1$ rpm -ivh [패키지 파일명] 패키지 삭제 설치된 패키지를 삭제합니다. 패키지명만 입력합니다. 1$ rpm -e [패키지명] 패키지 설치 여부 1$ rpm -q [패키지명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"}]},{"title":"Chocolatey 설치","slug":"chocolatey","date":"2021-07-21T10:21:51.000Z","updated":"2024-01-11T14:47:33.391Z","comments":true,"path":"2021/07/21/chocolatey/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/chocolatey/","excerpt":"","text":"윈도우(Windows)를 사용하면서 개발 환경을 쉽게 꾸릴 수 있는 Chocolatey(윈도우용 패키지 매니저) 설치와 사용 방법에 대해 알아보겠습니다. 설치 공식 Install 홈페이지를 따라 설치를 진행합니다. 윈도우 7 이상, 윈도우 서버 2003 이상에서 설치가 가능하고, PowerShell에서 명령어로 설치할 수 있습니다. PowerShell 사용 관리자 권한으로 실행해야 합니다. 그렇지 않으면 에러 메세지를 보여줍니다. 다음 설치 명령어를 복사하여 실행하면 설치가 진행됩니다. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 설치가 완료되었다면 choco 명령어를 실행하였을 때 다음과 같이 버전 정보가 나옵니다. 1234C:\\Windows\\system32&gt; chocoChocolatey v0.10.15Please run 'choco -?' or 'choco &lt;command&gt; -?' for help menu.C:\\Windows\\system32&gt; 패키지 설치 패키지 리스트 에서 설치 가능한 패키지들을 확인할 수 있습니다. 구글 크롬을 예제로 설치해보겠습니다. 검색 창에 google chrome 을 검색하면 결과가 나오고 오른쪽에 설치 명령어가 보입니다. 명령어를 복사하고 PowerShell에 입력하면 설치가 진행됩니다. 1&gt; choco install googlechrome 설치가 완료되었으면 다음 명령어를 실행하여 설치된 패키지들을 확인합니다. 1&gt; choco search googlechrome Ubuntu 의 apt-get와 CentOS rpm 명령어처럼 윈도우에서도 설치 명령어를 통해 필요한 프로그램을 쉽게 설치할 수 있습니다. 추천 패키지들 Windows Terminal vscode python3 git postman jdk8 Adobe Acrobat Reader Notepad++ Node JS PowerToys WSL(Windows Subsystem for Linux)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"}]},{"title":"알아두면 손해 안보는 사이트","slug":"util-1","date":"2021-07-21T02:59:01.000Z","updated":"2022-09-26T12:04:47.996Z","comments":true,"path":"2021/07/21/util-1/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/util-1/","excerpt":"","text":"개발 자바스크립트 https://beautifier.io/ 온라인 JSON Parser http://json.parser.online.fr/ 변수명 짓기 https://www.curioustore.com/#!/ 웹 템플릿 https://semantic-ui.com/ https://themeforest.net/ 마크다운 툴 https://stackedit.io/app# CSS Gradient Generator https://www.colorzilla.com/gradient-editor/ 디자인 컬러 팔레트 https://flatuicolors.com/ 무료 아이콘 모음 https://icons8.com/ https://www.flaticon.com/ 아이콘 변환 https://flat-icon.surge.sh/# 사진 모음 https://unsplash.com/ ETC. 파일 포맷 정보 https://eknote.tistory.com/89 좌표계 변환 http://www.synnatschke.de/geo-tools/coordinate-converter.php Convert Lat Long to UTM https://www.latlong.net/lat-long-utm.html 사진 용량 줄이기 https://tinypng.com/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"}]},{"title":"[JPA] Select Query 사용 방법","slug":"spring-jpa-1","date":"2021-06-19T13:27:35.000Z","updated":"2024-01-11T14:45:34.026Z","comments":true,"path":"2021/06/19/spring-jpa-1/","link":"","permalink":"http://hgko1207.github.io/2021/06/19/spring-jpa-1/","excerpt":"","text":"SpringData JPA를 사용하여 웹 프로젝트를 진행하면서 Select Query를 작성 시 잊어버리게 되어 검색을 하게 되는데 자주 사용하는 내용들을 정리하였습니다. JpaRepository를 상속받아 사용하는 기본 Query와 @Query 주석을 사용하여 JPQL 및 네이티브 SQL 쿼리를 실행하는 방법에 대해 알아보겠습니다. Entity 먼저 데이터베이스에 저장하기 위해 tb_user 테이블 이름의 Entity 클래스를 작성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) protected long id; /** 사용자ID */ @Column(nullable = false, length = 45) private String userId; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 이메일 */ @Column(length = 45) private String email; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Entity 클래스를 작성했다면 이번엔 Repository 인터페이스를 만들어야 합니다. Entity의 기본적인 CRUD가 가능하도록 JpaRepository 인터페이스를 제공합니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 기본 Query Spring Data JPA에서 기본적으로 제공하는 Query는 규칙에 맞게 작성해야 합니다. Method 설명 findBy… 쿼리를 요청 countBy… 쿼리 결과 행 수를 요청 orderBy… 쿼리 결과를 정렬 existsBy… 해당 조건의 항목이 존재하는지 확인 그리고 Query 메소드에 포함할 수 있는 키워드가 있습니다. 아래 참고 사이트에 자세하게 더 다양하게 정리가 되어있습니다. Keyword 설명 And 여러 컬럼을 and 로 쿼리 Or 여러 컬럼을 or 로 쿼리 Containing like 쿼리 Like like 쿼리 Between 컬럼의 두 값 사이에 있는 항목 쿼리 OrderBy 쿼리 결과를 정렬 In 여러 값 중에 하나인 항목 쿼리 Exists 해당 조건의 항목이 존재하는지 확인 아래는 예제 코드입니다. 12345678910111213User findByUserId(String userId);User findByUserIdAndPassword(String userId, String password);List&lt;User&gt; OrderByName();List&lt;User&gt; OrderByCreateDateDesc();List&lt;User&gt; findByRoleOrderByCreateDateDesc(Role role);List&lt;User&gt; findByNameContaining(String name);List&lt;User&gt; findByCreateDateBetween(LocalDateTime startDate, LocalDateTime endDate);boolean existsByUserId(String userId);int countByRole(Role role); JPQL(Java Persistence Query Language) JPQL은 SQL과 비슷한 문법을 가진 객체 지향 쿼리입니다. JPQL과 Native SQL 동일하게 @Query 어노테이션을 사용하여 쿼리를 작성하고, 또한 두 가지 방법으로 쿼리에 메소드의 매개변수 값을 전달할 수 있습니다. @Param 어노테이션을 사용하여 이름으로 정의 된 매개변수를 쿼리에 전달합니다. 메소드의 매개변수 순서로 쿼리에 전달합니다.(1부터 시작) 1234567891011121314@Query(value = \"SELECT u FROM User u WHERE u.role = 'GUEST'\")List&lt;User&gt; findByRole();@Query(\"SELECT u FROM User u WHERE u.userId = :userId\")User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT u FROM User u WHERE u.userId = :userId and u.password = :password\")User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT u FROM User u WHERE u.userId = ?1\")User findByUserId(String userId);@Query(\"SELECT u FROM User u WHERE u.userId = ?1 and u.password = ?2\")User findByUserIdAndPassword(String userId, String password); Native SQL 네이티브 SQL을 사용하여 쿼리를 정의할 수 있습니다. 네이티브 SQL을 사용하려면 nativeQuery 속성의 값을 true 로 설정합니다. 1234567891011121314@Query(value = \"SELECT * FROM tb_user u WHERE u.role = 'GUEST'\", nativeQuery = true)List&lt;User&gt; findByRole();@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId\", nativeQuery = true)User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId and u.password = :password\", nativeQuery = true)User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1\", nativeQuery = true)User findByUserId(String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1 and u.password = ?2\", nativeQuery = true)User findByUserIdAndPassword(String userId, String password); 참고 Spring Data JPA @Query https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"}]},{"title":"[JavaScript] 모달에서 이미지 및 동영상 출력","slug":"js-dev-4","date":"2021-06-16T13:25:20.000Z","updated":"2024-01-11T14:44:22.810Z","comments":true,"path":"2021/06/16/js-dev-4/","link":"","permalink":"http://hgko1207.github.io/2021/06/16/js-dev-4/","excerpt":"","text":"서론 [사진 보기], [동영상 보기] 버튼을 클릭 시 모달창이 띄워지면서 사진 또는 동영상이 출력되도록 하는 예제입니다. 사진과 동영상 파일을 images 경로에 저장하여 출력하였고, 실제 구동되는 프로젝트에서는 웹 서버가 실행되는 곳의 특정 경로에 저장하여 URL을 불러와서 출력합니다. html 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openImageModal()\"&gt;사진 보기&lt;/button&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openVideoModal()\"&gt;동영상 보기&lt;/button&gt; &lt;!-- 모달창 --&gt; &lt;div id=\"fileModal\" class=\"modal fade\" role=\"dialog\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header modal-header-sm\"&gt; &lt;h6 class=\"modal-title\"&gt;사진/동영상 보기&lt;/h6&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&amp;times;&lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body text-center\"&gt; &lt;div id=\"file-viewer\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; javascript JQuery를 이용하여 모달창을 생성합니다. 1234567891011121314151617181920212223242526272829// 이미지 출력 모달창 오픈function openImageModal() &#123; $('#file-viewer').empty(); let img = document.createElement('img'); img.setAttribute('src', 'images/image.jpg'); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); $('#fileModal').modal();&#125;// 동영상 출력 모달창 오픈function openVideoModal() &#123; $('#file-viewer').empty(); var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); // video 태그 사용 var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); ideo.setAttribute('src', 'images/video.mp4'); div.append(video); $('#file-viewer').append(div); $('#fileModal').modal();&#125; 응용 서버에서 파일를 조회하여 출력하도록 하는 예제입니다. 12345678910111213141516171819202122232425262728const contextPath = '$&#123;pageContext.request.contextPath&#125;';$.ajax(&#123; url: contextPath + '/file/get', type: 'GET', success: function (file) &#123; if (file.fileType == 'IMAGE') &#123; var img = document.createElement('img'); img.setAttribute('src', contextPath + '/uploads/' + file.fileName); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); &#125; else if (file.fileType == 'VIDEO') &#123; var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); video.setAttribute('src', contextPath + '/uploads/' + file.fileName); div.append(video); $('#file-viewer').append(div); &#125; $('#fileModal').modal(); &#125;,&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"}]},{"title":"[WPF] Slider Custom Style","slug":"wpf-3","date":"2021-06-04T13:50:55.000Z","updated":"2024-01-11T14:44:03.696Z","comments":true,"path":"2021/06/04/wpf-3/","link":"","permalink":"http://hgko1207.github.io/2021/06/04/wpf-3/","excerpt":"","text":"WPF 기본 Slider Stlye에서 Thumb을 드래그할 때마다 박스 안에 숫자가 표시되도록 Style 을 하였습니다. Slider 모양 Style 추가 App.xaml 에 추가하거나 Resource.xaml 파일을 생성하여 Style 을 추가합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;SolidColorBrush x:Key=\"CustomSliderBackgroundSolidColorBrush\" Color=\"#1E211B\" /&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderForegroundBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#9B5B2B\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderThumBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#454543\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;Style x:Key=\"CustomSliderThumbStyle\" TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Setter Property=\"Focusable\" Value=\"false\"/&gt; &lt;Setter Property=\"SnapsToDevicePixels\" Value=\"true\"/&gt; &lt;Setter Property=\"OverridesDefaultStyle\" Value=\"true\"/&gt; &lt;Setter Property=\"Height\" Value=\"20\"/&gt; &lt;Setter Property=\"Width\" Value=\"30\"/&gt; &lt;Setter Property=\"Cursor\" Value=\"Hand\"/&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Canvas SnapsToDevicePixels=\"true\"&gt; &lt;Grid Height=\"20\" Width=\"30\"&gt; &lt;Rectangle x:Name=\"Background\" Fill=\"&#123;StaticResource CustomSliderThumBrush&#125;\" Stroke=\"#FFDADADA\" Height=\"20\" Width=\"30\" RadiusX=\"3\" RadiusY=\"3\"/&gt; &lt;TextBlock HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"White\" FontSize=\"10\" Text=\"&#123;Binding Value, RelativeSource=&#123;RelativeSource AncestorType=&#123;x:Type Slider&#125;&#125;&#125;\"/&gt; &lt;/Grid&gt; &lt;/Canvas&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property=\"IsMouseOver\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Orange\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsDragging\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"&#123;StaticResource CustomSliderThumBrush&#125;\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsEnabled\" Value=\"false\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Gray\"/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt;&lt;/Style&gt;&lt;ControlTemplate x:Key=\"CustomSliderControlTemplate\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Border Background=\"Transparent\" SnapsToDevicePixels=\"True\"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=\"&#123;TemplateBinding MinHeight&#125;\" /&gt; &lt;/Grid.RowDefinitions&gt; &lt;DockPanel LastChildFill=\"True\"&gt; &lt;Border x:Name=\"PART_SelectionRange\" Height=\"5\" ClipToBounds=\"True\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 -10 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderForegroundBrush&#125;\" /&gt; &lt;/Border&gt; &lt;Border ClipToBounds=\"True\" Height=\"5\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 0 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderBackgroundSolidColorBrush&#125;\" /&gt; &lt;/Border&gt; &lt;/DockPanel&gt; &lt;Track x:Name=\"PART_Track\"&gt; &lt;Track.Thumb&gt; &lt;Thumb Style=\"&#123;StaticResource CustomSliderThumbStyle&#125;\" VerticalAlignment=\"Center\" Width=\"&#123;TemplateBinding MinWidth&#125;\" Height=\"&#123;TemplateBinding MinHeight&#125;\" OverridesDefaultStyle=\"True\" Focusable=\"False\" /&gt; &lt;/Track.Thumb&gt; &lt;/Track&gt; &lt;/Grid&gt; &lt;/Border&gt;&lt;/ControlTemplate&gt;&lt;Style x:Key=\"CustomSliderStyle\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Setter Property=\"Template\" Value=\"&#123;StaticResource CustomSliderControlTemplate&#125;\" /&gt; &lt;Setter Property=\"VerticalAlignment\" Value=\"Center\" /&gt; &lt;Setter Property=\"MinWidth\" Value=\"30\" /&gt; &lt;Setter Property=\"MinHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"Height\" Value=\"20\" /&gt; &lt;Setter Property=\"MaxHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"BorderBrush\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"AutoToolTipPlacement\" Value=\"None\" /&gt; &lt;Setter Property=\"IsMoveToPointEnabled\" Value=\"True\" /&gt; &lt;Setter Property=\"SelectionStart\" Value=\"0\" /&gt; &lt;Setter Property=\"SelectionEnd\" Value=\"&#123;Binding Path=Value, RelativeSource=&#123;RelativeSource Self&#125;&#125;\" /&gt; &lt;Setter Property=\"Stylus.IsPressAndHoldEnabled\" Value=\"false\" /&gt;&lt;/Style&gt; Slider Style 적용 다음과 같이 Slider 에 Style을 지정합니다. 1&lt;Slider Minimum=\"1\" Maximum=\"255\" IsSnapToTickEnabled=\"True\" Style=\"&#123;StaticResource CustomSliderStyle&#125;\"/&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"}]},{"title":"[WPF] Prism ViewModelBase 정의","slug":"wpf-2","date":"2021-05-27T05:50:42.000Z","updated":"2024-01-11T14:43:41.706Z","comments":true,"path":"2021/05/27/wpf-2/","link":"","permalink":"http://hgko1207.github.io/2021/05/27/wpf-2/","excerpt":"","text":"WPF에서 Prism을 사용하여 ViewModel을 구현할 때 필요에 따라 Container, EventAggregator, RegionManager, Logger 등의 서비스를 사용합니다. 서비스를 각각 ViewModel 에 정의해서 사용하는 것이 아닌 공통으로 작성하여 편리하게 사용할 수 있는 추상 클래스를 작성하였습니다. ViewModelBase Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using Prism.Events;using Prism.Logging;using Prism.Ioc;using Prism.Mvvm;using Unity;namespace Prism.Project.Common.Mvvm&#123; public abstract class ViewModelBase : BindableBase &#123; private string title; public string Title &#123; get =&gt; title; set =&gt; SetProperty(ref title, value); &#125; protected IUnityContainer Container &#123; get; &#125; private IEventAggregator eventAggregator; /// &lt;summary&gt; /// The EventAggregator /// &lt;/summary&gt; public IEventAggregator EventAggregator &#123; get &#123; return eventAggregator; &#125; private set &#123; this.SetProperty&lt;IEventAggregator&gt;(ref this.eventAggregator, value); &#125; &#125; private IRegionManager regionManager; /// &lt;summary&gt; /// The region manager /// &lt;/summary&gt; public IRegionManager RegionManager &#123; get &#123; return regionManager; &#125; private set &#123; this.SetProperty&lt;IRegionManager&gt;(ref this.regionManager, value); &#125; &#125; protected ILoggerFacade Logger &#123; get; &#125; protected ViewModelBase(IUnityContainer container) &#123; Container = container; RegionManager = container.Resolve&lt;IRegionManager&gt;(); EventAggregator = container.Resolve&lt;IEventAggregator&gt;(); Logger = container.Resolve&lt;ILoggerFacade&gt;(); &#125; &#125;&#125; 사용 코드 ViewModelBase 클래스를 상속받고 생성자에 container 를 정의합니다. 1234567891011121314151617181920212223242526using Prism.Project.Common.Mvvm;using Unity;using Prism.Events;namespace Prism.Project.ViewModels&#123; public class MainWindowViewModel : ViewModelBase &#123; public MainWindowViewModel(IUnityContainer container) : base(container) &#123; Title = \"Prism 테스트\"; Logger.Log(\"[MainWindowViewModel Created]\", Category.Debug, Priority.None); // Event 예제 코드 EventAggregator.GetEvent&lt;MainWindowClosedEvent&gt;().Subscribe(MainWindowClosed); &#125; /// &lt;summary&gt; /// MainWindow 화면 종료 시 /// &lt;/summary&gt; private void MainWindowClosed() &#123; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[JQuery] Select Box 제어","slug":"js-dev-3","date":"2021-05-21T02:47:06.000Z","updated":"2024-01-11T14:42:25.760Z","comments":true,"path":"2021/05/21/js-dev-3/","link":"","permalink":"http://hgko1207.github.io/2021/05/21/js-dev-3/","excerpt":"","text":"JQuery를 이용해서 select를 제어하는 방법에 대해 알아보겠습니다. 1&lt;select class=\"form-control\" name=\"name\" id=\"nameSelect\"&gt;&lt;/select&gt; 선택된 옵션 값 읽기 12$('#nameSelect option:selected').val();$('select[name=name]').val(); 선택된 옵션 이름 읽기 1$('#nameSelect option:selected').text(); 옵션 추가하기 123456$('#nameSelect').append( $('&lt;option&gt;', &#123; value: 1, text: '테스트', &#125;)); 값이 변경되었을 때 1234$('#nameSelect').change(function () &#123; const name = $(this).val(); console.log(name);&#125;); 특정한 값 선택하기 1$('#nameSelect').val(1).trigger('change'); 옵션 삭제 12345678// 지정한 인덱스의 옵션 삭제$('#nameSelect option:eq(0)').remove();// 첫 번째 옵션 삭제$('#nameSelect option:first').remove();// 마지막 옵션 삭제$('#nameSelect option:first').remove(); Select Box 비우기 1$('#nameSelect').empty();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"}]},{"title":"[Android] Yahoo Weather API를 이용하여 날씨정보 조회","slug":"android-dev-1","date":"2021-05-12T07:58:49.000Z","updated":"2024-01-11T14:42:02.757Z","comments":true,"path":"2021/05/12/android-dev-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/12/android-dev-1/","excerpt":"","text":"Yahoo Weather API를 이용하여 현재 위치의 날씨 정보를 조회하는 방법에 대해 알아보겠습니다. 개발 환경 Android Studio Java 설정 build.gradle -&gt; dependencies 추가 1implementation 'zh.wang.android:yweathergetter4a:1.3.0' manifest -&gt; permission 추가 1234567&lt;!-- 인터넷 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;!-- GPS 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 코드 작성 Activity 또는 Fragment에 YahooWeatherInfoListener 인터페이스를 implements 하면 gotWeatherInfo 함수를 오버라이딩(Override)을 하게 됩니다. 123456789101112public class WeatherActivity extends Activity implements YahooWeatherInfoListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; &#125;&#125; 이제 날씨 정보를 불러오기 위해 다음의 함수 중 상황에 맞게 호출합니다. 12345678// 장소 이름으로 쿼리public void queryYahooWeatherByPlaceName(final Context context, final String cityAreaOrLocation, final YahooWeatherInfoListener result)// 위도와 경도로 쿼리public void queryYahooWeatherByLatLon(final Context context, final String lat, final String lon, final YahooWeatherInfoListener result)// GPS를 사용하여 현재 위치로 쿼리public void queryYahooWeatherByGPS(final Context context, final YahooWeatherInfoListener result) 이번 프로젝트에는 GPS를 사용하여 현재 위치의 날씨 정보를 얻었습니다. 쿼리 함수를 호출하면 오버라이딩한 gotWeatherInfo 함수를 통해 날씨 정보를 얻을 수 있습니다. 123456YahooWeather yahooWeather = YahooWeather.getInstance();yahooWeather.setNeedDownloadIcons(true);yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS);yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS);yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); 날씨 정보를 한 번만 불러오는 것이 아니라 1분마다 얻기 위해 Timer를 사용하였습니다. Timer를 사용하기 위해 위의 코드를 함수로 만들었습니다. 12345678910111213141516171819Timer timer = new Timer();timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125;&#125;, 0, 1000 * 60);public void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this);&#125; 이제 1분 마다 날씨 정보를 불러올 수 있게 되었습니다. 현재 위치, 시간, 온도, 습도, 대기압, 풍향, 풍속 등의 다양한 날씨 정보를 화면에 표출하여 완성하였습니다. 1234567891011121314151617@Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; 전체 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// WeatherActivity.javaimport android.os.Handler;import android.os.Looper;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import butterknife.BindView;import butterknife.ButterKnife;import me.hgko.networkinfo.R;import zh.wang.android.yweathergetter4a.WeatherInfo;import zh.wang.android.yweathergetter4a.YahooWeather;import zh.wang.android.yweathergetter4a.YahooWeatherInfoListener;public class WeatherActivity extends AppCompatActivity implements YahooWeatherInfoListener &#123; private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss\"); @BindView(R.id.logitudeText) TextView logitudeText; @BindView(R.id.latitudeText) TextView latitudeText; @BindView(R.id.datetimeText) TextView datetimeText; @BindView(R.id.addressText) TextView addressText; @BindView(R.id.weatherText) TextView weatherText; @BindView(R.id.temperatureText) TextView temperatureText; @BindView(R.id.humidityText) TextView humidityText; @BindView(R.id.pressureText) TextView pressureText; @BindView(R.id.windDirectionText) TextView windDirectionText; @BindView(R.id.windSpeedText) TextView windSpeedText; @BindView(R.id.windChillText) TextView windChillText; @BindView(R.id.visibilityText) TextView visibilityText; private YahooWeather yahooWeather; private Timer timer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); ButterKnife.bind(this); yahooWeather = YahooWeather.getInstance(); timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125; &#125;, 0, 1000 * 60 * 10); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; private void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!-- activity_weather.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"20dp\" android:paddingLeft=\"20dp\" android:paddingRight=\"20dp\" android:paddingTop=\"20dp\" tools:context=\".activity.WeatherActivity\"&gt; &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Datetime :\" /&gt; &lt;TextView android:id=\"@+id/datetimeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Logitude :\" /&gt; &lt;TextView android:id=\"@+id/logitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Latitude :\" /&gt; &lt;TextView android:id=\"@+id/latitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Address :\" /&gt; &lt;TextView android:id=\"@+id/addressText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Weather :\" /&gt; &lt;TextView android:id=\"@+id/weatherText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Temperature :\" /&gt; &lt;TextView android:id=\"@+id/temperatureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Chill :\" /&gt; &lt;TextView android:id=\"@+id/windChillText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Direction :\" /&gt; &lt;TextView android:id=\"@+id/windDirectionText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Speed :\" /&gt; &lt;TextView android:id=\"@+id/windSpeedText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Humidity :\" /&gt; &lt;TextView android:id=\"@+id/humidityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Pressure :\" /&gt; &lt;TextView android:id=\"@+id/pressureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Visibility :\" /&gt; &lt;TextView android:id=\"@+id/visibilityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; TextView 에 공통으로 스타일을 지정하기 위해 styles.xml 에 추가합니다. 123456789101112131415&lt;style name=\"TextStyle1\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;1&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt;&lt;style name=\"TextStyle2\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;2&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt; 실행 결과 앱을 실행하면 아래 이미지와 같이 현재 위치의 날씨 정보를 확인할 수 있습니다. 참고 https://github.com/zh-wang/YWeatherGetter4a","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"}]},{"title":"[MATLAB] MinGW-W64 수동 설치","slug":"matlab-1","date":"2021-05-06T07:41:52.000Z","updated":"2024-01-11T14:41:22.480Z","comments":true,"path":"2021/05/06/matlab-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/06/matlab-1/","excerpt":"","text":"MATLAB에서 개발하고 MATLAB Coder를 사용하여 C 또는 C++ 코드로 변환하려고 하였다. 그런데 MEX 컴파일러를 확인할 수 없다는 에러가 났습니다. MATLAB 에서 mex -setup 명령어를 실행했더니 다음과 같이 MinGW-w64 C/C++ 컴파일러를 설치해야 한다는 내용이 나왔습니다. 1234&gt;&gt; mex -setup다음 사용 중 오류가 발생함: mex사용할 수 있는 컴파일러 또는 SDK를 찾을 수 없습니다. 무료로 제공되는 MinGW-w64 C/C++ 컴파일러를 설치할 수 있습니다. MinGW-w64 컴파일러 설치를 참조하십시오. 더 많은 옵션을보려면 http://www.mathworks.com/support/compilers/R2016a/win64.html을 참조하십시오. 구글 검색했을 때 홈 탭 &gt; 환경 섹션 &gt; 애드온 을 이용하여 설치할 수 있다고 하였는데 지금 사용하고 있는 MATLAB 2016a 버전 같은 경우에는 설치를 지원하지 않는 것인지 자동으로 설치를 할 수가 없었습니다. 그래서 직접 설치 파일을 다운로드하여 설치를 진행하였습니다. 수동 설치 https://jmeubank.github.io/tdm-gcc/download/ 페이지에서 현재 최신 버전인 tdm64-gcc-9.2.0.exe 설치 파일 다운로드(윈도우 운영체제에 맞게 다운로드) 위 그림처럼 체크를 해제한 후 Create 버튼을 클릭 설치 경로는 공백이 없는 C:\\TDM-GCC-64 경로로 지정하여 설치 환경 변수가 자동으로 등록되며 설치 완료 환경 설정 및 setup MATLAB 으로 돌아와서 setenv 명령어를 통해 설치된 경로에 대해 환경 설정을 하고 mex -setup 명령어를 실행하면 이제 MinGW64 Compiler를 사용할 수 있습니다. 123456789101112&gt;&gt; setenv ( 'MW_MINGW64_LOC', 'C:\\TDM-GCC-64' )&gt;&gt; mex -setupMEX이(가) C 언어 컴파일에 'MinGW64 Compiler (C)'을(를) 사용하도록 구성되었습니다.경고: 2^32-1개의 요소를 초과하는 MATLAB 변수를 지원하기 위해 MATLAB C와 Fortran API가 변경되었습니다. 새 API를 활용하기 위해서는 가까운 시일 내에 코드를 업데이트해야 할 수 있습니다. 자세한 내용은 http://www.mathworks.com/help/matlab/matlab_external/upgrading-mex-files-to-use-64-bit-api.html에서 확인할 수 있습니다.다른 언어를 선택하려면 다음 중 하나를 선택하십시오. mex -setup C++ mex -setup FORTRAN MinGW64 Compiler (C++) 을 사용하도록 구성할 시 다음 명령어를 실행합니다. 1&gt;&gt; mex -setup C++ 결과 MATLAB Coder를 이용한 Code 변환도 성공적으로 완료되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"}]},{"title":"[C++] 평균, 표준편차 구하기","slug":"cpp-coding-4","date":"2021-04-28T00:49:09.000Z","updated":"2023-03-14T02:22:32.765Z","comments":true,"path":"2021/04/28/cpp-coding-4/","link":"","permalink":"http://hgko1207.github.io/2021/04/28/cpp-coding-4/","excerpt":"","text":"평균 및 표준편차 계산 함수 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;// 평균 계산 함수template&lt;class T&gt;double Mean(std::vector&lt;T&gt; array)&#123; double sum = 0.0; for (int i = 0; i &lt; array.size(); i++) sum += array[i]; return sum / array.size();&#125;// 표준 편차 계산 함수template&lt;class T&gt;double StandardDeviation(std::vector&lt;T&gt; array)&#123; double meanValue = Mean&lt;T&gt;(array); // 배열 요소가 1개밖에 없을 때는 // NaN(숫자가 아님)이라는 의미로 // sqrt(-1.0) 을 반환 int size = array.size(); if (size &lt; 2) &#123; return sqrt(-1.0); &#125; double sum = 0.0; for (int i = 0; i &lt; size; i++) &#123; double diff = array[i] - meanValue; sum += diff * diff; &#125; return sqrt(sum / (size - 1));&#125; 테스트 123456789101112131415161718int main()&#123; std::vector&lt;int&gt; array; array.push_back(5); array.push_back(2); array.push_back(7); array.push_back(8); array.push_back(4); array.push_back(1); array.push_back(10); array.push_back(9); double meanValue = Mean&lt;int&gt;(array); double stddevValue = StandardDeviation&lt;int&gt;(array); std::cout &lt;&lt; \"meanValue : \" &lt;&lt; meanValue &lt;&lt; std::endl; std::cout &lt;&lt; \"stddevValue : \" &lt;&lt; stddevValue &lt;&lt; std::endl;&#125; 결과 12meanValue : 5.75stddevValue : 3.28416","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"}]},{"title":"[JAVA] 날짜 비교","slug":"java-dev-7","date":"2021-04-26T01:18:29.000Z","updated":"2024-01-11T14:40:35.864Z","comments":true,"path":"2021/04/26/java-dev-7/","link":"","permalink":"http://hgko1207.github.io/2021/04/26/java-dev-7/","excerpt":"","text":"SimpleDateFormat을 이용한 날짜 비교하는 방법에 대해 알아보겠습니다. 소스코드 12345678910111213141516171819202122232425262728293031import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatExample &#123; public static long getDayCount( String start, String end ) &#123; SimpleDateFormat format = new SimpleDateFormat( \"yyyy-M-d\" ); long diff = -1; try &#123; Date dateStart = format.parse( start ); Date dateEnd = format.parse( end ); // time is always 00:00:00 so rounding should help to ignore the // missing hour when going from winter to summer time as well as the // extra hour in the other direction diff = Math.round( ( dateEnd.getTime() - dateStart.getTime() ) / (double)( 60 * 60 * 24 * 1000 ) ); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; return diff; &#125; public static void main( String[] args ) &#123; long diff = getDayCount( \"2021-1-1\", \"2021-4-26\" ); System.out.println( \"결과 : \" + diff + \" 일\" ); &#125;&#125; 결과 1결과 : 115 일","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"}]},{"title":"[C++] Is the Point Inside the Polygon?","slug":"cpp-coding-3","date":"2021-04-13T04:58:06.000Z","updated":"2023-03-14T02:22:27.678Z","comments":true,"path":"2021/04/13/cpp-coding-3/","link":"","permalink":"http://hgko1207.github.io/2021/04/13/cpp-coding-3/","excerpt":"","text":"point-in-polygon (PIP) “In computational geometry, the point-in-polygon (PIP) problem asks whether a given point in the plane lies inside, outside, or on the boundary of a polygon.” Wikipedia. 점이 다각형(Polygon) 내부에 있는지 확인하는 코드입니다. 123456789101112131415161718192021struct Point&#123; int x; int y;&#125;;bool InsidePolygon(int nvert, Point polygon[], int pointx, int pointy)&#123; int i, j = 0; bool inside = false; for (i = 0, j = nvert - 1; i &lt; nvert; j = i++) &#123; if (((polygon[i].y &gt; pointy) != (polygon[j].y &gt; pointy)) &amp;&amp; (pointx &lt; (polygon[j].x - polygon[i].x) * (pointy - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) &#123; inside = !inside; &#125; &#125; return inside;&#125; 인수 nvert : 다각형의 정점 수 polygon[] : 다각형을 형성하는 점의 배열 pointx : 점의 X 좌표 pointy : 점의 Y 좌표 테스트 12345678910111213int main()&#123; Point polygon[] = &#123;&#123;0, 0&#125;, &#123;50, 0&#125;, &#123;50, 50&#125;, &#123;0, 50&#125;&#125;; int n = sizeof(polygon) / sizeof(polygon[0]); bool result = InsidePolygon(n, polygon, 0, 5); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; result = InsidePolygon(n, polygon, 60, 20); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; return 0;&#125; 결과 12YESNO","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[Oracle] Spatial Data Query","slug":"oracle-2","date":"2021-03-18T00:39:31.000Z","updated":"2023-03-14T02:22:25.175Z","comments":true,"path":"2021/03/18/oracle-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/18/oracle-2/","excerpt":"","text":"Table 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); INSERT SDO_GEOMETRY 컬럼에 넣을 데이터는 타입마다 형식이 다릅니다. Point(점) 타입 1234567SDO_GEOMETRY( 2001, 4326, SDO_POINT_TYPE(126.64,36.86, NULL), NULL, NULL ) Rectangle(직사각형) 타입 12345678SDO_GEOMETRY( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), -- 1개의 사각형 SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88) -- 사각형을 정의하기 위해 오직 2개의 포인트 필요(lower left and upper right)) Polygon 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1), -- 1개의 폴리곤 SDO_ORDINATE_ARRAY(126.63,36.88, 126.64,36.88, 126.64,36.84, 126.63,36.84, 126.63,36.88) ) Circle(원) 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,4), -- 1개의 원 SDO_ORDINATE_ARRAY(8,7, 10,9, 8,11) -- 1개의 원은 최소 3개의 점으로 정의됨 ) 두 개의 폴리곤 1234567SDO_GEOMETRY ( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1, 19,2003,1), SDO_ORDINATE_ARRAY(0,0, 10,0, 10,10, 0,10, 0,0, 4,4, 6,4, 6,6, 4,6, 4,4) ) Insert 예제 12345INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88)) ); SELECT 입력된 직사각형 영역 안의 데이터 조회 1234567891011# SDO_INTERSECTION(geometry1, geometry2, tolerance);SELECT id, nameFROM sample_tableWHERE SDO_GEOM.SDO_INTERSECTION( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 0.005 ) is not null 1234567891011# SDO_RELATE(geometry1, geometry2, param);SELECT id, nameFROM sample_tableWHERE SDO_RELATE( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 'mask=INSIDE+OVERLAPBDYINTERSECT+EQUAL+COVERS' ) = 'TRUE' 위의 쿼리에서 SDO_RELATE 의 param에 대한 내용은 참고 사이트에 자세하게 설명되어 있습니다. X, Y 좌표 조회 12SELECT name, t.x, t.y, t.idFROM sample_table s, TABLE(SDO_UTIL.GETVERTICES(s.shape)) t Polygon Center 좌표 조회 12345SELECT SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.X x, SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.Y yFROM sample_table s, user_sdo_geom_metadata mWHERE name = 'Polygon' Geometry 형식이 맞는가? 12SELECT s.name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(s.shape, 0.005)FROM sample_table s 참고 Oracle Help Center - Spatial Relationships and Filtering","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"}]},{"title":"[Oracle] SDO_GEOMETRY 사용 방법","slug":"oracle-1","date":"2021-03-16T01:22:54.000Z","updated":"2024-01-11T14:38:12.419Z","comments":true,"path":"2021/03/16/oracle-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/16/oracle-1/","excerpt":"","text":"SDO_GEOMETRY Oracle Spatial을 사용하여 공간 데이터를 생성하고 관리합니다. Oracle 에는 SDO_GEOMETRY 타입을 통하여 공간 데이터를 구성할 수 있습니다. SDO_GEOMETRY 은 다음과 같이 정의됩니다. 1234567CREATE TYPE sdo_geometry AS OBJECT ( SDO_GTYPE NUMBER, SDO_SRID NUMBER, SDO_POINT SDO_POINT_TYPE, SDO_ELEM_INFO SDO_ELEM_INFO_ARRAY, SDO_ORDINATES SDO_ORDINATE_ARRAY); SDO_GTYPE 00 - UNKNOWN_GEOMETRY 01 - POINT 02 - LINE or CURVE 03 - POLYGON or SURFACE 04 - COLLECTION 05 - MULTIPOINT 06 - MULTILINE or MULTICURVE 07 - MULTIPOLYGON or MULTISURFACE 08 - SOLID 09 - MULTISOLID 예) 2003 일 경우 2차원의 POLYGON 형식 SDO_SRID Geometry와 연관된 Coordinate System(Spatial Reference System)입니다. 값이 NULL 이면 관련된 Coordinate System 이 없는 것입니다. SDO_POINT POINT 형식일 때 사용합니다. SDO_POINT_TYPE(x, y, z) 을 통해 포인트를 입력합니다. SDO_ELEM_INFO SDO_ORDINATES 에 저장될 값의 형식을 정의합니다. 예) SDO_ELEM_INFO_ARRAY(1,1003,3) 첫 번째 1 은 SDO_ORDINATES 에 입력된 도형 ARRAY 의 시작 위치 1003과 3은 도형 형식을 정의 1003 은 외부도형, 2003 일 경우 내부도형 (1,1003,1) or (1,2003,1) : 폴리곤 형식으로 4면 다각형의 경우 5개의 점을 지정하고 점 5와 점 1은 동일 (1,1003,3) or (1,2003,3) : 직사각형 유형. 왼쪽 하단과 오른쪽 상단의 두 점을 지정 (1,1003,4) or (1,2003,4) : 원형 유형. 최소 3개의 점을 지정해야 함 자세한 내용은 참고 사이트에서 확인 SDO_ORDINATES SDO_ELEM_INFO 에서 정의된 형식으로 값을 입력합니다. Spatial Table 생성 1. 테이블 생성 shape 필드에 SDO_GEOMETRY 타입을 지정하여 Spatial 테이블을 생성하였습니다. 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); 2. 메타데이터 생성 SDO_GEOMETRY 를 사용하기 전에 꼭 메타데이터를 생성해줘야 합니다. 1234567891011121314151617insert into user_sdo_geom_metadata ( table_name, column_name, diminfo, srid )values ( 'sample_table', 'shape', SDO_DIM_ARRAY( SDO_DIM_ELEMENT('Longitude', -180, 180, 0.5), =&gt; 10 미터 허용오차 SDO_DIM_ELEMENT('Latitude', -90, 90, 0.5) ), 4326 ====&gt; Longitude/Latitude(WGS 84) : 4326 ); 3. 인덱스 생성 메타데이터 생성 후 Spatial 테이블의 인덱스를 생성합니다. 12345# 인덱스 생성 형식CREATE INDEX index_name ON table_name(column_name) INDEXTYPE IS MDSYS.SPATIAL_INDEX;# 사용 예제CREATE INDEX sample_index ON sample_table(shape) indextype IS MDSYS.SPATIAL_INDEX; 4. 데이터 입력 테이블을 생성하고 메타데이터와 인덱스까지 생성하였으면 데이터를 넣어봅니다. 123456# Rectangle 데이터INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(5,5, 10,10)) ); 5. 확인 입력된 데이터가 SDO_GEOMETRY 형식인지 확인합니다. 결과가 TRUE 가 아니면 잘못된 입력입니다. 1234SELECT id, name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(shape, 0.5) FROM sample_table;# 결과1, Rectangle, TRUE SDO_GEOMETRY 타입을 사용하여 공간 데이터 생성을 진행하였습니다. 다음에는 생성된 공간 데이터에 대한 쿼리를 알아보겠습니다. 참고 Oracle Help Center - SDO_GEOMETRY Object Type Oracle Help Center - Polygon with a Hole Oracle Spatial Geometry Type 및 Spatial Table 생성","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"}]},{"title":"[Spring Boot] 환경에 따른 설정 방법","slug":"springboot-2","date":"2021-03-11T00:38:25.000Z","updated":"2024-01-11T14:37:10.341Z","comments":true,"path":"2021/03/11/springboot-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/11/springboot-2/","excerpt":"","text":"Spring Boot를 사용하여 웹 프로젝트를 할 때에 환경(개발 또는 배포)에 따라 설정 값들을 달리 할 필요가 있습니다. Spring Boot 에서는 application.properties 파일을 profile 로 구분하여 사용할 수 있습니다. profile을 작성하지 않을 경우 default로 application.properties를 사용합니다. application.properties 작성 규칙 profile을 포함한 파일명을 작성합니다. 1234567891011121314# defaultapplication.properties# 배포 환경(prod)application-prod.properties# 개발 환경(dev)application-dev.properties# 테스트 환경(test)application-test.properties# customapplication-custom.properties 예제 개발과 배포할 때의 설정을 나눈 예제입니다. 파일 생성 12345# 배포용(기본)application.properties# 개발용(dev)application-dev.properties application.properties 설정 application-dev.properties 파일에 spring.profiles.active=dev 을 추가합니다. application.properties 12345678# Server 설정server.port=8080# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://[외부 IP]:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=root!23 application-dev.properties 1234567891011# Profile 설정 - 이 값을 꼭 넣어야 합니다.spring.profiles.active=dev# Server 설정server.port=8081# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=test!23 Application 실행 설정 STS(Spring Tool Suite) - Spring Boot Run 다음의 이미지와 같이 Profile에 적용하고자 하는 환경 값(예: dev)을 선택하면 application-dev.properties의 설정을 읽어옵니다. 실행 테스트 dev 환경을 주입 후 실행 테스트를 하였습니다. dev 환경일 때 서버 포트를 8081으로 설정을 하였었는데 다음의 실행 로그를 보면 Tomcat started on port(s): 8081 처럼 8081 포트로 서버가 실행된 것을 확인할 수 있습니다. 123452021-03-11 13:52:28.738 INFO 13588 --- [ restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'2021-03-11 13:52:28.772 INFO 13588 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292021-03-11 13:52:29.903 INFO 13588 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2021-03-11 13:52:30.836 INFO 13588 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path '/admin'2021-03-11 13:52:30.839 INFO 13588 --- [ restartedMain] c.y.a.a.EAfterschoolAdminApplication : Started EAfterschoolAdminApplication in 6.985 seconds (JVM running for 7.822)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"}]},{"title":"[JavaScript] String형 Bytes length 구하기","slug":"js-dev-2","date":"2021-03-10T00:52:06.000Z","updated":"2023-06-12T13:57:01.518Z","comments":true,"path":"2021/03/10/js-dev-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/js-dev-2/","excerpt":"","text":"UTF-8 인코딩 방식 바이트 길이 구하기 한글 한글자당 3 바이트씩 계산됩니다. 12345678910// Functionconst getByteLengthOfString = function (s, b, i, c) &#123; for (b = i = 0; (c = s.charCodeAt(i++)); b += c &gt;&gt; 11 ? 3 : c &gt;&gt; 7 ? 2 : 1); return b;&#125;;// Testconst test = '테스트';console.log('length : ', getByteLengthOfString(test), 'Bytes'); 12// 결과length : 9 Bytes 한글의 경우 2바이트 계산되도록 다음의 함수를 통해 한글 문자열의 바이트 수를 2 바이트로 나오게 할 수 있습니다. 1234567891011121314151617181920// FunctionString.prototype.getBytes = function () &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; &#125; return int_char_count;&#125;;// Testconst test = '테스트';console.log('length : ', test.getBytes(), 'Bytes'); 12// 결과length : 6 Bytes 입력된 길이 만큼의 문자열을 리턴 1234567891011121314151617181920212223242526// FunctionString.prototype.getStringFromByteLength = function (length) &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; let returnValue = ''; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; if (int_char_count &gt; length) &#123; break; &#125; returnValue += str_character; &#125; return returnValue;&#125;;// Testconst test = '테스트';console.log('result : ', test.getStringFromByteLength(4)); 12// 결과result: 테스;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"[JAVA] String형 Bytes length 구하기","slug":"java-dev-6","date":"2021-03-10T00:32:48.000Z","updated":"2024-01-11T14:35:38.744Z","comments":true,"path":"2021/03/10/java-dev-6/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/java-dev-6/","excerpt":"","text":"String 길이 구하기 123String test = \"테스트\";System.out.println(\"length : \" + test.length()); 12# 결과length : 3 바이트 길이 구하기 1234String test = \"테스트\";int length = test.getBytes().length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 9 Bytes 기본 인코딩이 UTF-8 설정되어있을 경우 한글은 한글자당 3바이트씩 계산됩니다. 한글 한글자당 2바이트씩 나오게 하려면 다음과 같이 인코딩을 설정하면 됩니다. 12345String charset = \"euc-kr\";String test = \"테스트\";int length = test.getBytes(charset).length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 6 Bytes 인코딩 문자셋에 따라 바이트 길이 구하기 12345678910111213141516/** * 문자열의 바이크 길이 구하기 * 인코딩 문자셋에 따라 바이크 길이 달라짐. * * @param str 문자열 * @param charset 인코딩 문자셋 * @return */private int getByteLength(String str, String charset) &#123; try &#123; return str.getBytes(charset).length; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"}]},{"title":"[Spring Boot] Maven 빌드 방법","slug":"springboot-1","date":"2021-03-09T04:52:07.000Z","updated":"2024-01-11T14:35:24.116Z","comments":true,"path":"2021/03/09/springboot-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/09/springboot-1/","excerpt":"","text":"STS(Spring Tool Suite)에서 빌드 방법 메뉴 -&gt; Run -&gt; Run Configurations -&gt; Maven Build(우클릭) -&gt; New Configuration 클릭 [Name] 입력 란에 작성 [Base directory] 에서 Workspace 버튼 클릭 빌드하려는 프로젝트 선택 [Goals] 입력 란에 clean install 작성 저장 후 빌드 실행 아래 이미지는 설정 한 내용입니다. Maven 빌드 중에 데이터베이스 연결을 제외하는 방법 Maven Build -&gt; [Goals] 입력 란에 clean install -DskipTests 작성합니다. 또는 pom.xml에 아래 코드를 추가합니다. 1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"}]},{"title":"[Kubernetes] 명령어들","slug":"kubernetes-1","date":"2021-03-04T02:17:05.000Z","updated":"2023-03-14T02:22:11.262Z","comments":true,"path":"2021/03/04/kubernetes-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/04/kubernetes-1/","excerpt":"","text":"명령어들 123456789101112131415161718192021222324# 생성kubectl create -f test.pod.yaml# 중지 및 삭제kubectl delete pod test --grace-period=0 --forcekubectl delete service test# node 정보 확인kubectl get nodes# pod 확인kubectl get pods --all-namespaces# 서비스 확인kubectl get svc# 배포 확인kubectl get deployments# 상세 정보 확인kubectl describe pods# 개별 상세 정보 확인kubectl describe pod &lt;name&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"}]},{"title":"[Docker] 명령어들","slug":"docker-2","date":"2021-01-26T06:18:26.000Z","updated":"2023-03-14T02:22:08.827Z","comments":true,"path":"2021/01/26/docker-2/","link":"","permalink":"http://hgko1207.github.io/2021/01/26/docker-2/","excerpt":"","text":"컨테이너 관련 명령어들 명령어 설명 docker ps 실행되고 있는 컨테이너 목록 docker ps -a 전체 컨테이너 목록 docker ps --no-trunc 컨테이너 정보 전체 표시 docker logs [컨테이너명 or ID] 로그 확인 docker exec -i -t [컨테이너명 or ID] /bin/bash 컨테이너 내부 셸 접속 docker rm [컨테이너명 or ID] 컨테이너 삭제 docker rm -f [컨테이너명 or ID] 컨테이너 강제 삭제 docker commit [옵션] [컨테이너명] [이미지명]:[태그] 컨테이너 커밋 12345678# 컨테이너 압축# export의 경우 컨테이너를 동작하는데 필요한 모든 파일이 압축됨docker export [컨테이너명 or ID] &gt; [파일명]docker export test &gt; test.tar# 컨테이너 importdocker import [파일명]docker import test.tar 이미지 관련 명령어들 명령어 설명 docker images 이미지 목록 확인 docker build [옵션] [이미지명] [Dockerfile 경로] 이미지 생성 docker rmi [이미지명 or ID] 이미지 삭제 docker tag [기존 이미지명] [새로운 이미지명] 이미지 태그명 변경 docker tag [기존 이미지명]:[기존 태그명] [새로운 이미지명]:[새로운 태그명] 이미지 태그명 변경 docker pull [저장소 주소]/[이미지명] 도커 허브에서 다운로드 docker push [저장소 주소]/[이미지명] 도커 허브 저장소에 이미지 올리기 1234567891011121314# 이미지 압축docker save [옵션] [파일명] &lt;이미지명 또는 이미지ID&gt;docker save -o baseimage.tar baseimage# 모든 이미지 압축docker save -o images.tar $(docker image ls -q)# gzip을 이용한 이미지 압축docker save [이미지명] | gzip &gt; [파일명]docker save baseimage | gzip &gt; baseimage.tar.gz# 이미지 로드docker load [옵션] [파일명]docker load -i baseimage.tar 기타 명령어 12# 컨테이너 정보 일부 표시docker ps --format \"table &#123;&#123;.image&#125;&#125;\\t&#123;&#123;.command&#125;&#125;\"","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[CentOS] Cmake 설치 및 사용 방법","slug":"linux-11","date":"2021-01-25T07:36:18.000Z","updated":"2024-01-11T14:34:58.640Z","comments":true,"path":"2021/01/25/linux-11/","link":"","permalink":"http://hgko1207.github.io/2021/01/25/linux-11/","excerpt":"","text":"리눅스 환경에서 Cmake 설치 및 사용 방법에 대해 알아보겠습니다. 다운로드 https://cmake.org/download/ 페이지를 가서 최신 버전을 다운로드합니다.현재 날짜 기준으로 3.19.3 버전입니다. 123[hgko@localhost ~]$ sudo su[root@localhost ~]$ cd /usr/local/src[root@localhost src]$ wget http://www.cmake.org/files/v3.19/cmake-3.19.3.tar.gz 다운로드가 완료되면 압축해제를 합니다. 1[root@localhost src]$ tar -zxvf cmake-3.19.3.tar.gz 설치 /usr/local 경로의 bin 폴더에 설치가 됩니다. 1234[root@localhost src]$ cd cmake-3.19.3[root@localhost cmake-3.19.3]$ ./bootstrap --prefix=/usr/local[root@localhost cmake-3.19.3]$ make[root@localhost cmake-3.19.3]$ make install 설치 확인 다음과 같이 버전 정보가 출력되면 성공적으로 설치가 완료되었습니다. 1234[root@localhost ~]$ cmake --versioncmake version 3.19.3CMake suite maintained and supported by Kitware (kitware.com/cmake). 사용 방법 다음 명령어는 사용 방법입니다. CMakeLists.txt 파일을 생성하고 내용을 작성 cmake 명령어로 실행 123$ cmake CMakeLists.txt$ make$ make install make 파일 정리 1$ make clean","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"}]},{"title":"[CentOS] 유용하게 쓰는 명령어들","slug":"linux-10","date":"2021-01-20T01:53:23.000Z","updated":"2023-03-14T02:22:03.502Z","comments":true,"path":"2021/01/20/linux-10/","link":"","permalink":"http://hgko1207.github.io/2021/01/20/linux-10/","excerpt":"","text":"유용하게 쓰는 명령어들 명령어 설명 source /etc/profile profile 적용 free -h 메모리 용량 확인 dh -h 디스크 용량 확인 nproc CPU 코어 수 확인 pwd 현재 경로 확인 chmod -R 755 [폴더 or 파일] 사용 권한 변경 chown -R root:root [폴더 or 파일] 소유자와 그룹 변경 ps -ef | grep [프로세스명] 프로세스 확인 rpm -qa | grep [패키지명] 설치된 패키지 확인 kill -9 [프로세스ID] 프로세스 삭제 mv [파일명] [변경할파일명] 파일명 바꾸기 mv [폴더명] [변경할폴더명] 폴더명 바꾸기 pgrep -f [파일명] 프로세스 id만 추출 1234567891011121314151617# 특정 파일 제외하고 삭제find ./ ! -name '*.h' -exec rm -rf &#123;&#125; \\;# 두 개의 파일 형식 빼고 다 삭제# 예) .h, .inl 파일 빼고 삭제find ./ \\( ! -name '*.inl' ! -name '*.h' \\) -exec rm -rf &#123;&#125; \\;# 별칭 설정alias rm='rm -i'alias cp='cp -i'alias mv='mv -i'# 환경변수 설정export LD_LIBRARY_PATH=/usr/bin:$LD_LIBRARY_PATH# 폴더와 하위 폴더에 있는 파일명 텍스트로 추출dir [폴더경로] &gt; list.txt 12# tail -n 로 가장 나중의 jar 파일 찾기ls -tr | grep jar | tail -n 1 가끔 쓰인 명령어들 명령어 설명 uname -r 커널 버전 확인 ln -s [원본파일] [링크파일] 심볼릭 링크 설정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[CentOS] Nginx 설치 및 사용 방법","slug":"linux-9","date":"2020-11-16T02:35:35.000Z","updated":"2024-01-11T14:34:25.936Z","comments":true,"path":"2020/11/16/linux-9/","link":"","permalink":"http://hgko1207.github.io/2020/11/16/linux-9/","excerpt":"","text":"리눅스 환경에서 Nginx 설치 및 사용 방법에 대해 알아보겠습니다. 1. Nginx 저장소 추가 yum 저장소에는 nginx 라이브러리가 없기 때문에 저장소를 추가합니다. 1[hgko@localhost ~]$ sudo vi /etc/yum.repos.d/nginx.repo /etc/yum.repos.d 경로에 nginx.repo 파일을 추가하고 다음과 같이 작성합니다. 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1 2. 설치 저장소를 추가하였다면 설치를 합니다. 1[hgko@localhost ~]$ sudo yum install -y nginx 3. 방화벽 포트 개방 웹서버의 8080 포트를 사용할 계획이므로, 8080 포트를 개방합니다. 123456# 포트 개방[hgko@localhost ~]$ sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp# 방화벽 재시작[hgko@localhost ~]$ sudo firewall-cmd --reload# 개방된 포트 목록 확인[hgko@localhost ~]$ sudo firewall-cmd --list-ports 4. 서비스 시작 서비스를 등록하고 시작합니다. 12[hgko@localhost ~]$ sudo systemctl enable nginx[hgko@localhost ~]$ sudo systemctl start nginx 5. 웹 서버 배포 서비스가 시작되었으면 개발된 웹 서버 배포 작업을 진행합니다. 빌드된 프로젝트를 /usr/share/nginx/ 경로로 이동시킵니다. 기존의 설정파일인 default.conf 파일을 엽니다. 기존 설정파일을 지우고 새로 생성해도 됩니다. 포트를 변경하고, 프로젝트 경로를 입력하고, 필요한 proxy 정보를 입력합니다. proxy_pass에는 backend server url을 입력합니다. 12[hgko@localhost ~]$ sudo su[root@localhost ~]$ vi /etc/nginx/conf.d/default.conf 12345678910111213141516171819202122232425262728293031server &#123; listen 8080; listen [::]:8080; server_name localhost; # 도메인 주소 root /usr/share/nginx/frontend; # 배포된 프로젝트 경로 index index.html index.htm; client_max_body_size 100M; location ^~ /api &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; location ^~ /stream &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_cache_bypass $http_upgrade; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 6. 서비스 재시작 설정이 완료되면 서비스를 재시작합니다. 1[hgko@localhost ~]$ sudo systemctl restart nginx 7. 확인 http://localhost:8080을 접속하여 웹 서버가 잘 실행되고 있는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"}]},{"title":"[CentOS] PM2 설치 및 사용 방법","slug":"linux-8","date":"2020-10-26T06:57:59.000Z","updated":"2024-01-11T14:33:51.482Z","comments":true,"path":"2020/10/26/linux-8/","link":"","permalink":"http://hgko1207.github.io/2020/10/26/linux-8/","excerpt":"","text":"리눅스 환경에서 PM2 설치 및 사용 방법에 대해서 알아보겠습니다. Node.js 는 단일 CPU 코어에서 실행되기 때문에 CPU 개수만큼 멀티코어 시스템을 사용하기 위해 PM2(Process Manager 2) 를 설치하고 사용하였습니다. 설치 npm이 설치되어 있어야 합니다. 1[root@localhost ~]$ npm install pm2 -g 설치 확인 pm2 프로세스의 상태를 확인합니다. 처음에는 시작한 애플리케이션이 없기 때문에 아무것도 없습니다. 1[root@localhost ~]$ pm2 list 기본 사용 방법 pm2를 사용해 보기 위해 간단한 애플리케이션을 작성하겠습니다. app.js 파일을 생성하고 아래 코드를 복사합니다. 123456789101112// app.jsconst express = require('express');const app = express();const port = 3000;app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);app.listen(port, function () &#123; console.log(`application is listening on port $&#123;port&#125;...`);&#125;); pm2를 통해 실행합니다. 1[root@localhost test]$ pm2 start app.js 또는 이름을 지정하여 실행할 수 있습니다. 1[root@localhost test]$ pm2 start app.js --name app 아무런 옵션없이 PM2를 사용하여 실행하면 위의 그림처럼 포크(fork) 모드로 애플리케이션을 실행합니다. 클러스터 모드 사용 설정파일을 활용해 클러스터 모드로 실행할 수 있습니다. 123# 설정파일 생성[root@localhost test]$ touch ecosystem.config.js[root@localhost test]$ vi ecosystem.config.js 1234567891011// ecosystem.config.jsmodule.exports = &#123; apps: [ &#123; name: 'app', script: './app.js', instances: 0, exec_mode: 'cluster', &#125;, ],&#125;; 1[root@localhost test]$ pm2 start ecosystem.config.js 위의 코드를 복사하고 pm2 명령어로 실행하면 클러스터 모드로 실행됩니다. exec_mode 값을 'cluster’로 설정하면 클러스터 모드로 실행한다는 의미이고, instances 값을 '0’으로 설정하면 CPU 코어 수 만큼 프로세스를 실행한다는 의미입니다. instances 값을 0이 아닌 고정으로 설정할 수도 있습니다. 다수의 어플리케이션 설정 123456789101112131415161718module.exports = &#123; apps: [ &#123; name: 'collect', cwd: './workspace/pipeline-service-collector', script: 'npm', args: 'run serve', instances: 5, exec_mode: 'cluster', &#125;, &#123; name: 'collect-manager', cwd: './workspace/pipeline-service-collector-manager', script: 'npm', args: 'run serve', &#125;, ],&#125;; 위의 코드는 두 개의 애플리케이션을 실행하는 예제입니다. 첫 번째는 클러스터 모드로 5개의 프로세스를 실행하도록 설정하였고, 두 번째는 포크(fork) 모드로 하나의 프로세스를 실행하도록 하였습니다. 이렇게 여러 개의 애플리케이션을 한 번에 실행하도록 설정을 할 수도 있습니다. 실제로 동작하는 상태는 아래 그림과 같습니다. 프로세스 줄이기 프로세스의 수가 많다면 프로세스를 2개로 줄일 수 있습니다. 1[root@localhost test]$ pm2 scale app 2 재시작 1[root@localhost test]$ pm2 reload 중지 1[root@localhost test]$ pm2 stop app 삭제 1[root@localhost test]$ pm2 delete app 추가 설정 nodejs 권한이 잘못 되어있는 경우 1234[hgko@localhost test]$ sudo su[root@localhost test]$ cd /usr/local/lib[root@localhost lib]$ chown -R hgko:hgko nodejs[root@localhost lib]$ exit","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"}]},{"title":"[CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법","slug":"linux-7","date":"2020-10-12T01:30:46.000Z","updated":"2024-01-11T14:31:29.414Z","comments":true,"path":"2020/10/12/linux-7/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-7/","excerpt":"","text":"리눅스 환경에서 아파치 톰캣 설치 및 사용 방법에 대해 알아보겠습니다. 아파치 톰캣(Tomcat) 이란 아파치 톰캣(Apache Tomcat)은 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너(또는 웹 컨테이너)만 있는 웹 애플리케이션 서버이다. 톰캣은 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 자바서버 페이지(JSP)와 자바 서블릿이 실행할 수 있는 환경을 제공하고 있다. 톰캣은 관리툴을 통해 설정을 변경할 수 있지만, XML 파일을 편집하여 설정할 수도 있다. 그리고, 톰캣은 HTTP 서버도 자체 내장하기도 한다. 출처 : 위키백과 1. 다운로드 http://archive.apache.org/dist/tomcat/tomcat-8/ 사이트에서 최신 버전을 확인하고 다운로드합니다. 12[hgko@localhost ~]$ cd /home/download[hgko@localhost download]$ wget http://archive.apache.org/dist/tomcat/tomcat-8/v8.5.59/bin/apache-tomcat-8.5.59.tar.gz 오프라인 환경에서는 Tomcat 8 Download 사이트 접속해서 tar.gz 파일을 직접 다운로드 후 서버에 전송합니다. 2. 설치 먼저 tar 명령어를 사용하여 압축을 풀어 줍니다. 압축이 풀리면 모든 사용자가 사용하고 관리가 편리하도록 Root 계정으로 접속 후 해당 폴더로 이동시켜줍니다. 123456# 압축 해제[hgko@localhost download]$ tar zxvf apache-tomcat-8.5.59.tar.gz# 폴더 이동[hgko@localhost download]$ sudo su[root@localhost download]$ mv /home/download/apache-tomcat-8.5.59 /usr/local/lib 3. 환경 설정 1[root@localhost ~]$ vi /etc/profile 123456JAVA_HOME=/usr/local/javaJRE_HOME=/usr/local/javaCATALINA_HOME=/usr/local/lib/apache-tomcat-8.5.59CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$CATALINA_HOME/lib/jsp-api.jar:$CATALINA_HOME/lib/servlet-api.jarPATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/binexport JAVA_HOME JRE_HOME CLASSPATH PATH CATALINA_HOME Tomcat 설정 부분(CATALINA)만 수정하면 됩니다. 설정이 완료되면 반영합니다. 12345# 설정 반영[root@localhost ~]$ source /etc/profile# 설정 확인[root@localhost ~]$ echo $CATALINA_HOME 4. 방화벽 설정 현재 톰캣 포트가 8080이기 때문에 8080 포트에 대한 방화벽을 설정합니다. 12[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=8080/tcp[root@localhost ~]$ firewall-cmd --reload 5. 실행 12[root@localhost ~]$ cd /usr/local/lib/apache-tomcat-8.5.59/bin[root@localhost bin]$ ./startup.sh 6. 중지 1[root@localhost bin]$ ./shutdown.sh 7. 실행 확인 http://localhost(ip 주소):8080 에 접속해서 확인합니다. 1[root@localhost bin]$ tail -f /usr/local/lib/apache-tomcat-8.5.59/logs/catalina.out tail 명령어를 사용하여 로그 내용을 출력해서 진행 상태를 파악할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"}]},{"title":"[CentOS] NFS 설치 및 설정 방법","slug":"linux-6","date":"2020-10-12T00:42:48.000Z","updated":"2024-01-11T14:29:35.392Z","comments":true,"path":"2020/10/12/linux-6/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-6/","excerpt":"","text":"리눅스 환경에서 NFS 설치 및 설정 방법에 대해 알아보겠습니다. NFS 란 네트워크 파일 시스템(Network File System, NFS)은 1984년에 썬 마이크로시스템즈가 개발한 프로토콜이다. 클라이언트 컴퓨터의 사용자가 네트워크 상의 파일을 직접 연결된 스토리지에 접근하는 방식과 비슷한 방식으로 접근하도록 도와준다. 다른 수많은 프로토콜과 마찬가지로 ONC RPC 시스템을 기반으로 한다. 네트워크 파일 시스템은 RFC에 정의된 오픈 표준이므로 누구나 구현할 수 있다. 출처 : 위키백과 운영환경 CentOS 7.6 NFS 서버 설정 1. 설치 nfs-utils 패키지가 설치되어있는지 확인하고 없을 시 yum을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 부팅 시 자동 시작되도록 서비스 등록을 하고 실행을 합니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트 할 디렉토리 생성 마운트 할 임의의 디렉토리 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 마운트 설정을 위해 /etc/export 파일을 수정합니다. 1$ vi /etc/export 아래 내용을 추가합니다. 1/nfstest 192.168.0.*(rw,sync) /nfstest: 공유할 디렉토리 192.168.0.*: 허가할 호스트 대역 rw : 읽기, 쓰기 가능 ro : 읽기만 가능 secure : 클라이언트 마운트 요청 시 포트를 1024 이하로 설정 noaccess : 액세스 거부 root_squach : 클라이언트의 root가 서버의 root 권한을 획득하는 것을 차단 no_root_squash : 클라이언트의 계정을 root로 매핑 sync : 파일 시스템이 변경되면 즉시 동기화 all_squach : root를 제외하고 서버와 클라이언트의 사용자를 동일한 권한으로 설정 no_all_squach : root를 제외하고 서버와 클라이언트의 사용자들을 하나의 권한을 가지도록 설정 참고로 /etc/exports 에서 IP 입력 후 띄어쓰기 없이 (rw) 설정을 해야하고, 만약 띄어쓰기를 사용하면 설정이 제대로 되지 않아 Read-only 설정으로 되어 에러가 발생할 수 있습니다. 5. 수정내용 적용 수정한 export 내용을 적용합니다. 1$ exportfs -r 서비스를 재시작 합니다. 1$ systemctl restart nfs-server 6. 수정내용 확인 NFS 설정이 정상적으로 되었는지 확인합니다. 12$ showmount -e$ exportfs -v 클라이언트 마운트 설정 1. 설치 nfs-utils 패키지가 설치되어 있는지 확인하고 없을 시 yum을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 서비스 등록 및 시작 명령어입니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트할 디렉토리 생성 마운트 할 임의의 디렉토리를 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 생성된 디렉토리에 NFS 디렉토리를 마운트 합니다. 1$ mount -t nfs 192.168.0.100:/nfstest /nfstest 192.168.0.100: nfs 서버 주소 5. 마운트 영구 적용 마운트 영구 적용을 위해 /etc/fstab 파일을 수정합니다. 12$ vi /etc/fstab192.168.0.100:/nfstest /nfstest nfs defaults 0 0 192.168.0.100: nfs 서버 주소 6. 마운트 확인 정상적으로 마운트 되었는지 확인을 합니다. 12$ df -h | grep nfs192.168.0.100:/nfstest 24G 6.4G 16G 30% /nfstest 7. 설정 확인 설정이 완료되었다면 /nfstest 경로에서 파일을 생성해 보고 클라이언트와 서버에 제대로 공유가 되는지 확인합니다. 12[root@localhost ~]$ cd /nfstest[root@localhost nfstest]$ touch test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"}]},{"title":"[PostgreSQL] TimescaleDB 설치 방법","slug":"postgresql-4","date":"2020-10-08T04:12:58.000Z","updated":"2024-01-11T08:27:52.346Z","comments":true,"path":"2020/10/08/postgresql-4/","link":"","permalink":"http://hgko1207.github.io/2020/10/08/postgresql-4/","excerpt":"","text":"TimescaleDB 란 TimescaleDB는 빠른 수집, 복잡한 쿼리를 편리하게 사용하기 위해 설계된 오픈 소스 시계열 데이터베이스입니다. PostgreSQL을 기반으로 하며 자동 파티셔닝과 SQL 지원을 제공합니다. PostgreSQL 보다 10 ~ 100배 빠른 쿼리를 수행하고 시계열에 대해 최적화가 되어 있습니다. 5 ~ 10분 단위로 수집되는 많은 양의 데이터를 데이터베이스에 추가하고 시계열로 관리하며 빠르게 조회하기 위해 TimescaleDB를 사용하였습니다. 운영환경 CentOS 7.6 PostgreSQL 11 설치 PostgreSQL이 설치되어있어야 합니다. 미설치 시 [PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작을 참고해서 설치합니다. 1. PostgreSQL 설치 확인 1$ rpm -qa | grep postgresql 2. 계정 확인 1$ cat /etc/passwd | grep postgres postgres 계정이 없으면 생성합니다. 12$ sudo useradd postgres$ sudo passwd postgres 3. 설정 변경 1234$ vi /var/lib/pgsql/11/data/postgresql.conf#listen_addresses = 'localhost' -&gt; listen_addresses = '*'#password_encryption = md5 -&gt; password_encryption = md5 4. TimescaleDB 다운로드 다음 명령어를 복사해서 붙여 넣습니다. 123456789101112$ sudo cat &gt; /etc/yum.repos.d/timescale_timescaledb.repo &lt;&lt;EOL[timescale_timescaledb]name=timescale_timescaledbbaseurl=https://packagecloud.io/timescale/timescaledb/el/7/\\$basearchrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/timescale/timescaledb/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300EOL 12$ sudo yum update -y$ yum install -y timescaledb-postgresql-11 5. 데이터베이스 설정 계속 y를 눌러줍니다. 1$ sudo timescaledb-tune --pg-config=/usr/pgsql-11/bin/pg_config 6. PostgreSQL 재시작 1$ systemctl restart postgresql-11 7. 접속 123$ sudo su$ su - postgres$ psql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"}]},{"title":"[CentOS] Apache Kafka 설치 및 사용 방법","slug":"linux-5","date":"2020-10-01T13:16:06.000Z","updated":"2023-06-04T14:51:05.343Z","comments":true,"path":"2020/10/01/linux-5/","link":"","permalink":"http://hgko1207.github.io/2020/10/01/linux-5/","excerpt":"","text":"아파치 카프카(Apache Kafka)는 아파치 소프트웨어 재단이 스칼라로 개발한 오픈 소스 메시지 브로커 프로젝트이다. 출처 : 위키백과 메시지 큐를 사용하여 동기화 서비스 및 대용량 분산 시스템을 구축하기 위해 Zookeeper와 함께 Apache Kafka를 사용하게 되었습니다. 운영환경 CentOS 7.6 1. 다운로드 및 설치 123[root@localhost ~]$ cd /home/test[root@localhost test]$ wget http://apache.mirror.cdnetworks.com/kafka/2.1.0/kafka_2.11-2.3.0.tgz[root@localhost test]$ ln -s kafka_2.11-2.3.0 kafka 2. server.properties 수정 123456789101112[root@localhost test]$ vim kafka/config/server.properties# zookeeper 서버의 myid 값으로 설정broker.id=1#Broker가 받은 데이터를 관리위한 저장공간log.dirs=/home/test/kafka-logs#Broker가 사용하는 호스트와 포트를 지정listeners=PLAINTEXT://0.0.0.0:9002#Producer와 Consumer가 접근할 호스트와 포트를 지정, 기본값은 listeners를 사용advertised.listeners=PLAINTEXT://192.168.24.10:9092# zookeeper의 접속 정보zookeeper.connect=192.168.24.7:2181 3. 실행 12[root@localhost test]$ cd kafka/bin[root@localhost bin]$ ./kafka-server.start.sh ../config/server.properties 정상적으로 실행이 되면 다음과 같은 메시지가 뜹니다. 12....중략....[KafkaServer id=1] started (kafka.server.KafkaServer) 4. 서비스 등록 마지막으로 kafka-server.service라는 스크립트를 만들고 서비스에 등록합니다. 123# 종료 후 서비스 등록[root@localhost bin]$ ./kafka-server-stop.sh[root@localhost bin]$ vi /etc/systemd/system/kafka.service 1234567891011121314151617[Unit]Description=kafkaAfter=network.target[Service]Type=simpleUser=testGroup=testSyslogIdentifier=kafkaWorkingDirectory=/home/test/kafkaRestart=alwaysRestartSec=0sExecStart=/home/test/kafka/bin/kafka-server-start.sh /home/test/kafka/config/server.propertiesExecStop=/home/test/kafka/bin/kafka-server-stop.sh[Install]WantedBy=multi-user.target 저장하고 나서 서비스를 재시작하고 카프카를 실행합니다. 정상적으로 실행되면 시스템 부팅 시 자동실행 설정을 지정합니다. 12345678# 서비스 데몬 재시작[root@localhost ~]$ systemctl daemon-reload# 카프카 실행 (종료는 stop, 재시작은 restart)[root@localhost ~]$ systemctl start kafka-server.service# 실행상태 확인[root@localhost ~]$ systemctl status kafka-server.service# 시스템 부팅할때 자동실행 설정[root@localhost ~]$ systemctl enable kafka-server.service 방화벽 설정 1234[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=9092/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload kafka topic 관리 topic 리스트 123# 192.168.24.7는 zookeeper 접속 주소[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --list --zookeeper 192.168.24.7:2181 topic 생성 topic 명은 manager-out 로 설정하였습니다. 123[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --create --zookeeper 192.168.24.7:2181 --replication-factor 1 --partitions 5 --topic manager-out[root@localhost bin]$ ./kafka-topics.sh --zookeeper 192.168.24.7:2181 --alter --topic manager-out --config retention.ms=600000 topic 삭제 1[root@localhost bin]$ ./kafka-topics.sh --delete --zookeeper 192.168.24.7:2181 --topic manager-out topic 상세정보 1[root@localhost bin]$ ./kafka-topics.sh --describe --zookeeper 192.168.24.7:2181","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"}]},{"title":"[CentOS] Apache Zookeeper 설치 및 사용 방법","slug":"linux-4","date":"2020-09-28T01:36:53.000Z","updated":"2024-01-11T08:26:08.304Z","comments":true,"path":"2020/09/28/linux-4/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-4/","excerpt":"","text":"아파치 주키퍼(Apache ZooKeeper)는 아파치 소프트웨어 재단 프로젝트 중의 한 소프트웨어 프로젝트로서 공개 분산형 구성 서비스, 동기 서비스 및 대용량 분산 시스템을 위한 네이밍 레지스트리를 제공한다. 주키퍼는 하둡의 한 하위 프로젝트이었으나 지금은 독립적인 상위 프로젝트이다. 출처 : 위키백과 위의 설명처럼 메시키 큐를 관리하고 동기 서비스 및 대용량 분산 시스템을 구축하기 위해 Apache ZooKeeper 를 사용할 경우가 있습니다. Apache ZooKeeper 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Java jdk 설치 먼저 java jdk를 필수로 설치를 합니다. 1[root@localhost ~]$ yum install java-1.8.0-openjdk.x86_64 profile 정보를 변경합니다. 1234[root@localhost ~]$ vim /etc/profile# profile 파일 안에 아래의 내용을 추가export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk source 명령어를 이용해서 변경된 내용 적용합니다. 1[root@localhost ~]$ source /etc/profile Zookeeper 설치 Zookeeper 서버 패키지를 다운로드하고 환경 설정을 합니다. 1. 계정 생성 먼저 계정을 생성합니다. 계정을 생성하는 이유는 Zookeeper를 별도로 관리하기 위함입니다. 12[root@localhost ~]$ useradd zookeeper[root@localhost ~]$ passwd zookeeper 생성된 계정으로 변경합니다. 1[root@localhost ~]$ su - zookeeper 2. 다운로드 및 설치 다음의 명령어 순서대로 실행해서 다운로드 한 후 압축을 해제합니다. 1234[zookeeper@localhost ~]$ cd /home/test[zookeeper@localhost zookeeper]$ wget http://apache.mirror.cdnetworks.com/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ tar xvfzp zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ ln -s zookeeper-3.4.14 zookeeper 3. 설정 파일 변경 데이터 디렉터리 경로와 서버 설정을 합니다. 12345678[zookeeper@localhost test]$ cd zookeeper/conf[zookeeper@localhost conf]$ cp zoo_sample.cfg zoo.cfg[zookeeper@localhost conf]$ vim zoo.cfgdataDir=/home/test/zookeeper/data #zookeeper 데이터 위치, 원하는 경로에 저장입력server.1=zoo-1:2888:3888 #멀티 서버 설정 (주키퍼 서버가 한곳이 아닐때)# server.2=server_host_1:2888:3888# server.3=server_host_2:2888:3888 4. myid 생성 반드시 myid 파일을 dataDir 속성에 넣었던 경로에 만들어야 합니다. 호스트마다 아이디를 부여해야 합니다. 위의 설정에서 server.1에만 설정하였기 때문에 {dataDir}/myid 내부에 1이라는 값이 있어야 합니다. 그리고 이 값은 유일해야 하고 1~255 사이로 설정해야 합니다. 123[zookeeper@localhost ~]$ cd /home/test/zookeeper/data[zookeeper@localhost data]$ touch myid[zookeeper@localhost data]$ echo 1 &gt; myid 5. Zookeeper 서버 실행 다음 명령어를 실행하면 이상없이 서버가 실행됩니다. 12[zookeeper@localhost ~]$ cd /home/test/zookeeper/bin[zookeeper@localhost bin]$ ./zkServer.sh start 실행 확인 12[zookeeper@localhost bin]$ ./zkCli.sh -server zoo-1:2181[zookeeper@localhost bin]$ ls / Zookeeper 서버 중지 1[zookeeper@localhost bin]$ ./zkServer.sh stop 추가 설정 추가적으로 프로세스 저장 경로와 로그 저장 경로 변경 및 환경변수 등록을 위한 절차입니다. 변경하지 않아도 됩니다. 폴더 권한 변경 Zookeeper 프로세스 아이디 저장 폴더와 로그 저장 폴더를 생성하고 권한을 변경합니다. 1234567891011# root 계정으로 전환[zookeeper@localhost ~]$ su -[root@localhost ~]$ cd /var/run[root@localhost run]$ mkdir zookeeper[root@localhost run]$ chown zookeeper:zookeeper /var/run/zookeeper[root@localhost run]$ cd ../log[root@localhost log]$ mkdir zookeeper[root@localhost log]$ chown zookeeper:zookeeper /var/log/zookeeper# zookeeper 계정으로 다시 돌아가기[root@localhost log]$ exit 추가로 위 두개의 폴더에 링크를 생성합니다. 123[zookeeper@localhost log]$ cd /home/test/zookeeper[zookeeper@localhost zookeeper]$ ln -s /var/run/zookeeper/ pids[zookeeper@localhost zookeeper]$ ln -s /var/log/zookeeper/ logs 환경변수 변경 12345678910export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdkexport ZOOKEEPER_HOME=/home/test/zookeeperexport ZOOKEEPER_CONF_DIR=$ZOOKEEPER_HOME/confexport ZOOKEEPER_LOG_DIR=/var/log/zookeeperexport ZOO_LOG_DIR=$ZOOKEEPER_LOG_DIRexport ZOOKEEPER_PID_DIR=/var/run/zookeeperexport ZOOPIDFILE=$ZOOKEEPER_PID_DIR/zookeeper_server.pidexport SERVER_JVMFLAGS=-Xmx1024mexport JAVA=$JAVA_HOME/bin/javaexport CLASSPATH=$ZOOKEEPER_CONF_DIR:/usr/share/java/jline.jar:/usr/share/java/log4j-1.2.jar:/usr/share/java/xercesImpl.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/netty.jar:/usr/share/java/slf4j-api.jar:/usr/share/java/slf4j-log4j12.jar:/usr/share/java/zookeeper.jar 서버 재시작 12[zookeeper@localhost bin]$ ./zkServer.sh stop[zookeeper@localhost bin]$ ./zkServer.sh start 방화벽 설정 123456[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2181/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2888/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3888/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"}]},{"title":"[CentOS] Proxy 서버를 사용한 내부망 yum 사용 방법","slug":"linux-3","date":"2020-09-28T00:49:32.000Z","updated":"2024-01-11T08:25:32.267Z","comments":true,"path":"2020/09/28/linux-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-3/","excerpt":"","text":"서버가 운영되는 시스템은 인터넷이 안 되는 시스템이 많습니다. 이런 상황에서 yum 을 통한 Package 를 설치할 수 없게 되어 관리가 쉽지 않습니다. Proxy 서버를 이용하여 인터넷이 가능한 하나의 서버 시스템을 통해 모든 서버가 인터넷이 가능하도록 구성할 수 있습니다. 운영환경 CentOS 7.6 설치 인터넷이 되는 서버에 squid Package를 설치합니다. 1$ yum -y install squid 설정 다음과 같이 Proxy 정책을 설정합니다. 1$ vi /etc/squid/squid.conf 12345678910111213141516... 생략 ...# Only allow cachemgr access from localhost#http_access allow localhost manager#http_access deny managerhttp_access allow all # 모든 IP 에 대해 Allow 정책 추가# And finally deny all other access to this proxy#http_access deny all # deny 정책 해제... 생략 ...# Squid normally listens to port 3128http_port 8080 # Proxy 로 사용하길 원하는 Port 지정#http_port 3128 서비스 시작 12$ systemctl start squid$ systemctl status squid 정상적으로 Proxy 서비스가 안될경우 다음과 같이 커널 파라미터를 추가합니다. 12net.ipv6.conf.all.disable_ipv6 = 1net.ipv4.ip_forward = 1 Proxy 서비스 테스트 인터넷이 안되는 내부 시스템에서 다음 명령어를 실행합니다. 1234567891011121314[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorDetermining fastest mirrorsCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - \"Could not resolve host: mirrorlist.centos.org; Unknown error\"Loading mirror speeds from cached hostfileLoading mirror speeds from cached hostfileLoading mirror speeds from cached hostfilerepo id repo name statusbase/7/x86_64 CentOS-7 - Base 0extras/7/x86_64 CentOS-7 - Extras 0updates/7/x86_64 CentOS-7 - Updates 0repolist: 0[root@localhost ~]# 아직 yum 을 사용 할 수 없습니다. yum.conf 수정 /etc/yum.conf 파일에 다음과 같이 proxy 옵션을 추가합니다. 인터넷이 되는 시스템의 IP와 Port 정보를 입력합니다. 12345678910111213141516[root@localhost ~]# vi /etc/yum.conf[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-releaseproxy=http://192.168.100.200:8080 # Proxy 서버 정보 추가 테스트 yum 사용이 가능한지 다시 확인합니다. 12345678910111213141516[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorLoaded plugins: fastestmirror, langpacksRepository nodesource is listed more than once in the configurationRepository nodesource-source is listed more than once in the configurationLoading mirror speeds from cached hostfile * base: mirror.kakao.com * epel: ftp.riken.jp * extras: mirror.kakao.com * updates: mirror.kakao.comrepo id repo name statusbase/7/x86_64 CentOS-7 - Base 10,070extras/7/x86_64 CentOS-7 - Extras 413updates/7/x86_64 CentOS-7 - Updates 1,134repolist: 11,617[root@localhost ~]# 위와 같은 결과가 나타나면 yum 을 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"}]},{"title":"[CentOS] VNC 설치 및 사용 방법(오프라인 환경)","slug":"linux-2","date":"2020-09-19T12:18:14.000Z","updated":"2024-01-11T08:25:07.112Z","comments":true,"path":"2020/09/19/linux-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/19/linux-2/","excerpt":"","text":"오프라인 환경에서 VNC 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Server 설치 다운로드 http://mirror.centos.org/centos/7/os/x86_64/Packages/ 사이트에 접속 후 tigervnc-server-1.8.0-19.el7.x86_64.rpm 파일을 선택하여 다운로드합니다. 다운로드가 완료되면 파일을 리눅스 환경으로 이동시킵니다. 설치 및 설정 12345# 실행$ sudo rpm -ivh tigervnc-server-1.8.0-19.el7.x86_64.rpm# 1 입력 시 5901 포트번호로 생성됩니다.cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 12345$ vi /etc/systemd/system/vncserver@:1.service# 변경ExecStart=/usr/bin/vncserver_wrapper &lt;USER&gt; %i- &lt;USER&gt;를 서버 계정으로 변경 서비스 등록 12$ systemctl daemon-reload$ systemctl enable vncserver@:1.service 방화벽 설정 123456# 포트 열기$ firewall-cmd --zone=public --permanent --add-port=5901/tcp# 포트 갱신$ firewall-cmd --reload# 포트 확인$ firewall-cmd --zone=public --list-all Client 설치 및 접속 https://www.realvnc.com/en/connect/download/viewer/ 사이트 접속 후 Download VNC Viewer를 클릭하여 다운로드합니다. 다운로드가 완료되면 설치를 합니다. VNC Viewer 실행 후 상단 search 란에 host:5901 입력 후 Enter 키를 누릅니다. 서버 계정명과 패스워드를 입력하면 리눅스 환경의 화면이 나오는 것을 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"}]},{"title":"[Node.js] 시작 및 구성 방법","slug":"nodejs-1","date":"2020-09-15T09:11:31.000Z","updated":"2024-01-11T08:24:36.670Z","comments":true,"path":"2020/09/15/nodejs-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/15/nodejs-1/","excerpt":"","text":"다운로드 및 설치 위의 페이지에 접속한 후 플랫폼에 맞게 선택을 하여 다운로드합니다. Windows 환경에서 개발하기 위해 Windows Installer (.msi) 64-bit를 다운로드 합니다. 현재 최신 LTS 버전은 v16.17.0 버전입니다. 다운 받은 인스톨러 파일을 실행해서 설치를 진행합니다. 설치가 완료되면 다음 명령어를 실행해서 확인을 합니다. 12345D\\&gt; node -vv16.17.0D\\&gt; npm -v8.15.0 Node.js를 설치하면 자동으로 NPM 이 설치가 됩니다. npm (노드 패키지 매니저/Node Package Manager)은 자바스크립트 프로그래밍 언어를 위한 패키지 관리자이다. 자바스크립트 런타임 환경 Node.js의 기본 패키지 관리자이다. 출처 : 위키백과 시작 1. 작업 디렉터리 생성 12D:\\&gt; mkdir node_testD:\\&gt; cd node_test 2. 프로젝트 초기화 npm init 명령어를 실행하면 각 항목들을 설정할 수 있는데 아무것도 입력하지 않고 엔터만 치면 괄호안의 기본값 또는 빈값으로 설정이 됩니다. 최종적으로 모든 설정이 끝나면 package.json 파일의 경로와 내용이 출력되고 yes를 입력하게 되면 저장과 동시에 종료됩니다. 1234567891011121314151617181920212223242526272829303132333435D:\\node_test&gt; npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\\node_test\\package.json:&#123; \"name\": \"node_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125;Is this OK? (yes) yesD:\\node_test&gt; 3. 패키지 설치 npm install 명령어를 실행합니다. 1D:\\node_test&gt; npm install 설치된 패키지들은 node_modules 디렉터리에 저장됩니다. 4. 웹 사이트 구축 app.js 파일을 생성합니다. 1D:\\node_test&gt; copy /Y /b NUL app.js 간단하게 Node.js 시작 가이드에 있는 코드를 복사해서 붙여넣습니다. 123456789101112131415// app.jsconst http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 5. 실행 node app.js 명령어를 실행합니다. 12D:\\node_test&gt; node app.jsServer running at http://127.0.0.1:3000/ 실행이 완료되면 서버가 구동이 됩니다. 사이트에 접속하면 Hello World 문자가 출력됩니다. 이로써 Node.js 설치와 초기 설정 및 실행을 완료하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[CentOS] 기본 명령어","slug":"linux-1","date":"2020-09-14T02:21:19.000Z","updated":"2023-03-14T02:19:57.438Z","comments":true,"path":"2020/09/14/linux-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/linux-1/","excerpt":"","text":"기본 명령어 명령어 설명 ll 해당 디렉토리 파일 목록 보기 ls -al 숨김 파일까지 보기 ls -lt 시간순으로 보기 hostname 호스트명 보기 cat [파일명]예) cat /etc/hosts 파일 내용 출력 vi [파일명]예) vi /etc/hosts 파일 내용 편집 mkdir [폴더명] 폴더 생성 touch [파일명] 파일 생성 rm [파일명] 파일 삭제 rm -f [파일명] 묻지 않고 삭제 rm -rf [폴더명] 폴더 삭제 cp [복사대상] [붙여넣을파일명] 파일 복사 cp -r [복사대상] [붙여넣을폴더명] 폴더 복사 mv [파일] [변경할파일] 파일 또는 폴더 이동 pwd 현재 경로 보기 서비스 명령어 설명 systemctl enable [서비스명] 서비스 등록 systemctl start [서비스명] 서비스 시작 systemctl stop [서비스명] 서비스 중지 systemctl restart [서비스명] 서비스 재시작 systemctl status [서비스명] 서비스 상태확인 systemctl list-unit-files | grep [서비스명] 서비스 검색 계정 명령어 설명 su [계정명] 접속 계정 변경 su - 예) su - root 다시 로그인 whoami 접속 사용자 확인 주요 명령어 명령어 설명 ssh 계정@IP주소예) ssh root@192.168.20.25 SSH 접속 scp 파일명 계정@IP주소:폴더위치 예) scp mydb.sql root@192.168.20.24:/home/sql 파일 이동 실시간 명령어 명령어 설명 watch [-d] [-n seconds] ‘command’ 기본 사용 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"}]},{"title":"[PostgreSQL] Command 명령어","slug":"postgresql-3","date":"2020-09-14T01:40:09.000Z","updated":"2023-03-14T02:19:59.865Z","comments":true,"path":"2020/09/14/postgresql-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/postgresql-3/","excerpt":"","text":"명령어 PostgreSQL에 접속합니다. 1$ psql -U postgres 명령어 설명 \\list or \\l 데이터베이스 목록 조회 \\list+ or \\l+ 데이터베이스 목록 상세조회 \\c [DB Name] 다른 DB에 접속 \\d 테이블 목록 보기 \\dt [Table Name] 지정된 테이블 컬럼 목록 보기 \\dS 시스템 테이블 목록 보기 \\dv 뷰 목록 보기 \\ds 시퀀스 목록 보기 \\du 롤 목록 보기 \\dn 스키마 목록 보기 \\q psql 종료(Ctrl + d) 백업 및 복원 명령어 설명 pg_dump &gt; [백업파일명] 전체 백업 pg_dump [DB명] &gt; [백업파일명]예) pg_dump mydb &gt; db.sql 데이터베이스만 백업 psql -U postgres [DB명] &gt; [백업파일명] 데이터베이스만 백업 psql -f [백업파일명] [복원할 DB명]예) psql -f db.sql mydb DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다. psql [복원할 DB명] &lt; [백업파일명]예) psql mydb &lt; db.sql DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[PostgreSQL] 외부 접속 허용 설정","slug":"postgresql-2","date":"2020-09-11T01:20:47.000Z","updated":"2024-01-11T08:23:27.189Z","comments":true,"path":"2020/09/11/postgresql-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/11/postgresql-2/","excerpt":"","text":"외부 접속 허용 설정 1. 사용자 비밀번호 설정 외부에서 접속하기 위해선 우선 postgres 비밀번호를 설정해야 합니다. postgres 계정으로 접속합니다. 1$ su - postgres psql 12345# 비밀번호 설정\\password postgres# 종료\\q 2. 방화벽 개방 방화벽에서 5432 포트를 개방합니다. 12$ firewall-cmd --permanent --zone=public --add-port=5432/tcp$ firewall-cmd --reload 3. 설정 파일 변경 postgresql 접속 후 Data 디렉터리 확인을 할 수 있습니다. 12$ show data_directory;-&gt; /var/lib/pgsql/11/data postgresql.conf 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/postgresql.conf 설정 파일에서 다음과 같이 변경합니다. 12# listen_addresses = 'localhost' -&gt; 주석으로 되어있음listen_addresses = '*' 4. 보안 설정 변경 외부 접속을 위해 보안 설정을 변경합니다. root 계정으로 복귀합니다. 1$ su - root 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/pg_hba.conf 설정 정보를 다음과 같이 변경합니다. 123local all all peer =&gt; local all all md5host all all 127.0.0.1/32 ident =&gt; host all all 0.0.0.0/0 md5host all all ::1/128 ident =&gt; host all all ::1/128 md5 md5 : 패스워드를 md5로 암호화해서 전송 5. 서비스 재시작 1$ sudo systemctl restart postgresql-11 참고 아래 링크에서는 pg_hba.conf를 수정하지 않고 접근제어를 할 수 있도록 하는 방법이 설명되어 있는데 테스트해보진 않았습니다. CentOS 7 에서 방화벽에 PostgreSQL 리스너 포트 등록하기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"외부접속허용","slug":"외부접속허용","permalink":"http://hgko1207.github.io/tags/%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D%ED%97%88%EC%9A%A9/"}]},{"title":"[PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작 방법","slug":"postgresql-1","date":"2020-09-10T09:22:53.000Z","updated":"2024-01-11T08:20:15.500Z","comments":true,"path":"2020/09/10/postgresql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/10/postgresql-1/","excerpt":"","text":"리눅스 환경에서 PostgreSQL 설치 및 시작 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 PostgreSQL 11.9 인터넷이 되는 환경 12345# Install the repository RPM:$ sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm# PostgreSQL을 설치합니다.$ sudo yum install -y postgresql11-server postgresql11-contrib 인터넷이 안 되는 환경 1. RPM 다운로드 외부 환경에서 PostgreSQL Database Server 11 PGDG 페이지에 접속해서 RPM 파일들을 다운로드하고 리눅스 환경으로 이동시킨다. postgresql11-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-contrib-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-libs-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-server-11.9-1PGDG.rhel7.x86_64.rpm 2. 설치 postgresql11-libs -&gt; postgresql11 -&gt; (postgresql11-server, postgresql11-contrib) 순으로 설치합니다. 1234sudo rpm -ivh postgresql11-libs-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-server-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-contrib-11.5-1PGDG.rhel7.x86_64.rpm 설치된 패키지 확인 1$ rpm -qa | grep postgresql 기본 Database 생성 initdb 명령어를 통해 기본 데이터베이스를 설치합니다. 기본 데이터베이스는 postgres라는 이름으로 생성됩니다. 1$ sudo /usr/pgsql-11/bin/postgresql-11-setup initdb 서비스 등록 및 실행 12$ sudo systemctl enable postgresql-11$ sudo systemctl start postgresql-11 postgresql 접속 1$ sudo -u postgres psql 데이터베이스 생성 1postgres=# create database &lt;name&gt; encoding 'utf-8';","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"}]},{"title":"[WPF] Event Notifier 사용 방법","slug":"wpf-1","date":"2020-09-07T01:40:55.000Z","updated":"2024-01-11T08:19:34.038Z","comments":true,"path":"2020/09/07/wpf-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/07/wpf-1/","excerpt":"","text":"컴포넌트 간의 데이터를 주고받을 경우 Prism의 EventAggregator를 사용하면 편리하지만 WPF 만을 사용할 경우 아래 코드와 같이 구성하여 사용하였습니다. Event Manager EventManager.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace Tool.Event&#123; public class EventManager &#123; public delegate void EventHandler(); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish() &#123; event?.Invoke(); &#125; &#125; public class EventManager&lt;T&gt; &#123; public delegate void EventHandler(T item); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish(T item) &#123; event?.Invoke(item); &#125; &#125;&#125; Event Notifier EventNotifier.cs 1234567891011namespace Tool.Event&#123; public class EventNotifier &#123; public static EventManager&lt;string&gt; InputDataEvent = new EventManager&lt;string&gt;(); public static EventManager OpenEvent = new EventManager(); public static EventManager CloseEvent = new EventManager(); &#125;&#125; 사용 예 이벤트 등록 12345678910111213141516namespace Tool.Views&#123; public partial class TestWindow : Window &#123; public TestWindow() &#123; InitializeComponent(); &#125; private void CloseClick(object sender, RoutedEventArgs e) &#123; this.Close(); EventNotifier.CloseEvent.Publish(); &#125; &#125;&#125; 이벤트 받기 123456789101112131415namespace Tool.ViewModwl&#123; public class MainWindowViewModwl &#123; public MainWindow() &#123; EventNotifier.CloseEvent.Subscribe(CloseEvent); &#125; private void CloseEvent() &#123; Console.WriteLine(\"CloseEvent\"); &#125; &#125;&#125; 위의 코드는 다른 Window 에서 창을 종료 시 메인 Window 의 기능을 수행하기 위한 예제입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Event","slug":"Event","permalink":"http://hgko1207.github.io/tags/Event/"}]},{"title":"[Docker] 주요 명령어 및 기본 사용법","slug":"docker-1","date":"2020-09-06T12:57:13.000Z","updated":"2024-01-11T08:18:54.021Z","comments":true,"path":"2020/09/06/docker-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/06/docker-1/","excerpt":"","text":"리눅스 환경에서 Docker 명령어와 기본 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 설치 1$ yum install docker 설치가 완료되면 버전을 조회하여 설치 확인을 합니다. 1$ docker -v 컨테이너 생성 및 실행 docker run 명령어는 컨테이너를 생성 및 실행과 동시에 컨테이너 내부로 들어갑니다. 기본 포맷입니다. 1$ docker run (&lt;옵션&gt;) &lt;이미지 식별자&gt; (&lt;명령어&gt;) (&lt;인자&gt;) 예시입니다. 가독성을 위해 (역슬래시)를 이용해 각 설정 옵션을 구분합니다. 1234567$ docker run -d \\ --name hgko.default.local \\ --privileged \\ -h hgko --network insnet \\ -v /data:/data \\ -p 5914:5901 \\ hgko 간략한 예시입니다. 1$ docker run -d -i -t test /bin/bash Run 옵션 목록 -d : 컨테이너를 백그라운드로 실행해야 할 때 사용 -name : 컨테이너를 식별할 수 있도록 이름을 부여 -h : 컨테이너 호스트 이름 설정 -v : 볼륨 마운트 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 디렉토리 마운트) -p : 포트 연결 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 포트간의 연결) --link : 내부 IP를 알 필요 없이 항상 컨테이너에 별명으로 접근하도록 설정 --privileged : 시스템 내 장치 등 주요 자원에 접근하며 커널의 기능을 대부분 사용할 수 있도록 설정 컨테이너 생성 docker create 명령어는 컨테이너를 생성만 할 뿐 컨테이너 내부로 들어가지 않습니다. 1$ docker create -i -t --name mycentos centos:7 컨테이너 실행 다음 명령어를 실행하여 컨테이너를 시작합니다. 1$ docker start mycentos 컨테이너 내부로 들어갑니다.(단, -i -t 옵션을 사용 했을 때) 1$ docker attach mycentos 컨테이너 내부 셸 사용 mycentos 컨테이너 내부에 bash 프로세스를 실행하고, -i -t 옵션을 사용해서 bash 셸을 쓸 수 있게 유지합니다. 12$ docker exec -i -t mycentos \\bin\\bash$ docker exec -i -t mycentos bash 컨테이너 내부에서 빠져나오기 컨테이너 내부에서 빠져나오는 방법은 두 가지가 있습니다. 첫 번째는 컨테이너 셸에서 exit를 입력하거나 Ctrl + D를 동시에 입력하는 것 입니다. 이 방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지시킵니다. 두 번째는 Ctrl + P, Q를 입력하는 것 입니다. 이 방법은 컨테이너를 정지하지 않고 빠져나옵니다. 컨테이너 확인 정지되지 않은 컨테이너만 출력합니다. 1$ docker ps 정지된 컨테이너를 포함한 모든 컨테이너를 출력합니다. 1$ docker ps -a 출력 결과가 줄바꿈되어 알아보기 힘들 때 --format 옵션을 사용합니다/ 1$ docker ps --format \"table &#123;&#123;.ID&#125;&#125;\\&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\" 특정 컨테이너를 출력합니다. 1$ docker ps | grep mycentos 컨테이너 이름 변경 1$ docker rename mycentos my_centos 컨테이너 삭제 정지된 컨테이너만 삭제 가능합니다. 1$ docker rm mycentos 실행 중인 컨테이너도 삭제 가능합니다. (-f : 강제 삭제) 1$ docker rm -f mycentos 모든 컨테이너 삭제 가능합니다. 1$ docker container prune 이미지 목록 1$ docker images 이미지 삭제 1$ docker rmi &lt;이미지 식별자&gt; 이미지 빌드 1$ docker build -t hgko ./image/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[딥러닝] Preprocess 준비","slug":"ai-preprocess-1","date":"2020-09-01T14:10:35.000Z","updated":"2023-07-18T04:14:09.880Z","comments":true,"path":"2020/09/01/ai-preprocess-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/ai-preprocess-1/","excerpt":"","text":"로컬 데이터를 불러와 전처리시 필요한 내용이다. Load Packages 12345678910import osfrom glob import globimport numpy as npimport tensorflow as tffrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 12345678910# 현재 경로를 알려준다.os.getcwd()# 경로를 넣으면 경로의 파일명만 목록 형식으로 보여준다.os.listdir()os.listdir('dataset/mnist_png/training/')# 경로가 포함된 모든 파일들을 목록 형식으로 보여준다.# 원하는 포맷의 파일만을 가져올 수 있습니다.(png, txt 등)glob('dataset/mnist_png/training/*.png') 데이터 분석 123456label_nums = os.listdir('dataset/mnist_png/training/')&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']# Label 데이터 갯수 확인len(label_nums)&gt; 10 데이터 별 갯수 비교 1234567nums_dataset = []for lbl_n in label_nums: data_per_class = os.listdir('../dataset/mnist_png/training/' + lbl_n) nums_dataset.append(len(data_per_class))&gt; [5923, 6742, 5958, 6131, 5842, 5421, 5918, 6265, 5851, 5949] TensorFlow로 열기 12gfile = tf.io.read_file(path)image = tf.io.decode_image(gfile) 데이터 이미지 사이즈 알기 123456789101112from tqdm import tqdm_notebookheights = []widths = []for path in tqdm_notebook(data_paths): image_pil = Image.open(path) image = np.array(image_pil) h, w = image.shape heights.append(h) widths.append(w)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[C++] DLL 동적 로딩","slug":"cpp-coding-2","date":"2020-09-01T09:46:17.000Z","updated":"2023-07-18T04:14:41.812Z","comments":true,"path":"2020/09/01/cpp-coding-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/cpp-coding-2/","excerpt":"","text":"DLL 동적 로딩 특정 폴더 내에 다수의 DLL 라이브러리 파일들을 로딩하기 위한 코드다. Header 파일 1234567891011121314151617181920// dllload.h#include &lt;iostream&gt;class DLLLoad&#123;public: DLLLoad() &#123;&#125; ~DLLLoad() &#123;&#125; bool LoadLibrary(); bool FreeLibrary();private: // DLL 폴더 경로를 설정한다. const std::string DLL_DIR; // 로딩된 DLL 파일 경로들을 저장하고 관리한다. std::list&lt;std::string&gt; fileList;&#125; C++ 파일 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// dllload.cpp#include \"dllload.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;const std::string DLLLoad::DLL_DIR = \"C:\\\\dll\\\\\";DLLLoad::DLLLoad() &#123;&#125;DLLLoad::~DLLLoad() &#123;&#125;// DLL 라이브러리들을 동적 로딩한다.bool DLLLoad::LoadLibrary()&#123; // 처음 DLL 로드 이후에는 다시 로드하지 않는다. if (fileList.size() == 0) &#123; std::string input = DLL_DIR + \"*.dll\"; WIN32_FIND_DATA FindData; HANDLE hFind = FindFirstFile(input.c_str(), &amp;FindData); if (hFind == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; \"Error - Can't find a file : \" &lt;&lt; FindData.cFileName &lt;&lt; std::endl; return false; &#125; do &#123; if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_ARCHIVE) // 파일만 검색 &#123; std::string dir = CSM_DLL_DIR + FindData.cFileName; HINSTANCE hmodule = LoadLibrary(dir.c_str()); if (hmodule != NULL) &#123; fileList.push_back(dir); &#125; &#125; &#125; while (FindNextFile(hFind, &amp;FindData) != 0); FindClose(hFind); &#125; return true;&#125;// 로딩된 DLL 라이브러리들을 해제한다.bool DLLLoad::FreeLibrary()&#123; for (std::string file : fileList) &#123; HINSTANCE hmodule = GetModuleHandle(file.c_str()); if (hmodule != NULL) &#123; FreeLibrary(hmodule); &#125; &#125; return true;&#125; Main 함수 123456int main()&#123; DLLLoad dllLoad = new DLLLoad(); dllLoad-&gt;LoadLibrary(); dllLoad-&gt;FreeLibrary();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[MSSQL] Geometry Query","slug":"mssql-1","date":"2020-09-01T08:38:30.000Z","updated":"2023-03-14T02:19:43.856Z","comments":true,"path":"2020/09/01/mssql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/mssql-1/","excerpt":"","text":"Geometry 데이터 형식 쿼리 STContains STContains(geometry 데이터 형식) geometry 인스턴스에 다른 geometry 인스턴스가 완전히 포함되어 있으면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STContains(@h); POINT 좌표가 POLYGON 좌표에 완전히 포함되어 있지 않기 때문에 결과는 0을 반환합니다. STIntersects STIntersects(geometry 데이터 형식) geometry 인스턴스가 다른 geometry 인스턴스와 교차하면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STIntersects(@h); POINT 좌표가 POLYGON 좌표와 교차하기 때문에 결과는 1을 반환합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"}]},{"title":"[딥러닝] 교육자료","slug":"ai-deep-1","date":"2020-08-21T08:24:38.000Z","updated":"2023-07-18T04:13:41.727Z","comments":true,"path":"2020/08/21/ai-deep-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/ai-deep-1/","excerpt":"","text":"딥러닝 교육자료 딥러닝을 배우기 위한 강의 사이트와 책을 정리하였다. 교육 사이트 프로그래머스 - https://programmers.co.kr/ 에드윗 - https://www.edwith.org/ 입문 강의 파이썬 입문 - https://programmers.co.kr/learn/courses/2 딥러닝 입문(Tensorflow) - https://www.edwith.org/others26 입문 블로그 딥러닝 입문(Keras) - https://tykimos.github.io/lecture/ 딥러닝 책 밑바닥부터 시작하는 딥러닝(기초) DeepLearningBook(심화) 머신러닝 책 핸즈온 머신러닝(심화) PRML(심화)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[Web Design] Canvas","slug":"web-design-1","date":"2020-08-21T07:59:04.000Z","updated":"2023-07-18T04:13:52.343Z","comments":true,"path":"2020/08/21/web-design-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/web-design-1/","excerpt":"","text":"HTML 템플릿 회사 홈페이지 및 블로그 형태의 사이트 제작 요청이 있어 디자인 템플릿을 찾아보던 중 심플하기도 하고 이쁜 HTML 템플릿을 찾게 되었다. Canvas The Multi-Purpose HTML5 Template Canvas는 Mulit-Page 및 One-Page 사이트를 제공하고 반응형을 지원하는 다목적 HTML5 템플릿이다. 비즈니스, 의료, SEO, 여행, 건설, 부동산, 요가, 뷰티, 기사, 사진, 뉴스, 대여, 이력서, 블로그, 웨딩, 음악, 앱 쇼케이스, 애완 동물, 스토어 등 120개 이상의 즉시 사용 가능한 홈페이지 템플릿을 제공합니다. 유료 이지만 가격도 저렴해서 가성비가 좋다. 빠르게 개발을 해야 하거나 디자인 비용을 절감해야 할 때 사용하면 좋은 사이트를 제작할 수 있을 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"}]},{"title":"TensorFlow 2.0과 PyTorch 비교","slug":"ai-dev-8","date":"2020-08-13T07:36:58.000Z","updated":"2023-03-14T02:19:19.731Z","comments":true,"path":"2020/08/13/ai-dev-8/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-dev-8/","excerpt":"","text":"TensorFlow 2.0 123import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Hyperparameter 1234567batch_size = 64learning_rate = 0.001dropout_rate = 0.7input_shape = (28, 28, 1)num_classes = 10 Preprocess 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Build Model 1234567891011121314151617181920212223inputs = layers.Input(input_shape)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(dropout_rate)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), # Optimization loss='sparse_categorical_crossentropy', # Loss Function metrics=['accuracy']) # Metrics / Accuracy Training 1234567model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# OutTrain on 60000 samples60000/60000 [==============================] - 6s 103us/sample - loss: 0.3794 - accuracy: 0.8767 12model.evaluate(test_x, test_y, batch_size=batch_size)=&gt; [0.06760077927671373, 0.9776] PyTorch 12345678import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optim# 이미지 데이터를 관리하기 위한 라이브러리from torchvision import datasets, transforms Hyperparameter 12345678910111213# 랜덤 값을 고정시키기 위해seed = 1lr = 0.001momentum = 0.5batch_size = 64test_batch_size = 64epochs = 5no_cuda = Falselog_interval = 100 Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Preprocess 12345678910111213141516171819202122torch.manual_seed(seed)use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")kwargs = &#123;'num_workers': 1, 'pin_memory': True&#125; if use_cuda else &#123;&#125;train_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True, **kwargs)test_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True, **kwargs) Optimization 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=lr, momentum=momentum) Training 12345678910111213141516171819202122232425262728293031323334for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() # backpropagation 계산하기 전에 0으로 기울기 계산 output = model(data) loss = F.nll_loss(output, target) # https://pytorch.org/docs/stable/nn.html#nll-loss loss.backward() # 계산한 기울기를 optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) # Test mode model.eval() # batch norm이나 dropout 등을 train mode 변환 test_loss = 0 correct = 0 with torch.no_grad(): # autograd engine, 즉 backpropagatin이나 gradient 계산 등을 꺼서 memory usage를 줄이고 속도를 높임 for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() # sum up batch loss pred = output.argmax(dim=1, keepdim=True) # get the index of the max log-probability correct += pred.eq(target.view_as(pred)).sum().item() # pred와 target과 같은지 확인 test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) 결과 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Train Epoch: 1 [0/60000 (0%)] Loss: 2.300039Train Epoch: 1 [6400/60000 (11%)] Loss: 2.239658Train Epoch: 1 [12800/60000 (21%)] Loss: 2.133953Train Epoch: 1 [19200/60000 (32%)] Loss: 2.007281Train Epoch: 1 [25600/60000 (43%)] Loss: 1.656340Train Epoch: 1 [32000/60000 (53%)] Loss: 1.400340Train Epoch: 1 [38400/60000 (64%)] Loss: 0.864186Train Epoch: 1 [44800/60000 (75%)] Loss: 0.613089Train Epoch: 1 [51200/60000 (85%)] Loss: 0.615066Train Epoch: 1 [57600/60000 (96%)] Loss: 0.427881Test set: Average loss: 0.4822, Accuracy: 8651/10000 (87%)Train Epoch: 2 [0/60000 (0%)] Loss: 0.635855Train Epoch: 2 [6400/60000 (11%)] Loss: 0.361398Train Epoch: 2 [12800/60000 (21%)] Loss: 0.457372Train Epoch: 2 [19200/60000 (32%)] Loss: 0.393982Train Epoch: 2 [25600/60000 (43%)] Loss: 0.536390Train Epoch: 2 [32000/60000 (53%)] Loss: 0.258121Train Epoch: 2 [38400/60000 (64%)] Loss: 0.413061Train Epoch: 2 [44800/60000 (75%)] Loss: 0.174248Train Epoch: 2 [51200/60000 (85%)] Loss: 0.222638Train Epoch: 2 [57600/60000 (96%)] Loss: 0.401988Test set: Average loss: 0.2956, Accuracy: 9128/10000 (91%)Train Epoch: 3 [0/60000 (0%)] Loss: 0.425370Train Epoch: 3 [6400/60000 (11%)] Loss: 0.242881Train Epoch: 3 [12800/60000 (21%)] Loss: 0.266271Train Epoch: 3 [19200/60000 (32%)] Loss: 0.344442Train Epoch: 3 [25600/60000 (43%)] Loss: 0.271553Train Epoch: 3 [32000/60000 (53%)] Loss: 0.233463Train Epoch: 3 [38400/60000 (64%)] Loss: 0.206387Train Epoch: 3 [44800/60000 (75%)] Loss: 0.289864Train Epoch: 3 [51200/60000 (85%)] Loss: 0.227708Train Epoch: 3 [57600/60000 (96%)] Loss: 0.266247Test set: Average loss: 0.2279, Accuracy: 9320/10000 (93%)Train Epoch: 4 [0/60000 (0%)] Loss: 0.197864Train Epoch: 4 [6400/60000 (11%)] Loss: 0.334545Train Epoch: 4 [12800/60000 (21%)] Loss: 0.171417Train Epoch: 4 [19200/60000 (32%)] Loss: 0.261458Train Epoch: 4 [25600/60000 (43%)] Loss: 0.129152Train Epoch: 4 [32000/60000 (53%)] Loss: 0.129057Train Epoch: 4 [38400/60000 (64%)] Loss: 0.203361Train Epoch: 4 [44800/60000 (75%)] Loss: 0.304724Train Epoch: 4 [51200/60000 (85%)] Loss: 0.136878Train Epoch: 4 [57600/60000 (96%)] Loss: 0.171525Test set: Average loss: 0.1808, Accuracy: 9482/10000 (95%)Train Epoch: 5 [0/60000 (0%)] Loss: 0.199721Train Epoch: 5 [6400/60000 (11%)] Loss: 0.246554Train Epoch: 5 [12800/60000 (21%)] Loss: 0.217517Train Epoch: 5 [19200/60000 (32%)] Loss: 0.255912Train Epoch: 5 [25600/60000 (43%)] Loss: 0.182075Train Epoch: 5 [32000/60000 (53%)] Loss: 0.296272Train Epoch: 5 [38400/60000 (64%)] Loss: 0.283726Train Epoch: 5 [44800/60000 (75%)] Loss: 0.239351Train Epoch: 5 [51200/60000 (85%)] Loss: 0.293096Train Epoch: 5 [57600/60000 (96%)] Loss: 0.157650Test set: Average loss: 0.1533, Accuracy: 9581/10000 (96%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Evaluating 및 Predicting","slug":"ai-pytorch-5","date":"2020-08-13T07:11:54.000Z","updated":"2023-07-18T04:13:35.982Z","comments":true,"path":"2020/08/13/ai-pytorch-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-5/","excerpt":"","text":"이전 블로그를 이어서 진행해본다. Evaluation model.train() 모드로 변한 것 처럼 평가할 때는 model.eval() 으로 설정한다. 1234567891011# Test mode# batch norm이나 dropout 등을 train mode 변환model.eval()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) torch.no_grad() 함수는 autograd engine, 즉 backpropagatin 이나 기울기 계산 등을 꺼서 memory usage 를 줄이고 속도를 높인다. 12345678910111213141516171819test_loss = 0correct = 0with torch.no_grad(): data, target = next(iter(test_loader)) data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct = pred.eq(target.view_as(pred)).sum().item()# Outtest_loss : 29.74889373779297correct : 54test_loss /= len(test_loader.dataset)=&gt; 0.0029748893737792967 정리 1234567891011121314151617181920model.eval()test_loss = 0correct = 0with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item()test0_loss /= len(test_loader.dataset)print('\\nTest set: Average Loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset)))# OutTest set: Average Loss: 0.4799, Accuracy: 8660/10000 (87%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Optimizer 및 Training","slug":"ai-pytorch-4","date":"2020-08-13T04:48:37.000Z","updated":"2023-07-18T04:13:15.068Z","comments":true,"path":"2020/08/13/ai-pytorch-4/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-4/","excerpt":"","text":"Optimization &amp; Training https://github.com/pytorch/examples/tree/master/mnist Load Packages 1234567import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsimport numpy as np 1234567no_cuda = False# cuda를 사용할지 안할지use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")=&gt; device(type='cuda') Preprocess 12345678910111213141516171819202122seed = 1batch_size = 64test_batch_size = 64torch.manual_seed(seed)train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True) Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Optimization Model과 Optimization를 설정한다. SGD 사용 확률적 경사 하강법(Stochastic Gradient Descent, SGD) 옵티마이저 Lr(learning Rate) : 0 보다 크거나 같은 float 값. 학습률 momentum: 0 보다 크거나 같은 float 값. SGD를 적절한 방향으로 가속화하며, 흔들림(진동)을 줄여주는 매개변수 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.5) parameters를 확인합니다. 12345678910111213params = list(model.parameters())for i in range(8): print(params[i].size())# Weight, Bais를 순서대로 보여준다.torch.Size([20, 1, 5, 5])torch.Size([20])torch.Size([50, 20, 5, 5])torch.Size([50])torch.Size([500, 800])torch.Size([500])torch.Size([10, 500])torch.Size([10]) Before Training 학습하기 전에 Model이 Train할 수 있도록 Train Mode로 변환한다. Convolution 또는 Linear 뿐만 아니라, DropOut과 Batch Normalization과 같이 parameter를 가진 Layer들도 학습하기 위해 준비한다. 12345678910# train modemodel.train()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) 모델에 넣기 위한 첫 Batch 데이터를 추출하고 cpu 또는 gpu device에 컴파일한다. 12345data, target = next(iter(train_loader))data, target = data.to(device), target.to(device)data.shape, target.shape=&gt; (torch.Size([64, 1, 28, 28]), torch.Size([64])) 기울기(gradients)를 clear해서 새로운 최적화 값을 찾기 위해 준비한다. 그리고 준비한 데이터를 model에 넣어 output을 얻습니다. Model에서 예측한 결과를 Loss Function에 넣는다. 12345optimizer.zero_grad()output = model(data)# Negative Log-Likelihood Loss 사용loss = F.nll_loss(output, target) Back Propagation을 통해 기울기를 계산한다. 계산된 기울기는 Parameter에 업데이트를 한다. 1234# 기울기 계산loss.backward()# Updateoptimizer.step() Start Training 위의 최적화 과정을 반복하여 학습을 시작한다. 12345678910111213141516171819202122232425262728293031epochs = 1log_interval = 100for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100 * batch_idx / len(train_loader), loss.item() ))# OutTrain Epoch: 1 [0/60000 (0%)] Loss: 2.290735Train Epoch: 1 [6400/60000 (11%)] Loss: 2.228956Train Epoch: 1 [12800/60000 (21%)] Loss: 2.121080Train Epoch: 1 [19200/60000 (32%)] Loss: 1.893549Train Epoch: 1 [25600/60000 (43%)] Loss: 1.570034Train Epoch: 1 [32000/60000 (53%)] Loss: 1.213198Train Epoch: 1 [38400/60000 (64%)] Loss: 0.993993Train Epoch: 1 [44800/60000 (75%)] Loss: 0.778737Train Epoch: 1 [51200/60000 (85%)] Loss: 0.732925Train Epoch: 1 [57600/60000 (96%)] Loss: 0.624502","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 각 Layer별 역할 및 파라미터","slug":"ai-pytorch-3","date":"2020-08-13T02:31:56.000Z","updated":"2023-07-18T04:12:30.053Z","comments":true,"path":"2020/08/13/ai-pytorch-3/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-3/","excerpt":"","text":"PyTorch Layer 이해하기 Load Packages 123456import torchfrom torchvision import datasets, transformsimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline 예제 불러오기 1234567891011train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor() ])), batch_size=1)image, label = next(iter(train_loader))image.shape, label.shape=&gt; (torch.Size([1, 1, 28, 28]), torch.Size([1])) 12plt.imshow(image[0, 0, :, :], 'gray')plt.show() 각 Layer별 설명 Network 쌓기 위한 준비를 합니다. 123import torchimport torch.nn as nnimport torch.nn.functional as F Convolution in_channels : 받게 될 channel의 갯수 out_channels : 보내고 싶은 channel의 갯수 kernel_size : 만들고 싶은 kernel(weights)의 사이즈 1234# Device type : cpu, cuda, mkldnn, opengl, opencl, ideep, hip, msnpulayer = nn.Conv2d(in_channels=1, out_channels=20, kernel_size=5, stride=1).to(torch.device('cpu'))=&gt; Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) weight 시각화를 위해 slice하고 numpy화 합니다. 1234weight = layer.weightweight.shape=&gt; torch.Size([20, 1, 5, 5]) 여기서 weight는 학습 가능한 상태이기 때문에 바로 numpy로 뽑아낼 수 없다. detach() method는 그래프에서 잠깐 꺼내서 gradient에 영향을 받지 않게 한다. 1234weight = weight.detach().numpy()weight.shape=&gt; (20, 1, 5, 5) 123plt.imshow(weight[0, 0, :, :], 'jet')plt.colorbar()plt.show() output 시각화 준비를 위해 numpy화 합니다. 123456output_data = layer(image)output_data = output_data.dataoutput = output_data.cpu().numpy()output.shape=&gt; (1, 20, 24, 24) input으로 들어간 이미지 numpy화 한다. 1234image_arr = image.numpy()image_arr.shape=&gt; (1, 1, 28, 28) 1234567891011plt.figure(figsize=(15, 30))plt.subplot(131)plt.title('Input')plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(132)plt.title('Weight')plt.imshow(weight[0, 0, :, :], 'jet')plt.subplot(133)plt.title('Output')plt.imshow(output[0, 0, :, :], 'gray')plt.show() Pooling input을 먼저 앞에 넣고, 뒤어 kernel 사이즈와 stride를 순서대로 넣는다. 1234pool = F.max_pool2d(image, 2, 2)pool.shape=&gt; torch.Size([1, 1, 14, 14]) MaxPool Layer는 weight가 없기 때문에 바로 numpy() 사용 가능하다. 1234pool_arr = pool.numpy()pool_arr.shape, image_arr.shape=&gt; ((1, 1, 14, 14), (1, 1, 28, 28)) 12345678plt.figure(figsize=(10, 15))plt.subplot(121)plt.title(\"Input\")plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(122)plt.title('Output')plt.imshow(np.squeeze(pool_arr), 'gray')plt.show() Linear nn.Linear는 2D가 아닌 1D만 들어가기 때문에 view() 함수를 사용하여 1D로 펼쳐줘야 한다. 12345# image size가 28 이기 때문에 28 * 28을 넣는다.flatten = image.view(1, 28 * 28)flatten.shape=&gt; torch.Size([1, 784]) 123456789lin = nn.Linear(784, 10)(flatten)lin.shape=&gt; torch.Size([1, 10])lin=&gt; tensor([[-0.1198, 0.2404, -0.0522, -0.3474, -0.3997, -0.0318, -0.0630, 0.2680, 0.1849, 0.1000]], grad_fn=&lt;AddmmBackward&gt;) 12plt.imshow(lin.detach().numpy(), 'jet')plt.show() Softmax 결과를 numpy로 꺼재기 위해선 weight가 담긴 Linear에 weight를 꺼줘야 한다. 123456789with torch.no_grad(): flatten = image.view(1, 28 * 28) lin = nn.Linear(784, 10)(flatten) softmax = F.softmax(lin, dim=1)softmax=&gt; tensor([[0.0846, 0.1084, 0.0792, 0.1265, 0.1004, 0.0897, 0.0990, 0.1113, 0.1239, 0.0769]]) 12np.sum(softmax.numpy())=&gt; 0.99999994 Layer 쌓기 예제 출처 : https://pytorch.org/tutorials/beginner/pytorch_with_examples.html#id23 nn 과 nn.functional의 차이점 nn은 학습 파라미터가 담긴 것 nn.functional은 학습 파라미터가 없는 것 123456789101112131415161718192021class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): # Feature Extraction x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) # Fully Connected (Classficiation) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) image를 Model에 넣어서 결과를 확인한다. 12345model = Net()result = model.forward(image)=&gt; tensor([[-2.3262, -2.2901, -2.2722, -2.2262, -2.3148, -2.3693, -2.2773, -2.2977, -2.3222, -2.3371]], grad_fn=&lt;LogSoftmaxBackward&gt;)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 데이터 불러오기","slug":"ai-pytorch-2","date":"2020-08-13T01:14:45.000Z","updated":"2023-07-18T04:11:52.897Z","comments":true,"path":"2020/08/13/ai-pytorch-2/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-2/","excerpt":"","text":"PyTorch Data Preprocess 12import torchfrom torchvision import datasets, transforms Import Error 1ImportError: cannot import name 'PILLOW_VERSION' from 'PIL' pillow 버전이 7.0.0 이상 일경우 Import 에러 나는 경우가 있다. 아래 처럼 pillow 버전을 내려주면 해결이 된다. 1$ pip install pillow==6.2.2 Data Loader 부르기 Pytorch는 DataLoader를 불러 model에 넣는다. 12345678910batch_size = 32train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset/', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize(mean=(0.5,), std=(0.5,)) ])), batch_size=batch_size, shuffle=True) 12345678910test_batch_size = 32test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5)) ])), batch_size=test_batch_size, shuffle=True) 첫번째 iteration에서 나오는 데이터 확인 1234images, labels = next(iter(train_loader))image.shape, label.shape=&gt; torch.Size([32, 1, 28, 28]), torch.Size([32]) 데이터 시각화 123import numpy as npimport matplotlib.pyplot as plt%matplotlib inline 12345# squeeze() 함수는 차원의 원소가 1인 차원을 없애준다.torch_image = torch.squeeze(images[0])torch_image.shape=&gt; torch.Size([28, 28]) 1234image = torch_image.numpy()image.shape=&gt; (28, 28) 123plt.title(label)plt.imshow(image, 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[JavaScript] DataTables 사용 방법","slug":"js-dev-1","date":"2020-08-12T04:24:43.000Z","updated":"2024-01-11T08:16:36.394Z","comments":true,"path":"2020/08/12/js-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/12/js-dev-1/","excerpt":"","text":"JQuery 용 테이블 라이브러리인 DataTables 플러그인을 사용하여 개발했을 경우 편리하게 사용하기 위해 구조를 설계하였습니다. DataTables는 데이터를 테이블로 쉽게 구현할 수 있도록 도와주는 라이브러리입니다. 설치와 사용법은 DataTables 공식 사이트에 잘 설명되어 있기 때문에 생략하겠습니다. 초기 설정 여러 곳에서 DataTables로 작업할 때 유용하도록 초기 기본값으로 설정하였습니다. 12345678910111213141516171819202122232425// table.js$.extend($.fn.dataTable.defaults, &#123; autoWidth: false, dom: `&lt;'row'&lt;'col-sm-12'tr&gt;&gt;&lt;'row'&lt;'col-sm-12 col-md-5'i&gt;` + `&lt;'col-sm-12 col-md-7 dataTables_pager'lp&gt;&gt;`, language: &#123; emptyTable: '데이터가 없습니다.', infoEmpty: '', info: ' _TOTAL_ 개의 데이터가 있습니다.', search: '&lt;span&gt;검색 :&lt;/span&gt; _INPUT_', searchPlaceholder: '내용 입력...', lengthMenu: 'Display _MENU_', paginate: &#123; first: 'First', last: 'Last', next: $('html').attr('dir') == 'rtl' ? '&amp;larr;' : '&amp;rarr;', previous: $('html').attr('dir') == 'rtl' ? '&amp;rarr;' : '&amp;larr;', &#125;, &#125;, // 검색 기능 숨기기 searching: false, // 표시 건수기능 숨기기 lengthChange: false, // 한 페이지에 표시되는 Row 수 pageLength: 10,&#125;); 기본 구조 기본 구조를 설계하여 다른 파일에서 공통으로 사용할 수 있도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// table.jsconst Datatables = &#123; // 기본 테이블 구조 basic: function (id, tableOption, info) &#123; let table = $(id).DataTable(&#123; // 반응형 테이블 설정 responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, order: [[0, 'asc']], &#125;); return table; &#125;, // 정렬하는 컬럼을 설정하도록 order: function (id, tableOption, num, info) &#123; let table = $(id).DataTable(&#123; responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, columnDefs: [ &#123; orderable: true, className: 'reorder', targets: 0 &#125;, &#123; orderable: true, className: 'reorder', targets: num &#125;, &#123; orderable: false, targets: '_all' &#125;, ], order: [[num, 'desc']], &#125;); return table; &#125;, // 데이터 추가 rowsAdd: function (table, url, param) &#123; table.clear(); $.ajax(&#123; url: url, type: 'POST', data: JSON.stringify(param), contentType: 'application/json', success: function (data) &#123; table.rows.add(data).draw(); // 반응형 테이블 사용 table.responsive.recalc(); &#125;, &#125;); &#125;, // 새로고침 refresh: function (table, data) &#123; table.clear(); table.rows.add(data).draw(); &#125;,&#125;; 사용 예제 예를 들어 공지사항 테이블을 만들어 보겠습니다. 1234567891011121314151617&lt;!-- notice.html --&gt;&lt;table class=\"table\" id=\"noticeTable\"&gt; &lt;thead class=\"text-center\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;작성시간&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=\"text-center\"&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;!-- thymeleaf 사용 --&gt;&lt;script th:src=\"@&#123;/js/table.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/notice.js&#125;\"&gt;&lt;/script&gt; table 태그의 id를 설정하고 위에서 설정한 Datatables.order 함수를 통해 DataTables을 생성하였습니다. 123456789101112131415161718192021222324252627282930313233// notice.jsconst dataTable = &#123; ele: '#noticeTable', table: null, option: &#123; columns: [ &#123; data: null, render: function (data, type, row, meta) &#123; return meta.row + 1; &#125;, &#125;, &#123; data: 'title' &#125;, &#123; data: 'userId' &#125;, &#123; data: 'createDate' &#125;, &#123; data: 'hit' &#125;, ], &#125;, init: function () &#123; // DataTables 생성 this.table = Datatables.order(this.ele, this.option, 3); this.search(); &#125;, search: function () &#123; const param = new Object(); // 조회 조건에 따라 데이터를 조회해서 DataTables에 넣는다. Datatables.rowsAdd(this.table, contextPath + '/notice/search', param); &#125;,&#125;;$(document).ready(function () &#123; dataTable.init();&#125;); 결과 DataTables 라이브러리를 사용하여 구현해 봤습니다. 여러 프로젝트에서 공통으로 사용하기 위해 정리를 하였는데 개선사항이 있으면 추가할 예정입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"}]},{"title":"[MySQL] Packet for query is too large 에러 발생시","slug":"mysql-1","date":"2020-08-10T06:14:27.000Z","updated":"2024-01-11T08:15:37.599Z","comments":true,"path":"2020/08/10/mysql-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/10/mysql-1/","excerpt":"","text":"MySQL을 사용하여 개발 중 4MB가 넘는 파일을 업로드 시 다음과 같은 패킷 에러가 발생하였다. 1com.mysql.jdbc.PacketTooBigException: Packet for query is too large (9,523,277 &gt; 4,194,304). You can change this value on the server by setting the 'max_allowed_packet' variable 기본적으로 할당된 패킷 사이즈 값이 너무 작기 때문에 에러가 발생했기 때문에 수정이 필요하다. MySQL 설정에서 max_allowed_packet 값을 변경하여 해결하였다. max_allowed_packet은 서버로 질의하거나 받게 되는 패킷의 최대 길이를 나타내는 시스템 변수 다음은 해결방법에 대해 알아보겠다. 1) MySQL 커맨드 라인에서 변경 먼저 MySQL 에 접속한다. 1$ mysql -u root -p **** 12345678910111213141516mysql&gt; show variables;## 1024 * 1024 * 32 -&gt; 32MBmysql&gt; SET GLOBAL max_allowed_packet = 33554432;Query OK, 0 rows affected (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables where Variable_name = 'max_allowed_packet';+--------------------+----------+| Variable_name | Value |+--------------------+----------+| max_allowed_packet | 33554432 |+--------------------+----------+1 row in set (0.01 sec) 2) 설정파일 변경 /etc/my.cnf 설정파일 내의 값을 변경한다. 1$ vi /etc/my.cnf 12# 없을 시 추가한다.max_allowed_packet=32M 3) MySQL 재시작 다음 명령어를 사용여 MySQL를 재시작한다. 12345678# 우분투$ service mysql restart# CentOS6$ service mysqld restart# CentOS7$ systemctl restart mysqld","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[JAVA] 동네예보 조회서비스 API 사용 방법","slug":"java-dev-5","date":"2020-08-06T06:13:50.000Z","updated":"2024-01-11T08:15:09.635Z","comments":true,"path":"2020/08/06/java-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/06/java-dev-5/","excerpt":"","text":"동네예보 조회서비스 동네예보 정보를 조회하기 위해 공공데이터 포털 사이트의 동네예보 조회서비스 API 사용 방법에 대해 알아보겠습니다. Open API 활용 방법 동네예보 조회서비스 사이트에서 활용신청을 하고 Service Key를 발급받는다. 오픈 API 활용 가이드를 다운로드하여 조회 조건 및 결과 데이터를 이해한다. 동네예보 데이터 조회 1http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst?ServiceKey=&#123;발급받은 Service Key&#125;&amp;pageNo=1&amp;numOfRows=10&amp;dataType=JSON&amp;base_date=&#123;현재날짜&#125;&amp;base_time=&#123;현재시간&#125;&amp;nx=&#123;지점 X 좌표값&#125;&amp;ny=&#123;지점 Y 좌표값&#125; 결과 데이터(JSON 형식) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#123; \"response\": &#123; \"header\": &#123; \"resultCode\": \"00\", \"resultMsg\": \"NORMAL_SERVICE\" &#125;, \"body\": &#123; \"dataType\": \"JSON\", \"items\": &#123; \"item\": [ &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"POP\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"80\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"PTY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"R06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"9\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"REH\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"85\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"S06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"SKY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"4\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"T3H\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"24\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"UUU\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"-1.1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VEC\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"127\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VVV\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0.9\", \"nx\": 76, \"ny\": 122 &#125; ] &#125;, \"pageNo\": 1, \"numOfRows\": 10, \"totalCount\": 216 &#125; &#125;&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 조회 서비스 마다 결과 데이터의 items 부분이 다르므로 기본 구조 도메인과 Item 도메인을 분리해서 생성하였다. 12345678import lombok.Data;@Datapublic class ApiData &#123; private Response response;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.List;import lombok.Data;@Datapublic class Response &#123; private Header header; private Body body; @Data public static class Header &#123; private int resultCode; private String resultMsg; &#125; @Data public static class Body &#123; /** 데이터 타입 */ private String dataType; /** 한 페이지 결과 수 */ private int numOfRows; /** 페이지 번호 */ private int pageNo; /** 전체 결과 수 */ private int totalCount; private Items items; &#125; @Data public static class Items &#123; private List&lt;VilageFcst&gt; item; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import lombok.Data;/** * 동네예보 서비스 도메인 * * @author hgko * */@Datapublic class VilageFcst &#123; /** 발표일자 */ private String baseDate; /** 발표시각 */ private String baseTime; /** 예보일자 */ private String fcstDate; /** 예보시각 */ private String fcstTime; /** 자료구분문자 */ private CategoryType category; /** 예보 값 */ private float fcstValue; /** 예보지점 X 좌표 */ private float nx; /** 예보지점 Y 좌표 */ private float ny; /** * 코드값 정보 */ @Getter public enum CategoryType &#123; POP(\"강수확률\", \"강수확률\"), R06(\"6시간 강수량\", \"범주 (1 mm)\"), S06(\"6시간 신적설\", \"범주 (1 cm)\"), SKY(\"하늘상태\", \"코드값\"), T3H(\"3시간 기온\", \"℃\"), TMN(\"아침 최저기온\", \"℃\"), TMX(\"낮 최저기온\", \"℃\"), WAV(\"파고\", \"M\"), T1H(\"기온\", \"℃\"), RN1(\"1시간 강수량\", \"mm\"), UUU(\"동서바람성분\", \"m/s\"), VVV(\"남북바람성분\", \"m/s\"), REH(\"습도\", \"%\"), PTY(\"강수형태\", \"코드값\"), VEC(\"풍향\", \"m/s\"), WSD(\"풍속\", \"1\"); private String name; private String unit; private CategoryType(String name, String unit) &#123; this.name = name; this.unit = unit; &#125; &#125;&#125; 2) 데이터 조회 데이터 조회 시 주의해야 할 점은 시간을 3시간 단위로 설정해야 한다. 오전 02시부터 3시간 단위로 증가해서 시간을 설정한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final String BASE_URL = \"http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst\";private final String serviceKey = \"\"; /*공공데이터포털에서 받은 인증키*/public void getVilageFcst() &#123; try &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); urlBuilder.append(\"?\" + URLEncoder.encode(\"ServiceKey\", \"UTF-8\") + \"=\" + serviceKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"pageNo\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"numOfRows\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"10\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"dataType\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"JSON\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_date\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"20200807\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_time\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1100\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"nx\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"76\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"ny\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"122\", \"UTF-8\")); URL url = new URL(urlBuilder.toString()); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Content-type\", \"application/json\"); System.out.println(\"Response code: \" + conn.getResponseCode()); if (conn.getResponseCode() &gt;= 200 &amp;&amp; conn.getResponseCode() &lt;= 300) &#123; StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); in.lines().forEach(line -&gt; &#123; sb.append(line); &#125;); in.close(); conn.disconnect(); System.out.println(sb.toString()); setWeatherInfo(sb.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 동네예보 데이터 파싱 * @param json */private void setWeatherInfo(String json) &#123; try &#123; ObjectMapper objectMapper = new ObjectMapper(); ApiData data = objectMapper.readValue(json, ApiData.class); Items items = data.getResponse().getBody().getItems(); for (VilageFcst item : items.getItem()) &#123; if (item.getCategory() == CategoryType.T3H) &#123; &#125; else if (item.getCategory() == CategoryType.REH) &#123; &#125; else if (item.getCategory() == CategoryType.SKY) &#123; &#125; else if (item.getCategory() == CategoryType.PTY) &#123; &#125; &#125; &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 동네예보 데이터들이 조회되면 데이터들을 가공해서 사용하도록 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"}]},{"title":"[JAVA] 농업기상정보 서비스 API 사용 방법","slug":"java-dev-4","date":"2020-07-31T06:07:15.000Z","updated":"2024-01-11T08:11:35.832Z","comments":true,"path":"2020/07/31/java-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-4/","excerpt":"","text":"농업기상정보 서비스 농업 관련 기상 데이터가 필요하게 되어 공공데이터 포털 사이트의 농업기상정보 API를 사용하여 조회하였다. Open API 활용 방법 농업기상정보서비스 사이트에 접속한다. 이용방법에 따라 회원가입 후 Open API 신청을 하고 Service Key를 발급받는다. 활용 가이드를 다운로드하여 조회 조건 및 결과 데이터를 이해한다. 농업 기상 데이터 조회 1http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp?mberid=&#123;id&#125;&amp;regist_ky=&#123;발급받은 Service Key&#125; 결과 데이터(XML 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;Root&gt; &lt;Info&gt; &lt;stncode&gt;380959A001&lt;/stncode&gt; &lt;stnname&gt;충주시 달천동&lt;/stnname&gt; &lt;date&gt;2020/07/31 14:50&lt;/date&gt; &lt;temp_150&gt;28.3℃&lt;/temp_150&gt; &lt;tmprt_150Top&gt;29.7℃&lt;/tmprt_150Top&gt; &lt;tmprt_150Lwet&gt;22.5℃&lt;/tmprt_150Lwet&gt; &lt;tmprt_50&gt;-℃&lt;/tmprt_50&gt; &lt;tmprt_50Top&gt;-℃&lt;/tmprt_50Top&gt; &lt;tmprt_50Lwet&gt;-℃&lt;/tmprt_50Lwet&gt; &lt;tmprt_400&gt;-℃&lt;/tmprt_400&gt; &lt;tmprt_400Top&gt;-℃&lt;/tmprt_400Top&gt; &lt;tmprt_400Lwet&gt;-℃&lt;/tmprt_400Lwet&gt; &lt;hd_150&gt;86.2%&lt;/hd_150&gt; &lt;hd_150Top&gt;100.0%&lt;/hd_150Top&gt; &lt;hd_150Lwet&gt;75.6%&lt;/hd_150Lwet&gt; &lt;hd_50&gt;-%&lt;/hd_50&gt; &lt;hd_50Top&gt;-%&lt;/hd_50Top&gt; &lt;hd_50Lwet&gt;-%&lt;/hd_50Lwet&gt; &lt;hd_400&gt;-%&lt;/hd_400&gt; &lt;hd_400Top&gt;-%&lt;/hd_400Top&gt; &lt;hd_400Lwet&gt;-%&lt;/hd_400Lwet&gt; &lt;wd_300&gt;남동&lt;/wd_300&gt; &lt;wd_300Top&gt;남&lt;/wd_300Top&gt; &lt;wd_300Lwet&gt;정온&lt;/wd_300Lwet&gt; &lt;wd_150&gt;-&lt;/wd_150&gt; &lt;wd_150Top&gt;-&lt;/wd_150Top&gt; &lt;wd_150Lwet&gt;-&lt;/wd_150Lwet&gt; &lt;wd_1000&gt;-&lt;/wd_1000&gt; &lt;wd_1000Top&gt;-&lt;/wd_1000Top&gt; &lt;wd_1000Lwet&gt;-&lt;/wd_1000Lwet&gt; &lt;arvlty_300&gt;1.9&lt;/arvlty_300&gt; &lt;arvlty_300Top&gt;4.0&lt;/arvlty_300Top&gt; &lt;arvlty_300Lwet&gt;0.0&lt;/arvlty_300Lwet&gt; &lt;arvlty_150&gt;-&lt;/arvlty_150&gt; &lt;arvlty_150Top&gt;-&lt;/arvlty_150Top&gt; &lt;arvlty_150Lwet&gt;-&lt;/arvlty_150Lwet&gt; &lt;arvlty_1000&gt;-&lt;/arvlty_1000&gt; &lt;arvlty_1000Top&gt;-&lt;/arvlty_1000Top&gt; &lt;arvlty_1000Lwet&gt;-&lt;/arvlty_1000Lwet&gt; &lt;afp&gt;0.0mm&lt;/afp&gt; &lt;afv&gt;-mm&lt;/afv&gt; &lt;sunshnTime&gt;202.0hr&lt;/sunshnTime&gt; &lt;solradQy&gt;10.4MJ/㎡&lt;/solradQy&gt; &lt;dwcnTime&gt;0.0hr&lt;/dwcnTime&gt; &lt;pnwgTp&gt;-hr&lt;/pnwgTp&gt; &lt;pnwgTpTop&gt;-hr&lt;/pnwgTpTop&gt; &lt;pnwgTpLwet&gt;-hr&lt;/pnwgTpLwet&gt; &lt;frfrTp&gt;-℃&lt;/frfrTp&gt; &lt;frfrTpTop&gt;-℃&lt;/frfrTpTop&gt; &lt;frfrTpLwet&gt;-℃&lt;/frfrTpLwet&gt; &lt;udgrHeattCndctvt&gt;-100.0℃&lt;/udgrHeattCndctvt&gt; &lt;udgrHeattCndctvtTop&gt;-100.0℃&lt;/udgrHeattCndctvtTop&gt; &lt;udgrHeattCndctvtLwet&gt;-100.0℃&lt;/udgrHeattCndctvtLwet&gt; &lt;udgrTp_10&gt;-℃&lt;/udgrTp_10&gt; &lt;udgrTp_10Top&gt;26.1℃&lt;/udgrTp_10Top&gt; &lt;udgrTp_10Lwet&gt;24.4℃&lt;/udgrTp_10Lwet&gt; &lt;udgrTp_5&gt;-℃&lt;/udgrTp_5&gt; &lt;udgrTp_5Top&gt;-℃&lt;/udgrTp_5Top&gt; &lt;udgrTp_5Lwet&gt;-℃&lt;/udgrTp_5Lwet&gt; &lt;udgrTp_20&gt;-℃&lt;/udgrTp_20&gt; &lt;udgrTp_20Top&gt;-℃&lt;/udgrTp_20Top&gt; &lt;udgrTp_20Lwet&gt;-℃&lt;/udgrTp_20Lwet&gt; &lt;soilMitr_10&gt;32.5&lt;/soilMitr_10&gt; &lt;soilMitr_10Top&gt;36.3&lt;/soilMitr_10Top&gt; &lt;soilMitr_10Lwet&gt;27.3&lt;/soilMitr_10Lwet&gt; &lt;soilMitr_10Cmst&gt;23.4&lt;/soilMitr_10Cmst&gt; &lt;soilMitr_10CmstTop&gt;27.2&lt;/soilMitr_10CmstTop&gt; &lt;soilMitr_10CmstLwet&gt;18.2&lt;/soilMitr_10CmstLwet&gt; &lt;soilMitr_20&gt;-&lt;/soilMitr_20&gt; &lt;soilMitr_20Top&gt;-&lt;/soilMitr_20Top&gt; &lt;soilMitr_20Lwet&gt;-&lt;/soilMitr_20Lwet&gt; &lt;soilMitr_20Cmst&gt;-&lt;/soilMitr_20Cmst&gt; &lt;soilMitr_20CmstTop&gt;-&lt;/soilMitr_20CmstTop&gt; &lt;soilMitr_20CmstLwet&gt;-&lt;/soilMitr_20CmstLwet&gt; &lt;soilMitr_30&gt;-&lt;/soilMitr_30&gt; &lt;soilMitr_30Top&gt;-&lt;/soilMitr_30Top&gt; &lt;soilMitr_30Lwet&gt;-&lt;/soilMitr_30Lwet&gt; &lt;soilMitr_30Cmst&gt;-&lt;/soilMitr_30Cmst&gt; &lt;soilMitr_30CmstTop&gt;-&lt;/soilMitr_30CmstTop&gt; &lt;soilMitr_30CmstLwet&gt;-&lt;/soilMitr_30CmstLwet&gt; &lt;/Info&gt;&lt;/Root&gt; 1) Respone Domain 생성 기본적으로 결과가 XML 형식이므로 javax.xml를 사용하여 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import lombok.Data;/** * 기상청 API로 기상정보 조회할 때 쓰이는 도메인 * * @author hgko * */@Data@XmlRootElement(name = \"Root\")@XmlAccessorType(value = XmlAccessType.FIELD)public class ResponseXml &#123; @XmlElement(name = \"Info\") private Info info; @Data public static class Info &#123; /** 지역 코드 */ private String stncode; /** 지역 이름 */ private String stnname; /** 일시 */ private String date; /** 온도(150CM) */ private String temp_150; /** 습도(150CM) */ private String hd_150; /** 풍향(300CM) */ private String wd_300; /** 풍속(300CM) */ private float arvlty_300; /** 강수량 */ private String afp; /** 증발량 */ private String afv; /** 일사량 */ private String solradQy; /** 일조시간 */ private String sunshnTime; /** 토양수분(10CM) */ private float soilMitr_10; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회한다. 123456789101112131415161718private final String BASE_URL = \"http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp\";private final String userId = \"\"; // Login Idprivate final String serviceKey = \"\"; // 발급받은 Service Keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"mberid\", \"UTF-8\") + \"=\" + userId); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"regist_ky\", \"UTF-8\") + \"=\" + serviceKey); RestTemplate restTemplate = new RestTemplate(); ResponseXml response = restTemplate.getForObject(urlBuilder.toString(), ResponseXml.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"}]},{"title":"[JAVA] OpenWeather API 사용 방법","slug":"java-dev-3","date":"2020-07-31T05:12:22.000Z","updated":"2024-01-11T08:11:18.411Z","comments":true,"path":"2020/07/31/java-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-3/","excerpt":"","text":"OpenWeather API 200,000 개가 넘는 도시를 포함하여 지구상의 모든 위치에 대한 현재 날씨 데이터에 액세스 할 수 있습니다. 현재 날씨는 글로벌 모델과 4만 개가 넘는 기상 관측소의 데이터를 기반으로 자주 업데이트됩니다. 데이터는 JSON, XML 또는 HTML 형식으로 제공됩니다. 출처 : OpenWeather OpenWeather API를 사용하여 현재 날씨 데이터를 조회하였다. 현재 날씨 데이터 조회 OpenWeather 사이트에 접속해서 API Key를 발급받는다. 메인에서 Current Weather Data를 선택받는다. 조회 조건 및 결과 정보와 다른 기능들에 대해 잘 설명되어 있다. 우리나라 전체에 대한 날씨 데이터를 조회할 것이기 때문에 조회 조건은 다음과 같다. 1http://api.openweathermap.org/data/2.5/weather?q=Koesan&amp;appid=&#123;발급받은 API Key&#125;&amp;lang=kr&amp;units=metric 결과 데이터(JSON 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"coord\": &#123; \"lon\": 127.79, \"lat\": 36.81 &#125;, \"weather\": [ &#123; \"id\": 803, \"main\": \"Clouds\", \"description\": \"튼구름\", \"icon\": \"04d\" &#125; ], \"base\": \"stations\", \"main\": &#123; \"temp\": 28, \"feels_like\": 32.65, \"temp_min\": 28, \"temp_max\": 28, \"pressure\": 1014, \"humidity\": 78 &#125;, \"visibility\": 10000, \"wind\": &#123; \"speed\": 1.5, \"deg\": 270 &#125;, \"clouds\": &#123; \"all\": 75 &#125;, \"dt\": 1596171614, \"sys\": &#123; \"type\": 1, \"id\": 8131, \"country\": \"KR\", \"sunrise\": 1596141211, \"sunset\": 1596191806 &#125;, \"timezone\": 32400, \"id\": 1842800, \"name\": \"Koesan\", \"cod\": 200&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;import lombok.Data;/** * OpenWeath API - 현재 날씨 데이터 * @author hgko */@Datapublic class OpenWeather &#123; private List&lt;Weather&gt; weather; /** 내부 매개 변수 */ private String base; private Main main; private Wind wind; private Clouds clouds; private Rain rain; private Snow snow; /** 가시성 */ private int visibility; /** 데이터 계산 시간, 유닉스, UTC */ private long dt; /** UTC에서 초 단위로 이동 */ private int timezone; /** 도시 ID */ private long id; /** 도시 이름 */ private String name; /** 내부 매개 변수 */ private int cod; @Data public static class Weather &#123; /** 기상 조건 ID */ private int id; /** 날씨 매개 변수 그룹 (비, 눈, 극한 등) */ private String main; /** 그룹 내 날씨 조건 */ private String description; /** 날씨 아이콘 ID */ private String icon; &#125; @Data public static class Main &#123; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float temp; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float feels_like; /** 현재 최저 온도.(대규모 대도시 및 도시 지역 내) */ private float temp_min; /** 현재 최대 온도.(대규모 대도시 및 도시 지역 내)*/ private float temp_max; /** 대기압 (해수면, 해수면 또는 grnd_level 데이터가 없는 경우), hPa */ private int pressure; /** 습도, % */ private float humidity; /** 해수면의 대기압, hPa */ private float sea_level; /** 지면에서의 대기압, hPa */ private float grnd_level; &#125; @Data public static class Wind &#123; /** 바람의 속도. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float speed; /** 풍향,도 (기상) */ private int deg; /** 바람 돌풍. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float gust; &#125; @Data public static class Clouds &#123; /** 흐림, % */ private int all; &#125; @Data public static class Rain &#123; /** 지난 1 시간 동안의 강우량, mm */ @JsonProperty(\"1h\") private float rain1h; /** 지난 3 시간 동안의 강우량, mm */ @JsonProperty(\"3h\") private float rain3h; &#125; @Data public static class Snow &#123; /** 지난 1 시간 동안의 눈량, mm */ @JsonProperty(\"1h\") private float snow1h; /** 지난 3 시간 동안의 눈량, mm */ @JsonProperty(\"3h\") private float snow3h; &#125; @Data public static class Sys &#123; private int type; private int id; /** 국가 코드 (GB, JP 등) */ private String country; /** 일출 시간, 유닉스, UTC */ private long sunrise; /** 일몰 시간, 유닉스, UTC */ private long sunset; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회하였다. 12345678910111213141516171819private final String BASE_URL = \"http://api.openweathermap.org/data/2.5/weather\";private final String apiKey = \"\"; // 발급받은 API keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"q\", \"UTF-8\") + \"=Koesan\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"appid\", \"UTF-8\") + \"=\" + apiKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"lang\", \"UTF-8\") + \"=kr\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"units\", \"UTF-8\") + \"=metric\"); RestTemplate restTemplate = new RestTemplate(); OpenWeather response = restTemplate.getForObject(urlBuilder.toString(), OpenWeather.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 결과가 출력되었는지 확인하고 정상이면 날씨 데이터들을 가공해서 사용하도록 한다. 추가 내용 풍향 데이터 변환 날씨 API에서 풍향 데이터는 대부분이 degree(integer) 형식으로 되어 있기 때문에 방향을 나타내는 String 형식으로 나타낼 필요가 있다. 123456789101112131415161718192021222324252627282930313233343536373839# Enum 정의@Getterpublic enum WindType &#123; N0(0, \"북\"), NNE(1, \"북북동\"), NE(2, \"북동\"), ENE(3, \"동북동\"), E(4, \"동\"), ESE(5, \"동남동\"), SE(6, \"남동\"), SSE(7, \"남남동\"), S(8, \"남\"), SSW(9, \"남남서\"), SW(10, \"남서\"), WSW(11, \"서남서\"), W(12, \"서\"), WNW(13, \"서북서\"), NW(14, \"북서\"), NNW(15, \"북북서\"), N16(16, \"북\"); private int code; private String name; private WindType(int code, String name) &#123; this.code = code; this.name = name; &#125; public static WindType value(int value) &#123; for (WindType type : WindType.values()) &#123; if (type.getCode() == value) &#123; return type; &#125; &#125; return null; &#125;&#125; Enum을 사용하여 편리하게 변환한다. 12345private String getWindDirection(int degree) &#123; int result = (int)((degree + 22.5 * 0.5) / 22.5); WindType windType = WindType.value(result); return windType.getName();&#125; 1234public static void main(String[] args) &#123; String wd = getWindDirection(270); System.out.println(\"풍향 : \" : wd);&#125; 결과 1풍향 : 서 날씨 정보 변환 OpenWeatherMap API의 다국어에 한국어 지원을 위한 협업용 정보 openweathermap_api_translation_ko","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"}]},{"title":"[CSS] 그라데이션 효과","slug":"css-dev-1","date":"2020-07-31T01:20:38.000Z","updated":"2023-07-17T12:56:40.270Z","comments":true,"path":"2020/07/31/css-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/css-dev-1/","excerpt":"","text":"linear-gradient : CSS3에서 추가된 것으로, 선형 그라데이션 효과를 만들 수 있다. 1linear-gradient( direction, color1, color2, …, color3 ); direction에는 그라데이션 방향을 입력한다. to bottom : 위에서 아래로 그라데이션을 만든다. (기본값) to top : 아래에서 위로 그라데이션을 만든다. to left : 오른쪽에서 왼쪽으로 그라데이션을 만든다. to right : 왼쪽에서 오른쪽으로 그라데이션을 만든다. ndeg : n 도의 방향으로 그라데이션을 만든다. 예시 1234.gradation_bar &#123; width: 100%; background: linear-gradient(to right, #ff0000, orange, yellow, #00ff00, #0000ff, indigo, violet);&#125; 결과 참고 Ultimate CSS Gradient Generator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"}]},{"title":"[JAVA] proj4 투형 변환","slug":"java-dev-2","date":"2020-07-31T01:04:39.000Z","updated":"2024-01-11T08:10:27.253Z","comments":true,"path":"2020/07/31/java-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-2/","excerpt":"","text":"투형 변환 TM(미국좌표) 좌표와 WGS84(한국좌표) 좌표를 서로 변환한다. 다운로드 Java Map Projection Library 사이트에 접속하여 다음의 Download에서 소스 및 jar 파일을 다운로드한다. 다운로드한 jar 파일은 프로젝트의 classpath 경로에 추가한다. 샘플 1234567891011121314151617181920212223// 투형 정보 입력(중부원점 직각좌표 투형정보)String[] proj4 = new String[] &#123; \"+proj=tmerc\", \"+lat_0=38N\", \"+lon_0=127.00289027777777777776E\", \"+ellps=bessel\", \"+units=m\", \"+x_0=200000\", \"+y_0=500000\", \"+k=1.0\"&#125;Projection proj = ProjectionFactory.fromPROJ4Specification(proj4);Point2D.Double srcProject = new Point2D.Double(132, 37);Point2D.Double dstProject = proj.transform(srcProject, new Point2D.Double());System.out.println(\"TM : \" + dstProject);srcProject = new Point2D.Double(644904.399587292, 400717.8948938238);dstProject = proj.inverseTransForm(srcProject, new Point2D.Double());System.out.println(\"WGS84 : \" + dstProjec); 결과 12TM : Point2D.Double[644904.399587292, 400717.8948938238]WGS84 : Point2D.Double[132.00000000065793, 36.999999999128526]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"}]},{"title":"[JAVA] Julian Date Conversion","slug":"java-dev-1","date":"2020-07-31T00:59:38.000Z","updated":"2023-03-14T02:18:51.709Z","comments":true,"path":"2020/07/31/java-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-1/","excerpt":"","text":"율리우스력 변환하기 율리우스력은 고대 로마의 정치가 율리우스 카이사르가 기원전 46년에 제정해 기원전 45년부터 시행한 양력(陽曆) 역법이다. 율리우스력의 1년은 365일 또는 366일(4년에 한번)이다. 기원전 46년 이전까지 고대 로마에서는 태음력을 사용하였으며, 점차 계절의 변화(즉, 태양의 일주)를 고려해 태음력과 태양력을 섞어서 년(年)과 월(月)을 계산하였다. 이에 따라 특히 달을 계산하는 데 적지 않은 혼란과 계산의 착오가 생겼으며, 이러한 착오는 제사장이 임의로 수정하였다. 율리우스 카이사르가 채택한 달력은 태양력을 기준으로 2월을 제외한 달은 모두 30일 또는 31일로 정함으로써 이전에 있던 번거로움을 한꺼번에 해소하였다. 출처 : 위키백과 1. Joda-Time Library 사용 12345String dateStr = \"2009218\";MutableDateTime mdt = new MutableDateTime();mdt.setYear(Integer.parseInt(dateStr.subString(0, 3)));mdt.setDayOfYear(Integer.parseInt(dateStr.subString(4)));Date parsedDate = mdt.toDate(); 2. Java Api 사용 12345String dateStr = \"2009218\";Calendar cal = new GregorianCalendar();cal.set(Calendar.YEAR,Integer.parseInt(dateStr.subString(0, 3)));cal.set(Calendar.DAY_OF_YEAR,Integer.parseInt(dateStr.subString(4)));Date parsedDate = cal.getTime();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"}]},{"title":"[Eclipse RCP] 폴더안의 파일 리스트 읽기","slug":"rcp-dev-4","date":"2020-07-31T00:53:37.000Z","updated":"2023-07-17T13:04:41.398Z","comments":true,"path":"2020/07/31/rcp-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-4/","excerpt":"","text":"SWT 의 DirectoryDialog 를 이용하여 폴더를 읽고 폴더의 파일들을 읽어서 원하는 List 의 형식으로 만든다. 123456789101112131415161718192021Shell shell = GUIUtil.getShell();shell.getDisplay().asyncExec(() -&gt; &#123; DirectoryDialog dialog = new DirectoryDialog(shell); dialog.setMessage(\"Please select a directory and click OK\"); String dir = dialog.open(); if (dir != null) &#123; List&lt;MapImage&gt; mapImages = null; try &#123; mapImages = Files.list(new File(dir).toPath()) .filter(file -&gt; file.toFile().isFile()) .filter(file -&gt; !file.toFile().getName().endsWith(\".txt\")) .map(file -&gt; &#123; return new MapImage(shell, file.toFile()); &#125;).collect(Collectors.toList()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.err.println(mapImages); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[Eclipse RCP] SWT에서의 GC, Drawable, Canvas 사용","slug":"rcp-dev-3","date":"2020-07-31T00:38:00.000Z","updated":"2024-01-11T08:13:05.766Z","comments":true,"path":"2020/07/31/rcp-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-3/","excerpt":"","text":"addPaintListener() Control 객체가 그 객체의 paintEvent를 통하여 그림을 그릴 수 있지만, 이보다는 Control 클래스를 상속받아 그래픽 작업을 위해 설계된 특별한 클래스인 Canvas 클래스를 사용하여 그림을 그리는 것이 더욱 좋습니다. Canvas 클래스를 생성한 후 addPaintListener()를 통하여 paintListener를 추가하거나, 사용자가 직접 정의한 Control을 상속받음으로써 그림을 그릴 수 있습니다. Canvas 클래스는 그림을 그릴 때 사용할 수 있는 다양한 종류의 스타일 비트를 가지고 있습니다. SWT.NO_BACKGROUND Canvas의 기본적인 동작은 다음과 같습니다. 객체의 할당영역을 그리기 앞서, 객체에 할당된 전체 영역을 현재 배경색으로 칠합니다. 이때 화면이 깜박이는 현상을 볼 수 있는데 이는 paintEvent가 배경색을 칠하고, 그 위에 Canvas의 요소들을 덧칠하는 순간을 우리가 보는 것입니다. 이 현상을 방지하기 위한 방법 중 하나는, Canvas를 생성할 때 SWT.NO_BACKGROUND 스타일 비트를 사용하여 배경이 그려지지 않게 하는것입니다. 단, 이 비트를 사용할 경우, 프로그램은 영역 전체에 대하여 모든 픽셀을 직접 그려야 합니다. SWT.NO_REDRAW_RESIZE 위젯의 사이즈가 변경될 때에도 paintEvent가 발생합니다. 이 역시 화면을 깜박거리게 할 수 있는데, 왜냐하면 사이즈가 변경될 때마다 해당 영역에 대해 모든 요소들을 다시 그려야 하기 때문입니다. 이는 SWT.NO_REDRAW_RESIZE 스타일 비트를 사용하여 완화시킬 수 있으며, 이는 컨트롤의 사이즈가 변경되더라도 paintEvent가 발생하지 않는다는 것을 의미합니다. 이는 컨트롤이 불필요하게 다시 그려지는 것을 방지한다는 의미를 갖으며, 만약 크기가 증가된다고 한다면, paintEvent의 GC는 이 영역을 제외한 부분만을 다시 그리게 됩니다. 단 사각형 모양이 Canvas가 존재할 경우 사각형의 오른쪽 하단에 L이 거꾸로 된 형태로 그려질 수 있습니다. SWT.NO_REDRAW_RESIZE 스타일 비트는 새로 그려지는 부분에 대해서 적절히 처리해줄 경우, 고정사이즈의 그림이 GC에 그려질 때 나타나는 깜박임을 감소시킬 수 있습니다. 하지만 잘못 쓰였을 경우, SWT.NO_REDRAW_RESIZE는 치즈(cheese)라는 효과를 불러올 수 있습니다. 치즈는 다시 그려야 할 상황에 제대로 다시 그려지지 않는 부분이 있는 경우를 지칭합니다. paintEvent가 클라이언트 전 영역을 다시 그려야 하는 다음의 예시를 확인해 보세요. 화면이 작아질 때에는 paintEvent가 발생하지 않기 때문에 그림이 다시 그려지지 않습니다. SWT.NO_REDRAW_RESIZE 상태에서 화면이 커질 경우, paintEvent는 새로 그려야 하는 부분에 대해서만 영역을 다시 그립니다. 그래서 기존에 그려졌던 부분이 지워지지 않았기 때문에 치즈 현상이 발생하게 됩니다. 또한 Canvas 사이즈가 증가할 때 GC는 필요한 부분만 다시 그리기 때문에 치즈 현상이 발생하게 됩니다. 12345678910shell.setLayout(new FillLayout());final Canvas canvas = new Canvas(shell,SWT.NO_REDRAW_RESIZE);canvas.addPaintListener(new PaintListener() &#123; public void paintControl(PaintEvent e) &#123; Rectangle clientArea = canvas.getClientArea(); e.gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN)); e.gc.fillOval(0,0,clientArea.width,clientArea.height); &#125;&#125;); SWT.NONE 이 문제를 해결하는 방법은 SWT.NONE 스타일 비트를 사용하여 GC가 크기가 커질 때 커진 부분만 새로 그리는것이 아닌, 모든 부분을 새로 그리도록 하고, 동시에 paintEvent가 셸 사이즈가 작아졌을 때에도 발생하게 하여, Canvas의 전체 부분이 다시 그려지게 하는 것입니다. 1final Canvas canvas = new Canvas(shell,SWT.NONE); SWT.NO_MERGE_PAINTS 각각의 SWT 위젯에 대해, 만약 하나이상의 영역이 다시 그려져야 할 경우, 운영체제는 다시 그려야 할 영역을 하나의 영역으로 묶어서 paintEvent를 발생하여 효율적인 처리를 가능하게 합니다. Canvas의 SWT.NO_MERGE_PAINTS 스타일 비트는 각각의 위젯에서 다시 그릴 영역을 하나로 묶지 않고, 각각의 영역에 대해 일일이 paintEvent를 호출하는 방식으로 변경합니다. 정리 NO_BACKGROUND, NO_REDRAW_RESIZE, NO_MERGE_PAINTS 스타일 비트는 Composite와 이 하부 클래스인 Canvas, Shell, Group등에서 사용할 수 있습니다, SWT에서 허용하긴 하지만, Composite 클래스의 Javadoc에서는 스타일 비트에 대해서 다음과 같이 기술합니다. Canvas 이외의 Composite의 하위클래스에서의 사용은 정의되지 않았다. 그러므로 Canvas 클래스가 그림 그리는데에 가장 적합한 컨트롤이라 할 수 있습니다. 깜박임을 방지하는 또 다른 방법은 더블 버퍼링을 사용하여 그림 그리기를 한 번에 처리하는 것입니다. 더블 버퍼링은 paintEvent에서 제공하는 GC기 아닌 GC에 그림을 미리 그린 후, 이것을 제공되는 GC에 복사하는 기술입니다. 이를 위하여, Canvas의 영역과 동일한 사이즈의 Image 객체를 만들고, GC(Image)를 통하여 이 객체에 그림을 그립니다. 그려진 그림(Image)은 drawImage(Image, int, int) 메서드를 호출함으로써 paintEvent의 GC로 그려지게 됩니다. 이 기술을 사용할 때 주의할 점은 몇몇 운영체제는 이미 더블 버퍼링을 자체적으로 구현하고 있으므로, 결국 트리플 버퍼링이 이루어질 수 있다는 점입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[PyTorch] 기초 사용법","slug":"ai-pytorch-1","date":"2020-07-30T06:04:07.000Z","updated":"2023-03-14T02:18:45.739Z","comments":true,"path":"2020/07/30/ai-pytorch-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/30/ai-pytorch-1/","excerpt":"","text":"Load Packages 12import numpy as npimport torch Basic PyTorch 기초 사용법 1234nums = torch.arange(9)nums.shapenums.numpy()nums.reshape(3, 3) 1234randoms = torch.rand((3, 3))zeros = torch.zeros((3, 3))ones = torch.ones((3, 3))torch.zeros_like(ones) Operations PyTorch로 수학연산 하기 1234567891011nums * 3nums = nums.reshape((3, 3))nums + numsresult = torch.add(nums, 10)result.numpy()# Outarray([[10, 11, 12], [13, 14, 15], [16, 17, 18]], dtype=int64) View reshape와 같다. 123456range_nums = torch.arange(9).reshape(3, 3)range_nums.view(-1)range_nums.view(1, 9)# Outtensor([[0, 1, 2, 3, 4, 5, 6, 7, 8]]) Compile numpy를 torch tensor로 불러오기 12345arr = np.array([1, 1, 1])arr_torch = torch.from_numpy(arr)arr_torch.float()# tensor([1., 1., 1.]) Device 설정 12345device = 'cuda' if torch.cuda.is_available() else 'cpu'arr_torch.to(device)# Out - GPU 사용 가능tensor([1, 1, 1], device='cuda:0', dtype=torch.int32) AutoGrad 기울기 구하기 123456x = torch.ones(2, 2, requires_grad=True)y = x + 2print(x.grad_fn)# Out&lt;AddBackward0 object at 0x000001FFE2A04148&gt; 1234567z = y * y * 3out = z.mean()print(z, out)# Outtensor([[27., 27.], [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;) 123456out.backward()print(x.grad)# Outtensor([[4.5000, 4.5000], [4.5000, 4.5000]])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[TensorFlow 2.0] Evaluating & Prediction","slug":"ai-dev-7","date":"2020-07-29T02:29:29.000Z","updated":"2023-07-17T12:56:15.225Z","comments":true,"path":"2020/07/29/ai-dev-7/","link":"","permalink":"http://hgko1207.github.io/2020/07/29/ai-dev-7/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Build Model 123456789101112131415161718192021222324252627input_shape = (28, 28, 1)num_classes = 10learning_rate = 0.001inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), loss='sparse_categorical_crossentropy', metrics=['accuracy']) Preprocess 데이터셋 불러오기 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Training 12345678910num_epochs = 1batch_size = 64hist = model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# 결과Train on 60000 samples60000/60000 [==============================] - 6s 94us/sample - loss: 0.0798 - accuracy: 0.9755 1234hist.history# 결과&#123;'loss': [0.07980264157739779], 'accuracy': [0.9755]&#125; Evaluating 학습한 모델을 확인합니다. 1234model.evaluate(test_x, test_y, batch_size=batch_size)# 결과[0.03286817007374484, 0.9888] 결과 확인 Input으로 들어갈 이미지 데이터를 확인한다. 123456789import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinetest_image = text_x[0, :, :, 0]test_image.shape# 결과(28, 28) 123plt.title(test_y[0])plt.imshow(test_image, 'gray')plt.show() 모델에 Input Data로 확인 할 이미지 데이터를 넣는다. 1234567# 이미지를 보기위해 shape를 바꿨었는데 다시 reshape로 차원을 변경합니다.pred = model.predict(test_image.reshape(1, 28, 28, 1))# 결과array([[2.4227038e-09, 2.3278629e-08, 5.8909092e-07, 1.0298673e-07, 9.4029007e-10, 6.1998517e-11, 1.4364351e-12, 9.9999928e-01, 4.7319365e-10, 4.7449920e-08]], dtype=float32) 12345# 배열에서 가장 높은 값의 인덱스를 찾을 때 np.argmax를 사용한다.np.argmax(pred)# 결과7 Test Batch Batch Test Dataset 모델에 넣는다. 12345test_batch = test_x[:32]test_batch.shape# 결과(32, 28, 28, 1) 12345preds = model.predict(test_batch)preds.shape# 결과(32, 10) 123456789# -1을 넣으면 하나의 값이 아니라 앞의 32개의 결과를 보여줍니다.np.argmax(preds, -1)# 결과array([7, 2, 1, 0, 4, 1, 4, 9, 5, 9, 0, 6, 9, 0, 1, 5, 9, 7, 5, 4, 9, 6, 6, 5, 4, 0, 7, 4, 0, 1, 3, 1], dtype=int64)plt.imshow(test_batch[5, :, :, 0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Expert)","slug":"ai-dev-6","date":"2020-07-28T08:38:22.000Z","updated":"2023-07-17T12:55:57.031Z","comments":true,"path":"2020/07/28/ai-dev-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/28/ai-dev-6/","excerpt":"","text":"TensorFlow 공식 홈페이지에서 설명하는 Expert 버전을 사용해본다. Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Build Model 1234567891011121314151617181920212223242526input_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Preprocess TensorFlow 공식 홈페이지에서 말한 expert 방법을 사용한다. 1234567891011mnist = tf.keras.datasets.mnist# Load Data from MNIST(x_train, y_train), (x_test, y_test) = mnist.load_data()# Channel 차원 추가x_train = x_train[..., tf.newaxis]x_test = x_test[..., tf.newaxis]# Data Normailzationx_train, x_test = x_train / 255.0, x_test / 255.0 tf.data 사용 from_tensor_slices() shuffle() batch() 123456train_ds = tf.data.Dataset.from_tensor_slices((x_train, y_train))train_ds = train_ds.shuffle(1000)train_ds = train_ds.batch(32)test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))test_ds = test_ds.batch(32) Visualize Data matplotlib 불러와서 데이터를 시각화한다. 1234567import matplotlib.pyplot as plt%matplotlib inlinefor image, label in train_ds.take(2): plt.title(label[0].shape) plt.imshow(image[0, :, :, 0], 'gray') plt.show() Training (Keras) Keras로 학습 할 때는 기존과 같지만, train_ds는 generator라서 그래도 넣을 수 있다. 12model.compile(optimizer='adam', loss='sparse_categorical_crossentropy')model.fit(train_ds, epochs=1000) Optimization Loss Function Optimizer Metrics 12345678loss_object = tf.keras.losses.SparseCategoricalCrossentropy()optimizer = tf.keras.optimizers.Adam()train_loss = tf.keras.metrics.Mean(name='train_loss')train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')test_loss = tf.keras.metrics.Mean(name='test_loss')test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy') Training @tf.function : 기존 session 열었던 것 처럼 바로 작동 안 하고, 그래프만 만들고 학습이 시작되면 돌아가도록 한다. 12345678910@tf.functiondef train_step(images, labels): with tf.GradientTape() as tape: predictions = model(images) loss = loss_object(labels, predictions) gradients = tape.gradient(loss, model.trainable_variables) optimizer.apply_gradients(zip(gradients, model.trainable_variables)) train_loss(loss) train_accuracy(labels, predictions) 1234567@tf.functiondef test_step(images, lebels): predictions = model(images) t_loss = loss_object(labels, predictions) test_loss(t_loss) test_accuracy(labels, predictions) 12345678910111213for epoch in range(2): for images, labels in train_ds: train_step(images, labels) for test_images, test_labels in test_ds: test_step(test_images, test_labels) template = 'Epoch &#123;&#125;, Loss: &#123;&#125;, Accuracy: &#123;&#125;, Test Loss &#123;&#125;, Test Accuracy: &#123;&#125;' print(template.format(epoch+1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100)) 결과 1234Start TrainingEpoch 1, Loss: 0.04196552559733391, Accuracy: 98.74666595458984, Test Loss 0.043360475450754166, Test Accuracy: 98.72000122070312Start TrainingEpoch 2, Loss: 0.033374134451150894, Accuracy: 99.0050048828125, Test Loss 0.03336939960718155, Test Accuracy: 98.95500183105469","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Keras)","slug":"ai-dev-5","date":"2020-07-24T08:35:22.000Z","updated":"2023-07-17T12:55:31.769Z","comments":true,"path":"2020/07/24/ai-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/24/ai-dev-5/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Prepare MNIST Datset 1(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data() Build Model 1234567891011121314151617181920212223inputs = layers.Input((28, 28, 1))net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(10)(net) # num_classesnet = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Optimization 모델을 학습하기 전에 설정을 한다. Loss Function Metrics Optimizer Loss Function Categorical vs Binary 12loss = 'binary_crossentropy'loss = 'categorical_crossentropy' sparse_categorical_crossentropy vs categorical_crossentropy 12345loss_fun = tf.keras.losses.sparse_categorical_crossentropy# 또는tf.keras.losses.categorical_crossentropytf.keras.losses.binary_crossentropy Metrics 모델을 평가하는 방법이다.(정확도 측정) Accuracy : 예측이 레이블과 일치하는 빈도를 계산 BinaryAccuracy: 예측이 이진 레이블과 일치하는 빈도를 계산 CategoricalAccuracy : 예측이 one-hot 레이블과 일치하는 빈도를 계산 TopKCategoricalAccuracy : 상위 K 예측에서 대상이 얼마나 자주 나타되는지 계산 SparseTopKCategoricalAccuracy : 상위 K 예측에서 정수 대상이 얼마나 자주 나타하는지 계산 12345# accurany를 이름으로 넣는 방법metrics = ['accuracy']# tf.keras.metricsmetrics = [tf.keras.metrics.CategoricalAccuracy()] Optimizer ‘sgd’ ‘rmsprop’ ‘adam’ 123456optm = tf.keras.optimizers.Adam()# Outtf.keras.optimizers.SGD()tf.keras.optimizers.RMSprop()tf.keras.optimizers.Adam() Compile Optimizer 적용을 합니다. 123model.compile(optimizer=optm, loss=loss_fun, metrics=metrics) Prepaer Dataset 학습에 사용할 데이터셋을 준비한다. 데이터셋 확인 12345train_x.shape, train_y.shape&gt; ((60000, 28, 28), (60000,))test_x.shape, test_y.shape&gt; ((10000, 28, 28), (10000,)) 차원 수 늘리기 1234567import numpy as npnp.expand_dims(train_x, -1).shape&gt; (60000, 28, 28, 1)tf.expand_dims(train_x, -1).shape&gt; TensorShape([60000, 28, 28, 1]) 123# 최신 버전train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis] Rescaling 12345678np.min(train_x), np.max(train_x)&gt; (0, 255)train_x = train_x / 255.test_x = test_x / 255.np.min(train_x), np.max(train_x)&gt; (0.0, 1.0) Training 본격적으로 학습을 해봅니다. 그 전에 학습용 Hyperparameter 설정한다. num_epochs, batch_size 12345# 전체 sample 데이터를 이용하여 한 바퀴 돌며 학습하는 것을 1회 epoch이라 부른다.num_epochs = 1# 모델에 한번에 들어가는 데이터 수를 조절하여 메모리 사용 효율을 향상시킨다.batch_size = 32 실행! 12345678model.fit(train_x, train_y, batch_size=batch_size, shuffle=True, epochs=num_epochs)# ResultTrain on 60000 samples60000/60000 [==============================] - 99s 2ms/sample - loss: 0.1414 - categorical_accuracy: 0.0992","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 각 Layer별 역할 및 파라미터","slug":"ai-dev-4","date":"2020-07-20T07:39:18.000Z","updated":"2023-07-17T12:54:57.875Z","comments":true,"path":"2020/07/20/ai-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-4/","excerpt":"","text":"Load Packages 12345import tensorflow as tfimport osimport matplotlib.pyplot as plt%matplotlib inline Input Image 1234567891011from tensorflow.keras import datasets(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()image = train_x[0]# 차원 수 높이기image = image[tf.newaxis, ..., tf.newaxis]image.shape# Out(1, 28, 28, 1) Feature Extraction Convolution filters: layer에서 나갈 때 몇 개의 filter를 만들 것인지 kernel_size: filter(Weight)의 크기 strides: 몇 개의 pixel을 skip 하면서 훑어지나갈 것인지 (크기에도 영향을 준다.) padding: zero padding을 만들 것인지. VALID는 padding이 없고, SAME은 padding이 있습니다. (크기에도 영향을 준다.) activation: Activation Function을 만들 것인지. 당장 설정 안해도 Layer 층을 따로 만들 수 있습니다. (Default: None) 1234tf.keras.layers.Conv2D(filters=3, kernel_size=(3, 3), strides=(1, 1), padding='VALID', activation='relu')# (3, 3) 대신에 3으로도 대체 가능tf.keras.layers.Conv2D(3, 3, 1, 'VALID') Visualization 1234image = tf.cast(image, dtype=tf.float32)layer = tf.keras.layers.Conv2D(3, 3, strides=(1, 1), padding='SAME')output = layer(image) 12345plt.subplot(121)plt.imshow(image[0, :, :, 0], 'gray')plt.subplot(122)plt.imshow(output[0, :, :, 0], 'gray')plt.show() weight 불러오기 1234567891011121314weight = layer.get_weights()[0]plt.figure(figsize=(15, 5))plt.subplot(131)plt.hist(output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(132)plt.title(weight.shape)plt.imshow(weight[:, :, 0, 0], 'gray')plt.subplot(133)plt.title(output.shape)plt.imshow(output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Activation Function 0 미만의 값들을 0으로 바꿔준다. 12345678import numpy as npact_layer = tf.keras.layers.ReLU()act_output = act_layer(output)np.min(act_output), np.max(act_output)# Out(0.0, 244.73064) # 0미만 값들이 0으로 바뀜 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(act_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(act_output.shape)plt.imshow(act_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Pooling 강조되는 것들만 압축합니다. 123456pool_layer = tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=(2, 2), padding='SAME')pool_output = pool_layer(act_output)pool_output.shape# OutTensorShape([1, 14, 14, 3]) 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(pool_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(pool_output.shape)plt.imshow(pool_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Fully Connected Flatten 1234567891011layer = tf.keras.layers.Flatten()flatten = layer(output)flatten.shape# OutTensorShape([1, 2352]) # 28 * 28 * 3output.shape# OutTensorShape([1, 28, 28, 3]) 123456plt.figure(figsize=(10, 5))plt.subplot(211)plt.hist(flatten.numpy().ravel())plt.subplot(212)plt.imshow(flatten[:, :100])plt.show() Dense 하나씩 연결하겠다는 의미다. 123456layer = tf.keras.layers.Dense(32, activation='relu')output = layer(flatten)output.shape# OutTensorShape([1, 32]) # 32로 줄어들었습니다. DropOut 학습할 때만 랜덤하게 끊어준다. 학습이 끝나면 다시 복구시킨다. 1234567# 0.7은 비율입니다. 얼마나 끊을 것인지 살릴 것인지layer = tf.keras.layers.Dropout(0.7)output = layer(output)output.shape# OutTensorShape([1, 32]) Build Model 1234567891011121314151617181920212223242526272829303132from tensorflow.keras import layersinput_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(shape=input_shape)# Feature Extractionnet = layers.Conv2D(32, 3, padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)# Fully Connectednet = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.25)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic-CNN')model.summary() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# OutModel: \"Basic-CNN\"_________________________________________________________________Layer (type) Output Shape Param #=================================================================input_1 (InputLayer) [(None, 28, 28, 1)] 0_________________________________________________________________conv2d_25 (Conv2D) (None, 28, 28, 32) 320_________________________________________________________________activation_8 (Activation) (None, 28, 28, 32) 0_________________________________________________________________conv2d_26 (Conv2D) (None, 28, 28, 32) 9248_________________________________________________________________activation_9 (Activation) (None, 28, 28, 32) 0_________________________________________________________________max_pooling2d_8 (MaxPooling2 (None, 14, 14, 32) 0_________________________________________________________________dropout_5 (Dropout) (None, 14, 14, 32) 0_________________________________________________________________conv2d_27 (Conv2D) (None, 14, 14, 64) 18496_________________________________________________________________activation_10 (Activation) (None, 14, 14, 64) 0_________________________________________________________________conv2d_28 (Conv2D) (None, 14, 14, 64) 36928_________________________________________________________________activation_11 (Activation) (None, 14, 14, 64) 0_________________________________________________________________max_pooling2d_9 (MaxPooling2 (None, 7, 7, 64) 0_________________________________________________________________dropout_6 (Dropout) (None, 7, 7, 64) 0_________________________________________________________________flatten_4 (Flatten) (None, 3136) 0_________________________________________________________________dense_3 (Dense) (None, 512) 1606144_________________________________________________________________activation_12 (Activation) (None, 512) 0_________________________________________________________________dropout_7 (Dropout) (None, 512) 0_________________________________________________________________dense_4 (Dense) (None, 10) 5130_________________________________________________________________activation_13 (Activation) (None, 10) 0=================================================================Total params: 1,676,266Trainable params: 1,676,266Non-trainable params: 0_________________________________________________________________","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 예제 데이터셋 (MNIST) 사용","slug":"ai-dev-3","date":"2020-07-20T04:02:24.000Z","updated":"2023-07-17T12:54:27.550Z","comments":true,"path":"2020/07/20/ai-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-3/","excerpt":"","text":"Load Packages 123456import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tf%matplotlib inline 데이터 불러오기 TensorFlow 에서 제공해주는 데이터셋(MNIST) 예제 불러오기다. 12345678from tensorflow.keras import datasetsmnist = datasets.mnist(train_x, train_y), (test_x, test_y) = mnist.load_data()train_x.shape# Out(60000, 28, 28) Image Dataset 들여다보기 불러온 데이터셋에서 이미지 데이터 하나만 뽑아서 시각화한다. 데이터 하나만 뽑기 12345image = train_x[0]image.shape# Out(28, 28) 시각화 하기 12plt.imshow(image, 'gray')plt.show() Channel 관련 [Batch Size, Height, Width, Channel] Gray Scale 이면 1, RGB 이면 3으로 만들어줘야 한다. 데이터 차원수 늘리기(numpy) 123456# -1 인 경우 마지막에 차원을 늘린다는 의미입니다.train_x = np.expand_dims(train_x, -1)train_x.shape# Out(60000, 28, 28, 1) 데이터 차원수 늘리기 (tensorflow) 12345new_train_x = tf.expand_dims(train_x, -1)new_train_x.shape# OutTensorShape([60000, 28, 28, 1]) TensorFlow 공식홈페이지에 나온 방법이다. 12345new_train_x =train_x[..., tf.newaxis]new_train_x.shape# Out(60000, 28, 28, 1) 다시 시각화 하기 주의사항: matplotlib로 이미지 시각화 할 때 gray scale의 이미지는 3번째 dimension이 없으므로, 2개의 dimension으로 차원 조절해서 넣어줘야 한다. 1234567display = new_train_x[0, :, :, 0]ordisplay = np.squeeze(new_train_x[0])display.shape# Out(28, 28) 12plt.imshow(display, 'gray')plt.show() Label Dataset 들여다보기 Label 하나를 열어서 Image와 비교하여 제대로 들어갔는지, 어떤 식으로 저장 되어 있는지 확인한다. Label 하나만 뽑아보기 1234train_y[0]# Out5 Lebel 시각화 하기 123plt.title(train_y[0])plt.imshow(train_x[0], 'gray')plt.show() OneHot Encoding 컴퓨터가 이해할 수 있는 형태로 변환해서 Label을 주도록 한다. 12345678# 1[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]# 5[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]# 9[0, 0, 0, 0, 0, 0, 0, 0, 0, 1] 1을 예시로 one hot encoding 하기 123456from tensorflow.keras.utils import to_categoricalto_categorical(1, 10)# Outarray([0., 1., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) Label 확인해서 to_categorical 사용 12345label = train_y[0]label_onehot = to_categorical(label, num_classes=10)# Outarray([0., 0., 0., 0., 0., 1., 0., 0., 0., 0.], dtype=float32) one hot encoding으로 바꾼 것과 이미지 확인 123plt.title(label_onehot)plt.imshow(train_x[0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[Tensorflow 2.0] 기초 사용법","slug":"ai-dev-2","date":"2020-07-20T02:30:15.000Z","updated":"2023-07-17T12:53:41.945Z","comments":true,"path":"2020/07/20/ai-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-2/","excerpt":"","text":"Load Packages 12import numpy as npimport tensorflow as tf Tensor 생성 list -&gt; Tensor 1234tf.constant([1, 2, 3])# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; tuple -&gt; Tensor 123456tf.constant(((1, 2, 3), (1, 2, 3)))# Out&lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy=array([[1, 2, 3], [1, 2, 3]])&gt; Array -&gt; Tensor 12345arr = np.array([1, 2, 3])tf.constant(arr)# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; Tensor에 담긴 정보 확인 shape 확인 12345tensor = tf.constant(arr)tensor.shape# OutTensorShape([3]) Data Type 확인 주의: Tensor를 생성 할 때 Data Type을 정해주지 않기 때문에 혼동이 올 수 있다. Data Type에 따라 모델의 무게나 성능 차이에 영향을 줄 수 있다. 1234tensor.dtype# Outtf.int32 Data Type 정의 1234tf.constant([1, 2, 3], dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Data Type 변환 1234tf.cast(tensor, dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Tensor에서 Numpy 불러오기 1234tensor.numpy()# Outarray([1, 2, 3]) Numpy로 변환된 것 확인 1234type(tensor.numpy())# Outnumpy.ndarray 난수 생성 Numpy에서는 난수 생성 시 기본적으로 Normal Distribution을 생성한다. Normal Distribution은 중심 극한 이론에 의한 연속적인 모양 Uniform Distribution은 중심 극한 이론과는 무관하며 불연속적이며 일정한 분포 Numpy에서 사용법 12345np.random.randn(9)# Outarray([ 0.53020669, 0.65508422, -0.59177912, 1.16459962, -1.05122869, 0.08080872, 0.17245994, 0.08721459, -0.69788519]) TensorFlow에서 사용법 1234567tf.random.normal([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[ 0.46394104, -0.8973731 , -0.1977468 ], [-1.6685097 , -0.8181516 , -1.8963411 ], [ 0.5654544 , 0.13616897, -1.7370273 ]], dtype=float32)&gt; 1234567tf.random.uniform([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[0.7996844 , 0.05048668, 0.7060809 ], [0.9390234 , 0.29056323, 0.33341527], [0.4387114 , 0.13688791, 0.12659645]], dtype=float32)&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"Tensorflow 2.0과 PyTorch 소개","slug":"ai-dev-1","date":"2020-07-17T10:02:44.000Z","updated":"2023-07-17T12:53:10.927Z","comments":true,"path":"2020/07/17/ai-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-dev-1/","excerpt":"","text":"TensorFlow 2.0 1.x에 비해 정말 쉬워졌다. Numpy Array와 호환이 쉽다. TensorBorad, TFLite, TPU 여전히 많은 사용자들이 사용한다. 상용 목적으로 주로 사용한다. PyTorch Dynamic Graph &amp; Define by Run 쉽고 빠르며 코드가 간결하다. 빠르게 성장하고 있다. 커뮤니티가 많이 활성화 되고 있다. 연구 목적으로 주로 사용한다. 둘 다 때에 따라 환경에 맞게 사용하면 될 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[Python] 시각화 기초(이미지)","slug":"ai-development-6","date":"2020-07-17T09:20:17.000Z","updated":"2024-01-11T08:08:39.221Z","comments":true,"path":"2020/07/17/ai-development-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-development-6/","excerpt":"","text":"Load Packages 12345import numpy as npfrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 이미지 불러오기 123456789path = 'images/dog.jpg'image_pil = Image.open(path)image = np.array(image_pil)image.shape# Out(300, 400, 3) 이미지 들여다 보기 1234np.min(image), np.max(image)# Out(0, 255) 그래프로 시각화하기 12plt.hist(image.ravel(), 256, [0, 256])plt.show() 그림 나타내기 12plt.imshow(image)plt.show() 이미지 흑백으로 열기 1234567image_pil = Image.open(path).convert(\"L\")image_bw = np.array(image_pil)image_bw.shape# Out(300, 400) 흑백 이미지 열기 12plt.imshow(image_bw, 'gray')plt.show() 다른 색상으로 cmap 표현하기 gray scale 12plt.imshow(image_bw, 'gray')plt.show() RdBu(Red and Blue) 12plt.imshow(image_bw, 'RdBu')plt.show() jet 색상 값이 높을수록 빨간색, 낮을수록 파란색으로 표현한다. 12plt.imshow(image_bw, 'jet')plt.show() Colorbar 추가하기 123plt.imshow(image_bw, 'jet')plt.colorbar()plt.show() 이미지 설정 이미지 보기 사이즈를 조절한다. 123plt.figure(figsize=(10, 10))plt.imshow(image)plt.show() 이미지에 제목 추가 123plt.title('Dog')plt.imshow(image)plt.show() 두 번째 이미지 열기 1234567cat_path = 'images/cat.jpg'cat_pil = Image.open(cat_path)cat_image = np.array(cat_pil)plt.imshow(cat_image)plt.show() 두 번째 이미지를 첫 번째 이미지 모양에 맞추기 준비 먼저 opencv 패키지를 설치한다. 1$ pip install opencv-python 12345678# Inimport cv2dog_image = cv2.resize(image, (400, 300))dog_image.shape, cat_image.shape# Out((300, 400, 3), (300, 400, 3)) 이미지 합치기 123plt.imshow(dog_image)plt.imshow(cat_image, alpha=0.5)plt.show() Subplot 12345678plt.figure(figsize=(10, 10))plt.subplot(221)plt.imshow(dog_image)plt.subplot(222)plt.imshow(image_bw, 'gray')plt.subplot(223)plt.imshow(cat_image)plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] 시각화 기초(그래프)","slug":"ai-development-5","date":"2020-07-16T09:08:35.000Z","updated":"2024-01-11T08:08:16.508Z","comments":true,"path":"2020/07/16/ai-development-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/16/ai-development-5/","excerpt":"","text":"Python에서 matplotlib를 사용하여 시각화하는 방법에 대해 알아보겠다. Load Packages 1234import numpy as npimport matplotlib.pyplot as plt%matplotlib inline Basic Attributes 123456789101112131415alpha : 투명도king : 그래프 종류 'line', 'bar', 'barh', 'kde'logy : Y축에 대해 Log scalinguse_index : 객체의 색인을 눈금 이름으로 사용할지 여부rot : 눈금 이름 돌리기 (rotating) 0 ~ 360xticks, yticks : X, Y축으로 사용할 값xlim, ylim : X, Y축의 한계grid : 축의 그리드를 표현할지 여부subplots : 각 column에 독립된 subplot 그리기sharex, sharey : subplots=True 이면 같은 X, Y축을 공유하고 눈금과 한계를 연결figsize : 생성될 그래프의 크기를 tuple로 지정title : 그래프의 제목 지정legend : subplot의 범례 지정sort_columns : column을 알파벳 순서로 그린다. Matplotlib 사용하기 점선 그래프 그리기 123data = np.random.randn(50).cumsum()plt.plot(data)plt.show() 여러 그래프 그릴 준비 하기 123plt.subplot(1, 2, 1)plt.subplot(1, 2, 2)plt.show() Multi Graph 그리기 12345678910111213hist_data = np.random.randn(100)scat_data = np.arange(30)plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 옵션 그래프를 그릴 때 표시 되는 색이나 마커 패턴을 바꾸는 것을 확인한다. 색상: r(빨간색), g(초록색), b(파란색), C(청록색), y(노란색), k(검은색), w(흰색) 마커: o(원), v(역삼각형), ^(삼각형), s(네모), +(플러스), .(점) 12plt.plot(data, 'go')plt.show() 그래프 사이즈 조절 plt.figure 안에 figsize를 이용하여 가로, 세로 길이 조절 가능하다. (inch 단위) 123plt.figure(figsize=(10, 10))plt.plot(data, 'k+')plt.show() 여러 그래프 그리고 그에 대한 크기 조절을 한다. 12345678910111213# 맨 위에 있어야 한다.plt.figure(figsize=(10, 5))plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 겹치기와 legend 표시 123456data = np.random.randn(30).cumsum()plt.plot(data, 'k--', label='Default')plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')plt.legend()plt.show() 이름 달기 12345plt.plot(np.random.randn(1000).cumsum())plt.title('Random Graph')plt.xlabel('Stages')plt.ylabel('Values')plt.show() 종합 1234567plt.title('Graph')plt.plot(np.random.randn(500).cumsum(), 'k^', label='one')plt.plot(np.random.randn(500).cumsum(), 'b.', label='two')plt.plot(np.random.randn(500).cumsum(), 'r', label='three')plt.legend()plt.show() 그래프 저장하기 12# 현재 작업 위치로 저장한다.plt.savefig('saved_graph.svg')","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] Numpy 기초(3)","slug":"ai-development-4","date":"2020-07-09T07:16:50.000Z","updated":"2024-01-11T08:07:54.347Z","comments":true,"path":"2020/07/09/ai-development-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/09/ai-development-4/","excerpt":"","text":"zeros 0으로 채워진 numpy 배열을 만든다. 123456np.zeros([3, 3])# Outarray([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) ones 1로 채워진 numpy 배열을 만든다. 123456np.ones([3, 3])# Outarray([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) arange 하나의 값만 입력하면 1씩 증가하는 1차원 배열을 만든다. 1234np.arange(10)# Outarray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 두 개의 인자를 넣으면 입력한 값의 범위만큼 배열을 만든다. 1234np.arange(4, 9)# Outarray([4, 5, 6, 7, 8]) reshape 1차원 배열의 차원 수를 바꿀 때 사용된다. 123456np.arange(9).reshape(3, 3)# Outarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) Index 기본적으로 python 에서 쓰는 방식과 동일하다. 12345arr = np.arange(9).reshape(3, 3)arr[1]# Outarray([3, 4, 5]) Slicing 다차원 배열의 원소 중 복수 개를 접근하기 위해 사용한다. 123456arr = np.arange(9).reshape(3, 3)arr[1:]# Outarray([[3, 4, 5], [6, 7, 8]]) 12345arr[1:, 1:]# Outarray([[4, 5], [7, 8]]) Boolean Indexing 원하는 행 또는 열의 값만 얻을 수 있고, 값들을 변경할 수 있다. 1234567891011data = np.random.randn(3, 3)data &lt;= 0# Outarray([[-0.43152818, -2.40848595, -0.00309727], [ 0.74972847, 0.18525482, -0.39854904], [ 1.09053126, 0.32096086, 0.31703319]])array([[ True, True, True], [False, False, True], [False, False, False]]) 1234data[data &lt;= 0]# Outarray([-0.43152818, -2.40848595, -0.00309727, -0.39854904]) 123456data[data &lt;= 0] = 1# Outarray([[1. , 1. , 1. ], [0.74972847, 0.18525482, 1. ], [1.09053126, 0.32096086, 0.31703319]]) Broadcast 연산하려는 서로 다른 두 개의 행렬의 shape가 같지 않고, 한쪽의 차원이라도 같거나 또는 값의 개수가 한 개 일 때 이를 여러 복사를 하여 연산한다. 1234567arr = np.arange(9).reshape(3, 3)arr + 3# Outarray([[ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) 123456arr * 3# Outarray([[ 0, 3, 6], [ 9, 12, 15], [18, 21, 24]]) 123456arr + np.array([1, 2, 3])# Outarray([[ 1, 3, 5], [ 4, 6, 8], [ 7, 9, 11]]) Math Function 배열 연산에 대해 여러 가지 예제다. 123456arr + 5arr * 5arr + arrnp.add(arr, 1)np.multiply(arr, 3) 12345678910np.sum(arr)np.sum(arr + arr_2)np.sum(arr, 0) # 0차원 기준으로 더해서 배열을 만든다.np.max(arr)np.max(arr, 0) # 0차원에서 가장 큰 값들을 배열로 만든다.np.min(arr)np.mean(arr) 12345678910arr = np.array([1, 6, 3, 7, 3, 2, 9, 0, 2])np.argmax(arr) # 가장 큰 수의 index값을 리턴한다.# Out6np.argmin(arr)# Out7 12345arr = np.array([3, 5, 6, 6, 3, 3, 1])np.unique(arr) # 유니크한 값들을 리턴한다.# Outarray([1, 3, 5, 6])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(2)","slug":"ai-development-3","date":"2020-07-02T01:36:18.000Z","updated":"2024-01-11T08:06:52.087Z","comments":true,"path":"2020/07/02/ai-development-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/02/ai-development-3/","excerpt":"","text":"Numpy 기초에 대해 다뤄보겠다. Load Package 1import numpy as np data type 배열의 dtype을 봅니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3]])arr.dtype# Outdtype('int32') .astype() 으로 datatype을 변환 가능하다. 123456arr = arr.astype('float32')arr = arr.astype(np.float32)# Outarray([[1., 2., 3.], [1., 2., 3.]], dtype=float32) len(arr.shape)를 통해서 차원이 개수를 확인할 수 있지만, 다음과 같이 ndim 을 통해 차원 수를 확인하다. 12345len(arr.shape)arr.ndim# Out2 Reshape 차원을 바꾼다. 12345arr = arr.reshape([1, 6])arr.shape# Out(1, 6) 차원을 몇 개로 나눠야할지 모를 경우 -1을 활용하다. 12345arr = arr.reshape(-1)arr.shape# Out(6,) 3차원으로 늘리는 방법이다. 123456arr = np.random.randn(8, 8) # (8, 8)arr = arr.reshape([32, 2]) # (32, 2)arr = arr.reshape([-1, 2, 1])# Out(32, 2, 1) Ravel 배열을 1차원으로 바꿔준다. 나중에 배열 layer를 flatten 할 때 같은 기능이라 생각하면 된다. 12345arr = arr.ravel()arr.shape# Out(64,) np.expand_dims() 안의 값은 유지하되 차원 수를 늘리고 싶을 때 사용한다. 12345arr = np.expand_dims(arr, 0)arr.shape# Out(1, 64)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(1)","slug":"ai-development-2","date":"2020-07-01T08:11:52.000Z","updated":"2024-01-11T08:06:05.488Z","comments":true,"path":"2020/07/01/ai-development-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/01/ai-development-2/","excerpt":"","text":"Numpy 란 Numpy는 C언어로 구현된 파이썬 라이브러리로써, 고성능의 수치계산을 위해 제작되었습니다. Numerical Python의 줄임말이기도 한 Numpy는 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공합니다. 출처: Tigercow.Door Numpy는 고차원적인 데이터를 다루기 쉽게 만들어져 있어 딥러닝을 하게 되면 많이 접하게 됩니다. 이제 Numpy 사용방법에 대해 알아보겠습니다. 12# Numpy 사용하기import numpy as np 0차원 numpy array는 1 또는 5, 10와 같이 숫자 데이터를 array화 해줄 수 있습니다. 12345arr = np.array(5);arr.shape # 배열의 형태(크기)를 나타냅니다.# Out() # shape가 아무것도 없는 것으로 나옵니다. 1234arr.ndim # 배열의 차원을 나타냅니다.# Out0 # 0차원을 의미합니다. 1차원 숫자가 10과 같이 하나만 들어간다고 해도 [] 리스트를 한번 씌우게 되면 차원이 생깁니다. 이때는 1차원이 되는데 numpy에서 shape를 표현할 때 (1)이 아닌 (1,) 형식으로 표현하게 됩니다. 12345arr = np.array([5])arr.shape# Out(1,) (3,)에서 3은 3이라는 값이 들어간 것이 아닌 1차원에 3개의 값이 들어갔다는 의미입니다. 2차원 대괄호를 추가적으로 씌우면 차원이 추가적으로 하나 생깁니다. 12345arr = np.array([[1, 2, 3]])arr.shape# Out(1, 3) 다음의 shape를 보면 차원이 2개 있고, 각 차원마다 각각 3개의 값이 들어있다는 의미입니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])arr.shape# Out(3, 3) 참고로 0차원 숫자에 대괄호를 2번 씌우면 두 개의 차원이 됩니다. 12345arr = np.array([[10]])arr.shape# Out(1, 1) 다차원 12345678910111213141516171819arr = np.array([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]])# Outarray([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]]) 4차원의 배열을 나타냅니다. 1234arr.shape# Out(2, 2, 3, 3)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"인공지능 개발준비 - 개발환경 구축(Windows)","slug":"ai-development-1","date":"2020-06-30T02:34:28.000Z","updated":"2024-01-11T08:04:51.172Z","comments":true,"path":"2020/06/30/ai-development-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/ai-development-1/","excerpt":"","text":"인공지능(AI)을 통해 개발을 하기 위해 개발 도구들을 설치합니다. 1. Anaconda 설치 Anaconda는 여러 가지 수학 및 과학 패키지들을 기본적으로 포함하고 있는 Python 배포판입니다. 그래서 머신러닝, 딥러닝, 데이터 분석에서 사용을 하려고 한다면 Anaconda를 통해 설치하는 것이 좋습니다. Anaconda Download 사이트에 접속하여 아래로 내려가 보면 다운로드 화면이 보입니다. 현재 Windows 운영체제에 맞게 선택하여 다운로드를 합니다. 다운로드가 완료되면 설치를 진행합니다. Next 버튼을 클릭하다가 아래 그림처럼 All Users를 선택합니다. 간혹 Windows에서 사용자의 계정을 한글로 만들었을 경우 설치할 때 또는 개발할 때 에러가 날 수 있기 때문에 선택합니다. 아래 그림처럼 체크박스도 선택을 하여 환경변수 설정이 되도록 합니다. Install 버튼을 클릭하면 설치가 됩니다. 설치가 잘 되었나 확인하려면 workspace 폴더에서 커맨드 창을 열고 다음 명령어를 실행합니다. 1$ c:\\workspace&gt; jupyter notebook Jupyter Notebook 페이지가 실행되고 Python 코드를 작성할 수 있습니다. 2. TensorFlow 설치 TensorFlow는 머신러닝을 위한 엔드 투 엔드 오픈소스 플랫폼입니다. 도구, 라이브러리, 커뮤니티 리소스로 구성된 포괄적이고 유연한 생태계를 통해 연구원들은 ML에서 첨단 기술을 구현할 수 있고 개발자들은 ML이 접목된 애플리케이션을 손쉽게 빌드 및 배포할 수 있습니다. 출처 : https://www.tensorflow.org/?hl=ko TensorFlow 2 설치 사이트에 접속합니다. 설치 가이드에 따라 설치를 합니다. 1$ pip install tensorflow 설치가 완료되면 Jupyter Notebook에서 import를 하여 확인합니다. 3. Pytorch 설치 PyTorch는 Python을 위한 오픈소스 머신 러닝 라이브러리입니다. Torch를 기반으로 하며, 자연어 처리와 같은 애플리케이션을 위해 사용됩니다. 출처 : 위키백과 Pytorch 사이트에 접속합니다. 아래로 내려가 보면 여러가지 설정을 하여 설치하는 방법을 안내해줍니다. Windows 버전이기 때문에 아래 그림 처럼 설정을 합니다. 만약에 GPU를 사용할 수 있으면 CUDA 버전에 맞게 설정하면 됩니다. 설정이 완료되었으면 Run this Command 칸의 내용을 복사하여 Command 창에 붙여넣기 하고 실행을 합니다. TensorFlow와 마찬가지로 Jupyter Notebook에서 import를 하여 설치가 완료되었는지 확인합니다. AI 개발 준비가 모두 완료 되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"}]},{"title":"[C++] string을 이용한 File Path 분리 방법","slug":"cpp-coding-1","date":"2020-06-30T02:05:16.000Z","updated":"2024-01-11T08:05:22.961Z","comments":true,"path":"2020/06/30/cpp-coding-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/cpp-coding-1/","excerpt":"","text":"개요 string 형식의 파일 경로를 이용하여 File Path와 Name을 분리합니다. 1) File Path와 File Name 분리 1234567891011121314#include &lt;iostream&gt;namespace using std;int main()&#123; string pullPath = \"c:\\\\test\\\\test.tif\"; int find = pullPath.rfind(\"\\\\\") + 1; string filePath = pullPath.substr(0, find); string fileName = pullPath.substr(find, pullPath.length() - find); cout &lt;&lt; \"Folder Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"File Name : \" &lt;&lt; fileName &lt;&lt; endl;&#125; 결과 12Folder Path : c:\\\\testFile Name : test.tif 2) 파일 확장자 바꾸기 123456789101112131415161718#include &lt;iostream&gt;namespace using std;int main()&#123; string filePath = \"c:\\\\test\\\\test.tif\"; string modExt = \"ntf\"; int ext = filePath.rfind(\"tif\"); int name = filePath.rfind(\"\\\\\") + 1; string dstPath = filePath.substr(0, name); dstPath += filePath.substr(name, ext - name); dstPath += modExt; cout &lt;&lt; \"Input Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"Output Path : \" &lt;&lt; dstPath &lt;&lt; endl;&#125; 결과 12Input Path : c:\\\\test\\\\test.tifOutput Path : c:\\\\test\\\\test.ntf","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"Hexo Quick Start","slug":"hello-world","date":"2020-06-29T06:30:00.000Z","updated":"2022-12-30T01:18:40.221Z","comments":true,"path":"2020/06/29/hello-world/","link":"","permalink":"http://hgko1207.github.io/2020/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[Git] 이클립스에서 Git Repository 연동","slug":"eclipse-git-clone","date":"2020-05-18T01:48:33.000Z","updated":"2024-01-11T07:09:32.719Z","comments":true,"path":"2020/05/18/eclipse-git-clone/","link":"","permalink":"http://hgko1207.github.io/2020/05/18/eclipse-git-clone/","excerpt":"","text":"이클립스와 Git 원격저장소 연동하는 방법과 프로젝트를 내려받는 방법에 대해 알아보도록 하겠습니다. 1. 원격저장소 주소 복사 먼저 github 사이트에서 생성한 저장소의 주소를 복사합니다. 2. 이클립스 실행 이클립스를 실행하고 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보입니다. Git을 선택하고 [OK] 버튼을 눌러 활성화시킵니다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경됩니다. 3. 원격저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭합니다. Clone Git Repository 창의 첫 번째 빨간 박스에 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력됩니다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭합니다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭합니다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭합니다. 원격저장소가 연동되면 아래 그림과 같이 프로젝트를 확인할 수 있습니다. 4. 프로젝트 내려받기 연동된 원격저장소에서 Working Tree -&gt; 프로젝트 선택 -&gt; 우클릭 -&gt; Import Projects 선택을 합니다. Import Projects 창에서 내려받아지는 경로를 확인 후 [Finish] 버튼을 클릭합니다. 내려받기가 완료되면 프로젝트가 생성됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"}]},{"title":"Hyperspectral(초분광) 센서","slug":"satellite-hyperspectral","date":"2020-05-11T01:17:10.000Z","updated":"2023-07-13T03:27:46.618Z","comments":true,"path":"2020/05/11/satellite-hyperspectral/","link":"","permalink":"http://hgko1207.github.io/2020/05/11/satellite-hyperspectral/","excerpt":"","text":"Hyperspectral 특징 초분광 영상의 픽셀 분광은 하나의 표면에 대한 다중분광픽셀 스펙트럼에서 이용할 수 있는 것보다 훨씬 많은 정보 제공 가능하다. Hyperspectral 원격탐사 특징 입사되는 빛을 분광시켜 영상의 각 화소에 해당하는 지표물의 수십에서 수백 개의 분광 정보를 취득하고 그 개체의 정보를 이미지 형태로 확보 가능 물질 고유의 광학적 성질과 물질의 흡수 및 반사 특징을 분석함으로써 토지피복, 식생, 그리고 수질 등의 식별에 주로 이용된다. 스펙트럼 영상은 두 개의 공간적 차원과 하나의 스펙트럼 크기로 구성된 3차원 (x, y, λ)으로 나타남(x, y : 공간적 2차원 / λ : 스펙트럼 크기) 2차원 (2-D) 검출기에서 각 화소에 스펙트럼 정보를 수집하여 초분광 큐브로 알려진 공간 및 스펙트럼 정보인 3차원(3-D) 데이터를 형성 Hyperspectral 활용 위성 Terra/Aqua(MODIS) STSat-3(COMIS) NMP-EO-1(Hyperion) NMP-EO-1(Hyperion)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"}]},{"title":"[MySQL] Query 정리","slug":"mysql-query","date":"2020-05-07T02:17:14.000Z","updated":"2024-01-11T07:08:12.345Z","comments":true,"path":"2020/05/07/mysql-query/","link":"","permalink":"http://hgko1207.github.io/2020/05/07/mysql-query/","excerpt":"","text":"SELECT 123SELECT * FROM 테이블명SELECT * FROM 테이블명 WHERE 조건SELECT 필드명1, 필드명2, ... FROM 테이블명 WHERE 조건 INSERT 123INSERT INTO 테이블명(필드명1, 필드명2, 필드명3, ...) VALUES (데이터값1, 데이터값2, 데이터값3, ...)또는INSERT INTO 테이블명 VALUES (데이터값1, 데이터값2, 데이터값3, ...) UPDATE 1UPDATE 테이블명 SET 필드명1=데이터값1, 필드명2=데이터값2, ... WHERE 필드명=데이터값 DELETE 1DELETE FROM 테이블명 WHERE 필드명=데이터값 중복 데이터 조회 중복된 것 모두 조회 1SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 중복된 개수가 n개 이상인 것 12345SELECT 필드명, count(*) as 변수명 FROM 테이블명 GROUP BY 필드명 HAVING 변수명 &gt; n;또는SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 HAVING count(*) &gt; n;SELECT 필드명, count(*) as 변수명 FROM 테이블명 WHERE 조건 GROUP BY 필드명 HAVING 변수명 &gt; n; 중복 데이터 추출(WHERE 절의 IN 사용) 123SELECT * FROM 테이블명 WHERE column1 IN ( SELECT column1 FROM 테이블명 WHERE 조건 GROUP BY column1 HAVING count(*) &gt; 1) AUTO_INCREMENT 초기화 1ALTER TABLE 테이블명 AUTO_INCREMENT = 시작할 값; 날짜 12SELECT * FROM 테이블명 WHERE 필드명 &gt;= 시작날짜SELECT * FROM 테이블명 WHERE 필드명 BETWEEN 시작날짜 and 종료날짜","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"Clean Code","slug":"book-cleancode","date":"2020-04-28T00:50:27.000Z","updated":"2024-01-11T07:07:47.404Z","comments":true,"path":"2020/04/28/book-cleancode/","link":"","permalink":"http://hgko1207.github.io/2020/04/28/book-cleancode/","excerpt":"","text":"책 정보 책 소개 애자일 소프트웨어의 혁명적인 패러다임을 제시하는 책이다. 저자 로버트 마틴은 오브젝트 멘토(Object Mentor)의 동료들과 힘을 모아 ‘개발하며’ 클린 코드를 만드는 최상의 애자일 기법을 정제하여『Clean Code 클린 코드』에 담았다. 아주 많은 코드를 읽고 그 코드의 무엇이 옳은지, 그른지 생각하며 전문가로서 자신이 지니는 가치를 돌아보기 위해 꾸준히 노력한다면, 이 책을 통해 여러분의 프로그래밍 실력은 한층 더 높아질 것이다. 리뷰 전부 다 읽어보진 못하였지만 읽다 보면 얼마나 잘못하고 있었는지 반성하게 됩니다. 의미 있는 이름, 좋은 주석 다는 법, 객체와 자료 구조 등 어떻게 깨끗하고 아름다운 코드를 작성할 수 있는지 알려줍니다. 잘못된 점과 좋은 점을 짚어주기 때문에 내가 짰던 코드와 비교할 수 있고 17장에는 사례 연구를 만들면서 수집한 휴리스틱과 냄새를 열거합니다. 협업을 할 때 필요한 내용들이며, 지금은 중간 개발자로서 신입 개발자를 교육할 때에도 정말 좋은 추천서라고 느껴집니다. 책 내용이 많고 글자 수도 많아서 끈기 있게 읽어야 할 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"}]},{"title":"Microwave(극초단파) 센서","slug":"satellite-microwave","date":"2020-04-27T00:42:37.000Z","updated":"2023-07-13T03:27:04.724Z","comments":true,"path":"2020/04/27/satellite-microwave/","link":"","permalink":"http://hgko1207.github.io/2020/04/27/satellite-microwave/","excerpt":"","text":"Microwave 특징 물체들이 방출하는 마이크로웨이브 파를 위성에서 감지하여 원격탐사에 활용하는 기술이다. 마이크로파의 파장 영역은 보통 1mm ~ 1m 이다. 자연방사 에너지를 관측하는지, 위성에서 Microwave를 쏘아서 되돌아오는 신호를 관측하는지에 따라 Passive microwave와 Active microwave로 나눌 수 있다. 대표적으로 SAR, 산란계, 고도계, 복사계로 나눠진다. Microwave 원격탐사 특징 1. Passive vs Active 2. 센서 특징 Microwave 활용 위성 GCOM-W1(AMSR-2) SMAP(SMAP) NOAA, AQUA, Metop(AMSU-A) GPM(GMI, GPM Microwave Imager)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"}]},{"title":"IR(적외선) 센서","slug":"satellite-ir-sensor","date":"2020-04-24T00:50:14.000Z","updated":"2023-07-13T03:26:42.946Z","comments":true,"path":"2020/04/24/satellite-ir-sensor/","link":"","permalink":"http://hgko1207.github.io/2020/04/24/satellite-ir-sensor/","excerpt":"","text":"IR(Infrared) 정의 가시광선대의 적색 끝부분에서부터 마이크로파전까지의 전자기파, 가시광선이나 자외선에 비해 강한 열작용을 가지고 있다. 파장 대역 : 0.7-1000㎛ 활용 분야 : 소독/멸균, 외과수술 및 종양 제거, 군사적(야간 투시경), 야간 촬영용 카메라 IR 특징 태양빛을 프리즘을 이용하여 스펙트럼으로 분산시킬 때 붉은색보다 더 바깥쪽에 위치함 열을 가지는 모든 물체에서 방출 또는 반사되는 특징이 있기 때문에 강한 열작용을 가짐(열선이라고도 불림) 파장에 따라 지구 대기를 투과하지 못하는 특성이 있어 대기 환경에 민감 IR 원격탐사의 특징 장파장으로 갈수록 물체 고유의 특성이 잘 관측될 수 있음 야간이나 해무(바다 안개), 옅은 구름이 낀 상황에서도 촬영 가능 해양 및 구름의 온도를 측정하여 지구의 열 balance를 측정하고, 해수표면으로부터 방사되어 나오는 원적외선을 감지함 인접한 물체간의 열적 특성 차이나 잠열 분석이 가능한 정보 제공(공간 분해능 + 열적 분해능) 센서의 발달과 더불어 온도 해상도는 1K에서 0.3K 정도로 높아짐 공간 해상도 역시 250m의 해상도를 갖는 것이 개발됨에 따라 large scale에서 small scale의 연구가 가능해짐 IR 활용 위성 Terra(ASTER) Terra/Aqua(MODIS) Landsat-7(ETM+)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"}]},{"title":"[Android Studio] 설치 및 주요 기능 정리","slug":"android-studio","date":"2020-04-21T00:49:50.000Z","updated":"2024-01-11T07:06:07.264Z","comments":true,"path":"2020/04/21/android-studio/","link":"","permalink":"http://hgko1207.github.io/2020/04/21/android-studio/","excerpt":"","text":"1. Android Studio 다운로드 및 설치 다운로드 사이트에서 최신 버전의 Android Studio를 다운로드하여 설치합니다. 현재 최신은 3.6.3 버전이다. 설치를 완료하고 다음 화면이 오픈되면 이제 개발을 시작할 수 있다. 2. 프로젝트 생성 Start a new Android Studio Project 선택 Slelect a Project Templat Empty Activity 선택 Configure Your Project Name: HelloApp Package: com.hgko.helloapp Language: Java or Kotlin Minimum SDK: API 26: Android 8.0(Oreo) Finish 버튼 클릭하면 다음과 같이 프로젝트가 생성된다. 3. 실행 1) 스마트폰 연결 시 스마트폰에서 USB 디버깅 설정 설정 &gt; 빌드 번호 6번 터치 -&gt; 개발자 옵션 화성화(메뉴가 보임) &gt; USB 디버깅 활성화 선택 스마트폰 케이블 연결 logcat에서 디바이스 연결 확인 2) 가상 디바이스 사용 시 Tools &gt; AVD Manager Create Virtual Device… 클릭 Select Hardware 적당한 디바이스를 선택한다. 예) Phone &gt; Pixel XL System Image Android 버전을 선택 Finish 버튼 클릭 스마트폰 또는 가상 디바이스를 연결 후 상단 툴바에서 장비를 선택 후 Run을 클릭하면 컴파일이 되며, 앱이 설치되고 구동된다. 4. SDK 설치 Tools &gt; SDK Manager 에서 설치 현황 및 안드로이드 버젼 별 SDK 설치/삭제/업데이트 등을 수행할 수 있다. 5. Device File Explorer 연결된 장비(스마트폰 or 가상 디바이스)의 파일 시스템을 탐색하는 뷰를 제공한다. View &gt; Tool Windows &gt; Device File Explorer 메뉴를 클릭하여 다음과 같이 Device File Explorer 뷰를 오픈한다. 디바이스 파일 중에 특히 다음과 같은 경로들이 유용하다. 1) data/data/app_name/ 내부 저장소에 저장괸 입의 데이터 파일 경로 2) sdcard/ 외부 사용자 SD 카드에 저장된 파일(사진 등) 경로 6. 주요 단축키 참고 : Android 스튜디오 단축키 설명 단축키 기본 코드 완성 Ctrl+Space 스마트 코드 완성 Ctrl+Shift+Enter, Ctrl+Enter 자동 Import Alt+Enter 주석 Ctrl+/ 블록 주석 Ctrl+Shift+/ 빌드 Ctrl+F9 복사 F5 코드 서식 자동 지정 Ctrl+Alt+L 자동 들여 쓰기 Ctrl+Alt+I 7. 자동 import 설정 Alt + Enter를 입력하지 않아도 클래스 사용시 자동으로 import 문을 추가해 주는 기능이다. File &gt; Settings &gt; Editor &gt; General &gt; Auto Import 에서 다음과 같이 “Add unambiguous…” 와 “Optimize imports…” 를 체크한다. 8. 새로운 개념/기능 1) ART VM 안드로이드는 이전 가지는 DVT에서 구동되었으나 현재는 ART라는 VM을 이용한다. ART는 JIT(Just In Time, 실행 시 컴파일 방식으로 2.2 버젼부터 지원)을 지원하는 VM들과 달리 앱이 설치 시 전체 바이트 코드가 기계어로 컴파일되는 AOT(Ahead Of Time)를 이용하므로 획기적으로 성능이 개선되었다. 2) App Bundle 안드로이드 앱 내보내기에 기존 APK 파일 외에 앱 번들이 추가되었다. Google Play의 새로운 앱 제공 모델인 Dynamic Delivery는 App Bundle을 사용하여 각 사용자의 기기 설정에 최적화된 APK를 생성하고 제공하므로, 사용자는 앱 실행에 필요한 최소한의 코드와 리소스만 다운로드하면 된다. 개발자가 더 이상 다양한 기기를 지원하기 위해 여러 개의 APK를 빌드하고 서명하고 관리할 필요가 없으며 사용자는 더 작고 최적화된 앱을 다운로드할 수 있다. 또한 앱 프로젝트에 동적 기능 모듈을 추가하여 App Bundle에 포함할 수 있다. 모듈의 일부 기능과 자원(동영상, 이미지 등)들은 사용자가 처음 앱을 다운로드하고 설치할 때 포함되지 않도록 할 수 있다. 나중에 앱에서 Play Core 라이브러리를 사용하여 이러한 모듈을 동적 기능 APK로 다운로드하도록 요청할 수 있다. 정리하면 App Bundle로 내보내기를 추천한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"}]},{"title":"[JavaScript] IE에서 작동하지 않는 BLOB 다운로드","slug":"javascript-blob","date":"2020-04-20T00:56:01.000Z","updated":"2023-07-13T03:24:54.579Z","comments":true,"path":"2020/04/20/javascript-blob/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/javascript-blob/","excerpt":"","text":"이미지를 Jcrop 라이브러리를 사용하여 자르고 Canvas 영역을 blob 형식으로 바꿔서 a Tag 를 생성하여 다운로드를 시도하였다. 크롬에서는 잘 동작하였지만 IE 에서는 동작하지 않고 에러를 발생하였다. 아래 코드처럼 작성하였더니 둘 다 동작하였다. 소스 코드 12345678910111213function downloadURI(blob, name) &#123; if (window.navigator &amp;&amp; window.navigator.msSaveOrOpenBlob) &#123; // IE에서 동작 window.navigator.msSaveBlob(blob, name); &#125; else &#123; // 크롬에서 동작 var link = document.createElement('a'); link.download = name; link.href = URL.createObjectURL(blob); link.click(); delete link; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"}]},{"title":"SAR 위성 활용","slug":"satellite-sar","date":"2020-04-20T00:31:30.000Z","updated":"2022-09-02T14:49:52.079Z","comments":true,"path":"2020/04/20/satellite-sar/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/satellite-sar/","excerpt":"","text":"SAR 위성 소개 SAR 위성이란? SAR(Synthetic Aperture Radar)란 각 Band의 다양한 파장대의 신호를 이용 지표면의 특성을 영상화 함 BANS 별 소개 SAR(파장 and 편파) 1. KOMPSAT-5(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. TerraSAR-X(독일의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. ALOS-2(일본의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 4. RADARSAT-2(캐나다의 위성) 위성의 본체 및 탑재체 제원 촬영모드 활용 분야 별 촬영 모드(개념도) 활용 분야 별 촬영 모드(지상) 활용 분야 별 촬영 모드(해양)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"}]},{"title":"[Android Studio] lombok 사용 방법","slug":"android-lombok","date":"2020-04-18T11:14:23.000Z","updated":"2024-01-11T07:04:44.560Z","comments":true,"path":"2020/04/18/android-lombok/","link":"","permalink":"http://hgko1207.github.io/2020/04/18/android-lombok/","excerpt":"","text":"자바에서 코드를 작성 시 모델을 만들다 보면 constructor와 기본 getter/setter 그리고 상황에 따라서 builder를 만들어 사용해야 합니다. 그런데 이런 일들을 모두 타이핑 하다 보니 보일러플레이트 같은 코드들이 많이도 써야 합니다. lombok를 사용하면 모델 객체들의 불필요한 보일러플레이트 코드들을 줄일 수 있습니다. annotation 방법으로 사용하기 때문에 사용 방법도 간단합니다. lombok annotation @Getter / @Setter 기본적으로 멤버 필드들에 대한 getter/setter 메소드들을 만들어 줍니다. @AllArgsConstructor / @NoArgsConstructor 멤버필드들이 모두 파라미터로 지정된 생성자와 빈 생성자를 만들어 줍니다. @Builder 모델을 빌더 패턴으로 만들어 줍니다. @ToString toString의 override된 메소드를 만들어 줍니다. @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 합쳐 둔 어노테이션입니다. @EqualsAndHashCode 해당 객체의 equals()와 hashCode() 메소드를 생성합니다. 그 외에도 여러가지가 있습니다. 그럼 AndroidStudio 에 적용하는 방법을 알아봅니다. 적용 방법 우선 lombok plugin을 설치해야 합니다. File -&gt; Settings -&gt; Plugins -&gt; Browse repositories lombok을 검색하여 Lombok Plugin을 설치합니다. gradle에 lombok 적용하기 Gradle Scripts -&gt; build.gradle 파일을 엽니다. dependencies 아래에 추가해줍니다. 12compileOnly 'org.projectlombok:lombok:1.18.12'annotationProcessor 'org.projectlombok:lombok:1.18.12' 이와 같은 과정 후에 다음과 같은 결과를 볼 수 있습니다. 결과","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"}]},{"title":"광학 위성 활용","slug":"satellite-optical","date":"2020-04-17T04:04:26.000Z","updated":"2023-12-01T06:14:00.818Z","comments":true,"path":"2020/04/17/satellite-optical/","link":"","permalink":"http://hgko1207.github.io/2020/04/17/satellite-optical/","excerpt":"","text":"위성영상 활용 목적 원격탐사 : 기록장치에 의해 물리적인 접속이 없이 관심 대상이 되는 목표물이나 현상에 대한 정보를 획득하는 방법 원격 : 관찰자와 관찰 대상이 분리되어 간격이 있는 것 탐사 : 감지하거나 특징을 지음 = 원거리에서 관찰 대상을 감지하거나 특징을 찾는 것 광학 위성 소개 고성능 광학 카메라를 탑재한 지구 관측 위성 해상도 : 위성의 해상도는 10m 급에서 0.4m 에 이르기까지 다양함 저해상도 활용 : 주로 광범위한 지역의 탐사나 지속적 관찰이 필요한 부분에 사용 고해상도 활용 : 고해상도로 갈수록 군사용이나 특수목적으로 사용 촬영 방식 : 전자광학카메라를 이용한 촬영(광학 신호를 전자신호로 변환하여 영상을 제공하는 방식) 장점 : 눈에 익숙한 영상이 촬영 됨 단점 : 촬영 지역에 구름이 심하게 끼거나 밤이 되면 사진을 찍지 못함 1. KOMPSAT-3(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. World View-3(미국의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. SkySat-2(미국의 상용 위성 + Google) 위성의 본체 및 탑재체 제원 배포자료 활용 분야 4. STOP-7(프랑스의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"}]},{"title":"리팩토링","slug":"book-refactoring","date":"2020-04-16T04:43:08.000Z","updated":"2024-01-11T06:59:39.571Z","comments":true,"path":"2020/04/16/book-refactoring/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/book-refactoring/","excerpt":"","text":"책 정보 책 소개 코드 품질을 개선하는 객체지향 사고법을 정리한 참고서 프로그램이 돌아가기면 하면 객체지향인가? 객체지향이라는 도구를 제대로 활용하지 못하고 마구잡이로 작성한 코드에는 악취가 진동한다. 리팩토링은 코드의 동작이나 의도는 유지하면서 코드의 구조, 재사용성, 가독성을 개선해 코드의 악취를 제거하고 전체 디자인을 개선하는 방법이다. 독자는 72가지 리팩토링 기법을 통해 코드를 점진적으로 개선하는 방법을 학습할 수 있으며, 이 책을 마쳤을 때는 객체지향 프로그래밍 능력이 한 단계 향상될 것이다. 객체지향 언어의 문법을 익혔다고 저절로 객체지향 프로그래밍을 할 수 있는 게 아니다. 리팩토링 카탈로그를 통해 어떤 코드를 고쳐야 하는지, 왜 고쳐야 하는지, 고친 코드가 왜 좋은지 이해할 수 있다. 이런 과정을 통해 객체지향에 어울리는 코드 디자인을 배우게 되고, 자신의 코딩 스타일도 바뀌게 된다. 이 책을 읽기 전과 후는 코드의 품질에 결정적인 차이를 가져오게 된다. 리뷰 3년 차 개발을 하던 중 팀장님에게 추천받았던 책입니다. 여러 가지 프로젝트를 개발하면서 고민했던 부분이 개발을 하고 있을 때 또는 유지보수 시 코드를 다시 보게 되면 너무 지저분해 보이고 가독성도 떨어지며 수정 작업이 오래 걸리는 것을 느끼게 되었습니다. 그래서 중복 코드를 제거하고 코딩 규칙을 검색하면서 개선해 보려고 노력을 하였지만 지식이 없어 힘들었습니다. 이 책을 읽으면서 리팩토링에 대해 알게 되고 필요성을 더욱 느끼게 되고 개발자로서 조금 더 성장할 수 있는 계기가 된 것 같습니다. 다만 번역서이기도 하고 글이 많아 읽기가 힘든 부분이 있습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"}]},{"title":"[Openlayers] getGetFeatureInfoUrl 함수 사용","slug":"openlayers-dev-1","date":"2020-04-16T01:02:45.000Z","updated":"2024-01-11T07:02:16.192Z","comments":true,"path":"2020/04/16/openlayers-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/openlayers-dev-1/","excerpt":"","text":"Geoserver에서 필요한 정보를 가져오기 위해 OpenLayers의 getGetFeatureInfoUrl 함수를 사용하였습니다. feature의 정보 중에 GRAY_INDEX 라는 컬럼의 정보를 가져와야 합니다. 아래 방식으로 image 형태인 layer 를 구성하였습니다. 1234567891011var wmsLayer = new ol.layer.Image(&#123; source: new ol.source.ImageWMS(&#123; ratio: 1, url: 'http://localhost:8080/geoserver/img/wms', params: &#123; FORMAT: 'image/png', VERSION: '1.1.1', STYLES: '', &#125;, &#125;),&#125;); getGetFeatureInfoUrl 함수를 사용하여 feature 정보를 불러와 표출하였습니다. 아래에서 url 에 요청할 때 Cross-Origin Read Blocking(CORN) 문제가 있어 ajax 대신 XMLHttpRequest를 사용하였습니다. 123456789101112131415161718192021222324252627var url = wmsLayer.getSource().getGetFeatureInfoUrl([longitude, latitude], view.getResolution(), view.getProjection(), &#123; INFO_FORMAT: 'application/json', FEATURE_COUNT: 10, QUERY_LAYERS: imageLayers, LAYERS: imageLayers,&#125;);if (url) &#123; var parser = new ol.format.GeoJSON(); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === xhr.DONE) &#123; // 요청이 완료되면 if (xhr.status === 200 || xhr.status === 201) &#123; var result = parser.readFeatures(xhr.responseText); if (result.length) &#123; var info = result[0].get('GRAY_INDEX'); $('#measurement_text').text( 'Val: ' + info + ', Lon: ' + longitude.toFixed(3) + ', Lat: ' + latitude.toFixed(3) ); &#125; &#125; &#125; &#125;; xhr.open('GET', url); xhr.send();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"}]},{"title":"[Cesium] 개발 팁","slug":"cesium-tip","date":"2020-04-15T13:04:56.000Z","updated":"2024-01-11T07:01:03.244Z","comments":true,"path":"2020/04/15/cesium-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/15/cesium-tip/","excerpt":"","text":"영상 레이어 추가 Geoserver에 추가된 영상 레이어를 Cesium 지도에 표출하는 코드입니다. layers 에는 Geoserver에 있는 레이어의 이름을 넣으면 됩니다. 123456789101112131415var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: '', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', &#125;, &#125;)); CesiumJS 포인트 그리기 마우스 왼쪽 버튼을 누를 때 포인트를 그립니다. 1234567891011121314151617181920var ellipsoid = viewer.scene.globe.ellipsoid;var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);handler.setInputAction(function (event) &#123; if (event.position != null) &#123; var cartesian = scene.camera.pickEllipsoid(event.position, ellipsoid); if (cartesian) &#123; var cartographic = Cesium.Cartographic.fromCartesian(cartesian); var longitude = Cesium.Math.toDegrees(cartographic.longitude); var latitude = Cesium.Math.toDegrees(cartographic.latitude); var point = scene.primitives.add(new Cesium.PointPrimitiveCollection()); point.add(&#123; position: Cesium.Cartesian3.fromDegrees(longitude, latitude), color: Cesium.Color.RED, // default: WHITE &#125;); &#125; &#125;&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 영상 레이어 추가 시 스타일 지정 영상 레이어 추가와 거의 같지만 styles와 COLORSCALERANGE 파라미터가 추가되었습니다. styles 에는 Geoserver에 추가된 스타일 이름을 지정하고, COLORSCALERANGE 에는 min, max 값을 지정한다. (COLORSCALERANGE 파라미터는 없어도 됩니다.) 12345678910111213141516var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: 'lut_redblue', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', COLORSCALERANGE: '0,100', &#125;, &#125;));","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"Cesium","slug":"Cesium","permalink":"http://hgko1207.github.io/tags/Cesium/"}]},{"title":"[Eclipse RCP] 개발 팁","slug":"rcp-tip","date":"2020-04-14T04:14:58.000Z","updated":"2024-01-11T06:59:07.588Z","comments":true,"path":"2020/04/14/rcp-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/rcp-tip/","excerpt":"","text":"1) RCP 배포 시 필수사항 build.properties 에 javacDefaultEncoding…=UTF-8 추가하기 추가하지 않을 시 한글이 깨지거나 다른 클래스를 참조할 수 없는 문제로 인해 배포된 프로그램이 실행이 되지 않을 수 있다. 2) Spring Bean 사용 방법 RCP에서 Spring 빈 생성 방법 서비스 인터페이스 설정 파일의 Runtime에 관련 라이브러리 Export 한다. String : core, beans, cglib, scheduling Log : slf4f, logback 빈 설정 정보를 담고 있는 클래스 인 AppConfig를 생성하고, AppConfig 클래스에 서비스 빈등록을 하고, SpringBeanFinder 클래스를 생성하여, 애플리케이션 컨텍스트를 로딩하고, getBean 메소드를 이용하여 해당 빈을 룩업 시킨다. RCP에서 DL(Dependency Lookup) 방법 SpringBeanFinder를 Activator를 이용하여 사용한다. getSpringBean(Class beanClass) Service를 사용하는 클래스에서private final XXXService = Activator.getSpringBean(XXXService.class); 형식으로 최상단에 멤버변수 선언을 한다. 서비스 인터페이스 설계 GUI에서 요구되는 서비스를 리스트업 한다. 리스트 한 서비스를 인터페이스로 생성한다. DummyXXXService를 먼저 생성하고 GUI에서 테스트 및 구현한다. ConnectionManager를 이용해서 서비스 구현한다. RequestMessage, ResponseMessage 생성 RequestMessage 생성 시 Service 정의 3) RCP 카페 https://cafe.naver.com/eclipseplugin 4) RCP Tutorial SWT : http://www.java2s.com/Tutorial/Java/0280__SWT/Catalog0280__SWT.htm SWT JFace Eclipse : http://java2s.com/Code/Java/SWT-JFace-Eclipse/CatalogSWT-JFace-Eclipse.htm Eclipse JFace Table : http://www.vogella.com/articles/EclipseJFaceTable/article.html Eclipse 4 RCP : http://www.vogella.com/articles/EclipseRCP/article.html Eclipse Commands : http://www.vogella.com/articles/EclipseCommands/article.html Eclipse RCP : http://www.vogella.com/articles/Eclipse3RCP/article.html#tips_loadimages","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"}]},{"title":"개발자의 성장","slug":"info-developer","date":"2020-04-14T01:55:09.000Z","updated":"2024-01-11T06:58:37.307Z","comments":true,"path":"2020/04/14/info-developer/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/info-developer/","excerpt":"","text":"회사에서 성장하기 1. 업무를 소비하지 말자 그냥 시키는 것을 그냥 하던 대로 그냥 빨리 해치워 버려야 한다는 생각으로 그냥 일단 돌아가면 되도록 그냥 개발을 하는 것 그냥 아무 생각 없이 누군지는 해주겠지(위험) 이렇게 업무를 개발을 하지 말자 책임감을 가지고 하자 2. 질문을 잘하자 배울 점이 많은 동료가 있는 것은 정말 큰 메리트 하지만 이것을 활용하지 못한다면 아무 의미 없음 회사의 업무는 혼자 하는 것이 아님 이 점을 최대한 활용 질문하는 법 충분한 구글링(검색)을 먼저 하자 사전 준비(질문 정리) 현재 발생한 상황 정리 자신의 시도들을 정리 최종적으로 Yes / No로 대답할 수 있도록 정리 그럴 수 없다면 자신의 결론에 대한 의견을 답할 수 있도록 정리 자신의 수준을 아는 사람에게 질문하자(중요) 3. 문서화를 잘하자 트러블 슈팅 나는 어쩌다 이 버그를 마주했는가 그 원인은 무엇이 있는가 그래서 어떤 시도를 해보았나 그래서 최종적으로 어떻게 해결을 했나 개발에 대한 팁 또는 유틸을 정리 4. 변화무쌍한 스펙 변경에 맞서는 경험 초기에 결정된 스펙은 무조건 변경된다. 나는 이에 어떻게 대응할 것인가 변경될 수 있는 요소들을 어떻게 제어할 것인가","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"}]},{"title":"자바 ORM 표준 JPA 프로그래밍","slug":"book-jpa","date":"2020-04-10T01:58:49.000Z","updated":"2024-01-11T06:56:50.913Z","comments":true,"path":"2020/04/10/book-jpa/","link":"","permalink":"http://hgko1207.github.io/2020/04/10/book-jpa/","excerpt":"","text":"책 정보 책 소개 자바 ORM 표준 JPA는 SQL 작성 없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주고, 객체와 관계형 데이터베이스의 차이도 중간에서 해결해 줍니다. 이 책은 JPA 기초 이론과 핵심 원리, 그리고 실무에 필요한 성능 최적화 방법까지 JPA에 대한 모든 것을 다룹니다. 또한, 스프링 프레임워크와 JPA를 함께 사용하는 방법을 설명하고, 스프링 데이터 JPA, QueryDSL 같은 혁신적인 오픈 소스를 활용해서 자바 웹 애플리케이션을 효과적으로 개발하는 방법을 다룹니다. 리뷰 스프링 프레임워크로 웹 개발할 때 JPA를 사용하기 전에는 MyBatis를 많이 사용하였다. JPA를 알고 난 후 책을 바로 구매하여 공부를 시작하게 되었다. 4년 전에 구매한 책이지만 지금까지도 가끔 보고 있고 설명이 잘 되어있어 실무에 바로 반영할 수 있었다. JPA를 사용하면서 더욱 데이터베이스 사용에 대해 편리해졌고, QueryDSL까지 사용하면서 웹 개발이 재미있어졌다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"}]},{"title":"[React] UI 추천","slug":"react-design","date":"2020-04-08T08:36:55.000Z","updated":"2024-01-11T06:57:43.850Z","comments":true,"path":"2020/04/08/react-design/","link":"","permalink":"http://hgko1207.github.io/2020/04/08/react-design/","excerpt":"","text":"React로 개발 시 기본적인 디자인을 적용하기 위해 고민이 많이 됩니다. 유료 템플릿 프로젝트를 구매해서 사용할 수 있지만 매번 사는 게 부담이기 때문에 디자인을 하기 무척 힘듭니다. 그래서 검색하던 중에 편리하게 디자인 할 수 있도록 지원해 주는 것들을 몇 가지 찾을 수 있었습니다. 1) Ant Design 리액트와 타입스크립트(Typescript) 기반으로 제작된 UI 라이브러리 중국 회사에서 오픈소스화한 라이브러리 코드가 리액트 기반이기 때문에 사용하기 편리함 앤트 디자인의 10가지 디자인 원칙 Proximity (근접성) Alignment (정렬) Contrast (대조) Repetition (반복) Make it Direct (직관적으로 만들어라) Stay on the Page (화면에 머물러라) Keep it Lightweight (가볍게 유지하라) Provide an Invitation (가이드를 제공해라) Use Transition (트랜지션을 사용하라) React Immediately (즉각적인 반응) 12$ npm i antd$ npm i --save @ant-design/icons 2) Material UI 리액트 기반 UI 라이브러리 중에 가장 인기 있고, 성숙한 라이브러리 구글 머테리얼 디자인 기반으로 제작 1$ npm install @material-ui/core 3) React Bootstrap 웹 UI 라이브러리로 전세계에서 가장 많이 사용되는 Bootstrap을 리액트 기반으로 변경한 라이브러리 Bootstrap 3.x 버전을 기반으로 제작된 라이브러리 Bootstrap 4.x 버전으로 마이그레이션 할 수 있음 1$ npm install react-bootstrap bootstrap 4) reactstrap Bootstrap 4.x 버전을 기반으로 제작된 라이브러리 1$ npm install --save reactstrap react react-dom 5) Semantic UI React 부트스트랩 만큼이나 인기 있는 Semantic UI의 리액트 버전 Semantic UI에 jQuery 의존성을 제거하고 순수하게 리액트로만 개발 된 버전 1$ yarn add semantic-ui-react","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"}]},{"title":"PROJ.4 란?","slug":"satellite-proj4","date":"2020-03-27T00:38:26.000Z","updated":"2024-01-11T06:56:15.764Z","comments":true,"path":"2020/03/27/satellite-proj4/","link":"","permalink":"http://hgko1207.github.io/2020/03/27/satellite-proj4/","excerpt":"","text":"PROJ.4 란? ​다양한 좌표계 변환을 제공하는 라이브러리 자유롭게 인자를 지정하여 표준이 아닌 좌표계 간도 변환 가능 USGS의 Gerald Evenden에 의해 만들어진 오픈소스 라이브러리 현재 OSGeo 프로젝트 중 하나이며 MIT 라이선스 GeoServer, OpenLayers, PostGIS, QGIS, GDAL, OGR, GeoTools 등 엄청나게 많은 프로그램에서 사용 중 C, C++, JAVA, Javascript 등 다양한 언어로 포팅 되어 있음​ 경위도 좌표계(WGS84) GPS가 사용하는 좌표계 EPSG:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs https://epsg.io/4326 구글 좌표계(Mercator) EPSG:3857, EPSG:900913 +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs https://epsg.io/3857 TM(Transverse Mercator) 국토지리정보원 기준 좌표계 +proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs UTM(Universal Transverse Mercator) 전 세계를 6도 단위로 나누는 표준적인 TM으로 군사지도에서 많이 사용 UTM52N: 경도 120 ~ 126도 사이에서 사용 EPSG:32652 +proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32652 UTM51N: 경도 126 ~ 132도 사이에서 사용 EPSG:32651 +proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32651 Polar Stereographic 기상청 북반구 표현에 사용 +proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://spatialreference.org/ref/epsg/wgs-84-ups-north/ 참고 epsg.io 한국 주요 좌표계 EPSG코드 및 proj4 인자 정리","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"}]},{"title":"Gdal 사용 방법","slug":"satellite-gdal","date":"2020-03-26T02:07:02.000Z","updated":"2024-01-11T06:55:54.027Z","comments":true,"path":"2020/03/26/satellite-gdal/","link":"","permalink":"http://hgko1207.github.io/2020/03/26/satellite-gdal/","excerpt":"","text":"GDAL 은 래스터 및 벡터 지리 공간 데이터를 조작할 수 있는 오픈 소스 라이브러리다. 라이브러리로서 지원되는 모든 형식의 호출 응용 프로그램에 단일 추상 데이터 모델을 제공한다. 데이터 변환 및 처리를 위한 다양한 명령 행 인터페이스 유틸리티가 제공된다. Windows, Linux 및 MacOS 에서 사용 가능하다. 1. gdalinfo (http://www.gdal.org/gdalinfo.html) GDAL 이 지원하는 영상 정보를 확인한다. 1gdalinfo test.tif 2. gdal_translate (http://www.gdal.org/gdal_translate.html) 다른 형식으로 래스터 데이터를 변환 영상 resize 및 포멧 변경 1gdal_translate -of GTiff -outsize 50% 50% src_dataset dst_dataset 3. gdalwarp (http://www.gdal.org/gdal_utilities.html) image reprojection and warping utility 좌표변환, resampling, image mosaicing 1gdalwarp -t_srs EPSG:4326 input.tif output.tif 4. gdal_merge (https://gdal.org/programs/gdal_merge.html) 일련의 이미지를 자동으로 모자이크한다. 모든 이미지는 동일한 좌표계에 밴드 수가 일치해야 한다. 겹치는 영역에서는 마지막 이미지가 이전 이미지에 복사된다. 1gdal_merge.py -init 255 -o out.tif in1.tif in2.tif 5. gdalmanage (http://www.gdal.org/gdalmanage.html) Mode: identify datasetname : List data format of file. 데이터 포맷 정보 보기 copy datasetname newdatasetname : 파일 복사 rename datasetname newdatasetname : 이름 수정 delete datasetname : 이미지 삭제 12345# 파일일 때gdalmanage identify test.tif# 폴더일 때gdalmanage identify –r test/ 6. gdal_contour (http://www.gdal.org/gdal_contour.html) 입력 래스터 표고 모델(DEM)로부터 벡터 등고선 파일을 생성한다. 7. gdal_polygonize.py (http://www.gdal.org/gdal_polygonize.html) Produces a polygon feature layer from a raster. ERS -&gt; Shape 파일로 변환 1python gdal_polygonize.py inputFile -f ”ESRI Shapefile” outputFile 8. ogr2ogr (http://www.gdal.org/ogr2ogr.html) Shape 파일 좌표 변환 1ogr2ogr -f \"ESRI Shapefile\" out.shp wgs84.shp -s_srs EPSG:32616 -t_srs EPSG:4326 Shape -&gt; GeoJSON 변환 1ogr2ogr -f GeoJSON -t_srs crs:84 [name].geojson [name].shp http://www.mercatorgeosystems.com/blog-articles/2008/05/30/using-ogr2ogr-to-re-project-a-shape-file/ 9. gdaldem (https://gdal.org/programs/gdaldem.html) ERS -&gt; GTiff 파일로 변환한다. 1gdaldem color-relief -of GTiff -co \"TILED=YES\" K220100502_22131215_ref_med_union.ers color_file.txt color.tif ※ GDAL 에서 .py 파일은 .exe로 만들어서 붙입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"}]},{"title":"[java] Geocoder을 이용해 주소를 위도/경도로 변환하기","slug":"java-geocoder","date":"2020-03-25T01:18:14.000Z","updated":"2024-01-11T06:53:30.099Z","comments":true,"path":"2020/03/25/java-geocoder/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/java-geocoder/","excerpt":"","text":"Geocoding 이란 주소를 위도, 경도로 변환해 주는 Google에서 제공하는 API입니다. 링크 : 지오코딩이란? 처음엔 HttpURLConnection 으로 접속해서 InputStreamReader 로 읽은 후 JSON으로 파싱 하게 만들었는데 해외 사이트에 geocoder 라이브러리를 이용하여 받아오는 예제가 있었다. 어쨌든 더 편리하고 깔끔하게 해결되었습니다. Geocoder Maven dependency 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.geocoder-java&lt;&#x2F;groupId&gt; &lt;artifactId&gt;geocoder-java&lt;&#x2F;artifactId&gt; &lt;version&gt;0.16&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Method 123456789101112131415161718192021222324252627public static Float[] findGeoPoint(String location) &#123; if (location == null) return null; // setAddress : 변환하려는 주소 (경기도 성남시 분당구 등) // setLanguate : 인코딩 설정 GeocoderRequest geocoderRequest = newGeocoderRequestBuilder().setAddress(location).setLanguage(\"ko\").getGeocoderRequest(); try &#123; Geocoder geocoder = new Geocoder(); GeocodeResponse geocoderResponse = geocoder.geocode(geocoderRequest); if (geocoderResponse.getStatus() == GeocoderStatus.OK &amp; !geocoderResponse.getResults().isEmpty()) &#123; GeocoderResult geocoderResult=geocoderResponse.getResults().iterator().next(); LatLng latitudeLongitude = geocoderResult.getGeometry().getLocation(); Float[] coords = new Float[2]; coords[0] = latitudeLongitude.getLat().floatValue(); coords[1] = latitudeLongitude.getLng().floatValue(); ​return coords; &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return null;&#125; latitudeLongitude.getLat().floatValue(); 이 부분은 floart 형이 아닌 toString()으로도 가능하다. 테스트 1234String location = \"대전광역시 유성구 궁동\";Float[] coords = CommonUtil.findGeoPoint(location);System.out.println(location + \": \" + coords[0] + \", \" + coords[1]); 결과 1대전광역시 유성구 궁동 : 36.366701, 127.344510","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"}]},{"title":"Spring AOP","slug":"spring-aop","date":"2020-03-25T01:04:18.000Z","updated":"2024-01-11T06:55:12.053Z","comments":true,"path":"2020/03/25/spring-aop/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/spring-aop/","excerpt":"","text":"AOP(Aspect Oriented Programming) 는 공통관심사항을 분리하여 반복되는 부분을 추출해 핵심 로직에 영향을 미치지 않고 소스의 중복을 줄이는 방법으로 기존 OOP(Object-Oriented Programming) 에서 공통관심사항을 여러 모듈에서 적용하며 발생하는 중복된 코드 양산의 한계를 극복하기 위해 나오게 되었습니다. Spring AOP의 장점 예를 들어 어떠한 홈페이지에 로그인 처리를 해야 할 때 AOP를 사용하지 않는다면 모든 페이지마다 로그인 상태인지 확인하는 소스코드를 넣어야 할 테고 혹시나 그 로직이 변경되게 된다면 또 그 모든 페이지의 소스를 수정해야 하는 일이 생길 것입니다. 하지만 AOP를 적용한다면 단 하나의 로그인 로직만 바꿔도 모든 소스에 적용시킬 수 있는 장점이 있습니다. 스프링 AOP 용어 스프링 AOP를 이해하기 위해선 5가지 용어에 대한 이해가 필요합니다. Aspect : 여러 객체에서 공통으로 적용되는 공통 관심사항(ex:트랜잭션, 로깅, 보안) JoinPoint : Aspect가 적용될 수 있는지점(ex:메소드, 필드) Pointcut : 공통 관심사항이 적용될 Joinpoint Advice : 어느시점(ex: 메소드수행 전/후, 예외발생후등)에 어떤 공통관심기능(Aspect)을 적용할지 정의한것 Weaving : 어떤 Advice를 어떤 Pointcut(핵심사항)에 적용시킬 것 인지에 대한 설정(Advisor)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"}]},{"title":"com, net, co.kr의 차이는?","slug":"info-domain","date":"2020-03-25T01:01:05.000Z","updated":"2023-07-13T03:18:17.744Z","comments":true,"path":"2020/03/25/info-domain/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/info-domain/","excerpt":"","text":"사용 com(company) : 회사의 도메인에 사용한다. net(network) : 네트워크를 관리하는 기관의 도메인에 사용한다. co.kr(company korea) : 회사의 도메인에 사용한다.(한국) 인터넷이 미국에서 시작했기 때문에 도메인도 미국이 먼저 선점했다. 그래서 다른 국가들은 .kr 처럼 국가고유 도메인을 추가하여 쓰게 되었다. 일본은 jp, 영국은 uk, 중국은 cn 등이 다 그런 것이다. 원래의 의미는 co.kr, com : 영리목적으로 설립된 회사의 홈페이지를 나타내는 말 or.kr, org : 비영리기구 ne.kr, net : 네트워크 관련 회사, 혹은 통신 관련 회사를 나타내는 말 하지만 or,org 를 제외하고는 모두 동일한 의미를 나타낸다고 보면 된다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"}]},{"title":"[Git] 커맨드 명령어","slug":"git-use","date":"2020-03-24T01:45:42.000Z","updated":"2024-01-11T06:48:53.991Z","comments":true,"path":"2020/03/24/git-use/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/git-use/","excerpt":"","text":"설정 확인 1$ git config --list 계정 확인 12$ git config user.name$ git config user.email 계정 변경 12$ git config --global user.name \"user name\"$ git config --global user.email \"user email\" Git Create 12345$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin https://github.com/username/repositoryName$ git push -u origin master 현재 master 브랜치를 push 할 때 origin의 master 브랜치로 푸시하는 명령어다. 처음 push 할 때 사용한다. 1$ git push --set-upstream origin master Git Update 12$ git add .$ git commit -m \"update\" commit 내용을 확인한다. 1$ git status 원격 저장소에 반영한다. 1$ git push Git Pull 12$ git remote add origin https://github.com/username/repositoryName$ git pull origin master 독립적인 두 프로젝트를 병합할 경우 --allow-unrelated-histories 옵션을 사용한다. 1$ git pull origin master --allow-unrelated-histories Git Repository Download 1$ git clone https://github.com/username/repositoryName 서브 모듈 포함에서 받을 경우 다음 명령어를 참고한다. 1234$ git clone https://github.com/username/repositoryName$ git submodule initor$ git clone --recurse-submodules https://github.com/username/repositoryName Git Ignore .gitignore 파일을 생성한다. 1$ touch .gitignore Git에 이미 올라가 있는 파일을 삭제하고 .gitignore 적용 123456789101112# 원격 저장소와 로컬 저장소에 있는 파일을 삭제한다.git rm [File Name]# 원격 저장소에 있는 파일을 삭제한다.(로컬 저장소에 있는 파일은 삭제하지 않는다.)git rm --cached [File Name]# 폴더 하위의 모든 파일을 삭제한다.git rm -r --cached [Directory]git rm -r --cached example/# 원격 저장소의 파일을 모두 삭제한다.git rm -r --cached . Git branch branch 를 만들고 관리하는 명령어다. 1234567891011# branch 만들기git branch [branch name]# branch 목록 보기git branch# 지정한 branch 삭제git branch -d [branch name]# branch 선택하기git checkout [branch name] Git Remote 원격 저장소를 관리할 수 있는 명령어다. 1234567891011# 원격 저장소의 이름 목록git remote# 원격 저장소에 대한 자세한 목록보기git remote -v# 원격 저장소 추가git remote add [name] [url]# 원격 저장소를 삭제git remote rm [name] Git Clean 작업 디렉토리에서 추적되지 않는 파일을 삭제하는 명령어다. 12345678# untracked 파일 모두 삭제git clean -f# 디렉토리까지 삭제git clean -fd# .gitignore로 무시되는 파일 삭제git clean -d -x Git Stash 1234567891011121314151617# 트래킹 된 파일을 stash 영역에 임시 저장하고 수정 내용은 제거git stash# stash 한 기록을 리스트 형태로 확인git stash list# 가장 최근에 저장한 stash 복원git stash apply# 가장 최근에 저장한 stash 삭제git stash drop# stash 기록 모두 삭제git stash clear# stash를 복원하고 삭제git stash pop 참고 Git 개요","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"}]},{"title":"React Study(2)","slug":"react-study-2","date":"2020-03-24T01:41:09.000Z","updated":"2024-01-11T06:51:26.280Z","comments":true,"path":"2020/03/24/react-study-2/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-2/","excerpt":"","text":"React 세미나😊(2) 2. Project Setup 2.1. Requirements 먼저 Node.js 가 설치되어 있어야 한다. Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/)에서 Window Installer 를 다운로드하고 설치한다. 12$ node -v$ npm -v 에디터로는 MS에서 제공하는 Visual Studio Code(VS Code)를 사용한다. vscode 는 크로스 플랫폼 에디터로 다양한 언어를 서포트하며, IntelliSense 와 Git 기능, 그리고 Extension 을 이용한 확장 기능을 제공하고 있다. 설치 방법은 https://code.visualstudio.com/ 에 접속하여 다운로드 후 설치하면 된다. React 개발에 좋은 Extension는 ESLint, Prettier, vscode-styled-components, Auto Close Tag, React-Native/React/Redux snippets for es6/es7 등 다양하게 있어 설치하고 사용하면 됩니다. 2.2. Creating React App 기존에는 Webpack, Babel 등 필요한 모듈들을 직접 설치하고 설정하느라 상당한 시간이 소요가 되었다. 2016년에 React 작업 환경을 명령어 하나로 설정 할 수 있는 공식 도구가 나오면서 개발자들과 입문자들에게 많은 도움이 되었다. 먼저 프로젝트 생성을 한다. 주의사항은 npm 5.2.0 이상 버전을 설치해야 합니다. 최신 npm 버전에는 npx 가 설치되어 있다. 123456$ npm install npx -global$ npx create-react-app test-project$ cd test-project$ code . 설치가 완료되면 Visual Studio Code 편집기로 프로젝트를 연다. 처음 프로젝트가 설치되면 여러가지 파일이 생성되는데 초기 세팅을 위해 불필요한 파일을 제거하는 것이 좋다. src 폴더에서 App.js, index.js 파일을 제외한 파일을 제거하고 import 된 코드를 제거한다. 3. React 개발 3.1. JSX JSX (JavaScript eXtension) 는 자바스크립트 언어 문법의 확장입니다. 자바스크립트 안에서 HTML 문법을 사용해서 화면을 구성할 수 있게 도와주는 문법으로, React 개발에 엄청난 도움을 줍니다. 123456789101112import React, &#123; Component &#125; from 'react';class HelloMessage extends React.Component &#123; render() &#123; return ( // JSX 문법 &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; ); &#125;&#125;export default HelloMessage; 아래는 스타일링의 여러가지 방법이다. class 대신 className 을 사용한다. 스타일 속성은 중괄호 ({}) 안에 객체 형태로 표시하며 단어 사이의 '-'를 없애는 대신 카멜케이스(Camel Case)를 사용해 CSS 프로퍼티는 나타낸다. styled-components는 리액트 CSS-in-JS 관련 라이브러리 중에서 가장 잘 나가는 라이브러리로써 자바스크립트 파일 안에 CSS 를 작성하는 형태다. 12345678910111213141516171819// App.jsimport React, &#123; Component &#125; from 'react';import styled from 'styled-components';import './App.css';const Content = styled.div` background-color: 'blue'; font-size: 16px;`;function App() &#123; return ( &lt;div&gt; &lt;div className=\"App\"&gt;&lt;/div&gt; &lt;div style=&#123;&#123; backgroundColor: 'black', fontSize: '12px', color: 'white' &#125;&#125;&gt;&lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; );&#125; 123456// App.css.App &#123; background-color: white; font-size: 16px; color: black;&#125; JSX 는 꼭 지켜야 할 몇몇 제한이 있다. JSX 를 사용하는 스크립트 파일은 상단에 React 라이브러리를 꼭 불러와야 한다.1import React from 'react'; 열어 놓은 태그는 꼭 닫아야 한다.1234# 에러&lt;hello&gt;# 정상 동작&lt;hello&gt;&lt;/hello&gt; or &lt;hello /&gt; 최상위 태그는 꼭 1개여야 한다.12345678&lt;Fragment&gt; &lt;header&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;h1&gt;main&lt;/h1&gt; &lt;/main&gt;&lt;/Fragment&gt; 3.2. Component 기반 구조 React 는 Component 기반 라이브러리다. 하나의 코드로 작성하는 것이 아니라 여러 부분을 분할해서 만들기 때문에 코드의 재사용성과 유지보수성이 증가 된다. 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;홈페이지&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;!-- 헤더 내용 --&gt; &lt;/header&gt; &lt;div class=\"content-list\"&gt; &lt;!-- 콘텐츠 리스트 --&gt; &lt;/div&gt; &lt;footer&gt; &lt;!-- 푸터 내용 --&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 위와 같은 html 코드가 있다고 해보자. 이를 React 로 만들게 되면 다음과 같다. 123456789101112131415161718import React, &#123; Component &#125; from 'react';import Header from './component/Header';import Footer from './component/Footer';import ContentList from './component/ContentList';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;ContentList /&gt; &lt;Footer /&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header 나 Footer, ContentList 등은 컴포넌트로 만들고, 이를 조립해서 루트 컴포넌트를 만드는 방식이다. 컴포넌트의 종류로는 클래스형(stateful)과 함수형(stateless)으로 나누어진다. 3.3. Props props란 부모 컴포넌트에서 자식 컴포넌트로 전달해 주는 데이터를 말한다. props는 읽기 전용 데이터라고 생각하면 된다. 자식 컴포넌트에서 전달받은 props를 변경이 불가능하고 props를 전달해 준 최상위 부모 컴포넌트만 props를 변경할 수 있다. 3.4. State state는 동적인 데이터를 다룰 때 사용한다. 사용자와의 상호작용을 통해 데이터를 동적으로 변경을 해야 할 때 사용한다. state는 클래스형 컴포넌트에서만 사용할 수 있는데 각각의 state는 독립적이라 다른 컴포넌트의 직접적인 접근은 불가능하다. 3.5 LifeCycle API LifeCycle API는 컴포넌트가 DOM 위에 생성되기 전 후 및 데이터가 변경되어 상태를 업데이트하기 전 후로 실행되는 메서드들이다. 자원낭비를 줄이기 위하여 코드를 최적화할 때 사용된다. 많이 사용하는 LifeCycle 메서드들은 constructor, componentDidMount, render, shouldComponentUpdate 이다. 참고 VS Code 기본 세팅 vscode 추천 익스텐션(Extensions)과 세팅 craete-react-app github React 시작하기 [npm] 🤔npx란 무엇인가? JSX 소개 - React 누구든지 하는 리액트 3편: JSX 리액트 Styled Components - 1편 강의 https://academy.nomadcoders.co/ https://www.opentutorials.org/module/4058","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"React Study(1)","slug":"react-study-1","date":"2020-03-24T01:39:16.000Z","updated":"2024-01-11T06:49:57.919Z","comments":true,"path":"2020/03/24/react-study-1/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-1/","excerpt":"","text":"React 세미나😊(1) 최근 React를 다시 공부하게 되면서 올해 초에 회사에서 세미나를 하게 되었다. 물론 기초이지만 React 에 관심을 다시 가지게 되는 계기가 되었다. React란? React는 페이스북에서 제공해 주는 프런트엔드 라이브러리다. 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM을 통해 속도와 편의를 높이고, 단방향 데이터 플로우를 지원하여 보일러플레이트 코드를 감소 시켜준다. React 는 싱글 페이지 애플리케이션(SPA)이나 모바일 애플리케이션을 개발할 때 사용할 수 있다. 특징 컴포넌트 기반 아키텍처 템플릿 언어가 아닌 자바스크립트로 컴포넌트 작성 특정 관심사에 집중된 기능 블록 (관심사의 분리) One Way Data flow(단방향 데이터 흐름 지향) React 는 데이터의 흐름이 한 방향으로만 흐흔다. 데이터가 내려가기만 하고 밑에서 데이터를 올릴 수 없다. 그래서 부모의 데이터를 바꿔주기 위해서는 state를 이용해야 한다. Virtual DOM - React는 가상의 DOM을 만들어서 진짜 DOM 과 비교하여 변경 사항이 있을 경우 전체를 새롭게 만드는 것이 아니라 변경된 부분만 진짜 DOM 에 반영하는 방식으로 작업을 수행한다. 그럼으로써 애플리케이션의 효율성과 속도를 높일 수 있게 된다. JSX 문법 리액트 JS를 하기 위해 알아야 할 것 Javascript(ES6) HTML CSS 1. Fundamentals(기초) React에서 많이 사용되는 자바스크립트 ES6 문법 기초를 먼저 알아보자. 기존에 우리가 웹 개발에서 많이 보던 자바스크립트는 2009년 12월에 나온 ECMAScript5(ES5) 버전이다. 최근 Node.js, react에서는 2015년 6월에 업데이트된 ECMAScript6(ES6) 문법의 자바스크립트를 사용하고 있다. ES6 문법을 사용하면서 처음에는 익숙해지기 어려웠지만 사용할 수록 코드가 간결해지고 깔끔해지면서 가독성이 좋아졌고, 모듈 별로 개발하면서 코드 관리가 쉬워졌다. 현재는 ES8까지 업데이트 되었지만 몇 가지 걸림돌이 있어 넘어가지 않고 있다. 아래에는 바뀐 ES6 문법과 많이 사용되는 기능들이다. 1.1. var -&gt; let &amp; const const 는 블록 범위이며 값이 지정되면 나중에 바꿀 수 없다. 또한, 재 선언 될 수도 없다. let 은 블록 범위이며 값이 지정되어도 값을 바꿀 수 있다. 12const name = 'eden';let tel = '010-0000-0000'; 1.2. Arrow Functions 함수는 간결해지고 코드는 짧아졌다. Argument가 하나 일 때는 괄호가 필요 없다.(유일한 규칙) 1234567// ES5function sayHello(name) &#123; reutn \"Hello \" + name;&#125;// ES6const sayHello = name =&gt; \"Hello \" + name;const sayHello = (name, something) =&gt; \"Hello \" + name + something; 1.3. Template Literals ``(backticks) 사용 12345const name = 'eden';// ES5console.log('Hello ' + name);// ES6console.log(`Hello $&#123;name&#125;`); 1.4. Object Destructuring (비구조화) 적은 코드를 사용해서 더 깔끔하게 보이도록 한다. 1234567891011121314151617181920212223const human = &#123; name: 'Ko', lastName: 'HyeongGyun', nationality: 'Korea', favFood: &#123; dinner: 'Samgyupsal', &#125;,&#125;;// ES5const name = human.name;const lastName = human.lastName;const difName = human.nationality;const dinner = human.favFood.dinner;// ES6const &#123; name, lastName, nationality: difName, favFood: &#123; dinner &#125;,&#125; = human;console.log(name, lastName, difName, dinner); 1.5. Spread Operator Iterable Object(열거 가능한 오브젝트)를 하나씩 전개한다. 표현방식 […iterable], 변수 앞에 ‘…’ 찍어서 선언한다. 변수뿐만 아니라 Argument, Function에서도 쓰인다. 123456const days = ['Mon', 'Tues', 'Wed'];const otherDays = ['Thu', 'Fri', 'Sat'];const allDays = [...days, ...otherDays, 'Sun'];console.log(allDays);결과: ['Mon', 'Tues', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; 1.6. Classes constructor 메서드도 사용할 수 있고 extends를 통해서 클래스 상속도 가능하다. 123456789101112131415161718class Human &#123; constructor(name, lastName) &#123; this.name = name; this.lastName = lastName; &#125;&#125;class Baby extends Human &#123; cry() &#123; console.log('cry'); &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;&#125;const myBaby = new Baby('mini', 'me');console.log(myBaby.cry(), myBaby.sayName()); 1.7. Array.map 요소를 일괄적으로 변경한다. 12345const days = ['Mon', 'Tues', 'Wed', 'Thu', 'Fri'];const smilingDays = days.map((day) =&gt; `😂 $&#123;day&#125;`);console.log(smilingDays);결과: ['😂 Mon', '😂 Tues', '😂 Wed', '😂 Thu', '😂 Fri']; 1.8. Array.filter 요소를 걸러내어 배열로 true/false 반환, 없으면 빈 배열을 반환한다. 123const numbers = [123, 5, 15, 67, 241, 54, 1, 6, 23, 90];const otherNumbers = numbers.filter((number) =&gt; number &gt; 15);console.log(otherNumbers); 1.9. forEach, includes, push 123456let posts = ['Hi', 'Hello', 'Bye'];if (!posts.includes('new')) &#123; posts.push('new');&#125;posts.forEach((post) =&gt; console.log(post)); CodeSandbox 웹 기반 자바스크립트 에디터 서비스를 제공하는 사이트 간단한 소스 코드 테스트를 할 때 사용하면 편리하다. codesandbox.io 참고 https://velog.io/@stampid/React란 https://velog.io/@kyusung/react-summary https://hgko1207.github.io/2019/01/09/react-start/ https://sanghaklee.tistory.com/54 http://woowabros.github.io/experience/2017/12/01/es6-experience.html https://blog.asamaru.net/2017/08/14/top-10-es6-features/ https://velog.io/@decody/map-정리","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"Node.js 교과서","slug":"book-nodejs","date":"2019-06-19T07:31:30.000Z","updated":"2024-01-11T06:47:07.547Z","comments":true,"path":"2019/06/19/book-nodejs/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/book-nodejs/","excerpt":"","text":"책 정보 책 소개 노드의 기본부터 실무까지, 전 과정을 한 권에 담았다! 다양한 서비스를 직접 만드는, 실무에 가장 가까운 강의! Node.js 10 + 자바스크립트 ES2018, 최신 문법으로 배우자. 서버와 데이터베이스 개념을 시작으로 노드의 기본 개념을 차근차근 설명해 나간다. 군더더기 없는 직관적인 설명, 풍부한 그림으로 기본 개념을 확실히 이해하고, 노드의 기능과 생태계를 사용해 보며 실제로 동작하는 서버를 만들어보자. 웹 서버, 웹 API 서버, SNS 서비스, 실시간 GIF 채팅방, 경매 시스템, 위치 기반 장소 검색 서비스, 커맨드라인 인터페이스를 모두 만들어 볼 수 있다. 실무에 당장 적용할 수 있고, 참고할 수 있는 예제와 코드를 최신 문법으로 다뤄보자. 리뷰 최근 Node.js에 관심이 생겨 공부를 해볼까 하다가 지인의 추천으로 이 책을 사게 되었습니다. 노드의 기본부터 실무까지 꼼꼼하게 설명되어 있고 무엇보다 예제 소스가 잘 되어 있어 힘들게 코드를 안 봐도 되고 이해도 빨라 금방 익숙해졌습니다. 아직은 걸음마 단계이지만 차근차근 공부하고 프로젝트도 진행해 볼 예정입니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[WPF] Prism Library 사용 방법","slug":"wpf-prism","date":"2019-06-19T07:26:34.000Z","updated":"2024-01-11T06:48:27.847Z","comments":true,"path":"2019/06/19/wpf-prism/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/wpf-prism/","excerpt":"","text":"최근 WPF 기반으로 응용 애플리케이션을 개발하고 있습니다. C#을 처음 하는 거라 처음에는 익숙하지 않았지만 자바와 비슷한 면이 많아 금방 적응하였습니다. WPF 개발을 하는데 Prism Library를 적용하였습니다. Prism은 WPF를 통해 풍부하고 유연하고 유지보수가 쉬운 설계를 할 수 있게 도와준다고 합니다. 그리고 MVVM 패턴, Dependency Inejction, CompositeView, Event Aggregator들을 이용하여 독립적인 컴포넌트들 간의 느슨한 결합들을 이용한 설계 중심의 애플리케이션 제작에도 도움을 준다고 합니다. 즉, WPF 어플리케이션을 만들 시 MVVM 디자인 패턴으로 개발하고 이에 추가적으로 Prism이 제공하는 CompositeView 제작방식과 Event Aggregator 기능들을 사용할 수 있는 것입니다. Prism 설계 목표(Prism Design Goals) 재사용성(Reuse) 확장성(Extensibility) 유연성(Flexibility) 협업(Team Development) 품질(Quality) Prism Key Concepts Prism의 설계 목표와 핵심 개념들입니다. Modules Module catalog Shell Views View models Models Commands Regions Navigation EventAggregator Dependency injection container Services Controllers Bootstrapper Prism 아키텍처","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"Hexo 시작 및 기본 사용법","slug":"hexo-basic-usage","date":"2019-02-13T01:38:15.000Z","updated":"2023-07-13T03:11:52.865Z","comments":true,"path":"2019/02/13/hexo-basic-usage/","link":"","permalink":"http://hgko1207.github.io/2019/02/13/hexo-basic-usage/","excerpt":"","text":"Hexo Hexo 라는 블로그 프레임워크를 사용하여 블로그를 작성하던 중에 시간이 지나면 생성하는 법이나 작성하는 법 등 사용법들을 자꾸 잊어버리게 되어 기존에 자주 보곤 했던 Hexo 사용법이 잘 정리되어있던 블로그 링크를 모아놨다. 참고 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 기본 사용법 Hexo 시작하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[JavaScript] Daum 우편번호 서비스 사용 방법","slug":"javascript-postcode","date":"2019-01-18T06:52:14.000Z","updated":"2024-01-11T06:46:10.067Z","comments":true,"path":"2019/01/18/javascript-postcode/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-postcode/","excerpt":"","text":"웹 프로젝트를 하면서 사용자 등록을 하게 될 때 주소를 입력을 하게 되는데, 우편번호 주소 조회가 되도록 처리해 달라는 요청이 있었습니다. 그래서 우편번호 서비스를 검색해 봤을 때 여러 가지가 있었지만 개인적으로 좋아 보이는 Daum 우편번호 서비스를 사용하게 되었습니다. Daum 우편번호 서비스 쉽고 간편하게 우편번호 검색, 도로명 주소 입력 기능을 만들 수 있습니다. Key를 발급받을 필요가 없습니다. 사용량에 대한 제한이 전혀 없습니다. 기업용이든 상업적 용도이든 상관없이 무조건 무료로 사용 가능합니다. 도로명 주소, 지번 주소, 영문 주소까지 모두 확인 가능합니다. 이 것 말고도 여러 가지 장점이 더 있지만 사용하기 쉽고 무료이며 사용량에 대한 제한이 없고, 특히나 기본 사용법이 정말 쉽게 잘 설명되어 있어서 사용하게 되었습니다. 예제 123456789&lt;script src=\"//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt;&lt;script&gt; new daum.Postcode(&#123; oncomplete: function(data) &#123; // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다. // 예제를 참고하여 다양한 활용법을 확인해 보세요. &#125; &#125;).open();&lt;/script&gt; 적용 아래는 적용한 코드입니다. HTML HTML 코드는 아래와 같습니다. 우편번호, 도로명 주소, 상세 주소 입력 란이 있고 우편번호 찾기 버튼이 있습니다. 버튼을 클릭하게 되면 execDaumPostcode() 함수를 호출하게 됩니다. 12345678910111213141516171819202122&lt;div class=\"form-group row\"&gt; &lt;label class=\"col-md-2 offset-md-3 form-label\"&gt; 주 소 &lt;span class=\"text-danger\"&gt;*&lt;/span&gt; &lt;/label&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"postcode\" id=\"postcode\" placeholder=\"우편번호\" readonly /&gt; &lt;/div&gt; &lt;div class=\"col-md-2 postcode-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-info\" onclick=\"execDaumPostcode()\"&gt;우편번호 찾기&lt;/button&gt; &lt;/div&gt; &lt;div class=\"offset-md-5 col-md-4 mt-2\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"address\" id=\"address\" placeholder=\"도로명 주소\" readonly /&gt; &lt;/div&gt; &lt;div class=\"offset-md-5 col-md-4 mt-2\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"detailA_address\" name=\"detailAddress\" placeholder=\"상세 주소\" required /&gt; &lt;/div&gt;&lt;/div&gt; 결과 화면입니다. JavaScript 버튼을 클릭하여 execDaumPostcode() 함수가 호출되면서 주소 검색 팝업창이 보이게 합니다. 팝업창에서 주소 검색 결과 항목을 클릭했을 때 우편번호와 도로명주소 입력란에 값을 채워 넣게 됩니다. 123456789101112131415161718192021222324252627&lt;script src=\"//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt;&lt;script&gt;/** 우편번호 찾기 */function execDaumPostcode() &#123; new daum.Postcode(&#123; oncomplete: function(data) &#123; // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다. // 각 주소의 노출 규칙에 따라 주소를 조합한다. // 내려오는 변수가 값이 없는 경우엔 공백('')값을 가지므로, 이를 참고하여 분기 한다. let addr = ''; // 주소 변수 //사용자가 선택한 주소 타입에 따라 해당 주소 값을 가져온다. if (data.userSelectedType === 'R') &#123; // 사용자가 도로명 주소를 선택했을 경우 addr = data.roadAddress; &#125; else &#123; // 사용자가 지번 주소를 선택했을 경우(J) addr = data.jibunAddress; &#125; $(\"#postcode\").val(data.zonecode); $(\"#address\").val(addr); $(\"#address\").focus(); &#125; &#125;).open();&#125;&lt;/script&gt; 결론 Daum 우편번호 서비스를 사용하여 주소를 검색하고 우편번호와 도로명 주소를 받아 입력란에 넣어줬습니다. Daum 우편번호 서비스 사이트 가시면 예제와 속성, 함수에 대한 부분도 잘 설명되어 있기 때문에 다양하게 개발할 수 있습니다. 참고 Daum 우편번호 서비스 Daum 우편번호 서비스 사용 가이드 - 우편번호 검색, 적용법 및 사용예제","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"Daum 우편번호","slug":"Daum-우편번호","permalink":"http://hgko1207.github.io/tags/Daum-%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8/"}]},{"title":"[JavaScript] 전화번호 하이픈(-) 자동입력","slug":"javascript-autoHypenTel","date":"2019-01-18T06:22:36.000Z","updated":"2024-01-11T06:43:51.812Z","comments":true,"path":"2019/01/18/javascript-autoHypenTel/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-autoHypenTel/","excerpt":"","text":"사용자 등록 시 전화번호를 입력하게 되는데 아래 그림처럼 세 개의 입력을 받아 합치는 형식으로 많이 되어 있습니다. 이렇게 개발해도 괜찮지만 좀 더 쉽게 하기 위해서 전화번호 입력 시 자동으로 하이픈(-)이 입력되도록 하는 형식으로 바꾸면 좋겠다 싶어 반영해 봤습니다. 개발된 화면은 다음과 같습니다. 1) HTML 먼저 HTML 소스 코드다. input 태그를 사용하고 pattern과 maxlength, required, placeholder를 사용하였습니다. 속성에 대한 설명은 참고 사이트를 보시면 됩니다. 12345678910&lt;input type=\"tel\" class=\"form-control m-input\" name=\"tel\" id=\"telInput\" required pattern=\"[0-9]&#123;2,3&#125;-[0-9]&#123;3,4&#125;-[0-9]&#123;4&#125;\" maxlength=\"13\" placeholder=\"예) 010-1234-5678\"/&gt; 2) JavaScript 먼저 전화번호 크기에 따라 나눴습니다. 서울 전화번호는 02로 두자리로 시작하고 핸드폰은 010, 011…이고 다른 지역 전화번호는 031, 041, 051 등 세 자리로 시작하여 {2}-{3 or 4}-{4} 또는 {3}-{3 or 4}-{4} 형태가 되도록 문자열을 잘라내는 방식으로 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function autoHypenTel(str) &#123; str = str.replace(/[^0-9]/g, ''); var tmp = ''; if (str.substring(0, 2) == 02) &#123; // 서울 전화번호일 경우 10자리까지만 나타나고 그 이상의 자리수는 자동삭제 if (str.length &lt; 3) &#123; return str; &#125; else if (str.length &lt; 6) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2); return tmp; &#125; else if (str.length &lt; 10) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 3); tmp += '-'; tmp += str.substr(5); return tmp; &#125; else &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 4); tmp += '-'; tmp += str.substr(6, 4); return tmp; &#125; &#125; else &#123; // 핸드폰 및 다른 지역 전화번호 일 경우 if (str.length &lt; 4) &#123; return str; &#125; else if (str.length &lt; 7) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3); return tmp; &#125; else if (str.length &lt; 11) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 3); tmp += '-'; tmp += str.substr(6); return tmp; &#125; else &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 4); tmp += '-'; tmp += str.substr(7); return tmp; &#125; &#125; return str;&#125; 호출 부분 코드입니다. 키가 입력될 때마다 검사를 진행합니다. 12345$('#telInput').keyup(function (event) &#123; event = event || window.event; var _val = this.value.trim(); this.value = autoHypenTel(_val);&#125;); 전화번호 시작이 1588, 1668 등과 같은 번호 일 경우에 대해서는 작성하지 않았습니다. 보다시피 완벽하게 최적화가 되지 않았기 때문에 추후에 수정이 될 것 같습니다. 참고 HTML Input 속성들(Attributes) 핸드폰 번호 하이픈(-) 자동입력 전화번호 입력 시 하이픈(-) 자동 입력","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"}]},{"title":"[Git] 이클립스에서 Git 사용법","slug":"eclipse-git","date":"2019-01-18T02:17:07.000Z","updated":"2024-01-11T06:41:51.685Z","comments":true,"path":"2019/01/18/eclipse-git/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/eclipse-git/","excerpt":"","text":"기존에는 사내에서 개발할 때 SVN으로 형상관리를 하였는데, 이번에 개인 공부도 하고 프로젝트로 만들다 보니 GitHub를 사용하게 되었습니다. GitHub는 원격 저장소를 제공하며 여러 가지 프로젝트 진행을 원활하게 하는 도구를 함께 제공하는 이점이 있어서 사용하였습니다. 스프링 프레임워크 기반 웹 프로젝트를 이클립스로 개발하고 있어 이클립스와 GitHub를 연동하였습니다. 이제 연동 방법을 설명합니다. 1. 원격 저장소 생성 먼저 공식 사이트인 https://github.com/ 에서 회원가입을 합니다. 회원가입 후 로그인을 하고 “Start a project” 버튼을 클릭합니다. 래 그림처럼 화면이 나옵니다. 원격 저장소 이름을 입력하고 다른 것은 수정하지 말고 “Create repository” 버튼을 클릭하면 다음과 같은 원격저장소가 생성됩니다. 빨간 네모 박스의 경로를 복사해둡니다. 2. EGit 설치 이클립스를 실행하고 Help -&gt; Eclipse Marketplace를 클릭합니다. Marketplace에서 Egit를 검색한다. 아래 그림처럼 EGit - Git Integration for Eclipse를 찾아 설치합니다. 설치가 완료되면 이클립스를 다시 실행하게 됩니다. 재실행 후에 이클립스의 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보입니다. Git 을 선택하고 [OK] 버튼을 눌러 활성화시킵니다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경됩니다. 3. 원격 저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭합니다. Clone Git Repository 창이 보이면 Clone URL를 선택하고 [Next] 버튼을 클릭하면 아래의 그림처럼 화면이 보입니다.(이클립스 버전마다 조금씩 다른 것 같습니다.) 첫 번째 빨간 박스에서 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력됩니다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭합니다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭합니다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭합니다. 4. 프로젝트 연동 개발하고 있는 프로젝트와 연동하기 위해 작업을 합니다. 프로젝트를 마우스 우클릭 후 그림처럼 **[Team] -&gt; [Share Project]**를 클릭합니다. Git을 선택하고 [Next] 버튼을 클릭합니다. 그런 다음 Repository 란에서 앞에서 생성한 저장소를 설정해주고 [Finish] 버튼을 클릭합니다. 4. 첫 번째 커밋 원격 저장소에 첫 번째로 합니다. 프로젝트를 마우스 우클릭 후 **[Team] -&gt; [Commit]**을 클릭합니다. 다음과 같은 화면이 뜨면 Commit Message 항목에 메시지를 작성 한 후 프로젝트 파일 전체를 Staged Changes 로 옮깁니다. 그런 후에 마지막으로 [Commit and Push] 버튼을 클릭합니다. Branch에 push 하기 과정인데 이 부분은 패스하겠습니다. [Next] 버튼을 클릭합니다. 그럼 로그인 창이 뜰 텐데, GitHub의 아이디와 비밀번호를 입력하시고 [OK] 버튼을 클릭합니다. Push 확인 화면이 보여지는데 확인하고 [Finish] 버튼을 클릭합니다. 다시 로그인 창이 뜹니다. 처음에만 2번 로그인하고 그다음에는 한 번만 로그인하면 됩니다. 아이디 비밀번호를 입력하고 [OK] 버튼을 클릭합니다. 완료가 되면 아래 그림처럼 Push 결과 화면이 보입니다. 5. GitHub에서 프로젝트 확인 GitHub 홈페이지를 가서 Push 된 프로젝트를 확인 할 수 있습니다. 그림처럼 프로젝트가 올라가있고 수정된 이력도 보입니다. 이클립스에서 소스 코드를 수정하고 위에서 본 Commit 과정과 같이 하면 프로젝트를 관리할 수 있습니다. 결론 이클립스와 GitHub의 원격 저장소와 연동하여 설정을 하였습니다. 아직은 깃을 많이 사용해보지 못하였고 조금씩 알아가며 사용하고 있고 Branch에 대해서도 알아가고 있습니다. 늦은 감이 있긴 한데 이제라도 얼른 써서 익숙해지려고 노력해야겠습니다. 참고 [Git] 이클립스에서 Git 사용하기 [Git] 이클릭스에서의 Git 사용법(egit) 1 [Git] 이클립스와 깃(GitHub) 연동하여 원격 저장소의 프로젝트 내려받기 [git] 이클립스(eclipse) 연동하여 처음 사용하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"}]},{"title":"[React Native] Expo 사용 방법","slug":"react-native-expo-start","date":"2019-01-11T07:35:26.000Z","updated":"2024-01-11T06:34:44.446Z","comments":true,"path":"2019/01/11/react-native-expo-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-expo-start/","excerpt":"","text":"Expo 리액트 네이티브는 리액트 아키텍처를 모바일에 적용한 것으로, ES6 문법과 리액트를 이용해 모바일 애플리케이션을 개발할 수 있도록 해주는 프레임워크다. 리액트 네이티브 프로젝트 생성 시 react-native init &lt;프로젝트 이름&gt;을 입력하여 사용하였다. 이것만으로도 충분하다고 느껴졌는데 다른 강좌를 보던 중에 Expo 툴을 발견하게 되었다. Expo는 리액트 네이티브 애플리케이션의 빌드를 돕는 툴이다. 네이티브 API에 접근하는 것도 쉽게 만들어주고, 안드로이드와 iOS 버전을 알아서 빌드해준다. 무엇보다 코드를 수정하면 바로 hot reloading 시켜주는 것이 가장 편하다. 작년 12월 쯤에 리액트 네이티브를 알게 되고 최근에 Expo도 접하게 되면서 찾던 중 처음에는 Expo Xde를 다운로드하여 사용하라고 하여서 Expo 홈페이지를 찾아봤지만 다운로드하지 못하였다. 그러던 중 xde 지원이 중단되고 대신 Expo dev tool(=expo cli 최신버전)을 설치해서 사용하라고 하는 내용을 보게 되었다. Expo cli 설치 및 실행 1. node.js 설치 이전 글인 리액트 시작하기 를 참고한다. &gt; [Programming/React/리액트 시작하기] - Node.js 설치: Windows 2. expo-cli 설치 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행한다. 1$ npm install -g expo-cli 3. 프로젝트 생성 프로젝트 생성할 때는 expo init &lt;프로젝트 이름&gt; 명령어를 사용한다. init 입력 후 프로젝트 개발 목적에 맞게 선택한다. 그런 다음 Use Yarn to install dependencies? 하는 질문에 Y 를 입력하고 엔터를 입력한다. 그러면 설치가 시작되고 완료 후 프로젝트가 정상적으로 생성이 되었는지 확인한다. 1$ expo init react-native-project 4. 프로젝트 실행 프로젝트를 실행하면 새 탭이 생성되면서 다음 그림처럼 보인다. 12$ cd react-native-project$ expo start 5. 모바일 디바이스 연결 실제 모바일 디바이스 먼저 Expo 홈페이지에서 계정을 생성한다. 그런 다음 모바일에서 “Expo client” 앱을 설치한다. 그리고 프로젝트 실행 화면에서 Publish or republish project… 을 클릭하고 내용을 입력 후 Publish Project 버튼을 클릭한다. 클릭하는 순간 터미널(또는 명령프롬프트)에 계정 정보를 입력하라는 문구가 뜬다. 그럼 생성한 계정정보를 입력 후 엔터키를 누르고 프로젝트 실행 화면으로 넘어와서 성공했는지 확인한다. &quot;Expo client&quot; 앱을 실행하고 생성한 계정정보를 입력한다. 로그인 성공 후 하단에 있는 Projects 탭을 클릭한다. 그러면 Publish 성공한 프로젝트가 보인다. 프로젝트를 클릭하면 우리가 작업한 화면이 보일 것이다. 코드를 수정하면 바로 앱에서 변경되는 것을 확인할 수 있다. 이슈사항은 모바일 디바이스와 연결 시 같은 망의 네트워크여야 하는 것 같다. QR Code로 하는 방법도 있는 것 같은데 아직 시도를 못 해봤다. 에뮬레이터 iOS는 Xcode를 설치하고 Android는 Android Studio를 설치하고 AVD manager에서 디바이스를 생성 후 실행시켜준다. 그런 다음 프로젝트 실행 화면에서 “Run on Android device/emulator” 또는 “Run on iOS simulator” 를 클릭한다. 자동으로 에뮬레이터에 앱이 설치가 되고 실행이 된다. 그리고서 실행된 화면을 확인하고 코드를 변경한다. 라이브 리로드 설정이 되어있으면 바로 리로드가 되는 것을 확인할 수 있다. 에뮬레이터 연결은 Expo 뿐만 아니라 앱 개발할 때 자주 사용하기 때문에 따로 설명은 없고 아래 링크에서 가이드를 보면 나와있다. &gt; 모바일 클라이언트 : iOS 및 Android 에뮬레이터 참고 Expo Quick Start Expo Xde 지원 중단에 따른 Expo dev tool(Expo cli) 설치 및 실행 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"}]},{"title":"[React Native] 시작하기","slug":"react-native-start","date":"2019-01-11T04:20:56.000Z","updated":"2024-01-11T06:36:08.306Z","comments":true,"path":"2019/01/11/react-native-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-start/","excerpt":"","text":"React Native 란 리액트는 페이스북이 웹 개발을 쉽게 하기 위해 만든 기술입니다. 리액트 네이티브는 리액트의 접근 방법을 모바일로 확장하는 페이스북의 오픈소스 프로젝트입니다. 기존의 하이브리드 앱은 WebView에 화면을 만들어 놓고 모바일 앱에서 접근하는 것이었기 때문에 퍼포먼스가 떨어지고, 모바일 앱과의 괴리감이 있었습니다. 리액트 네이티브는 실제 네이티브 UI를 사용하여 모바일 앱을 구현합니다. 퍼포먼스는 올라가고 괴리감도 사라지게 됩니다. 리액트 네이티브를 사용하면 JavaScript를 사용하여 모바일 앱을 제작할 수 있습니다. 리액트와 동일한 디자인을 사용하여 선언적 구성 요소에서 풍부한 모바일 UI를 구성할 수 있습니다. 출처: 배고픈사자의 React Native [리액트 네이티브] 장점 높은 생산성 리액트를 사용하여 개발해 보신분이라면 처음부터 빠르게 개발을 시작할 수 있습니다. 아니라면 처음에 당연히 러닝커브(Learning Curve)는 필요합니다. 그렇지만 Swift, Java 또는 Kotlin, Objective-C를 배우는 것보다 자바스크립트 언어 하나로 작성하기 때문에 생산성이 당연히 좋다고 생각합니다. 그리고 iOS와 Android를 동시에 개발할 수 있다는 점이 매우 큰 장점입니다. 라이브 리로딩 리액트 네이티브를 사용하면 앱을 더 빠르게 빌드할 수 있습니다. 기존 앱을 개발할 때는 변경되면 다시 빌드를 해야 했지만 리액트 네이티브로 개발할 때 다시 컴파일 하는 대신 즉시 앱을 다시 로드할 수 있습니다. 코드를 수정해서 저장만 하면 변경된 내용을 바로 확인할 수 있어 실제 개발시간을 확실히 단축시킬 수 있습니다. 필요한 경우 원시 코드 사용 리액트 네이티브는 Swift, Java 또는 Objective-C로 작성된 구성 요소와 원활하게 결합합니다. 애플리케이션의 몇 가지 측면을 최적화해야하는 경우 네이티브 코드로 간단하게 작성할 수 있습니다. 단점 개발자료 부족 시작된지 얼마 되지 않는 프로젝트라서 검색을 하였을 때 확실히 자료가 적은 것 같습니다. 더군다나 영어 자료는 있는데 한글로 된 자료는 더욱 없다고 느껴집니다. 힘든 유지보수 플랫폼 기기에 대한 문제가 생기면 원인을 찾기가 힘든 것 같습니다. 그리고 국내에 리액트 네이티브 개발자가 많이 없다고 들었습니다. 만약에 리액트 네이티브로 개발을 완료하고 퇴사를 하게 되면 후임자나 유지보수를 해야 하는 개발자를 구해야 하는데 특히 소규모 회사들은 더욱 어렵다고 느껴집니다. 비고 위의 단점이 있더라도 장점이 크다고 느껴지고 흥미가 있어 리액트 네이티브에 대해 공부하고 앞으로 있는 새로운 프로젝트에서 사용해 볼 예정입니다. 리액트 네이티브 설치와 실행 및 환경설정은 워낙 정리가 잘 되어있는 블로그가 많아서 따로 정리를 하지 않았습니다. 아래 참고에 되어 있는 링크를 따라가면 window, macOS 환경에서의 설치와 ios, android 플랫폼에서 실행할 수 있도록 잘 설명되어 있습니다. 그리고 리액트 네이티브에 대한 내용과 장단점에 대해서도 참고 링크를 보면 자세하게 볼 수 있습니다. 참고 React Native 설치와 실행(hello world) [RN] React-Native 시작하기 React Native React Native Getting Started [RN] React-Native의 장단점은?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"}]},{"title":"WPF MVVM 일주일 만에 배우기","slug":"book-wpf","date":"2019-01-11T02:00:22.000Z","updated":"2023-07-12T06:26:18.327Z","comments":true,"path":"2019/01/11/book-wpf/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/book-wpf/","excerpt":"","text":"책 정보 책 소개 필자의 십 수년간의 강의 경험을 최적화하여 집필한 가장 얇은 WPF 개발 서적으로 군더더기 없이 WPF를 빨리 배울 수 있다. 간단한 연습 과제와 따라 하기 방식의 해당 풀이를 통해 컨트롤 및 레이아웃, 데이터 바인딩 등의 WPF 기본 사항들을 익히고 최종적으로는 MVVM 패턴을 사용한 WPF 응용 프로그램 예제를 만들어 본다. 한국어판에서는 좀 더 쉽게 이해할 수 있도록 스크린샷과 설명을 추가했다. 짧은 시간 내에 WPF 및 MVVM 패턴에 대한 내용을 익히고 실제 프로젝트에 적용하고자 한다면 WPF 개발 서적이 몇 없는 국내 현실에서 단비와 같은 이 책 한 권으로 의도한 바를 이룰 수 있을 것이다. 리뷰 WPF 기반 프로젝트를 하기 전에 WPF 에 대한 기본 개념을 잡기 위해 구매한 책이다. 기본 개념을 잡기 위해 구매한 책이라 그런지 입문하는 입장에서는 좋은 책 인 것 같지만 정말 기본만 배우게 되어 조금 아쉬웠다. 그래도 애플리케이션 생성과 데이터 바인딩, MVVM 패턴 등 중요한 용어에 대해 알려줘서 나중에 개발 시 구글 검색을 할 때 좋을 것 같았다. 코드 양은 얼마 없고 페이지 수도 짧아 일주일이 되지 않아 다 읽게 되었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"}]},{"title":"이것이 C#이다","slug":"book-c","date":"2019-01-09T09:13:33.000Z","updated":"2024-01-11T06:47:24.508Z","comments":true,"path":"2019/01/09/book-c/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/book-c/","excerpt":"","text":"책 정보 책 소개 한 번 배울 때 제대로, 기본기부터 탄탄히 다지고 간다! 이 책은 C# .NET 프레임워크 세계에 첫 발을 들이는 입문자를 위한 책이다. 따라서 딱딱하지 않은 대화식 표현으로 1:1 강의처럼 배울 수 있는 것이 이 책의 가장 큰 장점이다. 또한 C#의 핵심 문법은 물론, 프로그래밍 동작 원리까지도 입문자 입장에서 하나하나 꼼꼼히 설명하였다. 책을 덮을 때쯤이면 기초 문법부터, 고급 문법, 그리고 .NET 프레임워크의 활용까지 C#의 전반적인 큰 틀을 자연스레 익힐 수 있을 것이다.『이것이 C#이다』로 C# 프로그래밍을 시작한다면, 튼튼한 기본기가 갖춰져, 더 이상 실전과 응용도 두렵지 않습니다. 리뷰 개발 서적을 구매하고 공부하는 것을 좋아해서 찾아보다가 예전부터 알개발해 보고 싶었던 C# 책을 찾게 되었다. 마침 회사에서도 C#, WPF 기반 프로젝트를 수행하게 되어 급하게 알아보다가 이 책을 구매해서 역시나 코드를 보며 이해하였다. Java 개발을 몇년 간 한 경험으로 C# 코드를 봤을 때 정말 비슷한 점이 많고 오히려 더 쉽게 느껴졌다. 역시나 개발을 하면서 더 익숙해지겠지만 LINQ 나 람다식으로 인해 코드가 직관적이고 간결하게 표현되는 것을 보며 책을 구매하기 잘 했다고 생각하였다. 여러모로 만족이었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[React] 설치 및 설정 방법","slug":"react-start","date":"2019-01-09T05:10:34.000Z","updated":"2024-01-11T06:32:36.105Z","comments":true,"path":"2019/01/09/react-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/react-start/","excerpt":"","text":"리액트란 React는 사용자 인터페이스를 만들기 위해 페이스북과 인스타그램에서 개발한 오픈소스 자바스크립트 라이브러리로써, 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM을 통해 속도와 편의를 높이고, 단방향 데이터플로우를 지원하여 보일러플레이트 코드를 감소시켜, 많은 사람들이 React를 MVC의 V를 고려하여 선택한다. 즉, React는 지속해서 데이터가 변하는 대규모 어플리케이션의 구축이라는 하나의 문제를 풀기 위해서 만들어졌다. 아래는 React에서 장점들이다. 단순함 : 당신의 어플리케이션이 어떤 주어진 시점에 어떻게 보여야 할지를 단순하게 표현함으로써, React는 그 데이터들이 변할 때, 자동적으로 모든 UI 업데이트들을 관리할 것이다. 선언적인 문법 : 데이터가 변할 때, React는 개념적으로 ‘새로고침’ 버튼을 눌러서, 변화된 부분을 알아채 업데이트하게 된다. 구성적인 컴포넌트 개발 : React는 재사용가능한 컴포넌트들을 개발하기 위한 모든 것이다. 사실, React로 당신이 할 수 있는 오직 한 가지는 컴포넌트를 개발하는 것이다. 그것들은 캡슐화되어있기 때문에, 컴포넌트들은 재사용될 수 있고, 테스트될 수 있으며, 관심의 분리(seperation of concerns)를 지키게 해 준다. 설치하기 리액트를 설치하고 프로젝트를 만들어 보자. 리액트 프로젝트를 만들 때는 Node.js 와 npm을 반드시 먼저 설치해야 한다. Node.js는 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임이다. 2009년 Node.js를 출시한 이후 자바스크립트는 웹 브라우저 영역 외에 웹 서버는 물론, 모바일 애플리케이션, 데스크톱 애플리케이션 영역에서도 엄청나게 활약할 수 있게 되었다. 1. Node.js 설치: Windows Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/)에서 Windows Installer를 다운로드하고 설치한다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인한다. 12$ node -vv10.15.0 2. 에디터 설치 리액트 애플리케이션을 만들면서 코드를 수정할 때는 코드 에디터를 설치하여 사용하는 것이 편하다. 브래킷(Bracket), 아톰, VS Code를 써본 결과 모든 운영체제를 지원하는 VS Code를 사용하고 있다. VS Code 공식 다운로드 페이지(https://code.visualstudio.com/Download)에서 운영체제에 맞는 버전을 설치한다. 여기서는 Windows 버전을 설치한다. 이 에디터는 macOS, Window, 리눅스를 모두 지원한다. 3. create-react-app 설치 create-react-app 도구는 npm으로 설치할 수 있다. 패키지를 설치하는 방법은 두 가지가 있는데, 첫 번째는 지역적으로 설치하는 것이고, 두 번째는 전역적으로 설치하는 것이다. create-react-app은 커맨드라인 도구라서 모든 디렉터리에서 필요하므로 전역적으로 설치한다. 1$ npm install -g create-react-app 프로젝트 생성 프로젝트 생성할 때는 create-react-app &lt;프로젝트 이름&gt; 명령어를 사용한다. 123$ create-react-app test-react$ cd test-react$ npm start npm start 실행하여 완료했다면 http://localhost:3000/ 로 접속하여 확인한다. 프로젝트 구조 VS Code를 실행하여 만들어진 test-react 프로젝트를 열면 다음과 같은 구조로 만들어져 있다. 이미 modules 가 설치되어 있고, 의존성 패키지는 대부분 node_modules/react-scripts 모듈 내에 선언되어 있다. src 폴더안에 있는 파일들을 추가하고 수정하면서 개발을 하면 된다. 정리 리액트에 관심이 생겨 책을 읽고 검색한 내용들을 모아서 리액트에 대한 설명부터 설치, 프로젝트 실행까지 간략하게 설명하였다. 현재는 리액트를 공부하면서 정리하는 단계라서 현업에서 리액트 라이브러리를 사용하면서 겪는 이슈사항이나 팁은 추후에 정리할 예정이다. 참고 React 시작하기 [ReactJs] create-react-app으로 react 시작하기 [React] 1. 리액트 시작하기 개발 관련 강좌 사이트 리액트를 다루는 기술 출간 / 집필후기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"}]},{"title":"[React Native] Live Reload","slug":"react-enable-reload","date":"2019-01-08T08:59:53.000Z","updated":"2024-01-11T06:30:20.062Z","comments":true,"path":"2019/01/08/react-enable-reload/","link":"","permalink":"http://hgko1207.github.io/2019/01/08/react-enable-reload/","excerpt":"","text":"Live Reload 리액트 네이티브 기반으로 안드로이드 앱 개발을 할 때 자동으로 리로드 되게 하려면 어떻게 해야 할까. 리액트 기반으로 웹 개발을 할 때에는 코드를 수정 시 자동으로 리로드 되었는데 리액트 네이티브로 개발할 때에 자동으로 되지 않아 검색하던 중 아래 내용처럼 옵션 설정을 하니까 잘 동작하였다. 명령 프롬프트에서 다음을 입력하여 장치 또는 에뮬레이터에서 앱을 설치하고 실행한다.1$ react-native run-android 에뮬레이터를 클릭하고 CTRL + M ( MacOS의 경우 CMD + M )을 누르거나 실행 중인 응용 프로그램이 있는 Android 장치를 흔들면 된다. 팝업 메뉴에서 Enable Live Reload 옵션을 선택한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"}]},{"title":"[Eclipse RCP] 이클립스 플러그인 추가","slug":"eclipse-rcp","date":"2019-01-07T09:25:03.000Z","updated":"2024-01-11T06:25:35.836Z","comments":true,"path":"2019/01/07/eclipse-rcp/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/eclipse-rcp/","excerpt":"","text":"Eclipse Piug-in 추가 Eclipse에 플러그인을 추가하는 방법에는 두 가지가 있다. 첫 번째 방법은 플러그인을 직접 복사해서 설치하는 방법이고, 두 번째 방법은 Eclipse 에서 제공하는 Software Update Manager 를 활용하는 방법이다. 직접 복사하는 방법 설치하고자 하는 플러그인을 Eclipse_home/plugin 디렉터리에 복사한 다음 Eclipse를 재시작하면 새롭게 설치된 Eclipse 플러그인 기능을 활용할 수 있다. Software Update Manager를 활용하는 방법 Eclipse 에서 제공하는 Software Update Manager 기능은 플러그인을 개발한 곳에서 이 기능을 사용할 수 있도록 지원하지 않으면 사용할 수 없다. Eclipse 에서 Help-&gt;Install New Software로 이동 후 설치 할 플러그인 URL를 입력하여 다운받는다. 또 다른 방법은 Help-&gt;Eclipse Marketplace로 이동 후 설치 플러그인을 검색 후 다운로드한다. 이클립스 RCP Piug-in 구조 모든 플러그인의 실제 동작에 대한 정의는 코드에 들어있지만, 플러그인의 종속성과 서비스는 MANIFEST.MF와 plugin.xml 파일에서 선다. 이런 구조 덕분에 플러그인 코드가 당장 필요한 순간이 되어서야 로딩되는 늦은 로딩(lazy loading)이 가능하며, 이에 따라 이클립스의 시동 시간과 메모리 사용량을 줄일 수 있습니다. 이클립스 시동될 때는 플러그인 로더가 각 플러그인에 대한 MANIFEST.MF와 plugin.xml 파일 전부를 훑어본 다음, 플러그인에 대한 정보를 포함하는 구조체를 구성한다. Piug-in 선언(MANIFEST.MF) 각 번들 내역서 내에는 이름, ID, 버전, 플러그인 클래스, 프로바이더에 대한 항목이 들어 있다. 1. Piug-in ID 플러그인 ID(Bundle-SymbolicName)는 단 하나의 플러그인을 식별하기 위해 설계된 것이며 일반적으로 자바 패키지 이름 규약(예: com.&lt;회사명&gt;.&lt;제품명&gt;)을 이용해 구성된다. 2. Piug-in 버전 플러그인에 지정된 버전(Bundle-version)은 항상 3개의 수를 점으로 구분해 나열한 것이다. 첫 번째 수는 주 버전(major version)을 의미하며 두 번째는 부 버전(minor version), 세 번째는 서비스 레벨을 의미한다. 3. Piug-in 이름과 제공자 이름과 제공자는 둘 다 사람이 읽기 위한 텍스트이므로 어떻게 입력하든지 상관없고 또한 유일할 것일 필요도 없다. 4. Piug-in 클래스 선언 모든 플러그인은 필요한 경우에 플러그인 클래스(Bundle-Activator)를 지정할 수 있다. 5. Piug-in 런타임 MANIFEST.MF 파일의 Bundle-ClassPath 선언에는 플러그인 코드에 포함된 라이브러리(*.jar 파일) 를 콤마(‘ , ‘)로 구분해 나열한다. Bundle-ClassPath에서 정의한 라이브러리에 들어있는 패키지를 다른 플러그인에서 접근 할 수 있게 지정하려면 ExportPackage 선언을 써서 접근 가능하게 할 패키지를 콤마 구분 목록으로 지정한다. 6. Piug-in 종속성 플러그인 로더는 각 로딩된 플러그인마다 개별 클래스 로더의 인스턴스를 생성하며 내역서의 Require-Bundle 선언을 사용해 해당 플러그인이 실행 중 참조해야 할 플러그인이 어느 것인지를 지정한다. Piug-in 모델 이클립스는 처음 실행될 때 각 플러그인 디렉토리를 모두 돌아본 다음, 찾아낸 개별 플러그인을 표현하는 내부 모델을 구성한다. 개별 플러그인 전체를 로딩하지 않으며 플러그인 내역서만 검토한다. 1. Platform org.eclipse.core.runtime.Platform 클래스는 현재 실행 중인 이클립스 환경에 대한 정보를 제공한다. 이 클래스를 사용해 설치되어 있는 플러그인(번들), 확장, 확장점, 명령행 인자, 작업 관리자 등의 정보를 얻을 수 있다. 2. Piug-in 과 번들 Platform.getBundleGroupProviders() 나 Platform.getBundle(String)을 사용해 현재 설치된 플러그 인(번들)에 대한 정보를 얻을 수 있다. 플러그인 클래스, 즉 번들 액티베이터에 접근하려면 해당 플러그인을 로드해야 하지만 Bundle 인터페이스에는 별도의 부담 없이 접근할 수 있다. 3. Piug-in 확장 레지스트리 Platform.getExtensionRegistry() 메소드를 사용해서 플러그인 확장 레지스트리(extension registry)에 접근할 수 있다. 확장 레지스트리에는 각 플러그인을 표현하는 플러그인 디스크립터가 포함되어 있으며 플러그인을 로딩하지 않고도 다양한 플러그인 정보를 얻을 수 있는 메소드를 제공한다. Piug-in 개발 Piug-in Project 생성 New -&gt; Plug-in Project 클릭한다. Project name 입력 후 Next 클릭한다. ID에 패키지명 입력 Activator 패키지 명을 1)번에 입력한 패키지명과 같도록 입력 No 버튼 클릭 후 Next 클릭 “Hello, World Command” 선택 후 Finish 클릭한다. 위와 같이 플러그인 프로젝트가 생성되면 MANIFEST.MF 클릭 -&gt; Extensions 탭으로 이동 기본적으로 “Hello, World Command”를 선택하면 commands, handlers, bindings, menus 4개의 트리가 만들어진다. Commands는 실제 동작으로부터 독립적이며 선언적이고, org.eclipse.ui.commands 확장점을 통하여 정의되어 있다. 그리고 단축키(Key Binding)가 정의될 수 있고, 커맨드의 행동은 핸들러를 통하여 정의된다. Handlers는 commands로부터 명령을 받아 호출되고, 호출되자마자 클래스를 실행한다. 클래스를 정의할 때 org.eclipse.core.commands.AbstractHandler 클래스를 상속받는다. Execute() 메소드는 핸들러가 실행되면 호출 되며, HandlerUtil 클래스를 통하여 서비스에 접근할 수 있다. Bindings는 메뉴에 단축키를 지정할 수 있다. Menus는 애플리케이션 메인 메뉴, 툴바, 뷰 툴바, 팝업메뉴를 만들 수 있다. org.eclipse.ui.menus 에서 menuContribution는 사용자 인터페이스에서 메뉴가 표시되는 위치를 정의할 수 있는 locationURI 속성을 가지고 있다. locationURI 속성에는 기본적으로 menu:와 toolbar:, popup: 으로 시작하며 그 다음에는 메뉴가 표시될 위치를 지정할 수 있다. 예를 들어, 파일 메뉴(ID:fileMenu)의 하의 메뉴에 위치시키려면 다음와 같은 위치식을 이용한다. 12// 예)menu:fileMenu?after=addition Piug-in 배포 플러그인을 만들었으면 jar로 생성해야 합니다. Export -&gt; Plug-in Development -&gt; Deployable plug-ins and fragments 선택 후 Next 클릭한다. 배포하는 플러그인 프로젝트를 선택하고, Directory란에 배포하는 폴더를 지정하고, Finish를 클릭한다. 지정한 폴더에 jar로 배포가 되는 것을 확인할 수 있다. 참고 이클립스 커맨드 튜토리얼 Eclipse RCP 란?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"도메인이란","slug":"it-domain","date":"2019-01-07T08:16:14.000Z","updated":"2024-01-11T06:27:57.981Z","comments":true,"path":"2019/01/07/it-domain/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/it-domain/","excerpt":"","text":"도메인 이름은 ‘인터넷에 연결된 컴퓨터들에 부여되는 교유의 문자 주소’ 정도라고 보시면 된다. 영어로는 DNS(Domain Name System)라고 합니다. 인터넷에 연결되어 있는 컴퓨터에 접속하려면 IP 주소(Internet Protocol Address)를 알아야 합니다. 그런데 IP 주소는 기억하기가 힘듭니다. 매우 불편합니다. 그래서 쉽게 사이트의 주소를 기억하고 여기서 좀 더 나아가서 사이트의 특성을 파악할 수 있도록 고안된 것이 바로 '도메인 이름’입니다. 도메인은 각 컴퓨터 고유의 IP주소에 대응되는 문자로 된 인터넷 주소입니다. EX) 구글(google) 사이트 google . co . kr =&gt; 소속기관이름 . 소속기관 분류 . 소속국가 도메인은 크게 3단계로 구분됩니다. (인터넷 도입 초기에는 3단계였으나, 현재는 2단계도 혼용 사용, 예) .kr) 가) 최상위 도메인(2가지로 분류) 미국 최상위 도메인 : com, edu, net, org, gov, re, mil, int 국가 최상위 도메인 : kr, jp, cn 나) 2차 도메인 미국 최상위 도메인에서의 2차 도메인 : naver, yahoo, google 국가 최상위 도메인에서의 2차 도메인 : or, co, ac, ne 다) 3차 도메인 국가 최상위 도메인에서의 3차 도메인 : nate, yahoo com : 상업기관 co.kr : 상업기기관 + 국가도메인 net : 네트워크 관련 기관 go.kr : 정부기관 + 국가도메인 or.kr : 비영이/기타 기관 + 국가도메인 kr과 혼합된 주소는 한국 관련 회사를 뜻하는 것입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"}]},{"title":"[JPA] Annotation 정리","slug":"jpa-annotation","date":"2019-01-07T05:15:34.000Z","updated":"2024-01-11T06:29:56.163Z","comments":true,"path":"2019/01/07/jpa-annotation/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/jpa-annotation/","excerpt":"","text":"JPA 로 개발하면서 자주 사용하는 어노테이션을 정리하였다. @Entity 해당 클래스가 엔티티임을 알리기 위해 사용한다. 애플리케이션이 실행이 될 때 엔티티 자동검색을 통하여 이 어노테이션이 선언된 클래스들은 엔티티 빈으로 등록한다. @Table 데이터의 저장소, 테이블을 의미한다. name 값은 실제 데이터베이스의 테이블 명을 의미하며, 생략이 가능한다. 어노테이션을 생략하면 클래스의 이름을 테이블의 이름으로 자동 인식하게 된다. @Id 엔티티빈의 기본키를 의미한다. 이 어노테이션은 하나의 엔티티에는 반드시 하나가 존재해야 한다. 복수키도 설정할 수 있다. @GeneratedValue 데이터베이스에 의해 자동으로 생성된 값이라는 의미다. 즉, 프로그램 상에서 조작된 데이터가 아닌, 실제 데이터베이스에 데이터가 영속(저장)될 때 생성되는 값이다. 몇 가지 생성전략이 존재한다. IDENTITY : 기본 키 생성을 데이터베이스가 함 SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키 할당 TABLE : 키 생성 테이블 생성 @Column 필드와 테이블의 컬럼을 매핑시켜 준다. 이 어노테이션은 생략이 가능하며, 생략 시 필드의 이름이 테이블의 컬럼으로 자동으로 매핑이 된다. name속성(String) 필드와 매핑 될 컬럼의 이름을 명시한다. nullable속성(boolean) 해당 컬럼이 null값을 허용하는가 하지않는 가의 여부다. length속성(int) 컬럼의 길이값을 의미합니다. unique속성(boolean) 컬럼이 유일한 값을 가져야 하는가 아닌가의 여부다. insertable속성(boolean) 엔티티가 영속될 때 insert에 참여할지 말지를 결정한다. 기본값은 true updatable속성(boolean) 변경된 필드의 값을 테이블에도 반영할지를 결정한다. 기본값은 true name 속성을 제외한 나머지 속성은 잘 사용되지 않을 것이라고 생각된다. nullable, length, unique는 DDL과 관련된 속성이고, insertable, updatable은 원래 잘 사용되지 않는 속성이기 때문이다. @Temporal java.util.Date와 java.util.Calendar 값을 매핑할 때 사용한다. TemporalType.Date : 년-월-일 의 date 타입 (2019-01-04) TemporalType.Time : 시:분:초 의 time 타입 (12:11:11) TemporalType.TIMESTAMP : date + time의 timestamp(datetime) 타입 (2019-01-04 12:11:11) 어노테이션을 사용하지 않을 경우 기본값은 timestamp 다. JPA 데이터베이스 방언에 의해, 데이터베이스의 타입에 따른 timestamp 또는 datetime은 자동으로 작성된다. @ColumnPosition(1) 컬럼 순서 정한다. @Enumerated 자바의 enum 타입을 매핑할 때 사용한다. 속성으로 EnumType.ORDINAL 과 EnumType.STRING 이 존재하는데 이름 그대로 ORDINAL은 순서를 STRING은 Enum의 이름을 저장한다. @LOB 데이터베이스 BLOB, CLOB 타입과 매핑된다. CLOB(String, char[], java.sql.CLOB)은 문자, BLOB(byte[], java.sql.BLOB)은 나머지가 매핑된다. @Transient 저장 조회에 사용되지도 않고 그냥 단순 값을 가지고 있고 싶을 때 사용한다. @Access 데이터베이스에 엔티티에 값이 저장될 때 필드(AccessType.FIELD)의 값을 직접 접근해서 사용할 것인가 아니면 메서드에 직접(AccessType.PROPERTY) 접근할 것 인가를 설정하는 것이다. @MappedSuperClass 어노테이션을 사용하면 부모 엔티티 접근 없이 부모 클래스의 매핑정보를 사용할 수 있다. 부모의 내용을 별도로 재정의해서 사용하고 싶은 경우에는 @AttributeOverride를 사용하여 재정의 한다. 여러 개를 한번에 정의하기 위해서는 @AttributeOverrides를 사용한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"}]},{"title":"리액트를 다루는 기술","slug":"book-react-technology","date":"2019-01-07T04:53:57.000Z","updated":"2024-01-11T06:47:29.806Z","comments":true,"path":"2019/01/07/book-react-technology/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-react-technology/","excerpt":"","text":"책 정보 책소개 리액트를 이해하기 위한 핵심 개념은 물론이고 어떤 상황에서 어떻게 사용해야 하는지, 왜 이렇게 사용하는 것이 효과적인지를 배우자. 공식 문서에는 나오지 않는 실전 노하우와 팁을 풍부하게 담았다. 또한, 프로젝트 생성부터 코드를 작성 및 개선하고, 배포하기까지 실무에 바로 응용할 수 있도록 예제를 준비했다. 일정 관리 애플리케이션을 만들면서 리액트의 기본기를 다지고, 프로젝트를 진행하면서 컴포넌트 스타일링, 상태 관리, API 연동, 라우팅, 코드 스플리팅, 서버사이드 렌더링 등 리액트를 활용한 다양한 기술을 사용해 보자. 마지막으로 마크다운 기반의 블로그 시스템을 만들며 배운 지식을 종합적으로 활용해 보자. 리뷰 작년에 처음으로 AngularJS를 사용하여 프로젝트를 하면서 접한 이후로 관심이 생겨 최신 버전인 Angular6을 공부하였었는데 뭔가 착 달라붙는다는 느낌이 들지 않아 잠깐 공부를 멈췄다. 최근에 다시 새로운 기술을 공부하고 싶어 찾던 중에 리액트가 자바스크립트 라이브러리라서 접근하기가 쉽고 이해도도 빠를 것 같아 책을 바로 구매하게 되었다. 책을 사면 예제를 직접 하나씩 다 코딩하면서 공부하는 타입이라서 이번에도 모두 다 코딩을 하면서 익숙해져 갔다. 그런데 책에 있는 예제들이 자바스크립트라서 익숙하긴 한데 리액트 초보자에게는 조금 어렵다는 느낌이 들었다. 그래도 열심히 따라서 코딩한 덕분에 흐름을 이해할 수 있었다. 리액트를 알게 되면서 리액트 네이티브에 대해서도 공부하고 싶은데 출간된 책이 많이 없는 것 같아 아쉬웠다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"}]},{"title":"[Android] Tab 구성 시 주의사항","slug":"android-tab","date":"2019-01-07T04:42:09.000Z","updated":"2024-01-11T06:22:45.145Z","comments":true,"path":"2019/01/07/android-tab/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/android-tab/","excerpt":"","text":"FragmentStatePagerAdapter의 getItem() 이 두 번 호출될 때 Viewpager를 사용하여 Tab 을 구성하였을 때 FragmentStatePagerAdapter를 사용하였다. 탭에 추가한 Fragment 와는 상관없이 getItem() 이 두 번 호출이 되어서 Fragment 를 두 번 로드하게 되는 현상 때문에 문제가 생겨 꼬이게 되었다. 이럴 경우 Fragment 화면이 보일 때와 보이지 않을 때 setUSerVisiblaHint() 함수를 사용하여 처리하는데 탭에 추가한 Fragment가 전부 로드되지 않고 어중간하게 두 개의 화면만 로드되었기 때문에 다른 탭을 누르거나 다시 돌아왔을 때 setUSerVisiblaHint() 와 onCreateView() 함수가 비정상적으로 호출되는 바람에 코딩을 하는데 애먹었다. 그래서 찾은 방법은 아래 코드 처럼 ViewPagerAdapter에 Fragment를 3개 추가 하였을 때 setOffscreenPageLimit() 함수에 viewPager 에 추가한 Fragement 의 수를 지정하여 화면이 미리 로드되게 하면 getItem() 은 Fragement 수 만큼(예: 3번) 호출되지만 앞에서 문제되는 것을 해결할 수 있었다. 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tabs) TabLayout tabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); setupViewPager(); &#125; private void setupViewPager() &#123; ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager()); viewPagerAdapter.addFragment(new MobileFragment()); viewPagerAdapter.addFragment(new LteFragment()); viewPagerAdapter.addFragment(new WifiFragment()); viewPager.setOffscreenPageLimit(viewPagerAdapter.getCount()); viewPager.setAdapter(viewPagerAdapter); tabLayout.setupWithViewPager(viewPager); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"}]},{"title":"[JavaScript] Chart 라이브러리 정리","slug":"javascript-chart","date":"2019-01-07T04:19:53.000Z","updated":"2024-01-11T06:28:52.168Z","comments":true,"path":"2019/01/07/javascript-chart/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/javascript-chart/","excerpt":"","text":"웹 개발을 하면서 사용해 본 Chart 를 정리 해보았다. 무료인 것도 있고 조건부 무료인 차트도 있다. 대부분 사용하기에 편리하여 적용하기도 쉽고 심플하고 이쁜 디자인도 많고 예제와 설명이 잘 되어있어 좋았다. 1. AmCharts 링크 : ​https://www.amcharts.com/ 예제 : http://www.amcharts.com/demos/ 유료 라이선스 이지만 조건부 무료다. 사용해 본 라이브러리 중에 기능이 엄청 많고 디자인이 제일 깔끔하다. 라이선스 비용은 개인이 사용하기에는 부담이 될 수 있지만, 차트에 개발사 링크가 출력되는 조건만 지키면 무료로 사용 가능하다. 2. HighCharts 링크 : https://www.highcharts.com/ amCharts와 같이 조건부 무료입니다. Angular에서도 쓸 수 있고, 차트 종류도 다양하고, 사용법이 편리하며 커스터마이징도 쉽게 할 수 있다. 현재 가장 많이 사용하는 차트다. 3. D3 Data-Driven Documents 링크 : https://d3js.org/ 무료입니다. 데이터 시각화 프레임워크로 잘 알려져 있고, 자바스크립트로 개발을 한다. HTML5의 SVG(Scalable Vector Graphic)을 통해 다양한 화면 해상도에서 깨짐 없는 가시화가 가능하다. D3 차트에서는 버블차트와 OpenLayers3에 파이차트를 올려 사용하였다. D3는 기본적인 개념과 사용법을 익혀야 사용이 가능하므로 공부를 많이 해야 한다. 4. Chart.js 링크 : http://www.chartjs.org/ 예제 : http://www.chartjs.org/docs/latest/ 오픈소스이며, 전체적으로 깔끔하고 문서도 정리가 잘 되어 있습니다. 인기가 많고, 사용법이 편리하고 이쁩니다. 5. Google Chart 링크 : https://developers.google.com/chart/ 구글 차트는 많이 사용해보지 못하였지만, 기능은 많습니다. 하지만 디자인이 다른 차트에 비해 이쁘지 않은 것 같아 많이 사용하지 않았습니다. 그렇지만 사용하기는 편리합니다. 6. Morris.js 링크 : http://morrisjs.github.io/morris.js/ 무료이며 사용이 정말 간단합니다. 그리고 디자인도 심플한 편이라 간단하게 테스트 용으로 많이 사용하였습니다. 7. Chartist.js 링크 : http://gionkunz.github.io/chartist-js/ Chartist 또한 인기있는 Chart Javascript 라이브러리 중의 하나로 SVG를 사용하며, CSS를 통해 모양을 다듬을 수 있습니다. 위의 차트들이 자주 사용하는 차트들입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"[Cesium] 초기 설정","slug":"cesium-init","date":"2019-01-07T02:37:21.000Z","updated":"2024-01-11T06:24:54.384Z","comments":true,"path":"2019/01/07/cesium-init/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/cesium-init/","excerpt":"","text":"GIS 관련 프로젝트를 하다 보니 오픈소스인 CesiumJS 나 Openlayers 라이브러리를 사용하게 되었다. 최근에는 2D, 3D 모드가 가능한 CesiumJS를 주로 사용하게 되었다. Cesium 이란? 순수 웹 기불을 이용한 3D Globe 엔진 WebGL 기반 다양한 배경 영상/지도 기본 제공 3D / 2.5D / 2D 모드 지원 -&gt; Openlayers3에 통합 카메라 움직임 추적, 시간 시뮬레이션 등 다양한 기능 제공 Cesium 을 시작할 때 초기 설정이 복잡하다. 아래 두 개의 링크를 따라가서 따라 하면 쉽게 할 수 있다. 하지만 웹에서 커스터마이징을 하기 위해 아래 코드처럼 Cesium에서 지원하는 기본적인 기능들을 끄고 지도만 보이도록 설정해야 한다. API들은 문서나 인터넷 검색으로 찾아봅시다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- Include the CesiumJS JavaScript and CSS files --&gt; &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt; &lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; imageryProvider: new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/gwc/service/wms', layers: 'osm:osm', parameters: &#123; service: 'WMS', version: '1.1.1', request: 'GetMap', layers: 'osm:osm', srs: 'EPSG:3857', crs: 'EPSG:3857', format: 'image/png', tranparent: true, tiled: true, &#125;, tilingScheme: new Cesium.WebMercatorTilingScheme(), &#125;), animation: false, baseLayerPicker: false, fullscreenButton: false, vrButton: false, geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, selectionIndicator: false, timeline: false, navigationHelpButton: false, projectionPicker: false, selectedEntity: false, trackedEntity: false, clockTrackedDataSource: false, &#125;); const scene = viewer.scene; const camera = viewer.camera; const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas); const ellipsoid = scene.globe.ellipsoid; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 위의 예제는 미리 구축된 Geoserver 를 베이스 맵으로 설정하였다. Geoserver 가 구축되지 않았다면 Cesium에서 제공되는 기본 Provider를 사용하면 된다. 123456&lt;!-- 예시 --&gt;&lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; terrainProvider: Cesium.createWorldTerrain(), // 기본 지도를 지형지도로 셋팅 &#125;);&lt;/script&gt; 참고 https://cesium.com/docs/tutorials/quick-start/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"}]},{"title":"깡샘의 안드로이드 프로그래밍","slug":"book-ggangsam","date":"2019-01-07T01:09:21.000Z","updated":"2024-01-11T06:47:33.060Z","comments":true,"path":"2019/01/07/book-ggangsam/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-ggangsam/","excerpt":"","text":"책 정보 책 소개 이 책은 각 챕터마다 안드로이드 프로그램과 각 기능이 어떠한 구조로 어떻게 작동하는지 그 원리를 파악하는 데 주력합니다. 그리고 이를 구현하는 핵심 코드를 알아본 다음, 이를 종합하여 실제 상용 앱에서 많이 사용하는 기능을 직접 개발해 보는 실습을 진행합니다. 그리고 각 파트별로 도전 과제를 통해 학습자 스스로 주어진 조건에 맞는 앱을 만들어봄으로써 앞에서 배운 이론과 실습을 복기하고 문제 해결 능력을 기를 수 있게 구성하였습니다. 한 마디로 체계적이고 따라 하기 쉽습니다. 리뷰 최근에 안드로이드를 다시 공부하면서 보는 책이다. 안드로이드 스튜디오 3.0 기반으로 개발할 수 있도록 해주며, 끝에는 Kotlin 까지 나온다. 그리고 예제도 다양하여 도움이 많이 되었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"}]},{"title":"[Angular] 강좌 추천","slug":"angular","date":"2019-01-07T00:55:40.000Z","updated":"2024-01-11T06:23:13.935Z","comments":true,"path":"2019/01/07/angular/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/angular/","excerpt":"","text":"Angular 강좌 추천 작년에 Angular1 즉 AngluarJS를 Spring Framework + Spring JPA + MySQL 합쳐서 연동하여 개발하였다. 그 때에 AngularJS 를 처음 접해보았고, 제가 아는 분에게 배우기도 해서 일부분을 개발하다가 하나의 프로젝트를 처음부터 만들어 보았었다. 그 이후로 Angular 를 사용하지 않았었는데, 지금 벌써 Angular 6 버전 까지 나와서 놀랐다. 아래 URL은 Angular 6 은 아니지만 Angular 5 버전 강좌다. NodeJS 와 Typescript 가 대세여서 공부해보려고 하다가 Angular를 다시 보게 되어 찾다가 이 강좌가 설명이 너무 잘 되어 있어서 공부를 하는 중이다. 여러모로 감사합니다. URL: https://moon9342.github.io/angular-lecture-introduction","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"}]},{"title":"[Web Design] Metronic Dashboard","slug":"dashboard","date":"2019-01-04T09:13:00.000Z","updated":"2024-01-11T06:22:12.990Z","comments":true,"path":"2019/01/04/dashboard/","link":"","permalink":"http://hgko1207.github.io/2019/01/04/dashboard/","excerpt":"","text":"대시보드 템플릿 웹 개발을 하다 보면 작은 프로젝트인데도 디자인 요청이 있다. 그럴 때마다 디자인된 부트스트랩 기반 템플릿을 찾곤 했었다. 매번 디자인이 아쉽고 템플릿을 사용하여도 직접 CSS를 작업하는 경우가 많았는데 지인의 추천으로 Metronic을 알게 되었다. Metronic - Responsive Admin Dashboard Template The World’s #1 Bootstrap 4 HTML, Angular 9, React, VueJS &amp; Laravel Admin Dashboard Theme 이 템플릿은 사용하기도 편하고 디자인도 요즘 트렌드에 맞게 계속 업데이트를 하고 있다. 알아둘 점은 유료다. 구매비용이 저렴한 것에 비해 다양한 컴포넌트들이 있고 10가지 이상의 템플릿을 제공해 준다. 한 마디로 가성비가 최고다. React, Angular, Vue에서 사용 가능하며 업데이트될 때마다 바로 적용되는 점이 매우 좋다. 이 템플릿을 쓰려면 구조와 사용법을 공부를 해야 하는 시간이 조금 소요되지만 커스텀하기가 편해서 자주 사용하고 있다. 물론 직접 프론트엔드를 개발하면서 하면 좋지만 편리하고 빠르게 개발하기 위해 템플릿들을 써서 개발하는 것도 좋은 것 같다. 단점이라면 포함된 기능들이 많아 초기에 로드할 때 느리다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"}]}],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"},{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"},{"name":"WinUI","slug":"Programming/Frontend/WinUI","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WinUI/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"},{"name":"ETC","slug":"ETC","permalink":"http://hgko1207.github.io/categories/ETC/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"},{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"원격회의","slug":"원격회의","permalink":"http://hgko1207.github.io/tags/%EC%9B%90%EA%B2%A9%ED%9A%8C%EC%9D%98/"},{"name":"회의도우미","slug":"회의도우미","permalink":"http://hgko1207.github.io/tags/%ED%9A%8C%EC%9D%98%EB%8F%84%EC%9A%B0%EB%AF%B8/"},{"name":"AI Meeting Assistant","slug":"AI-Meeting-Assistant","permalink":"http://hgko1207.github.io/tags/AI-Meeting-Assistant/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","permalink":"http://hgko1207.github.io/tags/Pandas/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"콘텐츠","slug":"콘텐츠","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"DevOps","slug":"DevOps","permalink":"http://hgko1207.github.io/tags/DevOps/"},{"name":"Software Development","slug":"Software-Development","permalink":"http://hgko1207.github.io/tags/Software-Development/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"String","slug":"String","permalink":"http://hgko1207.github.io/tags/String/"},{"name":"string","slug":"string","permalink":"http://hgko1207.github.io/tags/string/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Vue 2","slug":"Vue-2","permalink":"http://hgko1207.github.io/tags/Vue-2/"},{"name":"Vue 3","slug":"Vue-3","permalink":"http://hgko1207.github.io/tags/Vue-3/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"WinUI","slug":"WinUI","permalink":"http://hgko1207.github.io/tags/WinUI/"},{"name":"WinForms","slug":"WinForms","permalink":"http://hgko1207.github.io/tags/WinForms/"},{"name":"UWP","slug":"UWP","permalink":"http://hgko1207.github.io/tags/UWP/"},{"name":"MFC","slug":"MFC","permalink":"http://hgko1207.github.io/tags/MFC/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"예측분석","slug":"예측분석","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EC%B8%A1%EB%B6%84%EC%84%9D/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"암호화폐","slug":"암호화폐","permalink":"http://hgko1207.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"XML","slug":"XML","permalink":"http://hgko1207.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://hgko1207.github.io/tags/JSON/"},{"name":"AJAX","slug":"AJAX","permalink":"http://hgko1207.github.io/tags/AJAX/"},{"name":"디코딩","slug":"디코딩","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%BD%94%EB%94%A9/"},{"name":"ML","slug":"ML","permalink":"http://hgko1207.github.io/tags/ML/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hgko1207.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://hgko1207.github.io/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"Generative Ai Tools","slug":"Generative-Ai-Tools","permalink":"http://hgko1207.github.io/tags/Generative-Ai-Tools/"},{"name":"이미지 생성기","slug":"이미지-생성기","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%83%9D%EC%84%B1%EA%B8%B0/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"거절","slug":"거절","permalink":"http://hgko1207.github.io/tags/%EA%B1%B0%EC%A0%88/"},{"name":"좌절","slug":"좌절","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%EC%A0%88/"},{"name":"성공","slug":"성공","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EA%B3%B5/"},{"name":"긍정적인 생각","slug":"긍정적인-생각","permalink":"http://hgko1207.github.io/tags/%EA%B8%8D%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%9D%EA%B0%81/"},{"name":"Motivation","slug":"Motivation","permalink":"http://hgko1207.github.io/tags/Motivation/"},{"name":"동기부여","slug":"동기부여","permalink":"http://hgko1207.github.io/tags/%EB%8F%99%EA%B8%B0%EB%B6%80%EC%97%AC/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"열정","slug":"열정","permalink":"http://hgko1207.github.io/tags/%EC%97%B4%EC%A0%95/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"},{"name":"MVC","slug":"MVC","permalink":"http://hgko1207.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://hgko1207.github.io/tags/MVP/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"},{"name":"Generative AI","slug":"Generative-AI","permalink":"http://hgko1207.github.io/tags/Generative-AI/"},{"name":"생성형 AI","slug":"생성형-AI","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%84%B1%ED%98%95-AI/"},{"name":"대화형 AI","slug":"대화형-AI","permalink":"http://hgko1207.github.io/tags/%EB%8C%80%ED%99%94%ED%98%95-AI/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"다중 장치","slug":"다중-장치","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%EC%A4%91-%EC%9E%A5%EC%B9%98/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://hgko1207.github.io/tags/Flexbox/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"반응형 웹","slug":"반응형-웹","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/"},{"name":"아이디어","slug":"아이디어","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4/"},{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"Angularjs","slug":"Angularjs","permalink":"http://hgko1207.github.io/tags/Angularjs/"},{"name":"차세대 웹 앱","slug":"차세대-웹-앱","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%84%B8%EB%8C%80-%EC%9B%B9-%EC%95%B1/"},{"name":"버전 관리","slug":"버전-관리","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"코드 관리","slug":"코드-관리","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%93%9C-%EA%B4%80%EB%A6%AC/"},{"name":"공동 개발","slug":"공동-개발","permalink":"http://hgko1207.github.io/tags/%EA%B3%B5%EB%8F%99-%EA%B0%9C%EB%B0%9C/"},{"name":"작업 흐름","slug":"작업-흐름","permalink":"http://hgko1207.github.io/tags/%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84/"},{"name":"VCS","slug":"VCS","permalink":"http://hgko1207.github.io/tags/VCS/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"기본","slug":"기본","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Angular CLI","slug":"Angular-CLI","permalink":"http://hgko1207.github.io/tags/Angular-CLI/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://hgko1207.github.io/tags/Visual-Studio-Code/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://hgko1207.github.io/tags/VS-Code/"},{"name":"편집기","slug":"편집기","permalink":"http://hgko1207.github.io/tags/%ED%8E%B8%EC%A7%91%EA%B8%B0/"},{"name":"ChangeDetectorRef","slug":"ChangeDetectorRef","permalink":"http://hgko1207.github.io/tags/ChangeDetectorRef/"},{"name":"변경감지","slug":"변경감지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80/"},{"name":"Pipe","slug":"Pipe","permalink":"http://hgko1207.github.io/tags/Pipe/"},{"name":"파이프","slug":"파이프","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84/"},{"name":"ViewRef","slug":"ViewRef","permalink":"http://hgko1207.github.io/tags/ViewRef/"},{"name":"뷰","slug":"뷰","permalink":"http://hgko1207.github.io/tags/%EB%B7%B0/"},{"name":"캡슐화","slug":"캡슐화","permalink":"http://hgko1207.github.io/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"ViewEncapsulation","slug":"ViewEncapsulation","permalink":"http://hgko1207.github.io/tags/ViewEncapsulation/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"http://hgko1207.github.io/tags/Lifecycle/"},{"name":"생명주기","slug":"생명주기","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"},{"name":"Hook","slug":"Hook","permalink":"http://hgko1207.github.io/tags/Hook/"},{"name":"훅","slug":"훅","permalink":"http://hgko1207.github.io/tags/%ED%9B%85/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"스레드","slug":"스레드","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Express","slug":"Express","permalink":"http://hgko1207.github.io/tags/Express/"},{"name":"웹 크롤러","slug":"웹-크롤러","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC/"},{"name":"Cheerio","slug":"Cheerio","permalink":"http://hgko1207.github.io/tags/Cheerio/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"},{"name":"Tree Shaking","slug":"Tree-Shaking","permalink":"http://hgko1207.github.io/tags/Tree-Shaking/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"트리 쉐이킹","slug":"트리-쉐이킹","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9/"},{"name":"Zone.js","slug":"Zone-js","permalink":"http://hgko1207.github.io/tags/Zone-js/"},{"name":"성능향상","slug":"성능향상","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://hgko1207.github.io/tags/RabbitMQ/"},{"name":"메시지","slug":"메시지","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%8B%9C%EC%A7%80/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"},{"name":"OAuth","slug":"OAuth","permalink":"http://hgko1207.github.io/tags/OAuth/"},{"name":"JWT","slug":"JWT","permalink":"http://hgko1207.github.io/tags/JWT/"},{"name":"인증","slug":"인증","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"보안","slug":"보안","permalink":"http://hgko1207.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"},{"name":"Amazon Web Services","slug":"Amazon-Web-Services","permalink":"http://hgko1207.github.io/tags/Amazon-Web-Services/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"Git 명령","slug":"Git-명령","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9/"},{"name":"버전 제어","slug":"버전-제어","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EC%A0%9C%EC%96%B4/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"소프트웨어","slug":"소프트웨어","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"},{"name":"HTTP","slug":"HTTP","permalink":"http://hgko1207.github.io/tags/HTTP/"},{"name":"POST","slug":"POST","permalink":"http://hgko1207.github.io/tags/POST/"},{"name":"GET","slug":"GET","permalink":"http://hgko1207.github.io/tags/GET/"},{"name":"Https","slug":"Https","permalink":"http://hgko1207.github.io/tags/Https/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"Package","slug":"Package","permalink":"http://hgko1207.github.io/tags/Package/"},{"name":"Creating","slug":"Creating","permalink":"http://hgko1207.github.io/tags/Creating/"},{"name":"Publishing","slug":"Publishing","permalink":"http://hgko1207.github.io/tags/Publishing/"},{"name":"Script","slug":"Script","permalink":"http://hgko1207.github.io/tags/Script/"},{"name":"Workflow","slug":"Workflow","permalink":"http://hgko1207.github.io/tags/Workflow/"},{"name":"사용자 정의 스트립트","slug":"사용자-정의-스트립트","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8/"},{"name":"워크플로우 자동화","slug":"워크플로우-자동화","permalink":"http://hgko1207.github.io/tags/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9E%90%EB%8F%99%ED%99%94/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"Array","slug":"Array","permalink":"http://hgko1207.github.io/tags/Array/"},{"name":"Array Methods","slug":"Array-Methods","permalink":"http://hgko1207.github.io/tags/Array-Methods/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"},{"name":"Handling","slug":"Handling","permalink":"http://hgko1207.github.io/tags/Handling/"},{"name":"오류처리","slug":"오류처리","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"},{"name":"callback","slug":"callback","permalink":"http://hgko1207.github.io/tags/callback/"},{"name":"Promise","slug":"Promise","permalink":"http://hgko1207.github.io/tags/Promise/"},{"name":"Async/Await","slug":"Async-Await","permalink":"http://hgko1207.github.io/tags/Async-Await/"},{"name":"콜백","slug":"콜백","permalink":"http://hgko1207.github.io/tags/%EC%BD%9C%EB%B0%B1/"},{"name":"multithreading","slug":"multithreading","permalink":"http://hgko1207.github.io/tags/multithreading/"},{"name":"Thread","slug":"Thread","permalink":"http://hgko1207.github.io/tags/Thread/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"애니메이션","slug":"애니메이션","permalink":"http://hgko1207.github.io/tags/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/"},{"name":"Performance","slug":"Performance","permalink":"http://hgko1207.github.io/tags/Performance/"},{"name":"콘솔","slug":"콘솔","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%EC%86%94/"},{"name":"백그라운드","slug":"백그라운드","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C/"},{"name":"백그라운드 실행","slug":"백그라운드-실행","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"jar 파일","slug":"jar-파일","permalink":"http://hgko1207.github.io/tags/jar-%ED%8C%8C%EC%9D%BC/"},{"name":"Captcha","slug":"Captcha","permalink":"http://hgko1207.github.io/tags/Captcha/"},{"name":"SimpleCptcha","slug":"SimpleCptcha","permalink":"http://hgko1207.github.io/tags/SimpleCptcha/"},{"name":"자동가입방지문자","slug":"자동가입방지문자","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%8F%99%EA%B0%80%EC%9E%85%EB%B0%A9%EC%A7%80%EB%AC%B8%EC%9E%90/"},{"name":"DI","slug":"DI","permalink":"http://hgko1207.github.io/tags/DI/"},{"name":"의존성","slug":"의존성","permalink":"http://hgko1207.github.io/tags/%EC%9D%98%EC%A1%B4%EC%84%B1/"},{"name":"수명","slug":"수명","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EB%AA%85/"},{"name":"lifetime","slug":"lifetime","permalink":"http://hgko1207.github.io/tags/lifetime/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"지도","slug":"지도","permalink":"http://hgko1207.github.io/tags/%EC%A7%80%EB%8F%84/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"},{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"},{"name":"node-gyp","slug":"node-gyp","permalink":"http://hgko1207.github.io/tags/node-gyp/"},{"name":"Framer Motion","slug":"Framer-Motion","permalink":"http://hgko1207.github.io/tags/Framer-Motion/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"},{"name":"Drag","slug":"Drag","permalink":"http://hgko1207.github.io/tags/Drag/"},{"name":"Drop","slug":"Drop","permalink":"http://hgko1207.github.io/tags/Drop/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"},{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"},{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"},{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"},{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"},{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"외부접속허용","slug":"외부접속허용","permalink":"http://hgko1207.github.io/tags/%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D%ED%97%88%EC%9A%A9/"},{"name":"Event","slug":"Event","permalink":"http://hgko1207.github.io/tags/Event/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"},{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"},{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"Cesium","slug":"Cesium","permalink":"http://hgko1207.github.io/tags/Cesium/"},{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"},{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Daum 우편번호","slug":"Daum-우편번호","permalink":"http://hgko1207.github.io/tags/Daum-%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"},{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"}]}