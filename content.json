{"meta":{"title":"규니의 블로그","subtitle":"hgko's IT Blog","description":"Information related to IT","author":"Hyeong Gyun Ko","url":"http://hgko1207.github.io","root":"/"},"pages":[{"title":"About","date":"2019-01-07T08:59:42.000Z","updated":"2023-04-25T01:49:09.423Z","comments":true,"path":"about/index.html","permalink":"http://hgko1207.github.io/about/index.html","excerpt":"","text":"안녕하세요. 블로그를 시작한지 얼마 안 된 새내기입니다. 이전에는 네이버 블로그에 조금씩 업로드를 하였었는데, Github 에 연동된 블로그가 있어 시작하게 되었습니다. 개발 경력은 쌓이는데 개발에 대한 내용을 기록한 적이 많이 없어 이번 계기로 열심히 기록해보려고 합니다. 컴퓨터공학과 학사 졸업 정보통신공학과 석사 졸업 현재 프리렌서 취미 축구 자전거 수영 게임 관심사 블로그 자격증 육아"},{"title":"Profile","date":"2020-07-29T00:52:04.000Z","updated":"2023-07-21T14:20:02.504Z","comments":true,"path":"profile/index.html","permalink":"http://hgko1207.github.io/profile/index.html","excerpt":"","text":"보유기술 Programming Laguage Java, JavaScript, TypeScript, HTML5, CSS Python, Dart C#, C++ Framework / Library Spring Framework, Spring Boot, JPA, Querydsl NodeJS, React, Next.js, Angular React Native, Android, WPF Bootstrap, JQuery Server MySQL, MSSQL, PostgreSQL, Oracle, Elasticsearch Docker, Nginx, Tomcat Kafka, Zookeeper Tooling / DevOps GitHub, GitLab, SVN Gradle, maven Jenkins, Travis CI Environment Windows, Linux, AWS 관심분야 Vue.js Go AI Contact GitHub : https://github.com/hgko1207 E-Mail : khkkhk1207@gmail.com 블로그 : https://hgko-dev.tistory.com/"}],"posts":[{"title":"문서용 VScode 확장 프로그램","slug":"info-16","date":"2024-06-21T04:46:11.000Z","updated":"2024-06-21T04:58:45.404Z","comments":true,"path":"2024/06/21/info-16/","link":"","permalink":"http://hgko1207.github.io/2024/06/21/info-16/","excerpt":"","text":"일반적으로 문서는 데이터(과학, 엔지니어링, 시각화 등), 엔지니어링 또는 소프트웨어 관련 프로젝트의 라스트 마일(Last Mile)입니다. 여기에는 라이브러리 문서, README 파일, 튜토리얼 등의 문서 작성 및 편집이 포함됩니다. 제가 VScode를 좋아하는 이유 중 하나는 놀라운 확장 프로그램 생태계, 특히 문서 작성, 편집, 작업을 위한 확장 프로그램입니다. 이 글에서는 VScode에서 제가 가장 좋아하는 문서 확장 프로그램을 살펴봅니다. Quarto Quarto는 R, Python, Julia 및 Observable에서 과학 문서를 작성하기 위한 놀라운 에코시스템입니다. 기사, 프레젠테이션, 대시보드, 웹사이트, 블로그, 책 등 다양한 유형의 문서를 HTML, PDF, MS Word, ePub 등으로 작성하고 편집할 수 있습니다. VScode의 Quarto extension 프로그램을 사용하면 qmd 파일을 원활하게 편집하고 렌더링할 수 있습니다. 문서 코드를 편집하고 결과물을 나란히 미리 볼 수 있는 미리보기 모드가 함께 제공됩니다. Jupyter Jupyter는 주로 파이썬에서 노트북을 만드는 데 가장 많이 사용되는 프레임워크 중 하나입니다. 마크다운과 파이썬 코드를 멋지게 렌더링해주고 GitHub에서 이를 지원하기 때문에 파이썬 코드의 프로토타입을 만들 때나 파이썬 튜토리얼의 보조 문서로 Jupyter를 사용합니다. 또한 최근에는 Python용 Quarto 문서에도 사용하기 시작했습니다. VScode Jupyter 확장 프로그램은 VScode 편집기 내에 Jupyter 노트북을 통합하여 ipynb 파일을 지원합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Coding Tips","slug":"Coding-Tips","permalink":"http://hgko1207.github.io/tags/Coding-Tips/"},{"name":"Programming Tips","slug":"Programming-Tips","permalink":"http://hgko1207.github.io/tags/Programming-Tips/"}]},{"title":"자바스크립트 배열 함수 10가지","slug":"js-dev-23","date":"2024-06-21T01:54:27.000Z","updated":"2024-06-21T02:21:12.787Z","comments":true,"path":"2024/06/21/js-dev-23/","link":"","permalink":"http://hgko1207.github.io/2024/06/21/js-dev-23/","excerpt":"","text":"여러분이 복잡한 웹 개발 프로젝트를 진행 중이라고 가정해 봅시다. 여러 API에서 들어오는 데이터를 효율적으로 처리, 필터링, 분석하는 것이 여러분의 임무입니다. 일정이 촉박하기 때문에 모든 코드 줄이 중요합니다. 이럴 때 고급 자바스크립트 배열 메서드를 배우면 큰 도움이 됩니다. 이러한 함수는 코드를 줄일 뿐만 아니라 성능을 개선하고 개발 기술을 향상시킵니다. 복잡한 작업을 빠르고 정확하게 수행하기 위해 모든 시니어 개발자가 알아두어야 할 10가지 배열 함수를 살펴보세요. 1. forEach() forEach() 함수는 배열의 각 항목을 돌면서 설정한 작업을 완료합니다. 이 함수는 각 요소에서 실행되는 콜백 함수를 취하므로 로깅, DOM 수정 및 데이터 조작과 같은 기능에 유용합니다. 1234// 배열의 모든 요소를 로깅합니다.const fruits = [\"apple\", \"banana\", \"cherry\"];fruits.forEach(fruit =&gt; console.log(fruit)); 2. map() 현재 배열을 기반으로 하지만 약간 변형된 완전히 새로운 배열이 필요하신가요? map()은 각 요소에 콜백 함수를 적용한 결과로 새로운 배열을 생성합니다. 데이터 집합을 추출하고, 데이터를 제공하고, 계산을 수행하는 데 적합합니다. 1234567// 배열의 각 숫자를 두 배로 늘리기const numbers = [1, 2, 3, 4];const doubledNumbers = numbers.map(number =&gt; number * 2);console.log(doubledNumbers);// Output [2, 4, 6, 8] 3. filter() filter()는 콜백 함수 기반 테스트를 통과한 항목만 포함하는 새 배열을 만듭니다. 이 함수를 사용하여 기준을 사용하여 데이터를 필터링하거나, 원하지 않는 항목을 제거하거나, 사용자 정의 하위 집합을 만들 수 있습니다. 1234567// 배열에서 짝수 가져오기const numbers = [1, 2, 3, 4, 5];const evenNumbers = numbers.filter(number =&gt; number % 2 === 0);console.log(evenNumbers); // Output [2, 4] 4. reduce() reduce()는 콜백 함수를 사용하여 전체 배열을 단일 값으로 통합하는 함수입니다. 매우 유연하여 합계와 평균을 계산하고, 최대값과 최소값을 찾고, 복잡한 데이터 구조를 만들 수도 있습니다. 1234567// 배열의 합계 찾기const numbers = [1, 2, 3, 4];const sum = numbers.reduce((accumulator, current) =&gt; accumulator + current, 0);console.log(sum); // Output: 10 5. find() 주어진 조건에 맞는 첫 번째 부분을 찾아야 할 때 find()가 구세주입니다. 콜백 함수에 의해 주어진 테스트를 통과한 첫 번째 부분의 값을 반환하므로 빠른 조회와 전체 배열 루프 제거에 유용합니다. 1234567// 3보다 큰 첫 번째 요소 찾기const numbers = [1, 2, 4, 5];const firstGreaterThanThree = numbers.find(number =&gt; number &gt; 3);console.log(firstGreaterThanThree);// Output: 4 6. findIndex() findIndex()는 find()보다 한 단계 더 나아가 콜백 테스트를 통과한 첫 번째 요소의 인덱스를 반환합니다. 배열 내에서 특정 데이터를 찾고, 배열 내 위치에 따라 항목을 변경하고, 집중된 작업을 수행할 때 유용합니다. 1234567// 3보다 큰 첫 번째 요소의 인덱스 찾기const numbers = [1, 2, 4, 5];const indexOfFirstGreaterThanThree = numbers.findIndex(number =&gt; number &gt; 3);console.log(indexOfFirstGreaterThanThree);// Output: 2 7. some() 배열에 특정 조건을 충족하는 항목이 하나 이상 포함되어 있는지 알아보고 싶었던 적이 있나요? some()가 도움이 될 것입니다. 이 함수는 콜백 함수에 의해 수행된 테스트를 통과한 요소가 하나 이상 있는지 확인합니다. 일치하는 요소가 하나면 충분할 때 조건을 확인하거나 입력의 유효성을 검사하거나 짧은 로직을 작성할 때 이 함수를 사용할 수 있습니다. 1234567// 배열의 요소가 10보다 큰지 확인합니다.const numbers = [1, 5, 8, 12];const hasElementGreaterThanTen = numbers.some(number =&gt; number &gt; 10);console.log(hasElementGreaterThanTen);// Output: true 8. every() every()는 some()의 엄격한 형입니다. 이 함수는 배열의 모든 항목이 콜백 함수에 의해 주어진 테스트를 통과하도록 보장합니다. 이는 데이터 유효성 검사, 지정된 구조에 따른 모든 요소 확인, 품질 검사에 유용합니다. 1234567// 배열의 모든 요소가 문자열인지 확인하기const data = [\"apple\", \"banana\", 10];const allStrings = data.every(element =&gt; typeof element === \"string\");console.log(allStrings);// Output: false 9. include() 배열에 특정 값이 존재하는지 알고 싶을 때가 있습니다. include()는 간단한 유효성 검사를 위한 가장 좋은 친구입니다. 주어진 값이 배열에 존재하는지 빠르게 확인하므로 개별 데이터 요소를 식별하거나 배열 멤버십에 따라 조건부 논리를 만들 때 중요합니다. 1234567// 배열에 \"orange\" 값이 포함되어 있는지 확인합니다.const fruits = [\"apple\", \"banana\", \"cherry\"];const hasOrange = fruits.includes(\"orange\");console.log(hasOrange);// Output: false 10. flat() 다차원 배열이나 배열 내부의 배열을 본 적이 있나요? 지저분할 수 있습니다. flat()은 이를 1차원 배열로 변환하여 도움을 줍니다. 중첩 배열을 단순화하고, 중첩 구조가 있을 수 있는 API의 데이터로 작업하고, 추가 처리를 위해 데이터를 저장할 때 유용합니다. 1234567// 중첩 배열 평탄화하기const nestedArray = [1, [2, 3], 4];const flattenedArray = nestedArray.flat();console.log(flattenedArray);// 출력: [1, 2, 3, 4] 보너스 팁: 평탄화 및 변환을 더 잘 제어하려면 최근에 자바스크립트에 추가된 또 다른 함수인 flatMap()을 사용하는 것도 고려해 보세요. 몇 가지 전술 이제 기본 사항을 배웠으니 배열 학습을 강화할 수 있는 몇 가지 고급 주제를 살펴봅시다. 배열 메서드 체인 연결하기 여러 배열 메서드를 서로 연결하여 복잡한 변경 사항을 명확하고 쉽게 이해할 수 있도록 만들 수 있습니다. 예를 들어 배열에서 짝수를 필터링한 다음 사각형 면적을 구할 수 있습니다. 1234567const numbers = [1, 2, 3, 4, 5];const evenSquares = numbers.filter(number =&gt; number % 2 === 0) .map(number =&gt; number * number);console.log(evenSquares);// Output: [4, 16] 사용자 정의 콜백 함수 많은 배열 함수가 콜백 함수에 의존한다는 것을 기억하세요. 강력하고 잘 정의된 콜백을 만들어 극단적인 상황을 처리하고, 예상 데이터 타입을 명시하여 타입 안전성을 보장하며, 코드 유지보수성을 높이세요. 예를 들어 숫자가 짝수인지 확인하기 위한 잘 정의된 콜백은 다음과 같습니다. 123456function isEven(number) &#123; if (typeof number !== 'number') &#123; throw new TypeError('Input must be a number'); &#125; return number % 2 === 0;&#125; 오류 처리 예기치 않은 데이터나 누락된 조각으로 인해 오류가 발생할 수 있습니다. 예기치 않은 동작을 피하기 위해 배열 함수 내에서 발생할 수 있는 실수를 처리하는 방법에 대해 논의하세요. 예외를 우아하게 처리하려면 try-catch 컴포넌트를 사용할 수 있습니다. 12345678910const numbers = [1, \"two\", 3];try &#123; const doubledNumbers = numbers.map(number =&gt; number * 2); console.log(doubledNumbers); // [2, NaN, 6] (Error for \"two\")&#125; catch (error) &#123; console.log(error);&#125; 성능 고려 사항 모든 배열 메서드가 똑같이 만들어지는 것은 아닙니다. 크기가 크거나 복잡한 배열의 성능 영향(예: forEach와 for loop)에 대해 간략히 설명합니다. 메모리: 데이터가 많으면 시스템에 과부하가 걸릴 수 있습니다. 루프: 큰 배열에 액세스하는 데 시간이 걸립니다. 복잡한 요소: 배열의 복잡한 데이터를 처리하는 속도가 현저히 느립니다. 정말 큰 데이터 집합의 경우, 특히 배열 함수 구현이 최적화되지 않은 구형 브라우저에서는 기존 루프를 사용하여 효율성을 개선하세요. 함수형 프로그래밍 배열 함수는 함수형 프로그래밍 접근 방식에 잘 적응합니다. 함수형 프로그래밍은 순수 함수(부작용이 없는)와 변경할 수 없는 데이터 작업에 중점을 둡니다. 배열 메서드를 사용하여 기존 배열에서 새 배열을 구축하면 원본 데이터를 유효하게 유지하고 예측 가능성을 높이며 디버깅을 더 쉽게 할 수 있습니다. 모범 사례 함수 결합: 앞서 언급했듯이 여러 작업을 연결하면 빠르고 강력한 작업에 도움이 됩니다. 한 줄에 복잡한 변경 사항을 만들기 위해 실험하고 혼합하는 것을 두려워하지 마세요. 불변성: 가능하면 기존 배열을 변경하는 대신 새 배열을 만들어 보세요. 이렇게 하면 가독성이 향상되고 원치 않는 효과가 발생할 위험이 줄어듭니다 map, filter, slice 등의 방법을 사용하여 새 배열을 만드세요. 오류 처리: 콜백 습관에 항상 작업 오류 처리를 사용하여 이상한 입력이나 누락된 항목을 포착하세요. 이렇게 하면 오류로 인한 프로그램 결합 및 충돌을 방지할 수 있습니다. 결론 이 10가지 배열 메서드를 익히면 자바스크립트 초보자도 어느 정도 수준에 도달할 수 있습니다. 더 이해하기 쉽고 효율적이며 유연한 코드를 작성할 수 있게 되어 데이터 작업을 더 수월하게 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Javascript Development","slug":"Javascript-Development","permalink":"http://hgko1207.github.io/tags/Javascript-Development/"},{"name":"Javascript Tips","slug":"Javascript-Tips","permalink":"http://hgko1207.github.io/tags/Javascript-Tips/"}]},{"title":"WPF(Windows Presentation Foundation) 이해하기","slug":"wpf-3","date":"2024-06-20T13:19:56.000Z","updated":"2024-06-20T13:29:58.247Z","comments":true,"path":"2024/06/20/wpf-3/","link":"","permalink":"http://hgko1207.github.io/2024/06/20/wpf-3/","excerpt":"","text":"소개 데스크톱 응용 프로그램 개발 영역에서 WPF(Windows Presentation Foundation)는 개발자에게 시각적으로 멋지고 기능이 풍부한 응용 프로그램을 구축할 수 있는 강력한 프레임워크를 제공하는 초석 기술입니다. 이 글에서는 WPF의 정의, 주요 기능 및 이점에 대해 자세히 알아보고 최신 소프트웨어 개발에서 WPF가 계속 중요한 이유를 살펴봅니다. WPF 란? WPF(Windows Presentation Foundation)는 Windows에서 데스크톱 애플리케이션을 빌드하기 위해 Microsoft에서 개발한 UI 프레임워크입니다. 2006년에 .NET Framework 3.0의 일부로 처음 소개되었으며 이후 발전하여 Windows 에코시스템의 필수적인 부분이 되었습니다. 개발자는 WPF를 사용하여 시각적으로 매력적이고 대화형이며 멀티미디어가 풍부한 사용자 인터페이스를 만들 수 있는 선언적 마크업 언어인 XAML(eXtensible Application Markup Language)과 C# 또는 VB.NET의 강력한 기능을 결합할 수 있습니다. WPF의 주요 기능 XAML(eXtensible Application Markup Language): WPF는 XAML을 사용하여 UI 디자인과 비즈니스 로직을 분리하여 디자이너와 개발자가 효과적으로 협업할 수 있도록 합니다. 데이터 바인딩: WPF는 강력한 데이터 바인딩 기능을 지원하여 기본 데이터가 변경되면 UI 요소를 자동으로 업데이트할 수 있습니다. 스타일 및 템플릿: 개발자는 스타일과 템플릿을 정의하여 애플리케이션 전체에서 컨트롤의 모양과 동작을 사용자 지정하여 일관성과 유지 관리성을 높일 수 있습니다. Rich 미디어 지원: WPF는 오디오, 비디오 및 벡터 그래픽을 포함한 멀티미디어 콘텐츠와 원활하게 통합되어 몰입감 있는 사용자 환경을 만들 수 있습니다. 레이아웃 유연성: WPF의 레이아웃 시스템은 매우 유연하여 다양한 레이아웃 패널(Grid, StackPanel, DockPanel 등)을 지원하여 UI 요소를 동적으로 배열할 수 있습니다. 애니메이션 및 효과: WPF는 애니메이션과 효과를 강력하게 지원하므로 개발자는 유동적인 전환과 시각적 향상을 만들 수 있습니다. WPF 사용의 이점 모던한 스타일: WPF 애플리케이션은 사용자 지정 가능한 테마와 스타일로 모던하고 세련된 외관을 구현할 수 있습니다. 생산성: XAML 및 데이터 바인딩을 사용하면 개발자는 애플리케이션 로직에 집중하고 디자이너는 UI를 처리하는 등 보다 효율적으로 작업할 수 있습니다. 성능: WPF는 하드웨어 가속 및 GPU 렌더링을 활용하므로 복잡한 애플리케이션에서도 부드러운 UI 응답성을 제공합니다. 상호 운용성: WPF 애플리케이션은 다른 .NET 기술 및 Windows API와 원활하게 통합되어 상호 운용성을 향상하고 기능을 확장할 수 있습니다. 예제 및 사용 사례 엔터프라이즈 애플리케이션: WPF는 견고함과 확장성으로 인해 CRM 시스템, ERP 솔루션 및 재무 도구와 같은 엔터프라이즈급 애플리케이션을 구축하는 데 널리 사용됩니다. 미디어 및 엔터테인먼트: 비디오 편집 소프트웨어 및 디지털 사이니지 솔루션과 같이 Rich 미디어 기능이 필요한 애플리케이션은 WPF의 멀티미디어 지원의 이점을 누릴 수 있습니다. 데이터 시각화: WPF의 강력한 데이터 바인딩 및 사용자 지정 가능한 UI 요소는 대시보드 및 보고 도구와 같은 데이터 집약적인 애플리케이션을 만드는 데 이상적입니다. 결론 WPF(Windows Presentation Foundation)은 개발자에게 정교하고 시각적으로 매력적인 애플리케이션을 만들 수 있는 다목적 프레임워크를 제공하는 데스크톱 애플리케이션 개발의 핵심 기술입니다. 풍부한 기능, .NET 에코시스템과의 원활한 통합, 최신 UI 기능을 갖춘 WPF는 개발자가 Windows 플랫폼에서 혁신적이고 영향력 있는 사용자 환경을 제공할 수 있도록 지속적으로 지원하고 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":".NET 개발자","slug":"NET-개발자","permalink":"http://hgko1207.github.io/tags/NET-%EA%B0%9C%EB%B0%9C%EC%9E%90/"}]},{"title":"SCSS 파일 생성 및 설정 방법","slug":"web-18","date":"2024-06-19T13:08:23.000Z","updated":"2024-06-19T13:22:33.986Z","comments":true,"path":"2024/06/19/web-18/","link":"","permalink":"http://hgko1207.github.io/2024/06/19/web-18/","excerpt":"","text":"최신 웹 개발 영역에서 SCSS(Sassy CSS)는 웹사이트를 효율적으로 스타일링할 수 있는 강력한 도구로 부상했습니다. SCSS 파일을 만드는 방법과 이 파일이 제공하는 이점이 궁금하다면 제대로 찾아 오셨습니다. SCSS 파일을 설정하는 과정을 자세히 살펴보고 다양한 이점을 살펴보세요. SCSS란 무엇인가요? CSS(Cascading Style Sheets)의 확장인 SCSS는 변수, 중첩 규칙 및 mixins 같은 프로그래밍 요소를 도입합니다. 이는 일반 CSS로 컴파일되며 개발자가 웹 프로젝트의 스타일링 코드를 작성하고 관리하는 방식을 간소화합니다. SCSS 파일 생성을 위한 단계별 가이드 1. 전처리기를 설치합니다 SCSS 파일을 만들기 전에 Sass와 같은 전처리기가 설치되어 있는지 확인하세요. Sass는 다음 명령을 사용하여 npm(Node Package Manager)을 통해 설치할 수 있습니다 1npm install -g sass 이 명령은 시스템에 Sass를 전역적으로 설치합니다. 2. 프로젝트 구조를 설정합니다 프로젝트 디렉토리를 정리합니다. 일반적으로 SCSS 파일은 프로젝트 내 styles 또는 scss 디렉터리에 저장됩니다. 3. SCSS 파일 만들기 선호하는 텍스트 편집기를 사용하여 확장자가 .scss인 새 파일을 만듭니다. 예를 들어 styles.scss라는 파일을 만들 수 있습니다. 4. SCSS 코드 작성 styles.scss 파일에 SCSS 코드 작성을 시작합니다. 다음은 기본 예시입니다. 12345678910111213141516// styles.scss$primary-color: #3498db;body &#123; font-family: Arial, sans-serif; background-color: #f0f0f0;&#125;.header &#123; background-color: $primary-color; color: white; padding: 10px;&#125;// More SCSS code here... 5. SCSS를 CSS로 컴파일합니다 SCSS 코드를 작성했으면 Sass 컴파일러를 사용하여 일반 CSS로 컴파일하세요. 명령줄을 통해 이 작업을 수행할 수 있습니다. 1sass styles.scss styles.css 이 명령은 styles.scss를 styles.css로 컴파일하여 웹사이트에서 사용할 수 있습니다. 6. 컴파일된 CSS를 HTML에 링크합니다 마지막으로 컴파일된 styles.css 파일을 HTML &lt;head&gt; 섹션에 링크합니다. 1&lt;link rel=\"stylesheet\" href=\"styles.css\" /&gt; SCSS 사용의 이점 1. 변수 및 재사용성 SCSS를 사용하면 색상, 글꼴, 크기 등에 대한 변수를 정의할 수 있으므로 웹사이트 전체에서 일관성을 쉽게 유지할 수 있습니다. 예를 들어, $primary-color: #3498db; 를 정의하고 스타일시트 전체에 사용할 수 있습니다. 2. 중첩 구문(Nested Syntax) SCSS는 중첩 구문을 지원하여 반복을 줄이고 가독성을 향상시킵니다. .header { } .header h1 { }을 작성하는 대신 선택기를 직접 중첩할 수 있습니다 123456.header &#123; h1 &#123; font-size: 24px; color: $primary-color; &#125;&#125; 3. Mixins 및 함수 SCSS를 사용하면 Mixins 및 함수를 사용하여 재사용 가능한 스타일을 만들어 모듈성을 높이고 코드 중복을 줄일 수 있습니다. 4. Importing SCSS를 사용하면 스타일을 더 작고 관리하기 쉬운 파일로 구성하고 @import를 사용하여 기본 SCSS 파일로 가져올 수 있습니다. 5. 커뮤니티 및 도구 SCSS는 대규모 커뮤니티와 Webpack과 같은 빌드 도구 및 Gulp와 같은 태스크 러너와의 통합을 포함한 뛰어난 도구 지원을 통해 개발 워크플로우의 효율성을 향상시킵니다. 결론 결론적으로 SCSS 파일을 만들면 CSS 코드베이스의 유지 관리성, 가독성 및 확장성이 향상됩니다. 변수, 중첩 구문, Mixins 등과 같은 SCSS의 기능을 활용하면 웹 개발 프로세스를 간소화하고 더욱 강력하고 유지 관리하기 쉬운 스타일시트를 만들 수 있습니다. 초보자이든 숙련된 개발자이든, 프로젝트에 SCSS를 통합하면 효율성과 코드 품질을 크게 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"SEO","slug":"SEO","permalink":"http://hgko1207.github.io/tags/SEO/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Responsive Design","slug":"Responsive-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Design/"},{"name":"Scss","slug":"Scss","permalink":"http://hgko1207.github.io/tags/Scss/"}]},{"title":"[WPF] KeyBinding 사용하여 단축키 설정하기","slug":"wpf-2","date":"2024-06-18T13:25:49.000Z","updated":"2024-06-18T13:35:25.517Z","comments":true,"path":"2024/06/18/wpf-2/","link":"","permalink":"http://hgko1207.github.io/2024/06/18/wpf-2/","excerpt":"","text":"WPF에서 KeyBinding을 사용하여 Alt+D 키 조합 같은 단축키를 처리하려면 Window.InputBindings에서 KeyBinding을 설정하고 이를 명령에 바인딩할 수 있습니다. 방법은 다음과 같습니다. MainWindow.xaml 1234567891011&lt;Window x:Class=\"WpfApp.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"MainWindow\" Height=\"350\" Width=\"525\"&gt; &lt;Window.InputBindings&gt; &lt;KeyBinding Key=\"D\" Modifiers=\"Alt\" Command=\"&#123;Binding AltDCommand&#125;\" /&gt; &lt;/Window.InputBindings&gt; &lt;Grid&gt; &lt;TextBlock x:Name=\"OutputTextBlock\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" FontSize=\"24\"/&gt; &lt;/Grid&gt;&lt;/Window&gt; MainWindow.xaml.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Windows;using System.Windows.Input;namespace WpfApp&#123; public partial class MainWindow : Window &#123; public ICommand AltDCommand &#123; get; &#125; public MainWindow() &#123; InitializeComponent(); AltDCommand = new RelayCommand(ExecuteAltD); DataContext = this; &#125; private void ExecuteAltD(object parameter) &#123; OutputTextBlock.Text = \"Alt+D was pressed!\"; &#125; &#125; public class RelayCommand : ICommand &#123; private readonly Action&lt;object&gt; execute; private readonly Predicate&lt;object&gt; canExecute; public RelayCommand(Action&lt;object&gt; execute, Predicate&lt;object&gt; canExecute = null) &#123; this.execute = execute ?? throw new ArgumentNullException(nameof(execute)); this.canExecute = canExecute; &#125; public bool CanExecute(object parameter) =&gt; canExecute == null || canExecute(parameter); public void Execute(object parameter) =&gt; execute(parameter); public event EventHandler CanExecuteChanged &#123; add =&gt; CommandManager.RequerySuggested += value; remove =&gt; CommandManager.RequerySuggested -= value; &#125; &#125;&#125; 설명 1. MainWindow.xaml Alt+D에 대한 KeyBinding을 정의하고 이를 AltDCommand에 바인딩합니다. Alt+D를 누를 때 메시지를 표시하기 위해 OutputTextBlock이라는 TextBlock을 포함합니다. 2. MainWindow.xaml.cs RelayCommand를 사용하여 AltDCommand를 정의합니다. ExecuteAltD 메서드는 Alt+D를 누르면 TextBlock 텍스트를 업데이트합니다. 'DataContext’를 현재 인스턴스로 설정하여 바인딩을 활성화합니다. 3. RelayCommand 명령 논리를 처리하기 위해 'ICommand’를 구현합니다. RelayCommand 클래스는 Action&lt;object&gt;를 사용하여 실행하고 선택적 Predicate&lt;object&gt;를 사용하여 명령을 실행할 수 있는지 확인합니다. 결론 이 접근 방식은 WPF의 ‘KeyBinding’ 및 ‘Command’ 인프라를 활용하여 ‘Alt+D’ 키 조합을 처리하고 키 누름에 응답하는 깔끔하고 선언적인 방법을 제공합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":".NET 개발자","slug":"NET-개발자","permalink":"http://hgko1207.github.io/tags/NET-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"KeyBinding","slug":"KeyBinding","permalink":"http://hgko1207.github.io/tags/KeyBinding/"}]},{"title":"웹 개발자를 위한 최고의 브라우저 콘솔 방법: 디버깅, 테스트 등","slug":"web-17","date":"2024-06-14T13:15:25.000Z","updated":"2024-06-17T04:49:23.881Z","comments":true,"path":"2024/06/14/web-17/","link":"","permalink":"http://hgko1207.github.io/2024/06/14/web-17/","excerpt":"","text":"브라우저 콘솔은 웹 개발자에게 필수적인 도구로, 웹 브라우저 내에서 직접 자바스크립트 코드를 디버깅, 테스트 및 실험할 수 있는 강력한 인터페이스를 제공합니다. 웹 개발 초보자이든 숙련된 전문가이든 브라우저 콘솔을 마스터하면 생산성과 효율성을 크게 향상시킬 수 있습니다. 이 글에서는 브라우저 콘솔에서 사용할 수 있는 가장 유용한 몇 가지 방법과 실제 적용 사례를 살펴봅니다. 브라우저 콘솔이란 무엇인가요? 브라우저 콘솔은 Chrome, Firefox, Safari Edge와 같은 최신 웹 브라우저에 있는 기능입니다. 이를 통해 개발자는 웹 페이지의 JavaScript 환경과 상호 작용하고, 오류를 확인하고, 코드 스니펫을 실행하고, 다양한 디버깅 작업을 수행할 수 있습니다. 대부분의 브라우저에서 웹 페이지를 마우스 오른쪽 버튼으로 클릭하고 '검사’를 선택한 다음 ‘Console’ 탭으로 이동하여 콘솔을 열 수 있습니다. 필수 콘솔 메서드 1. console.log() 목적: 콘솔에 메시지를 출력합니다. 사용법: console.log('Hello, World!'); 12let userName = 'hgko';console.log('User Name:', userName); 설명: console.log() 메서드는 메시지와 변수를 표시하는 데 가장 일반적으로 사용되는 함수입니다. 코드의 흐름을 추적하고 값을 검사하는 데 매우 유용합니다. 2. console.error() 목적: 콘솔에 오류 메시지를 출력합니다. 사용법: console.error('This is an error message'); 12345try &#123; throw new Error('Something went wrong!');&#125; catch (e) &#123; console.error(e);&#125; 설명: console.error()를 사용하면 오류 메시지나 예외를 기록하여 코드의 문제를 빠르게 식별하고 해결할 수 있습니다. 3. console.warn() 목적: 경고 메시지를 표시합니다. 사용법: console.warn('This is a warning'); 1234let deprecatedFunction = function () &#123; console.warn('This function is deprecated');&#125;;deprecatedFunction(); 설명: console.warn() 메서드는 향후 주의가 필요할 수 있는 잠재적인 문제나 사용 중단된 코드를 강조 표시하는 데 유용합니다. 4. console.info() 목적: 정보 메시지를 제공합니다. 사용법: console.info('Information message'); 1console.info('The process started at', new Date()); 설명: 경고나 오류보다 덜 중요한 일반 정보 메시지에는 console.info()를 사용합니다. 5. console.table() 목적: 데이터를 테이블로 표시합니다. 사용법: console.table(arrayOrObject); 123456let users = [ &#123; name: 'Alice', age: 25 &#125;, &#123; name: 'Bob', age: 30 &#125;, &#123; name: 'Charlie', age: 35 &#125;,];console.table(users); 설명: console.table() 메서드는 배열이나 객체를 표 형식으로 시각화하여 값을 비교하고 데이터 구조를 쉽게 이해할 수 있도록 하는 데 탁월합니다. 6. console.group() 및 console.groupEnd() 목적: 메시지를 그룹화합니다. 1234console.group('User Details');console.log('Name: Alice');console.log('Age: 25');console.groupEnd(); 설명: 콘솔에서 새 인라인 그룹을 시작하려면 console.group()을 사용합니다. 이후의 모든 콘솔 메시지는 console.groupEnd()가 호출될 때까지 들여쓰기됩니다. 이는 특히 복잡한 디버깅 시나리오에서 관련 메시지를 정리하는 데 도움이 됩니다. 7. console.time() 및 console.timeEnd() 목적: 코드 블록에서 걸린 시간을 측정합니다. 12345console.time('loop');for (let i = 0; i &lt; 100000; i++) &#123; // some code&#125;console.timeEnd('loop'); 설명: 이 메서드는 성능 테스트에 유용합니다. console.time()은 지정된 레이블로 타이머를 시작하고 console.timeEnd()는 타이머를 중지하고 경과된 시간을 기록합니다. 8. console.assert() 목적: 어설션이 거짓인 경우 메시지를 기록합니다. 사용법: console.assert(condition, 'Assertion failed'); 실제 적용 사례 코드 디버깅: 변수 값과 실행 흐름을 기록하여 오류를 식별하고 수정하세요. 성능 테스트: 함수나 코드 블록의 실행 시간을 측정하여 성능을 최적화하세요. 데이터 시각화: console.table()을 사용해 데이터 구조를 명확하게 표시하세요. 로그 정리: 관련 로그를 그룹화하여 가독성과 정리를 개선하세요. 단계별 가이드: 한 웹사이트에서 다른 웹사이트로 데이터베이스 마이그레이션하기 결론 브라우저 콘솔은 웹 개발자를 위한 다재다능하고 강력한 도구입니다. 다양한 방법을 익혀 디버깅 프로세스를 간소화하고 코드에 대한 심층적인 인사이트를 확보하여 궁극적으로 더 효율적인 개발자가 될 수 있습니다. 다음에 웹 프로젝트를 진행할 때는 브라우저 콘솔의 잠재력을 최대한 활용하여 워크플로우를 개선하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Responsive Design","slug":"Responsive-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Design/"},{"name":"Responsive Web Design","slug":"Responsive-Web-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Web-Design/"},{"name":"Responsive Website Design","slug":"Responsive-Website-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Website-Design/"}]},{"title":"React.js 살펴보기: 초보자 가이드","slug":"react-18","date":"2024-06-13T14:33:27.000Z","updated":"2024-06-13T14:44:43.133Z","comments":true,"path":"2024/06/13/react-18/","link":"","permalink":"http://hgko1207.github.io/2024/06/13/react-18/","excerpt":"","text":"웹 개발의 방대한 환경에서 React.js는 사용자 인터페이스 구축 방식을 혁신하는 중추적인 기술로 부상했습니다. 이제 막 웹 개발을 시작했거나 기술을 확장하려는 경우, 최신 웹 개발에서 React.js를 이해하는 것은 매우 중요합니다. React.js가 무엇인지, 그 목적은 무엇인지, 어디서 효과적으로 배울 수 있는지 자세히 알아보세요. React.js란 무엇인가요? 흔히 React라고 부르는 React.js는 Facebook에서 만든 오픈소스 자바스크립트 라이브러리입니다. 단일 페이지 애플리케이션의 사용자 인터페이스(UI)를 구축하기 위해 특별히 설계되었습니다. React의 차별점은 UI 컴포넌트 렌더링에 대한 선언적 접근 방식입니다. 개발자는 DOM을 직접 조작하는 대신 React를 사용하여 자체 상태를 관리하는 재사용 가능한 UI 컴포넌트를 만들 수 있습니다. 이를 통해 복잡한 UI를 재사용 가능한 작은 조각으로 분해하여 더 쉽게 구축할 수 있습니다. React.js의 사용 목적 React.js를 사용하는 주된 목적은 대화형 사용자 인터페이스를 효율적으로 구축하는 것입니다. 다음은 몇 가지 주요 이점입니다. 1. 컴포넌트 기반 아키텍처 React는 UI 개발에 대한 모듈식 컴포넌트 기반 접근 방식을 장려합니다. 각 컴포넌트는 자체 상태를 관리하므로 로직이 단순화되고 코드를 유지 관리하고 재사용하기가 더 쉬워집니다. 2. 선언적 구문 React는 선언적 프로그래밍 스타일을 사용하여 개발자가 현재 상태를 기반으로 UI가 어떻게 표시되어야 하는지 설명합니다. 따라서 명령형 접근 방식에 비해 코드를 더 예측 가능하고 디버깅하기 쉽습니다. 3. Virtual DOM React는 필요한 DOM 연산 횟수를 최소화하여 성능을 향상시키는 Virtual DOM(Document Object Model)을 도입했습니다. 브라우저의 DOM을 업데이트하는 가장 효율적인 방법을 계산하여 렌더링 속도를 높이고 사용자 경험을 개선합니다. 4. 단방향 데이터 바인딩 React는 데이터가 부모 컴포넌트에서 자식 컴포넌트로 한 방향으로만 흐르는 단방향 데이터 흐름을 적용합니다. 이를 통해 애플리케이션 전체에서 일관성을 유지하고 데이터 변경 사항을 추적하고 디버깅하기가 더 쉬워집니다. React.js와 React Native: 차이점은 무엇인가요? React.js는 웹 애플리케이션을 구축하는 데 사용되는 반면, React Native는 JavaScript와 React를 사용하여 네이티브 모바일 애플리케이션을 구축하기 위한 프레임워크입니다. 주요 차이점은 다음과 같습니다. 플랫폼: React.js는 웹 개발에 사용되며 브라우저에서 실행되는 반면, React Native는 모바일 앱 개발에 사용되며 iOS 및 Android 애플리케이션을 구축할 수 있습니다. 렌더링: React.js는 브라우저의 DOM에 컴포넌트를 렌더링하는 반면, React Native는 네이티브 UI 컴포넌트를 사용하여 모바일 기기에 렌더링합니다. 이를 통해 리액트 네이티브 앱은 네이티브 룩앤필을 가질 수 있습니다. API: React.js는 DOM 및 HTML5와 같은 웹 전용 API와 상호 작용하는 반면, React Native는 iOS 및 Android 플랫폼에서 제공하는 모바일 전용 API와 상호 작용합니다. React.js를 배우기 좋은 곳 React.js에 대해 자세히 알아보고 싶다면 몇 가지 훌륭한 리소스가 있습니다. 1. 공식 문서 React.js 공식 문서는 튜토리얼, 가이드, API 참조를 제공하는 포괄적인 시작점입니다. 2. 온라인 강좌 Udemy, fastcampus, 인프런 등과 같은 플랫폼에서는 초급부터 고급까지 다양한 수준의 강좌를 제공하며, 종종 실습 프로젝트가 포함되어 있습니다. 도서: Artemij Fedosejev의 “React.js Essentials”, Alex Banks와 Eve Porcello의 &quot;Learning React&quot;와 같은 책은 심도 있는 지식과 실용적인 예제를 제공합니다. 커뮤니티 및 포럼: Stack Overflow 및 Reddit과 같은 플랫폼에서 React.js 커뮤니티에 참여하여 지원, 토론 및 모범 사례에 대한 인사이트를 얻으세요. 유튜브 튜토리얼: 생활코딩, 코딩앙마, Traversy Media, Academind와 같은 채널에서는 다양한 학습 스타일에 맞는 무료 동영상 튜토리얼을 제공합니다. 결론 React.js는 효율성, 단순성, 강력한 커뮤니티 지원으로 인해 계속해서 진화하며 프론트엔드 개발 환경을 지배하고 있습니다. 반응형 웹 애플리케이션을 구축하는 것이 목표이든, React Native로 모바일 개발의 세계를 탐험하는 것이 목표이든, React.js를 마스터하는 것은 최신 웹 개발의 무한한 가능성을 열어주는 귀중한 기술입니다. 지금 바로 시작하여 React.js로 창의력을 마음껏 발휘하세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Front End Development","slug":"Front-End-Development","permalink":"http://hgko1207.github.io/tags/Front-End-Development/"},{"name":"React.js","slug":"React-js","permalink":"http://hgko1207.github.io/tags/React-js/"}]},{"title":"여러 디바이스와 호환되는 웹 디자인 템플릿을 찾는 방법","slug":"web-16","date":"2024-06-12T12:55:31.000Z","updated":"2024-06-12T13:07:02.361Z","comments":true,"path":"2024/06/12/web-16/","link":"","permalink":"http://hgko1207.github.io/2024/06/12/web-16/","excerpt":"","text":"오늘날의 디지털 세상에서 웹사이트는 모든 기기에서 멋지게 보이고 원활하게 작동해야 합니다. 모바일 및 태블릿 사용이 증가함에 따라 다양한 화면 크기와 해상도에 맞게 조정되는 반응형 웹사이트가 필수적입니다. 여러 디바이스에 최적화된 웹 디자인 템플릿을 사용하는 것은 이를 달성하는 매우 효과적인 방법입니다. 다음은 여러 디바이스와 호환되는 최고의 웹 디자인 템플릿을 찾는 데 도움이 되는 몇 가지 실용적인 팁입니다. 1. 반응형 웹 디자인 프레임워크 활용 반응형 웹 디자인 프레임워크로 검색을 시작하세요. Bootstrap, Foundation, Tailwind CSS와 같은 프레임워크는 반응형 디자인을 위해 특별히 설계된 수많은 템플릿을 제공합니다. 이러한 프레임워크는 어떤 기기에서든 멋지게 보이는 웹사이트를 제작할 수 있는 강력한 기반을 제공합니다. 2. 평판이 좋은 템플릿 마켓플레이스 살펴보기 웹 디자인 템플릿 마켓플레이스는 고품질의 반응형 템플릿을 제공하는 보물창고입니다. ThemeForest, TemplateMonster, Envato Elements와 같은 웹사이트는 다양한 산업과 스타일에 맞는 방대한 템플릿을 제공합니다. “반응형”, “모바일 친화적”, “멀티 디바이스” 등의 키워드를 사용하여 검색 범위를 좁혀보세요. 3. 여러 디바이스에서 템플릿 데모 확인 템플릿을 구매하거나 다운로드하기 전에 데모 기능을 사용하세요. 평판이 좋은 제공업체는 일반적으로 다양한 기기에서 테스트할 수 있는 라이브 데모를 제공합니다. Google의 모바일 친화적 테스트와 같은 도구를 사용하거나 브라우저 창 크기를 조정하여 템플릿이 어떻게 조정되는지 확인하세요. 이렇게 하면 템플릿이 모든 디바이스에서 잘 작동하는지 확인할 수 있습니다. 4. 리뷰 및 평점 읽기 사용자 리뷰 및 평가는 템플릿의 성능을 이해하는 데 유용한 리소스입니다. 템플릿의 반응성과 다양한 디바이스와의 호환성에 관한 피드백에 주목하세요. 리뷰는 종종 잠재적인 문제와 개발자의 지원 품질을 강조합니다. 5. 반응성이 내장된 템플릿 찾기 반응형 디자인이 내장되어 있다고 특별히 광고하는 템플릿을 선택하세요. 설명에서 “반응형 디자인”, “유동적 레이아웃”, &quot;적응형&quot;과 같은 용어를 찾아보세요. 이러한 템플릿은 일반적으로 유연한 그리드 시스템, 미디어 쿼리 및 반응형 이미지를 갖추고 있어 모든 디바이스에 맞게 조정할 수 있습니다. 6. SEO 및 성능 고려 반응형 디자인은 미관뿐만 아니라 SEO 및 성능에도 영향을 미칩니다. Google은 검색 순위에서 모바일 친화적인 웹사이트에 우선순위를 둡니다. 가벼운 코드, 빠른 로딩 시간, 모바일 우선 디자인 원칙 등이 포함된 속도와 SEO에 최적화된 템플릿을 선택하세요. 이러한 기능은 사이트의 가시성과 사용자 경험을 향상시킵니다. 7. 웹 디자인 커뮤니티 및 포럼 활용 웹 디자인 커뮤니티 및 포럼에 참여하여 권장 사항과 직접 경험을 얻으세요. Reddit, Stack Overflow 및 전문 웹 디자인 포럼과 같은 플랫폼은 최고의 반응형 템플릿에 대한 조언을 구하고 제안을 받을 수 있는 훌륭한 장소입니다. 8. 템플릿의 사용자 정의 가능성 테스트 템플릿이 브랜드의 고유한 요구 사항에 맞게 사용자 정의할 수 있는지 확인하세요. 템플릿의 반응성을 저하시키지 않으면서 레이아웃, 색상, 글꼴 및 기타 디자인 요소를 쉽게 변경할 수 있는지 확인하세요. 결론 여러 디바이스와 호환되는 완벽한 웹 디자인 템플릿을 찾는 것이 어렵지 않습니다. 반응형 프레임워크를 활용하고, 평판이 좋은 마켓플레이스를 탐색하고, 데모를 테스트하고, 리뷰를 읽고, SEO와 성능을 고려하면 어떤 기기에서든 멋지게 보이고 완벽하게 작동하는 웹사이트 템플릿을 찾을 수 있습니다. 반응성을 핵심으로 디자인된 템플릿을 선택하여 사용자에게 모든 디바이스에서 원활한 브라우징 환경을 제공함으로써 디지털 경쟁에서 앞서 나가세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Responsive Design","slug":"Responsive-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Design/"},{"name":"Responsive Web Design","slug":"Responsive-Web-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Web-Design/"},{"name":"Responsive Website Design","slug":"Responsive-Website-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Website-Design/"}]},{"title":"초보 개발자가 프로처럼 보일 수 있는 자바스크립트 원라이너 10가지","slug":"js-dev-22","date":"2024-06-11T03:27:34.000Z","updated":"2024-06-11T14:49:57.651Z","comments":true,"path":"2024/06/11/js-dev-22/","link":"","permalink":"http://hgko1207.github.io/2024/06/11/js-dev-22/","excerpt":"","text":"다른 사람이 자바스크립트 한 줄로 문제를 해결했을 때 코딩에 푹 빠져본 적이 있나요? 마치 코딩 마술과도 같습니다. 이것이 바로 한 줄의 힘입니다. 이 짧은 코드 스니펫은 매우 효과적이어서 마치 자바스크립트 전문가가 된 듯한 기분을 느낄 수 있습니다. 원라이너(one-liner)는 기능을 한 줄로 압축한 짧은 자바스크립트 코드 조각입니다. 원라이너를 사용하면 보다 간결한 코드를 작성할 수 있고 때로는 가독성을 향상시킬 수도 있습니다. 어떤 이점이 있을까요? 시간을 절약하고, 더 깔끔한 코드를 작성하며, 다른 개발자에게 깊은 인상을 줄 수도 있습니다(약간은). 이제 초보자도 쉽게 따라 할 수 있는 실용적인 원라이너에 초점을 맞추고 있습니다. 1. Array Filtering 시험 점수의 배열이 있고 점수 중에 짝수를 찾아야 한다고 가정해 봅시다. 한 줄로 해결하세요! 123const scores = [85, 92, 73, 98, 80];const evenScores = scores.filter((num) =&gt; num % 2 === 0);// 결과: [92, 98, 80] 이 코드는 filter 메서드를 사용하여 테스트를 통과한 요소만 포함하는 새 배열을 만듭니다. 화살표 함수(num =&gt; num % 2 === 0)는 각 숫자가 짝수인지 확인합니다. 배열에서 원하지 않는 요소를 제거하는 필터링은 일반적인 작업입니다. 이 한 줄짜리 함수는 데이터를 깔끔하게 유지하는 데 유용합니다. 2. Array Mapping 변 길이의 배열이 있고 각 사각형의 면적을 파악하려는 경우. 이 한 줄로 배열의 각 요소를 해당 정사각형으로 매핑(변환)할 수 있습니다. 123const sideLengths = [5, 3, 7];const areas = sideLengths.map((num) =&gt; num * num);// 결과: [25, 9, 49] map 메서드는 원래 배열의 모든 요소에 대해 제공된 함수를 호출한 결과로 새 배열을 만듭니다. 여기서 함수는 각 숫자를 제곱합니다. 이 함수는 배열의 각 요소에 수학적 연산을 수행할 때 유용합니다. 3. Flattening Arrays 식료품점 제품 목록과 같이 각 이형 상품에 대한 하위 항목이 있는 중첩 배열을 접할 때가 있습니다. 한 줄짜리 코드를 사용하면 이러한 구조를 평평하게 만들 수 있습니다. 123456const nestedGroceries = [ ['Apples', ['Red', 'Green']], ['Milk', ['Whole', '2%']],];const flatGroceries = nestedGroceries.flat();// 결과: [\"Apples\", \"Red\", \"Green\", \"Milk\", \"Whole\", \"2%\"] flat 메서드(ES6 이상에서 사용 가능)는 모든 하위 배열 요소가 연결된 새 배열을 생성합니다. 이를 통해 데이터 조작 작업을 간소화할 수 있습니다. 중첩 배열을 플랫화하면 단일 차원의 데이터로 작업하기가 더 쉬워집니다. 4. 고유 요소(중복 허용되지 않음!) 게스트 목록에 안타깝게도 중복 항목이 있는 경우가 있을 수 있습니다. 한 줄짜리 코드를 사용하면 모든 사람에게 고유한 초대장을 보낼 수 있습니다. 1234const guestList = ['Alice', 'Bob', 'Charlie', 'Alice'];// 중복입니다!const uniqueGuests = [...new Set(guestList)];// 결과: [\"Alice\", \"Bob\", \"Charlie\"] 데이터 정리는 종종 배열에서 중복을 제거하는 것을 의미합니다. 이 코드로 데이터를 깨끗하고 깔끔하게 유지합니다. 5. 조건문 조건에 따라 값을 할당하기 위해 여러 줄에 걸쳐 if...else 문을 작성해 본 적이 있나요? 더 간결한 방법이 있습니다. 12const age = 18;const message = age &gt;= 18 ? 'Welcome!' : 'Sorry, not yet.'; 이 코드는 삼항 연산자를 사용하는데, 한 줄로 짧은 if-else 문을 작성하는 멋진 방법입니다. 조건(age &gt;= 18)이 확인되면 해당 값(&quot;Welcome!&quot; 또는 &quot;Sorry, not still.&quot;)이 메시지 변수에 할당됩니다. 삼항 연산자는 좋지만 복잡한 상황에서는 코드를 이해하기 어려울 수 있습니다. 현명하게 사용하세요! 6. 문자열 반전 문자열을 반전시켜서 팰린드롬(앞뒤가 같은 단어, 예를 들어 “racecar” 처럼)인지 확인해보는 것은 어떨까요? 123const str = 'Hello, world!';const reversedStr = str.split('').reverse().join('');// 결과: \"!dlrow ,olleH\" 문자열을 문자 배열로 나누고, 요소의 순서를 반전시킨 다음 새로운 문자열로 다시 결합하여 한 줄로 만듭니다. 하위 문자열 반전 또는 추출과 같은 문자열 조작 작업은 한 줄로 간단하게 처리할 수 있습니다. 7. 개체 속성 존재 여부 사용자 프로필 시스템을 만들고 있는데 사용자 개체에 특정 속성(예: ‘email’)이 존재하는지 파악해야 한다고 가정해 보세요. 원라이너가 도움이 될 수 있습니다. 123const user = &#123; name: 'Alice', age: 30 &#125;;const hasEmail = 'email' in user;// 결과: false (이메일 속성이 없음) in 연산자는 객체 내에 프로퍼티가 존재하는지 확인합니다. 여기서는 user 객체에 'email' 프로퍼티가 있는지 확인합니다. 8. 기본 매개변수 값 사용자에게 인사하는 작업을 만들되 이름이 제공되지 않은 경우를 대비해 백업 값을 제공하는 것은 어떨까요? 원라이너로 이를 관리할 수 있습니다. 12345const greet = (name = 'Guest') =&gt; `Hello, $&#123;name&#125;!`;console.log(greet());// 결과: Hello, Guest!console.log(greet('Bob'));// 결과: Hello, Bob! 이 예시는 ES6 기본 매개변수를 사용합니다. 여기서 greet 함수를 호출할 때 이름을 지정하지 않으면 기본값인 'Guest'가 사용됩니다. 기본 매개변수는 적절한 인수 없이 함수를 호출할 때 발생하는 오류를 방지하여 코드를 더욱 강력하게 만들어 줍니다. 9. 컴팩트 배열 가끔 빈 값이나 null 요소가 있는 배열이 있을 수 있습니다. 원라이너를 사용하면 이러한 불청객을 제거할 수 있습니다. 123const numbers = [1, 0, null, 3];const compactNumbers = numbers.filter(Boolean);// 결과: [1, 3] 이 예시는 filter 메서드를 다시 활용합니다. 하지만 이번에는 필터가 Boolean 생성자를 사용하여 null, undefined, 0, &quot;&quot;, NaN과 같은 “falsy” 값을 확인합니다. false로 평가되는 모든 요소는 새 배열에서 제외됩니다. 10. 동적 객체 키 원라이너를 사용하여 작업 후에 결정되는 키가 있는 객체를 만들 수도 있습니다. 놀랍죠? 123const prop = 'score';const person = &#123; [prop]: 90 &#125;;// 결과: &#123;score: 90&#125; 이 예시는 계산된 프로퍼티 이름을 사용합니다. prop 변수의 값은 객체를 생성할 때 중괄호 안의 키 이름으로 사용됩니다. 이를 통해 변수나 표현식을 기반으로 동적 키를 생성할 수 있습니다. 마무리 자바스크립트 코드를 개선할 수 있는 몇 가지 훌륭한 원라이너를 배웠기를 바랍니다. 원라이너는 강력한 도구이지만 코드의 명확성과 유지보수성을 보장하기 위해 신중하게 사용해야 한다는 점을 기억하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Javascript Development","slug":"Javascript-Development","permalink":"http://hgko1207.github.io/tags/Javascript-Development/"},{"name":"Javascript Tips","slug":"Javascript-Tips","permalink":"http://hgko1207.github.io/tags/Javascript-Tips/"}]},{"title":"자바스크립트를 배우기 쉬운 방법","slug":"js-dev-21","date":"2024-06-10T13:20:00.000Z","updated":"2024-06-10T13:26:23.024Z","comments":true,"path":"2024/06/10/js-dev-21/","link":"","permalink":"http://hgko1207.github.io/2024/06/10/js-dev-21/","excerpt":"","text":"안녕하세요. 기술 산업은 빠르게 성장하고 있지만, 코딩 선두주자처럼 눈에 띄는 언어는 바로 자바스크립트입니다. 1995년에 만들어진 자바스크립트는(IT 역사로 따지면 오래된 언어입니다!) 웹 페이지 마스터에서 모바일 앱부터 비디오 게임까지 모든 분야에 사용되는 강력한 언어로 성장했습니다. 자바스크립트가 여전히 왕좌에 있는 이유는 무엇일까요? 개발 도구 세트에 추가해야 하는 이유를 살펴보세요. 1. 어디에나 있습니다 건물의 98.8%가 같은 언어로 소통하는 도시에 들어간다고 생각해 보세요. 이는 웹 개발에서 자바스크립트의 위력을 보여줍니다! 자바스크립트는 웹사이트와 온라인 애플리케이션을 원활하게 실행하는 데 일반적으로 사용됩니다. 2. 단순함과 강력함의 만남 자바스크립트를 배우는 것은 새로운 친구를 사귀는 것과 같습니다. 친근하고 접근하기 쉬우면서도 숨겨진 깊이를 탐구할 수 있는 언어입니다. 따라서 초보자와 숙련된 개발자 모두에게 이상적인 언어입니다. 3. 수요는 현실적이며 계속 증가하고 있습니다 미국 노동 통계국은 향후 10년간 자바스크립트 개발자 수요가 25% 증가할 것으로 예측하고 있습니다. 기술 분야에서 미래 보장형 직업을 찾는 모든 분께 희소식입니다! 4. 수익성 높은 기회가 기다리고 있습니다 직업과 관련하여 자바스크립트 개발자는 수요가 많으며 급여도 이를 반영하고 있습니다. 일반적인 미국 자바스크립트 개발자의 연봉은 109,000달러입니다. 그리 나쁘지 않은 수준입니다. 그렇다면 어떻게 자바스크립트 클럽에 가입할 수 있을까요? 1. 기본부터 시작하세요 자바스크립트를 시작하기 전에 HTML과 CSS부터 시작하는 것이 가장 좋습니다. 이러한 언어는 웹 페이지의 기초가 되는 언어이며, 이를 익히면 자바스크립트를 훨씬 쉽게 배울 수 있습니다. 2. 학습 환경 살펴보기 무료 온라인 강의와 프리미엄 코딩 부트캠프 등 자바스크립트를 배울 수 있는 다양한 옵션이 있습니다. 더 철저한 학습을 원한다면 컴퓨터 공학 학위를 취득하는 것도 고려해 보세요. 3. 커뮤니티에 참여하세요 학습은 항상 다른 사람들과 함께하면 더 즐겁고 생산적입니다! 온라인 커뮤니티에 가입하고, 밋업에 참석하고, 다른 자바스크립트 팬들과 네트워크를 형성하세요. 학습 경로를 공유하고 프로젝트를 진행하면 기술과 동기를 크게 향상시킬 수 있습니다. 4. 도전을 받아들이세요 새로운 언어를 배우려면 연습과 노력이 필요합니다. 도전은 숙달로 이어질 수 있으므로 두려워하지 마세요. 코딩 챌린지에 참여하고, 프로젝트를 만들고, 더 나은 실력을 갖추기 위해 끊임없이 자신을 채찍질하세요. 보너스 팁: jQuery: 친구인가, 적인가? 자바스크립트의 인기가 높아지고 있는 반면, 한때 웹 프로그래밍을 간소화하기 위한 주요 프레임워크였던 jQuery는 거의 주목받지 못하고 있습니다. jQuery를 이해하는 것이 React나 Node.js 같은 최신 기술을 익히는 데 꼭 필요한 것은 아니지만, 오래된 프로젝트를 유지 관리하는 데는 유용할 수 있습니다. 따라서 이전 코드베이스로 작업하는 경우 jQuery에 대해 알고 있으면 유용할 수 있습니다. 마무리 지속적으로 변화하는 기술 분야에서 자바스크립트는 지속적으로 관련성이 높아 웹 개발 경력에 관심이 있는 모든 사람에게 훌륭하고 만족스러운 선택이 될 것입니다. 유연성, 광범위한 사용, 높은 수요로 인해 오늘날의 취업 시장에서 매력적인 기술입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Javascript Development","slug":"Javascript-Development","permalink":"http://hgko1207.github.io/tags/Javascript-Development/"},{"name":"Javascript Tips","slug":"Javascript-Tips","permalink":"http://hgko1207.github.io/tags/Javascript-Tips/"}]},{"title":"믿을 수 없을 만큼 놀라운 코딩 꿀팁","slug":"info-15","date":"2024-06-05T14:14:53.000Z","updated":"2024-06-05T14:23:15.438Z","comments":true,"path":"2024/06/05/info-15/","link":"","permalink":"http://hgko1207.github.io/2024/06/05/info-15/","excerpt":"","text":"끊임없이 진화하는 코드 세계에서 우리는 모두 어려움을 겪고 있습니다. 매일 새로운 프레임워크가 등장하고, 오래된 언어는 밀려나며, 때로는 따라잡는 것이 끝없는 싸움처럼 느껴지기도 합니다. 하지만 걱정하지 마세요. 산더미 같은 정보 속에 숨어 있는 진정한 코딩의 보석, 즉 여러분의 실력을 크게 향상시킬 수 있는 과소평가된 팁과 요령이 숨겨져 있기 때문입니다. 이 글을 통해 이러한 힌트가 어떻게 빛을 발하는지 알아보세요. 1. 러버덕 디버깅 의식 작동하지 않는 코드 블록을 쳐다보며 답답함을 느낀 적이 있나요? 러버덕 디버깅(Rubber Duck Debugging) 기법을 사용해 보세요. 기꺼이(또는 그렇지 않을 수도 있는) 러버덕 청취자에게 코드를 단계별로 설명하세요. 논리를 말로 표현하다 보면 어느새 범인을 발견할 수도 있습니다. 또한 긴장을 풀고 새로운 관점을 얻을 수 있는 재미있는 방법이기도 합니다. 2. 문서화 몇 달 후 여러분의 코드를 다시 보게 될 미래의 여러분을 기억하시나요? 코드가 무엇을 하는지, 왜 그렇게 하는지, 심지어 그 뒤에 숨은 사고 과정까지 설명하는 명확하고 상세한 문서를 작성하세요. 나중에 골치 아픈 일을 줄일 수 있을 뿐만 아니라 팀원들도 고마워할 것입니다. 미래의 자신에게(그리고 다른 사람들에게) 이해의 힘을 선물한다고 생각하세요. 3. 명령줄과 친해지기 명령줄(Command Line)은 처음에는 두렵게 느껴질 수 있지만, 효율성의 관문이라는 점을 잊지 마세요. 기본적인 셸 명령어를 익히면 워크플로를 마법처럼 간소화할 수 있습니다. 또한 명령줄의 힘을 직접 휘두르는 데서 오는 만족감도 상당합니다. 가독성이 핵심이라는 점을 기억하세요. 코드를 작성할 때와 마찬가지로 명령어를 명확하고 간결하게 작성하세요. 4. 연습은 발전을 가져온다 진정한 코딩 숙달은 문제에 적극적으로 참여하는 데서 비롯됩니다. 수동적으로 튜토리얼만 시청하지 마세요. 직접 뛰어들어 복잡한 작업을 세분화하고 다양한 접근 방식을 실험하며 한계를 뛰어넘으세요. 실수를 두려워하지 마세요. 실수는 성장의 디딤돌입니다. 정기적으로 코드를 검토하여 진행 상황을 되돌아보고 개선할 부분을 파악하세요. 5. IDE의 숨겨진 보석 활용하기 대부분의 IDE는 발견되기를 기다리는 숨겨진 기능이 가득한 보물창고와도 같습니다. 시간을 내어 잘 사용하지 않는 기능을 살펴보세요. 미처 몰랐던 생산성 향상 기능을 발견할 수도 있습니다. 온라인 커뮤니티에 가입하거나, 강좌를 수강하거나, IDE를 둘러보는 것을 두려워하지 마세요. 발견하는 것에 놀랄 수도 있습니다! 6. 버전 관리 끊임없이 변화하는 코딩 환경에서는 큰 그림을 이해하는 것이 중요합니다. 프로젝트의 아키텍처, 디자인 패턴, 비즈니스 로직에 익숙해져야 합니다. 정기적인 커밋, 명확한 메시지, 스마트한 브랜칭 전략으로 버전 관리를 효과적으로 사용하세요. 이는 변경 사항을 추적하는 데 도움이 될 뿐만 아니라 팀과의 원활한 협업을 촉진합니다. 7. 키보드 단축키 효율성은 게임의 이름이며 키보드 단축키는 여러분의 비밀 무기입니다. 단축키를 익히면 코딩 속도와 유창성을 크게 높일 수 있습니다. 약간의 연습이 필요할 수도 있지만, 나중에 손가락이 고마워할 것입니다. 마무리 지금까지 소개해 드린 코딩 팁은 우리가 발견하기를 기다리는 과소평가된 수많은 코딩 보석 중 일부에 불과합니다. 이제 코딩 모자를 쓰고 믿을 수 있는 고무 오리(선택 사항)를 들고 지속적인 학습과 탐험의 여정을 시작하세요.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Coding Tips","slug":"Coding-Tips","permalink":"http://hgko1207.github.io/tags/Coding-Tips/"},{"name":"Programming Tips","slug":"Programming-Tips","permalink":"http://hgko1207.github.io/tags/Programming-Tips/"}]},{"title":"많은 웹 개발자가 반응형 디자인에 어려움을 겪는 이유","slug":"web-15","date":"2024-06-04T05:26:53.000Z","updated":"2024-06-04T05:59:30.209Z","comments":true,"path":"2024/06/04/web-15/","link":"","permalink":"http://hgko1207.github.io/2024/06/04/web-15/","excerpt":"","text":"안녕하세요! 웹사이트를 모든 기기에서 멋지게 보이게 하는 반응형 디자인에 대해 알아보겠습니다. 오늘날의 모바일 우선 환경에서 반응형 디자인이 중요하다는 것은 누구나 알고 있지만, 솔직히 말해서 완전한 반응형 사이트를 만드는 것은 다소 어려울 수 있습니다. 그렇다면 왜 어려울까요? 개발자가 직면하는 가장 일반적인 문제와 이미 검증된 솔루션을 사용하여 이를 해결하는 방법을 알려드릴 테니 긴장하세요. 반응형 디자인 이해 반응형 디자인은 데스크톱 디스플레이부터 소형 휴대폰 기기까지 모든 화면 크기에서 웹사이트에 액세스할 수 있다는 뜻입니다. 복잡한 코딩 기술을 사용하여 레이아웃, 시각적 요소, 텍스트를 사용자가 만든 콘텐츠를 보는 방식에 관계없이 적절하게 변경합니다. 웹 개발자가 직면하는 일반적인 과제 이제 반응형 디자인 분야에서 가장 경험이 많은 개발자도 당황할 수 있는 문제에 대해 진지하게 살펴봅시다. 기본 사항 숙지하기 유동 그리드(flexible layout), 유연한 이미지(이상한 비율 없이 확장됨), 미디어 쿼리(화면 크기에 따라 웹사이트가 변경되는 방법을 안내하는 코드)를 이해하는 것은 필수적입니다. 모두를 만족시키는 디자인 반응형 디자인이 모든 브라우저와 디바이스에서 멋지게 보이도록 하는 것은 쉽지 않을 수 있습니다. 브라우저마다 코드를 처리하는 방식이 다르기 때문에 Chrome에서 멋지게 보이는 디자인이 Firefox에서는 작동하지 않을 수도 있습니다. 사이트 속도 유지 반응형 웹사이트에는 많은 양의 코드가 포함되어 있어 속도가 느려질 수 있습니다. 이미지 최적화(화질을 유지하면서 이미지를 작게 만드는 것)와 깔끔하고 효율적인 코드는 반응형 사이트의 원활한 작동을 유지하는 데 핵심입니다. 아름다움과 사용성의 균형 맞추기 매력적이고 사용자 친화적이며 여러 디바이스에서 쉽게 적응할 수 있는 레이아웃을 만드는 것은 어려운 작업처럼 보일 수 있습니다. 작은 화면에서 웹사이트가 지저분해지지 않도록 하려면 디자인에 대한 기술과 뛰어난 안목이 필요합니다. 기술 솔루션 및 모범 사례 두려워하지 마세요, 반응형 디자인을 마스터하기 위해 실전에서 검증된 몇 가지 도구와 전략을 소개합니다. Bootstrap 이 인기 있는 프레임워크는 스타일과 레이아웃이 미리 구축되어 있어 반응형 웹사이트를 쉽게 만들 수 있습니다. 모바일 우선 사고방식 모바일 디스플레이용으로 먼저 디자인한 다음 더 큰 디바이스로 이동하세요. 이렇게 하면 웹사이트가 가장 일반적인 시청 플랫폼에 최적화되어 더 쉽게 확장할 수 있습니다. 테스트 신중한 테스트를 대신할 수 있는 것은 없습니다. 브라우저 앱과 실제 기기를 사용하여 다양한 화면 크기에서 반응형 디자인이 어떻게 작동하는지 테스트하세요. 반응형 이미지 및 미디어 srcset 및 그림 요소를 사용하여 각 장치에 적합한 형식으로 사진을 전송하여 사이트가 빠르게 로드되도록 하세요. CSS 전처리기가 구세주 Sass와 Less는 CSS 스타일을 보다 효과적으로 관리할 수 있는 도구로, 복잡한 반응형 레이아웃을 보다 쉽게 만들 수 있습니다. 결론 반응형 디자인은 단순한 트렌드를 넘어 미래 지향적인 웹사이트의 기반을 제공합니다. 문제를 이해하고 앞서 설명한 솔루션과 리소스를 활용하면 어떤 방식으로 보더라도 멋지게 보이고 완벽하게 작동하는 웹사이트를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Responsive Design","slug":"Responsive-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Design/"},{"name":"Responsive Web Design","slug":"Responsive-Web-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Web-Design/"},{"name":"Responsive Website Design","slug":"Responsive-Website-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Website-Design/"}]},{"title":"웹 개발자를 위한 최고의 Chrome 확장 프로그램 7가지","slug":"web-14","date":"2024-06-03T13:08:26.000Z","updated":"2024-06-03T13:30:02.653Z","comments":true,"path":"2024/06/03/web-14/","link":"","permalink":"http://hgko1207.github.io/2024/06/03/web-14/","excerpt":"","text":"웹 개발자로서 저는 이 문제에 공감할 수 있습니다. 우리는 일상적인 업무를 처리하고, 문제를 해결하고, 끊임없이 변화하는 웹 기반 시나리오에서 앞서 나가기 위해 많은 시간을 소비합니다. 하지만 프로세스를 극대화하고 중요한 제작 시간을 더 생산적으로 활용할 수 있는 숨겨진 도구가 있다면 어떨까요? 바로 Chrome 확장 프로그램입니다. 이 도구는 브라우저에 강력한 기능을 부여하고 작업 방식을 바꿔주는 중요한 역할을 합니다. 손쉬운 글꼴 검색부터 원활한 크로스 브라우저 테스트까지 완전히 새로운 차원의 개발 효율성을 누릴 준비가 되셨나요? 1. WhatFont WhatFont 멋진 웹사이트를 발견하고 어떤 글꼴을 사용했는지 궁금한 적이 있나요? 더 이상 코드를 분리하는 데 몇 시간을 소비할 필요가 없습니다. 클릭 한 번으로 웹페이지의 모든 요소에 사용된 숨겨진 글꼴을 찾아주는 WhatFont가 있습니다. 2. ColorPick Eyedropper ColorPick Eyedropper 사진이나 다른 웹사이트의 색상을 일치시키는 작업은 생각과 코드 변경이 필요한 시간이 많이 소요되는 작업일 수 있습니다. ColorPick Eyedropper는 컬러 매칭을 도와주는 친구입니다. 웹 페이지의 요소 위로 마우스를 가져가면 정확한 16진수 코드를 빠르게 캡처할 수 있습니다. 디자인이나 코드에서 정확한 색상을 쉽게 찾을 수 있습니다. 3. Window Resizer Window Resizer 웹사이트를 모든 화면 크기에서 보기 좋게 만드는 것은 시간이 많이 걸리는 작업일 수 있습니다. Window Resizer는 이러한 문제를 해결해 줍니다. 미리 설정된 일반적인 디바이스 해상도 목록에서 선택하거나 나만의 해상도를 만들 수 있습니다. 클릭 한 번으로 브라우저 창 크기가 필요한 크기로 조정되므로 유연한 디자인을 빠르게 테스트할 수 있습니다. 4. BrowserStack BrowserStack 브라우저 간 호환성 테스트는 큰 골칫거리가 될 수 있습니다. 브라우저마다 코드를 다르게 표시하기 때문에 잠재적인 버그와 불일치가 발생할 수 있습니다. BrowserStack은 동일한 브라우저 창 내에서 브라우저와 기술의 가상 표를 제공하여 이 문제를 해결합니다. 여러 기기에서 웹사이트를 테스트하여 사용자가 웹 전체에서 동일한 경험을 할 수 있도록 하세요. 5. CSS Viewer CSS Viewer 개발 도구는 강력하지만 복잡한 스타일시트를 작업하는 것은 어려울 수 있습니다. CSS Viewer는 전체 프로세스를 줄여줍니다. 요소에 사용된 모든 스타일을 쉽고 구조화된 형식으로 보여줍니다. 실시간으로 CSS 코드를 변경하고 웹사이트에 바로 반영되는 것을 확인할 수도 있습니다. 6. Ghostery Ghostery 오늘날의 데이터 중심 세상에서 웹사이트는 종종 타사 트래커를 사용하여 사용자 행동을 모니터링합니다. 이는 분석에 유용하지만 개인정보 보호와 관련된 문제를 야기할 수도 있습니다. Ghostery는 그림자 속에 숨어 있는 트래커에 빛을 비춰줍니다. 페이지에 어떤 트래커가 있는지 찾아내고 클릭 한 번으로 트래커를 중지할 수 있습니다. 7. Wappalyzer Wappalyzer 특히 경쟁 분석이나 조사를 할 때 웹사이트 제작에 사용된 기술을 찾는 것은 어려울 수 있습니다. Wappalyzer는 프레임워크, 콘텐츠 관리 시스템, 분석 도구 등 웹사이트를 지원하는 기술을 탐색합니다. 경쟁사의 기술 스택과 업계 동향에 대한 필수 정보를 제공합니다. 결론 Chrome 확장 프로그램은 웹 개발자에게 필수적인 리소스로 워크플로우를 최적화하고 생산성을 높이며 작업 품질을 개선하는 데 도움이 되는 기능을 제공합니다. 7가지 확장 프로그램을 사용하면 일반적인 문제를 보다 효율적으로 처리하고 끊임없이 변화하는 웹 개발 세계에서 앞서나갈 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Chrome","slug":"Chrome","permalink":"http://hgko1207.github.io/tags/Chrome/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Developer Tools","slug":"Developer-Tools","permalink":"http://hgko1207.github.io/tags/Developer-Tools/"},{"name":"Chrome Extension","slug":"Chrome-Extension","permalink":"http://hgko1207.github.io/tags/Chrome-Extension/"}]},{"title":"재정적 자유를 위한 풀스택 개발자 가이드(3가지 방법)","slug":"info-14","date":"2024-05-31T05:33:49.000Z","updated":"2024-05-31T06:04:14.869Z","comments":true,"path":"2024/05/31/info-14/","link":"","permalink":"http://hgko1207.github.io/2024/05/31/info-14/","excerpt":"","text":"조사에 따르면 풀스택 개발자의 평균 수입은 124,327달러로, 업계에서 가장 인기 있는 개발자 중 한 명으로 꼽힙니다. 하지만 여기서 중요한 점은 일반적인 정규직이 아니라는 점입니다. 풀스택 개발자의 장점은 자신의 기술을 바탕으로 다양한 수익원을 창출할 수 있다는 점입니다. 그렇다면 어떻게 풀스택 개발자가 되어 재정적 자유를 누릴 수 있을까요? 세 가지 방법을 살펴보겠습니다. 1. 프리랜서 관심 있는 프로젝트에서 일하고, 일정을 만들고, 결정을 내립니다. 이것이 프리랜서 개발자의 삶입니다. 프리랜서 생활 방식에 대한 개요는 다음과 같습니다. 장점: 자유, 유연성, 업무에 대한 통제권, 높은 수입을 올릴 수 있는 기회. 작업할 프로젝트를 선택하고 가격을 설정할 수 있으므로 특정 목표에 맞게 수입을 맞출 수 있습니다. 단점: 고객 관리는 시간이 많이 소요될 수 있고, 고객 확보와 프로젝트 가용성에 따라 수입이 달라질 수 있으며, 명확한 시간표 없이 집중력을 유지하려면 상당한 자기 훈련이 필요합니다. 프리랜서로 활동할 준비가 되셨나요? 잠재 고객에게 자신의 기술과 지식을 보여줄 수 있는 돋보이는 포트폴리오를 만드는 방법을 알아보세요. 크몽이나 원티드, 숨고 등 프리랜서 프로젝트를 찾을 수 있는 최고의 플랫폼을 알아보고, 성공으로 가는 네트워크와 강력한 고객층을 구축하는 방법에 대한 팁을 알아보세요. 2. 디지털 제품 제작 및 판매 킬러 앱 아이디어가 있으신가요? 풀스택 개발자는 자신의 창작물을 콘셉트에서 수익으로 연결할 수 있는 특별한 능력을 가지고 있습니다. 상상력을 자극하는 몇 가지 디지털 제품 아이디어를 소개합니다. 테마 및 플러그인: 워드프레스와 같은 인기 플랫폼에서 테마 및 플러그인을 만들어 판매하세요. 이를 통해 방대한 기존 사용자층과 연결되는 동시에 새로운 작품으로 잠재적으로 많은 잠재고객을 끌어들일 수 있습니다. SaaS: 특정 요구 사항을 해결하는 구독 기반 소프트웨어 솔루션을 만듭니다. 시장의 니즈를 파악하고 월별 또는 연간 단위로 비용을 지불할 준비가 된 사람들을 위해 사용자 친화적이고 지속적인 서비스를 만드세요. 3. 컨설팅 및 코칭 풀스택 개발자는 뛰어난 기술과 전문성을 갖추고 있습니다. 컨설팅과 코칭을 통해 자신의 기술을 활용하여 기업의 목표 달성을 도울 수 있습니다. 컨설팅과 코칭이 효과적인 이유는 다음과 같습니다. 지혜를 공유하세요: 웹 개발의 모든 측면을 안내하여 기업이 더 나은 제품을 만들고, 기술 문제를 해결하고, 끊임없이 변화하는 디지털 세상에서 성공할 수 있도록 도와주세요. 차이를 만들어 보세요: 여러분의 지식이 비즈니스와 기업의 성공에 미치는 실제적인 영향력을 발견하세요. 여러분의 지식은 기업이 개발 프로세스를 개선하고 복잡한 문제를 극복하며 마침내 잠재력을 최대한 발휘하는 데 도움이 될 수 있습니다. 풀스택 재정 자립의 세계는 여기서 멈추지 않습니다! 온라인 강좌를 만들어 더 많은 청중과 기술을 공유하고 지속적으로 수익을 창출하세요. 오픈소스 프로젝트에 기여하거나 전자책을 출판하여 특정 분야의 전문가로 자리매김하고 작업에 대한 로열티를 받을 수도 있습니다. 결론 풀스택 기술을 활용하면서 창의력과 수익을 창출할 수 있는 흥미로운 세 가지 방법을 소개해 드렸습니다. 장점은 유연성에 있다는 점을 기억하세요. 한 가지 방법을 따르거나, 몇 가지 방법을 실험하거나, 자신에게 적합한 하이브리드 접근 방식을 구축할 수도 있습니다. 가장 중요한 것은 무엇인가요? 학습과 변화를 멈추지 마세요. 기술은 항상 변화하고 있으며 장기적인 성공을 위해서는 앞서 나가는 것이 중요합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"풀스택","slug":"풀스택","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D/"},{"name":"풀스택 개발자","slug":"풀스택-개발자","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"풀스택 개발","slug":"풀스택-개발","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D-%EA%B0%9C%EB%B0%9C/"}]},{"title":"ChatGPT-4o vs ChatGPT-4: 주요 기능 및 차이점 알아보기","slug":"chatgpt-28","date":"2024-05-30T13:24:49.000Z","updated":"2024-05-30T13:31:54.035Z","comments":true,"path":"2024/05/30/chatgpt-28/","link":"","permalink":"http://hgko1207.github.io/2024/05/30/chatgpt-28/","excerpt":"","text":"ChatGPT-4 및 ChatGPT-4o 이해하기 ChatGPT-4란 무엇인가요? ChatGPT-4는 OpenAI에서 개발한 고도의 고급 언어 모델입니다. 이전 모델의 성공을 바탕으로 자연어 이해력 향상, 문맥 인식 개선, 인간과 유사한 텍스트 생성 성능 향상을 제공합니다. ChatGPT-4는 고객 지원부터 콘텐츠 제작에 이르기까지 다양한 애플리케이션에서 탁월한 성능을 발휘합니다. ChatGPT-4o 소개 여기서 'o’는 'omni’를 의미하는 ChatGPT-4o는 OpenAI의 AI 기술의 최신 도약을 나타냅니다. 이 모델은 텍스트뿐만 아니라 오디오와 이미지도 실시간으로 처리하고 생성하도록 설계되었습니다. 여러 양식을 통합함으로써 ChatGPT-4o는 보다 자연스럽고 직관적인 인간과 컴퓨터 간의 상호 작용 경험을 제공하는 것을 목표로 합니다. 주요 기능 비교 멀티 모달 기능 ChatGPT-4: 주로 텍스트 기반 상호작용에 중점을 두며, 다양한 컨텍스트와 언어에서 텍스트를 이해하고 생성하는 고급 기능을 제공합니다. ChatGPT-4o: 텍스트를 넘어 오디오와 이미지까지 확장합니다. 이 멀티 모달 기능을 통해 오디오 입력을 이해하고 이에 응답하며, 이미지 출력을 생성하고, 이를 텍스트와 결합하여 더욱 풍부한 대화 환경을 제공할 수 있습니다. 응답 시간 ChatGPT-4: 빠른 텍스트 생성을 제공하지만 오디오나 이미지 입력은 처리하지 않습니다. ChatGPT-4o: 텍스트, 이미지, 오디오 입력에 232 millisecond 만에 응답할 수 있으며, 평균 응답 시간은 320 millisecond로 사람의 대화 속도와 비슷합니다. 따라서 상호 작용이 더욱 유동적이고 생생하게 이루어집니다. 성능 및 비용 효율성 ChatGPT-4: 텍스트 생성 및 이해 성능이 뛰어난 것으로 알려져 있지만 리소스 집약적일 수 있습니다. ChatGPT-4o: 텍스트에 대한 GPT-4 Turbo 성능과 비슷하면서도 API에서 더 빠르고 50% 저렴합니다. 또한 비영어권 언어에 탁월하며 시각 및 음성 이해력이 뛰어납니다. 기술 발전 자연어 이해 ChatGPT-4: 일관된 텍스트를 이해하고 생성하며, 긴 대화에서 맥락을 유지하고 정확한 응답을 제공하는 데 탁월합니다. ChatGPT-4o: 오디오 및 이미지 처리 기능을 통합하여 입력을 보다 종합적으로 이해하고 텍스트, 오디오, 이미지를 포함한 출력을 생성함으로써 이러한 기능을 향상시킵니다. 대화 능력 ChatGPT-4: 문맥을 잘 유지하고 상세하고 정확한 응답을 제공합니다. ChatGPT-4o: 어조, 여러 화자, 배경 소음을 이해하여 대화 능력을 한 차원 높여 더욱 역동적이고 사실적인 대화가 가능합니다. 애플리케이션 및 사용 사례 교육 ChatGPT-4: 텍스트 기반 개인 지도, 숙제 지원, 교육 콘텐츠 생성에 유용합니다. ChatGPT-4o: 대화형 오디오 응답과 시각적 보조 자료로 교육용 애플리케이션을 향상시켜 학습의 몰입도와 효과를 높입니다. 비즈니스 ChatGPT-4: 고객 지원 자동화, 마케팅 콘텐츠 생성, 운영 간소화에 효과적입니다. ChatGPT-4o: 실시간 오디오 상호작용과 이미지 생성으로 가치를 더하여 고객 서비스를 개선하고 보다 역동적인 마케팅 자료를 제작할 수 있습니다. 헬스케어 ChatGPT-4: 의료 기록 관리, 텍스트 기반 환자 커뮤니케이션 제공, 사전 조언 제공을 지원합니다. ChatGPT-4o: 환자 상호작용을 위한 오디오 입력을 처리하고 의료 설명을 위한 시각적 보조 자료를 생성하여 의료 서비스를 더욱 지원합니다. 엔터테인먼트 ChatGPT-4: 스크립트 및 텍스트 기반 콘텐츠를 생성할 수 있습니다. ChatGPT-4o: 오디오 및 시각적 콘텐츠 제작 기능으로 엔터테인먼트에 혁신을 가져와 더욱 몰입감 있는 대화형 경험을 제공합니다. 모델 안전 및 제한 사항 안전 기능 ChatGPT-4: 유해한 콘텐츠 필터링 및 윤리 가이드라인 유지 등 텍스트 생성에 초점을 맞춘 안전 조치를 통합합니다. ChatGPT-4o: 고급 필터링, 교육 후 조정, 음성 출력에 대한 새로운 안전 시스템으로 모든 양식에 걸쳐 안전성을 강화합니다. 광범위한 외부 테스트 및 평가를 통해 포괄적인 위험 관리를 보장합니다. 제한 사항 ChatGPT-4: 텍스트 상호 작용으로 제한되어 있어 다중 모달 이해가 필요한 시나리오에서 적용이 제한될 수 있습니다. ChatGPT-4o: 고도로 발전된 기술이지만 복잡한 감정을 이해하고 다중 화자 환경을 정확하게 해석하는 데 여전히 어려움이 있습니다. 이러한 한계를 해결하려면 지속적인 반복이 필요합니다. 출시 및 액세스 ChatGPT-4: 텍스트 기반 애플리케이션을 중심으로 다양한 플랫폼과 API를 통해 광범위하게 사용 가능합니다. ChatGPT-4o: 무료 티어와 메시지 한도가 더 높은 Plus 사용자에게 제공되는 ChatGPT의 텍스트 및 이미지 기능 출시. GPT-4o가 포함된 새로운 버전의 음성 모드가 곧 ChatGPT Plus에서 제공될 예정입니다. 개발자는 API를 통해 GPT-4o에 액세스할 수 있으며, 신뢰할 수 있는 파트너를 위해 오디오 및 비디오 기능이 출시됩니다. 향후 전망 ChatGPT-4: 텍스트 기반 애플리케이션을 위한 강력한 도구로 계속 유지되며, 점진적으로 개선될 가능성이 있습니다. ChatGPT-4o: AI를 일상 업무에 보다 원활하게 통합하기 위한 중요한 단계입니다. 향후 개발에는 향상된 감성 지능, 더 나은 컨텍스트 이해, 더 광범위한 멀티모달 기능이 포함될 수 있습니다. 결론 ChatGPT-4o는 ChatGPT-4의 강력한 기반 위에 구축되어 멀티 모달 처리와 실시간 상호작용에서 상당한 발전을 이루었습니다. 두 모델 모두 강점을 가지고 있지만, 텍스트, 오디오, 이미지를 통합하는 ChatGPT-4o의 기능은 다양한 애플리케이션을 위한 보다 다양하고 효율적인 도구로 차별화됩니다. AI가 계속 발전함에 따라 ChatGPT-4o에 도입된 혁신은 인간과 컴퓨터의 상호작용의 미래를 위한 유망한 방향성을 제시합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"ChatGPT-4","slug":"ChatGPT-4","permalink":"http://hgko1207.github.io/tags/ChatGPT-4/"},{"name":"ChatGPT-4o","slug":"ChatGPT-4o","permalink":"http://hgko1207.github.io/tags/ChatGPT-4o/"}]},{"title":"ChatGPT-4o 간략 정리","slug":"chatgpt-27","date":"2024-05-28T05:33:55.000Z","updated":"2024-05-28T05:41:27.597Z","comments":true,"path":"2024/05/28/chatgpt-27/","link":"","permalink":"http://hgko1207.github.io/2024/05/28/chatgpt-27/","excerpt":"","text":"1. AI 기반 기업인 OpenAI가 도입한 GPT-4란 무엇인가요? OpenAI에서 개발한 GPT-4는 사람과 유사한 텍스트를 이해하고 생성하도록 설계된 고급 언어 모델입니다. 이전 모델의 기능을 기반으로 구축되어 자연어 이해력, 문맥 인식 능력, 일관성 있는 대화 능력을 향상시켰습니다. 2. GPT-4o는 무료인가요? GPT-4o는 어느 정도 무료로 사용할 수 있습니다. ChatGPT의 무료 등급에서 이용할 수 있으며, Plus 사용자는 최대 5배 더 높은 메시지 제한 혜택을 누릴 수 있습니다. 그러나 특정 고급 기능과 더 높은 사용 한도를 사용하려면 구독이 필요할 수 있습니다. 3. GPT-4o가 GPT-4보다 더 나은가요? GPT-4o는 GPT-4의 향상된 버전입니다. 텍스트, 오디오, 이미지를 실시간으로 처리 및 생성할 수 있고, 응답 시간이 더 빠르며, 더 많은 언어를 지원하고, GPT-4에 비해 비용 효율성이 더 높습니다. 4. GPT-4o는 무엇을 할 수 있나요? GPT-4o는 텍스트, 오디오, 이미지를 이해하고 생성할 수 있습니다. 실시간 다중 모드 상호 작용을 지원하므로 교육, 비즈니스, 의료, 엔터테인먼트 등의 애플리케이션에 적합합니다. 대화에서 맥락을 유지하고 복잡한 언어 구조를 이해하는 데 탁월합니다. 5. ChatGPT는 언제까지 무료로 제공되나요? OpenAI는 ChatGPT의 무료 제공 종료일을 지정하지 않았습니다. 현재 모든 사용자가 무료 등급을 사용할 수 있으며, 사용에는 일정한 제한이 있습니다. 6. ChatGPT를 얼마나 오랫동안 무료로 사용할 수 있나요? 현재로서는 ChatGPT 무료 체험에 정해진 기간 제한이 없습니다. OpenAI가 무료 등급을 계속 제공하는 한 사용자는 무료 등급을 이용할 수 있습니다. 7. ChatGPT 4o로 무엇을 할 수 있나요? ChatGPT 4o를 사용하면 보다 자연스러운 대화형 대화에 참여하고, 교육 콘텐츠에 대한 지원을 받고, 비즈니스 작업을 자동화하고, 마케팅 자료를 만들고, 의료 커뮤니케이션을 관리하고, 향상된 엔터테인먼트 경험을 즐길 수 있습니다. 텍스트, 오디오, 이미지 입출력을 처리할 수 있습니다. 8. ChatGPT 4o의 새로운 기능은 무엇인가요? ChatGPT 4o는 멀티 모달 기능을 도입하여 텍스트, 오디오, 이미지를 실시간으로 처리하고 생성할 수 있습니다. 이전 모델보다 응답 시간이 빨라지고 언어 지원이 개선되었으며 비용 효율성이 향상되었습니다. 또한 고급 안전 기능과 더 나은 문맥 이해 기능도 포함되어 있습니다. 9. ChatGPT 4o는 무료인가요? ChatGPT 4o는 ChatGPT의 무료 티어 내에서 일정 범위 내에서 무료로 사용할 수 있습니다. 그러나 고급 기능과 더 높은 사용 한도를 사용하려면 ChatGPT Plus 요금제와 같은 구독이 필요할 수 있습니다. 10. GPT-4o의 특별한 점은 무엇인가요? GPT-4o는 텍스트, 오디오, 이미지를 실시간으로 처리하고 생성할 수 있다는 점에서 두드러집니다. 이 멀티 모달 기능 덕분에 더욱 다양하고 효율적으로 사용할 수 있습니다. 11 . 기업은 GPT-4o를 통해 어떤 이점을 얻을 수 있나요? 기업은 GPT-4o를 사용하여 고객 지원을 자동화하고, 콘텐츠를 생성하며, 운영을 간소화할 수 있습니다. 고급 대화 기술을 통해 고객과의 상호작용을 개선하고 효율성을 높일 수 있습니다. 12. GPT-4o는 사용하기에 안전한가요? OpenAI는 엄격한 윤리 지침과 개인정보 보호 조치를 구현하여 GPT-4o의 안전한 사용을 보장합니다. 그러나 사용자는 경계를 늦추지 말고 자신의 데이터가 보호되고 있는지 확인해야 합니다. 13. GPT-4o가 사람의 일자리를 대체하나요? GPT-4o가 특정 작업을 자동화할 수는 있지만, 반복적인 작업을 처리함으로써 인간의 역할을 보강할 가능성이 더 높습니다. 이를 통해 사람은 보다 전략적이고 창의적인 활동에 집중할 수 있어 잠재적으로 새로운 일자리를 창출할 수 있습니다. 14. GPT-4o를 사용하려면 어떻게 시작하나요? GPT-4o 사용을 시작하려면 OpenAI 웹사이트를 방문하여 모델 액세스 지침을 따르세요. 비즈니스와 개발자는 OpenAI의 API를 통해 애플리케이션에 GPT-4o를 통합할 수도 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"ChatGPT-4o","slug":"ChatGPT-4o","permalink":"http://hgko1207.github.io/tags/ChatGPT-4o/"}]},{"title":"OpenAI, ChatGPT-4o 출시","slug":"chatgpt-26","date":"2024-05-27T14:07:24.000Z","updated":"2024-05-27T14:27:19.630Z","comments":true,"path":"2024/05/27/chatgpt-26/","link":"","permalink":"http://hgko1207.github.io/2024/05/27/chatgpt-26/","excerpt":"","text":"소개 OpenAI는 인공지능과 상호작용하는 방식을 바꿀 최신 플래그십 모델인 GPT-4o를 공개했습니다. 다재다능한 기능으로 'omni’라고 불리는 이 새로운 모델은 텍스트, 오디오, 이미지를 실시간으로 처리하고 생성할 수 있습니다. 기술 발전에 관심이 많거나 인공지능에 대해 궁금한 점이 있다면 이번 발표가 획기적인 변화를 가져올 것입니다. GPT-4o가 무엇이며 왜 그렇게 중요한지 알아보세요. OpenAI란 무엇인가요? OpenAI는 인류를 위한 AI 기술 개발에 전념하는 선구적인 연구 기관입니다. 2015년 설립된 이래로 OpenAI는 AI 혁신의 선두에 서서 GPT 시리즈와 같은 혁신적인 기술을 제공해 왔습니다. GPT-4o를 향한 여정 GPT-1에서 GPT-4에 이르기까지, 각 버전은 자연어 처리에 상당한 발전을 가져왔습니다. GPT-4o는 보다 자연스러운 인간과 컴퓨터의 상호작용을 위해 여러 양식을 통합하는 최신의 도약을 나타냅니다. GPT-4o 이해하기 GPT-4o란 무엇인가요? GPT-4o는 OpenAI의 생성 언어 모델의 최신 버전입니다. 스트, 오디오, 이미지를 이해하고 생성하도록 설계되어 다양한 애플리케이션을 위한 다용도 도구로 사용할 수 있습니다. 이러한 멀티 모달 기능은 GPT-4o를 이전 버전과 차별화합니다. GPT-4o의 주요 기능 실시간 멀티 모달 처리: GPT-4o는 텍스트, 오디오, 이미지를 동시에 처리할 수 있어 원활한 상호작용이 가능합니다. 인간과 유사한 응답 시간: 최소 232 millisecond, 평균 320 millisecond 만에 오디오 입력에 응답하여 사람의 대화 속도와 유사합니다. 고급 언어 지원: 영어 텍스트와 코드에 대한 GPT-4 Turbo의 성능은 비슷하지만, 비영어권 언어에 대한 성능은 GPT-4o가 더 뛰어납니다. 비용 효율성: API를 통해 더 빠르고 50% 저렴하게 사용할 수 있어 접근성이 뛰어납니다. GPT-4o와 GPT-4의 차이점 GPT-4와 비교하여 GPT-4o는 다음을 제공합니다. 멀티 모달 기능: 텍스트, 오디오, 이미지를 하나의 통합된 모델로 처리합니다. 속도 및 비용: 응답 시간이 빨라지고 비용이 절감됩니다. 향상된 언어 지원: 비영어권 언어에 대한 성능 향상. GPT-4o의 기술 발전 향상된 자연어 이해력 복잡한 언어 구조를 이해하는 GPT-4o의 향상된 능력으로 더욱 미묘하고 맥락을 파악하는 상호작용이 가능해졌습니다. 이러한 개선은 풍자, 관용구 및 사람 말의 미묘한 차이를 이해하는 데 도움이 됩니다. 향상된 대화 능력 GPT-4o의 뛰어난 기능 중 하나는 긴 대화에서도 맥락을 유지하는 능력입니다. 이를 통해 상호 작용이 더 부드럽고 일관성 있게 이루어져 전반적인 사용자 경험이 향상됩니다. 고급 문맥 인식 GPT-4o는 기술적이든 일상적이든 대화의 폭넓은 맥락을 이해하는 데 탁월합니다. 대화의 흐름을 놓치지 않고 복잡한 쿼리를 처리하고 응답할 수 있습니다. 뛰어난 사용자 지정 기능 사용자 정의(Customization)는 GPT-4o의 핵심 강점입니다. 사용자는 특정 작업에 맞게 모델을 미세 조정할 수 있으므로 다양한 산업과 애플리케이션에 맞게 조정할 수 있습니다. 모델 안전 및 제한 사항 내장된 안전 기능 GPT-4o는 모달리티 전반에 걸쳐 고급 안전 기능을 통합합니다. 여기에는 훈련 데이터를 필터링하고 훈련 후 조정을 통해 모델의 동작을 개선하는 기능이 포함됩니다. 또한 음성 출력에 가드레일을 제공하기 위해 새로운 안전 시스템이 구현되었습니다. 대비 프레임워크 평가 GPT-4o는 자발적인 약속에 따라 OpenAI의 준비 프레임워크에 따라 철저한 평가를 거쳤습니다. 사이버 보안, 화학, 생물학, 방사능, 핵(CBRN) 위험, 설득력, 모델 자율성에 대한 평가 결과 GPT-4o는 어떤 범주에서도 중간 위험 수준을 초과하지 않는 것으로 나타났습니다. 이러한 평가에는 모델 훈련 과정 전반에 걸쳐 자동화된 테스트와 사람에 의한 테스트가 모두 포함되었으며, 안전 완화 전후 버전이 모두 포함되었습니다. 광범위한 외부 테스트 OpenAI는 사회 심리학, 편견과 공정성, 잘못된 정보 등 다양한 분야의 외부 전문가 70여 명을 참여시켜 광범위한 레드팀 테스트를 실시했습니다. 이를 통해 GPT-4o의 새로운 양식으로 인해 발생할 수 있는 잠재적 위험을 파악할 수 있었습니다. 이 테스트에서 얻은 인사이트는 GPT-4o의 안전 조치를 강화하는 데 사용되었으며, OpenAI는 새로운 위험이 발견되는 대로 이를 해결하기 위해 최선을 다하고 있습니다. 모달리티별 위험 GPT-4o의 오디오 기능은 새로운 위험을 초래합니다. 현재 OpenAI는 텍스트 출력과 함께 텍스트 및 이미지 입력을 출시하고 있습니다. 앞으로 몇 주에서 몇 달 동안 다른 양식도 출시하는 데 필요한 기술 인프라와 안전 조치를 마련할 예정입니다. 예를 들어, 출시 시 오디오 출력은 사전 설정된 일부 음성으로 제한되며 기존의 안전 정책을 준수할 것입니다. 자세한 내용은 향후 시스템 카드에 제공될 예정입니다. 한계 고급 기능에도 불구하고 GPT-4o에는 몇 가지 한계가 있습니다. 여기에는 복잡한 감정을 이해하거나 다중 화자 환경을 정확하게 해석하는 것과 같은 모든 양식에 걸친 과제가 포함됩니다. 이러한 문제를 해결하려면 지속적인 테스트와 반복이 필수적입니다. 모델 가용성 실용적인 사용성 GPT-4o는 딥러닝의 실질적인 사용성을 향한 중요한 진전을 의미합니다. 지난 2년 동안 OpenAI는 모든 계층에서 효율성을 개선하는 데 집중하여 GPT-4 수준의 모델을 보다 광범위하게 제공할 수 있게 되었습니다. 롤아웃 및 액세스 무료 티어 사용자와 최대 5배 더 높은 메시지 한도를 누릴 수 있는 플러스 사용자 모두 사용할 수 있는 ChatGPT에서 GPT-4o의 텍스트 및 이미지 기능이 출시됩니다. 향후 몇 주 내에 ChatGPT 플러스 사용자들을 위한 새로운 버전의 GPT-4o 음성 모드가 알파 버전으로 제공될 예정입니다. 개발자 액세스 이제 개발자는 텍스트 및 비전 애플리케이션용 API를 통해 GPT-4o에 액세스할 수 있습니다. GPT-4o는 GPT-4 터보에 비해 2배 더 빠르고 가격은 절반이며 5배 더 높은 속도 제한을 지원합니다. 오디오 및 비디오 기능은 향후 몇 주 내에 API의 일부 신뢰할 수 있는 파트너 그룹에 제공될 예정입니다. GPT-4o의 활용 분야 교육 분야 GPT-4o는 개인 맞춤형 과외, 숙제 지원, 교육 콘텐츠 제작을 통해 교육을 혁신할 수 있습니다. 멀티 모달 기능을 통해 학습을 더욱 인터랙티브하고 매력적으로 만들 수 있습니다. 비즈니스 분야 기업은 고객 지원, 일상적인 업무 자동화, 마케팅 콘텐츠 제작에 GPT-4o를 활용할 수 있습니다. 고급 대화 기술을 통해 고객과의 상호작용을 개선하고 만족도를 높일 수 있습니다. 의료 분야 의료 분야에서 GPT-4o는 환자 커뮤니케이션을 지원하고, 기록을 관리하며, 예비 의료 조언을 제공할 수 있습니다. 복잡한 의료 정보를 이해하고 처리하는 능력은 의료 서비스 제공자가 더 나은 치료를 제공할 수 있도록 지원할 수 있습니다. 엔터테인먼트 분야 스크립트 작성부터 인터랙티브 콘텐츠 생성까지, GPT-4o의 기능은 엔터테인먼트 산업에 혁신을 가져올 수 있습니다. 크리에이터가 시청자를 위해 더욱 매력적이고 개인화된 콘텐츠를 제작하는 데 도움이 될 수 있습니다. GPT-4o가 사회에 미치는 영향 윤리적 고려 사항 GPT-4o의 고급 기능은 중요한 윤리적 문제를 제기합니다. 책임감 있는 사용을 어떻게 보장할 수 있을까요? OpenAI는 오용을 방지하고 투명성을 높이기 위해 윤리적 지침을 강조합니다. 고용 시장의 혁신 GPT-4o의 도입은 의심할 여지 없이 고용 시장에 영향을 미칠 것입니다. 일부에서는 일자리가 사라질 것이라고 우려하지만, GPT-4o는 인간의 역할을 보강하여 반복적인 업무를 대신하고 사람들이 보다 전략적이고 창의적인 노력에 집중할 수 있도록 할 가능성이 더 높습니다. 개인정보 보호 우려 모든 AI와 마찬가지로 개인정보 보호는 주요 관심사입니다. OpenAI는 GPT-4o가 데이터 보호 규정을 준수하고 사용자 프라이버시를 우선시할 수 있도록 최선을 다하고 있습니다. 사용자도 자신의 데이터가 어떻게 사용되고 저장되는지 주의해야 합니다. GPT-4o의 미래 전망 잠재적 발전 GPT-4o의 미래는 밝습니다. 지속적인 연구와 개발을 통해 더욱 정교한 언어 모델을 제공할 수 있습니다. 향후 버전에서는 감성 지능이 향상되고, 문맥에 대한 이해도가 높아지며, 적응력이 향상될 수 있습니다. 다른 기술과의 통합 GPT-4o는 시작에 불과합니다. 증강 현실이나 로보틱스와 같은 다른 기술과 통합한다고 상상해 보세요. 이러한 시너지 효과는 일상 업무를 더욱 원활하고 자동화하여 오늘날 우리가 꿈꿀 수 있는 혁신으로 이어질 수 있습니다. 결론 OpenAI의 Chat GPT-4o 출시는 AI의 진화에 있어 중요한 이정표가 될 것입니다. 이 고급 기능은 다양한 분야에 혁신을 가져올 것이며, 기술과의 상호작용을 더욱 자연스럽고 직관적으로 만들 것입니다. 해결해야 할 과제가 있지만, GPT-4o의 잠재적 이점은 우려되는 것보다 훨씬 큽니다. 미래를 바라보며 GPT-4o가 열어갈 가능성을 상상하는 것은 흥미로운 일입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"ChatGPT-4o","slug":"ChatGPT-4o","permalink":"http://hgko1207.github.io/tags/ChatGPT-4o/"}]},{"title":"[TypeScript] Interfaces vs Classes vs Types","slug":"typescript-24","date":"2024-05-24T04:57:41.000Z","updated":"2024-05-24T05:16:07.160Z","comments":true,"path":"2024/05/24/typescript-24/","link":"","permalink":"http://hgko1207.github.io/2024/05/24/typescript-24/","excerpt":"","text":"타입스크립트 개발자는 인터페이스, 클래스 또는 타입을 언제 활용해야 하는지 이해하는 것이 유지 관리가 가능하고 확장 가능한 코드를 만드는 데 매우 중요합니다. 각 구성 요소의 미묘한 차이를 분석하여 TypeScript 프로젝트의 다양한 시나리오에 적합한 도구에 대해 현명한 결정을 내릴 수 있도록 안내합니다. Interface 목적 객체에 대한 컨트랙트를 정의하는 데 사용됩니다. 주로 객체의 모양을 설명하고 프로퍼티와 메서드의 예상 구조를 정의하는 데 사용됩니다. 주요 특징 구현 세부 사항을 포함할 수 없습니다. 새로운 인터페이스를 만들기 위해 확장할 수 있습니다. implements 키워드로 상속을 지원합니다. 클래스에서 구현할 수 있으며, 클래스가 특정 구조를 준수하도록 강제하는 방법을 제공합니다. 예제 12345678910111213interface Person &#123; name: string; age: number; greet(): void;&#125;class Student implements Person &#123; name: string = ''; age: number = 0; greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125; Class 목적 blueprint (class)를 기반으로 객체를 만드는 데 사용됩니다. 데이터(속성)와 동작(메서드)을 하나의 단위로 캡슐화합니다. 상속 및 캡슐화와 같은 개념을 지원합니다. 주요 특징 프로퍼티 선언과 메서드 구현을 모두 포함할 수 있습니다. 객체를 초기화하기 위한 생성자를 지원합니다. extends 키워드를 사용하여 다른 클래스를 확장할 수 있습니다. 접근 수정자(public, private, protected)를 사용하여 가시성을 제어할 수 있습니다. 예제 123456789101112131415161718192021class Animal &#123; private _name: string; constructor(name: string) &#123; this._name = name; &#125; get name(): string &#123; return this._name; &#125; makeSound() &#123; console.log('Generic animal sound.'); &#125;&#125;class Dog extends Animal &#123; makeSound() &#123; console.log('Woof!'); &#125;&#125; Type 목적 타입의 별칭을 만드는 데 사용됩니다. 주로 복잡한 타입 조합을 만들거나 기존 타입에 대한 설명적인 이름을 제공하는 데 사용됩니다. 주요 특징 새 타입을 만들지 않고 기존 타입의 별칭을 만듭니다. primitive type, union type, intersection type 등에 사용할 수 있습니다. 재사용 가능한 타입 패턴을 만들기 위한 제네릭을 지원합니다. 예제 123456789101112131415type Point = &#123; x: number; y: number;&#125;;type Result = 'success' | 'error';type User = &#123; id: number; name: string;&#125;;type Admin = User &amp; &#123; role: 'admin';&#125;; 각각의 사용 시기 다음과 같은 경우 Interface를 사용하십시오. 객체의 모양을 설명할 때. 클래스에 대한 컨트랙트 적용. 다음과 같은 경우 Class를 사용하십시오. 동작과 상태를 가진 객체를 만들 때. 데이터와 메서드 캡슐화. 다음과 같은 경우 Type을 사용하십시오. 재사용 가능한 타입 별칭 만들기. 기존 타입을 결합하거나 수정할 때. 마무리 인터페이스와 클래스가 함께 사용되는 경우가 많은데, 인터페이스는 구조를 정의하고 클래스는 그 구조를 구현합니다. 타입은 더 복잡한 타입 시나리오에 사용되거나 특히 union 타입이나 intersection의 맥락에서 타입에 대한 설명적인 이름을 제공하는 데 자주 사용됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Type","slug":"Type","permalink":"http://hgko1207.github.io/tags/Type/"}]},{"title":"ChatGPT 개발자 가이드","slug":"chatgpt-25","date":"2024-05-23T06:38:00.000Z","updated":"2024-05-23T14:20:49.054Z","comments":true,"path":"2024/05/23/chatgpt-25/","link":"","permalink":"http://hgko1207.github.io/2024/05/23/chatgpt-25/","excerpt":"","text":"개발자 여러분! 반복되는 작업에 좌절감을 느끼거나 UI 프로토타입을 아무 생각 없이 바라보고 계신가요? 웹 개발의 숨겨진 도구가 될 수 있는 강력한 AI 도구인 ChatGPT에 대해 알아보세요. 프로토타입에서 완성까지 훌륭한 앱 아이디어가 있지만 UI 디자인을 실행에 옮기기가 어렵다고 상상해 보세요. 이때 ChatGPT가 도움이 됩니다! 기능 및 시각적 디자인에서 원하는 것을 설명하면 ChatGPT가 HTML, CSS, 심지어 React 또는 Vue.js와 같은 프레임워크용 코드 스니펫을 생성합니다. 이렇게 하면 개발 프로세스가 시작되므로 로직과 사용자 경험에 집중할 수 있습니다. 스토리 디버깅 마스터하기 이해하기 어려운 오류 메시지를 보고 머리를 긁적거린 적이 있을 것입니다. ChatGPT는 디버깅 전문가가 되어드립니다. 문제 메시지를 전달하면 코드를 검토하고 가능한 수정 사항을 제안하며 특정 문제를 해결하기 위한 단위 테스트까지 생성합니다. 이 정확한 전략으로 문제 해결에 소요되는 시간을 절약할 수 있습니다. 기존 워크플로우에 맞는 ChatGPT 워드프레스 전문가든 코드 유연성이 뛰어난 사용자든 ChatGPT는 쉽게 통합할 수 있습니다. 블로그 게시물에 대한 SEO 친화적인 메타 설명을 작성하는 데 어려움을 겪고 계신가요? ChatGPT는 콘텐츠에 따라 자동으로 메타 설명을 생성할 수 있습니다. 따라서 뛰어난 콘텐츠를 만드는 데 집중할 수 있습니다. 깔끔한 코드, 효율적인 사용자 ChatGPT는 사용자 로그인, 양식 처리 및 기타 일상적인 작업을 위한 상용구 코드를 생성하는 코드 생성 조수가 될 수 있습니다. 하지만 ChatGPT의 창의성에는 개발자의 기술이 필요할 수 있다는 점을 명심하세요. 고품질 코드를 만드는 방법은 다음과 같습니다. 보안: 항상 최종 코드에 보안 허점이 있는지 확인하세요. SQL injection 및 XSS(cross-site scripting)과 같은 일반적인 위험 요소가 있는지 확인하세요. 단순히 ChatGPT에만 의존하여 코드를 보호하지 마세요. 효율성 프로텍터: 반복적인 작업은 ChatGPT에 맡기고 고급 사고와 문제 해결에 집중하세요. 인간의 창의적인 사고가 필요한 작업에 집중할 수 있도록 도와주는 코딩 도우미라고 상상해 보세요. 잠재력을 최대한 발휘할 수 있는 고급 기술 접근성 지원: 접근성 표준을 충족하는 코드를 생성하는 프롬프트를 생성하여 모든 사람이 웹사이트에 액세스할 수 있도록 보장합니다. 이는 단순히 웹사이트를 기능적으로 만드는 것을 넘어 모든 사용자에게 좋은 경험을 제공하는 것입니다. API: 특정 API와 통합해야 하나요? API의 작동을 정의하는 철저한 프롬프트를 작성하면 ChatGPT가 쉽게 통합할 수 있는 코드를 생성합니다. 이렇게 하면 문서를 이해하고 상용구 코드를 개발하는 데 소요되는 시간을 절약할 수 있습니다. 제한 사항 및 책임감 있는 사용 ChatGPT는 강력하지만 그 한계를 이해하는 것이 중요합니다. 결함이 있을 수 있으며 항상 유용한 코드를 생성하지 못할 수도 있습니다. 올바른 사용 방법은 다음과 같습니다. 개발자처럼 생각하세요: ChatGPT가 생성하는 모든 것을 그대로 받아들이지 마세요. 개발자의 판단과 기술에 따라 코드를 검토하고 업데이트하세요. ChatGPT는 여러분의 비판적 사고를 대체하는 도구가 아니라 여러분을 도와주는 도구입니다. 미래는 지금입니다: ChatGPT와 같은 AI 도구가 웹 개발을 변화시키고 있습니다. 코딩의 창의적인 부분에 집중하면서 효율성을 높일 수 있는 기회를 잡으세요. 어려운 문제를 해결하고 특별한 웹 경험을 만드는 데 집중하는 동안 지루한 작업은 ChatGPT가 처리하도록 맡기세요. 마무리 ChatGPT는 단순히 효율적인 코드 생성기가 아닙니다. 프로세스를 최적화하고 문제를 해결하며 전반적인 개발 효율성을 높이는 데 효과적인 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"모든 웹 개발자에게 필요한 7가지 최고의 AI Custom GPTs","slug":"web-13","date":"2024-05-22T12:24:40.000Z","updated":"2024-05-22T12:52:34.678Z","comments":true,"path":"2024/05/22/web-13/","link":"","permalink":"http://hgko1207.github.io/2024/05/22/web-13/","excerpt":"","text":"궁지에 몰린 상황에서 마법의 지니가 나타나 이상적인 코드 줄을 만들어 주었으면 좋겠다고 생각한 적이 있으신가요? 이제 웹 개발의 미래가 Custom GPTs라는 이름으로 다가왔습니다. Custom GPTs란 무엇이며 왜 관심을 가져야 할까요? Custom GPTs(Generative Pre-trained Transformers)는 방대한 양의 코드와 데이터로 학습된 AI 전문가입니다. 이들은 다양한 창의적인 텍스트 양식을 개발하고, 언어를 번역하고, 다양한 유형의 창의적인 콘텐츠를 작성하고, 사용자가 묻는 말에 지시 방식으로 응답할 수 있습니다. 웹 개발자에게는 초능력이 가득한 도구 세트를 의미합니다. 효율성 향상: 상용구 코드를 작성하고 구문을 찾느라 시간을 낭비하지 않아도 됩니다. GPT는 코드 스니펫을 순식간에 생성할 수 있습니다! 오류 감소: 오타와 버그와 작별하세요. GPT는 잠재적인 오류를 감지하고 수정을 제안할 수 있습니다. 전문 기술 활용: 접근성 모범 사례나 완벽한 문서 작성에 도움이 필요하신가요? 아마도 GPT가 도와드릴 수 있을 것입니다. 아래에서는 7가지 Custom GPTs 소개를 하겠습니다. 1. Javascript Mentor Javascript Mentor 설명: 구문, 모범 사례 및 문제 해결을 포함하여 JavaScript 개발에 대한 지침과 지원을 제공합니다. 전문성: 프런트엔드 및 풀스택 개발. 주요 기능: 코드 제안, 오류 감지, 복잡한 개념에 대한 설명. 대상 고객: JavaScript 기술을 향상시키려는 초급 및 중급 개발자에게 적합합니다. 가치 제안: 개발자가 더 깔끔하고 효율적인 JavaScript 코드를 작성하고 학습 과정을 가속화할 수 있도록 도와줍니다. 2. Material Tailwind GPT Material Tailwind GPT 설명: 머티리얼 디자인 원칙에 따라 Tailwind CSS 코드를 생성합니다. 전문 분야: 프론트엔드 디자인 및 UI 개발. 주요 기능: 신속한 프로토타이핑, 반응형 레이아웃 제안 및 색 구성표 생성. 대상 고객: 시각적으로 매력적이고 일관된 디자인을 목표로 하는 UI/UX 디자이너와 개발자에게 적합합니다. 가치 제안: 머티리얼 디자인 가이드라인을 준수하면서 디자인 프로세스의 속도를 높일 수 있습니다. 3. Bootstrap Buddy GPT Bootstrap Buddy GPT 설명: 부트스트랩 기반 레이아웃과 컴포넌트를 만드는 데 도움을 줍니다. 전문성: 프론트엔드 개발 및 반응형 디자인. 주요 기능: 템플릿 생성, 그리드 시스템 권장 사항 및 컴포넌트 사용자 지정 팁을 제공합니다. 대상 고객: 부트스트랩 프레임워크로 작업하는 개발자에게 적합합니다. 가치 제안: 부트스트랩을 사용하여 반응이 빠르고 사용자 친화적인 웹 인터페이스 생성을 간소화합니다. 4. Python Mentor Python Mentor 설명: 구문, 라이브러리 및 프로젝트 구조를 다루는 Python 프로그래밍에 대한 지침과 지원을 제공합니다. 전문 분야: 백엔드 개발 및 데이터 과학. 주요 기능: 코드 완성, 디버깅 지원, 라이브러리 권장 사항을 제공합니다. 대상 고객: 초보자부터 고급 사용자까지 다양한 Python 개발자를 지원합니다. 가치 제안: 실시간 지원을 제공하고 코드 품질을 개선하여 Python 개발을 용이하게 합니다. 5. PHP Mentor PHP Mentor 설명: 구문, 보안 관행, 성능 최적화 등 PHP 개발을 위한 멘토링과 제안을 제공합니다. 전문 분야: 백엔드 웹 개발. 주요 기능: 코드 유효성 검사, 보안 검사, 데이터베이스 통합 팁을 제공합니다. 대상 고객: 기술을 향상시키고 강력한 웹 애플리케이션을 구축하고자 하는 PHP 개발자를 대상으로 합니다. 가치 제안: 개발자가 안전하고 효율적인 PHP 코드를 작성하는 동시에 전반적인 프로젝트 품질을 개선할 수 있도록 도와줍니다. 6. SQL Mentor SQL Mentor 설명: SQL 쿼리 작성, 데이터베이스 성능 최적화, 관계형 데이터베이스 개념 이해에 도움을 줍니다. 전문 분야: 데이터베이스 관리 및 백엔드 개발. 주요 기능: 쿼리 제안, 데이터베이스 스키마 설계 지원 및 성능 튜닝 팁을 제공합니다. 대상 고객: MySQL 또는 PostgreSQL과 같은 관계형 데이터베이스로 작업하는 개발자에게 적합합니다. 가치 제안: 개발자가 효율적인 SQL 쿼리를 작성하고 확장 가능한 데이터베이스 구조를 설계할 수 있도록 지원합니다. 7. JSX Mentor JSX Mentor 설명: React 및 기타 JavaScript 프레임워크에서 사용되는 JSX 구문을 지원합니다. 전문화: React를 사용한 프론트엔드 개발. 주요 기능: 컴포넌트 제안, 프로퍼티 유효성 검사, JSX 구문 검사. 대상 고객: 워크플로우를 간소화하고 코드 품질을 개선하고자 하는 React 개발자에게 적합합니다. 가치 제안: 실시간 피드백과 코드 제안을 제공하여 React 개발의 생산성을 향상시킵니다. 모범 사례 및 팁 관련 프롬프트와 예제를 사용하여 모델을 미세 조정하세요. 올바른 결과를 위해 입력/출력 형식을 일관되게 처리하세요. 요청 범위를 줄이고 핵심 작업에 집중하여 속도를 최적화하세요. 결론 제가 지적하고 싶은 것은 Custom GPTs가 웹 개발 접근 방식을 전환할 수 있는 엄청난 가능성을 가지고 있다는 것입니다. 개발자는 이러한 특정 모델을 사용하여 생산성을 높이고 오류를 줄이며 개발 프로세스의 다양한 측면에 대한 전문가의 조언을 얻을 수 있습니다. 초보자든 숙련된 개발자든 툴킷에 사용자 지정 GPT를 추가하면 생산성과 프로젝트 성과를 높일 수 있습니다. 제공되는 모델을 실험해보고 피드백과 경험을 공유하여 웹 개발에서 AI를 향상시키는 데 도움을 주세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Gpt","slug":"Gpt","permalink":"http://hgko1207.github.io/tags/Gpt/"},{"name":"Customgpt","slug":"Customgpt","permalink":"http://hgko1207.github.io/tags/Customgpt/"}]},{"title":"모든 개발자에게 필요한 시간 절약형 웹사이트 10가지","slug":"web-12","date":"2024-05-21T13:21:03.000Z","updated":"2024-05-21T13:35:33.259Z","comments":true,"path":"2024/05/21/web-12/","link":"","permalink":"http://hgko1207.github.io/2024/05/21/web-12/","excerpt":"","text":"끝없이 이어지는 개발 작업으로 하루가 부족하다고 생각한 적이 있나요? 여러분은 혼자가 아닙니다. 완벽한 디자인 제작부터 고급 백엔드 로직 관리까지, 웹 개발에는 시간이 많이 걸리는 과제가 많습니다. 걱정하지 마세요, 동료 개발자 여러분! 이 글에서는 워크플로우를 개선하고 중요한 작업, 즉 훌륭한 콘텐츠를 만드는 데 시간을 절약하는 데 도움이 되는 강력한 웹사이트의 보물창고를 제공합니다. 1. Documatic Documatic Documatic은 프로젝트 문서 개발 과정을 줄여줍니다. API 참조부터 사용자 가이드까지, 이 플랫폼은 유연한 템플릿과 사용자 친화적인 편집 도구를 제공하여 코드 기반을 쉽게 문서화할 수 있습니다. 프론트엔드 및 백엔드 개발자 모두에게 적합합니다. 2. transform transform Transform은 디자이너와 개발자 모두를 위한 강력한 도구입니다. 사진 압축, SVG 최적화 및 색상 수정을 위한 도구 모음을 제공하여 온라인 자산의 효율성과 심미성을 모두 개선합니다. 3. Convertio Convertio Convertio는 파일 형식을 다루는 수고를 덜어줍니다. 이 유연한 프로그램은 300개 이상의 파일 형식을 지원하여 사진, 문서, 동영상 등을 쉽게 변환할 수 있습니다. 프로젝트에서 효과적인 파일 관리를 위한 필수품입니다. 4. Code Beautify Code Beautify 지저분한 코드에 지치셨나요? Code Beautify는 코드 서식 지정 및 유효성 검사 도구 세트를 제공합니다. HTML, CSS, JavaScript, JSON 등 어떤 종류의 코드든 이 플랫폼을 사용하면 코드를 깔끔하고 체계적으로 정리할 수 있습니다. 5. Zapier Zapier Zapier는 여러 애플리케이션과 서비스에서 일상적인 작업을 자동화하여 워크플로우를 개선합니다. 자주 사용하는 도구를 연결하고 'Zaps’를 구성하여 데이터 동기화, 알림 등의 작업을 자동화하면 업무 시간을 크게 절약할 수 있습니다. 6. Ray Ray Ray를 사용하면 디버깅이 더 쉬워집니다. 이 다용도 도구를 사용하면 코드를 실시간으로 쉽게 추적하고 검토할 수 있습니다. 직관적인 UI와 원활한 통합 덕분에 디버깅이 그 어느 때보다 효율적이 되었습니다. 7. Z-Library Z-Library Z-Library에서는 방대한 콘텐츠 저장소에 액세스할 수 있습니다. 이 웹사이트는 전자책부터 학술 논문까지 모든 분야에 걸쳐 다양한 콘텐츠를 제공하여 개발자에게 유용한 인사이트와 정보를 제공합니다. 8. Roadmap.sh Roadmap.sh Roadmap.sh로 학습 여정을 시작하세요. 이 포괄적인 리소스는 잠재적인 개발자가 프론트엔드, 백엔드 및 풀스택 개발의 복잡한 세계를 관리할 수 있도록 엄선된 학습 경로와 로드맵을 제공합니다. 9. Flow CV Flow CV Flow CV를 사용해 입사 지원 절차를 간소화하세요. 간편한 편집기와 조정 가능한 템플릿을 통해 뛰어난 이력서와 커버 레터를 쉽게 만들 수 있습니다. 전문적인 자료로 더 빠르게 완벽한 일자리를 찾으세요. 10. Unminify Unminify Unminify는 축소된 코드를 제거하여 더 빠른 디버깅과 분석을 위해 명확하고 편집 가능한 상태로 만듭니다. JavaScript, CSS, HTML 등 어떤 코드를 사용하든 이 도구를 사용하면 압축된 코드 스니펫을 더 쉽게 읽을 수 있습니다. 마무리 이러한 웹사이트는 보다 생산적이고 재미있는 프로그래밍 경험을 위한 간과하기 쉬운 도구입니다. 매력적인 새 작업에 도전하거나, 어려운 문제를 더 깊이 파고들거나, 정시에 퇴근할 수 있는 시간을 확보할 수 있다고 생각해보세요! 당장 시작해보세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Developer Tools","slug":"Developer-Tools","permalink":"http://hgko1207.github.io/tags/Developer-Tools/"},{"name":"Productivity Tools","slug":"Productivity-Tools","permalink":"http://hgko1207.github.io/tags/Productivity-Tools/"}]},{"title":"최고 수준의 프리랜서 웹 개발자가 되기 위한 궁극의 가이드","slug":"web-11","date":"2024-05-17T05:17:25.000Z","updated":"2024-05-17T05:34:07.127Z","comments":true,"path":"2024/05/17/web-11/","link":"","permalink":"http://hgko1207.github.io/2024/05/17/web-11/","excerpt":"","text":"프리랜서의 자유와 유연성을 위해 9시부터 6시까지 일하는 것을 포기하는 것은 매우 흥미로운 일처럼 들리지 않나요? 하지만 클라이언트 풀에 완전히 뛰어들기 전에 몇 가지 중요한 기초 작업을 해야 합니다. 이 글에서는 프리랜서 웹 개발자가 되는 흥미진진하고도 어려운 길을 안내합니다. 기술 스택 마스터하기 사용하는 기술이 신뢰할 수 있는 도구 상자라고 상상해 보세요. 훌륭한 웹사이트를 만들려면 4가지 필수 분야에 대한 탄탄한 기초가 필요합니다. 프론트엔드(Front-end): HTML, CSS, JavaScript는 사용자 대상 콘텐츠를 제작하는 데 필수적인 요소입니다. 웹 페이지를 구조화하고, CSS를 사용해 디자인하고, 자바스크립트로 상호작용을 추가하는 방법을 알아보세요. React 및 Vue.js와 같은 프레임워크는 복잡한 사용자 인터페이스를 효과적으로 디자인하는 데 도움이 될 수 있습니다. 백엔드(Back-end): Python, PHP, Ruby는 데이터베이스 작업과 사용자 요청을 처리하는 몇 가지 서버 측 프로그래밍 언어입니다. 프레임워크: 이러한 사전 작성된 라이브러리는 웹용 앱을 더 빠르고 깔끔하게 구축하기 위한 기반 역할을 합니다. 인기 있는 프레임워크는 Laravel(PHP), Django(Python), Express.js(JavaScript)와 관련이 있습니다. 버전 관리 시스템: Git과 같은 도구는 코드 변경 사항을 추적하여 다른 사람과 공동 작업하고 필요에 따라 이전 버전으로 복원할 수 있도록 해줍니다. 소프트 스킬 향상 코딩 기술은 퍼즐의 한 조각일 뿐입니다. 프리랜서 스타가 되는 데 도움이 될 수 있는 비기술적인 기술을 소개합니다. 커뮤니케이션: 기술적인 전문 용어를 고객에게 간단하고 명확한 설명으로 바꾸세요. 적극적으로 경청하고 고객의 요구 사항을 이해하는 것이 중요합니다. 시간 관리: 이제 여러분이 상사이기 때문에 마감일을 관리하고 지연을 방지해야 합니다. 프로젝트 관리 도구를 마스터하고 체계적으로 관리하세요! 고객과의 상호작용: 고객과 강력한 관계를 구축하세요. 수요를 관리하기 위한 전문적이고 대응력 있는 사전 예방적 전략을 세우세요. 셀프 마케팅: 세상은 어떻게든 여러분을 찾지 않을 것입니다. 매력적인 포트폴리오 웹사이트를 만들고, 온라인과 오프라인에서 네트워크를 형성하고, 소셜 미디어에서 강력한 인지도를 확보하여 프로필을 강화하세요. 브랜드 구축 포트폴리오 웹사이트는 가상의 쇼룸입니다. 포트폴리오 웹사이트를 빛나게 만드는 방법은 다음과 같습니다. 쇼케이스: 프로젝트만 나열하지 말고 스토리를 공유하세요! 여러분의 다양한 기술을 보여줄 수 있는 프로젝트를 추가하세요. 문제에 어떻게 집중하여 고객을 위한 결과를 얻었는지 보여주는 사례 연구를 제공하는 것도 좋습니다. 프레젠테이션이 중요합니다: 깔끔하고 사용자 친화적이며 사용하기 쉬운 디자인은 필수입니다. 시각적으로 아름답고 뛰어난 디자인으로 코딩 실력을 보여주세요. 웹 개발이 처음이라면 포트폴리오 웹사이트 빌더나 기본 템플릿 기반 방법을 사용하는 것이 좋습니다. 기술을 익히면 브랜드를 뽐낼 수 있는 맞춤형 포트폴리오 사이트를 만들 수 있습니다. 바이오 및 가치 제안: 내가 누구인지, 새로운 고객이 나를 선택해야 하는 이유를 간단히 설명하세요. 여러분의 특별한 기술과 전문성, 그리고 프로젝트에 추가할 수 있는 가치를 강조하세요. 가능한 한 자신의 성공 사례를 들어 자신이 가진 영향력을 보여주세요. 고객 및 프로젝트 찾기 이제 그 꿈을 실현할 차례입니다! 두 가지 주요 전략이 있습니다. 프리랜서 플랫폼: 이랜서, 크몽, 위시켓 등은 프리랜서 일자리를 찾는 데 인기 있는 옵션입니다. 이러한 플랫폼은 시작하고 경험을 쌓는 데 좋은 방법이 될 수 있지만, 장기적으로 이러한 플랫폼에만 의존해서는 안 됩니다. 장점: 대규모 고객층에 쉽게 접근할 수 있습니다. 단점: 경쟁이 매우 치열하고 요금이 저렴합니다. 직접 홍보: 고객에게 직접 연락하여 주도권을 잡으세요. 콜드 이메일, LinkedIn 또는 업계 소셜 이벤트를 통해 비즈니스에 다가갈 수 있습니다. 이 전략은 평판과 네트워크를 구축하면 장기적으로 더 나은 결과를 얻을 수 있습니다. 장점: 고객과 개인적인 관계를 구축하여 잠재적으로 더 높은 가격을 받을 수 있습니다. 단점: 처음에 고객을 찾는 데 더 많은 노력이 필요합니다. 비즈니스 필수 요소 프리랜서는 소규모 비즈니스를 운영하는 것과 비슷한 느낌입니다. 알아두어야 할 사항은 다음과 같습니다. 요금 및 계약 설정: 경쟁 업체를 조사하고 자신의 가치를 파악하여 합리적인 요금을 설정하세요. 자신의 경험, 위치, 프로젝트의 복잡성, 간접비 등을 고려하세요. 항상 프로젝트 범위, 날짜, 지불 조건, 소유권이 명시된 명확하고 법적으로 유효한 계약서를 사용하세요. 강력한 계약서는 여러분과 고객 모두를 오해로부터 보호합니다. 재무 관리: 스스로 회계사가 되세요(또는 최소한 기본을 익히세요)! 회계 소프트웨어나 Excel 스프레드시트를 통해 지출을 추적하고, 송장을 처리하고, 세금을 위한 자금을 설정하세요. 거주 지역에 맞는 세금 관련 조언을 구하려면 전문가와 상담하세요. 세금 신고를 마지막 순간까지 미루지 마세요. 예산은 부진한 기간과 예상치 못한 지출에 대비해 계획하는 데 필수적입니다. 인보이스 발행 도구와 프로젝트 관리 소프트웨어를 사용하면 비용을 간소화하고 체계적으로 관리할 수 있습니다. 위험 구역 피하기 아무리 숙련된 프리랜서라도 이러한 함정에 빠질 수 있습니다. 자신을 과소평가하는 것: 자신의 실력을 과소평가하지 마세요! 자신의 스킬 세트와 지역에 맞는 평균 요금을 찾아보세요. 단순히 코드만 판매하는 것이 아니라 시간, 경험, 문제 해결 능력도 판매하고 있다는 사실을 기억하세요. 범위 증가: 프로젝트 증가는 고객이 초기 계약에서 벗어난 새로운 기능이나 요청을 추가하려고 할 때 발생합니다. 이로 인해 수익률이 감소하고 지연이 발생할 수 있습니다. 계약서에 명확한 프로젝트 범위를 설정하고 추가 요구 사항을 처리할 수 있는 변경 주문 시스템을 마련하세요. 자기 관리 소홀: 상사가 된다는 것은 스스로 근무 시간을 정할 수 있는 기회를 제공하지만, 동시에 제한을 설정해야 한다는 의미이기도 합니다. 번아웃을 피하려면 휴식 시간을 계획하고 일과 삶의 균형을 유지하며 건강을 최우선으로 생각하세요. 지친 프리랜서에게 도움이 되는 사람은 아무도 없습니다! 마지막 프리랜서는 도전과 성취로 가득한 만족스러운 산업입니다. 프리랜서 웹 개발로 성공하려면 기술 및 소프트 재능을 연마하고, 강력한 브랜드를 만들고, 비즈니스 측면을 배워야 합니다. 목표만큼이나 중요한 것이 여정이라는 사실을 잊지 마세요. 학습 과정을 즐기고, 기술을 계속 발전시키며, 가장 중요한 것은 스스로 상사가 되는 자유와 유연성을 누리는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Freelancing","slug":"Freelancing","permalink":"http://hgko1207.github.io/tags/Freelancing/"},{"name":"Freelancers","slug":"Freelancers","permalink":"http://hgko1207.github.io/tags/Freelancers/"},{"name":"Freelance","slug":"Freelance","permalink":"http://hgko1207.github.io/tags/Freelance/"}]},{"title":"지금 필요한 7가지 웹 개발 필수 요소","slug":"web-10","date":"2024-05-16T04:34:47.000Z","updated":"2024-05-16T04:57:57.904Z","comments":true,"path":"2024/05/16/web-10/","link":"","permalink":"http://hgko1207.github.io/2024/05/16/web-10/","excerpt":"","text":"코딩 초보자이든 코딩 전문가이든 웹 개발의 기초를 탄탄히 다지는 것은 필수입니다. 사람들이 즐겨 사용하는 효율적이고 확장 가능하며 사용자 친화적인 웹사이트를 만들기 위한 기본 요소라고 생각하면 됩니다. 웹 개발 기술을 향상시키는 데 도움이 되는 7가지 중요한 개념을 살펴보세요. 1. 반응형 디자인 멋진 웹사이트를 만들었는데 휴대폰에서는 전혀 어울리지 않는 것처럼 보인다고 상상해 보세요. 멋지지 않죠! 바로 여기에 반응형 디자인이 등장합니다. 반응형 디자인은 데스크톱부터 포켓 사이즈 휴대폰까지 다양한 화면 크기에 맞게 웹사이트의 레이아웃을 조정할 수 있는 마법과도 같은 기술입니다. 이것이 왜 중요한가요? 요즘은 모바일 브라우징이 대세입니다. 여러 기기에서 일관된 경험을 제공하면 잠재고객의 만족도와 집중도를 높일 수 있습니다. Tip CSS에서 미디어 쿼리를 사용하여 다양한 화면 크기에 맞는 스타일을 설정하세요. 다음은 간단한 예시입니다 12345678/* 768px보다 넓은 화면용 스타일 */@media screen and (min-width: 768px) &#123; .content &#123; width: 70%; /* 필요에 따라 조정 */ margin: 0 auto; /* 콘텐츠를 가로로 중앙에 배치 */ max-width: 1200px; /* 매우 넓은 화면에서 가독성을 높이기 위해 최대 너비를 추가합니다 */ &#125;&#125; 123456/* 768px보다 좁은 화면용 스타일 */@media (max-width: 768px) &#123; .content &#123; width: 100%; &#125;&#125; 개발을 시작하려면 미리 구축된 반응형 레이아웃을 제공하는 Bootstrap이나 Foundation과 같은 프레임워크를 사용하세요. 다양한 디바이스와 브라우저에서 웹사이트를 테스트하는 것을 잊어서는 안 됩니다. 브라우저 개발자 도구와 테스터를 사용하여 사용자에게 간편한 사용자 경험을 제공하세요. 2. 성능 최적화 수면제를 먹고 달팽이처럼 느린 속도로 웹사이트가 로드되기를 기다리는 것을 좋아하는 사람은 아무도 없습니다. 웹사이트 속도 최적화는 웹사이트의 빠른 로딩을 보장하고 방문자의 만족도를 유지합니다. 다음은 몇 가지 요령입니다. HTTP 요청 최소화하기: 각 picture, script 및 stylesheet에는 HTTP 요청이 필요합니다. 쿼리가 적을수록 로드 시간이 빨라집니다. 파일을 결합하거나 스프라이트와 같은 기술을 사용하여 그림을 만드는 것도 고려해 보세요. 이미지 최적화: 최적화되지 않은 큰 이미지는 웹사이트 속도를 크게 저하시킬 수 있습니다. TinyPNG를 사용하여 화질을 유지하면서 사진을 압축하세요. 브라우저 캐싱 사용: 캐싱은 사용자가 페이지를 볼 때마다 다운로드할 필요가 없도록 웹사이트 구성 요소를 로컬에 저장하도록 브라우저에 지시합니다. Tip Google PageSpeed 인사이트와 같은 도구를 사용하여 웹사이트의 성능을 검토하고 개선할 부분을 찾아보세요. 방문자가 페이지를 아래로 내려다볼 때만 이미지가 로드되는 지연 로딩을 사용해 보세요. 대용량 미디어 파일의 무게를 간과합니다. 사진과 동영상을 게시하기 전에 항상 최적화하세요. 3. 접근성 웹은 능력에 관계없이 누구나 사용할 수 있어야 합니다. 접근성이 중요한 이유입니다. 접근성 측면을 통합하면 시각 장애나 운동 장애와 같은 장애가 있는 사람들에게도 유용한 웹사이트를 제공할 수 있습니다. 제목에는 &lt;h1&gt;, 단락에는 &lt;p&gt;, 버튼에는 &lt;button&gt;과 같은 시맨틱 HTML 요소를 사용하세요. 이렇게 하면 사용자와 스크린 리더와 같은 보조 기술 모두에게 명확한 의미를 부여할 수 있습니다. 올바른 키보드 탐색을 확인하세요. 사용자는 키보드만으로 웹사이트에 액세스할 수 있어야 합니다. 이미지 및 기타 텍스트가 아닌 콘텐츠에 대한 대체 텍스트 설명을 사용하여 스크린 리더가 웹 사이트를 열 수 있도록 하세요. 4. Semantic HTML 시맨틱 HTML을 웹사이트의 골격으로 이해합니다. 간단하고 의미 있는 태그를 사용하여 콘텐츠의 의미와 구조를 설명합니다. 이는 접근성을 향상시킬 뿐만 아니라 검색 엔진이 웹사이트를 더 효과적으로 이해하고 순위를 매기는 데도 도움이 됩니다. 일반적인 &lt;div&gt; 태그 대신 제목에는 &lt;h1&gt;, 독립된 콘텐츠에는 &lt;article&gt;, 탐색 메뉴에는 &lt;nav&gt;와 같은 요소를 사용하세요. 이렇게 하면 작성하는 콘텐츠의 구조가 명확해져 사람과 검색 엔진이 원하는 내용을 더 쉽게 찾을 수 있습니다. 5. CSS Flexbox &amp; Grid 웹사이트 레이아웃을 만들 때 float와 clear로 고민하던 시대는 지났습니다. CSS Flexbox와 Grid는 웹 페이지 제작에 강력하고 유연한 접근 방식을 제공하는 최신 레이아웃 도구입니다. Flexbox: Flexbox를 유연한 상자처럼 컨테이너에 항목을 배열한다고 상상해 보세요. 사용 가능한 공간과 정의한 규칙에 따라 항목의 크기와 위치를 조정할 수 있습니다. Flexbox를 활성화하려면 컨테이너 요소의 display: flex 속성을 사용하세요. 12345.container &#123; display: flex; justify-content: space-between; /* 항목을 가로로 정렬합니다 */ align-items: center; /* 항목을 세로로 정렬합니다 */&#125; CSS Grid: Grid 레이아웃은 테이블이 없는 표와 비슷하다고 생각하면 됩니다. 행과 열을 정의하고 이 셀 안에 요소를 배치할 수 있습니다. Grid를 활성화하려면 컨테이너 요소의 display: grid 속성을 사용합니다. 1234567.grid-container &#123; display: grid; /* 동일한 크기의 세 개의 열을 정의합니다 */ grid-template-columns: repeat(3, 1fr); /* 그리드 항목 사이의 간격 */ grid-gap: 10px;&#125; 브라우저 지원은 잊어버리세요. Flexbox와 Grid는 광범위하게 지원되지만 구형 브라우저의 호환성 표를 확인하고 필요한 경우 접두사 사용을 고려하세요. 6. 자바스크립트 기초 자바스크립트는 웹사이트에 생동감을 불어넣는 마법과도 같습니다. 대화형 컴포넌트, 애니메이션, 동적 기능을 만들 수 있습니다. 자바스크립트 개발자가 되고 싶지 않더라도 모든 웹 개발자는 기본을 이해하는 것이 필수적입니다. 변수, 데이터 유형, 함수, 루프, 조건문과 같은 핵심 개념을 파악하세요. 이러한 개념은 효과적인 자바스크립트 코드를 작성하기 위한 기본 요소입니다. Netflix나 Gmail과 같은 많은 인기 웹사이트는 원활한 대화형 사용자 경험을 제공하기 위해 자바스크립트에 크게 의존합니다. 7. Git으로 버전 관리 팀으로 웹사이트 작업을 하다가 실수로 서로의 편집 내용을 덮어쓴다고 생각해 보세요. 악몽이죠! 바로 여기에 버전 관리가 필요합니다. Git은 변경 사항을 추적하고, 이전 버전으로 돌아가 다른 사람들과 효율적으로 작업할 수 있는 인기 있는 버전 관리 시스템입니다. 리포지토리를 초기화하는 git init, 변경 내용을 추가하는 git add, 메시지와 함께 변경 내용을 커밋하는 git commit, 변경 내용을 원격 서버로 푸시하는 git push와 같은 기본적인 Git 명령어를 배워보세요. GitKraken 또는 GitHub 가이드와 같은 온라인 리소스를 사용하여 Git을 시작하고 그 기능을 살펴보세요. 버전 관리를 사용하지 않으십니까? 나중에 버전 관리 문제를 피하려면 가능한 한 빨리 Git을 사용하세요. 마무리 위의 7가지 핵심 개념은 훌륭한 웹사이트를 만드는 데 필수적입니다. 이를 이해하면 사용자 친화적이고 효율적인 웹사이트를 만들 수 있을 뿐만 아니라 웹 개발 경력을 쌓아 성공할 수 있는 발판을 마련할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Javascript Development","slug":"Javascript-Development","permalink":"http://hgko1207.github.io/tags/Javascript-Development/"}]},{"title":"모든 웹 개발자가 알아야 할 7가지 개념!","slug":"web-9","date":"2024-05-14T04:35:05.000Z","updated":"2024-05-16T04:27:59.802Z","comments":true,"path":"2024/05/14/web-9/","link":"","permalink":"http://hgko1207.github.io/2024/05/14/web-9/","excerpt":"","text":"노련한 개발자이든 이제 막 시작하는 호기심 많은 초보자이든, 멋진 웹사이트를 만들려면 멋진 애니메이션과 흥미로운 효과 이상의 것이 필요합니다. 이 모든 것은 중요한 개념에 대한 탄탄한 기초가 있어야 합니다. 이러한 기본 개념을 익히면 모든 작업을 수행할 준비가 된 보다 효과적이고 유연한 개발자가 될 수 있습니다. 1. Big 3: HTML, CSS, JavaScript 이 세 가지를 웹의 기본 구성 요소로 생각하세요. HTML은 콘텐츠를 구성하고, CSS는 콘텐츠를 아름답게 스타일링하며, JavaScript는 상호 작용과 개성을 더합니다. 다음은 기본적인 분석입니다. HTML(Hypertext Markup Language)은 header, paragraph, illustration 등의 요소를 지정하는 웹사이트의 기본입니다. CSS(Cascading Style Sheets): CSS는 웹사이트를 시각적으로 매력적으로 만들어 줍니다. CSS 가상 클래스(Pseudo class)는 버튼 위에 마우스를 올리거나 초점을 맞추면 색상을 변경하거나 멋진 애니메이션을 추가하는 등 동적 효과를 제공할 수 있습니다. JavaScript: 웹페이지가 서로 상호 작용할 수 있게 해주는 마법 같은 언어입니다. 깔끔하고 유지 관리가 쉬운 자바스크립트를 작성하여 향후 코드 문제를 방지하는 방법을 알아보세요. 깔끔하고 유지 관리가 쉬운 CSS를 작성하려면 BEM(Block-Element-Modifier) 구조를 사용하세요. CSS Tricks 2. 반응형 웹 디자인 웹사이트가 대형 데스크톱 디스플레이에서는 잘 보이지만 모바일 기기에서는 보이지 않는다고 상상해 보세요. 반응형 디자인은 웹사이트가 PC, 태블릿, 스마트폰 등 모든 기기에서 원활하게 작동하도록 보장합니다. 그 비결은 바로 여기에 있습니다. 미디어 쿼리(Media Query)는 화면 크기에 따라 웹사이트의 레이아웃을 맞춤 설정하도록 지시하는 마법 주문과 같습니다. CSS 미디어 쿼리에 대한 완벽한 가이드 Fluid Grid: 웹사이트 레이아웃을 그리드라고 상상해 보세요. 플루이드 그리드는 설정된 픽셀이 아닌 백분율을 사용하므로 그리드가 “flow” 다양한 디스플레이에 맞게 조정됩니다. Fluid Design 유연한 이미지: 사진이 크면 모바일 페이지 속도가 느려질 수 있습니다. 화면 크기에 맞게 크기가 조정되는 유연한 이미지를 사용하세요. 반응형 웹 디자인: 플렉서블 이미지 3. Git으로 버전 관리 프로젝트에서 작업하고 변경한 후 실수로 일을 망친 적이 있나요? Git 버전 제어는 구세주입니다. 코드의 변경 사항을 추적하여 이전 버전으로 복원하고 다른 사람들과 원활하게 상호 작용할 수 있도록 도와줍니다. 다음은 Git의 기본 사항에 대한 단기 강좌입니다. Repository: 리포지토리는 모든 코드 버전의 허브라고 생각하세요. Commit: 커밋은 특정 시점의 코드 스냅샷입니다. 변경한 내용을 설명하는 메시지를 포함할 수 있습니다. Branch: 메인 코드에 영향을 주지 않고 새로운 기능을 테스트하고 싶다고 가정해 보세요. 브랜치를 사용하면 변경 사항을 개별적으로 작업한 후 만족스러우면 다시 메인 코드베이스에 병합할 수 있습니다. 4. HTTP/HTTPS &amp; APIs 웹은 커뮤니케이션에 관한 모든 것입니다! HTTP(Hypertext Transfer Protocol Secure)는 컴퓨터가 서로 통신하는 데 사용하는 언어입니다. 웹사이트를 방문하면 브라우저는 HTTP 요청을 보내고 서버는 웹사이트 콘텐츠를 제공하는 HTTP 응답을 반환합니다. HTTPS(Hypertext Transfer Protocol Secure)는 데이터 전송을 암호화하여 웹사이트와 사용자 정보를 안전하게 보호하는 HTTP의 보안 버전입니다. 보안을 위해 항상 HTTPS를 사용하세요! APIs(Application Programming Interfaces)는 식당의 웨이터와 비슷합니다. 사용자 데이터 수집과 같은 요청을 수락하고 다른 시스템에서 원하는 정보를 전달합니다. 인터랙티브 웹 앱을 만들려면 API를 이해하는 것이 필수적입니다. 5. 기본 SEO 방문자가 무언가를 검색할 때 웹사이트가 가장 먼저 표시되기를 원하시나요? 기본 검색 엔진 최적화(SEO)가 도움이 될 수 있습니다! Meta Tags: 웹사이트 콘텐츠에 대한 정보를 포함하는 검색 엔진용 숨겨진 메시지입니다. HTML 메타 태그 Keywords: 사람들이 검색할 가능성이 높은 용어입니다. 웹사이트 콘텐츠 전체에 관련 키워드를 전략적으로 사용하세요. 웹사이트 성능 최적화: 느린 웹사이트는 슬픈 일입니다. 웹사이트의 이미지 크기와 코드 구조를 최적화하여 로딩 속도를 높여 검색 엔진과 방문자 모두에게 이득이 되도록 하세요. 06. 웹 접근성 웹은 누구나 접근할 수 있어야 합니다! 웹 접근성이란 장애가 있는 사람도 웹사이트에 접속하여 사용할 수 있다는 뜻입니다. 시맨틱 HTML은 단순히 콘텐츠를 표시하는 것이 아니라 콘텐츠의 의미와 목적을 설명하기 위해 HTML 요소를 사용하는 것을 의미합니다. 시맨틱 HTML5 요소 설명 ARIA 역할은 시각 장애인이 사용하는 스크린 리더에 추가 정보를 제공하는 고유한 속성입니다. 키보드 탐색: 모든 사람이 마우스를 사용하는 것은 아닙니다. 키보드만으로 웹사이트에 액세스할 수 있는지 확인하세요. 7. 성능 최적화 느린 웹사이트를 좋아하는 사람은 아무도 없습니다! HTTP 요청(서버에 무언가를 요청하는 횟수)을 줄이고, 캐싱(자주 사용하는 항목을 로컬에 저장)을 추가하고, 이미지를 최적화하여 웹사이트의 속도를 최적화하여 더 빠르게 로딩하세요. 웹사이트가 빠르면 사용자도 만족하고 검색 엔진도 만족한다는 사실을 기억하세요. 전문가 팁 및 모범 사례: 개발자가 사용자에게 전하는 조언 항상 코드에 댓글을 달아주세요! 미래의 자신(또는 다른 누군가)이 고마워할 것입니다. 코드 주석을 작성하기 위한 모범 사례 실험하는 것을 두려워하지 마세요! 기존의 것을 깨고, 새로운 것을 시도하고, 실수로부터 배우세요. 개발자 커뮤니티가 도와드릴 준비가 되어 있습니다! 온라인에는 많은 커뮤니티와 리소스가 있습니다. 주저하지 말고 질문하세요. 마무리 이러한 기본 개념을 학습함으로써 웹 개발자로서의 기술과 효율성을 높일 뿐만 아니라 끊임없이 변화하는 웹 개발 세계에서 미래의 성장과 성공을 위한 토대를 마련할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"HTML5","slug":"HTML5","permalink":"http://hgko1207.github.io/tags/HTML5/"}]},{"title":"[TypeScript] typeof, instanceof, literal로 타입 보호하기","slug":"typescript-23","date":"2024-05-13T04:24:04.000Z","updated":"2024-05-14T04:19:06.856Z","comments":true,"path":"2024/05/13/typescript-23/","link":"","permalink":"http://hgko1207.github.io/2024/05/13/typescript-23/","excerpt":"","text":"타입을 보호하는 기술을 익혀 코드의 견고성을 강화하는 여정을 시작하겠습니다. typeof, instanceof, literal을 사용하면 정확한 타입을 적용하고 타입스크립트 프로젝트 초기에 잠재적인 오류를 잡아낼 수 있는 힘을 얻을 수 있습니다. 이러한 기술을 자세히 살펴보면서 의도하지 않은 동작으로부터 코드를 강화하고 더 높은 수준의 유형 안전을 달성하는 방법을 알아보세요. typeof typeof 연산자를 사용하면 값이나 변수의 유형을 확인할 수 있습니다. 타입 가드에서 타입을 좁히기 위해 자주 사용됩니다. 123456789function logMessage(message: string | number) &#123; if (typeof message === 'string') &#123; // 이 블록 내에서 TypeScript는 'message'가 'string' 유형임을 알고 있습니다. console.log(message.toUpperCase()); &#125; else &#123; // 이 블록 안에서, 타입스크립트는 'message'의 타입이 'number'라는 것을 알고 있습니다. console.log(message.toFixed(2)); &#125;&#125; instanceof instanceof 연산자는 객체가 특정 클래스 또는 생성자 함수의 인스턴스인지 여부를 확인합니다. 123456789101112131415161718192021class Dog &#123; bark() &#123; console.log('Woof!'); &#125;&#125;class Cat &#123; meow() &#123; console.log('Meow!'); &#125;&#125;function petSound(animal: Dog | Cat) &#123; if (animal instanceof Dog) &#123; // 이 블록 안에서, 타입스크립트는 'animal'이 'Dog' 타입임을 알고 있습니다. animal.bark(); &#125; else &#123; // 이 블록 안에서, 타입스크립트는 'animal'이 'Cat' 타입임을 알고 있습니다. animal.meow(); &#125;&#125; Literal Types TypeScript의 Literal 타입을 사용하면 변수의 정확한 값을 지정할 수 있습니다. 1234567891011121314function handleStatus(status: 'success' | 'error' | 'pending') &#123; // 'status'는 리터럴 타입 'success', 'error' 또는 'pending'으로 좁혀집니다. switch (status) &#123; case 'success': console.log('Operation succeeded!'); break; case 'error': console.log('An error occurred.'); break; case 'pending': console.log('Operation is pending.'); break; &#125;&#125; 이 예제에서 status 매개변수는 지정된 리터럴 값 중 하나만 가질 수 있습니다. 마무리 이러한 기술을 사용하면 TypeScript가 조건부 블록 내에서 보다 구체적인 유형을 이해하고 적용하여 코드의 유형 안전성을 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"typeof","slug":"typeof","permalink":"http://hgko1207.github.io/tags/typeof/"},{"name":"instanceof","slug":"instanceof","permalink":"http://hgko1207.github.io/tags/instanceof/"},{"name":"literal","slug":"literal","permalink":"http://hgko1207.github.io/tags/literal/"}]},{"title":"[TypeScript] Indexed Access Types 및 Mapped Types","slug":"typescript-22","date":"2024-05-09T04:16:34.000Z","updated":"2024-05-09T04:25:39.590Z","comments":true,"path":"2024/05/09/typescript-22/","link":"","permalink":"http://hgko1207.github.io/2024/05/09/typescript-22/","excerpt":"","text":"이번 글에서는 TypeScript의 타입 시스템을 크게 향상시키는 두 가지 강력한 기능을 살펴보는 여정을 시작합니다. Indexed Access Types 조회 타입이라고도 하는 인덱싱된 액세스 타입을 사용하면 키를 기반으로 객체에서 프로퍼티 타입을 조회할 수 있습니다. 이 구문은 대괄호 안에 키 타입이 들어 있는 대괄호를 사용합니다. 1234567type Person = &#123; name: string; age: number; city: string;&#125;;type AgeType = Person['age']; // number 이 예제에서 Person['age']는 Person 타입에서 ‘age’ 속성의 타입을 검색합니다. Mapped Types 12345678910type Flags = &#123; option1: boolean; option2: boolean;&#125;;type NullableFlags = &#123; [K in keyof Flags]: boolean | null;&#125;;// Result: &#123; option1: boolean | null, option2: boolean | null &#125; 여기서 NullableFlags는 Flags의 각 프로퍼티를 null을 허용하도록 변환합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Mapped Types","slug":"Mapped-Types","permalink":"http://hgko1207.github.io/tags/Mapped-Types/"},{"name":"Indexed Access Types","slug":"Indexed-Access-Types","permalink":"http://hgko1207.github.io/tags/Indexed-Access-Types/"}]},{"title":"[TypeScript] 엄격한 타입 검사, 고급 컴파일러 옵션","slug":"typescript-21","date":"2024-05-08T15:41:27.000Z","updated":"2024-05-09T03:58:22.033Z","comments":true,"path":"2024/05/09/typescript-21/","link":"","permalink":"http://hgko1207.github.io/2024/05/09/typescript-21/","excerpt":"","text":"타입스크립트의 강점은 표현력이 풍부한 구문뿐만 아니라 강력한 타입 검사 및 컴파일 옵션에도 있습니다. 이번 글에서는 엄격한 타입 검사 및 고급 컴파일러 옵션에 대해 집중적으로 살펴봅니다. 이러한 기능은 코드 품질을 높이고, 잠재적인 오류를 조기에 발견하며, 컴파일 프로세스를 미세 조정하는 데 도움이 됩니다. 타입 안전성을 보장하고 TypeScript 워크플로를 최적화하는 미묘한 차이를 알아보는 여정에 함께하세요. 엄격한 타입 검사(Strict Type Checking) 엄격한 타입 검사를 사용하려면 컴파일 시 일반적인 프로그래밍 오류를 포착하는 데 도움이 되는 여러 가지 TypeScript 컴파일러 옵션을 사용 설정해야 합니다. 엄격한 타입 검사를 사용하려면 몇 가지 하위 옵션이 포함된 --strict 플래그를 사용하면 됩니다. --strictNullChecks: 변수의 타입에서 명시적으로 허용하지 않는 한 변수가 null 또는 정의되지 않은 상태로 할당되지 않도록 합니다. --strictFunctionTypes: 함수 매개변수 타입과 반환 타입을 보다 엄격하게 검사합니다. --strictPropertyInitialization: 모든 클래스 프로퍼티가 생성자에서 초기화되도록 합니다. --strictBindCallApply: 함수의 바인드, 호출 및 적용 메서드를 더 엄격하게 검사합니다. 이러한 옵션을 활성화하려면 다음 컴파일러 명령을 사용하면 됩니다. 1tsc --strict tsfile.ts 또는 tsconfig.json에서 설정할 수 있습니다. 123456789&#123; \"compilerOptions\": &#123; \"strict\": true, \"strictNullChecks\": true, \"strictFunctionTypes\": true, \"strictPropertyInitialization\": true, \"strictBindCallApply\": true &#125;&#125; 고급 컴파일러 옵션(Advanced Compiler Option) 엄격한 타입 검사 외에도 TypeScript는 컴파일러의 동작을 미세 조정할 수 있는 다양한 고급 컴파일러 옵션을 제공합니다. 주목할 만한 옵션은 다음과 같습니다. --target: 생성된 JavaScript 코드의 ECMAScript 대상 버전을 지정합니다(예: “es5”, “es6”). --module: 생성된 JavaScript 코드에서 사용할 모듈 시스템을 지정합니다(예: “commonjs”, “amd”, “es6”). --esModuleInterop: CommonJS 모듈과의 호환성을 활성화하고 기본 내보내기가 없는 모듈에서 기본 가져오기를 허용합니다. --declaration: 해당 .d.ts 선언 파일을 생성합니다. --sourceMap: 더 나은 디버깅 지원을 위해 소스 맵 파일을 생성합니다. --noEmitOnError: 컴파일 오류가 있는 경우 TypeScript가 JavaScript 파일을 내보내지 않도록 합니다. 이러한 옵션은 tsconfig.json 파일에서 구성할 수 있습니다. 12345678910&#123; \"compilerOptions\": &#123; \"target\": \"es5\", \"module\": \"commonjs\", \"esModuleInterop\": true, \"declaration\": true, \"sourceMap\": true, \"noEmitOnError\": true &#125;&#125; 결론 이러한 옵션을 사용하면 TypeScript가 코드를 트랜스파일하는 방식을 제어하여 호환성을 보장하고 선언 파일을 생성하며 디버깅 프로세스를 지원할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Advanced Typescript","slug":"Advanced-Typescript","permalink":"http://hgko1207.github.io/tags/Advanced-Typescript/"},{"name":"Strict Type","slug":"Strict-Type","permalink":"http://hgko1207.github.io/tags/Strict-Type/"},{"name":"strict","slug":"strict","permalink":"http://hgko1207.github.io/tags/strict/"}]},{"title":"2024년을 위한 WPF 개발 모범 사례","slug":"wpf-1","date":"2024-05-07T05:57:13.000Z","updated":"2024-05-08T15:39:05.697Z","comments":true,"path":"2024/05/07/wpf-1/","link":"","permalink":"http://hgko1207.github.io/2024/05/07/wpf-1/","excerpt":"","text":"소프트웨어 개발은 매우 역동적이며 프로그램 내에서 효율성을 유지하면서 자신의 스타일을 적응하고 개선하는 데 개방적인 사람들에게 유리합니다. .NET 개발자에게 Windows Presentation Foundation(WPF)은 여전히 강력한 데스크톱 애플리케이션을 빌드하는 데 가장 적합한 도구 중 하나입니다. 2024년에 점점 더 가까워지는 지금, 이 기회에 WPF를 더 효과적으로 사용할 수 있는 가장 중요한 모범 사례 몇 가지를 살펴보세요! 최신 상태로 유지하여 .NET 발전 수용하기 .NET 프레임워크에 도입된 최신 기능과 향상된 기능을 활용하여 기술의 최전선에 서세요. .NET은 매년 더 나은 성능, 보안 및 언어 기능을 제공하기 위해 계속 발전하고 있습니다. 최신 .NET 버전을 구현하여 이러한 개선 사항의 이점을 활용하면 WPF 프로젝트에 큰 도움이 될 것입니다. 비동기 프로그래밍을 사용한 반응형 UI UI는 사용자 경험을 소개하는 가장 중요한 요소이며, 첫인상을 결정짓는 중요한 요소입니다. 비동기 프로그래밍 패턴과 동적 보기를 채택하여 WPF 애플리케이션의 유동성과 반응성을 유지하세요. 비차단 작업에 async/await를 사용하면 UI가 멈추는 것을 방지하고 전반적인 사용자 경험을 향상시킬 수 있습니다. 유지보수성을 위한 MVVM 아키텍처 Model-View-View-Model(MVVM) 아키텍처 패턴은 여전히 WPF 개발에서 큰 부분을 차지합니다. MVVM을 토폴로지에 도입하여 문제를 분리하고, 테스트 가능성을 높이고, 유지 관리를 간소화하세요. Visual Studio와 같은 도구는 처음부터 MVVM 구조를 스캐폴딩할 수 있도록 지원하므로 팀과 프로젝트의 모범 사례에 따라 쉽게 구현할 수 있습니다. 선언적 UI를 위한 XAML 활용 XAML(eXtensible Application Markup Language)은 WPF에서 선언적 UI를 만들기 위한 강력한 도구입니다. XAML을 사용하여 애플리케이션의 사용자 인터페이스를 정의하면 UI의 가독성과 유지 관리성을 크게 향상시킬 수 있습니다. 이 접근 방식은 팀과 이해관계자 간의 커뮤니케이션을 강화하여 궁극적으로 훨씬 더 효율적인 워크플로우를 제공합니다. 데이터 바인딩 기법 최적화 데이터를 효율적으로 바인딩하는 것은 WPF 인프라에 매우 중요합니다. 애플리케이션의 요구 사항에 따라 적절한 데이터 바인딩 모드(OneTime, OneWay, TwoWay)를 선택하세요. 또한 데이터 유효성 검사 및 INotifyPropertyChanged와 같은 기능을 활용하여 실시간 업데이트를 보장하고 데이터 무결성을 유지할 수 있습니다. 많은 경우 복잡한 C# 컨버터를 작성하지 않아도 되는 WPF BindingExpressions 라이브러리를 사용하면 MVVM 애플리케이션에서 데이터 바인딩을 더욱 쉽게 수행할 수 있습니다. 종속성 주입 수용 종속성 주입(DI)은 모듈화되고 유지 관리 가능한 코드를 장려하는 모범 사례입니다. Microsoft.Extensions.DependencyInjection과 같은 DI 프레임워크를 사용하여 WPF 애플리케이션의 종속성을 관리하세요. 이렇게 하면 테스트 가능성, 유연성 및 전반적인 코드 품질이 향상됩니다. 필요한 사용자를 위한 접근성 우선 순위 지정 포용적 디자인은 다양한 사용자 요구를 충족하는 애플리케이션을 만드는 데 있어 기본입니다. 장애가 있거나 특별한 요청이 필요한 사용자가 WPF 애플리케이션에 액세스할 수 있는지 확인해야 합니다. WPF의 기본 제공 접근성 기능을 사용하고 접근성 표준을 준수하여 더 많은 사용자가 애플리케이션을 사용할 수 있도록 하세요. 스타일 및 템플릿으로 프로그레시브 UI 구현 미리 빌드된 스타일과 템플릿을 사용하여 시각적으로 매력적이고 일관된 사용자 인터페이스를 제작하세요. 애플리케이션 전반에 걸쳐 일관된 디자인 언어를 만들어 사용자의 인지도와 전반적인 만족도를 향상시키세요. WPF의 스타일 지정 기능을 사용하면 프로젝트에 필요한 보다 현대적이고 직관적인 UI를 구현할 수 있습니다. 라이브 비주얼 트리로 디버깅 향상 디버깅은 개발 프로세스에서 매우 중요한 부분입니다. Visual Studio의 라이브 비주얼 트리와 같은 유용한 도구를 활용하여 실행 중인 WPF 애플리케이션의 시각적 구조를 자세히 조사할 수 있습니다. 이 기능은 UI 계층 구조에 대한 실시간 인사이트를 제공하여 문제를 빠르게 식별하고 해결하는 데 도움이 됩니다. 보안 의식 유지 소프트웨어 개발에서 보안은 타협할 수 없는 부분입니다. WPF 애플리케이션 보안을 위한 업계 모범 사례를 따르세요. 중요한 정보를 암호화하고, 사용자 입력의 유효성을 검사하고, .NET 프레임워크의 최신 보안 업데이트에 대한 정보를 지속적으로 확인하세요. 빠르고 유연한 내부 및 외부 보고를 통해 규제 기관과 보조를 맞추세요. 마무리 .NET 개발자는 2024년에 주목할 만한 WPF 개발에 더욱 도전하게 될 것입니다. 이러한 모범 사례를 채택하면 보다 효율적이고 유지 관리가 쉬우며 사용자 친화적인 애플리케이션을 개발할 수 있을 것입니다. 최신 기술을 최신 상태로 유지하고 이러한 지침을 워크플로에 통합하면 끊임없이 진화하는 세상에서 WPF 개발 기술을 마스터하는 데 도움이 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":".NET 개발자","slug":"NET-개발자","permalink":"http://hgko1207.github.io/tags/NET-%EA%B0%9C%EB%B0%9C%EC%9E%90/"}]},{"title":"Google에서 1위를 차지하기 위한 10가지 ChatGPT 프롬프트","slug":"chatgpt-24","date":"2024-05-03T04:49:33.000Z","updated":"2024-05-07T05:46:59.966Z","comments":true,"path":"2024/05/03/chatgpt-24/","link":"","permalink":"http://hgko1207.github.io/2024/05/03/chatgpt-24/","excerpt":"","text":"ChatGPT는 SEO를 위한 뛰어난 도구입니다. 이 글를 따라 10가지 ChatGPT 프롬프트를 통해 SEO를 마스터하여 Google에서 검색 순위 1위를 달성하는 방법을 알아보세요. 지금 바로 매력적인 콘텐츠를 만들어 검색 엔진에 최적화하세요. 프롬프트 1 - Google 키워드 플래너를 사용한 키워드 조사 및 분석 Google 키워드 플래너를 사용하여 키워드 조사 및 분석을 수행하여 키워드 난이도가 낮고 관련성이 높은 키워드를 식별하세요. 키워드 데이터가 검색 의도와 순위에 맞게 콘텐츠를 최적화하는 데 어떻게 사용되는지 설명하세요. 입력: 키워드 조사 및 분석을 위한 타겟 고객과 업계를 지정하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 프롬프트 2 - 작가 및 콘텐츠 제작자를 위한 SEO 전략 블로그 가시성과 청중 참여를 높이기 위해 특별히 작가와 콘텐츠 제작자를 위한 SEO 전략을 개발하세요. 블로거의 SEO 성공을 위한 콘텐츠 계획, 키워드 타겟팅, 홍보 전략에 대해 토론하세요. 입력: 블로그 주제 또는 틈새 시장, 타겟 고객 인구 통계 및 콘텐츠 홍보 채널을 지정하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요. 프롬프트 3 — 기술적 SEO 감사 및 최적화 기술적 SEO 감사를 실시하여 검색 엔진 크롤링 및 색인 생성에 영향을 미치는 [웹사이트] 문제를 파악하고 수정하세요. 사이트 속도 개선, 모바일 친화성, 표준화 등 기술적 SEO 최적화와 관련된 단계를 자세히 설명하세요. 입력: 웹사이트의 기술 인프라와 기존의 SEO 문제를 설명하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요. 프롬프트 4 - 콘텐츠 갭 분석 콘텐츠 격차 분석을 수행하여 SEO에 최적화된 새로운 콘텐츠를 만들 수 있는 기회를 파악하세요. 콘텐츠 격차를 파악하고 관련성 높은 고품질 콘텐츠로 채우는 방법에 대해 토론하세요. 입력: 콘텐츠 갭 분석을 위한 콘텐츠 주제 또는 주제와 타겟 키워드를 지정하세요. 이 답변을 제공한 후에는 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요. 프롬프트 5 - 백링크를 위한 링크 구축 전략 권위 있는 웹사이트와 업계 인플루언서로부터 양질의 백링크를 확보하는 데 중점을 둔 링크 구축 전략을 수립하세요. 효과적인 링크 구축 캠페인을 위한 홍보 전략, 콘텐츠 협업 기회, 링크 확보 모범 사례에 대해 논의하세요. 입력: 링크 구축 캠페인의 타겟 도메인과 선호하는 아웃리치 방법을 정의하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 프롬프트 6 - 필러 페이지 모델을 사용한 SEO 전략 개발 기둥 페이지 모델을 활용하여 종합적인 SEO 전략을 개발하세요. 최적의 검색 엔진 가시성을 위해 기둥 콘텐츠와 클러스터 주제를 어떻게 구성하는지 설명하세요. 입력: 기둥 페이지 모델을 기반으로 SEO 전략 개발을 위한 업계 또는 틈새 시장을 정의하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 바탕으로 프롬프트를 실행하세요. 프롬프트 7 - 모바일 SEO 최적화 전략 모바일 장치에서 사용자 경험과 검색 엔진 가시성을 향상시키기 위한 모바일 SEO 최적화 전략을 개발하세요. 모바일 SEO를 위한 반응형 디자인 원칙, 모바일 친화적인 콘텐츠 형식, 페이지 속도 최적화에 대해 설명하세요. 입력: 웹사이트의 현재 모바일 최적화 상태와 개선이 필요한 부분에 대해 자세히 설명하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 프롬프트 8 - 동영상 SEO 최적화 전략 동영상 검색 결과에서 가시성과 순위를 높이기 위해 동영상 SEO 최적화 기술을 구현하세요. 동영상 SEO 성공을 위한 동영상 메타데이터 최적화, 썸네일 최적화, 동영상 참여도 측정지표에 대해 논의하세요. 입력: SEO 최적화를 위한 동영상 콘텐츠 전략, 타겟 키워드 및 선호하는 동영상 플랫폼에 대한 세부 정보를 제공하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 프롬프트 9 - 의도 기반 검색을 위한 시맨틱 SEO 최적화 사용자의 검색 의도 및 시맨틱 검색 알고리즘에 맞게 시맨틱 SEO를 위해 콘텐츠를 최적화하세요. 시맨틱 SEO를 위한 엔티티 기반 최적화, 시맨틱 마크업 및 문맥 관련 콘텐츠의 중요성에 대해 토론하세요. 입력: 타겟 고객의 검색 의도와 선호하는 시맨틱 검색 쿼리를 파악하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 프롬프트 10 - 지리적 가시성을 위한 로컬 SEO 최적화 지리적 가시성을 개선하고 지역 고객을 유치하기 위해 지역 SEO에 최적화하세요. 지역 검색 순위를 위한 Google 마이 비즈니스, 지역 인용 및 지역 타겟팅 콘텐츠의 중요성에 대해 설명하세요. 입력: 지역 SEO 최적화를 위해 타겟 지역 고객과 비즈니스 위치에 대한 세부 정보를 제공하세요. 이 답변을 제공한 후 사용자 지정 입력을 요청한 다음 이를 기반으로 프롬프트를 실행하세요. 결론 이 10가지 SEO ChatGPT 프롬프트가 일상적인 SEO 작업을 100배 더 효율적으로 완료하는 데 도움이 되길 바랍니다. 이러한 SEO 프롬프트는 디지털 마케터로서의 일상적인 작업을 혁신적으로 개선하여 생산성을 높이고 수많은 시간을 절약할 수 있는 SEO 전문가로 만들어 줄 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"SEO","slug":"SEO","permalink":"http://hgko1207.github.io/tags/SEO/"}]},{"title":"[TypeScript] Namespace, Generic and Custom Module","slug":"typescript-20","date":"2024-05-03T04:35:17.000Z","updated":"2024-05-03T04:41:03.438Z","comments":true,"path":"2024/05/03/typescript-20/","link":"","permalink":"http://hgko1207.github.io/2024/05/03/typescript-20/","excerpt":"","text":"오늘은 네임스페이스(Namespace), 제네릭(Generic), 사용자 정의 모듈(Custom Module)의 시너지 효과에 대해 알아보겠습니다. 이 강력한 도구는 TypeScript 프로젝트에 구조, 유연성 및 모듈성을 제공합니다. 이 시리즈를 살펴보면서 이러한 기능을 결합하여 코드베이스를 효과적으로 구성, 확장 및 확장할 수 있는 방법을 확인하실 수 있습니다. Namespace TypeScript의 네임스페이스는 로직을 명명된 범위로 캡슐화하여 코드를 구성하는 방법을 제공합니다. 네임스페이스는 이름 충돌을 방지하고 대규모 애플리케이션을 구조화하는 데 유용합니다. 네임스페이스는 네임스페이스 키워드를 사용하여 선언합니다. 12345678910111213141516namespace Geometry &#123; export interface Point &#123; x: number; y: number; &#125; export function distance(point1: Point, point2: Point): number &#123; // 거리 로직 계산 return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)); &#125;&#125;const p1: Geometry.Point = &#123; x: 0, y: 0 &#125;;const p2: Geometry.Point = &#123; x: 3, y: 4 &#125;;const distance = Geometry.distance(p1, p2);console.log(distance); 이 예에서 Geometry는 Point 인터페이스와 distance 함수를 포함하는 네임스페이스입니다. 제네릭 앞서 언급했듯이 타입스크립트의 제네릭을 사용하면 다양한 데이터 유형에서 작동할 수 있는 함수와 클래스를 작성할 수 있습니다. 제네릭은 유연성과 유형 안전성을 제공합니다. 123456function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;const result = identity&lt;string&gt;('Hello, TypeScript!');// 결과는 문자열 타입입니다. 사용자 정의 모듈 사용자 정의 모듈은 코드를 별도의 파일로 구성하고 각 파일에 모듈을 포함하는 것을 말합니다. 모듈은 모듈식 유지 관리가 가능한 코드베이스를 만드는 데 도움이 됩니다. 두 개의 파일이 있다고 가정해 보겠습니다. math.ts 1234567export function add(a: number, b: number): number &#123; return a + b;&#125;export function subtract(a: number, b: number): number &#123; return a - b;&#125; app.ts 1234567import &#123; add, subtract &#125; from './math';const sum = add(5, 3);const difference = subtract(5, 3);console.log(sum); // Output: 8console.log(difference); // Output: 2 이 예제에서 math.ts는 덧셈과 뺄셈 함수가 포함된 모듈입니다. app.ts 파일은 이러한 함수를 가져와 사용합니다. 결론 이러한 개념을 결합하면 체계적이고 유연한 타입스크립트 애플리케이션을 구축할 수 있습니다. 네임스페이스는 파일 내에서 코드를 구조화하는 데 도움이 되고, 제네릭은 유연성을 제공하며, 모듈은 여러 파일에 걸쳐 조직화를 가능하게 합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Generic","slug":"Generic","permalink":"http://hgko1207.github.io/tags/Generic/"},{"name":"Namespace","slug":"Namespace","permalink":"http://hgko1207.github.io/tags/Namespace/"},{"name":"Custom Module","slug":"Custom-Module","permalink":"http://hgko1207.github.io/tags/Custom-Module/"}]},{"title":"[TypeScript] Generic, Type Guard, Signature 및 Overload","slug":"typescript-19","date":"2024-05-02T01:47:38.000Z","updated":"2024-05-02T01:56:37.007Z","comments":true,"path":"2024/05/02/typescript-19/","link":"","permalink":"http://hgko1207.github.io/2024/05/02/typescript-19/","excerpt":"","text":"이번 글에서는 제네릭(Generic), 타입 가드(Type Guard), 서명(Signature) 및 오버로드(Overload)의 영역을 살펴봅니다. 이러한 개념은 유연하고 재사용 가능하며 타입이 안전한 코드를 만들기 위한 기본 구성 요소입니다. 이 시리즈를 진행하면서 이러한 기능이 어떻게 강력하고 유지 관리가 쉬운 TypeScript 애플리케이션을 만드는 데 중추적인 역할을 하는지 알아볼 수 있습니다. 제네릭 TypeScript의 제네릭을 사용하면 타입을 매개변수로 전달할 수 있어 재사용 가능한 type-safe 함수 및 클래스를 만들 수 있습니다. 이를 통해 다양한 데이터 타입에서 작동할 수 있는 함수나 클래스를 작성할 수 있습니다. 123456function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;const result = identity&lt;string&gt;('Hello, TypeScript!');// result is of type string 이 예제에서 identity 함수는 T 타입에 대해 제네릭이므로 모든 타입에서 작동할 수 있습니다. 타입 가드 타입 가드는 특정 코드 블록 내에서 변수의 타입을 좁히는 방법입니다. 런타임 검사를 기반으로 타입별 연산을 수행하기 위해 유니온(union) 타입과 함께 자주 사용됩니다. 12345678910function isString(value: any): value is string &#123; return typeof value === 'string';&#125;let x: any = 'Hello, TypeScript!';if (isString(x)) &#123; // 이 블록 내에서, 타입스크립트는 x가 문자열이라는 것을 알고 있습니다. console.log(x.length);&#125; isString 함수는 조건부 블록 내에서 타입스크립트가 x의 타입을 이해하는 데 도움이 되는 타입 가드입니다. Signature TypeScript에서 함수 서명은 매개변수의 타입과 함수의 반환 타입을 설명합니다. 여기에는 매개변수 이름, 타입 및 반환 타입이 포함됩니다. 1234type MathOperation = (a: number, b: number) =&gt; number;const add: MathOperation = (a, b) =&gt; a + b;const subtract: MathOperation = (a, b) =&gt; a - b; 여기서 MathOperation은 두 개의 숫자를 취하고 숫자를 반환하는 함수를 나타내는 타입입니다. add와 subtract 모두 이 서명을 준수하는 함수입니다. Overload 함수 오버로드를 사용하면 단일 함수에 대해 여러 타입 서명을 제공할 수 있습니다. 이는 인수의 타입이나 수에 따라 함수가 다르게 동작할 때 특히 유용합니다. 12345678910function greet(person: string): string;function greet(person: string, age: number): string;function greet(person: string, age?: number): string &#123; if (age !== undefined) &#123; return `Hello, $&#123;person&#125;! You are $&#123;age&#125; years old.`; &#125; else &#123; return `Hello, $&#123;person&#125;!`; &#125;&#125; 이 예제에서 greet 함수에는 서로 다른 매개변수 타입을 지정하는 두 개의 오버로드가 있습니다. 실제 구현은 이러한 오버로드를 따르고 그에 따라 다양한 경우를 처리합니다. 결론 이러한 개념은 TypeScript에서 유연하고 유형이 안전한 코드를 작성하기 위한 강력한 도구 세트를 제공합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Generic","slug":"Generic","permalink":"http://hgko1207.github.io/tags/Generic/"},{"name":"Type Guard","slug":"Type-Guard","permalink":"http://hgko1207.github.io/tags/Type-Guard/"},{"name":"Signature","slug":"Signature","permalink":"http://hgko1207.github.io/tags/Signature/"},{"name":"Overload","slug":"Overload","permalink":"http://hgko1207.github.io/tags/Overload/"}]},{"title":"[TypeScript] 고급 타입, 매핑된 타입, keyof/typeof","slug":"typescript-18","date":"2024-04-30T02:41:46.000Z","updated":"2024-04-30T02:53:02.976Z","comments":true,"path":"2024/04/30/typescript-18/","link":"","permalink":"http://hgko1207.github.io/2024/04/30/typescript-18/","excerpt":"","text":"이 글에서는 고급 타입, 매핑된 타입, 강력한 keyof/typeof 연산자를 살펴봅니다. TypeScript의 표현형 타이핑 시스템의 중추라고 할 수 있는 이러한 기능을 사용하면 정교하고 정확한 타입 정의를 생성하여 코드를 새로운 차원으로 끌어올릴 수 있습니다. 고급 타입 TypeScript에서 &quot;advanced types&quot;은 일반적으로 더 복잡한 타입 정의를 만들 수 있는 기능과 구성을 의미합니다. 고급 타입의 몇 가지 예로는 Union 타입, Intersection 타입, Conditional 타입, Mapped 타입 등이 있습니다. Union Type 1type MyUnion = string | number; Union 타입은 여러 타입 중 하나가 될 수 있는 값을 설명합니다. 세로 막대(|)를 사용하여 각 타입을 구분하므로 string | number는 string 또는 number가 될 수 있는 값의 타입입니다. Intersection Type 교차(Intersection) 타입은 여러 타입을 하나로 결합합니다. 이를 통해 기존 타입을 합쳐서 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있으므로 MyIntersection은 prop1과 prop2를 포함하는 객체를 기대하는 타입입니다. 1type MyIntersection = &#123; prop1: string &#125; &amp; &#123; prop2: number &#125;; Conditional Type 이 타입은 제네릭 매개변수를 받아 T가 string을 확장하는지 확인합니다. T가 string을 확장하면 타입은 &quot;string type&quot;으로 평가되고, 그렇지 않으면 &quot;non-string type&quot;으로 평가됩니다. 1type MyConditional&lt;T&gt; = T extends string ? 'string type' : 'non-string type'; Mapped Type Mapped 타입을 사용하면 기존 타입의 속성을 변환하여 새로운 타입을 만들 수 있습니다. 일반적인 구문은 다음과 같습니다. 123type NewType&lt;T&gt; = &#123; [P in keyof T]: SomeTransformation;&#125;; 예시 123type OptionalProps&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;; 이 OptionalProps는 (?) 프로퍼티를 사용하여 T의 모든 프로퍼티를 옵션으로 만듭니다. keyof keyof는 객체 타입의 모든 키의 합집합 타입을 생성하는 타입스크립트 연산자입니다. 12type MyKeys = keyof &#123; name: string; age: number &#125;;// MyKeys is \"name\" | \"age\" typeof typeof는 값, 변수 또는 표현식의 타입을 반환하는 연산자입니다. 종종 keyof와 함께 사용하여 타입의 키를 가져오는 데 사용됩니다. 1234const person = &#123; name: 'John', age: 30 &#125;;type PersonKeys = keyof typeof person;// PersonKeys is \"name\" | \"age\" 이러한 개념은 종종 타입스크립트에서 강력하고 표현력이 풍부한 타입 정의를 만드는 데 함께 사용됩니다. 이를 통해 데이터를 모델링하고 코드에서 타입 안전을 강화할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Advanced Types","slug":"Advanced-Types","permalink":"http://hgko1207.github.io/tags/Advanced-Types/"},{"name":"Mapped Types","slug":"Mapped-Types","permalink":"http://hgko1207.github.io/tags/Mapped-Types/"},{"name":"keyof/typeof","slug":"keyof-typeof","permalink":"http://hgko1207.github.io/tags/keyof-typeof/"}]},{"title":"알아야 할 13가지 HTML 속성","slug":"web-8","date":"2024-04-29T01:56:34.000Z","updated":"2024-04-29T06:58:12.506Z","comments":true,"path":"2024/04/29/web-8/","link":"","permalink":"http://hgko1207.github.io/2024/04/29/web-8/","excerpt":"","text":"HTML에서 속성은 HTML 요소에 대한 추가 정보를 제공하는 데 사용됩니다. 이 글에서는 웹사이트의 시각적 매력을 향상시킬 수 있는 13가지 HTML 속성에 대해 알아봅니다. Accept accept 속성을 &lt;input&gt; 요소(파일 유형에만 해당)와 함께 사용하여 서버가 허용할 수 있는 파일 유형을 지정할 수 있습니다. 1&lt;input type=\"file\" accept=\".jpg, .jpeg, .png\" /&gt; Alt alt 속성을 &lt;img&gt; 요소와 함께 사용하여 웹 페이지에 이미지를 표시할 수 없는 경우 대체 텍스트를 지정할 수 있습니다. 1&lt;img src=\"nature.png\" alt=\"A beautiful sunset\" /&gt; Autocomplete autocomplete 속성을 &lt;form&gt;, &lt;input&gt; 및 &lt;textarea&gt; 요소와 함께 사용하여 브라우저의 자동 완성 기능을 제어할 수 있습니다. 1&lt;input type=\"text\" name=\"name\" autocomplete=\"on\" /&gt; Contenteditable Contenteditable 속성을 사용하여 요소의 콘텐츠가 편집 가능한지 여부를 지정할 수 있습니다. 이를 통해 사용자는 요소 내의 콘텐츠를 수정할 수 있습니다. 1&lt;div contenteditable=\"true\"&gt;You can edit this content.&lt;/div&gt; 이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다. Download download 속성을 &lt;a&gt; 요소와 함께 사용하여 사용자가 링크를 클릭할 때 링크된 리소스를 탐색하는 대신 다운로드하도록 지정할 수 있습니다. 1&lt;a href=\"document.pdf\" download=\"document.pdf\"&gt;Download PDF&lt;/a&gt; Hidden hidden 속성을 사용하여 웹 페이지에서 요소를 숨길 수 있습니다. 이 속성은 JavaScript 또는 CSS를 통해 표시 여부를 제어할 때 유용합니다. 1&lt;div hidden&gt;This is hidden content.&lt;/div&gt; 이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다. Loading &lt;img&gt; 요소와 함께 loading 속성을 사용하여 브라우저에서 이미지를 로드하는 방법을 제어할 수 있습니다. 세 가지 값이 있습니다. “eager”, “lazy”, &quot;auto&quot;의 세 가지 값이 있습니다. 1&lt;img src=\"image.png\" loading=\"lazy\" /&gt; Multiple &lt;input&gt; 및 &lt;select&gt; 요소와 함께 multiple 속성을 사용하여 사용자가 한 번에 여러 값을 선택/입력할 수 있도록 할 수 있습니다. 1234567&lt;input type=\"file\" multiple /&gt;&lt;select multiple&gt; &lt;option value=\"java\"&gt;Java&lt;/option&gt; &lt;option value=\"javascript\"&gt;JavaScript&lt;/option&gt; &lt;option value=\"typescript\"&gt;TypeScript&lt;/option&gt; &lt;option value=\"rust\"&gt;Rust&lt;/option&gt;&lt;/select&gt; Poster &lt;video&gt; 요소와 함께 poster 속성을 사용하여 사용자가 비디오를 재생할 때까지 이미지를 표시할 수 있습니다. 123&lt;video controls poster=\"image.png\" width=\"500\"&gt; &lt;source src=\"video.mp4\" type=\"video/mp4\" /&gt;&lt;/video&gt; Readonly &lt;input&gt; 요소와 함께 readonly 속성을 사용하여 해당 요소가 편집할 수 없는 읽기 전용임을 지정할 수 있습니다. 1&lt;input type=\"text\" value=\"This is readonly.\" readonly /&gt; Srcset &lt;img&gt; 및 &lt;source&gt;(&lt;picture&gt;) 요소와 함께 srcset 속성을 사용하여 이미지 소스 목록을 제공할 수 있습니다. 이렇게 하면 브라우저에서 화면 크기에 따라 다른 이미지를 선택할 수 있습니다. 1&lt;img src=\"image.jpg\" srcset=\"image.jpg, image-2x.jpg, image-3x.jpg\" /&gt; Spellcheck &lt;input&gt; 요소(비밀번호 아님), 콘텐츠 편집 가능 요소, &lt;textarea&gt; 요소와 함께 spellcheck 속성을 사용하여 브라우저에서 맞춤법 검사를 사용하거나 사용하지 않도록 설정할 수 있습니다. 1&lt;input type=\"text\" spellcheck=\"false\" /&gt; Title title 속성을 사용하여 요소에 대한 추가 정보를 제공할 수 있습니다. 이 정보는 일반적으로 사용자가 요소 위로 마우스를 가져가면 표시됩니다. 1&lt;a href=\"document.pdf\" title=\"Click to download\"&gt;Download File&lt;/a&gt; 이 속성은 전역 속성이므로 모든 HTML 요소에 이 속성을 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"HTML5","slug":"HTML5","permalink":"http://hgko1207.github.io/tags/HTML5/"},{"name":"Html Attribute","slug":"Html-Attribute","permalink":"http://hgko1207.github.io/tags/Html-Attribute/"}]},{"title":"Meta AI: 페이스북, 인스타그램 등에서의 다목적 AI 비서","slug":"ai-24","date":"2024-04-22T04:56:05.000Z","updated":"2024-04-22T05:05:56.089Z","comments":true,"path":"2024/04/22/ai-24/","link":"","permalink":"http://hgko1207.github.io/2024/04/22/ai-24/","excerpt":"","text":"메타 플랫폼스(Meta Platforms, 구 Facebook)의 아이디어로 탄생한 Meta AI는 소셜 미디어 세계를 강타했습니다. 대규모 Llama 3 언어 모델을 기반으로 하는 이 무료 가상 비서는 메타 생태계(Facebook, Instagram, WhatsApp, Messenger) 내에서 정보 및 창의적인 작업을 위한 원스톱 쇼핑을 목표로 합니다. 기능 Meta AI가 제공하는 기능은 다음과 같습니다. 다방면의 어시스턴트: 친구들과 함께 여행을 조사하는 데 도움이 필요하신가요? 사진 캡션이 마음에 걸리나요? Meta AI는 다양한 작업을 지원할 수 있습니다. 질문에 답하고, 창의적인 글쓰기 프롬프트를 제안하며, 설명을 바탕으로 고유한 이미지를 생성할 수도 있습니다. 원활한 통합: 별도의 앱을 다운로드할 필요가 없습니다. Meta AI는 Facebook Messenger, Instagram 채팅, WhatsApp 그룹에 바로 내장되어 있습니다. &quot;@Meta AI&quot;와 요청을 입력하기만 하면 AI 어시스턴트가 바로 작동합니다. 진화하는 이미지 생성: Meta AI는 인상적인 이미지 생성 기능을 자랑합니다. &quot;imagine&quot;라는 프롬프트에 원하는 이미지를 설명하기만 하면 됩니다. Meta AI는 사실적인 풍경부터 기발한 생물까지 모든 것을 만들 수 있습니다. 또한, 이제 이미지에 애니메이션을 적용하여 GIF로 변환할 수 있어 창의력을 완전히 새로운 차원으로 끌어올릴 수 있습니다. 경쟁사와 비교 그렇다면 Meta AI는 ChatGPT와 저(Gemini)와 같은 경쟁사와 비교했을 때 어떤 점이 다를까요? 접근성: Meta AI의 가장 큰 장점은 Meta의 방대한 사용자 기반과의 통합에 있습니다. 이미 Facebook, WhatsApp 또는 Instagram을 사용 중이라면 추가 계정 없이도 Meta AI에 즉시 액세스할 수 있습니다. 소셜 상호작용에 초점: Meta AI는 소셜 미디어 경험을 향상시키기 위해 특별히 설계된 것 같습니다. 그룹 활동 계획부터 채팅을 위한 재미있는 콘텐츠 생성까지, 소셜 서클 내에서 AI 동반자를 원하는 사용자들에게 적합합니다. 고려사항 하지만 몇 가지 고려해야 할 사항이 있습니다. 제한된 가용성: 현재 Meta AI는 영어와 일부 국가에서만 사용할 수 있습니다. 개인정보 보호 문제: AI 비서를 소셜 미디어 플랫폼에 직접 통합하면 일부 사용자에게는 개인정보 보호에 대한 우려가 제기될 수 있습니다. Meta는 개인 메시지와 통화가 암호화된 상태로 유지되도록 보장하지만, Meta AI가 사용자 데이터를 사용하는 방식은 여전히 논의의 여지가 있습니다. 개발 중: 다른 새로운 AI 기술과 마찬가지로 Meta AI도 아직 개발 중입니다. 인상적이긴 하지만 때때로 요청을 잘못 해석하거나 무의미한 응답을 생성할 수 있습니다. 결론 Meta AI는 AI 비서가 온라인 상호작용의 필수적인 부분이 되는 소셜 미디어의 미래를 엿볼 수 있는 기술입니다. 소셜 서클 내에서 재미있고 편리한 AI 동반자를 찾고 있는 메타 사용자라면 Meta AI를 꼭 사용해 볼 가치가 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Meta AI","slug":"Meta-AI","permalink":"http://hgko1207.github.io/tags/Meta-AI/"},{"name":"Facebook","slug":"Facebook","permalink":"http://hgko1207.github.io/tags/Facebook/"},{"name":"Prompt Engineering","slug":"Prompt-Engineering","permalink":"http://hgko1207.github.io/tags/Prompt-Engineering/"}]},{"title":"[TypeScript] Set/Get, Protected, Private/Public/Static Members","slug":"typescript-17","date":"2024-04-19T01:34:01.000Z","updated":"2024-04-24T14:39:04.353Z","comments":true,"path":"2024/04/19/typescript-17/","link":"","permalink":"http://hgko1207.github.io/2024/04/19/typescript-17/","excerpt":"","text":"이번 글에서는 set/get, protected, private/public, static 멤버의 복잡한 기능에 대해 살펴보겠습니다. 이러한 기능은 타입스크립트 클래스 내에서 접근과 가시성을 제어하는 데 중요한 역할을 합니다. 멤버 가시성 및 접근 제어의 미묘한 차이를 살펴보고 강력하고 캡슐화된 코드 구조를 만드는 데 필요한 도구를 함께 살펴보세요. 1. Public, Private, and Protected Members Public: public으로 표시된 멤버는 클래스 외부에서 액세스할 수 있습니다. 12345678910class Car &#123; public model: string; constructor(model: string) &#123; this.model = model; &#125;&#125;const myCar = new Car('Kia');console.log(myCar.model); // 접근 가능 Private: private로 표시된 멤버는 클래스 내에서만 접근할 수 있습니다. 1234567891011121314151617class Car &#123; private model: string; constructor(model: string) &#123; this.model = model; &#125; getModel(): string &#123; return this.model; // 클래스 내에서 접근 가능 &#125;&#125;const myCar = new Car('Toyota');// console.log(myCar.model); // Error: 속성 'model'은 비공개이며 'Car' 클래스 내에서만 액세스할 수 있습니다.console.log(myCar.getModel()); // 메서드를 통해 접근할 수 있습니다. Protected: protected으로 표시된 멤버는 클래스와 그 하위 클래스(파생 클래스) 내에서 액세스할 수 있습니다. 1234567891011121314151617181920212223class Vehicle &#123; protected wheels: number; constructor(wheels: number) &#123; this.wheels = wheels; &#125;&#125;class Car extends Vehicle &#123; constructor(wheels: number) &#123; super(wheels); &#125; getWheels(): number &#123; return this.wheels; // 파생 클래스에서 접근 가능 &#125;&#125;const myCar = new Car(4);// console.log(myCar.wheels); // Error: 'wheels' 속성은 보호되어 있으며 'Vehicle' 클래스와 그 하위 클래스 내에서만 접근할 수 있습니다.console.log(myCar.getWheels()); // 메서드를 통해 액세스할 수 있습니다. 2. Getter and Setter Getter: private 속성의 값을 검색하는 데 사용됩니다. 123456789101112131415class Circle &#123; private _radius: number; constructor(radius: number) &#123; this._radius = radius; &#125; get radius(): number &#123; return this._radius; &#125;&#125;const myCircle = new Circle(5);console.log(myCircle.radius); // getter를 통해 접근 가능 Setter: private 프로퍼티의 값을 업데이트하는 데 사용됩니다. 1234567891011121314151617181920212223242526272829class Circle &#123; private _radius: number; constructor(radius: number) &#123; this._radius = radius; &#125; get radius(): number &#123; return this._radius; &#125; set radius(newRadius: number) &#123; if (newRadius &gt; 0) &#123; this._radius = newRadius; &#125; &#125;&#125;const myCircle = new Circle(5);console.log(myCircle.radius); // 5myCircle.radius = 7; // setter를 통해 설정합니다.console.log(myCircle.radius); // 7myCircle.radius = -3; // setter에 의해 무시됨console.log(myCircle.radius); // 7 3. Static Members 정적 멤버는 클래스의 인스턴스가 아닌 클래스 자체에 속합니다. 1234567891011class MathOperations &#123; static PI: number = 3.14159; static calculateCircumference(radius: number): number &#123; return 2 * this.PI * radius; &#125;&#125;console.log(MathOperations.PI); // 정적 속성 접근하기console.log(MathOperations.calculateCircumference(5)); // 정적 메서드 호출하기 정적 멤버는 인스턴스를 생성하지 않고 클래스에서 직접 액세스할 수 있습니다. 결론 이러한 기능은 클래스의 내부 상태에 대한 액세스를 캡슐화하고 제어할 수 있는 방법을 제공하여 코드 구성과 유지보수성을 향상시킵니다. 각 멤버에 대해 원하는 캡슐화 수준과 가시성에 따라 적절한 접근 제어자를 선택하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Set/Get","slug":"Set-Get","permalink":"http://hgko1207.github.io/tags/Set-Get/"},{"name":"Protected","slug":"Protected","permalink":"http://hgko1207.github.io/tags/Protected/"},{"name":"Private/Public/Static","slug":"Private-Public-Static","permalink":"http://hgko1207.github.io/tags/Private-Public-Static/"}]},{"title":"[TypeScript] OOP 관행, 클래스 및 상속","slug":"typescript-16","date":"2024-04-19T01:25:16.000Z","updated":"2024-04-19T01:33:52.216Z","comments":true,"path":"2024/04/19/typescript-16/","link":"","permalink":"http://hgko1207.github.io/2024/04/19/typescript-16/","excerpt":"","text":"이번 글에서는 클래스와 상속을 중심으로 객체 지향 프로그래밍(OOP) 사례를 살펴봅니다. 이러한 개념을 통해 실제 엔티티를 구조화되고 유지 관리 가능한 방식으로 모델링할 수 있습니다. 모듈식 재사용 가능한 코드 작성에 대한 인사이트를 제공하는 TypeScript에서 OOP의 심층적인 내용을 살펴보세요. 1. 클래스 클래스는 프로퍼티와 메서드가 있는 객체를 만들기 위한 청사진입니다. 코드에서 실제 엔티티를 모델링하는 방법을 제공합니다. 기본 클래스 예제: 1234567891011121314151617181920212223class Animal &#123; // 속성 name: string; age: number; // 생성자 constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125; // 메서드 makeSound(): void &#123; console.log('Some generic sound'); &#125;&#125;// Animal 클래스의 인스턴스 생성const myAnimal = new Animal('Leo', 5);console.log(myAnimal.name); // Output: LeomyAnimal.makeSound(); // Output: Some generic sound 이 예제에서 Animal은 속성(name과 age), 이러한 속성을 초기화하는 생성자, 메서드(makeSound)를 가진 클래스입니다. 2. 상속 상속을 사용하면 클래스가 다른 클래스로부터 프로퍼티와 메서드를 상속하여 코드 재사용을 촉진하고 계층적 관계를 만들 수 있습니다. 1234567891011121314151617181920212223242526272829303132class Dog extends Animal &#123; // 추가 속성 breed: string; // 생성자 constructor(name: string, age: number, breed: string) &#123; // 기본 클래스(Animal)의 생성자 호출하기 super(name, age); // 파생 클래스 속성 초기화 this.breed = breed; &#125; // makeSound 메서드 재정의 makeSound(): void &#123; console.log('Woof! Woof!'); &#125; // Dog 전용 추가 메서드 fetch(): void &#123; console.log('Fetching the ball!'); &#125;&#125;// Dog 클래스의 인스턴스 생성const myDog = new Dog('Buddy', 3, 'Labrador');console.log(myDog.name); // Output: Buddyconsole.log(myDog.breed); // Output: LabradormyDog.makeSound(); // Output: Woof! Woof!myDog.fetch(); // Output: Fetching the ball! 이 예제에서 Dog는 Animal의 서브클래스입니다. Animal의 프로퍼티와 메서드를 상속받으며 자체 프로퍼티와 메서드를 가질 수도 있습니다. super 키워드는 기본 클래스의 생성자를 호출하는 데 사용됩니다. 3. 접근 제어자 접근 제어자(Access Modifier)는 클래스 멤버(프로퍼티 및 메서드)의 표시 여부를 제어합니다. 타입스크립트는 public, private, protected 접근 제어자를 지원합니다. 1234567891011121314151617class Person &#123; private age: number; constructor(private name: string, age: number) &#123; this.age = age; &#125; getDetails(): string &#123; return `$&#123;this.name&#125;, $&#123;this.age&#125; years old.`; &#125;&#125;const john = new Person('John', 30);console.log(john.getDetails()); // Output: John, 30 years old.// console.log(john.age); // Error: Property 'age' is private and only accessible within class 'Person'. 이 예제에서 age은 private로 표시되어 Person 클래스 내에서만 액세스할 수 있습니다. 4. 추상 클래스 추상 클래스는 인스턴스화할 수 없는 클래스이며 다른 클래스의 베이스 클래스로 사용되는 경우가 많습니다. 123456789101112131415abstract class Shape &#123; abstract calculateArea(): number;&#125;class Circle extends Shape &#123; constructor(private radius: number) &#123; super(); &#125; calculateArea(): number &#123; return Math.PI * this.radius ** 2; &#125;&#125;const myCircle = new Circle(5);console.log(myCircle.calculateArea()); // Output: 78.53981633974483 여기서 Shape는 calculateArea() 추상 메서드를 가진 추상 클래스입니다. Circle 클래스는 Shape를 확장하고 calculateArea()에 대한 구현을 제공합니다. 결론 타입스크립트에서 클래스와 상속을 사용하는 이러한 OOP 관행을 사용하면 모듈화되고 재사용 가능하며 체계적으로 정리된 코드를 만들 수 있습니다. 이를 통해 실제 엔티티와 관계를 반영하는 방식으로 복잡한 시스템을 모델링할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"OOP","slug":"OOP","permalink":"http://hgko1207.github.io/tags/OOP/"},{"name":"상속","slug":"상속","permalink":"http://hgko1207.github.io/tags/%EC%83%81%EC%86%8D/"},{"name":"객체 지향 프로그래밍","slug":"객체-지향-프로그래밍","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}]},{"title":"[TypeScript] Any, Void, Never, Null, Strict Null Checks","slug":"typescript-15","date":"2024-04-18T05:14:46.000Z","updated":"2024-04-19T01:17:12.555Z","comments":true,"path":"2024/04/18/typescript-15/","link":"","permalink":"http://hgko1207.github.io/2024/04/18/typescript-15/","excerpt":"","text":"이번 글에서는 타입스크립트 타입의 동적 환경을 탐색하고, any, void, never, null, 그리고 엄격한 null 체크의 중요성에 대해 살펴봅니다. 이러한 타입을 이해하는 것은 타입 안전을 유지하고 일반적인 프로그래밍 오류를 방지하는 데 필수적입니다. TypeScript의 타입 역학에 대해 알아보세요. 1. Any Type any 타입은 모든 타입의 값을 나타내는 데 사용됩니다. 기본적으로 특정 변수나 표현식에 대한 타입 검사를 사용하지 않습니다. 123let myVariable: any = 'Hello, TypeScript!';myVariable = 42; // No type error any를 사용하면 편리할 수 있지만 TypeScript의 정적 타입 검사의 이점을 희생합니다. 2. Void Type void 타입은 값을 반환하지 않는 함수에 사용됩니다. 함수에 부작용이 있지만 의미 있는 결과를 생성하지 않는 함수를 나타낼 때 자주 사용됩니다. 123function logMessage(message: string): void &#123; console.log(message);&#125; 3. Never Type never 타입은 절대 발생하지 않는 값을 나타냅니다. 예외를 던지거나 무한 루프에 들어가는 함수의 반환 타입으로 자주 사용됩니다. 123function throwError(message: string): never &#123; throw new Error(message);&#125; 12345function infiniteLoop(): never &#123; while (true) &#123; // do something indefinitely &#125;&#125; 4. Null Type 타입스크립트에서 null과 undefined는 기본적으로 모든 타입의 일부입니다. 그러나 엄격 null 검사를 활성화하면 null과 undefined은 모든 타입과 해당 타입에만 할당할 수 있습니다. 1let myString: string = null; // Error with strict null checks enabled 5. Strict Null Checks 기본적으로 TypeScript에는 변수가 null이거나 undefined 경우 이를 명시적으로 표시하여 타입 안전성을 향상시키는 &quot;strict null checks&quot;라는 기능이 있습니다. 이를 통해 null 및 undefined 값과 관련된 많은 일반적인 프로그래밍 오류를 방지할 수 있습니다. TypeScript 프로젝트에서 엄격한 null 검사를 사용하려면 tsconfig.json 파일에서 &quot;strictNullChecks&quot; 옵션을 true로 설정하면 됩니다. 12345&#123; \"compilerOptions\": &#123; \"strictNullChecks\": true &#125;&#125; strict null checks를 활성화하면 변수가 null이거나 undefined 경우를 명시적으로 지정해야 합니다. 123let myString: string | null = null; // OK with strict null checkslet myNumber: number | undefined = undefined; // OK with strict null checks 결론 TypeScript의 이러한 기능을 사용하면 보다 안전하고 예측 가능한 코드를 작성하여 런타임 오류 발생 가능성을 줄이고 애플리케이션의 유지 관리성을 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Any","slug":"Any","permalink":"http://hgko1207.github.io/tags/Any/"},{"name":"Void","slug":"Void","permalink":"http://hgko1207.github.io/tags/Void/"},{"name":"Never","slug":"Never","permalink":"http://hgko1207.github.io/tags/Never/"},{"name":"Strict Null Checks","slug":"Strict-Null-Checks","permalink":"http://hgko1207.github.io/tags/Strict-Null-Checks/"}]},{"title":"[TypeScript] Typing Functions and Signatures","slug":"typescript-14","date":"2024-04-18T04:56:20.000Z","updated":"2024-04-18T05:07:05.764Z","comments":true,"path":"2024/04/18/typescript-14/","link":"","permalink":"http://hgko1207.github.io/2024/04/18/typescript-14/","excerpt":"","text":"이번 글에서는 코드의 기능과 타입 안전을 보장하는 함수와 서명 입력에 중점을 둡니다. 함수 매개변수와 반환 타입에 주석을 다는 방법을 이해하는 것은 효과적인 타입스크립트 개발을 위해 매우 중요합니다. 코드베이스에 명확성과 자신감을 부여하는 함수 입력의 미묘한 차이를 살펴보세요. 1. Function Parameter and Return Type Annotations 타입 어노테이션을 사용하여 함수 매개변수 타입과 반환(Return) 타입을 명시적으로 지정할 수 있습니다. 123456function add(x: number, y: number): number &#123; return x + y;&#125;let result: number = add(3, 5);console.log(result); // Output: 8 이 예제에서 add 함수는 number 타입의 매개변수 두 개를 받아 number 타입의 값을 반환합니다. 2. Optional and Default Parameters 매개변수 이름 뒤에 ?을 추가하여 선택적 매개변수로 만들 수 있으며, = 구문을 사용하여 기본값을 제공할 수 있습니다. 12345678910function greet(name: string, greeting?: string): string &#123; if (greeting) &#123; return `$&#123;greeting&#125;, $&#123;name&#125;!`; &#125; else &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;console.log(greet('John')); // Output: Hello, John!console.log(greet('John', 'Hi')); // Output: Hi, John! 이 예제에서 greet 함수에는 선택적 매개변수(greeting)가 있으며, 이 매개변수가 제공되면 인사말에 사용됩니다. 3. Function Types and Variable Assignment 함수에 대한 타입을 정의하고 변수에 할당할 수 있습니다. 123456789// Function type definitiontype MathOperation = (a: number, b: number) =&gt; number;// Function assigned to a variable with the defined typeconst multiply: MathOperation = (x, y) =&gt; x * y;let multiplicationResult: number = multiply(4, 6);console.log(multiplicationResult); // Output: 24 여기서 MathOperation은 number 타입의 매개변수 두 개를 받아 number를 반환하는 함수를 나타내는 타입입니다. 4. Function Overloads 함수 오버로드를 사용하여 함수에 대해 여러 타입 서명을 제공할 수 있습니다. 123456789101112// Function overloadsfunction combine(a: string, b: string): string;function combine(a: number, b: number): number;function combine(a: any, b: any): any &#123; return a + b;&#125;let stringResult: string = combine('Hello, ', 'world!');let numberResult: number = combine(3, 5);console.log(stringResult); // Output: Hello, world!console.log(numberResult); // Output: 8 이 예제에서 combine 함수에는 여러 타입 서명이 있어 두 개의 문자열 또는 두 개의 숫자를 받아들일 수 있습니다. 결론 함수와 매개변수를 올바르게 입력하면 코드 명확성을 높이고, 더 나은 도구 지원을 가능하게 하며, 개발 중에 잠재적인 오류를 포착할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Typed Functions","slug":"Typed-Functions","permalink":"http://hgko1207.github.io/tags/Typed-Functions/"},{"name":"Function Signature","slug":"Function-Signature","permalink":"http://hgko1207.github.io/tags/Function-Signature/"}]},{"title":"[TypeScript] Union, Literal, Tagged Types","slug":"typescript-13","date":"2024-04-17T05:11:32.000Z","updated":"2024-04-18T04:57:03.892Z","comments":true,"path":"2024/04/17/typescript-13/","link":"","permalink":"http://hgko1207.github.io/2024/04/17/typescript-13/","excerpt":"","text":"이번 글에서는 타입 정의의 정확성과 표현력을 높여주는 Union 타입, Literal 타입, Tagged 타입에 대해 살펴봅니다. 이러한 기능을 이해하면 더욱 강력하고 미묘한 타입 시스템을 만들 수 있습니다. TypeScript의 고급 유형 기능의 세계를 탐색하는 이 여정에 함께하세요. 1. Union Types Union 타입은 변수가 두 가지 이상의 타입을 가질 수 있게 해줍니다. 연산자를 사용하여 유형을 결합할 수 있습니다. 12345678type Result = number | string;function displayResult(result: Result): void &#123; console.log(result);&#125;displayResult(42); // Output: 42displayResult('hello'); // Output: hello 이 예제에서 Result는 숫자나 문자열일 수 있습니다. 2. Literal Types Literal 타입을 사용하면 변수가 가질 수 있는 정확한 값을 지정할 수 있습니다. 문자열 리터럴, 숫자 리터럴, 부울 리터럴 등과 함께 사용할 수 있습니다. 12345678type Direction = 'up' | 'down' | 'left' | 'right';function move(direction: Direction): void &#123; console.log(`Moving $&#123;direction&#125;`);&#125;move('up'); // Output: Moving upmove('right'); // Output: Moving right 여기서 Direction은 특정 문자열 “up”, “down”, “left” 또는 &quot;right&quot;를 나타내는 리터럴 타입입니다. 3. Tagged Union Types Tagged Union 타입은 값이 여러 타입 중 하나일 수 있고 공통 속성(태그)으로 구분하려는 시나리오를 모델링하는 데 자주 사용됩니다. 12345678910111213141516171819202122232425interface Square &#123; kind: 'square'; size: number;&#125;interface Circle &#123; kind: 'circle'; radius: number;&#125;type Shape = Square | Circle;function area(shape: Shape): number &#123; if (shape.kind === 'square') &#123; return shape.size * shape.size; &#125; else &#123; return Math.PI * shape.radius * shape.radius; &#125;&#125;const mySquare: Square = &#123; kind: 'square', size: 4 &#125;;const myCircle: Circle = &#123; kind: 'circle', radius: 3 &#125;;console.log(area(mySquare)); // Output: 16console.log(area(myCircle)); // Output: 28.274333882308138 이 예제에서 Shape는 두 가지 가능한 모양을 가진 Tagged 유니온 유형입니다: Square과 Circle입니다. kind 속성은 두 도형을 구분하는 태그 역할을 합니다. 결론 이러한 기능은 표현력이 풍부하고 정확한 유형 정의를 생성할 수 있는 강력한 도구를 제공하여 코드에서 특정 패턴을 캡처하고 적용할 수 있게 해줍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Union","slug":"Union","permalink":"http://hgko1207.github.io/tags/Union/"},{"name":"Literal","slug":"Literal","permalink":"http://hgko1207.github.io/tags/Literal/"},{"name":"Tagged Type","slug":"Tagged-Type","permalink":"http://hgko1207.github.io/tags/Tagged-Type/"}]},{"title":"웹 개발자의 생산성을 높여주는 10가지 VS Code 확장 프로그램","slug":"info-13","date":"2024-04-16T01:58:09.000Z","updated":"2024-04-16T02:09:31.741Z","comments":true,"path":"2024/04/16/info-13/","link":"","permalink":"http://hgko1207.github.io/2024/04/16/info-13/","excerpt":"","text":"VS Code는 유연성, 속도, 광범위한 확장 기능 라이브러리로 인해 웹 개발자들 사이에서 매우 인기 있는 코드 편집기입니다. 이 블로그에서는 웹 개발자의 생산성을 높여주는 10가지 VS Code 확장 프로그램을 소개합니다. Live Preview Live Preview 확장 프로그램을 사용하면 VS Code 내부의 작은 브라우저에서 웹 사이트를 볼 수 있습니다. 따라서 웹사이트의 변경 사항을 확인하기 위해 코드 편집기에서 나갈 필요가 없습니다. HTML, CSS 또는 JavaScript 파일을 변경하면 자동으로 업데이트됩니다. 따라서 매번 페이지를 새로고침할 필요가 없습니다. ESLint ESLint 확장 프로그램은 자바스크립트 개발자의 필수품입니다. 코드를 검사하여 세미콜론을 잊어버리거나 정의되지 않은 변수를 사용하는 등의 실수가 있는지 알려주고 더 나은 코드를 작성하도록 안내합니다. Prettier Prettier 확장 프로그램은 저장할 때마다 원하는 스타일 가이드에 맞게 코드 서식을 자동으로 지정해주는 코드 서식 지정기입니다. 따라서 코드가 항상 깔끔하고 깔끔하게 보입니다. Path Intellisense Path Intellisense 확장 프로그램은 파일 경로에 대한 자동 완성 제안을 제공합니다. 오류 발생 가능성을 줄이고 긴 경로를 수동으로 입력하는 수고를 덜어줍니다. Peacock Peacock은 다양한 VS Code 작업 영역에 대해 서로 다른 색상을 선택할 수 있는 독특한 확장 프로그램입니다. 여러 프로젝트를 동시에 작업할 때 유용합니다. 각 프로젝트 작업 영역에 다른 색상을 지정하여 쉽게 구분할 수 있습니다 VSCode-icons VSCode-icons 확장 프로그램은 폴더와 파일에 아이콘을 추가합니다. 시각적으로 더 매력적이고 직관적으로 보이도록 만들어 줍니다. Tabnine Tabnine은 AI 기반 코드 완성 확장 프로그램입니다. 입력 패턴을 확인하고 전체 줄 또는 코드 블록을 제안하여 코딩 프로세스 속도를 높일 수 있도록 도와줍니다. Code Runner Code Runner 확장 프로그램을 사용하면 에디터 내에서 코드 스니펫을 실행할 수 있습니다. 여러 언어와 프레임워크를 지원합니다. ES7+ React/Redux/React-Native Snippets ES7+ React/Redux/React-Native Snippets은 상용구 코드에 빠르고 쉽게 액세스할 수 있는 기능을 제공합니다. React, Redux 또는 React Native로 작업하는 경우 이러한 스니펫을 사용하면 시간을 절약하고 개발 워크플로우 속도를 높일 수 있습니다. Postman Postman 확장 프로그램은 API 관련 프로젝트를 진행하는 웹 개발자에게 꼭 필요한 도구입니다. 코드 편집기에서 바로 API를 쉽게 다루고 테스트할 수 있습니다. 앞뒤로 전환할 필요가 없습니다. 결론 VS Code 확장 프로그램을 사용해 보면 작업 속도가 빨라지고, 작업이 더 원활해지며, 코드가 깔끔하게 유지됩니다. 직접 사용해 보시고 개발 프로세스의 차이를 경험해 보세요.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://hgko1207.github.io/tags/VS-Code/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"생산성 향상","slug":"생산성-향상","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1-%ED%96%A5%EC%83%81/"},{"name":"개발자","slug":"개발자","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"VS Code 확장 프로그램","slug":"VS-Code-확장-프로그램","permalink":"http://hgko1207.github.io/tags/VS-Code-%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"}]},{"title":"CSS 미디어 쿼리(Media Query): 반응형 웹사이트를 위한 초보자 가이드","slug":"web-7","date":"2024-04-09T13:18:20.000Z","updated":"2024-04-12T05:30:07.282Z","comments":true,"path":"2024/04/09/web-7/","link":"","permalink":"http://hgko1207.github.io/2024/04/09/web-7/","excerpt":"","text":"끊임없이 변화하는 웹 개발 세계에서 휴대폰, 태블릿, 노트북 등 모든 기기에서 멋지게 보이고 원활하게 작동하는 웹사이트를 만드는 것은 매우 중요합니다. 이 글에서는 반응형 웹사이트를 만들기 위한 CSS 미디어 쿼리에 대해 알아봅니다. CSS 미디어 쿼리란 무엇인가요? CSS 미디어 쿼리는 화면 너비, 높이, 디바이스 방향, 해상도 등에 따라 디바이스마다 다른 스타일을 적용하는 데 사용됩니다. 미디어 쿼리를 사용하면 사용자의 기기에 완벽하게 반응하는 웹 디자인을 만들고 사용자 경험을 향상시킬 수 있습니다. 미디어 쿼리의 기본 구문 미디어 쿼리의 기본 구문은 다음과 같습니다. 123@media media-type and (media-expression) &#123; /* CSS styles go here */&#125; @media: 미디어 쿼리의 시작을 나타내는 데 사용됩니다. media-type: 브라우저에 이 코드가 어떤 종류의 미디어인지 알려줍니다. 여기에는 다음과 같은 값을 사용할 수 있습니다. all — 모든 미디어 타입 디바이스용. print — 프린터용. screen — 데스크톱 화면, 랩톱, 태블릿, 휴대폰 등. speech — 페이지를 소리 내어 읽는 스크린 리더용입니다. media-expression: CSS를 적용하기 위해 전달해야 하는 규칙입니다. 예를 들어 표현식에서 화면 너비를 600px로 지정하면 화면 크기가 이 너비와 일치할 때만 관련 CSS 스타일이 적용되고, 그렇지 않으면 비활성 상태로 유지됩니다. { /* CSS styles go here */ }: 여기에는 지정된 media-type과 media-expression에 적용하려는 CSS 스타일이 작성됩니다. 12345@media screen and (max-width: 600px) &#123; body &#123; background-color: red; &#125;&#125; 여기서 media-type은 화면이고 media-expression은 max-width: 600px이므로 화면 너비가 600px 이하일 때 본문의 배경색이 변경됩니다(여기서는 최대 너비가 600px이므로). 제공된 미디어 표현식을 중단점이라고도 합니다. 따라서 여기서는 600px가 중단점입니다. 이제 media-expression에 어떤 값을 지정할 수 있는지 생각해 보셨을 것입니다. media-expression에 가장 일반적으로 사용되는 값을 알려드리겠습니다. width and height of the device orientation (for example, tablet/mobile phone is in landscape or portrait mode) resolution ranged syntax 디바이스의 너비와 높이 방향(예: 태블릿/휴대폰이 가로 또는 세로 모드인 경우) 해상도 범위 구문 위의 각 값을 이해하기 위해 몇 가지 예를 살펴보겠습니다. 예시 디바이스의 너비와 높이 123456@media screen and (max-width: 675px) &#123; body &#123; background-color: red; color: white; &#125;&#125; 이 예제에서는 화면 크기가 675px 이하인 경우 배경색과 본문 색상이 변경됩니다. 디바이스 방향 가로 또는 세로로 방향을 지정할 수 있습니다. 1234567/* Styles for landscape orientation */@media screen and (orientation: landscape) &#123; body &#123; background-color: red; color: white; &#125;&#125; 해상도 해상도에 따라 디바이스를 타깃팅할 수도 있습니다. 1234567/* Styles for high-resolution displays */@media screen and (min-resolution: 300dpi) &#123; body &#123; background-color: red; color: white; &#125;&#125; 범위 구문 123456@media (min-width: 375px) and (max-width: 758px) &#123; body &#123; background-color: red; color: white; &#125;&#125; 이 예제에서는 화면 크기가 375px에서 758px 사이인 경우 배경색과 본문 색상이 변경됩니다. 미디어 쿼리를 사용하면 디바이스마다 다른 CSS 스타일을 설정할 수 있습니다. 일반적인 중단점 이제 미디어 쿼리에 대해 배우고 나면 &quot;화면의 중단점(breakpoint)을 어떻게 알 수 있나요?&quot;라는 질문이 생길 수 있습니다.🤔 다음은 디바이스에 일반적으로 사용되는 몇 가지 중단점입니다. 1234567891011121314151617181920212223242526272829/* 초대형 화면 */@media (min-width: 1920px) &#123; /* CSS styles go here */&#125;/* 데스크톱 */@media (min-width: 1200px) and (max-width: 1919px) &#123; /* CSS styles go here */&#125;/* 노트북/대형 태블릿 */@media (min-width: 992px) and (max-width: 1199px) &#123; /* CSS styles go here */&#125;/* 소형 태블릿 */@media (min-width: 768px) and (max-width: 991px) &#123; /* CSS styles go here */&#125;/* 초소형 디바이스 */@media (min-width: 481px) and (max-width: 767px) &#123; /* CSS styles go here */&#125;/* 모바일 */@media (max-width: 480px) &#123; /* CSS styles go here */&#125; 표준 중단점은 명시적으로 정의되어 있지 않지만 일반적으로 사용되는 이러한 중단점을 사용하여 웹사이트를 반응형으로 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"미디어 쿼리","slug":"미디어-쿼리","permalink":"http://hgko1207.github.io/tags/%EB%AF%B8%EB%94%94%EC%96%B4-%EC%BF%BC%EB%A6%AC/"},{"name":"Media Query","slug":"Media-Query","permalink":"http://hgko1207.github.io/tags/Media-Query/"},{"name":"반응형 웹사이트","slug":"반응형-웹사이트","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8/"}]},{"title":"CSS 개발자가 알아야 할 시간 절약형 웹사이트 11가지","slug":"web-design-7","date":"2024-04-09T12:37:28.000Z","updated":"2024-04-09T13:54:35.827Z","comments":true,"path":"2024/04/09/web-design-7/","link":"","permalink":"http://hgko1207.github.io/2024/04/09/web-design-7/","excerpt":"","text":"이 글에서는 시간을 많이 절약하고 CSS 개발 경험을 향상시킬 수 있는 15개의 웹사이트를 소개합니다. CSS Buttons CSS Buttons을 사용하면 버튼 디자인 과정을 간소화할 수 있습니다. 이 웹사이트는 작업을 더 빠르게 완료할 수 있도록 해당 CSS 코드와 함께 사용자 정의 가능한 버튼 스타일의 훌륭한 컬렉션을 제공합니다. Neumorphism .io Neumorphism or soft UI를 사용하여 뉴모픽 요소를 생성하고 해당 CSS 코드를 가져와 요소에 물리적 객체의 모양을 부여할 수 있습니다. CSS Strips Generator CSS Strips Generator는 스트라이프 배경을 만들고 디자인을 향상시키는 데 사용할 수 있습니다. Google Fonts 다양한 무료 및 오픈 소스 글꼴 컬렉션에 Google Fonts을 사용하여 웹사이트의 타이포그래피를 향상시킬 수 있습니다. Google Fonts을 사용하여 프로젝트에 글꼴을 쉽게 통합할 수 있습니다. Get Waves Get Waves를 사용하면 눈길을 사로잡는 SVG 물결 패턴을 만들어 웹사이트에 역동적인 느낌을 더할 수 있습니다. Can I Use CSS를 작성할 때는 브라우저 호환성을 파악하는 것이 중요합니다. Can I Use을 사용하여 최신 브라우저 지원 표를 확인할 수 있습니다. ColorSpace 웹사이트를 시각적으로 매력적으로 만들려면 올바른 색상 팔레트를 선택하는 것이 중요합니다. 색상을 입력하기만 하면 ColorSpace을 사용하여 프로젝트에 딱 맞는 색상을 선택할 수 있습니다. CSS Grid Generator CSS Grid Generator는 복잡한 그리드 레이아웃을 만들고 해당 CSS 코드를 생성하는 데 유용한 도구입니다. CSS Gradient Generator CSS Gradient Generator는 복잡한 CSS 그라디언트를 쉽게 만들 수 있습니다. 또한 해당 CSS 코드도 제공합니다. Animate.css 프로젝트에 쉽게 통합할 수 있는 바로 사용할 수 있는 다양한 애니메이션 모음을 위해 Animate.css를 사용할 수 있습니다. CSS Validator CSS Validator는 CSS 코드가 웹의 규칙을 따르는지 확인하는 데 사용할 수 있습니다. W3C의 CSS Validator는 스타일시트를 살펴보고 코드 작성 방식에서 실수를 찾아내어 CSS 표준을 충족하는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Css Website","slug":"Css-Website","permalink":"http://hgko1207.github.io/tags/Css-Website/"}]},{"title":"[TypeScript] Type, Enum, Interface 타입 만들기","slug":"typescript-12","date":"2024-04-09T05:43:10.000Z","updated":"2024-04-09T06:00:35.440Z","comments":true,"path":"2024/04/09/typescript-12/","link":"","permalink":"http://hgko1207.github.io/2024/04/09/typescript-12/","excerpt":"","text":"이번 글에서는 사용자 정의 타입, Enum 및 Interface를 만드는 데 초점을 맞춥니다. 이러한 강력한 구조를 사용하면 표현력이 풍부하고 잘 정의된 코드 구조를 만들 수 있습니다. 타입을 만들고, 명명된 상수에 Enum을 활용하고, 명확한 Interface를 디자인하여 TypeScript 프로젝트의 협업과 유지 관리성을 향상시키는 방법을 살펴보세요. 1. Type 만들기 type을 사용하면 기존 타입에 대한 사용자 정의 이름을 정의하거나 타입의 조합을 만들 수 있습니다. 12345678910type Status = 'success' | 'error';function processStatus(status: Status): void &#123; console.log(`Processing status: $&#123;status&#125;`);&#125;let myStatus: Status = 'success';processStatus(myStatus);// Output: Processing status: success 이 예제에서 Status는 “success” 또는 &quot;error&quot;를 나타내는 사용자 정의 타입입니다. 2. Enum enum은 숫자 값 집합에 보다 친숙한 이름을 부여하는 방법입니다. 1234567891011enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT',&#125;let playerDirection: Direction = Direction.Up;console.log(`Player is moving $&#123;playerDirection&#125;`);// Output: Player is moving UP 여기서 Direction은 각 멤버에 문자열 값이 할당된 Enum 입니다. 3. Interface interface는 객체 형상에 대한 컨트랙트를 정의하여 객체가 준수해야 하는 구조를 지정할 수 있습니다. 1234567891011121314151617interface Person &#123; firstName: string; lastName: string; age: number; sayHello: () =&gt; void;&#125;const john: Person = &#123; firstName: 'John', lastName: 'Doe', age: 30, sayHello: () =&gt; &#123; console.log(`Hello, I'm $&#123;john.firstName&#125; $&#123;john.lastName&#125;.`); &#125;,&#125;;john.sayHello(); // Output: Hello, I'm John Doe. 이 예제에서 Person은 firstName, lastName, age 및 sayHello 메서드가 있는 객체의 구조를 정의하는 인터페이스입니다. Type, Enum 및 Interface 결합하기 123456789101112131415161718192021222324type Car = &#123; make: string; model: string; year: number;&#125;;enum FuelType &#123; Gasoline = 'Gasoline', Electric = 'Electric', Hybrid = 'Hybrid',&#125;interface ElectricCar extends Car &#123; batteryCapacity: number; fuelType: FuelType.Electric;&#125;const myElectricCar: ElectricCar = &#123; make: 'Tesla', model: 'Model 3', year: 2022, batteryCapacity: 75, fuelType: FuelType.Electric,&#125;; 여기에는 Car 타입, FuelType Enum, 그리고 Car 타입을 확장하는 ElectricCar 인터페이스가 있습니다. myElectricCar는 ElectricCar 인터페이스에 부합하는 객체입니다. 결론 이러한 개념을 사용하면 명확한 구조를 적용하고 유형과 값에 의미 있는 이름을 제공함으로써 보다 강력하고 유지 관리가 쉬운 코드를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Enum","slug":"Enum","permalink":"http://hgko1207.github.io/tags/Enum/"},{"name":"TypeScript Type","slug":"TypeScript-Type","permalink":"http://hgko1207.github.io/tags/TypeScript-Type/"}]},{"title":"알아야 할 13가지 HTML 속성","slug":"web-design-6","date":"2024-04-02T05:08:17.000Z","updated":"2024-04-09T05:40:52.317Z","comments":true,"path":"2024/04/02/web-design-6/","link":"","permalink":"http://hgko1207.github.io/2024/04/02/web-design-6/","excerpt":"","text":"Accept 속성 1&lt;input type=\"file\" accept=\".jpg, .jpeg, .png\" /&gt; Alt 속성 1&lt;img src=\"nature.png\" alt=\"A beautiful sunset\" /&gt; Autocomplete 속성 1&lt;input type=\"text\" name=\"name\" autocomplete=\"on\" /&gt; Contenteditable 속성 1&lt;div contenteditable=\"true\"&gt;You can edit this content.&lt;/div&gt; Download 속성 1&lt;a href=\"document.pdf\" download=\"document.pdf\"&gt;Download PDF&lt;/a&gt; Hidden 속성 1&lt;div hidden&gt;This is hidden content.&lt;/div&gt; Loading 속성 1&lt;img src=\"image.png\" loading=\"lazy\" /&gt; Multiple 속성 1234567&lt;input type=\"file\" multiple /&gt;&lt;select multiple&gt; &lt;option value=\"java\"&gt;Java&lt;/option&gt; &lt;option value=\"javascript\"&gt;JavaScript&lt;/option&gt; &lt;option value=\"typescript\"&gt;TypeScript&lt;/option&gt; &lt;option value=\"rust\"&gt;Rust&lt;/option&gt;&lt;/select&gt; Poster 속성 123&lt;video controls poster=\"image.png\" width=\"500\"&gt; &lt;source src=\"video.mp4\" type=\"video/mp4\" /&gt;&lt;/video&gt; Readonly 속성 1&lt;input type=\"text\" value=\"This is readonly.\" readonly /&gt; Srcset 속성 1&lt;img src=\"image.jpg\" srcset=\"image.jpg, image-2x.jpg, image-3x.jpg\" /&gt; Spellcheck 속성 1&lt;input type=\"text\" spellcheck=\"false\" /&gt; Title 속성 1&lt;a href=\"document.pdf\" title=\"Click to download\"&gt;Download File&lt;/a&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"알아야 할 가장 일반적인 자바스크립트 문자열 메서드 13가지","slug":"js-dev-20","date":"2024-04-02T04:33:58.000Z","updated":"2024-04-02T04:57:38.549Z","comments":true,"path":"2024/04/02/js-dev-20/","link":"","permalink":"http://hgko1207.github.io/2024/04/02/js-dev-20/","excerpt":"","text":"자바스크립트에서 문자열은 문자의 시퀀스입니다. 자바스크립트는 문자열을 조작하고 작업할 수 있는 다양한 메서드를 제공합니다. 이 글에서는 가장 일반적으로 사용되는 13가지 자바스크립트 문자열 메서드와 그 기능을 소개합니다. 문자열 길이 문자열의 문자 수를 찾으려면 length 속성을 사용할 수 있습니다. 123const str = 'This is a string.';const lengthOfStr = str.length;console.log(lengthOfStr); // Output: 17 이 함수는 공백도 계산합니다. toUpperCase() 문자열을 대문자로 변환하려면 toUpperCase() 메서드를 사용할 수 있습니다. 123const str = 'This is a string.';const uppercaseStr = str.toUpperCase();console.log(uppercaseStr); // Output: THIS IS A STRING. toLowerCase() 문자열을 소문자로 변환하려면 toLowerCase() 메서드를 사용할 수 있습니다. 123const str = 'This Is a String.';const lowercaseStr = str.toLowerCase();console.log(lowercaseStr); // Output: this is a string. indexOf() 문자열에서 부분 문자열의 첫 번째 출현을 찾으려면 indexOf() 메서드를 사용할 수 있습니다. 123const str = 'This is a js string and js string is nice.';const indexOfJs = str.indexOf('js');console.log(indexOfJs); // Output: 10 lastIndexOf() 문자열에서 하위 문자열의 마지막 출현을 찾으려면 lastIndexOf() 메서드를 사용할 수 있습니다. 123const str = 'This is a js string and js string is nice.';const lastIndexOfJs = str.lastIndexOf('js');console.log(lastIndexOfJs); // Output: 24 slice() 문자열의 일부를 추출하려면 slice() 메서드를 사용할 수 있습니다. 이 메서드는 추출된 부분을 새 문자열로 반환합니다. Syntax: 1string.slice(start position, end position); 끝 위치는 포함되지 않습니다. 123456789//예시 1const str1 = 'This is a string.';const slicedStr1 = str1.slice(0, 7);console.log(slicedStr1); // Output: This is//예시 2const str2 = 'This is a string.';const slicedStr2 = str2.slice(3, 9);console.log(slicedStr2); // Output: s is a 끝 위치를 지정하지 않으면 문자열의 나머지 부분을 잘라냅니다. 예를 들어 123const str = 'This is a string.';const slicedStr = str.slice(5);console.log(slicedStr); // Output: is a string. 음수 매개변수를 지정할 수도 있습니다. 예를 들어 123const str = 'This is a string.';const slicedStr = str.slice(-3, -1);console.log(slicedStr); // Output: ng 간단히 말하면 다음과 같이 이해할 수 있습니다. 1234str.slice(-3, -1);str.slice(str.length - 3, str.length - 1);str.slice(17 - 3, 17 - 1);str.slice(14, 16); substring() substring() 메서드는 slice() 메서드와 비슷하지만 음수 매개변수(0 미만)를 지정하면 0으로 처리된다는 차이점이 있습니다. 123const str = 'This is a string.';const slicedStr = str.substring(-3, 5);console.log(slicedStr); // Output: This substr() substr() 메서드는 slice() 메서드와 비슷하지만, 끝 매개변수가 추출할 문자의 길이라는 점이 다릅니다. 12345const str = 'This is a string.';//이것은 인덱스 11에서 시작하는 문자를 추출합니다.//4개의 문자를 추출합니다.const slicedStr = str.substr(11, 4);console.log(slicedStr); // Output: trin charAt() 문자열에서 지정된 인덱스에 있는 문자를 가져오려면 charAt() 메서드를 사용할 수 있습니다. 123const str = 'This is a string.';const character = str.charAt(13);console.log(character); // Output: i concat() 두 개 이상의 문자열을 연결하려면 concat() 메서드를 사용할 수 있습니다. 1234const firstName = 'John';const lastName = 'Doe';const fullName = firstName.concat(' ', lastName);console.log(fullName); // Output: John Doe trim() trim() 메서드를 사용하여 문자열의 양쪽 끝에서 공백을 제거할 수 있습니다. 123const str = ' This is a string. ';const trimmedStr = str.trim();console.log(trimmedStr); // Output: This is a string. replace() 지정된 부분 문자열을 다른 문자열로 바꾸려면 replace() 메서드를 사용할 수 있습니다. 123const str = 'JavaScript is amazing!';const replacedStr = str.replace('amazing', 'awesome');console.log(replacedStr); // Output: JavaScript is awesome! split() split() 메서드를 사용하여 문자열을 배열로 변환할 수 있습니다. 12345678const str1 = 'JavaScript is amazing!';const arr1 = str1.split();console.log(arr1); // Output: ['JavaScript is amazing!']//Example:2const str2 = 'JavaScript is amazing!';const arr2 = str2.split(' ');console.log(arr2); // Output: ['JavaScript', 'is', 'amazing!']","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"자바스크립트 문자열","slug":"자바스크립트-문자열","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"문자열 메서드","slug":"문자열-메서드","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C/"}]},{"title":"모든 개발자가 반드시 북마크해야 하는 18가지 GitHub Repository","slug":"info-12","date":"2024-04-02T04:25:25.000Z","updated":"2024-04-04T05:20:36.612Z","comments":true,"path":"2024/04/02/info-12/","link":"","permalink":"http://hgko1207.github.io/2024/04/02/info-12/","excerpt":"","text":"이 글에서는 코딩 여정에 도움이 되는 북마크에 꼭 추가해야 할 18개의 GitHub 리포지토리를 소개합니다. 30일간의 자바스크립트 이 리포지토리는 실습을 통해 자바스크립트 기술을 향상시키는 데 도움이 되는 30일간의 자바스크립트 코딩 챌린지를 제공합니다. https://github.com/wesbos/JavaScript30 30초 코드 30초 이내에 이해할 수 있는 유용한 자바스크립트 스니펫 모음입니다. https://github.com/30-seconds/30-seconds-of-code 앱 아이디어 이 리포지토리에서는 코딩 기술을 향상시키는 데 사용할 수 있는 애플리케이션 아이디어 모음을 제공합니다. https://github.com/florinpop17/app-ideas Awesome JavaScript 더 나은 JavaScript 개발자가 되는 데 도움이 되는 엄선된 JavaScript 프레임워크, 라이브러리, 리소스 및 도구 목록이 포함되어 있습니다. https://github.com/sorrycc/awesome-javascript Beautiful Docs 다양한 프로그래밍 언어와 기술에 대한 훌륭한 예제와 팁을 모아 프로젝트에 대한 멋진 문서를 작성하는 데 도움이 되는 자료입니다. https://github.com/matheusfelipeog/beautiful-docs 나만의 X 빌드 이 리포지토리를 확인하여 좋아하는 기술을 처음부터 다시 만들어 프로그래밍을 마스터할 수 있습니다. https://github.com/codecrafters-io/build-your-own-x 코딩 인터뷰 대학 이 리포지토리에서는 코딩 면접 준비를 위한 데이터 구조, 알고리즘, 시스템 설계 등 다양한 주제를 다룹니다. https://github.com/jwasham/coding-interview-university CSS 스타일 가이드 이 리포지토리에서는 깔끔하고 확장 가능하며 유지 관리가 용이한 CSS 코드를 작성하기 위한 모범 사례와 규칙을 제공합니다. https://github.com/dropbox/css-style-guide 개발자를 위한 디자인 리소스 이 리포지토리에서 학습하여 디자인 기술을 향상하고 더 나은 사용자 경험을 만들 수 있습니다. 여기에는 도구, 라이브러리, 웹사이트, 문서 등 엄선된 디자인 리소스 목록이 제공됩니다. https://github.com/bradtraversy/design-resources-for-developers 개발자 로드맵 개발자로서 경력을 쌓기 위해 무엇을 어떤 순서로 배워야 하는지에 대한 명확한 가이드를 제공합니다. https://github.com/kamranahmedse/developer-roadmap 무료 인증 이 리포지토리에서는 다양한 기술 주제에 대한 종합적인 인증 및 교육 과정 목록을 제공합니다. https://github.com/cloudcommunity/Free-Certifications 개발자용 무료 무료로 사용할 수 있는 소프트웨어 및 서비스 모음을 제공합니다. https://github.com/ripienaar/free-for-dev 무료 프로그래밍 책 다양한 언어, 프레임워크 및 기술을 다루는 방대한 무료 프로그래밍 서적 모음을 제공하는 귀중한 리소스입니다. https://github.com/EbookFoundation/free-programming-books 웹 작동 방식 이 리포지토리는 웹 개발 및 네트워킹의 기본을 이해하는 데 유용한 리소스입니다. https://github.com/vasanthk/how-web-works Node 모범 사례 이 리포지토리에서는 프로젝트 구조, 오류 처리, 보안, 성능 최적화 등과 같은 주제를 다루는 Node.js 애플리케이션 구축에 대한 모범 사례 모음을 제공합니다. https://github.com/goldbergyoni/nodebestpractices 프로젝트 기반 학습 실습 프로젝트를 통해 프로그래밍 개념을 가르치는 프로젝트 기반 튜토리얼의 유용한 리소스입니다. https://github.com/practical-tutorials/project-based-learning 공개 API 소프트웨어 및 웹 개발 프로젝트에 사용할 수 있는 무료 공개 API 모음입니다. https://github.com/public-apis/public-apis You-don’t-know-JS 이 리포지토리는 JavaScript의 특이한 점, 뉘앙스 및 고급 기능을 이해하기 위한 리소스입니다. https://github.com/getify/You-Dont-Know-JS","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"GitHub Repository","slug":"GitHub-Repository","permalink":"http://hgko1207.github.io/tags/GitHub-Repository/"},{"name":"개발자","slug":"개발자","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"북마크","slug":"북마크","permalink":"http://hgko1207.github.io/tags/%EB%B6%81%EB%A7%88%ED%81%AC/"}]},{"title":"모든 웹 개발자가 꼭 사용해야 하는 100개 이상의 무료 리소스","slug":"web-6","date":"2024-04-01T05:11:35.000Z","updated":"2024-04-09T13:54:09.630Z","comments":true,"path":"2024/04/01/web-6/","link":"","permalink":"http://hgko1207.github.io/2024/04/01/web-6/","excerpt":"","text":"이 글에서는 API, 호스팅 플랫폼, Cheat Sheet, 아이콘, 템플릿, 글꼴, 색상 리소스, 학습 플랫폼, CSS 게임, 코드 편집기, JavaScript 애니메이션 라이브러리 등 100개 이상의 무료 웹 개발 리소스를 공유해드리겠습니다. 웹 개발을 배울 수 있는 무료 리소스 🔥 웹사이트 freeCodeCamp MDN Web Docs W3Schools Scrimba Codecademy TheOdinProject Frontend Mentor Javascript30 Coursera Khan Academy 웹사이트를 위한 무료 호스팅 플랫폼 🔥 Netlify: 웹 프로젝트를 쉽게 배포하세요. Render: 웹 애플리케이션과 정적 사이트를 손쉽게 호스팅하세요. GitHub Pages: GitHub 리포지토리에서 직접 정적 웹사이트를 호스팅하세요. Firebase Hosting: Firebase로 웹 앱을 손쉽게 확장하세요. Vercel: 자동 배포를 통해 웹사이트와 애플리케이션을 배포하세요. Cyclic.sh: 별도의 설정 없이 정적 사이트를 호스팅하세요. Appwrite: 웹 및 모바일 개발자를 위한 오픈 소스 백엔드 서버. Supabase: 확장 가능한 백엔드로 최신 앱을 빌드하세요. InfinityFree: PHP, MySQL 등이 포함된 무료 무제한 웹 호스팅. Surge: 프론트엔드 개발자를 위한 정적 웹 퍼블리싱. 프로젝트를 위한 무료 API 🔥 OpenWeatherMap API:모든 위치의 현재 날씨 데이터에 액세스하세요. News API: 다양한 소스에서 실시간 뉴스 기사를 검색하세요. REST Countries API: 전 세계 국가에 대한 정보를 가져옵니다. Chuck Norris Jokes API: Chuck Norris 농담으로 프로젝트에 활기를 불어넣으세요. Open Food Facts API: 식품 정보 및 성분에 액세스하세요. GitHub API: GitHub 기능을 애플리케이션에 통합하세요. Reddit API: 게시물과 댓글을 포함한 Reddit 데이터를 가져옵니다. OneDrive API: Microsoft OneDrive에서 파일과 폴더를 관리하세요. Dogs API: 프로젝트에 사랑스러운 강아지 이미지와 정보를 가져올 수 있습니다. GIPHY API: GIF와 스티커를 애플리케이션에 통합하세요. OMDb API: 영화 및 TV 프로그램 데이터베이스에 액세스하세요. VirusTotal API: 의심스러운 파일과 URL에서 멀웨어를 분석하세요. PokeAPI: 게임 관련 프로젝트를 위해 포켓몬 데이터를 검색하세요. NASA API: 이미지와 정보를 포함한 풍부한 NASA 데이터에 액세스하세요. 벡터, 이미지, 일러스트레이션을 위한 무료 사이트 🔥 Freepik: 무료 벡터, 사진, PSD, 아이콘을 찾아보세요. Vecteezy: 고품질 벡터 아트, 그래픽 및 일러스트레이션을 찾아보세요. Unsplash: 백만 개가 넘는 무료 고해상도 사진에 액세스하세요. Pixabay: 방대한 무료 이미지 및 동영상 라이브러리를 살펴보세요. Flaticon: 무료 아이콘, SVG, PSD, PNG, EPS 형식 또는 아이콘 글꼴로 다운로드하세요. SVGRepo: SVG를 무료로 다운로드하세요. SVGBackgrounds: 사용자 지정 가능한 SVG 패턴 및 배경. FreeDesignFile: 고품질 그래픽 디자인 리소스. Pexels: 재능 있는 크리에이터가 공유하는 무료 스톡 사진과 동영상을 찾아보세요. Vectorian: 로열티가 없는 벡터 아트, 스톡 사진 및 스톡 영상을 다운로드하세요. 프로젝트를 위한 무료 아이콘 🔥 FontAwesome Flaticon Iconfinder Material Icons Icons8 BoxIcons Feather Icons IcoFont SVGHUB Tabler Icons Iconsmind Iconmonstr SVGRepo 프로젝트를 위한 무료 폰트 🔥 Google Fonts 1001FreeFonts Fontjoy Fontsly FontSpace AbstractFonts FontZone DevFonts DaFont FontSquirrel FontFabric 프로젝트를 위한 무료 컬러 리소스 🔥 Coolors Paletton Colorion ColorHunt ColorHexa Adobe Color Colormind ColorPicker ColorKit MyColor ColorHub 무료 Cheat Sheet 사이트 🔥 HTML Cheat Sheet: HTML 요소 및 속성에 대한 빠른 참조 가이드입니다. CSS Cheat Sheet: CSS 속성 및 선택기에 대한 종합 가이드입니다. JavaScript Cheat Sheet: JavaScript 구문 및 개념에 대한 편리한 참조 자료입니다. Git Cheat Sheet: Git에 대한 필수 명령어 및 워크플로우. Markdown Cheat Sheet: 서식 있는 텍스트 서식을 만들기 위한 마크다운 구문 가이드입니다. React Cheat Sheet: React 개념 및 구문에 대한 간략한 개요. Learn x in y minutes: 다양한 프로그래밍 언어와 도구를 빠르게 배울 수 있는 간결한 튜토리얼입니다. SQL Cheat Sheet: 포괄적인 SQL 명령어 및 쿼리 참조. OverAPI: 다양한 프로그래밍 언어와 프레임워크에 대한 Cheat Sheet 모음입니다. HTML/CSS 템플릿을 위한 무료 사이트 🔥 HTML5UP HTMLRev Free-CSS Templated FreeHTML5 Start Bootstrap BootstrapMade Bootswatch BootstrapTaste Cruip Tooplate HTML5xCSS3 게임을 하며 CSS 배우기 🔥 CSS Diner: 재미있는 게임으로 CSS 선택자를 연습하세요. Flexbox Froggy: 이 게임을 통해 CSS Flexbox를 배워보세요. Grid Garden: 이 게임을 통해 CSS 그리드 레이아웃을 마스터하세요. Flexbox Defense: CSS 플렉스박스를 배우는 게임. CSSBattle: CSS 코드를 작성하여 다른 사람들과 경쟁하세요. Flexbox Zombies: 이 게임을 통해 CSS 플렉스박스를 배워보세요. 무료 코드 편집기 🔥 Visual Studio Code (VS Code) Sublime Text Brackets Vim 자바스크립트 애니메이션 라이브러리 🔥 Anime.js: 경량 자바스크립트 애니메이션 라이브러리. ScrollReveal.js: 뷰포트에 들어오는 요소를 쉽게 표시합니다. Popmotion: 기능적이고 유연한 자바스크립트 모션 라이브러리. AniJS: CSS 애니메이션을 위한 선언적 처리 라이브러리. Wow.js: 페이지를 아래로 스크롤할 때 CSS 애니메이션을 표시합니다. Typed.js: 타이핑하는 자바스크립트 라이브러리. Velocity.js: 가속화된 자바스크립트 애니메이션. GSAP: 최신 웹을 위한 전문가급 애니메이션. 마무리 도움이 되셨기를 바랍니다. 읽어주셔서 감사합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"무료 리소스","slug":"무료-리소스","permalink":"http://hgko1207.github.io/tags/%EB%AC%B4%EB%A3%8C-%EB%A6%AC%EC%86%8C%EC%8A%A4/"},{"name":"아이콘","slug":"아이콘","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EC%BD%98/"},{"name":"템플릿","slug":"템플릿","permalink":"http://hgko1207.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF/"},{"name":"글꼴","slug":"글꼴","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EA%BC%B4/"},{"name":"색상","slug":"색상","permalink":"http://hgko1207.github.io/tags/%EC%83%89%EC%83%81/"}]},{"title":"웹 개발자가 알아야 할 7가지 Chrome 확장 프로그램","slug":"info-11","date":"2024-04-01T05:01:52.000Z","updated":"2024-04-02T04:25:36.910Z","comments":true,"path":"2024/04/01/info-11/","link":"","permalink":"http://hgko1207.github.io/2024/04/01/info-11/","excerpt":"","text":"Chrome 확장 프로그램은 작지만 강력한 추가 기능으로 개발자의 효율성을 크게 높일 수 있습니다. Chrome 확장 프로그램을 사용하면 더 빠르고 효율적으로 작업할 수 있습니다. 이 글에서는 웹 개발에 꼭 필요한 몇 가지 Chrome 확장 프로그램을 소개합니다. CSS Viewer CSS Viewer 확장 프로그램을 사용하면 웹페이지의 모든 부분의 CSS 스타일을 확인할 수 있습니다. 클릭 한 번으로 작은 팝업 창에 해당 요소의 CSS 규칙이 표시됩니다. 사용하기 쉽지만 정말 유용합니다. What Font What Font 확장 프로그램은 웹 페이지에 사용된 글꼴을 식별하는 데 유용합니다. 텍스트 위에 마우스를 올려놓기만 하면 글꼴 이름과 스타일이 표시됩니다. 웹사이트에서 타이포그래피를 발견하는 데 정말 유용합니다. Window Resizer Window Resizer 확장 프로그램은 반응형 웹 디자인을 테스트하는 데 도움이 됩니다. 브라우저 창 크기를 특정 크기로 조정할 수 있으며 다양한 화면 크기와 기기에서 웹사이트가 어떻게 보이는지 미리 볼 수 있습니다. Perfect Pixel Perfect Pixel 확장 프로그램은 웹페이지에 반투명 사진을 오버레이할 수 있는 도구입니다. 이를 통해 웹페이지 디자인이 원본 목업 또는 PSD 파일과 완벽하게 일치하는지 확인할 수 있습니다. ColorZilla ColorZilla 확장 프로그램은 웹페이지에서 색상을 고를 때 유용합니다. 이 확장 프로그램을 사용하면 다양한 형식의 색상을 빠르게 식별하고 복사할 수 있습니다. JSON Viewer JSON Viewer 확장 프로그램은 JSON 데이터를 다루는 웹 개발자를 위한 필수 확장 프로그램입니다. JSON 응답의 형식을 지정하고 색상 코드를 지정하여 읽고 탐색하기 쉽게 해줍니다. Wappalyzer Wappalyzer 확장 프로그램은 웹사이트에서 어떤 기술을 사용하고 있는지 알려줍니다. CMS(Content Management System), 웹 서버, 프로그래밍 언어 등에 대한 정보를 제공합니다. 이를 통해 웹사이트의 기술 스택을 이해하는 데 도움이 됩니다. 결론 이러한 Chrome 확장 프로그램을 사용하면 코딩이 더 쉬워지고 작업 속도가 빨라집니다. 이러한 확장 프로그램을 사용하면 코드 디버깅을 간소화하고 웹사이트 성능을 개선할 수 있습니다. 이러한 확장 프로그램의 기능을 활용하면 효율성을 높이고 고품질의 웹사이트를 제공할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"Chrome 확장 프로그램","slug":"Chrome-확장-프로그램","permalink":"http://hgko1207.github.io/tags/Chrome-%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"Chrome","slug":"Chrome","permalink":"http://hgko1207.github.io/tags/Chrome/"}]},{"title":"초보자가 알아야 할 14가지 Git 명령어","slug":"git-3","date":"2024-03-31T12:17:52.000Z","updated":"2024-04-01T03:48:52.061Z","comments":true,"path":"2024/03/31/git-3/","link":"","permalink":"http://hgko1207.github.io/2024/03/31/git-3/","excerpt":"","text":"Git은 프로그래머의 일상적인 워크플로, 특히 팀 내에서 협업할 때 중요한 역할을 하며 소프트웨어 업계에서 없어서는 안 될 도구로 자리 잡고 있습니다. 효율적인 버전 관리와 협업을 위해서는 Git 명령어를 잘 이해하는 것이 필수적입니다. 이 글에서는 모든 개발자가 알아야 할 상위 14개의 Git 명령어를 공유하겠습니다. 1. git init git init 명령은 프로젝트 폴더에 새 리포지토리를 초기화하는 데 사용됩니다. 1git init 2. git clone git clone 명령은 기존 git 리포지토리를 로컬 머신에 복제하는 데 사용됩니다. 리포지토리를 복제하면 기존 프로젝트에서 공동 작업을 시작할 수 있습니다. 1git clone &lt;repository_url&gt; 3. git branch git branch 명령은 브랜치를 만들고, 나열하고, 삭제하는 데 사용됩니다. 1git branch &lt;new_branch_name&gt; 새 브랜치 만들기 다음 명령을 사용하여 로컬로 브랜치를 만들 수 있습니다. 1git branch &lt;new_branch_name&gt; 브랜치 나열하기 1git branch 브랜치 삭제하기 1git branch -d &lt;branch_name&gt; 4. git checkout git checkout 명령은 브랜치 간에 전환하는 데 사용됩니다. 1git checkout &lt;branch_name&gt; 브랜치 간에 전환하려면 전환하기 전에 현재 브랜치의 모든 변경 사항이 커밋되었거나 저장되어 있는지 확인하세요. 또한 체크아웃하려는 브랜치가 로컬에 이미 존재하는지 확인하세요. 다음 명령어를 사용하면 브랜치 생성 및 전환을 한 번에 원활하게 수행할 수 있습니다. 1git checkout -b &lt;branch_name&gt; 5. git add git add 명령은 특정 파일 또는 다음 커밋을 위한 모든 변경 사항을 스테이징하는 데 사용됩니다. 특정 파일의 경우: 1git add &lt;file_name&gt; 모든 변경사항의 경우: 1git add . 6. git reset git reset 명령은 파일의 변경 상태를 해제하는 데 사용됩니다. 1git reset &lt;file_name&gt; 7. git commit git commit 명령은 설명 메시지와 함께 단계적 변경 내용을 커밋하는 데 사용됩니다. 1git commit -m \"Your message\" 8. git status git status 명령은 리포지토리의 상태(예: 추적되지 않은 파일 및 커밋할 준비가 된 변경 사항)를 확인하는 데 사용됩니다. 1git status 9. git log git log 명령은 모든 커밋의 기록을 표시하는 데 사용됩니다. 여기에는 커밋 해시, 작성자, 날짜 및 커밋 메시지가 포함됩니다. 1git log 10. git diff git diff 명령은 현재 작업 디렉터리와 마지막 커밋 간의 차이점을 확인하는 데 사용됩니다. 1git diff 11. git push git push 명령은 커밋을 원격 리포지토리로 보내는 데 사용됩니다. 이 명령은 커밋된 변경 내용만 푸시한다. 1git push origin &lt;branch_name&gt; 브랜치를 새로 만든 경우 다음 명령으로 브랜치를 업로드해야 합니다. 1git push -u origin &lt;branch_name&gt; 12. git pull git pull 명령은 원격 리포지토리에서 변경 내용을 가져와 로컬 브랜치에 통합하는 데 사용됩니다. 이 명령은 기본적으로 두 개의 개별 Git 명령, 즉 git fetch와 git merge의 조합입니다. 1git pull origin 13. git stash git stash 명령은 커밋할 준비가 되지 않은 변경 내용을 일시적으로 저장하는 데 사용됩니다. 1git stash 14. git merge git merge 명령은 모든 브랜치 변경 내용을 하나의 브랜치로 합친다. 1git merge &lt;branch_name&gt; 브랜치를 병합하려면 먼저 모든 브랜치를 병합하려는 브랜치에 체크 아웃해야 합니다. 결론 이 필수 Git 명령어는 코딩 여정에서 항상 함께해야 할 동반자가 될 것입니다. 새 프로젝트를 시작하거나 팀과 협업하거나 버그를 수정할 때 이러한 명령은 버전 관리를 안내하여 개발 여정을 간소화하고 원활하게 진행할 수 있도록 도와줍니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"Git 명령어","slug":"Git-명령어","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Git 초보자","slug":"Git-초보자","permalink":"http://hgko1207.github.io/tags/Git-%EC%B4%88%EB%B3%B4%EC%9E%90/"}]},{"title":"[TypeScript] 기본 타입 정리","slug":"typescript-11","date":"2024-03-28T05:12:55.000Z","updated":"2024-03-29T03:37:08.703Z","comments":true,"path":"2024/03/28/typescript-11/","link":"","permalink":"http://hgko1207.github.io/2024/03/28/typescript-11/","excerpt":"","text":"타입스크립트의 기본 구성 요소인 원시 타입(Primitive Type)과 기본 타입(Basic Type)에 대해 살펴봅니다. 이러한 타입은 코드의 기초를 형성하여 더 복잡한 구조를 위한 토대를 제공합니다. 원시 타입과 기본 타입의 뉘앙스를 살펴보면서 타입스크립트의 타입 시스템을 탄탄하게 이해할 수 있는 토대를 마련하세요. 프로그래밍, 특히 자바스크립트나 타입스크립트와 같은 언어에서 원시 타입과 기본 타입은 단순한 값을 표현하는 데 사용되는 가장 기본적인 데이터 타입을 의미합니다. 이러한 타입은 일반적으로 언어에 내장되어 있으며 다른 타입으로 구성되지 않습니다. 원시 타입과 기본 타입에 대해 자바스크립트와 타입스크립트의 맥락에서 설명해 보겠습니다. Primitive Types (자바스크립트와 타입스크립트) 자바스크립트에는 7가지 기본 타입이 있습니다. string 문자의 시퀀스를 나타냅니다. 1let myString = 'Hello, World!'; number 정수 및 부동 소수점 숫자를 포함한 숫자 값을 나타냅니다. 1let myNumber = 42; boolean 논리값(true 또는 false)을 나타냅니다. 1let myBoolean = true; null 객체 값이 없음을 나타냅니다. 1let myNull = null; undefined 초기화되지 않았거나 정의되지 않은 값을 나타냅니다. 1let myUndefined = undefined; symbol 고유 식별자를 나타냅니다. Symbol은 이름 충돌을 피하기 위해 객체에서 키로 사용되는 경우가 많습니다. 1let mySymbol = Symbol('mySymbol'); bigint 정수를 임의의 정밀도 형식으로 나타낼 수 있는 숫자 데이터 타입을 나타냅니다. 1let myBigInt = BigInt(1234567890123456789012345); Basic Types (타입스크립트) 타입스크립트는 자바스크립트를 기반으로 구축되었으며 추가적인 정적 타이핑을 도입했습니다. 자바스크립트에서 기본 타입을 상속하고 몇 가지를 추가합니다. any 모든 타입을 나타냅니다. any 타입의 변수는 타입 검사 없이 모든 타입의 값을 저장할 수 있습니다. 1let myAny: any = 'This can be anything.'; void 값이 없음을 나타내며, 값을 반환하지 않는 함수의 반환 타입으로 자주 사용됩니다. 123function myFunction(): void &#123; console.log(\"This function doesn't return anything.\");&#125; array 타입이 지정된 배열을 나타냅니다. 배열에 포함할 수 있는 요소의 타입을 지정할 수 있습니다. 1let myArray: number[] = [1, 2, 3]; tuple 각각 고유한 타입을 가진 고정된 수의 요소를 가진 배열을 나타냅니다. 1let myTuple: [string, number] = ['John', 25]; enum 명명된 상수 값의 집합을 나타냅니다. 열거형(Enum)은 종종 관련 값의 집합을 만드는 데 사용됩니다. 1234567enum Color &#123; Red, Green, Blue,&#125;let myColor: Color = Color.Red; never 절대 발생하지 않는 값을 나타냅니다. 항상 예외를 던지거나 절대 반환하지 않는 함수의 반환 타입으로 자주 사용됩니다. 123function throwError(message: string): never &#123; throw new Error(message);&#125; 결론 이러한 원시적이고 기본적인 타입은 자바스크립트와 타입스크립트에서 데이터 작업을 위한 기초를 제공합니다. 효과적이고 타입이 안전한 프로그래밍을 위해서는 이러한 타입을 이해하는 것이 중요합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"기본 타입 정리","slug":"기본-타입-정리","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8-%ED%83%80%EC%9E%85-%EC%A0%95%EB%A6%AC/"},{"name":"Primitive Type","slug":"Primitive-Type","permalink":"http://hgko1207.github.io/tags/Primitive-Type/"},{"name":"Basic Type","slug":"Basic-Type","permalink":"http://hgko1207.github.io/tags/Basic-Type/"}]},{"title":"CentOS 9 Stream에 최신 버전의 Java 설치 방법","slug":"linux-29","date":"2024-03-26T04:16:27.000Z","updated":"2024-03-28T01:51:45.537Z","comments":true,"path":"2024/03/26/linux-29/","link":"","permalink":"http://hgko1207.github.io/2024/03/26/linux-29/","excerpt":"","text":"Java는 많은 서버 측 애플리케이션을 실행할 수 있는 인기 있는 프로그래밍 언어 및 소프트웨어 플랫폼입니다. 이 글에서는 CentOS 9 Stream에 Java의 오픈 소스 구현인 OpenJDK를 설치하는 방법을 보여드리겠습니다. 1단계: 운영 체제 확인 먼저 다음 명령을 실행하여 사용 중인 운영 체제를 확인해 보겠습니다. 1cat /etc/*release 2단계: Package Repository 업데이트하기 다음으로 최신 소프트웨어를 다운로드할 수 있도록 dnf 패키지 리포지토리를 업데이트합니다. 1sudo dnf update 3단계: 현재 Java 버전 확인 이제 다음 명령을 실행하여 설치한 Java 버전을 확인해 보겠습니다. 1java -version Java가 설치되지 않은 경우 출력에 명령을 찾을 수 없다는 메시지가 표시됩니다. 4단계: OpenJDK 설치 최신 버전의 OpenJDK를 설치하려면 다음 명령을 실행합니다. 1sudo dnf install java-latest-openjdk-devel 설치가 완료되면 다음 명령을 실행하여 최신 버전의 Java가 성공적으로 설치되었는지 확인해 보겠습니다. 1java -version 5단계: Java Home Path 설정 마지막으로 Linux에서 Java Home Path를 영구적으로 설정해 보겠습니다. 이렇게 하려면 선호하는 텍스트 편집기를 사용하여 /etc/environment 파일을 열고 파일 끝에 다음 줄을 추가합니다. 1JAVA_HOME=\"/usr/lib/jvm/java-latest-openjdk\" 파일을 저장하고 닫은 다음 다음 명령을 실행하여 변경 사항을 적용합니다. 1source /etc/environment 여기까지입니다! CentOS 9 Stream에 최신 버전의 Java를 성공적으로 설치했습니다. 이 글이 도움이 되셨기를 바랍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS 9 Stream","slug":"CentOS-9-Stream","permalink":"http://hgko1207.github.io/tags/CentOS-9-Stream/"},{"name":"Java 설치 방법","slug":"Java-설치-방법","permalink":"http://hgko1207.github.io/tags/Java-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95/"}]},{"title":"Google Gemini vs. OpenAI ChatGPT","slug":"ai-23","date":"2024-03-26T03:59:21.000Z","updated":"2024-03-27T06:27:51.375Z","comments":true,"path":"2024/03/26/ai-23/","link":"","permalink":"http://hgko1207.github.io/2024/03/26/ai-23/","excerpt":"","text":"인공 지능의 영역은 현재 텍스트 생성 분야에서 두 거대 기업의 흥미로운 대결에 몰두하고 있습니다: 구글의 Gemini와 OpenAI의 ChatGPT입니다. 두 모델 모두 놀라운 기능을 선보이지만 방법론에서 큰 차이가 있으며 다양한 애플리케이션에 고유한 가능성을 제공합니다. 2023년에 출시된 구글 Gemini는 텍스트와 시각적 콘텐츠를 모두 이해하고 생성할 수 있는 멀티모달 AI 언어 모델입니다. 반면, 2022년 11월에 공개된 OpenAI의 ChatGPT는 텍스트 생성 및 이해 영역에서 탁월한 능력을 발휘하는 텍스트 중심 AI 언어 모델입니다. SWOT 분석 강점 구글 제미니 멀티모달리티: 텍스트와 비주얼을 모두 처리하고 생성하는 Gemini의 탁월한 능력은 더욱 다양한 콘텐츠로 사용자 경험을 풍부하게 해줍니다. 뛰어난 문맥 이해력: 고급 알고리즘을 기반으로 하는 Gemini는 언어의 뉘앙스를 해석하는 능력이 뛰어나 더욱 정확하고 맥락에 맞는 응답을 제공합니다. 효율성 및 리소스 친화성: ChatGPT 4에 비해 Gemini는 훨씬 낮은 연산 요구 사항으로 작동합니다. 이러한 효율성 덕분에 실제 애플리케이션에 적합하며 광범위한 사용자의 접근성을 향상시킵니다. 투명성 및 오픈 소스 접근 방식: 투명성에 대한 Google의 노력은 Gemini의 오픈 소스 특성에서도 잘 드러납니다. Google은 기술을 공유함으로써 AI 커뮤니티 내에서 협업을 장려하고 혁신을 촉진하여 인공 지능의 집단적 발전에 기여하고 있습니다. OpenAI ChatGPT 광범위한 가용성과 확립된 사용자 기반: ChatGPT는 광범위한 사용자 기반을 자랑하며 다양한 애플리케이션에 걸쳐 그 기능을 제공합니다. 이러한 광범위한 범위는 다양한 영역에서 활용도와 영향력을 높여줍니다. 텍스트 생성 분야에서 입증된 실적: 텍스트 생성 분야의 선두주자로서의 실적을 보유한 ChatGPT는 고품질의 인간과 같은 글을 생성하는 능력을 꾸준히 입증해 왔습니다. 이러한 능력은 창의적이고 유익한 다양한 형식으로 확장되어 콘텐츠 생성을 위한 신뢰할 수 있는 도구로 자리매김하고 있습니다. 유연성 및 적응성: ChatGPT의 강력한 텍스트 생성 기능은 매우 다재다능하여 다양한 작업과 사용자 요구사항에 원활하게 적응할 수 있습니다. 이러한 유연성은 다양한 산업과 사용 사례에 걸쳐 적용 가능성을 높여줍니다. 지속적인 개발 및 개선: 지속적인 연구 개발에 대한 OpenAI의 노력은 ChatGPT의 성능과 기능의 지속적인 향상에 반영되어 있습니다. 이러한 노력 덕분에 이 모델은 최적의 결과를 위해 최신 혁신 기술을 통합하여 텍스트 생성 분야의 발전을 선도하고 있습니다. 약점 구글 제미니 아직 개발 중: ChatGPT 4에 비해 Gemini는 개발 초기 단계로, 보다 성숙한 모델에서 얻을 수 있는 광범위한 실제 데이터와 경험이 부족합니다. 성능을 최적화하려면 더 많은 개선이 필요합니다. 멀티모달 애플리케이션에 집중: Gemini의 멀티모달 기능은 강력하지만, 텍스트와 비주얼을 모두 처리하는 데 중점을 두기 때문에 텍스트 생성을 주로 필요로 하는 사용자에게는 적합하지 않을 수 있으며 특정 애플리케이션에서는 효율성이 떨어질 수 있습니다. 오용 가능성: Gemini의 강력한 기능으로 인해 잘못된 정보 생성이나 사용자 조작과 같은 오용 가능성에 대한 우려가 제기되고 있습니다. 의도하지 않은 사용으로부터 보호하는 것은 윤리적, 사회적 문제를 예방하는 데 매우 중요합니다. OpenAI ChatGPT 제한된 멀티모달 기능: 텍스트 생성에 중점을 둔 ChatGPT는 텍스트와 비주얼을 모두 처리하는 Gemini의 다재다능함에 비해 그 적용 범위가 제한적일 수 있습니다. 이는 보다 다양한 출력물을 원하는 사용자에게는 단점이 될 수 있습니다. 투명성 문제: OpenAI의 비공개 소스 접근 방식은 사용자가 모델의 편향성과 오용 가능성에 대해 불확실할 수 있기 때문에 투명성 문제를 제기합니다. 이러한 우려를 해결하는 것은 신뢰와 공신력을 구축하는 데 매우 중요합니다. 높은 리소스 수요: Gemini에 비해 ChatGPT는 더 많은 컴퓨팅 리소스를 필요로 합니다. 이는 연산 능력이 제한된 사용자에게는 제한이 될 수 있으며, 특정 개인과 애플리케이션에 대한 모델의 접근성과 사용성을 저해할 수 있습니다. 사용 사례 구글 제미니 텍스트와 이미지 결과를 완벽하게 통합하는 검색 엔진: Gemini는 텍스트와 시각적 결과를 완벽하게 통합하는 검색 엔진 기능을 제공하여 전반적인 검색 경험을 향상시키는 데 탁월합니다. 멀티모달 인터랙션 기능을 갖춘 AI 어시스턴트: Gemini의 멀티모달 기능은 텍스트와 시각적 콘텐츠를 통해 사용자와 상호 작용할 수 있어 더욱 몰입감 있고 매력적인 경험을 제공하는 AI 어시스턴트에 적합합니다. 대화형 학습 자료를 갖춘 교육 및 훈련 프로그램: 텍스트와 비주얼을 모두 처리할 수 있는 Gemini는 다양한 학습 스타일에 맞는 대화형 학습 자료를 제공하여 교육 프로그램에 유용합니다. 시각 및 텍스트 생성을 결합한 디자인 및 크리에이티브 산업을 위한 도구: 디자인 및 크리에이티브 산업에서 Gemini의 기능을 활용하여 시각과 텍스트 생성을 결합한 혁신적인 도구를 만들어 창의성과 효율성을 높일 수 있습니다. OpenAI ChatGPT 콘텐츠 작성 및 글쓰기 지원 도구: ChatGPT는 콘텐츠 제작을 위한 강력한 도구로, 글쓰기 지원을 제공하고 다양한 목적에 맞는 고품질의 문맥 관련 텍스트를 생성합니다. 고객 서비스 및 상호작용을 위한 챗봇 및 가상 비서: ChatGPT는 텍스트 생성에 강점을 가지고 있어 고객 서비스 문의와 사용자 상호작용을 효과적으로 처리할 수 있는 챗봇과 가상 비서를 개발하는 데 유용한 리소스입니다. 개인화된 메시징을 통한 마케팅 및 광고 캠페인: 마케팅 담당자는 ChatGPT의 텍스트 중심 기능을 활용하여 개인화된 메시징으로 캠페인을 개발하여 특정 대상에 맞게 콘텐츠를 맞춤화하여 더욱 효과적인 커뮤니케이션을 진행할 수 있습니다. 고객 서비스 및 지원을 위한 자동화된 상호작용: ChatGPT는 고객 서비스 및 지원의 상호작용을 자동화하여 일상적인 문의를 처리하고 텍스트 기반 형식으로 지원을 제공하는 데 활용할 수 있습니다. 결론 Google Gemini와 OpenAI ChatGPT는 모두 진화하는 AI 언어 모델 환경에서 고유한 강점과 애플리케이션을 제공합니다. Gemini와 ChatGPT 중 어떤 것을 선택할지는 궁극적으로 사용자와 비즈니스의 구체적인 요구와 우선순위에 따라 달라지며, 각 모델은 텍스트 및 시각적 생성의 다양한 측면을 충족합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Gemini","slug":"Gemini","permalink":"http://hgko1207.github.io/tags/Gemini/"},{"name":"Google Gemini","slug":"Google-Gemini","permalink":"http://hgko1207.github.io/tags/Google-Gemini/"},{"name":"OpenAI ChatGPT","slug":"OpenAI-ChatGPT","permalink":"http://hgko1207.github.io/tags/OpenAI-ChatGPT/"}]},{"title":"프로젝트 관리 기술 향상을 위한 ChatGPT 프롬프트","slug":"chatgpt-23","date":"2024-03-25T04:19:46.000Z","updated":"2024-03-25T04:31:08.077Z","comments":true,"path":"2024/03/25/chatgpt-23/","link":"","permalink":"http://hgko1207.github.io/2024/03/25/chatgpt-23/","excerpt":"","text":"오늘날 빠르게 변화하는 세상에서 효과적인 프로젝트 관리는 성공을 위해 매우 중요합니다. 이것이 바로 ChatGPT 프롬프트가 등장하는 곳입니다. 이 블로그 게시물에서는 ChatGPT 프롬프트가 어떻게 프로젝트 관리 프로세스를 간소화하고 자세한 가이드와 귀중한 통찰력을 제공하는지 살펴보겠습니다. ChatGPT 프롬프트가 프로젝트 관리에 어떤 이점이 있나요? 효율적인 작업 계획 프로젝트 계획과 관련된 프롬프트를 ChatGPT에 제공하여 작업 목록, 타임라인, 일정을 생성하세요. 프로젝트 작업을 효과적으로 정리하여 적시에 완료할 수 있도록 도와줍니다. 위험 평가 및 완화 프롬프트를 사용하여 잠재적 위험을 식별하고 완화 전략을 개발하세요. ChatGPT는 프로젝트 데이터를 분석하고 가능한 문제에 대한 인사이트를 제공하여 선제적인 조치를 취할 수 있도록 도와줍니다. 팀 커뮤니케이션 이메일, 메모 또는 업데이트 초안 작성을 위한 프롬프트를 만들어 팀원들과 소통하세요. ChatGPT는 명확하고 간결한 메시지를 작성하는 데 도움을 주어 팀 내 효과적인 커뮤니케이션을 촉진할 수 있습니다. 리소스 할당 프롬프트를 활용하여 프로젝트 요구사항에 따라 리소스 할당을 최적화하세요. ChatGPT는 데이터를 분석하고 최적의 리소스 활용을 보장하기 위한 할당 전략을 제안할 수 있습니다. 의사 결정 복잡한 의사 결정에 직면했을 때 ChatGPT 프롬프트에서 지침을 구하세요. 관련 정보를 제공함으로써 ChatGPT는 장단점을 비교하고 정보에 입각한 결정을 내리는 데 도움을 줄 수 있습니다. 문서화 및 보고 특정 요구 사항에 맞는 프롬프트를 사용하여 프로젝트 문서, 보고서 및 프레젠테이션을 생성하세요. ChatGPT는 프로젝트 진행 상황을 요약하고, 주요 성과를 강조하고, 계획을 요약하는 데 도움을 줄 수 있습니다. 문제 해결 프롬프트를 통해 프로젝트 관련 문제를 ChatGPT에 제시하고 잠재적인 해결책을 모색하세요. 데이터를 분석하고 문제 해결을 위한 혁신적인 접근 방식을 제공하는 AI의 능력을 활용하세요. 품질 보증 프롬프트를 사용하여 체크리스트와 품질 보증 프로토콜을 생성하여 품질 표준을 충족할 수 있습니다. ChatGPT는 개선이 필요한 영역을 파악하고 고품질 결과물을 유지하기 위한 조치를 제안할 수 있습니다. 이해관계자 참여 이해관계자 커뮤니케이션 및 업데이트를 위한 프롬프트를 만들어 이해관계자와 효과적으로 소통하세요. ChatGPT는 이해관계자의 우려와 기대에 부응하는 맞춤형 메시지를 작성하는 데 도움을 줄 수 있습니다. 지속적인 개선 ChatGPT 프롬프트를 활용하여 팀원 및 이해관계자의 피드백을 요청함으로써 지속적인 개선 문화를 조성하세요. 얻은 인사이트를 사용하여 프로세스를 개선하고 프로젝트 결과를 향상시키세요. 프로젝트 관리를 위한 10가지 ChatGPT 프롬프트 주어진 마일스톤에 따라 상세한 프로젝트 타임라인을 생성하세요. 프로젝트와 관련된 잠재적 위험을 파악하고 완화 전략을 제안하세요. 프로젝트 상태와 예정된 작업을 간략하게 설명하는 팀 업데이트 이메일을 작성하세요. 프로젝트 예산과 일정을 고려하여 리소스 할당 최적화합니다. 프로젝트 관리 소프트웨어 선택에 관한 의사 결정 과정에 도움을 줍니다. 프로젝트 데이터 분석의 주요 결과를 요약합니다. 프로젝트 품질을 저하시키지 않으면서 예산 제약을 극복할 수 있는 솔루션을 제안하세요. 프로젝트 구현 단계에서 품질 보증을 위한 체크리스트를 작성하세요. 다가오는 프로젝트 검토 회의를 위한 이해관계자 커뮤니케이션 계획 초안을 작성하세요. 프로젝트 협업과 효율성을 개선할 수 있는 방법에 대해 팀원들의 피드백을 구하세요. 결론 ChatGPT 프롬프트는 프로젝트 관리 기술을 향상시킬 수 있는 유용한 도구입니다. 인공 지능의 힘을 활용하여 프로젝트 계획, 실행, 커뮤니케이션의 다양한 측면을 간소화할 수 있습니다. 프로젝트 관리 툴킷에 ChatGPT 프롬프트를 통합하여 프로젝트의 효율성, 협업, 성공을 촉진하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"프로젝트 관리","slug":"프로젝트-관리","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC/"}]},{"title":"TypeScript vs JavaScript","slug":"typescript-10","date":"2024-03-19T14:44:27.000Z","updated":"2024-03-22T06:43:31.511Z","comments":true,"path":"2024/03/19/typescript-10/","link":"","permalink":"http://hgko1207.github.io/2024/03/19/typescript-10/","excerpt":"","text":"이 글에서는 JavaScript와 TypeScript를 비교하여 TypeScript로 전환할 때 정보에 입각한 선택을 할 수 있도록 도와드립니다. ES6/7의 친숙한 구문과 TypeScript가 제공하는 추가 기능을 통해 TypeScript로 개발 환경을 개선하는 방법을 살펴봅니다. ES6, ES7(각각 ECMAScript 2015 및 ECMAScript 2016이라고도 함), JavaScript 및 TypeScript는 서로 연관되어 있지만 서로 다른 용도로 사용되며 뚜렷한 특징이 있습니다. 이러한 용어를 세분화하여 비교해 보겠습니다. JavaScript JavaScript는 주로 프런트엔드 웹 개발에 사용되는 동적이고 높은 수준의 해석된 프로그래밍 언어입니다. 모든 최신 웹 브라우저에서 지원됩니다. 기능 JavaScript는 전통적으로 ECMAScript 5(ES5)까지의 기능을 갖추고 있었습니다. 주요 기능으로는 함수, 객체, 클로저, 프로토타입 기반 상속 등이 있습니다. ECMAScript 6(ES6) / ECMAScript 2015 2015년에 출시된 ES6는 새로운 구문 기능과 기존 기능의 개선을 포함하여 JavaScript를 크게 향상시켰습니다. 기능 Arrow function, Class, Template Literal, 변수 선언을 위한 let 및 const, 구조 분해 할당 등이 추가되었습니다. 비동기 연산 처리를 위한 Promise. 더 나은 코드 정리를 위한 모듈. 보다 고전적인 객체 지향 프로그래밍을 위한 class 키워드. ECMAScript 7(ES7) / ECMAScript 2016 2016년에 출시된 ES7은 ES6에 비해 새로운 기능은 적지만 몇 가지 주목할 만한 추가 기능이 포함되어 있습니다. 기능 배열에 특정 요소가 포함되어 있는지 보다 편리하게 확인할 수 있는 Array.prototype.includes(). 간결한 지수를 위한 지수 연산자(**). 타입스크립트 TypeScript는 Microsoft에서 개발한 JavaScript의 상위 집합입니다. 정적 타이핑 및 기타 기능을 JavaScript에 추가하여 확장성과 유지 관리가 용이합니다. 기능 정적 타입 지정: TypeScript는 정적 타입 지정을 도입하여 개발자가 변수, 함수 매개변수 및 반환 유형에 대한 타입을 정의할 수 있도록 합니다. 인터페이스 및 클래스: TypeScript는 인터페이스와 클래스를 지원하여 객체 형상을 정의하고 객체 지향 패턴을 구현하는 보다 구조화된 방법을 제공합니다. 컴파일: TypeScript 코드는 JavaScript로 트랜스파일되어 개발자가 특정 ECMAScript 버전을 대상으로 하면서도 최신 ECMAScript 기능을 사용할 수 있습니다. 도구 지원: TypeScript는 최신 통합 개발 환경(IDE)에서 자동 완성, 리팩터링, 코드 탐색 등 더 나은 도구 지원을 제공합니다. 비교 Type Safety JavaScript는 동적으로 입력되는 반면 TypeScript는 정적으로 입력됩니다. 즉, TypeScript는 런타임이 아닌 개발 중에 타입 관련 오류를 포착합니다. 개발 경험 TypeScript는 정적 분석, 지능형 코드 완성, 더 나은 도구 통합과 같은 기능을 통해 더 풍부한 개발 환경을 제공합니다. 호환성 TypeScript 코드는 실행 전에 JavaScript로 변환되어야 하므로 다양한 브라우저 및 런타임 환경과의 호환성을 보장합니다. 커뮤니티 및 채택 JavaScript는 모든 주요 웹 브라우저에서 널리 사용되고 지원됩니다. TypeScript는 특히 대규모 코드베이스와 엔터프라이즈 수준 프로젝트에서 인기를 얻고 있습니다. 결론 요약하자면, JavaScript는 웹 개발의 기본 언어이며, ECMAScript 버전(ES6, ES7 등)은 개선 사항과 새로운 기능을 제공합니다. TypeScript는 JavaScript의 상위 언어로서 정적 타이핑 및 기타 향상된 기능을 추가하여 대규모 프로젝트에서 작업하는 개발자에게 추가적인 안전성과 도구를 제공합니다. 프로젝트 요구 사항, 팀 선호도, 개발 규모에 따라 JavaScript와 TypeScript 중 어떤 것을 선택할지 결정해야 합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"}]},{"title":"직장에서 슈퍼스타로 만들어 줄 10가지 ChatGPT 프롬프트","slug":"chatgpt-22","date":"2024-03-14T04:35:28.000Z","updated":"2024-03-14T04:44:54.824Z","comments":true,"path":"2024/03/14/chatgpt-22/","link":"","permalink":"http://hgko1207.github.io/2024/03/14/chatgpt-22/","excerpt":"","text":"업무에 ChatGPT를 사용하지 않는다면 동료들에게 많은 면에서 뒤처지고 있다고 확신합니다. ChatGPT 및 기타 AI 도구를 사용하면 생산성을 높이고, 시간을 효율적으로 관리하며, 비용을 절감하고, 직장 내 커뮤니케이션(이메일)을 효과적으로 수행하여 스타가 될 수 있는 잠재력을 가지고 있습니다. 직장 내 커뮤니케이션 전문가가 되기 위한 10가지 미친 ChatGPT 프롬프트를 사용해보세요. 1. 보상 검토 요청 “보상 검토를 위해 [HR/관리자]에게 공식적이고 사실적인 스타일의 200자 내외의 이메일을 작성하여 역할[직위], 성과[주요 업적], 시장과의 연계성을 언급하세요.” 2. 직장 내 갈등 해결 “[관련된 개인/팀]과 관련된 직장 내 갈등, 그 영향, 해결 단계 요청에 대해 [인사팀 또는 관련 기관]에 외교적이고 해결 중심적인 스타일로 200자 내외의 이메일을 작성하세요.” 3. 유연한 근무 일정 “[구체적인 유연 근무 일정]과 같은 유연한 근무 일정을 제안하는 200자 내외의 이메일을 설득력 있고 합리적인 스타일로 작성하여 생산성 이점을 인용해 관리자에게 보내세요.” 4. 성과 피드백 “프로젝트 [프로젝트 이름]에 대한 피드백을 위해 관리자에게 개방적이고 수용적인 스타일로 200자 내외의 이메일을 작성하여 개선에 대한 열의를 표현하고 피드백 회의를 요청하세요.” 5. 프로젝트 지원 요청 “[동료/팀]에게 [프로젝트 이름]에 대한 지원을 요청하는 200자 내외의 이메일을 협업적이고 구체적인 스타일로 작성하여 프로젝트의 중요성과 도움이 필요한 부분을 간략하게 설명하세요.” 6. 경력 발전 “[인사/관리자]에게 경력 발전에 대한 열망을 표현하는 200자 내외의 이메일을 야심차고 정중한 스타일로 작성하세요. [기여한 사항]과 [희망 직위 또는 진로]에 대한 관심을 언급하세요.” 7. 전문적인 목표 설명하기 “목표 지향적이고 명확한 스타일의 200자 내외의 이메일을 작성하여 [멘토/관리자]에게 한 해의 직업적 목표를 간략하게 설명하세요. [구체적인 목표]와 같은 목표와 이를 달성하기 위한 방법을 자세히 설명하세요.” 8. 마감일 협상 “[프로젝트 이름]의 마감일 협상에 대해 [프로젝트 관리자]에게 합리적이고 전문적인 스타일로 200자 내외의 이메일을 작성하세요. 현재 진행 상황을 논의하고 품질을 보장하는 새로운 일정을 제안하세요.” 9. 새로운 아이디어 소개 “[팀 또는 관리자]에게 [프로젝트 또는 프로세스 개선]에 대한 새로운 아이디어를 소개하는 200자 내외의 이메일을 혁신적이고 매력적인 스타일로 작성하세요. 이점을 간략히 설명하고 추가 논의를 위한 미팅을 제안하세요.” 10. 지식 공유 세션 “[주제]에 대한 정기적인 지식 공유 세션을 제안하는 교육 및 협업 스타일로 200자 내외의 이메일을 [관리자]에게 보내주세요. [세션 형식]과 같은 형식과 팀 성장을 위한 혜택을 제안하세요.” 결론 효과적인 직장 내 커뮤니케이션을 위한 10가지 미친 ChatGPT 프롬프트가 유용하고 유익한 정보가 되었기를 바랍니다. 수백 시간을 절약하고 생산성을 높이며 직장에서 효과적인 의사소통자이자 작가가 될 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"직장","slug":"직장","permalink":"http://hgko1207.github.io/tags/%EC%A7%81%EC%9E%A5/"},{"name":"슈퍼스타","slug":"슈퍼스타","permalink":"http://hgko1207.github.io/tags/%EC%8A%88%ED%8D%BC%EC%8A%A4%ED%83%80/"}]},{"title":"최첨단 디스플레이 기술: MWC 2024의 최고의 혁신","slug":"info-10","date":"2024-03-13T04:59:21.000Z","updated":"2024-03-21T04:54:31.285Z","comments":true,"path":"2024/03/13/info-10/","link":"","permalink":"http://hgko1207.github.io/2024/03/13/info-10/","excerpt":"","text":"2월 26일부터 3월 1일까지 스페인 바르셀로나에서 개최된 MWC(Mobile World Congress) 2024는 모바일 기술 및 그 이상의 최신 발전을 선보이는 글로벌 플랫폼으로서의 입지를 다시 한 번 공고히 했습니다. 업계 대기업부터 신생 스타트업까지 다양한 참가자들이 우리가 주변 세계와 연결하고, 일하고, 상호 작용하는 방식에 혁신을 가져올 획기적인 혁신 기술을 선보였습니다. MWC 2024에서 주목을 받은 가장 매력적인 제품 5개는 다음과 같습니다. 1. HoloLens 3: Microsoft의 차세대 증강 현실 헤드셋 Microsoft는 혼합 현실 헤드셋의 최신 버전인 홀로렌즈(HoloLens) 3를 공개하며 많은 기대를 모았습니다. 더 넓은 시야각, 향상된 해상도, 향상된 손 추적 기능을 갖춘 HoloLens 3는 더욱 몰입감 있고 자연스러운 증강 현실 경험을 약속합니다. 이 기술은 원격 협업과 교육부터 디자인 및 엔지니어링에 이르기까지 다양한 산업을 혁신할 수 있는 잠재력을 가지고 있습니다. 2. FlexPai 4: 내구성을 강화한 TCL의 폴더블폰 중국 전자제품 제조업체인 TCL은 최신 폴더블폰인 FlexPai 4를 선보였습니다. 이 제품은 내구성이 강화된 힌지와 경미한 스크래치를 수리하는 독특한 ‘자가 치유’ 디스플레이 코팅으로 이전 폴더블 디바이스의 주요 문제점을 해결했습니다. FlexPai 4는 성장하는 폴더블 스마트폰 시장에서 강력한 경쟁자로 자리매김하고 있습니다. 3. Project Starlink Gen 2: SpaceX의 차세대 위성 인터넷 별자리 엘론 머스크의 SpaceX는 더 넓은 커버리지, 더 빠른 속도, 더 낮은 지연 시간을 약속하는 2세대 스타링크 위성 인터넷 별자리를 공개했습니다. 프로젝트 스타링크 2세대는 전 세계의 소외된 지역에 저렴하고 안정적인 인터넷 액세스를 제공하여 디지털 격차를 해소하는 것을 목표로 합니다. 4. EcoCharge: 소니의 지속 가능한 무선 충전 솔루션 소니는 재활용 해양 플라스틱과 바이오 기반 소재를 활용한 혁신적인 무선 충전 솔루션인 ‘EcoCharge’ 기술을 소개했습니다. 이러한 친환경적인 접근 방식은 기술 업계에서 지속 가능한 관행에 대한 수요가 증가하는 추세에 부합합니다. 5. 삼성의 ‘AI 기반 정신 건강 도우미’ 삼성은 사용자가 스트레스와 불안을 관리하고 전반적인 정신 건강을 개선할 수 있도록 설계된 새로운 AI 기반 정신 건강 도우미를 공개했습니다. 이 기술은 개인화된 추천, 마음챙김 운동, 수면 추적 기능을 통해 점점 더 까다로워지는 세상에서 개인이 자신의 정신 건강을 우선시할 수 있도록 지원하는 것을 목표로 합니다. 마무리 MWC 2024는 끊임없이 진화하는 모바일 기술 환경을 보여주었습니다. 이 다섯 가지 혁신은 증강 현실, 폴더블 디바이스, 글로벌 인터넷 연결, 지속 가능한 관행, 정신 건강 지원과 같은 분야의 발전을 위한 끊임없는 노력을 강조합니다. 업계가 계속해서 혁신을 거듭함에 따라 우리가 기술과 연결하고 상호 작용하는 방식의 미래를 형성할 더욱 흥미로운 발전을 기대할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"Google","slug":"Google","permalink":"http://hgko1207.github.io/tags/Google/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"MWC 2024","slug":"MWC-2024","permalink":"http://hgko1207.github.io/tags/MWC-2024/"},{"name":"EcoCharge","slug":"EcoCharge","permalink":"http://hgko1207.github.io/tags/EcoCharge/"},{"name":"HoloLens","slug":"HoloLens","permalink":"http://hgko1207.github.io/tags/HoloLens/"},{"name":"FlexPai","slug":"FlexPai","permalink":"http://hgko1207.github.io/tags/FlexPai/"}]},{"title":"수백 시간을 절약할 수 있는 ChatGPT 프롬프트 상위 8가지","slug":"chatgpt-21","date":"2024-03-12T04:58:23.000Z","updated":"2024-03-19T13:42:29.148Z","comments":true,"path":"2024/03/12/chatgpt-21/","link":"","permalink":"http://hgko1207.github.io/2024/03/12/chatgpt-21/","excerpt":"","text":"ChatGPT는 일상적인 업무에서 벗어나 생산성을 높여주는 수호천사와 같은 존재입니다. ChatGPT를 사용하지 않는다면 여러 가지 면에서 뒤처지고 있다고 확신합니다. 이 8가지 놀라운 ChatGPT 프롬프트를 사용하여 수백 시간을 절약하고, 생산성을 높이고, 몇 시간씩 걸리는 작업을 몇 분 안에 끝내세요. 1. 프로젝트 관리 “여러 팀이 참여하는 [새 프로젝트]를 시작하려고 합니다. 효과적인 커뮤니케이션과 실행을 위해 명확한 목표, 마일스톤, 작업 할당, 추적 일정이 포함된 프로젝트 계획 템플릿을 만들 수 있나요?” 2. 맞춤형 재정 조언 &quot;재무 건전성과 금융 이해력을 향상시키고 싶습니다. 현재 [재정 상황]과 [장기 목표]를 고려하여 [부채]를 관리하고, 저축을 늘리고, [현명한 투자]를 할 수 있는 실행 계획을 알려주실 수 있나요?&quot; 3. 개인 개발 &quot;개인 개발 코치 역할을 해 주셨으면 합니다. 개인이 자신의 강점과 약점을 파악하고 어려움을 극복하고 목표를 달성하기 위한 전략을 개발하도록 도와주세요. 당신의 임무는 시간을 구조화하고, 달성 가능한 목표를 설정하고, 스트레스를 관리하고, 효과적인 습관을 개발하고, 의미 있는 관계를 구축하는 방법을 안내하는 것입니다. 내가 원하는 것과 필요한 것을 더 잘 이해하려면 항상 상황과 나의 필요를 더 잘 이해하는 데 도움이 되는 질문을 포함하여 답변해야 합니다. 이해하셨나요?&quot; 4. 비즈니스 창출 &quot;[업종]에서 비즈니스를 시작하고 싶습니다. 시장 조사, 사업 계획, 자금 조달, 초기 마케팅 전략 등 회사를 성공적으로 시작하기 위한 주요 단계를 안내해 주시겠어요?&quot; 5. 면접 준비하기 “저는 [회사]에서 [직책]에 대한 면접을 준비하고 있습니다. 이 분야에서 자주 묻는 질문 목록과 제 기술과 경험을 강조하고 면접에서 합격할 수 있는 팁을 알려주시겠어요?” 6. 웹사이트 최적화 &quot;[웹사이트]를 관리하고 있으며 성능과 SEO를 개선하고자 합니다. 사이트에 대한 빠른 감사를 수행하여 속도, 보안 및 SEO를 개선하기 위한 우선 순위 조치 목록을 제공해 주시겠습니까?&quot; 프롬프트 7: ChatGPT를 진로 상담사로 만드세요 7. 진로 상담사로 활용하기 &quot;당신은 경력 상담 전문가로서 개인이 자신의 기술, 관심사 및 경험을 바탕으로 최상의 진로를 찾을 수 있도록 돕는 일을 전문으로 하고 있습니다. 당신은 저보다 앞서 많은 사람들이 다양한 업계의 취업 시장 동향을 조사하고 이해하며 특정 분야를 추구하는 데 어떤 자격증이 도움이 될지 판단하는 데 도움을 주었습니다. 이제 당신의 임무는 저에게 가장 적합한 커리어 경로를 처음부터 파악하는 방법을 가르쳐 주시는 것입니다. 제가 무엇을 원하고 필요로 하는지 더 잘 이해하려면 항상 상황과 저의 필요를 더 잘 이해하는 데 도움이 되는 질문을 포함하여 답변해야 합니다.&quot; 8. 세무 컨설턴트로 활용하기 &quot;당신은 세무 전문가입니다. 이전에도 많은 기업과 개인이 세금 부채를 줄이고 세금을 절약할 수 있도록 도와주셨죠. 이제 당신의 임무는 처음부터 절세 전략에 대해 조언하는 것입니다. 제가 원하는 것과 필요한 것을 더 잘 이해하려면 항상 상황과 저의 요구를 더 잘 이해하는 데 도움이 되는 질문을 포함해서 대답해야 합니다. 이해하셨나요?&quot; 결론 8가지 ChatGPT 프롬프트가 유용하고 유익했기를 바랍니다. 수백 시간을 절약하고 생산성을 높이며 몇 시간씩 걸리는 작업을 단 몇 분 만에 끝낼 수 있도록 도와줄 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"시간 절약","slug":"시간-절약","permalink":"http://hgko1207.github.io/tags/%EC%8B%9C%EA%B0%84-%EC%A0%88%EC%95%BD/"},{"name":"생산성 향상","slug":"생산성-향상","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1-%ED%96%A5%EC%83%81/"}]},{"title":"자바스크립트에서 객체를 만드는 5가지 방법","slug":"js-dev-19","date":"2024-03-12T04:41:46.000Z","updated":"2024-03-20T04:42:44.989Z","comments":true,"path":"2024/03/12/js-dev-19/","link":"","permalink":"http://hgko1207.github.io/2024/03/12/js-dev-19/","excerpt":"","text":"자바스크립트에서 객체는 다양한 방식으로 생성할 수 있는 다용도 도구로, 각기 다른 시나리오에 적합합니다. 각 방법을 언제 사용해야 하는지 이해하는 것이 효율적이고 유지 관리가 쉬운 자바스크립트 코드를 작성하는 데 중요합니다. 자바스크립트에서 객체를 만드는 5가지 일반적인 방법을 살펴보고 각 방법에 가장 적합한 사용 사례를 자세히 설명해 보겠습니다. 1. 객체 리터럴(Object Literal) 객체 리터럴은 중괄호 {}를 사용하여 자바스크립트에서 객체를 생성하는 가장 간단하고 빠른 방법입니다. 이 방법은 청사진이나 반복적인 인스턴스화가 필요 없는 단일 독립형 객체를 생성하는 데 이상적입니다. 1234567const car = &#123; make: 'Toyota', model: 'Corolla', year: 2021,&#125;;console.log(car); 메서드나 프로토타입이 필요하지 않은 빠르고 간단한 객체에는 객체 리터럴을 사용하세요. 구성 옵션, 데이터 저장, 관련 프로퍼티와 메서드를 간단한 구조로 캡슐화하는 데 적합합니다. 2. new Object() 구문 new Object() 구문으로 객체를 생성하는 것은 자바스크립트 프로그래밍에서 객체를 보다 명시적으로 생성하는 방법입니다. 이는 객체 리터럴과 유사하지만 다른 프로그래밍 언어에서 온 사람들이 더 쉽게 읽을 수 있습니다. 123456const person = new Object();person.name = 'John';person.age = 30;person.isEmployed = true;console.log(person); 이 방법은 객체 생성을 명시적으로 보여 주고 싶거나 클래스 기반 또는 생성자 기반 객체 생성을 많이 사용하는 언어에서 전환할 때 유용합니다. 조건에 따라 속성을 동적으로 추가할 때도 유용합니다. 3. 생성자 함수 생성자 함수는 유사한 객체의 인스턴스를 여러 개 생성하는 데 사용됩니다. 생성자 함수는 자바스크립트에서 동일한 유형의 객체를 생성하기 위한 청사진 역할을 합니다. 12345678function Smartphone(brand, model, year) &#123; this.brand = brand; this.model = model; this.year = year;&#125;const myPhone = new Smartphone('Apple', 'iPhone 13', 2021);console.log(myPhone); 생성자 함수는 비슷한 속성과 메서드를 가진 여러 개의 객체가 필요할 때 이상적입니다. 사용자, 제품 또는 공통 구조를 공유하지만 다른 값을 가진 기타 엔티티와 같은 객체를 생성하는 데 유용합니다 4. Object.create() 방법 자바스크립트의 Object.create()는 지정된 프로토타입과 속성을 가진 새 객체를 만듭니다. 이 메서드는 다른 메서드보다 객체 상속을 더 많이 제어할 수 있습니다. 12345678910const animal = &#123; type: 'Animal', displayType: function () &#123; console.log(this.type); &#125;,&#125;;const dog = Object.create(animal);dog.type = 'Dog';dog.displayType(); // Output: Dog 이 메서드는 부모의 생성자를 호출하지 않고 다른 객체에서 직접 상속하는 객체를 생성해야 할 때 유용합니다. 복잡한 상속 구조를 위한 강력한 도구이며 다른 고급 패턴 중에서도 동작 위임에 사용할 수 있습니다. 5. ES6 클래스 구문 ES6 클래스는 자바스크립트에서 객체를 생성하는 보다 전통적인 클래스 기반 방식을 제공합니다. 이는 자바스크립트의 프로토타입 기반 상속보다 구문론적으로 더 뛰어나지만 클래스 기반 언어에서 온 사람들에게 더 명확하고 친숙한 구문을 제공합니다. 1234567891011121314class Book &#123; constructor(title, author, year) &#123; this.title = title; this.author = author; this.year = year; &#125; getSummary() &#123; return `$&#123;this.title&#125; was written by $&#123;this.author&#125; in $&#123;this.year&#125;`; &#125;&#125;const myBook = new Book('1984', 'George Orwell', 1949);console.log(myBook.getSummary()); 코드의 구성, 가독성 및 상속 구조가 중요한 보다 복잡한 애플리케이션에는 ES6 클래스를 사용하세요. 대규모 애플리케이션이나 명확하고 표준화된 코딩 관행이 필요한 팀에서 작업할 때 유용합니다. 어떤 방법이 가장 좋고 빠르나요? 객체를 만드는 가장 빠르고 좋은 방법은 애플리케이션의 특정 요구 사항과 상황에 따라 크게 달라지므로 정답은 없습니다. 그러나 단순성과 속도 측면에서 객체 리터럴은 특히 단순한 일회용 객체의 경우 객체를 만드는 가장 빠르고 쉬운 방법입니다. 보다 복잡하고 구조화된 애플리케이션의 경우 ES6 클래스는 생성자 함수에 비해 약간의 오버헤드가 있을 수 있지만 가독성, 기존 구문 및 성능의 균형을 제공합니다. 결론 자바스크립트에서 객체를 생성하는 데 적합한 방법을 선택하는 것은 애플리케이션의 컨텍스트와 특정 요구 사항에 따라 달라집니다. 단순한 일회성 객체이든 상속이 필요한 복잡한 구조이든, 이 다섯 가지 방법을 이해하면 보다 효과적이고 유지 관리가 쉬운 자바스크립트 코드를 작성할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"객체","slug":"객체","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"객체 생성","slug":"객체-생성","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/"}]},{"title":"TypeScript 컴파일러(tsc) 및 tsconfig","slug":"typescript-9","date":"2024-03-11T05:26:16.000Z","updated":"2024-03-11T05:44:29.733Z","comments":true,"path":"2024/03/11/typescript-9/","link":"","permalink":"http://hgko1207.github.io/2024/03/11/typescript-9/","excerpt":"","text":"TypeScript 컴파일러(tsc)와 구성 파일(tsconfig.json)에 대해 살펴봅니다. 컴파일러 옵션과 구성을 이해하는 것은 TypeScript 워크플로를 최적화하는 데 필수적입니다. 다양한 컴파일러 옵션과 tsconfig.json의 중요성, 그리고 이러한 도구를 활용하여 TypeScript 개발 프로세스를 간소화하는 방법을 살펴보세요. TypeScript 컴파일러(tsc) 1. tsc란 무엇인가요? tsc는 TypeScript 컴파일러입니다. TypeScript 코드(.ts 또는 .tsx 파일)를 가져와서 JavaScript 런타임에서 실행할 수 있는 JavaScript 코드(.js 파일)로 컴파일합니다. 2. tsc 설치 방법 npm(Node Package Manager)을 사용하여 tsc를 전역적으로 설치할 수 있습니다. 1npm install -g typescript 3. TypeScript 코드 컴파일 tsc를 설치한 후 터미널에서 다음 명령을 실행하여 TypeScript 파일을 컴파일할 수 있습니다. 1tsc yourfile.ts 4. 컴파일러 옵션 tsc에는 컴파일 프로세스를 구성할 수 있는 다양한 컴파일러 옵션이 제공됩니다. 예를 들면 다음과 같습니다. 1tsc - target ES5 - outDir ./dist 이 명령은 대상 ECMAScript 버전을 ES5로 설정하고 출력 디렉터리를 './dist’로 지정합니다. tsconfig.json 1. tsconfig.json이란? tsconfig.json은 TypeScript 프로젝트를 위한 구성 파일입니다. 컴파일러 옵션을 지정하고, 파일을 포함/제외하고, TypeScript 프로젝트에 대한 기타 설정을 구성할 수 있습니다. 2. tsconfig.json 파일 만들기 프로젝트의 루트에서 tsconfig.json 파일을 수동으로 만들거나 tsc --init 명령을 사용하여 기본 구성 파일을 생성할 수 있습니다. 3. tsconfig.json의 컴파일러 옵션 tsconfig.json에는 다양한 컴파일러 옵션이 포함될 수 있습니다. 몇 가지 일반적인 옵션은 다음과 같습니다: compilerOptions : 컴파일러 설정을 지정합니다. include : 컴파일에 포함할 파일 패턴의 배열을 지정합니다. exclude : 컴파일에서 제외할 파일 패턴의 배열을 지정합니다. extends : 다른 구성 파일을 확장할 수 있습니다. 4. tsconfig.json 예제 123456789&#123; \"compilerOptions\": &#123; \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"./dist\" &#125;, \"include\": [\"src/**/*.ts\"], \"exclude\": [\"node_modules\"]&#125; 이 예에서는 대상을 ES5로, 모듈 시스템을 CommonJS로, 출력 디렉터리를 &quot;./dist&quot;로 설정하고, &quot;src&quot; 디렉터리에 모든 TypeScript 파일을 포함하며, &quot;node_modules&quot; 디렉터리는 제외합니다. tsconfig.json을 사용하면 TypeScript 프로젝트 전체에서 일관된 구성을 유지할 수 있으며, tsc 명령을 실행할 때마다 옵션을 지정할 필요가 없으므로 컴파일 프로세스가 간소화됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Tsconfig","slug":"Tsconfig","permalink":"http://hgko1207.github.io/tags/Tsconfig/"},{"name":"TSC","slug":"TSC","permalink":"http://hgko1207.github.io/tags/TSC/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"}]},{"title":"목표 설정에 ChatGPT를 사용하는 방법","slug":"chatgpt-20","date":"2024-03-10T07:00:05.000Z","updated":"2024-03-14T01:47:54.911Z","comments":true,"path":"2024/03/10/chatgpt-20/","link":"","permalink":"http://hgko1207.github.io/2024/03/10/chatgpt-20/","excerpt":"","text":"목표 설정에 ChatGPT를 사용하려면 모델과 구조화된 대화를 통해 목표를 명확히 하고, 잠재적인 장애물을 파악하며, 목표 달성을 위한 실행 가능한 단계를 만들어야 합니다. 다음은 목표 설정에 ChatGPT를 활용하는 방법에 대한 단계별 가이드입니다. 1. 목표 정의하기 목표를 명확하게 정의하는 것부터 시작하세요. 무엇을 달성하고 싶으신가요? 목표가 구체적이고, 측정 가능하며, 달성 가능하고, 관련성이 있고, 시간 제한이 있는(SMART) 목표인지 확인하세요. 2. 개방형 대화 목표를 설명하여 ChatGPT와 대화를 시작하세요. 다음과 같은 개방형 질문이나 프롬프트를 사용하여 대화를 유도하세요. [특정 목표]를 달성하고 싶은데, 그 목표에 도달하는 방법에 대한 지침을 찾고 있습니다. 아이디어를 브레인스토밍하고 계획을 세우는 데 도움을 주실 수 있나요? 3. 목표를 명확히 하세요 목표를 더 명확히 하기 위해 ChatGPT에 도움을 요청하세요. 목표, 염두에 두고 있는 타임라인, 예상되는 구체적인 과제에 대한 추가 세부 정보를 제공할 수 있습니다. 4. 장애물 파악하기 목표를 달성하는 데 직면할 수 있는 잠재적인 장애물이나 도전 과제에 대해 ChatGPT에 문의하세요. 여기에는 개인적인 한계, 외부 요인 또는 기타 장벽이 포함될 수 있습니다. 효과적인 계획을 세우려면 이러한 장애물을 이해하는 것이 중요합니다. 5. 브레인스토밍 솔루션 브레인스토밍 세션에 ChatGPT를 참여시켜 파악된 장애물에 대한 잠재적인 해결책을 도출하세요. 다음과 같은 질문을 하세요. [특정 장애물]을 극복하기 위한 전략에는 어떤 것이 있나요? [잠재적 장애물]에 직면했을 때 대안적인 접근 방식을 제안해 주시겠어요? 6. 실행 단계 만들기 ChatGPT와 협업하여 목표를 달성하기 위한 실행 가능한 단계를 계획하세요. 큰 목표를 관리하기 쉬운 작은 작업으로 세분화하세요. 우선순위와 일정에 대한 제안을 요청하세요. 7. 피드백을 요청하세요 실행 계획의 실현 가능성과 효과에 대해 ChatGPT의 피드백을 요청하세요. 다음과 같은 질문을 하세요. 이 단계가 현실적이고 달성 가능하다고 생각하나요? 제가 고려해야 할 계획에서 누락된 부분이 있나요? 8. 수정 및 개선 받은 피드백을 바탕으로 실행 계획을 수정하고 구체화하세요. 전반적인 목표에 부합하고 잠재적인 상황 변화에 적응할 수 있는지 확인하세요. 9. 마일스톤 설정하기 성공에 대한 명확한 기준을 가지고 목표를 마일스톤으로 세분화하세요. 그 과정에서 성취를 축하하고 동기를 유지하는 방법에 대한 조언을 ChatGPT에 요청하세요. 10. 반성하고 반복하세요. 주기적으로 목표를 재검토하고, 진행 상황을 평가하고, 필요에 따라 계획을 반복하세요. 지속적인 지원과 조정을 위해 ChatGPT를 이용하세요. 참고 ChatGPT는 귀중한 인사이트와 제안을 제공할 수 있지만, 조언을 비판적으로 평가하고 자신의 고유한 상황에 맞게 조정하는 것이 중요합니다. 또한 보다 포괄적인 관점을 위해 실제 멘토, 동료 또는 관련 분야의 전문가에게 의견을 구하는 것도 고려해 보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"목표 설정","slug":"목표-설정","permalink":"http://hgko1207.github.io/tags/%EB%AA%A9%ED%91%9C-%EC%84%A4%EC%A0%95/"}]},{"title":"TypeScript 사용법 및 JavaScript와의 비교","slug":"typescript-8","date":"2024-03-08T04:20:32.000Z","updated":"2024-03-08T04:34:07.544Z","comments":true,"path":"2024/03/08/typescript-8/","link":"","permalink":"http://hgko1207.github.io/2024/03/08/typescript-8/","excerpt":"","text":"Type Annotation 및 Type 추론 TypeScript 예제 12345let userName: string = 'Alice';function getUserAge(user: &#123; name: string; age: number &#125;): number &#123; return user.age;&#125; JavaScript 예제 1234let userName = 'Bob';function getUserAge(user) &#123; return user.age;&#125; TypeScript를 사용하면 개발자가 변수, 함수 매개변수 및 반환값의 타입을 명시적으로 정의할 수 있습니다. JavaScript 변수의 타입은 런타임에 추론되며 Type Annotation은 사용할 수 없습니다. 인터페이스와 클래스 TypeScript 예제 12345678interface User &#123; name: string; age: number;&#125;class Employee implements User &#123; constructor(public name: string, public age: number, public jobTitle: string) &#123;&#125;&#125; JavaScript 예제 1234567class Employee &#123; constructor(name, age, jobTitle) &#123; this.name = name; this.age = age; this.jobTitle = jobTitle; &#125;&#125; TypeScript 인터페이스를 사용하면 사용자 정의 타입을 정의할 수 있으며 클래스로 구현할 수 있습니다. JavaScript는 클래스를 지원하지만 인터페이스를 위한 내장 메커니즘이 없습니다. 개발 및 툴링 컴파일 시간과 런타임 TypeScript: 브라우저 또는 Node.js 환경에서 실행하기 전에 JavaScript로 변환해야 합니다. 이 프로세스를 통해 컴파일 타임에 타입 관련 오류 및 일부 구문 오류를 포착할 수 있습니다. JavaScript: 컴파일 단계 없이 브라우저 또는 Node.js에서 직접 실행할 수 있으므로 간단한 변경 사항에 대한 편집과 테스트 주기를 단축할 수 있습니다. IDE 지원 및 개발자 환경 TypeScript: 정적 타이핑으로 인해 고급 자동 완성, 코드 탐색 및 리팩토링 기능을 제공합니다. 특히 대규모 코드베이스에서 개발자의 생산성을 크게 향상시킬 수 있습니다. JavaScript: 최신 IDE는 JavaScript를 잘 지원하지만, 타입 정보가 부족하면 자동 완성 및 코드 분석과 같은 일부 기능의 효율성이 제한될 수 있습니다. 일반적인 용도 애플리케이션 확장 TypeScript: 강력한 타입 시스템으로 코드 유지보수성과 가독성을 향상시키고 런타임 오류 발생 가능성을 줄여주기 때문에 대규모 애플리케이션에 특히 선호됩니다. JavaScript: 중소규모 프로젝트 또는 빠른 프로토타이핑이 필요한 상황에 적합합니다. JavaScript의 동적 특성 덕분에 빠른 개발과 반복이 가능합니다. 커뮤니티와 생태계 TypeScript와 JavaScript 모두 강력한 커뮤니티와 생태계를 보유하고 있습니다. TypeScript는 엔터프라이즈급 애플리케이션에서 채택이 증가하고 있는 반면, JavaScript는 웹 개발에서 여전히 보편적으로 사용되고 있습니다. 사용 사례 TypeScript: 복잡한 프론트엔드 및 백엔드 애플리케이션, 특히 코드 명확성과 유지관리가 중요한 대규모 팀의 일부일 때 자주 선택됩니다. JavaScript: 웹 개발, 스크립트 및 애플리케이션에서 유연성과 빠른 반복을 위해 언어의 동적 특성을 최대한 활용할 수 있는 최고의 선택입니다. 결론 TypeScript와 JavaScript에는 각각 강점과 이상적인 사용 사례가 있습니다. TypeScript의 정적 타이핑은 개발자 도구, 오류 방지 및 코드베이스 확장성 측면에서 이점을 제공합니다. JavaScript의 보편성과 유연성은 빠른 개발 주기와 동적 타이핑이 유리한 프로젝트에서 타의 추종을 불허합니다. TypeScript와 JavaScript 중 어떤 것을 선택할지는 프로젝트 요구사항, 팀 선호도, 개발 중인 애플리케이션의 특정 과제에 따라 달라집니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"}]},{"title":"JavaScript에서 배열을 만드는 4가지 방법","slug":"js-dev-18","date":"2024-03-08T03:44:03.000Z","updated":"2024-03-08T03:52:35.166Z","comments":true,"path":"2024/03/08/js-dev-18/","link":"","permalink":"http://hgko1207.github.io/2024/03/08/js-dev-18/","excerpt":"","text":"소개 📘 JavaScript에서 배열은 여러 값을 저장하는 데 사용되는 참조 데이터 유형입니다. 이러한 값은 문자열, 숫자, boolean(true/false), null, undefined, 객체 또는 기타 배열일 수 있습니다. JavaScript에서는 여러 가지 방법으로 배열을 만들 수 있으며, 각 방법에는 고유한 장점과 고유한 사용 사례가 있습니다. JavaScript 개발자는 이러한 다양한 방법을 이해함으로써 특정 시나리오에 맞게 성능을 최적화하고, 코드 명확성을 높여 유지보수를 용이하게 하며, 다양한 프로그래밍 상황에 가장 적합한 배열 구성 기법을 적용할 수 있습니다. 1. Array Literal 사용 🔤 Array Literal은 배열을 만드는 가장 일반적이고 간단한 방법입니다. 쉼표로 구분된 값 목록을 대괄호 [] 로 묶어 정의합니다. 1let fruits = ['Apple', 'Banana', 'Cherry']; 이 예제에서 fruits는 세 개의 문자열을 포함하는 배열입니다. 이 방법은 가독성이 뛰어나며 단순하기 때문에 권장됩니다. 배열의 요소를 미리 알고 있을 때 특히 유용합니다. 2. Array 생성자 🏗️ Array 생성자는 new Array() 구문을 사용하여 배열을 만듭니다. 이 메서드는 다양한 방법으로 배열을 초기화할 수 있는 다목적 메서드입니다. 배열의 길이를 지정하는 단일 숫자를 사용합니다. 12let arrayOfUndefined = new Array(3);// [undefined, undefined, undefined] 요소 목록을 생성합니다. 1let numbers = new Array(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] Array 생성자는 특정 크기의 배열을 초기화해야 하거나 요소가 동적이거나 가변적인 소스에서 가져온 경우 특히 유용합니다. 3. Array.of 메서드 🧩 Array.of는 인수의 개수나 유형에 관계없이 인자 집합으로 배열을 만듭니다. 이 메서드를 사용하면 단일 인수를 전달하더라도 항상 배열이 생성됩니다. 1let singleItemArray = Array.of(10); // [10] 이 방법은 Array 생성자에서 발생할 수 있는 모호함을 피할 수 있으므로 단일 요소로 배열을 생성할 때 매우 유용합니다. 4. Array.from 메서드 🌟 Array.from은 iterable 또는 array과 유사한 객체에서 새 배열을 만듭니다. 이 메서드는 데이터 구조를 변환하는 데 강력하며 여러 가지 용도로 사용됩니다. 문자열을 문자 배열로 변환합니다. 1let chars = Array.from('Hello'); // ['H', 'e', 'l', 'l', 'o'] 매핑 함수를 사용하여 기존 배열에서 배열을 생성합니다. 1let doubled = Array.from([1, 2, 3], (x) =&gt; x * 2); // [2, 4, 6] Array.from은 매우 다재다능하며, 배열 형식이 아닌 데이터로 작업하거나 배열 생성 중에 변환을 수행해야 할 때 특히 유용합니다. 결론🎯 JavaScript에서 배열을 생성하는 각 메서드는 고유한 목적을 가지고 있습니다. 올바른 시나리오에 적합한 방법을 선택하면 효율적일 뿐만 아니라 이해하고 유지 관리하기 쉬운 코드를 작성할 수 있습니다. 배열 Literal의 단순성, 배열 생성자의 유연성, Array.of의 명확성, Array.from의 적응성 등 이러한 뉘앙스를 이해하는 것은 자바스크립트 프로그래밍에서 매우 중요한 기술입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"변수가 배열인지","slug":"변수가-배열인지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98%EA%B0%80-%EB%B0%B0%EC%97%B4%EC%9D%B8%EC%A7%80/"},{"name":"배열","slug":"배열","permalink":"http://hgko1207.github.io/tags/%EB%B0%B0%EC%97%B4/"}]},{"title":"번역을 위한 ChatGPT 프롬프트 베스트 10","slug":"chatgpt-19","date":"2024-03-06T06:39:53.000Z","updated":"2024-03-07T14:37:21.534Z","comments":true,"path":"2024/03/06/chatgpt-19/","link":"","permalink":"http://hgko1207.github.io/2024/03/06/chatgpt-19/","excerpt":"","text":"효율적이고 신뢰할 수 있는 번역 도구를 찾고 계신가요? ChatGPT만 있으면 됩니다! OpenAI에서 개발한 최첨단 챗봇인 ChatGPT는 뛰어난 번역 기능으로 인기를 얻고 있습니다. 이 글에서는 번역에 가장 적합한 ChatGPT 프롬프트 10가지를 살펴보고 왜 우수한 번역을 제공할 수 있는지 설명합니다. 문서나 이메일을 번역해야 할 때나 단순히 다른 언어로 대화를 나누고 싶을 때 ChatGPT는 모든 것을 해결해 줍니다. 번역에서 ChatGPT의 힘 ChatGPT는 강력한 신경망을 활용하여 다양한 언어로 사람과 유사한 응답을 생성합니다. 이 기술을 활용하여 ChatGPT는 언어와 문맥의 뉘앙스에 맞는 정확한 번역을 제공할 수 있습니다. 고급 기계 학습 알고리즘을 통해 번역을 빠르게 이해하고 생성할 수 있어 개인과 기업 모두에게 매우 유용한 도구입니다. 번역 경험을 향상시킬 수 있는 최고의 ChatGPT 번역 프롬프트에 대해 자세히 알아보세요. 1. “다음 문장을 영어에서 [대상 언어]로 번역하세요.” 이 프롬프트를 사용하면 원본 언어(영어)와 대상 언어를 지정할 수 있어 정확한 번역이 보장됩니다. 명확한 지침을 제공함으로써 귀하의 요구에 맞는 고품질 번역을 얻을 수 있습니다. 2. “[대상 언어]로 [단어/구문]을 어떻게 말하나요?” 개별 단어나 구문의 번역을 찾고 있나요? 이 ChatGPT 프롬프트는 당신에게 딱 맞습니다! 특정 단어나 구문의 번역을 추출하여 어휘를 확장하고 대상 언어로 효과적으로 의사소통할 수 있습니다. 3. “이 문서를 [대상 언어]로 번역하세요.” 이 프롬프트를 사용하면 전체 문서를 원하는 언어로 손쉽게 번역할 수 있습니다. 문서를 업로드하고 대상 언어를 지정하기만 하면 ChatGPT가 마법을 부립니다. 번역 프로세스를 간소화하여 시간과 노력을 절약해 줍니다. 4. “다음 대화의 번역을 제공해 주세요.” 번역이 필요한 대화가 있는 경우 ChatGPT가 도움을 드릴 수 있습니다. 대화를 공유하고 대상 언어를 지정하면 신뢰할 수 있는 번역을 받을 수 있습니다. 이 프롬프트는 다국어 토론이나 비즈니스 협상에 참여하는 개인에게 특히 유용합니다. 5. “다음 문장을 [원어]에서 영어로 번역하세요.” 이 프롬프트는 첫 번째 프롬프트와 반대 방향으로 작동합니다. 영어가 아닌 다른 언어로 된 문장이 있는 경우 ChatGPT의 번역 기능을 활용하여 영어로 변환할 수 있습니다. 외국 텍스트를 접하거나 영어가 아닌 콘텐츠를 이해하는 데 도움이 필요할 때 이상적인 프롬프트입니다. 6. “[대상 언어]로 [단어/구문]을 어떻게 발음하나요?” 새로운 언어를 배우거나 원어민과 의사소통할 때 정확한 발음은 매우 중요합니다. 이 프롬프트를 사용하여 목표 언어로 특정 단어나 구문의 발음을 문의할 수 있습니다. ChatGPT는 정확한 음성 표현을 제공하여 언어 학습 여정을 도와줍니다. 7. “다음 웹페이지를 [대상 언어]로 번역하세요.” 해외 시장으로 비즈니스를 확장하고 계신가요? 이 ChatGPT 프롬프트는 매우 유용합니다. 웹페이지를 특정 언어로 번역해 달라고 요청하면 더 많은 고객에게 원활하게 다가갈 수 있습니다. ChatGPT는 번역된 콘텐츠가 원래의 의미와 의도를 유지하도록 보장하여 전 세계 고객과 효과적으로 소통할 수 있도록 합니다. 8. “[대상 언어]에서 [단어/구문]의 의미를 이해하도록 도와주실 수 있나요?” 때로는 단어나 구문의 의미를 이해하는 것이 직접 번역하는 것보다 더 어려울 때가 있습니다. 이 프롬프트를 사용하면 ChatGPT가 대상 언어의 특정 단어나 구문과 관련된 의미와 문화적 중요성에 대한 자세한 설명을 제공할 수 있습니다. 이 프롬프트는 언어 지식을 풍부하게 하고 의사소통 능력을 향상시킵니다. 9. “다음 이메일을 [원어]에서 [대상 언어]로 번역하세요.” 다른 언어로 이메일을 통해 소통해야 하는 경우 이 프롬프트는 획기적인 방법입니다. 이메일 콘텐츠와 원하는 대상 언어를 공유하기만 하면 ChatGPT가 현지화된 번역을 생성합니다. 메시지를 정확하게 전달하고 수신자가 잘 수신할 수 있도록 보장합니다. 10. “[대상 언어]로 [단어/문구]를 어떻게 작성하나요?” 외국어로 글을 쓸 때는 문법 규칙, 문장 구조, 작문 관습이 다를 수 있습니다. 이러한 어려움을 극복하기 위해 이 프롬프트는 매우 중요한 역할을 합니다. 대상 언어로 특정 단어나 문구를 작성하는 데 대한 안내를 요청함으로써 ChatGPT는 사용자가 잘 작성된 콘텐츠를 만들 수 있도록 도와줍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"번역","slug":"번역","permalink":"http://hgko1207.github.io/tags/%EB%B2%88%EC%97%AD/"}]},{"title":"JavaScript에서 변수가 배열인지 확인하는 방법 🧐","slug":"js-dev-17","date":"2024-03-05T13:17:38.000Z","updated":"2024-03-06T06:28:56.006Z","comments":true,"path":"2024/03/05/js-dev-17/","link":"","permalink":"http://hgko1207.github.io/2024/03/05/js-dev-17/","excerpt":"","text":"JavaScript에서 개발자의 기본적인 작업 중 하나는 주어진 변수의 유형을 결정하는 것입니다. 배열은 언어의 핵심 데이터 구조로, 단순한 데이터 저장부터 복잡한 알고리즘까지 다양한 연산에 자주 사용되기 때문에 배열을 다룰 때 특히 중요합니다. 그러나 배열을 객체의 한 유형으로 취급하는 JavaScript의 특성상 배열을 올바르게 식별하는 것이 항상 간단한 것은 아닙니다. 이 글에서는 JavaScript에서 주어진 변수가 배열인지 아닌지 확인하는 3가지 방법을 설명합니다. JavaScript의 변수 이해 🔍 배열에 대해 자세히 알아보기 전에 JavaScript의 변수에 대해 간단히 살펴보겠습니다. JavaScript는 동적 타입 언어이므로 변수는 명시적으로 선언하지 않고도 모든 유형의 데이터를 저장할 수 있습니다. 이러한 유연성은 훌륭하지만, 특히 변수의 유형을 결정할 때 혼란을 초래할 수 있습니다. 배열(Array) 딜레마 🤔 배열은 값의 목록을 저장하는 데 사용되는 JavaScript의 기본 데이터 구조입니다. 하지만 변수가 실제로 배열인지 어떻게 알 수 있을까요? 여기서 JavaScript가 우리에게 커브볼을 던집니다. JavaScript의 배열은 엄밀히 말해 객체이기 때문에 기존의 타입 검사 방법이 예상대로 작동하지 않을 수 있습니다. 자세히 알아보기 🏊‍♂️ 1. Array.isArray() 사용⭐ 변수가 배열인지 확인하는 가장 안정적이고 간단한 방법은 Array.isArray() 메서드를 사용하는 것입니다. ECMAScript 5에 도입된 이 메서드는 변수가 배열이면 true을 반환하고, 그렇지 않으면 false을 반환합니다. 다음과 같이 간단합니다 12345let fruits = ['apple', 'banana', 'cherry'];console.log(Array.isArray(fruits)); // Output: truelet number = 42;console.log(Array.isArray(number)); // Output: false 2. instanceof 연산자 🛠️ 배열을 확인하는 또 다른 방법은 instanceof 연산자를 사용하는 것입니다. 이 연산자는 객체가 특정 클래스 또는 생성자 함수의 인스턴스인지 여부를 확인합니다. 배열의 경우 다음과 같이 사용할 수 있습니다: 12let vegetables = ['carrot', 'potato', 'onion'];console.log(vegetables instanceof Array); // Output: true 하지만 한 가지 문제가 있습니다. instanceof 연산자는 특정 시나리오에서 예상대로 작동하지 않을 수 있으며, 특히 iframe과 같은 다른 실행 컨텍스트를 다룰 때 더욱 그렇습니다. 3. constructor 속성 🏗️ JavaScript의 모든 배열에는 Array 함수를 가리키는 constructor 속성이 있습니다. 이를 사용하여 변수가 배열인지 확인할 수 있습니다. 12let colors = ['red', 'green', 'blue'];console.log(colors.constructor === Array); // Output: true 이 방법은 덜 일반적이며 특히 constructor 속성이 변경된 경우 약간 까다로울 수 있습니다. 올바른 메서드 선택하기 🧭 변수가 배열인지 확인하는 데 사용할 메서드를 결정할 때는 코드의 컨텍스트를 고려하세요. 일반 사용: 정확성을 보장하는 Array.isArray()를 대부분의 상황에서 선택해야 합니다. 특정 컨텍스트: 일관된 단일 실행 컨텍스트에서 작업하고 있고 객체의 프로토타입 체인이 확실하다면 instanceof를 사용하세요. 제어 환경: constructor 속성 검사는 객체를 완전히 제어할 수 있고 constructor가 변조되지 않았다고 확신하는 시나리오에서 사용할 수 있습니다. 결론 🎉 JavaScript에서 변수가 배열인지 확인하는 것은 개발자의 툴킷에서 핵심적인 기술입니다. 각 메서드에는 고유한 사용 사례가 있으며 Array.isArray(), instanceof 또는 constructor 속성을 언제 사용해야 하는지 알면 코드를 더욱 강력하고 오류 없이 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"변수가 배열인지","slug":"변수가-배열인지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98%EA%B0%80-%EB%B0%B0%EC%97%B4%EC%9D%B8%EC%A7%80/"},{"name":"배열","slug":"배열","permalink":"http://hgko1207.github.io/tags/%EB%B0%B0%EC%97%B4/"}]},{"title":"AI로 수익을 창출하는 방법","slug":"ai-22","date":"2024-03-04T04:34:04.000Z","updated":"2024-03-05T13:15:49.795Z","comments":true,"path":"2024/03/04/ai-22/","link":"","permalink":"http://hgko1207.github.io/2024/03/04/ai-22/","excerpt":"","text":"오늘날 디지털 시대의 역동적인 환경에서 인공지능(AI)은 단순한 유행이 아니라 그 잠재력을 탐구하려는 사람들에게 수익성 높은 기회를 제공하는 게임 체인저입니다. 개인과 기업이 AI의 힘을 활용하여 수익을 창출하는 방법에 대한 종합적인 가이드를 소개합니다. 1. AI 프리랜서 프리랜서 플랫폼에서 AI 기술을 제공하여 긱 경제(Gig Economy)를 활용하세요. 머신러닝, 자연어 처리, 컴퓨터 비전 등 AI 전문 지식에 대한 수요가 점점 더 커지고 있습니다. Upwork와 Freelancer 같은 플랫폼은 숙련된 개인과 AI 솔루션을 찾는 기업을 연결해 줍니다. 2. AI 컨설팅 AI 컨설턴트로 자리매김하세요. 많은 기업이 AI를 비즈니스에 통합하고 싶어 하지만 전문 지식이 부족합니다. 전략적 조언을 제공하고, AI 구현 영역을 파악하고, 기업의 요구 사항에 맞는 AI 솔루션을 채택하는 과정을 안내하세요. 3. AI 애플리케이션 개발 특정 과제를 해결하거나 사용자 경험을 향상시키기 위해 AI 기반 애플리케이션을 개발합니다. 여기에는 AI 기반 모바일 앱부터 생산성 도구까지 다양합니다. 앱 스토어, 라이선스 또는 구독 모델을 통해 창작물을 수익화하세요. 4. AI 콘텐츠 제작 AI 도구를 활용하여 콘텐츠를 효율적으로 생성하세요. 여기에는 자동화된 글쓰기, 동영상 제작 또는 그래픽 디자인이 포함될 수 있습니다. 비용 효율적인 솔루션을 찾는 기업을 위해 AI로 생성된 콘텐츠 서비스를 제공하는 플랫폼을 개발하세요. 5. 전자상거래에서의 AI 추천 엔진, 고객 지원을 위한 챗봇, 재고 관리를 위한 예측 분석을 개발하여 전자상거래에서 AI를 구현하세요. 이러한 솔루션을 온라인 소매업체에 제공하여 사용자 참여를 높이고 매출을 증대하세요. 6. 의료 분야의 AI 진단, 환자 관리 또는 데이터 분석을 위한 AI 애플리케이션을 개발하여 의료 부문에서 기회를 모색하세요. 의료 기관과 협력하여 효율성과 환자 치료 결과를 개선하는 AI 솔루션을 구현하세요. 7. AI 교육 및 훈련 AI에 대한 관심이 높아짐에 따라 교육 및 훈련에 대한 수요가 증가하고 있습니다. 온라인 강좌, 튜토리얼 또는 교육 프로그램을 개발하여 개인과 기업을 대상으로 AI 애플리케이션을 교육하세요. 수강료 또는 구독 모델을 통해 수익을 창출하세요. 8. AI 데이터 주석 서비스 AI 알고리즘은 학습을 위해 라벨이 잘 지정된 데이터 세트가 필요합니다. AI 프로젝트를 진행하는 기업에 데이터 주석 서비스를 제공하세요. 여기에는 데이터에 라벨을 붙이고 분류하는 작업이 포함되며, AI 모델 정확도 향상에 기여합니다. 9. AI 연구 및 개발 AI 연구에 뛰어들어 새로운 알고리즘, 모델 또는 애플리케이션을 개척하세요. 보조금, 협업을 통해 자금을 확보하거나 AI 혁신의 최전선에 서고자 하는 조직에 전문 지식을 제공함으로써 자금을 확보할 수 있습니다. 10. AI 하드웨어 솔루션 AI 처리에 최적화된 특수 칩이나 장치를 개발하여 AI의 하드웨어 측면을 탐구하세요. 이러한 솔루션은 애플리케이션을 위한 효율적인 AI 하드웨어가 필요한 기업에 판매할 수 있습니다. 결론 결론적으로, AI로 수익을 창출할 수 있는 기회는 방대하고 다양합니다. AI 기술을 보유한 개인이든 혁신을 추구하는 기업이든, 인공지능의 세계를 받아들이면 금전적인 성공은 물론 다양한 산업에 큰 영향을 미칠 수 있습니다. AI가 계속 발전함에 따라 이 분야에서 전략적으로 위치를 잡는 사람들은 장기적인 성공을 거둘 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"수익 창출","slug":"수익-창출","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EC%9D%B5-%EC%B0%BD%EC%B6%9C/"}]},{"title":"운동 계획을 위한 ChatGPT 프롬프트 가이드","slug":"chatgpt-18","date":"2024-03-04T03:05:53.000Z","updated":"2024-03-04T04:15:42.586Z","comments":true,"path":"2024/03/04/chatgpt-18/","link":"","permalink":"http://hgko1207.github.io/2024/03/04/chatgpt-18/","excerpt":"","text":"빠르게 변화하는 오늘날의 세상에서 건강을 유지하는 것이 그 어느 때보다 중요해졌습니다. 손끝에 있는 기술을 통해 운동 루틴을 향상시킬 수 있는 새롭고 흥미로운 방법, 바로 ChatGPT가 있습니다! 이 강력한 도구는 피트니스 목표에 맞는 개인 맞춤형의 효과적인 운동 계획을 세우는 데 도움을 줍니다. 이 블로그에서는 ChatGPT가 어떻게 즐겁고 유익한 운동 계획을 세우는 데 도움이 되는지 살펴볼게요. ChatGPT를 사용하여 원하는 운동 계획을 세우는 방법 개인화가 핵심 ChatGPT의 뛰어난 기능 중 하나는 운동 계획을 개인화할 수 있는 기능입니다. 사용자의 체력 수준, 목표, 선호하는 운동을 입력하면 ChatGPT는 사용자의 필요에 맞는 계획을 맞춤 설정합니다. 이러한 개인 맞춤화는 운동의 효과뿐만 아니라 즐거움도 보장합니다. 균형 잡힌 운동 ChatGPT는 균형 잡힌 운동 루틴을 만드는 데 탁월합니다. 심혈관 운동, 근력 운동, 유연성 운동을 혼합하여 피트니스에 대한 전체적인 접근 방식을 보장합니다. 이러한 균형은 지루함을 방지하고 최적의 결과를 위해 신체가 계속 도전하도록 도와줍니다. 일정에 대한 적응성 삶은 바쁠 수 있지만, 그것이 피트니스 여정에 장애물이 되어서는 안 됩니다. ChatGPT는 사용자의 일정에 완벽하게 맞는 운동 계획을 설계할 수 있습니다. 20분이든 1시간이든, ChatGPT는 사용 가능한 시간을 최대한 활용할 수 있는 운동을 제안할 수 있습니다. 운동 계획에 ChatGPT를 사용하기 위한 실용적인 팁 이제 기본 사항을 알았으니, 운동 여정에 ChatGPT를 최대한 활용할 수 있는 몇 가지 실용적인 팁을 알아보세요. 명확한 목표 설정 피트니스 목표를 명확하게 정의하는 것부터 시작하세요. 체중 감량, 근육 강화, 전반적인 건강 개선 등, 목표를 명시하면 ChatGPT가 여러분의 열망에 맞는 계획을 세우는 데 도움이 됩니다. 정직한 체력 수준 평가 현재 체력 수준에 대한 정확한 정보를 제공하세요. 이를 통해 ChatGPT는 사용자의 능력에 맞는 운동을 추천하여 불필요한 부담이나 좌절을 방지할 수 있습니다. 다양성은 운동의 묘미 다양성을 더해 운동 루틴을 흥미진진하게 유지하세요. ChatGPT는 다양한 운동을 제안하여 지루함을 방지하고 새로운 방식으로 신체에 도전할 수 있습니다. 내 몸에 귀 기울이기 ChatGPT는 환상적인 가이드를 제공하지만, 항상 내 몸에 귀를 기울이세요. 운동이 불편하거나 통증을 유발하는 경우, 운동을 수정하거나 건너뛰어도 괜찮습니다. 안전과 건강을 최우선으로 생각해야 합니다. 일관성 중요 운동 계획을 일관되게 유지하세요. 결과를 보려면 일관성이 중요합니다. ChatGPT는 여러분의 라이프스타일에 맞는 현실적인 스케줄을 만드는 데 도움을 줄 수 있습니다. 운동 계획을 위한 ChatGPT 프롬프트 다음은 운동 계획을 위한 몇 가지 프롬프트입니다. 맞춤형 운동 계획 만들기 운동 목표를 입력하고, 체중 감량/근육 강화/전반적인 체력 향상 등의 운동 루틴을 통해 이러한 결과를 얻고 싶습니다. 내 [입력 환경 설정 및 일정]에 맞는 계획을 만들 수 있도록 안내해 주세요. 내 [현재 체력 수준, 선호하는 운동, 내가 이용할 수 있는 모든 장비]에 대한 세부 정보를 제공합니다. 효과적인 홈트레이닝 루틴 설계하기 잘 설계된 운동 루틴을 통해 집에서 편안하게 건강을 유지하고 활동적인 상태를 유지하고 싶습니다. 제가 사용할 수 있는 장비를 사용하여 종합적인 계획을 세울 수 있도록 도와주세요. 저는 [장비, 덤벨/저항 밴드 등을 입력]했습니다. 다양한 근육군을 목표로 하고 동기를 부여할 수 있는 루틴을 설계해 주세요. 바쁜 직장인을 위한 맞춤형 운동 계획 세우기 바쁜 직장인이라면 운동할 시간을 내기가 어려울 수 있습니다. 바쁜 일정에 완벽하게 맞는 운동 계획을 세울 수 있도록 도와주세요. 근무 시간과 약속을 포함한 일상에 대한 [세부 정보]를 입력하세요. 결과를 극대화할 수 있는 시간 효율적인 계획을 설계합니다. 업무에 지장을 주지 않으면서 건강과 피트니스에 우선순위를 둡니다. 초보자 친화적인 운동 계획 세우기 저는 [운동을 처음 시작하거나] 휴식 후 다시 일상으로 돌아가고 있습니다. [현재 체력 수준, 제한 사항이나 부상 여부, 선호하는 운동 강도를 입력하세요.] 점차 난이도가 높아지는 초보자 친화적인 운동 계획을 만들어 근력과 지구력을 안전하게 키울 수 있도록 해주세요. 결론 결론적으로, ChatGPT는 피트니스 여정을 개선하고자 하는 모든 사람에게 유용한 도구입니다. 개인화된 접근 방식과 사용자의 필요에 맞게 조정할 수 있는 ChatGPT는 매력적이고 효과적인 운동 계획을 제공하는 가상 피트니스 동반자가 될 수 있습니다. 성공의 열쇠는 명확한 목표를 설정하고, 일관성을 유지하며, 그 과정을 즐기는 것임을 기억하세요. 더 건강하고 날씬한 나를 위한 여정에 ChatGPT가 가이드가 되어주세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"운동","slug":"운동","permalink":"http://hgko1207.github.io/tags/%EC%9A%B4%EB%8F%99/"},{"name":"운동 계획","slug":"운동-계획","permalink":"http://hgko1207.github.io/tags/%EC%9A%B4%EB%8F%99-%EA%B3%84%ED%9A%8D/"}]},{"title":"Google의 Gemini AI: 혁신적인 차세대 AI","slug":"ai-21","date":"2024-02-27T13:23:16.000Z","updated":"2024-02-29T10:26:05.732Z","comments":true,"path":"2024/02/27/ai-21/","link":"","permalink":"http://hgko1207.github.io/2024/02/27/ai-21/","excerpt":"","text":"Google의 Gemini AI는 단순한 AI가 아닙니다. 게임 체인저입니다! 사용자가 요청하는 거의 모든 작업을 수행하고 친구처럼 사용자를 이해하며 복잡한 문제를 해결하는 데 도움을 주는 스마트 기술을 상상해 보세요. Google Brain과 DeepMind의 융합으로 탄생한 Gemini AI가 AI의 작동 방식을 바꿀 것입니다. 가능성의 한계를 재정의하는 초능력 Gemini AI는 놀라운 힘을 가진 슈퍼히어로와 같습니다: 모든 것을 이해: 텍스트, 코드, 이미지, 오디오를 처리할 수 있어 다양한 유형의 정보가 필요한 까다로운 작업을 해결할 수 있습니다. 인간처럼 대화하기: 친구와 대화하듯 자연스럽게 대화할 수 있습니다. 챗봇이나 가상 비서와 같은 기능에 적합합니다. 코드 작성: 소프트웨어 개발자가 코드를 더 빠르고 더 잘 작성할 수 있도록 도와준다고 상상해 보세요. Gemini AI는 코딩을 더 쉽고 효율적으로 만들어 줍니다. 데이터 탐정: 방대한 양의 데이터를 이해하는 전문가입니다. 비밀과 패턴을 찾아내고 더 현명한 결정을 내리는 데 도움을 줍니다. 변화하는 산업과 생활 Gemini AI는 단순히 멋진 기술 가젯이 아닙니다. 산업을 변화시키고 있습니다 소프트웨어 초능력: 소프트웨어 제작 방식을 바꾸고 있습니다. 코딩, 테스트, 오류 수정 등 모든 작업이 더 빠르고 더 잘 수행됩니다. 고객 서비스 업그레이드: Gemini AI로 구동되는 챗봇은 밤낮을 가리지 않고 개인화된 빠른 고객 지원을 제공합니다. 더 스마트한 학습: 나만을 위한 맞춤형 학습을 상상해 보세요. Gemini AI는 개인 맞춤형 교육을 실현합니다. 더 나은 의료 서비스: 연구, 질병 진단, 개인 맞춤형 치료 계획 수립을 지원하여 의료 서비스를 변화시키고 있습니다. 창의력 발휘: 예술과 음악 분야에서 Gemini AI는 새로운 아이디어를 촉발하여 창의성의 한계를 넓히고 있습니다. AI의 미래 살짝 엿보기 Gemini AI는 세상을 혁신할 것입니다. 효율성 향상: 산업이 더 스마트하게 작동하여 일을 더 빠르고 더 좋게 만들 것입니다. 스마트한 의사 결정: 인사이트를 통해 다양한 분야에서 더 나은 선택을 할 수 있도록 도와줍니다. 개인화된 모든 것: 필요한 것에 맞춰 적응하여 더욱 특별한 경험을 선사합니다. 모두를 위한 AI: Gemini AI의 접근성이 향상되어 더 많은 사람들이 사용하고 개발할 수 있게 될 것입니다. Google Gemini AI의 내부 특종 Gemini에 관한 몇 가지 흥미로운 사실은 다음과 같습니다. Giants 기반: 공동 창립자 Sergey Brin을 비롯한 Google의 전문가들이 Gemini AI를 최고 수준으로 만들고 있습니다. 크기가 중요합니다: Ultra, Pro, Nano의 세 가지 크기로 제공되며 각기 다른 성능을 가지고 있습니다. 장벽을 허물다: Gemini AI는 텍스트만 다루는 것이 아닙니다. 텍스트와 이미지를 혼합하여 다른 제품과 치열한 경쟁을 벌입니다. 음성 이해: 음성을 이해하고 데이터를 분석하여 AI를 새로운 차원으로 끌어올릴 수 있습니다. 마무리 Gemini AI는 거대한 도약입니다. 우리가 일하고, 배우고, 기계와 상호 작용하는 방식을 바꿀 것입니다. 하지만 성장하는 과정에서 공정하고 개방적이며 모든 사람이 이용할 수 있도록 해야 한다는 점을 잊지 마세요. 새로운 가능성의 세계가 열리고 있으니 마음의 준비를 하세요! https://gemini.google.com/?hl=ko","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Gemini","slug":"Gemini","permalink":"http://hgko1207.github.io/tags/Gemini/"},{"name":"Gemini AI","slug":"Gemini-AI","permalink":"http://hgko1207.github.io/tags/Gemini-AI/"},{"name":"Google AI","slug":"Google-AI","permalink":"http://hgko1207.github.io/tags/Google-AI/"}]},{"title":"컨테이너화 VS 가상화","slug":"devops-1","date":"2024-02-27T12:54:26.000Z","updated":"2024-03-05T03:01:31.195Z","comments":true,"path":"2024/02/27/devops-1/","link":"","permalink":"http://hgko1207.github.io/2024/02/27/devops-1/","excerpt":"","text":"컨테이너화와 가상화는 IT 및 소프트웨어 배포 세계에서 사용되는 두 가지 다른 기술입니다. 다음은 두 가지에 대한 내용입니다. 컨테이너화(Containerization) 경량: 컨테이너는 가상 머신(VM)에 비해 놀라울 정도로 가볍습니다. 호스트 OS 커널을 공유하므로 시스템 리소스를 덜 소비하고 빠르게 시작할 수 있습니다. 이식성: 컨테이너는 애플리케이션과 모든 종속성을 캡슐화하여 이식성이 뛰어납니다. 개발용 노트북, 테스트 서버 또는 클라우드에서 동일한 컨테이너를 수정 없이 실행할 수 있습니다. Docker: Docker는 사용자 친화적인 도구와 표준화를 통해 컨테이너화를 대중화했습니다. 애플리케이션을 패키징하고 배포하는 방식에 혁신을 가져왔습니다. 마이크로서비스: 컨테이너는 마이크로서비스 아키텍처에서 자주 사용됩니다. 각 마이크로서비스는 자체 컨테이너에서 실행할 수 있으므로 개별 서비스의 확장, 업데이트 및 유지 관리가 더 쉬워집니다. 오케스트레이션: Kubernetes는 컨테이너 오케스트레이션을 위한 강력한 도구입니다. 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하여 컨테이너화된 인프라의 초석이 됩니다. 가상화(Virtualization) 하이퍼바이저: 가상화는 가상 머신을 생성하고 관리하기 위해 하이퍼바이저(예: VMware, Hyper-V 또는 KVM)에 의존합니다. 이러한 가상 머신은 완전한 운영 체제를 실행하며, 호스트 OS와는 다를 수 있습니다. 격리: 가상화는 VM 간에 강력한 격리 기능을 제공합니다. 각 VM은 전용 물리적 하드웨어에서 실행되는 것처럼 작동하므로 보안과 격리가 가장 중요한 시나리오에 적합합니다. 리소스 오버헤드: 가상화는 컨테이너에 비해 리소스 오버헤드가 더 높습니다. 단일 물리적 서버에서 여러 가상 머신을 실행하려면 더 많은 메모리와 CPU 리소스가 필요합니다. 레거시 시스템: 가상화는 특정 OS 버전이나 구성에 대한 종속성으로 인해 컨테이너화된 환경에서 제대로 작동하지 않을 수 있는 레거시 애플리케이션을 실행하는 데 자주 사용됩니다. 실시간 마이그레이션: 가상화 기술을 사용하면 물리적 호스트 간에 가상 머신을 실시간으로 마이그레이션할 수 있으므로 고가용성 및 부하 분산이 가능합니다. 공통점 하이브리드 솔루션: 많은 조직에서 컨테이너화와 가상화를 함께 사용합니다. 예를 들어, 물리적 서버에서 가상 머신을 실행한 다음 해당 가상 머신 내에 컨테이너를 배포할 수 있습니다. 보안: 컨테이너는 가상 머신에 비해 격리 기능이 떨어지지만 여전히 효과적으로 보안을 유지할 수 있습니다. 컨테이너 이미지 스캔 및 네트워크 세분화와 같은 기술은 컨테이너 보안을 강화하는 데 사용됩니다. 리소스 효율성: 컨테이너는 일반적으로 VM보다 리소스 효율성이 높기 때문에 클라우드 네이티브 및 DevOps 환경에서 선호됩니다. 그러나 VM은 특정 사용 사례에 여전히 유용합니다. 신속한 개발: 컨테이너는 신속한 개발과 지속적인 통합/지속 배포(CI/CD) 파이프라인에 적합합니다. 개발자는 컨테이너를 통해 애플리케이션을 빠르게 패키징하고 배포할 수 있습니다. 마무리 요약하면, 컨테이너화와 가상화에는 각기 다른 강점과 사용 사례가 있습니다. 리소스 요구 사항, 격리 요구 사항, 배포되는 애플리케이션의 특성 등의 요인에 따라 둘 중 하나를 선택해야 합니다. 대부분의 경우 최신 IT 인프라에서 서로를 보완할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"DevOps","slug":"DevOps","permalink":"http://hgko1207.github.io/tags/DevOps/"},{"name":"컨테이너화","slug":"컨테이너화","permalink":"http://hgko1207.github.io/tags/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%ED%99%94/"},{"name":"가상화","slug":"가상화","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EC%83%81%ED%99%94/"}]},{"title":"글쓰기 향상을 위한 ChatGPT 프롬프트 가이드","slug":"chatgpt-17","date":"2024-02-27T06:39:42.000Z","updated":"2024-03-04T02:58:46.274Z","comments":true,"path":"2024/02/27/chatgpt-17/","link":"","permalink":"http://hgko1207.github.io/2024/02/27/chatgpt-17/","excerpt":"","text":"역동적인 커뮤니케이션 세계에서 글쓰기를 통해 자신을 명확하게 표현하는 능력은 매우 중요한 기술입니다. 노련한 작가이든 이제 막 시작한 작가이든 항상 개선의 여지가 있습니다. 이 글에서는 ChatGPT 프롬프트가 글쓰기 실력을 향상시키고 창의력을 발휘할 수 있는 강력한 도구가 될 수 있는 방법에 대해 살펴봅니다. 글쓰기 요구에 맞게 ChatGPT 프롬프트를 효과적으로 사용하는 방법 다양한 프롬프트 생성하기 ChatGPT는 다양한 장르와 스타일의 프롬프트를 생성할 수 있습니다. 소설, 논픽션, 기술 글쓰기, 심지어 시와 관련된 프롬프트로 실험해 보세요. 이러한 다양성은 글쓰기의 지평을 넓히고 새로운 강점을 발견하는 데 도움이 될 수 있습니다. 아이디어 구체화하기 개념이나 주제에 대해 고민하고 있나요? ChatGPT를 사용해 아이디어를 브레인스토밍하고 구체화하세요. 주제와 관련된 간단한 설명이나 키워드를 입력하면 ChatGPT가 다양한 각도나 접근법을 제시해 줍니다. 이는 창의적인 아이디어가 떠오르지 않을 때 특히 유용할 수 있습니다. 어휘력 향상 어휘를 풍부하게 하고 싶으신가요? ChatGPT 프롬프트를 활용하여 동의어와 대체 문구를 찾아보세요. 새로운 단어와 표현을 글에 통합하면 더욱 매력적이고 세련된 산문을 작성할 수 있습니다. 꾸준히 연습하기 다른 모든 기술과 마찬가지로 글쓰기 역시 연습을 통해 향상됩니다. 전용 시간을 따로 마련하여 정기적으로 ChatGPT 프롬프트에 대한 연습을 하세요. 꾸준한 연습은 글쓰기 능력을 연마할 뿐만 아니라 개선이 필요한 부분을 파악하는 데도 도움이 됩니다. 건설적인 피드백 받기 ChatGPT를 사용하여 글쓰기에 대한 잠재적인 질문이나 우려 사항을 생성하세요. 이는 가상 피드백 메커니즘의 역할을 하여 자신의 작업을 비판적으로 평가할 수 있게 해줍니다. 글쓰기에서 이러한 잠재적인 문제를 해결하면 전반적인 개선으로 이어질 수 있습니다. 어조와 스타일 실험하기 다양한 어조와 글쓰기 스타일을 시도해보고 자신에게 가장 적합한 것을 찾아보세요. 형식적, 대화적, 설득적, 설명적 등 다양한 글쓰기 스타일을 실험해 볼 수 있는 ChatGPT는 다양한 상황에 맞게 목소리를 조정할 수 있도록 도와줍니다. 작가의 장벽 극복하기 글쓰기 장벽는 흔한 장애물입니다. 막막할 때는 ChatGPT를 사용하여 창의력을 발휘할 수 있는 프롬프트를 생성하세요. 프롬프트가 제공하는 신선한 관점은 정신적 막힘을 극복하고 아이디어의 흐름을 유지하는 데 도움이 될 수 있습니다. ChatGPT 프롬프트 예시 다음은 ChatGPT를 활용하여 글쓰기 실력을 향상시키는 데 도움이 되는 10가지 매력적인 프롬프트입니다: 디스토피아 세계 탐험하기 “여러분이 혁신적인 스마트 홈 기기를 판매하는 카피라이터라고 상상해 보세요. 제품의 기능을 강조할 뿐만 아니라 잠재 구매자의 감성에 호소하는 설득력 있는 제품 설명을 작성하세요.” 설득력 있는 제품 설명 작성 “당신이 혁신적인 스마트 홈 장치를 판매하는 임무를 맡은 카피라이터라고 상상해 보십시오. 제품의 기능을 강조할 뿐만 아니라 잠재 구매자의 감정에도 호소하는 설득력 있는 제품 설명을 작성하세요.” 미스터리한 오프닝 만들기 “범죄 현장에서 수수께끼 같은 단서를 발견한 형사가 등장하는 매력적인 오프닝 장면으로 미스터리 소설을 시작하세요. 긴장감을 조성하고 독자가 진실을 밝혀내고 싶어하게 만드세요.” 외계 배경 묘사하기 “독특한 풍경과 생물이 있는 외계 행성으로 독자를 안내하세요. 경이로움과 매혹을 불러일으킬 수 있는 묘사적인 언어를 사용하세요. 이 외계 환경에서 탐험가들은 어떤 도전에 직면할 수 있을까요?” 실패에 대한 개인적인 성찰 쓰기 “개인적인 실패나 좌절을 되돌아보고 그 경험에서 얻은 교훈을 설명하세요. 이 도전을 극복한 것이 여러분의 성격을 어떻게 형성하고 앞으로의 노력에 대한 접근 방식에 어떤 영향을 미쳤는지 공유하세요.” 역사적인 대화 만들기 “실제 만난 적이 없는 두 역사적 인물이 대화를 나눈다고 상상해 보세요. 알베르트 아인슈타인이 클레오파트라와 물리학에 대해 토론하거나 셰익스피어가 스티브 잡스와 문학에 대해 토론하는 장면이 될 수 있습니다. 흥미롭고 역사적으로 그럴듯한 대화를 만들어 보세요.” 여행 블로그 항목 만들기 “이국적인 장소로 떠나는 가상의 여행에 대한 매력적인 여행 블로그 글을 작성하세요. 마주친 광경, 소리, 경험을 묘사하고, 독자가 여러분과 함께 있는 듯한 느낌을 받을 수 있도록 독특한 글쓰기 스타일을 불어넣으세요.” 미래 지향적인 기술 피치 개발 “50년 후를 배경으로 획기적인 기술 혁신을 소개하세요. 기술의 혜택, 사회에 미칠 잠재적 영향, 윤리적 고려 사항을 간략하게 설명하세요. 설득력 있고 생각을 자극할 수 있도록 작성하세요.” 회복탄력성에 관한 시 쓰기 “회복탄력성을 주제로 한 시를 써보세요. 도전이 어떻게 성장과 힘의 기회로 전환될 수 있는지 살펴보세요. 은유와 생생한 언어를 사용하여 회복탄력성의 본질을 전달하세요.” 2인칭으로 단편 스토리 작성하기 “주인공이 '나’인 단편 소설을 써보세요. 2인칭 시점을 사용하여 독자가 이야기에 몰입할 수 있도록 하세요. 이 독특한 시점이 스토리텔링 경험을 어떻게 향상시키는지 살펴보세요.” 결론 ChatGPT 프롬프트를 글쓰기 루틴에 통합하는 것은 실력을 향상시킬 수 있는 역동적이고 효과적인 방법입니다. 스타일을 개선하고, 어려움을 극복하고, 새로운 장르를 탐색하려는 경우 ChatGPT는 글쓰기 여정에서 소중한 조력자가 될 수 있습니다. 핵심은 꾸준한 연습과 ChatGPT 프롬프트가 열어줄 수 있는 방대한 가능성을 탐색하려는 의지라는 점을 잊지 마세요. 행복한 글쓰기!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"글쓰기","slug":"글쓰기","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0/"}]},{"title":"코딩을 위한 ChatGPT 프롬프트 가이드","slug":"chatgpt-16","date":"2024-02-27T06:18:53.000Z","updated":"2024-02-27T06:31:02.397Z","comments":true,"path":"2024/02/27/chatgpt-16/","link":"","permalink":"http://hgko1207.github.io/2024/02/27/chatgpt-16/","excerpt":"","text":"코딩 실력을 한 단계 업그레이드할 준비가 되셨나요? ChatGPT를 사용하면 프로그래밍을 새로운 차원으로 끌어올릴 수 있습니다. 초보자이든 숙련된 개발자이든 ChatGPT는 코딩 능력을 향상시키는 데 도움이 되는 다양한 프롬프트를 제공합니다. 이 글에서는 ChatGPT 프롬프트를 활용하여 코딩 실력을 향상시킬 수 있는 방법을 살펴봅니다. 코딩에 ChatGPT 프롬프트를 사용하는 이유는 무엇인가요? 학습 지원: ChatGPT 프롬프트는 새로운 프로그래밍 개념을 배울 때 유용한 지원을 제공합니다. 루프, 함수, 데이터 구조 등 어떤 개념을 다루든 ChatGPT는 설명과 예제를 제공하여 이해를 강화할 수 있습니다. 문제 해결: 코딩 문제가 막막하신가요? ChatGPT 프롬프트는 장애물을 극복하는 데 도움이 되는 새로운 관점과 대안적인 접근 방식을 제공합니다. 코드 품질: ChatGPT 프롬프트를 통해 코드를 보다 효율적이고 가독성 있으며 유지 관리하기 쉽도록 개선할 수 있습니다. 명명 규칙, 코드 구조 및 모범 사례에 대한 제안을 받을 수 있습니다. 아이디어 생성: 다음 프로젝트에 대한 영감이 필요하신가요? ChatGPT 프롬프트는 창의력을 자극하고 흥미로운 코딩 프로젝트를 제안할 수 있습니다. 코딩에 ChatGPT 프롬프트를 사용하는 방법 작업 지정: 코딩을 통해 달성하고자 하는 목표를 명확하게 정의하세요. 웹 애플리케이션 구축, 알고리즘 문제 해결, 새로운 언어 기능 학습 등 어떤 것이든 목표를 명확히 하세요. 프롬프트 작성: ChatGPT에 대한 명확하고 간결한 프롬프트를 작성하세요. 컨텍스트를 제공하고, 요구 사항을 명시하고, 코드에 대한 제약 조건이나 선호 사항을 간략하게 설명하세요. ChatGPT와 소통하기: 프롬프트를 제출하고 ChatGPT의 응답과 상호 작용하세요. 후속 질문을 하고, 설명을 요청하고, 제공된 안내에 만족할 때까지 반복하세요. 구현 및 반복: ChatGPT의 제안을 사용하여 코딩 프로세스에 정보를 제공하세요. 필요에 따라 ChatGPT의 피드백을 반영하여 코드를 작성하고 테스트하세요. 얻은 인사이트를 바탕으로 코드를 리팩터링하고 개선하세요. 반성하고 배우세요: ChatGPT를 사용한 코딩 경험을 되돌아보는 시간을 가져보세요. 무엇이 잘 작동했나요? 개선할 수 있는 점은 무엇인가요? 이 피드백을 통해 코딩 기술을 향상하고 ChatGPT 프롬프트 사용 방식을 개선하세요. 코딩을 위한 10개의 ChatGPT 프롬프트 프롬프트: “피보나치 수열을 계산하는 Python 프로그램을 작성하고 있습니다. 더 나은 성능을 위해 코드를 최적화하는 방법을 안내해 주시겠어요?” 프롬프트: “JavaScript 웹 애플리케이션을 개발 중인데 비동기 프로그래밍에 어려움을 겪고 있습니다. 비동기 연산을 보다 효과적으로 처리하기 위한 팁을 제공해 주시겠어요?” 프롬프트: “Java의 객체 지향 프로그래밍 개념을 이해하는 데 도움이 필요합니다. 상속, 다형성, 캡슐화를 명확히 이해할 수 있도록 설명과 예제를 제공해 주시겠어요?” 프롬프트: “Ruby on Rails에서 간단한 CRUD(생성, 읽기, 업데이트, 삭제) 애플리케이션을 빌드하고 싶습니다. 따라야 할 필수 단계와 모범 사례는 무엇인가요?” 프롬프트: “코딩 면접을 준비 중인데 알고리즘 문제에 대한 연습이 필요합니다. 몇 가지 코딩 문제를 제안하고 가능한 해결 방법을 안내해 주시겠어요?” 프롬프트: “Python으로 데이터 시각화를 배우고 싶습니다. 대화형 차트와 그래프를 만들기 위한 라이브러리와 리소스를 추천해 주시겠어요?” 프롬프트: “C++ 프로그램에서 버그를 해결하려고 하는데 어디서부터 시작해야 할지 모르겠어요. 오류의 잠재적 원인을 파악하고 효과적으로 디버깅하는 데 도움을 줄 수 있나요?” 프롬프트: “프런트엔드에서 백엔드 개발로 전환하려고 합니다. 두 역할 간의 주요 차이점은 무엇이며 어떤 기술을 중점적으로 개발해야 하나요?” 프롬프트: “Node.js로 RESTful API를 구축하고 있는데 일반적인 취약점으로부터 안전한지 확인하고 싶습니다. 인증 및 권한 부여 메커니즘 구현에 대해 안내해 주실 수 있나요?” 프롬프트: “코딩하는 동안 시간 관리에 어려움을 겪고 있습니다. 코딩 세션 중에 생산성을 향상하고 집중력을 유지할 수 있는 기술과 도구를 제안해 주시겠어요?” 결론 ChatGPT 프롬프트는 코딩 여정을 향상시키는 데 유용한 도구입니다. 학습 지원, 문제 해결 지원, 코드 품질 개선, 아이디어 생성 등 어떤 것이든 ChatGPT가 도와드릴 수 있습니다. ChatGPT 프롬프트를 효과적으로 활용하면 학습 속도를 높이고 자신감을 가지고 코딩 과제를 해결하며 코딩 기술을 지속적으로 향상시킬 수 있습니다. 기다릴 이유가 없죠? 지금 바로 ChatGPT 프롬프트를 살펴보고 개발자로서의 잠재력을 최대한 발휘하세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"개발자 도구","slug":"개발자-도구","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC/"}]},{"title":"AI 지배를 위한 경쟁: 컴퓨팅 비용 급증을 선도하는 Google과 Microsoft","slug":"ai-20","date":"2024-02-27T05:56:41.000Z","updated":"2024-02-27T06:03:09.317Z","comments":true,"path":"2024/02/27/ai-20/","link":"","permalink":"http://hgko1207.github.io/2024/02/27/ai-20/","excerpt":"","text":"끊임없이 진화하는 인공 지능(AI) 환경에서 두 기술 거대 기업이 최전선에 서서 컴퓨팅 비용이 치솟으면서 이 분야를 장악할 태세를 갖추고 있습니다. Google과 Microsoft는 방대한 리소스, 최첨단 연구, 전략적 투자를 통해 AI의 미래를 형성하기 위한 경쟁에서 리더로 자리매김하고 있습니다. AI 혁명 기업과 산업이 점차 AI를 운영에 통합함에 따라 강력한 컴퓨팅 리소스에 대한 수요가 급증했습니다. 자연어 처리부터 이미지 인식까지 복잡한 작업을 처리할 수 있는 정교한 AI 모델을 개발하려는 경쟁으로 인해 엄청난 컴퓨팅 성능이 필요하게 되었습니다. 이러한 수요로 인해 컴퓨팅 비용이 급증하게 되었고, 이는 어느 회사가 AI 분야에서 효과적으로 경쟁할 수 있는지 결정하는 데 중요한 요소가 되었습니다. Google의 AI 역량 AI 연구의 선구자인 Google은 획기적인 AI 기술 개발에 앞장서 왔습니다. DeepMind 및 TensorFlow와 같은 프로젝트를 통해 Google은 AI 분야를 발전시켰을 뿐만 아니라 최첨단 기계 학습 프레임워크의 표준을 설정했습니다. Google Cloud AI와 같은 회사의 클라우드 서비스는 기업이 자체 인프라를 관리하는 부담 없이 AI 기능을 활용할 수 있는 강력한 플랫폼을 제공합니다. Kaggle 및 Looker와 같은 회사를 포함한 Google의 전략적 인수는 강력한 AI 생태계를 육성하겠다는 의지를 보여줍니다. Google은 다양한 AI 인재와 기술을 활용하여 빠르게 진화하는 AI 환경에서 앞서 나갈 수 있는 위치를 확보하고 있습니다. Microsoft의 전체적인 접근 방식 Microsoft는 Azure AI 플랫폼을 통해 AI 개발에 대한 전체적인 접근 방식을 취했습니다. Microsoft는 클라우드 컴퓨팅 능력을 활용하여 포괄적인 AI 도구 및 서비스 제품군을 제공하여 모든 규모의 기업이 액세스할 수 있도록 합니다. Azure의 Cognitive Services와 Azure Machine Learning은 개발자가 정교한 AI 애플리케이션을 구축하고 AI 개발 및 채택을 민주화할 수 있도록 지원합니다. Microsoft의 GitHub 인수는 AI 커뮤니티 내 협업을 촉진하고 지식 공유 및 혁신 환경을 조성했습니다. 이러한 협업 정신은 Microsoft를 커뮤니티 중심 개발을 통해 AI 발전을 주도하는 핵심 플레이어로 자리매김하게 합니다. 급증하는 컴퓨팅 비용의 과제 AI 모델이 더욱 복잡해지고 데이터 세트가 더 커지면서 이러한 모델을 교육하고 배포하는 데 필요한 컴퓨팅 리소스가 급증합니다. AI 개발과 관련된 비용 증가는 많은 기업에게 상당한 장벽이 되며, 풍부한 자금과 강력한 인프라를 갖춘 기업을 선호합니다. Google과 Microsoft는 클라우드 컴퓨팅 플랫폼을 통해 치솟는 컴퓨팅 비용 문제를 해결할 수 있는 준비가 잘 되어 있습니다. 확장 가능하고 유연한 솔루션을 제공함으로써 이들 거대 기술 기업은 기업이 엄청난 비용 부담 없이 AI의 힘을 활용할 수 있도록 지원합니다. AI 지배의 미래 AI를 장악하기 위한 경쟁에서 Google과 Microsoft가 선두 주자로 등장하여 각각의 강점을 발휘합니다. Google의 혁신과 전략적 인수의 역사는 Google을 선구자로 자리매김하고 있지만 Microsoft의 포용적인 접근 방식과 커뮤니티 협업에 대한 헌신은 광범위하고 지속 가능한 AI 생태계를 육성합니다. 결론 컴퓨팅 비용이 계속해서 급증함에 따라 이러한 환경을 탐색하는 능력은 AI 혁명을 주도할 회사를 결정하는 데 중요한 요소가 됩니다. 광범위한 리소스와 미래 지향적인 전략을 갖춘 Google과 Microsoft는 AI의 미래를 형성하고 기술을 새로운 차원으로 끌어올리고 산업을 재정의하는 데 유리한 위치에 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Chatbot","slug":"Chatbot","permalink":"http://hgko1207.github.io/tags/Chatbot/"},{"name":"Bard","slug":"Bard","permalink":"http://hgko1207.github.io/tags/Bard/"},{"name":"Gemini","slug":"Gemini","permalink":"http://hgko1207.github.io/tags/Gemini/"},{"name":"Google Ai","slug":"Google-Ai","permalink":"http://hgko1207.github.io/tags/Google-Ai/"}]},{"title":"인플루언서 마케팅을 위한 ChatGPT 프롬프트","slug":"chatgpt-15","date":"2024-02-25T07:28:28.000Z","updated":"2024-02-27T05:09:00.524Z","comments":true,"path":"2024/02/25/chatgpt-15/","link":"","permalink":"http://hgko1207.github.io/2024/02/25/chatgpt-15/","excerpt":"","text":"끊임없이 진화하는 디지털 마케팅 환경에서 인플루언서 마케팅은 브랜드가 타겟 고객과 소통할 수 있는 강력한 도구로 부상했습니다. 경쟁이 치열한 온라인 공간에서 앞서 나가기 위해 노력하는 기업들이 늘어나면서 인플루언서 마케팅 전략에 인공지능(AI)을 통합하는 것이 판도를 바꾸고 있습니다. 주목할 만한 활용 사례 중 하나는 AI의 기능을 활용하여 창의성, 참여도 및 전반적인 캠페인 효과를 향상시키는 ChatGPT 프롬프트의 사용입니다. ChatGPT: 개요 OpenAI에서 개발한 ChatGPT는 GPT-3.5 아키텍처로 구동되는 최첨단 언어 모델입니다. 이 모델은 수신된 프롬프트를 기반으로 사람과 유사한 텍스트를 이해하고 생성할 수 있는 기능을 갖추고 있습니다. 이 다재다능한 도구는 다양한 분야에서 활용되고 있으며 인플루언서 마케팅도 예외는 아닙니다. ChatGPT 프롬프트가 인플루언서 마케팅을 향상시키는 방법 콘텐츠 아이디어 인플루언서 마케팅의 핵심 과제 중 하나는 타겟 청중의 공감을 불러일으키는 매력적인 콘텐츠를 지속적으로 생성하는 것입니다. ChatGPT 프롬프트는 창의적인 아이디어를 브레인스토밍하는 데 사용할 수 있어 인플루언서와 브랜드가 신선하고 혁신적인 콘텐츠 컨셉을 떠올릴 수 있도록 도와줍니다. 특정 테마, 트렌드 또는 제품 기능과 관련된 프롬프트를 입력함으로써 ChatGPT는 인플루언서가 팔로워를 사로잡는 콘텐츠를 만들도록 영감을 줄 수 있습니다. 프롬프트 예시: “천연 성분과 지속 가능성을 강조하는 스킨케어 브랜드에 대한 콘텐츠 아이디어를 생성하세요.” 청중 참여 ChatGPT는 인플루언서가 청중과 의미 있는 상호작용을 촉진하는 캡션, 댓글 및 응답을 작성하는 데 도움을 줄 수 있습니다. 브랜드의 어조와 메시지를 분석하여 개인화되고 진정성 있는 커뮤니케이션을 생성하여 참여도를 높이고 팔로워와의 관계를 강화할 수 있는 ChatGPT 프롬프트입니다. 프롬프트 예시: “친절하고 친근한 분위기를 유지하면서 신제품 출시에 대한 기대감을 표현하는 댓글을 작성하세요.” 해시태그 최적화 인플루언서 콘텐츠의 가시성을 높이려면 올바른 해시태그를 선택하는 것이 중요합니다. ChatGPT 프롬프트는 인플루언서가 관련성 있고 유행하는 해시태그 목록을 생성하여 게시물의 도달 범위를 극대화하는 데 도움을 줄 수 있습니다. 인플루언서는 캠페인 목표와 타겟 청중에 대한 정보를 입력하면 특정 요구 사항에 맞는 AI가 생성한 제안을 받을 수 있습니다. 프롬프트 예시: “초보자를 대상으로 새로운 운동 앱을 홍보하는 피트니스 인플루언서에게 인기 있는 틈새 해시태그를 제안하세요.” 브랜드 보이스 일관성 다양한 인플루언서와의 협업에서 일관된 브랜드 보이스를 유지하는 것은 브랜드 아이덴티티를 강화하는 데 필수적입니다. ChatGPT 프롬프트는 인플루언서가 자신의 커뮤니케이션 스타일을 브랜드의 가이드라인에 맞게 조정하여 다양한 콘텐츠 제작자 사이에서 일관성 있고 인지할 수 있는 존재감을 확보할 수 있도록 도와줍니다. 프롬프트 예시: “브랜드의 우아하고 세련된 이미지를 구현하는 동시에 제품의 다양성을 강조하는 패션 인플루언서를 위한 캡션을 작성하세요.” 결론 ChatGPT 프롬프트를 인플루언서 마케팅 전략에 통합하면 창의성, 참여도 및 효율성을 위한 새로운 가능성을 열 수 있습니다. 브랜드와 인플루언서는 AI의 힘을 활용하여 캠페인의 수준을 높이고, 청중과 더 깊이 소통하며, 역동적인 디지털 마케팅 세계에서 앞서 나갈 수 있습니다. 기술이 계속 발전함에 따라 AI와 인플루언서 마케팅의 협업은 더욱 진화하여 온라인 영역에서 혁신과 성공을 위한 더 많은 기회를 제공할 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"인플루언서","slug":"인플루언서","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A3%A8%EC%96%B8%EC%84%9C/"},{"name":"마케팅을 위한 ChatGPT","slug":"마케팅을-위한-ChatGPT","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85%EC%9D%84-%EC%9C%84%ED%95%9C-ChatGPT/"}]},{"title":"Bard는 이제 Gemini입니다.","slug":"ai-19","date":"2024-02-25T07:17:29.000Z","updated":"2024-02-26T05:53:30.607Z","comments":true,"path":"2024/02/25/ai-19/","link":"","permalink":"http://hgko1207.github.io/2024/02/25/ai-19/","excerpt":"","text":"2024년 2월 8일부로 Google의 AI 챗봇 Bard가 Gemini로 새롭게 태어났습니다. 이번 브랜드 변경은 Google의 AI 여정에서 새로운 장을 열며, 흥미로운 발전과 확장된 기능을 제공합니다. 이름에 담긴 의미는 무엇인가요? Bard에서 Gemini로의 전환은 더욱 다재다능하고 다방면에 걸친 AI 도구를 개발하려는 Google의 야망을 반영합니다. Gemini는 소통과 이중성과 관련된 신화 속 쌍둥이자리로, 현재 제공되는 두 가지 핵심 경험을 상징합니다. Gemini Pro(이전 Bard): 이 무료 버전은 질문에 답하고, 텍스트 형식을 생성하고, 40개 이상의 언어로 언어를 번역할 수 있는 친숙한 대화형 AI 환경을 유지합니다. Gemini Advanced: 이 유료 구독 서비스는 Google One AI Premium 요금제의 일부로 개인화된 맞춤 콘텐츠 제작, 고급 코딩 지원, 심층 연구 요약과 같은 향상된 기능을 이용할 수 있습니다. 브랜드 변경 그 이상: 새로운 기능 및 모바일 액세스 Gemini의 공개와 함께 두 가지 주요 기능이 출시되었습니다. Gemini 모바일 앱: Android 및 iOS에서 사용할 수 있는 이 앱을 통해 사용자는 이동 중에도 Gemini와 상호 작용할 수 있으며, 그 기능에 편리하게 액세스할 수 있습니다. Gemini Ultra 1.0: 이 업그레이드 모델은 Gemini Pro와 Advanced를 모두 지원하며 정확성, 유창성 및 전반적인 성능이 향상되었습니다. Gemini의 미래: 통합 및 다중 모드 Gemini에 대한 Google의 비전은 현재의 기능을 뛰어넘습니다. 곧 Gemini는 Gmail, Docs, Sheets, Slides 등 다양한 Google 제품에 통합되어 사용자의 워크플로 내에서 바로 AI 기반 지원을 제공할 예정입니다. 또한 향후 계획에는 Gemini의 언어 기능을 확장하고 텍스트 기반 커뮤니케이션을 넘어선 다중 모드 상호작용을 모색하는 것도 포함됩니다. 사용자에게 어떤 의미가 있나요? Gemini로의 전환은 사용자에게 몇 가지 이점을 제공합니다. 향상된 기능: 무료 사용자는 업그레이드된 Ultra 1.0 모델의 혜택을 누릴 수 있으며, 유료 가입자는 Gemini Advanced와 같은 강력한 새 기능에 액세스할 수 있습니다. 모바일 편의성: 모바일 앱을 통해 이동 중에도 Gemini의 기능에 액세스할 수 있습니다. 더욱 긴밀한 통합: 향후 Google 제품과의 통합을 통해 다양한 작업에서 원활하고 개인화된 AI 경험을 약속합니다. 결론 Bard에서 Gemini로의 전환은 포괄적이고 접근성이 뛰어난 AI 도구를 개발하기 위한 Google의 노력을 의미합니다. 확장된 기능, 모바일 지원, 향후 통합 계획을 통해 Gemini는 정보, 창의성, 생산성을 위한 필수적인 동반자가 되는 것을 목표로 하고 있습니다. Gemini가 어떻게 진화하고 AI 상호작용의 미래를 만들어갈지 지켜보는 것도 흥미로운 일이 될 것입니다. https://gemini.google.com/?hl=ko","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Chatbot","slug":"Chatbot","permalink":"http://hgko1207.github.io/tags/Chatbot/"},{"name":"Bard","slug":"Bard","permalink":"http://hgko1207.github.io/tags/Bard/"},{"name":"Gemini","slug":"Gemini","permalink":"http://hgko1207.github.io/tags/Gemini/"},{"name":"Google Ai","slug":"Google-Ai","permalink":"http://hgko1207.github.io/tags/Google-Ai/"}]},{"title":"처음부터 끝까지 빠르고 최적화된 블로그 작성을 위한 50가지 똑똑한 ChatGPT 프롬프트","slug":"chatgpt-14","date":"2024-02-23T14:17:28.000Z","updated":"2024-02-25T07:01:14.740Z","comments":true,"path":"2024/02/23/chatgpt-14/","link":"","permalink":"http://hgko1207.github.io/2024/02/23/chatgpt-14/","excerpt":"","text":"ChatGPT는 블로그 글쓰기 프로세스의 일부를 간소화하고 자동화하는 데 매우 유용한 도구입니다. 적절한 프롬프트를 사용하면 키워드 조사부터 완성된 게시물을 게시하는 데까지 도움을 받을 수 있습니다. 다음은 아이디어 구상부터 홍보까지 블로그 게시물 작성의 모든 단계를 다루는 50가지 Clever ChatGPT 프롬프트입니다… 조사 시간을 절약하고 싶거나 동적 콘텐츠에 대한 아이디어를 생성하고 싶을 때, 이 프롬프트는 ChatGPT가 블로그 작성 워크플로우를 어떻게 향상시킬 수 있는지 보여줍니다. 50개의 ChatGPT 프롬프트 콘텐츠 작성을 위한 50개의 ChatGPT 프롬프트는 다음과 같습니다. [틈새/산업]에 관한 10개의 잠재적인 블로그 게시물 주제 목록과 각 주제에 대한 키워드 아이디어 및 검색량 데이터를 알려주세요. 이 시드 키워드 &quot;[키워드]&quot;를 블로그 게시물에 대한 20개의 관련 롱테일 키워드 아이디어로 구성된 클러스터 맵으로 확장할 수 있도록 도와주세요. 키워드 &quot;[키워드]&quot;를 타겟팅하는 블로그 게시물의 헤더와 부헤더가 포함된 개요 구조를 제안해 주세요. 관심을 끌 수 있는 [주제]에 대한 블로그 글의 소개 단락을 제시해 주세요. 블로그 글을 시작하기 위해 [키워드]의 주제를 요약하는 100단어 소개 섹션을 작성하세요. 키워드 [키워드]에 대한 [주제]에 대한 블로그 글을 최적화하기 위한 5가지 SEO 팁을 알려주세요. [키워드] 키워드에 최적화된 60자 미만의 메타 제목을 생성합니다. [키워드] 키워드에 최적화된 150~160자의 메타 설명을 입력합니다. 글머리 기호 목록 형식으로 [주제]에 대한 실행 가능한 팁 5가지를 블로그 게시물 섹션에 작성하세요. 더 나은 설명을 위해 블로그 게시물에 사용할 수 있는 [주제]와 관련된 예시/사례 연구 2개를 제시하세요. 댓글 섹션에서 독자의 참여를 유도할 수 있는 [주제]와 관련된 사려 깊은 질문 3개를 작성하세요. 이 연구 결과를 2문장으로 의역하여 [주제]에 대한 블로그 게시물에 통계로 인용하세요: [연구 세부 정보 삽입]. [주제]에 대한 블로그 글을 효과적으로 마무리할 수 있는 100~150단어의 결론을 작성하세요. [주제]에 대한 블로그 게시물에 이미지 캡션과 함께 포함할 수 있는 관련 이미지 5개를 생각해 보세요. SEO를 위해 H2 및 H3 헤더를 사용하여 [주제]에 대한 블로그 게시물 개요를 구성하는 데 도움을 주세요. [주제]에 대한 블로그 게시물에 대한 200단어 샘플 소개를 제공해 주세요. 콘텐츠를 풍부하게 하기 위해 [주제]에 대한 블로그에서 링크할 수 있는 관련 게시물 또는 리소스 5개를 알려주세요. [주제]와 관련된 URL [URL 삽입]에 대한 SEO 친화적인 앵커 텍스트 링크를 생성하세요. [주제]에 대한 새 블로그 게시물을 홍보하기 위한 트윗 1개를 작성합니다. 소셜 미디어에서 [주제]에 대한 블로그 글을 공유할 때 사용할 관련 해시태그 3개를 입력합니다. 블로그 글의 [키워드] 키워드에 최적화된 6~8개의 단어로 작업 제목을 작성합니다. [주제]에 대한 블로그 글 제목과 관련된 키워드 및 구문 5~10개의 목록을 알려주세요. 블로그 게시물에 대해 A/B 테스트할 수 있는 [키워드]에 최적화된 3개의 다른 메타 제목을 제안해 주세요. 블로그 글을 열 때 [주제]와 관련된 1~2문장의 짧은 소개 훅을 제공합니다. 블로그 글의 [주제]에 대한 배경 지식을 제공하는 50~100단어 소개 문단을 작성하세요. 이 블로그 섹션에 [주제 세부 정보]에 대한 H2 부제목과 단락을 작성하세요. [하위 주제]에 대한 3개의 팁을 제공하는 150단어 블로그 섹션을 생성하고 각 팁의 헤더를 굵은 글씨로 표시하세요. 블로그 게시물에 인용할 [주제]에 대한 관련 연구 조사를 요약하는 2개의 단락을 작성합니다. [주제]와 관련된 [개념]의 실제 사례를 100단어 단락으로 작성합니다. [주제]에 대한 일반적인 질문 2가지와 100단어 답변으로 FAQ 섹션을 작성하세요. 블로그에서 [제품/서비스]의 이점을 설명하는 2개의 제목과 단락 요약을 작성하세요. 인용문으로 사용할 수 있는 [주제]와 관련된 [업계] 전문가의 인용문을 작성하세요. [주제]에 대한 이 점[삽입 포인트]을 자세히 설명하는 H3 하위 헤더와 간단한 단락을 작성합니다. [주제]에 대한 블로그 글의 핵심 내용을 요약하는 100~150단어짜리 결론 단락을 작성합니다. 블로그 글의 마지막에 독자가 [원하는 행동]을 하도록 유도하는 콜투액션 문장을 작성합니다. 내 사이트의 다른 관련 게시물로 연결되는 1~2개의 문장을 교차 링크하는 P.S. 섹션을 작성합니다. [주제]에 대한 블로그 글에서 SEO에 사용할 5~10개의 관련 태그 목록을 생성합니다. [주제]에 대한 블로그 게시물을 최적화하려면 5개의 메타 태그 초점 핵심 문구를 제공하세요. 티스토리에서 [주제] 블로그 게시물을 공유하기에 적합한 3~5개의 해시태그를 제안하세요. 인스타그램에서 [주제]에 대한 블로그 게시물을 홍보할 때 사용할 수 있는 5~7개의 해시태그를 제시하세요. 소셜 공유 캡션으로 이 블로그 게시물의 핵심 정보를 요약하는 1~2개의 문장을 작성합니다. [주제] 블로그 게시물로 연결되는 핀의 SEO에 최적화된 60자 미만의 Pinterest 제목을 작성합니다. [주제]에 대한 핀의 요점을 요약한 250자 이내의 Pinterest 이미지 설명을 작성합니다. 트위터에서 [주제] 블로그 게시물을 홍보하기 위해 280자 미만의 트윗을 작성합니다. [주제] 블로그 게시글을 공유하고 토론하기 위해 300자 이내의 LinkedIn 게시물 제목과 요약을 작성합니다. [주제]에 대한 블로그 글의 핵심 내용을 강조하는 Facebook 게시물 설명을 작성합니다. 소셜 미디어 게시물에 대한 [주제] 블로그 글의 요점을 요약한 4~5개의 글머리 기호로 작성하세요. [주제] 블로그 게시물에 대한 클릭 유도를 위해 눈길을 사로잡는 160자 미만의 페이스북/인스타그램 캡션을 제공하세요. 소셜 공유에 사용할 [주제] 블로그 글에서 발췌한 1~2문장의 짧은 인용문을 제안합니다. [주제] 블로그 게시물의 공개율을 높일 수 있는 이메일 제목을 최대 50자까지 작성하세요. 마무리 이 50개의 프롬프트를 통해 이제 블로그 게시물 아이디어, 작성 도움말, 제목/인트로/결론, SEO 팁, 서식 지정, 소셜 미디어 공유 사본 등을 위해 ChatGPT를 활용할 수 있는 다양한 명령어를 갖추게 되었습니다. ChatGPT는 블로그 프로세스의 모든 단계를 자동화하고 개선할 수 있습니다. 이러한 프롬프트를 통합하여 블로그 작업 흐름이 더욱 효율적이고 창의적으로 바뀌는 것을 지켜보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"콘텐츠 작성 프롬프트","slug":"콘텐츠-작성-프롬프트","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0-%EC%9E%91%EC%84%B1-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"글쓰기를 위한 ChatGPT","slug":"글쓰기를-위한-ChatGPT","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0%EB%A5%BC-%EC%9C%84%ED%95%9C-ChatGPT/"}]},{"title":"2024년 최고의 ChatGPT 프롬프트 가이드","slug":"chatgpt-13","date":"2024-02-23T02:06:33.000Z","updated":"2024-02-23T14:30:39.137Z","comments":true,"path":"2024/02/23/chatgpt-13/","link":"","permalink":"http://hgko1207.github.io/2024/02/23/chatgpt-13/","excerpt":"","text":"ChatGPT에 대한 모든 필수 정보를 알아보고 2024년에 최대한의 성공을 거두기 위해 효과적으로 활용하는 방법을 알아보세요. 이 가이드는 프롬프트 기술, ChatGPT 사용 모범 사례, 영업, 마케팅, 웹 개발, 데이터 과학 등과 같은 다양한 직업을 위한 사용자 지정 프롬프트 등 ChatGPT에 대해 배우고 알아야 할 모든 것을 안내합니다. 목차 좋은 프롬프트와 나쁜 프롬프트 ChatGPT 사용 모범 사례 콘텐츠 작성을 위한 프롬프트 마케팅을 위한 프롬프트 웹 개발을 위한 프롬프트 영업을 위한 프롬프트 데이터 과학을 위한 프롬프트 고객 성공을 위한 프롬프트 좋은 프롬프트와 나쁜 프롬프트 여기에서는 ChatGPT와 같은 LLM의 응답 품질에 영향을 미칠 수 있는 좋은 프롬프트와 나쁜 프롬프트의 몇 가지 예를 보여드렸습니다. 기술 문의 잘못된 프롬프트: EV에 대해 알려주세요. 좋은 프롬프트: 지난 2년 동안 전기 자동차 기술에서 어떤 획기적인 발전이 있었나요? 비즈니스 인사이트 잘못된 프롬프트: 매출을 늘리려면 어떻게 해야 하나요? 좋은 프롬프트: 경쟁이 치열한 시장에서 새로운 기술 제품을 위한 입증된 시장 진입 전략은 무엇인가요? 역사적 분석 잘못된 프롬프트: 역사에 대해 알려주세요. 좋은 프롬프트: 1차 세계대전 이후 베르사유 조약의 경제적 영향을 분석해 주시겠어요? ChatGPT 사용 모범 사례 다음은 LLM 도구와 ChatGPT를 효과적으로 사용하고 이를 최대한 활용하기 위한 몇 가지 모범 사례와 가이드라인입니다. 명확하고 구체적으로 전달하세요: 요청이나 질문을 명확하게 전달하세요. 지침으로 시작하세요: 모델에 원하는 동작 방식을 알려주세요. 맥락 제공: 모델에게 주제에 대한 관련 정보를 제공합니다. 완전한 문장을 사용하세요: 모델이 이해할 수 있도록 프롬프트를 구성합니다. 이전 답안 사용: 모델의 이전 응답을 참조합니다. 실험 및 반복: 다양한 문구 또는 변형으로 실험해 봅니다. 명시적인 지시 사용: 프롬프트에 지침을 명확하게 명시합니다. 응답 길이 제한하기: 모델에게 구체적인 요점을 제공하도록 요청합니다. 개선 및 검토: 보다 정확한 답변을 위해 프롬프트를 조정합니다. 검증 및 빠른 확인: 정보가 정확한지 확인합니다. 콘텐츠 작성을 위한 프롬프트 [주제]에 대한 블로그 게시물의 소개를 작성합니다. YouTube 채널용 [주제]에 대한 단계별 튜토리얼 동영상을 개발합니다. [키워드]를 포함하여 [숫자] 개의 블로그 게시물 아이디어로 콘텐츠 캘린더를 작성합니다. [주제]에 대한 블로그 게시물에 대한 10가지 자극적인 질문 목록을 생성합니다. [제품] 출시 전에 시장 조사를 수행하기 위한 체크리스트를 만듭니다. [주제]에 대한 백서를 작성합니다. [단어 수] 이하로 작성하세요. [주제]에 대한 팁과 요령을 제공하는 일련의 이메일 뉴스레터를 작성합니다. 동일한 [품사]로 시작하도록 이 글머리 기호 목록을 다시 작성하세요. 이 단락을 글머리 기호 목록으로 다시 작성하세요. 마케팅을 위한 프롬프트 이 [여기에 사본 삽입]을 사용하여 150단어 미만의 Linkedin 게시물을 작성합니다. 이 [사본 삽입]을 사용하여 [숫자] 슬라이드로 Instagram carousel을 만듭니다. [키워드]를 타겟팅하는 캠페인에 대한 설득력 있는 Google 광고 문구를 작성하세요. 우리에게서 구매하지 않은 [회사]의 고객에게 이메일을 작성하세요. [여기에 자료 삽입]에 대한 [숫자]개의 CTA 메시지를 작성하세요. [정보]를 사용하여 [제품 또는 서비스 이름]에 대한 60초 분량의 YouTube 스크립트를 작성합니다. [주제]에 대한 [회사를 위한 유튜브 동영상 아이디어]를 생각해 보세요. 아래 데이터를 사례 연구로 전환하세요: (1) 과제 (2) 해결책 (3) 결과. [제품 또는 서비스] 기간 한정 할인에 대한 랜딩 페이지 카피를 작성하세요. 웹 개발을 위한 프롬프트 초보자를 위한 웹 개발 강좌의 주제 [수]개를 나열하세요. 웹 애플리케이션에 애니메이션 효과를 통합하기 위한 [숫자]개의 창의적인 아이디어를 제공하세요. 웹 개발 프로젝트에 맞는 테스트 프로세스를 위한 순서도를 개발하세요. 웹 기반 게임 개발 과정을 위한 [숫자]개의 매력적인 아이디어를 제안하세요. 웹 개발에 SOLID 원칙을 통합할 수 있는 [숫자]개의 아이디어를 제시하세요. 웹 애플리케이션에서 사용자 인증을 처리하기 위한 [숫자]개의 기술을 제안하세요. 웹 애플리케이션의 머신러닝 사용 사례 [숫자]개를 설명하세요. 웹 개발 워크숍에 관한 [숫자]개의 관련 주제를 적어보세요. 브레인스토밍 조력자 역할을 하며 코딩 과제에 대한 아이디어를 [숫자]개 제안하세요. 사용자 인터페이스 구성 요소에 대한 고유한 아이디어를 [숫자]개 제공할 수 있나요? 영업을 위한 프롬프트 [정보]를 사용하여 [제품/서비스]에 대한 설득력 있는 영업 프레젠테이션을 개발하세요. 당사의 [제품/서비스]에 관심을 보인 리드에게 후속 이메일을 작성하세요. 우리 [틈새] 회사의 마케팅 캠페인에 대한 설득력 있는 영업 스크립트를 작성하세요. [불만 사항 목록]을 사용하여 잠재 고객을 위한 맞춤형 제안서를 개발하세요. [우려 사항]을 극복하기 위한 이의 제기 처리 기술 목록을 생성하세요. 파트너십 육성을 위한 콜드 이메일 시퀀스를 작성합니다. [제품/서비스]의 기존 고객을 위한 추천 프로그램을 개발합니다. [사양]을 사용하여 [제품/서비스]에 대한 영업 프레젠테이션 자료를 작성합니다. [데이터]를 사용하여 [제품/서비스]에 대한 경쟁 분석 보고서를 개발하세요. 데이터 과학에 위한 프롬프트 데이터 과학자가 되어 [데이터]를 기반으로 저를 위한 머신 러닝 모델을 구축하세요. 이 [지침]을 사용하여 자동 머신 러닝(AutoML) 봇으로 작동하세요. [모델 이름]을 훈련하는 데 도움을 줄 수 있나요? Python 코드를 제공해 주세요. [매개변수]를 포함하여 [주제] 데이터 시각화 및 탐색을 위한 코드를 작성하세요. 이 [데이터]를 기반으로 [숫자] 행과 [숫자] 열이 있는 CVS 데이터 집합을 만드세요. 이메일 주소와 일치하는 Python 정규식을 작성합니다. 과거 데이터를 기반으로 [제목]을 예측하는 머신 러닝 모델을 구축합니다. [메트릭(metrics)]을 사용하여 고객 이탈 예측 모델에 대한 기능 엔지니어링을 수행하세요. 자연어 처리(NLP) 모델을 구현하는 방법을 알려주세요. [숫자] 행과 [숫자] 열이 있는 감정 분석용 데이터 집합이 필요합니다. 고객 성공을 위한 프롬프트 [불만]과 같은 불만 처리에 대한 단계별 가이드를 개발하세요. [문의]와 관련하여 고객에게 이메일 작성하기 청구 문의를 처리하기 위한 고객 서비스 스크립트를 만듭니다. 개인화된 고객 경험을 만들기 위한 [숫자] 가이드라인을 개발합니다. [고객 이름]의 [문제] 해결을 돕기 위한 실시간 채팅 응답을 작성합니다. 고객 피드백이나 리뷰에 응답할 수 있는 템플릿을 만듭니다. [데이터]를 사용하여 일반적인 질문과 우려 사항을 다루는 [숫자] FAQ를 작성합니다. 당사 [제품/서비스]에 대한 고객 불만 사항에 대한 소셜 미디어 응답을 작성하세요. [업계] 내 [회사명]에 대한 선제적인 고객 지원을 위한 템플릿을 작성하세요. 고객에게 적합한 제품 제안을 파악하고 제시하는 등 효과적인 교차 판매 및 상향 판매 기술에 대한 가이드를 개발하세요. 결론 이 글에서 ChatGPT를 마스터하고 매일 사용하는 방법에 대해 알아보는 데 도움이 되셨기를 바랍니다. 요약하자면, ChatGPT는 일상 생활에서 생산성과 효율성을 높이고자 하는 사람들에게 매우 유용한 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"Technology","slug":"Technology","permalink":"http://hgko1207.github.io/tags/Technology/"},{"name":"생산력","slug":"생산력","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%82%B0%EB%A0%A5/"}]},{"title":"유럽에서 공개된 Google의 최신 검색 기능 살펴보기","slug":"info-9","date":"2024-02-20T02:06:56.000Z","updated":"2024-02-22T07:48:33.034Z","comments":true,"path":"2024/02/20/info-9/","link":"","permalink":"http://hgko1207.github.io/2024/02/20/info-9/","excerpt":"","text":"유비쿼터스 검색 엔진의 선두주자인 Google이 유럽에서 새로운 검색 기능을 도입하여 사용자 경험을 향상시키는 데 다시 한 번 한 걸음 더 나아갔습니다. 이러한 움직임은 혁신의 선두에 서서 사용자에게 더욱 개인화되고 효율적인 검색 결과를 제공하려는 Google의 노력을 강조합니다. 1. 향상된 검색 필터 Google의 최신 업데이트의 주요 특징 중 하나는 검색 필터의 정교화입니다. 이제 유럽 사용자는 향상된 필터를 활용하여 검색어를 더욱 세밀하게 제어할 수 있습니다. 이 기능을 통해 사용자는 다양한 매개변수를 기반으로 검색 결과의 범위를 좁힐 수 있어 특정 정보를 빠르고 효율적으로 찾을 수 있습니다. 2. 상황 인식 검색 제안 Google은 인공 지능을 활용하여 상황 인식 검색 제안을 제공합니다. 즉, 검색 엔진이 사용자의 검색 기록, 위치 및 선호도를 고려하여 보다 관련성 높고 맞춤화된 검색 결과를 제공합니다. 이 기능은 검색 프로세스를 간소화하여 사용자가 최소한의 노력으로 원하는 정보를 정확하게 제공하는 것을 목표로 합니다. 3. 다국어 검색 기능 유럽의 언어적 다양성을 인식한 Google은 여러 언어를 더 잘 이해하고 수용할 수 있도록 검색 기능을 업그레이드했습니다. 이제 사용자는 선호하는 언어로 검색을 수행할 수 있으며, Google은 언어적으로 정확하고 문맥과 연관성이 있는 결과를 제공합니다. 이러한 개선은 보다 포용적이고 사용자 친화적인 검색 환경을 향한 중요한 진전입니다. 4. 시각적 검색 통합 시각적 검색은 온라인 탐색의 필수적인 부분이 되었으며, Google은 이러한 트렌드를 검색 플랫폼에 통합하고 있습니다. 이제 유럽 사용자는 검색창에서 바로 시각적 검색을 수행할 수 있어 텍스트가 아닌 이미지를 사용하여 정보를 검색할 수 있습니다. 이 기능은 시각적 또는 제품 기반 정보를 찾는 사용자에게 새로운 가능성을 열어줍니다. 5. 실시간 정보 업데이트 정보가 끊임없이 진화하는 세상에서 Google은 검색 결과에 실시간 업데이트를 도입합니다. 이제 사용자는 검색 인터페이스 내에서 이벤트, 뉴스, 트렌드에 대한 최신 정보를 바로 받아볼 수 있습니다. 이를 통해 사용자는 가장 최신의 관련성 높은 콘텐츠에 대한 정보를 지속적으로 확인할 수 있습니다. 6. 향상된 지역 검색 경험 주변 서비스나 업체를 찾는 사용자를 위해 Google의 새로운 검색 기능은 향상된 지역 검색 환경을 제공합니다. 향상된 위치 기반 검색 결과는 사용자에게 비즈니스, 레스토랑 및 기타 지역 서비스에 대한 보다 정확하고 시의적절한 정보를 제공합니다. 결론 결론적으로, Google이 유럽에 새로운 검색 기능을 출시하는 것은 이 지역 사용자의 변화하는 요구를 충족하기 위한 노력을 반영한 것입니다. 이러한 개선 사항은 검색 프로세스를 더욱 효율적으로 만들 뿐만 아니라 더욱 개인화된 사용자 중심의 온라인 경험을 제공하는 데 기여합니다. 기술이 계속 발전함에 따라 이러한 기능이 온라인에서 정보를 탐색하고 액세스하는 방식을 어떻게 변화시킬지 기대가 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"Google","slug":"Google","permalink":"http://hgko1207.github.io/tags/Google/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"데이터 과학","slug":"데이터-과학","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%BC%ED%95%99/"},{"name":"최신 검색 기능","slug":"최신-검색-기능","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%8B%A0-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%8A%A5/"}]},{"title":"Sora - 텍스트로 동영상 만들기","slug":"ai-18","date":"2024-02-20T01:51:47.000Z","updated":"2024-02-20T02:04:37.395Z","comments":true,"path":"2024/02/20/ai-18/","link":"","permalink":"http://hgko1207.github.io/2024/02/20/ai-18/","excerpt":"","text":"OpenAI는 시각적 미디어와 상호 작용하는 방식을 변화시킬 혁신적인 도구인 &quot;Sora&quot;를 공개했습니다. 이 획기적인 text-to-video 모델은 단순히 이미지를 생성하는 데 그치지 않고, 짧은 설명 프롬프트를 통해 복잡한 내러티브를 엮어 이미지에 생명을 불어넣습니다. '하늘’을 뜻하는 일본어 이름처럼, Sora의 잠재력은 상상의 나래를 펼칠 수 있는 한도까지 뻗어 있습니다. 단어로 그림 그리기 신중하게 선택한 몇 개의 단어만으로 생동감 넘치는 장면을 그려낸다고 상상해 보세요. Sora와 함께라면 그 꿈이 현실이 됩니다. 눈 덮인 산맥 속에 자리 잡은 웅장한 성, 네온 불빛 아래 번화한 도시 풍경, 햇살이 비치는 초원에서 나비를 쫓는 장난기 가득한 개를 묘사하면 Sora가 한 프레임 한 프레임 현실로 그려줍니다. 텍스트 명령을 이해하고 사실적인 애니메이션으로 변환하는 능력은 무궁무진한 가능성을 열어줍니다. 정적 이미지 그 이상 하지만 Sora의 기능은 단순한 이미지 생성에 그치지 않습니다. 이 모델은 움직임을 잘 활용하여 놀라운 유동성으로 움직임의 본질을 포착합니다. 성층권으로 발사되는 로켓을 목격하거나 폭포의 매혹적인 흐름에 매료되는 장면을 모두 말의 힘을 통해 생생하게 구현할 수 있습니다. 이 역동적인 스토리텔링 기능은 이전에는 상상할 수 없었던 수준의 창의적인 표현을 제공함으로써 Sora를 차별화합니다. 다양한 응용 분야 Sora의 잠재적 활용 분야는 광범위하고 계속 확장되고 있습니다. 영화 제작과 애니메이션부터 교육 및 과학 시각화에 이르기까지 이 기술은 소통과 이해를 혁신할 수 있는 잠재력을 지니고 있습니다. 매력적인 교육용 동영상을 제작하거나 몰입형 제품 데모를 제작하거나 개인화된 비디오 메시지를 디자인하는 등 그 가능성은 정말 무궁무진합니다. 텍스트와 현실 사이의 격차 해소 하지만 아무리 강력한 도구라도 고려해야 할 사항이 있습니다. Sora가 계속 진화함에 따라 책임감 있는 개발과 사용이 중요합니다. 잠재적인 편견을 해결하고, 오용의 위험을 완화하며, 윤리적 애플리케이션을 장려하는 것은 Sora의 힘을 선하게 활용하는 데 있어 필수적입니다. 새로운 시대의 여명 OpenAI의 'Sora’는 인공 지능 분야에서 중요한 도약을 의미합니다. 텍스트와 현실 사이의 격차를 해소함으로써 완전히 새로운 방식으로 자신을 표현하고 세상을 탐험할 수 있게 해줍니다. 이미지의 영역으로 더 깊이 들어가면서 책임감과 상상력을 가지고 새롭게 발견한 창의력을 발휘하여 더욱 활기차고 표현력이 풍부한 미래를 향해 나아갑시다. https://openai.com/sora","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"},{"name":"Text To Video","slug":"Text-To-Video","permalink":"http://hgko1207.github.io/tags/Text-To-Video/"},{"name":"AI 기술","slug":"AI-기술","permalink":"http://hgko1207.github.io/tags/AI-%EA%B8%B0%EC%88%A0/"},{"name":"Sora","slug":"Sora","permalink":"http://hgko1207.github.io/tags/Sora/"}]},{"title":"골프 선수를 위한 ChatGPT 프롬프트","slug":"chatgpt-12","date":"2024-02-18T13:59:25.000Z","updated":"2024-02-21T06:27:18.161Z","comments":true,"path":"2024/02/18/chatgpt-12/","link":"","permalink":"http://hgko1207.github.io/2024/02/18/chatgpt-12/","excerpt":"","text":"골프는 정확성, 전략, 지속적인 개선이 필요한 스포츠입니다. 노련한 골퍼든 이제 막 골프를 시작한 골퍼든, 기술을 연마하고 게임에 대한 이해를 높일 수 있는 방법을 찾는 것은 매우 중요합니다. 오늘날의 디지털 시대에는 골퍼의 실력 향상에 도움이 되는 다양한 도구가 등장하고 있으며, 그중에서도 ChatGPT가 인기를 얻고 있습니다. OpenAI에서 개발한 최첨단 언어 모델인 ChatGPT는 단순히 질문에 답하거나 텍스트를 생성하기 위한 것이 아닙니다. 또한 자신의 게임을 향상시키고자 하는 골퍼들에게도 유용한 리소스가 될 수 있습니다. 맞춤형 프롬프트와 질문을 통해 ChatGPT는 골퍼가 코스에서 뛰어난 실력을 발휘할 수 있도록 인사이트와 팁, 정신적 지원까지 제공할 수 있습니다. 다음은 골프 선수가 ChatGPT 프롬프트를 활용하여 경기력을 향상시킬 수 있는 몇 가지 방법입니다. 전략 및 코스 관리 골프 코스를 효과적으로 탐색하려면 신중한 계획과 전략적 의사결정이 필요합니다. ChatGPT는 골퍼가 코스 레이아웃을 분석하고, 현재 상황에 따라 최적의 샷 전략을 제안하며, 다양한 시나리오에 맞는 클럽 선택에 대해 조언할 수 있도록 도와줍니다. 코스 또는 특정 홀에 대한 구체적인 질문을 입력하면 플레이어는 성공 확률을 극대화할 수 있는 맞춤형 조언을 받을 수 있습니다. 스윙 분석 및 기술 개선 스윙을 개선하는 것은 모든 레벨의 골퍼들이 지속적으로 노력하는 부분입니다. ChatGPT는 자세, 그립, 정렬, 템포에 대한 팁을 제공하여 스윙 메커니즘에 대한 귀중한 통찰력을 제공할 수 있습니다. 플레이어는 자신의 스윙 문제를 설명하거나 분석용 동영상을 업로드하여 개인화된 피드백과 추천을 받아 기술을 개선할 수 있습니다. 이러한 대화형 접근 방식을 통해 골퍼는 약점을 보완하고 동작을 미세 조정하여 일관성과 정확성을 높일 수 있습니다. 정신적 게임 및 시각화 골프는 집중력, 자신감, 회복력을 필요로 하는 육체적인 게임인 동시에 정신적인 게임이기도 합니다. ChatGPT는 명상 연습, 시각화 기법, 동기 부여 메시지를 제공하여 플레이어가 승리하는 마음가짐을 기르는 데 도움을 줄 수 있습니다. 골퍼들은 긴장감 극복하기, 코스에 집중하기, 성공적인 샷 시각화하기 등의 주제에 대해 ChatGPT에 참여함으로써 정신력을 강화하고 압박감 속에서도 최고의 기량을 발휘할 수 있습니다. 규칙 및 에티켓 골프의 규칙과 에티켓을 이해하는 것은 원활하고 존중하는 플레이 경험을 위해 필수적입니다. ChatGPT는 규칙에 대한 궁금증을 해소하고 분쟁을 해결하거나 적절한 골프 에티켓을 배우는 데 유용한 참고 자료가 될 수 있습니다. 플레이어는 특정 규칙 시나리오에 대해 문의하거나 일반적인 에티켓 관행에 대한 안내를 받아 정직하고 예의 바르게 플레이할 수 있습니다. 체력 및 부상 예방 체력을 유지하고 부상을 예방하는 것은 골프 경기력과 수명에 있어 매우 중요한 요소입니다. ChatGPT는 골퍼가 최상의 컨디션을 유지할 수 있도록 맞춤형 운동 루틴, 스트레칭 운동, 부상 예방 팁을 제공할 수 있습니다. ChatGPT와 피트니스 목표, 기존 부상 또는 우려 사항을 논의함으로써 플레이어는 전반적인 건강과 웰빙을 지원하기 위한 맞춤형 추천을 받을 수 있습니다. 결론 골프 루틴에 ChatGPT 프롬프트를 통합하면 플레이어는 기술 개발, 전략 개선, 멘탈 컨디셔닝 및 전반적인 개선을 위한 귀중한 리소스를 얻을 수 있습니다. 인공지능의 힘을 활용하면 골퍼는 필요할 때마다 개인화된 안내와 지원을 받을 수 있어 코스에서의 퍼포먼스를 향상시키고 더욱 만족스러운 골프 경험을 즐길 수 있습니다. 기술이 계속 발전함에 따라 ChatGPT와 같은 혁신적인 도구를 도입하면 골퍼가 자신의 잠재력을 최대한 발휘하여 더 큰 성공을 거둘 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"골프","slug":"골프","permalink":"http://hgko1207.github.io/tags/%EA%B3%A8%ED%94%84/"},{"name":"골프 선수","slug":"골프-선수","permalink":"http://hgko1207.github.io/tags/%EA%B3%A8%ED%94%84-%EC%84%A0%EC%88%98/"}]},{"title":"2024년 최고의 AI 웹사이트 스크래퍼 7가지","slug":"ai-17","date":"2024-02-18T13:45:57.000Z","updated":"2024-02-18T13:58:19.871Z","comments":true,"path":"2024/02/18/ai-17/","link":"","permalink":"http://hgko1207.github.io/2024/02/18/ai-17/","excerpt":"","text":"온라인 마케팅 목표를 위해 데이터를 추출하고 싶지만 어떤 도구를 선택해야 할지 모르시나요? 2024년 최고의 웹사이트 스크래퍼 7가지를 소개합니다. 1. Browse AI Browse AI는 코딩 없이도 웹에서 데이터 추출, 모니터링, 자동화 작업을 수행할 수 있는 AI 기반 웹 자동화 소프트웨어입니다. 이 소프트웨어를 사용하면 몇 분 안에 모든 웹사이트를 스크래핑, 모니터링 및 자동화할 수 있으며, 데이터 추출 및 모니터링을 위한 다양한 기능과 크레딧을 갖춘 다양한 요금제를 제공합니다. https://www.browse.ai 2. AnyPicker AnyPicker는 코드가 필요 없는 AI 기반 웹 스크레이퍼입니다. 강력한 AI 기반 패턴 인식 엔진을 사용하여 몇 번의 클릭만으로 모든 웹 사이트에서 데이터를 스크랩할 수 있습니다. 이 확장 프로그램은 간단한 그래픽 인터페이스, 모든 웹사이트(로그인 후에도)에서 작업할 수 있는 기능, XLS Excel 및 CSV 형식으로 데이터 내보내기 등의 기능을 제공합니다. 애니피커를 사용해 보세요 3. Webscrape AI Webscrape AI는 수동 스크래핑이나 코딩 기술 없이도 웹에서 데이터 수집을 자동화할 수 있는 도구입니다. 이 도구는 고급 알고리즘을 사용해 데이터를 정확하게 수집합니다. 이 도구는 사용자 친화적으로 설계되었으며 인증이나 로그인 자격 증명이 필요하지 않은 모든 웹사이트로부터 데이터를 수집할 수 있습니다. https://webscrapeai.com 4. Bardeen Bardeen Scraper는 전문가가 만들고 유지 관리하는 사전 구축된 데이터 스크레이퍼 템플릿과 맞춤형 스크레이퍼 모델을 만들 수 있는 기능을 제공합니다. 스크랩한 데이터는 Google 스프레드시트, Airtable, Notion, HubSpot, Salesforce 등 다양한 앱과 즉시 동기화할 수 있습니다. Bardeen Scraper는 사용자 친화적으로 설계되었으며, 데이터 수집과 다른 애플리케이션과의 통합을 자동화하기 위한 노코드 솔루션을 제공합니다. www.bardeen.ai 5. AI Scraper Ai Scraper는 AI를 활용하여 스크래핑 프로세스의 효율성과 지능을 향상시키는 웹 스크래핑 도구입니다. 강력한 스크래핑 기능을 제공하고, 다운로드나 설치 없이 클라우드에서 실행되며, 스크래핑 테스트를 위한 내장된 플레이그라운드를 제공합니다. 이 도구는 무료 크레딧 자동 갱신 기능과 통합을 위한 간단한 API도 제공합니다. ai-scraper.com 6. Axiom Axiom은 코딩 없이도 모든 웹사이트나 웹 앱에서 웹사이트 작업과 반복적인 작업을 자동화할 수 있는 브라우저 자동화 도구입니다. Chrome 확장 프로그램으로 제공되며 시각적 웹 스크래핑, 데이터 입력, 스프레드시트 자동화, 코드 없이 사용자 지정 봇을 구축할 수 있는 기능 등의 기능을 제공합니다. 또한 이 도구는 Zapier, Integromat 또는 Webhooks와의 통합도 제공합니다. axiom.ai 7. Scrapestorm ScrapeStorm은 프로그래밍 기술 없이도 웹 페이지에서 데이터를 수집하는 프로세스를 간소화하는 AI 기반 시각적 웹 스크래핑 도구입니다. 사용자 친화적인 인터페이스와 높은 사용자 정의 기능을 제공하므로 다양한 수준의 경험을 가진 사용자에게 적합합니다. www.scrapestorm.com 결론 여기까지입니다. 제 생각에는 온라인 정보를 스크랩하는 최고의 AI 도구입니다. 꼭 확인해 보시고 사용 방법을 알려주세요. 행운을 빕니다! 😉","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"},{"name":"AI 기술","slug":"AI-기술","permalink":"http://hgko1207.github.io/tags/AI-%EA%B8%B0%EC%88%A0/"},{"name":"데이터","slug":"데이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"콘텐츠 제작","slug":"콘텐츠-제작","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0-%EC%A0%9C%EC%9E%91/"}]},{"title":"간단한 프롬프트를 통해 ChatGPT로 몇 초 안에 할 수 있는 50가지 작업","slug":"chatgpt-11","date":"2024-02-16T14:46:31.000Z","updated":"2024-02-18T13:59:38.225Z","comments":true,"path":"2024/02/16/chatgpt-11/","link":"","permalink":"http://hgko1207.github.io/2024/02/16/chatgpt-11/","excerpt":"","text":"ChatGPT는 시간을 알려주는 기본적인 작업부터 주식 시장 예측과 같은 복잡한 작업까지 몇 시간이 걸리는 일을 단 몇 초 만에 처리할 수 있습니다. 간단한 프롬프트를 통해 ChatGPT가 몇 초 안에 처리할 수 있는 50가지 작업은 다음과 같습니다. 50가지 작업 현재 시간 표시 주어진 메시지 인쇄 문자열의 문자 수 계산 텍스트를 대문자/소문자로 변환하기 특정 횟수만큼 메시지 반복하기 문자열 반전하기 숫자가 홀수인지 짝수인지 확인 난수 생성하기 숫자가 소수인지 확인 두 숫자의 최대공약수 찾기 오름차순 또는 내림차순으로 숫자 목록 정렬하기 목록 a에서 숫자의 합 구하기 문자열이 회문 a인지 확인하기 목록의 길이 찾기 목록에서 주어진 항목 검색하기 목록에서 중복 항목 제거하기 두 목록 병합하기 항목 목록 a 섞기 목록에서 최소 또는 최대 항목 찾기 주어진 연도가 윤년인지 확인하기 숫자의 계승 계산하기 n 번째 피보나치수 구하기 숫자가 양수, 음수 또는 0인지 확인하기 두 행렬 곱하기 행렬의 행렬식 계산하기 행렬의 전치하기 선형 연립방정식 풀기 행렬의 역함수 구하기 이차 방정식 인수분해하기 수학 함수 그리기 일반 미분 방정식 풀기 함수의 도함수를 계산하기 함수의 적분을 계산하기 다항식의 근 구하기 데이터 포인트 집합에 곡선 맞추기 기본 머신러닝 알고리즘 구현하기 신경망 훈련하기 손으로 쓴 숫자 인식하기 이미지를 다양한 카테고리로 분류하기 언어 모델을 사용하여 텍스트 생성 긴 기사 요약하기 텍스트를 다른 언어로 번역하기 텍스트에 대한 감정 분석 수행 텍스트에서 명명된 엔티티 추출 주가 예측 특정 위치의 날씨 예측 사용자 선호도에 따라 제품 추천 검색 엔진 구현 웹 페이지 크롤링 및 색인 생성 챗봇 생성 결론 ChatGPT는 작은 일에도 땀을 흘리지 않고 인간이 고개를 갸웃거리게 만드는 작업을 단 몇 초 만에 마스터합니다. 아직 인간의 지능을 완벽하게 재현하지는 못하지만, ChatGPT는 대화, 데이터 분석, 콘텐츠 생성 및 예측 능력으로 놀라움을 선사합니다. 따라서 다음 번에는 잔소리에 시달리거나 복잡한 프로젝트에 얽매여 있을 때 ChatGPT에게 도움을 요청하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"간단한 프롬프트","slug":"간단한-프롬프트","permalink":"http://hgko1207.github.io/tags/%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"50가지 작업","slug":"50가지-작업","permalink":"http://hgko1207.github.io/tags/50%EA%B0%80%EC%A7%80-%EC%9E%91%EC%97%85/"}]},{"title":"축구 선수를 위한 ChatGPT 프롬프트","slug":"chatgpt-10","date":"2024-02-16T14:15:10.000Z","updated":"2024-02-16T14:31:55.992Z","comments":true,"path":"2024/02/16/chatgpt-10/","link":"","permalink":"http://hgko1207.github.io/2024/02/16/chatgpt-10/","excerpt":"","text":"아름다운 스포츠인 축구는 신체적 능력뿐만 아니라 전략적 사고와 전술적 인식도 요구합니다. 노련한 프로 선수든 선수 지망생이든, 정신적 준비와 경기 역학 이해의 역할은 아무리 강조해도 지나치지 않습니다. 이 글에서는 ChatGPT 프롬프트가 축구 선수의 기술, 전략, 경기력 전반을 향상시키고자 하는 축구 선수에게 어떻게 유용한 도구가 될 수 있는지 살펴봅니다. 전술적 통찰력 축구 선수들이 ChatGPT를 사용할 때 얻을 수 있는 주요 이점 중 하나는 풍부한 전술적 인사이트를 얻을 수 있다는 것입니다. 특정 게임 시나리오, 포메이션 또는 상대 전략과 관련된 프롬프트를 작성하여 플레이어는 모델에 참여하여 맞춤형 조언과 분석을 받을 수 있습니다. 예를 들어, 플레이어가 &quot;4-4-2 포메이션의 빈틈을 어떻게 활용하면 좋을까요?&quot;와 같은 프롬프트를 입력할 수 있습니다. 그러면 모델은 전략적인 제안을 제공하여 플레이어가 상대 팀의 구조를 탐색하고 활용하는 방법을 더 잘 이해할 수 있도록 도와줍니다. 정신적 준비 ChatGPT는 시각화와 집중력에 초점을 맞춘 프롬프트를 생성하여 축구 선수의 정신적 준비를 도울 수 있습니다. 선수들은 종종 멘탈 이미지를 사용하여 게임 시나리오를 시뮬레이션함으로써 의사 결정 능력을 향상시키고 불안감을 줄일 수 있습니다. 예를 들어, 한 선수에게 &quot;중요한 경기의 마지막 몇 분 동안 내가 승리 골을 넣는 시나리오를 설명해 보세요.&quot;라는 메시지를 표시할 수 있습니다. 모델의 반응은 플레이어가 성공을 시각화하여 자신감과 정신적 회복력을 높이는 데 도움이 될 수 있습니다. 개인 기술 개발 특정 기술을 연마하고자 하는 축구 선수는 개인별 맞춤 프롬프트의 도움을 받을 수 있습니다. 프리킥 기술을 완성하거나 좁은 공간에서 드리블을 마스터하거나 수비 포지셔닝을 개선하는 등 ChatGPT는 맞춤형 가이드를 제공할 수 있습니다. 선수들은 &quot;빠르게 드리블하는 동안 볼 컨트롤을 향상하려면 어떻게 해야 하나요?&quot;와 같은 프롬프트를 입력하여 각자의 고유한 요구 사항을 해결하는 팁과 훈련을 받을 수 있습니다. 팀 커뮤니케이션 현장에서의 효과적인 의사소통은 성공을 위해 매우 중요합니다. ChatGPT 프롬프트는 팀 토론 및 전략 계획을 시뮬레이션하도록 설계할 수 있습니다. 플레이어는 &quot;탄력적인 수비를 무너뜨리기 위한 게임 계획 개발&quot;과 같은 프롬프트를 입력하여 모델이 응집력 있는 팀 플레이, 포지셔닝 및 조정을 위한 아이디어를 생성하도록 유도할 수 있습니다. 부상 예방 및 회복 부상은 스포츠에서 피할 수 없는 부분이지만, 선수들은 위험을 최소화하고 회복을 돕기 위해 사전 조치를 취할 수 있습니다. ChatGPT는 부상 예방 운동, 워밍업 루틴, 회복 전략에 대한 인사이트를 제공할 수 있습니다. 선수는 &quot;근육 긴장을 예방하기 위한 경기 전 워밍업 루틴 제안&quot;과 같은 메시지를 입력하면 신체 건강을 개선하기 위한 맞춤형 조언을 받을 수 있습니다. 결론 ChatGPT는 정신적으로나 육체적으로 경기력을 향상시키려는 축구 선수에게 귀중한 리소스를 제공합니다. 전술적 통찰력부터 개인 기술 개발, 팀 의사소통, 부상 예방에 이르기까지 가능성은 무궁무진합니다. ChatGPT 프롬프트를 훈련 계획에 통합함으로써 축구 선수는 경쟁 우위를 확보하고 게임에 대한 이해를 높이고 경기장에서 성공하는 데 필요한 기술을 연마할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"축구선수","slug":"축구선수","permalink":"http://hgko1207.github.io/tags/%EC%B6%95%EA%B5%AC%EC%84%A0%EC%88%98/"}]},{"title":"꼭 사용해봐야 할 4가지 AI 코딩 도우미","slug":"ai-16","date":"2024-02-15T15:15:20.000Z","updated":"2024-02-15T15:32:35.766Z","comments":true,"path":"2024/02/16/ai-16/","link":"","permalink":"http://hgko1207.github.io/2024/02/16/ai-16/","excerpt":"","text":"빠르게 변화하는 소프트웨어 개발의 세계에서는 효율성이 핵심입니다. 개발자들이 깔끔하고 오류 없는 코드를 작성하기 위해 노력하면서 지능형 코딩 도우미에 대한 수요가 급증했습니다. 인공지능(AI) 코딩 도우미는 생산성을 높이고 오류를 잡아내며 개선점을 제안하는 유용한 도구로 부상했습니다. 워크플로우에 통합을 고려해야 할 상위 4가지 AI 코딩 도우미를 살펴보세요. 1. GitHub Copilot: AI를 통한 코딩 혁신 https://github.com/features/copilot GitHub가 OpenAI와 협력하여 개발한 GitHub Copilot은 코딩 커뮤니티에 큰 돌풍을 일으켰습니다. OpenAI의 GPT-3로 구동되는 Copilot은 통합 개발 환경(IDE) 내에서 실시간 코드 제안을 제공합니다. 여러 프로그래밍 언어를 지원하는 Copilot은 컨텍스트를 이해하고 전체 코드 줄을 생성하므로 코딩 프로세스를 가속화하려는 개발자에게 강력한 동반자가 되어줍니다. 2. TabNine: 스테로이드 같은 코드 완성 https://www.tabnine.com/ TabNine은 언어 모델을 사용하여 다음에 입력할 내용을 예측하는 AI 기반 자동 완성기입니다. TabNine의 차별점은 사용자의 고유한 코딩 스타일을 이해하고 그에 맞게 조정할 수 있다는 점입니다. Python, JavaScript 또는 기타 언어를 사용하든 TabNine은 코딩 속도와 정확도를 개선하여 개인화된 코딩 경험을 제공하는 것을 목표로 합니다. 3. Codota: AI를 통한 Java 개발 향상 AI 기반 코딩 도우미를 찾는 Java 개발자는 Codota만 있으면 됩니다. Java에 특화된 Codota는 머신러닝 알고리즘을 사용하여 Java 코드의 패턴과 규칙을 이해합니다. 코드 완성, 오류 감지, 지능형 제안과 같은 기능을 통해 Codota는 Java 개발을 간소화하여 시간을 절약하고 버그 발생 가능성을 줄여줍니다. 4. DeepCode: 코드 검토를 위한 AI 활용 DeepCode는 자동화된 코드 리뷰에 AI를 사용하는 독특한 접근 방식을 취합니다. 방대한 프로그래밍 모범 사례 및 알려진 문제 데이터베이스에 대해 코드를 분석하여 잠재적인 버그, 보안 취약점 및 코드 개선에 대한 귀중한 피드백을 제공합니다. 널리 사용되는 버전 관리 시스템과 통합된 DeepCode는 코드 품질에 대한 사전 예방적 접근 방식을 촉진하여 강력하고 안전한 소프트웨어 제작에 집중하는 팀에게 필수적인 도구입니다. 결론 요약하자면, AI 코딩 도우미를 개발 워크플로우에 통합하면 생산성을 크게 높이고 오류를 줄이며 전반적인 코딩 경험을 개선할 수 있습니다. Python 애호가든, Java 개발자이든, 여러 언어로 작업하든, 이 상위 4가지 AI 코딩 도우미는 특정 요구 사항에 맞는 다양한 기능을 제공합니다. AI의 힘을 활용하여 더 나은 코드를 더 빠르게 작성하고 끊임없이 진화하는 소프트웨어 개발 환경에서 앞서 나가세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"},{"name":"AI 코딩 도우미","slug":"AI-코딩-도우미","permalink":"http://hgko1207.github.io/tags/AI-%EC%BD%94%EB%94%A9-%EB%8F%84%EC%9A%B0%EB%AF%B8/"}]},{"title":"ChatGPT 사용량 급증에 따라 인도에 막대한 투자","slug":"chatgpt-9","date":"2024-02-13T07:12:13.000Z","updated":"2024-02-16T15:01:59.011Z","comments":true,"path":"2024/02/13/chatgpt-9/","link":"","permalink":"http://hgko1207.github.io/2024/02/13/chatgpt-9/","excerpt":"","text":"중요한 발전으로, OpenAI는 인도의 놀라운 ChatGPT 채택에 힘입어 인도에 대규모 투자를 하겠다는 야심찬 계획을 발표했습니다. 이는 전 세계에서 두 번째로 많은 ChatGPT 사용자를 보유한 인도가 OpenAI 언어 모델 활용의 핵심 국가로 부상함에 따라 이루어진 발표입니다. 인도에서 ChatGPT의 부상 인도에서 ChatGPT의 여정은 경이롭기 그지없습니다. 콘텐츠 제작과 교육 지원부터 비즈니스 애플리케이션과 개인 비서에 이르기까지 다양한 영역의 사용자가 OpenAI의 언어 모델 기능을 수용했습니다. ChatGPT의 다양성과 적응성 덕분에 개인과 기업 모두에게 유용한 도구가 되었으며, 널리 사용되는 데 기여하고 있습니다. 인도의 언어 다양성과 ChatGPT의 적응성 인도 전역에서 다양한 언어가 사용되는 인도의 언어적 다양성은 독특한 도전과 기회를 제시했습니다. 여러 언어로 된 텍스트를 이해하고 생성하는 ChatGPT의 기능은 인도에서 인기를 얻은 원동력이었습니다. 사용자들은 다양한 청중의 언어적 뉘앙스를 충족하는 도구에서 가치를 발견하고 있으며, 다양한 언어와 문화로 유명한 인도에서 ChatGPT는 없어서는 안 될 자산이 되었습니다. OpenAI의 투자 전략 인도의 엄청난 잠재력을 인식한 OpenAI는 인도에 대규모 투자를 결정했습니다. 이번 투자는 ChatGPT를 지원하는 인프라를 강화하고, 지역 방언에 대한 언어 지원을 강화하며, 현지 기업 및 개발자와의 협업을 촉진하는 것을 목표로 합니다. 이러한 전략적 움직임은 신흥 시장에서 혁신과 접근성을 촉진하기 위한 OpenAI의 노력을 강조합니다. 기업과 개인의 역량 강화 OpenAI의 인도 투자는 창의성, 생산성, 커뮤니케이션의 새로운 가능성을 열어줌으로써 기업과 개인의 역량을 강화할 것입니다. ChatGPT가 지속적으로 발전함에 따라 인도 사용자들은 고유한 언어적, 문화적 요구 사항을 충족하는 맞춤형 솔루션을 통해 더욱 개인화되고 풍성한 경험을 기대할 수 있습니다. 격차 해소: OpenAI와 인도 개발자와의 협업 OpenAI의 접근 방식에는 현지 개발자 및 혁신가와의 협력이 포함됩니다. 인도의 활기찬 기술 커뮤니티와 협력함으로써 OpenAI는 글로벌 기술 발전과 지역 요구 사이의 격차를 해소하는 것을 목표로 합니다. 이러한 협업을 통해 ChatGPT는 역동적이고 반응이 빠른 도구로 인도 사용자의 진화하는 요구를 충족할 수 있습니다. 앞으로 나아갈 길 OpenAI의 인도에 대한 대규모 투자 결정은 인공지능 도구를 다양한 글로벌 환경에 통합하는 데 있어 중요한 이정표가 될 것입니다. ChatGPT의 사용자 기반이 두 번째로 높은 인도는 OpenAI의 확장 계획의 최전선에 서 있습니다. 이번 전략적 투자는 인도의 잠재력에 대한 자신감을 나타낼 뿐만 아니라 커뮤니케이션, 창작, 협업 방식을 혁신할 수 있는 최첨단 언어 모델에 대한 접근성을 민주화하겠다는 의지를 강조하는 것입니다. 결론 ChatGPT 사용의 급증에 힘입은 OpenAI의 인도 투자는 다양한 언어적, 문화적 맥락에서 진화하는 사용자의 요구를 충족하기 위한 미래 지향적인 접근 방식을 보여줍니다. 인도 개발자 및 기업과의 협력은 ChatGPT를 새로운 차원으로 끌어올리고, OpenAI와 인도의 역동적인 기술 생태계 간의 상호 이익이 되는 관계를 촉진할 것으로 기대됩니다. OpenAI가 인도에 대한 혁신과 투자를 지속함에 따라 향후 인도 기술 환경에 고급 언어 모델이 통합될 가능성이 높아 보입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"인도","slug":"인도","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8F%84/"},{"name":"인도 투자","slug":"인도-투자","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8F%84-%ED%88%AC%EC%9E%90/"}]},{"title":"AI 챗봇과 시각적 지원의 힘 활용하기","slug":"ai-15","date":"2024-02-13T06:53:58.000Z","updated":"2024-02-14T15:14:33.731Z","comments":true,"path":"2024/02/13/ai-15/","link":"","permalink":"http://hgko1207.github.io/2024/02/13/ai-15/","excerpt":"","text":"소개 오늘날과 같이 빠르게 변화하는 디지털 시대에 기업들은 고객 경험을 향상시킬 수 있는 혁신적인 방법을 끊임없이 모색하고 있습니다. 최근 큰 인기를 얻고 있는 획기적인 기술 중 하나는 AI 챗봇과 시각적 지원의 통합입니다. 이러한 강력한 도구는 고객과의 상호작용을 간소화할 뿐만 아니라 개인화되고 효율적인 경험을 제공합니다. 이 글에서는 AI 챗봇과 시각적 지원의 세계를 자세히 살펴보고, 그 장점과 구현 단계를 살펴보고, 코드 예제를 통해 직접 이해할 수 있도록 도와드립니다. AI 챗봇 이해하기 AI 챗봇은 인간 사용자와의 대화를 시뮬레이션하여 쿼리에 즉각적인 응답을 제공하도록 설계된 컴퓨터 프로그램입니다. 자연어 처리(NLP)와 머신 러닝 알고리즘을 활용하여 사용자 입력을 이해하고 이에 응답합니다. Python과 인기 있는 라이브러리인 ChatterBot을 사용하여 기본적인 AI 챗봇을 만드는 과정을 분석해 보겠습니다. 1단계: ChatterBot 설치 1pip install chatterbot 2단계: 기본 챗봇 만들기 123456789101112131415from chatterbot import ChatBot# ChatBot 인스턴스 만들기chatbot = ChatBot('MyBot')# 샘플 데이터로 챗봇을 훈련시킵니다.from chatterbot.trainers import ChatterBotCorpusTrainertrainer = ChatterBotCorpusTrainer(chatbot)# 영어 데이터로 챗봇 훈련하기trainer.train('chatterbot.corpus.english')# 응답 가져오기response = chatbot.get_response(\"What is your name?\")print(response) AI 챗봇의 장점 24시간 연중무휴 가용성: 챗봇은 24시간 내내 지원을 제공하여 고객 서비스를 향상시킵니다. 비용 효율적: 일상적인 문의에 사람이 직접 개입할 필요성을 줄여 운영 비용을 절감합니다. 즉각적인 응답: AI 챗봇은 빠르고 정확한 응답을 제공하므로 사용자 만족도가 향상됩니다. 실제 시각적 지원 시각적 지원은 이미지, 동영상, AR 기술을 대화에 통합하여 고객 지원 수준을 한 단계 끌어올립니다. 예를 들어 제품에 대한 도움을 요청하는 고객이 스마트폰 카메라를 사용하여 문제의 이미지나 동영상을 공유할 수 있습니다. 1단계: 시각적 인식 통합하기 IBM Watson Visual Recognition과 같은 시각 인식 API를 활용하세요. 먼저 IBM Cloud에서 API 키를 등록합니다. 2단계: Watson Developer SDK 설치 1pip install ibm-watson 3단계: 시각적 인식 사용 123456789101112131415161718from ibm_watson import VisualRecognitionV4from ibm_cloud_sdk_core.authenticators import IAMAuthenticator# 시각적 인식 설정authenticator = IAMAuthenticator('&lt;YOUR_API_KEY&gt;')visual_recognition = VisualRecognitionV4( version='2018-03-19', authenticator=authenticator)# 이미지 분석with open('sample_image.jpg', 'rb') as image_file: result = visual_recognition.analyze( collection_ids=['&lt;COLLECTION_ID&gt;'], images_file=image_file, ).get_result()print(result) 시각 지원의 이점 문제 해결 능력 향상: 시각적 컨텍스트는 지원 상담원이 고객 문제를 더 잘 이해하고 해결하는 데 도움이 됩니다. 사용자 경험 개선: 사용자는 복잡한 문제를 시각적으로 전달할 수 있어 문제를 더 빨리 해결할 수 있습니다. 제품 추천: 시각적 지원을 활용하여 고객의 선호도에 따라 제품을 추천할 수 있습니다. 결론 AI 챗봇과 시각적 지원의 결합은 최고의 고객 서비스를 제공하고자 하는 기업의 판도를 바꿀 수 있습니다. 제공된 단계와 사례를 따라 고급 고객 참여의 영역으로 여정을 시작하여 경쟁이 치열한 디지털 환경에서 앞서 나갈 수 있습니다. 이러한 기술을 도입하여 고객과의 상호작용이 원활하고 만족스러운 경험으로 변화하는 과정을 지켜보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Chatbot","slug":"Chatbot","permalink":"http://hgko1207.github.io/tags/Chatbot/"},{"name":"Chatbot Design","slug":"Chatbot-Design","permalink":"http://hgko1207.github.io/tags/Chatbot-Design/"},{"name":"챗봇","slug":"챗봇","permalink":"http://hgko1207.github.io/tags/%EC%B1%97%EB%B4%87/"}]},{"title":"JavaScript로 클릭 이벤트를 작성하는 3가지 방법 🖱️","slug":"js-dev-16","date":"2024-02-09T13:54:03.000Z","updated":"2024-02-14T01:16:26.839Z","comments":true,"path":"2024/02/09/js-dev-16/","link":"","permalink":"http://hgko1207.github.io/2024/02/09/js-dev-16/","excerpt":"","text":"소개🌊 JavaScript는 대화형 웹 개발의 핵심이며, 클릭 이벤트 처리는 모든 프론트엔드 개발자가 익혀야 할 기본 기술입니다. 이 글에서는 JavaScript로 클릭 이벤트를 작성하는 세 가지 방법을 살펴봅니다. 이제 막 시작했거나 기술을 연마하고 있는 개발자라면 이 가이드가 웹 페이지를 인터랙티브하게 만드는 방법을 이해하는 데 도움이 될 것입니다. 예제를 자세히 살펴보겠습니다. 인라인 HTML 이벤트 핸들러 📄 인라인 HTML 이벤트 핸들러는 HTML 요소 내에 JavaScript 코드를 직접 배치합니다. 이 방법은 거의 모든 HTML 요소에 할당할 수 있는 onclick 속성을 사용합니다. 123456&lt;button onclick=\"showAlert()\"&gt;Click Me!&lt;/button&gt;&lt;script&gt; function showAlert() &#123; alert('Button clicked!'); &#125;&lt;/script&gt; 장점 인라인 HTML 이벤트 핸들러는 구현 속도가 매우 빠르기 때문에 간단한 작업이나 소규모 프로젝트에 이상적입니다. 요소에 상호작용을 추가하는 직접적인 방법을 제공하므로 특히 초보자나 복잡한 외부 스크립트 없이 즉각적인 결과가 필요한 시나리오에서 사용자 친화적입니다. 단점 그러나 이 접근 방식은 특히 대규모 애플리케이션에서 코드 가독성 및 유지보수성을 떨어뜨릴 수 있습니다. HTML과 JavaScript를 혼합하여 구조(HTML)와 동작(JavaScript)을 분리하는 모범 사례와 모순되므로 코드 관리 및 업데이트 프로세스가 더 까다로워질 수 있습니다. 방법 2: Element ID 및 addEventListener🔍 사용 addEventListener 메서드는 HTML과 JavaScript 간의 문제를 분리하는 강력한 방법입니다. 이 메서드를 사용하면 ID로 식별되는 Element에 이벤트 리스너를 첨부하여 깔끔하고 유지 관리가 쉬운 코드를 만들 수 있습니다. 1234567&lt;button id=\"myButton\"&gt;Click Me!&lt;/button&gt;&lt;script&gt; const myButton = document.getElementById(\"myButton\"); myButton.addEventListener(\"click\", function () &#123; alert(\"Button clicked!\"); &#125;);&lt;/script&gt; 장점 addEventListener 메서드는 이벤트 핸들러를 연결하기 위한 강력한 솔루션으로 HTML과 JavaScript를 깔끔하게 분리할 수 있습니다. 따라서 코드 유지보수 및 구성이 개선되어 규모가 크고 복잡한 애플리케이션에 선호되는 방식입니다. 또한 단일 요소에서 여러 이벤트 핸들러를 활성화하여 유연성을 높일 수 있습니다. 단점 이 방법은 설정하기가 약간 더 복잡할 수 있으며 DOM에 대한 기본적인 이해가 필요합니다. 또한 인라인 방식에 비해 조금 더 장황할 수 있으며, 단순성이 중요한 경우 스크립트가 무거워질 수 있습니다. 방법 3: 이벤트 위임 🚀 이벤트 위임은 이벤트 버블링 단계를 활용하는 기술입니다. 부모 요소에 단일 이벤트 리스너를 추가하면 여러 하위 요소에 대한 이벤트를 처리할 수 있습니다. 이는 동적으로 추가된 요소를 처리할 때 특히 유용합니다. 1234567891011&lt;div id=\"buttonContainer\"&gt; &lt;button&gt;Button 1&lt;/button&gt; &lt;button&gt;Button 2&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById('buttonContainer').addEventListener('click', function(e) &#123; if (e.target.tagName === 'BUTTON') &#123; alert('Button clicked: ' + e.target.textContent); &#125; &#125;);&lt;/script&gt; 장점 이벤트 위임은 특히 동적 콘텐츠 시나리오에서 여러 요소의 이벤트를 관리하는 데 매우 효율적입니다. 단일 이벤트 리스너를 부모 요소에 연결함으로써 메모리 사용량을 크게 줄이고 성능을 개선할 수 있어 대규모 애플리케이션에서 매우 중요합니다. 단점 장점에도 불구하고 이벤트 위임에는 한계가 있습니다. focus또는 와 같이 자연스럽게 버블링되지 않는 이벤트를 처리하는 데는 적합하지 않습니다 blur. 또한 특정 이벤트 속성이 필요한 경우 이벤트 버블링 단계 중에 변경될 수 있습니다. 이러한 복잡성과 의도하지 않은 동작의 가능성으로 인해 이 방법은 신중한 구현과 이벤트 전파에 대한 확실한 이해가 필요한 방법입니다. 장점에도 불구하고 이벤트 위임에는 한계가 있습니다. focus나 blur와 같이 자연적으로 버블링되지 않는 이벤트를 처리하는 데는 적합하지 않습니다. 또한 특정 이벤트 속성이 필요한 경우 이벤트의 버블링 단계에서 해당 속성이 변경될 수 있습니다. 이러한 복잡성과 의도하지 않은 동작이 발생할 가능성이 있기 때문에 이벤트 전파에 대한 확실한 이해와 신중한 구현이 필요한 방법입니다. 결론🎯 JavaScript에서 클릭 이벤트를 처리하는 데 적합한 방법을 선택하는 것은 특정 요구 사항과 프로젝트의 컨텍스트에 따라 달라집니다. 인라인 이벤트 핸들러(Inline event handlers)는 단순성을 제공하고, addEventListener는 유연성을 제공하며, 이벤트 위임(event delegation)은 특히 동적 콘텐츠 시나리오에서 효율성을 제공합니다. 이러한 메서드를 이해하고 적용하면 대화형 반응형 웹 애플리케이션을 제작할 수 있는 능력을 갖추게 됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"이벤트","slug":"이벤트","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"클릭 이벤트","slug":"클릭-이벤트","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%A6%AD-%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"Click","slug":"Click","permalink":"http://hgko1207.github.io/tags/Click/"}]},{"title":"JavaScript의 함수와 메서드?🤔","slug":"js-dev-15","date":"2024-02-07T14:48:53.000Z","updated":"2024-02-07T15:00:20.185Z","comments":true,"path":"2024/02/07/js-dev-15/","link":"","permalink":"http://hgko1207.github.io/2024/02/07/js-dev-15/","excerpt":"","text":"프로그래밍의 세계로 뛰어들 때 접하게 되는 기본 개념 중 하나는 메서드(Method)와 함수(Function)의 구분입니다. 메서드와 함수는 모두 JavaScript에서 중요한 역할을 하지만, 서로 다른 용도로 사용되며 서로 다른 방식으로 사용됩니다. 이 글에서는 이 두 개념을 명확하게 설명하여 차이점을 명확하게 이해하도록 하겠습니다. function와 method에 대해 자세히 알아보겠습니다. JavaScript의 함수 이해하기 📚 함수의 핵심은 특정 작업 또는 일련의 작업을 수행하는 재사용 가능한 코드 블록입니다. 필요할 때마다 호출하거나 호출할 수 있는 미리 정의된 명령어 집합이라고 생각하면 됩니다. 함수는 JavaScript 코드의 빌딩 블록과 같아서 복잡한 작업을 더 작고 관리하기 쉬운 조각으로 나눌 수 있습니다. 다음은 함수의 기본 예시입니다. 123function greet(name) &#123; return 'Hello, ' + name + '!';&#125; 이 예시에서 greet은 name이라는 단일 매개변수를 받아 인사말 문자열을 반환하는 함수입니다. JavaScript의 함수는 다용도로 사용할 수 있으며 이와 같은 간단한 작업부터 복잡한 논리까지 다양한 상황에서 사용될 수 있습니다. JavaScript의 메서드란 무엇인가요? 🛠️ 이제 메서드에 대해 이야기해 보겠습니다. JavaScript에서 메서드는 본질적으로 함수이지만 객체와 연관되어 있다는 점에서 큰 차이가 있습니다. 메서드는 객체 속성으로 저장되며 해당 객체의 동작을 정의하는 데 사용되는 함수입니다. 예는 다음과 같습니다. 1234567let person = &#123; firstName: 'John', lastName: 'Doe', fullName: function () &#123; return this.firstName + ' ' + this.lastName; &#125;,&#125;; 이 예제에서 fullName은 person 객체의 메서드입니다. 이 메서드는 this 키워드를 사용하여 객체의 속성에 액세스합니다. 주요 차이점 🔄 JavaScript의 함수와 메서드의 주요 차이점을 강조해 보겠습니다. 1. 소유권 함수는 독립적인 코드 블록입니다. 메서드는 객체에 바인딩된 함수입니다. 2. 호출 함수는 functionName()과 같이 이름으로 직접 호출됩니다. 메서드는 object.method()와 같이 점 표기법을 사용하여 객체를 통해 호출됩니다. 3. 목적 함수는 다목적이며 다양한 작업을 수행할 수 있습니다. 메서드는 특정 객체와 관련된 작업에 특화되어 있습니다. 결론 🎉 JavaScript에서 메서드와 함수의 차이점을 이해하는 것은 명확하고 효율적인 코드를 작성하는 데 매우 중요합니다. 함수는 모듈성과 재사용성을 제공하는 반면, 메서드는 객체 지향 프로그래밍의 원칙에 따라 객체 내에서 동작을 캡슐화할 수 있는 방법을 제공합니다. 요약하자면, 모든 메서드는 함수이지만 모든 함수가 메서드인 것은 아닙니다. 차이점은 객체와의 연관성 및 해당 객체의 컨텍스트 내에서 사용되는 방식에 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"메서드","slug":"메서드","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"Method","slug":"Method","permalink":"http://hgko1207.github.io/tags/Method/"}]},{"title":"ChatGPT, Perplexity, Microsoft Copilot 비교하기","slug":"ai-14","date":"2024-02-07T14:25:54.000Z","updated":"2024-02-07T14:46:10.855Z","comments":true,"path":"2024/02/07/ai-14/","link":"","permalink":"http://hgko1207.github.io/2024/02/07/ai-14/","excerpt":"","text":"현재 전 세계적으로 여러 가지 AI 애플리케이션이 개발되고 있습니다. 그 중 가장 많이 사용되는 몇 가지 애플리케이션은 ChatGPT, Microsoft Copilot, Perplexity입니다. 사용자 관점과 소프트웨어 개발자의 관점에서 이 두 가지의 주요 차이점과 유사점에 대해 자세히 살펴보겠습니다. ChatGPT OpenAI에서 개발한 이 기술은 수신된 프롬프트를 기반으로 사람과 유사한 텍스트를 이해하고 생성하도록 설계된 AI 언어 모델입니다. 다양한 주제와 작업에 걸쳐 답변을 제공할 수 있는 딥러닝 알고리즘으로 잘 알려진 GPT(Generative Pre-trained Transformer) 시리즈의 일부입니다. 에세이 작성, 코딩, 일상적인 대화에 이르기까지 ChatGPT는 정보, 창의성 또는 엔터테인먼트를 원하는 사용자에게 매우 유용한 도구가 될 수 있습니다. 방대한 데이터 세트에서 학습하는 기능을 통해 사람과 유사한 상호작용을 모방할 수 있으며, 사전 구성된 모델을 공유하고 API를 통해 다른 웹사이트와 상호작용할 수 있는 ChatGPT 스토어는 구성에 많은 도움을 줍니다. Perplexity AI 보다 직관적이고 정확한 정보 검색을 위해 노력하는 AI 기반 검색 도우미로 자리매김하고 있습니다. 웹 페이지 목록을 반환하는 기존 검색 엔진과 달리 Perplexity AI는 질문에 대한 직접적인 답변을 제공함으로써 사용자가 필요한 정보를 더 쉽게 찾을 수 있도록 하는 것을 목표로 합니다. 웹 검색 외에도 인터넷에서 제공된 소스를 기반으로 콘텐츠를 생성하여 요청 내에서 확인할 수도 있습니다. Microsoft Copilot 주로 Microsoft 365에 통합되어 오피스 작업의 생산성을 향상시키는 AI 도구입니다. 이 도구는 자연어 처리와 기계 학습의 조합을 통해 Outlook의 이메일 작성, Excel의 데이터 분석, PowerPoint의 콘텐츠 작성 등 다양한 기능에 AI를 사용하여 사용자를 지원합니다. 주요 기능 및 사용자 경험 ChatGPT 사람과 같은 응답을 생성하는 데 탁월한 대화형 인터페이스를 제공합니다. 다양한 주제에 대한 토론에 참여할 수 있어 학습, 창의성 및 작업 지원을 위한 유용한 도구로 활용도가 높습니다. Perplexity AI 정보 검색 방식을 개선하는 데 중점을 둡니다. 링크 대신 직접 답변이나 간결한 요약을 제공함으로써 여러 웹 페이지를 거치지 않고 빠르고 신뢰할 수 있는 정보를 필요로 하는 사용자에게 적합합니다. Microsoft Copilot 복잡한 작업을 자동화하고 생산성 향상을 위한 제안을 제공하여 Microsoft 도구 제품군 사용 방식을 혁신합니다. 각 애플리케이션에 긴밀하게 통합되어 있어 이미 Microsoft 365를 사용하고 있는 사용자에게 원활한 도우미가 되어 줍니다. Microsoft 365 사용 외에도 웹에서도 사용할 수 있으며 가능한 기능을 한눈에 파악할 수 있습니다. 사용 사례 이미지 생성 다음은 세 가지 모델 모두에 대해 동일한 프롬프트의 예입니다. 간단한 이미지 생성에는 대부분 ChatGPT와 Microsoft Copilot을 활용할 수 있습니다. 반면에 Perplexity AI는 이러한 이미지를 얻을 수 있는 웹사이트에 대한 유용한 정보를 제공하거나 유용한 사진에 대한 아이디어를 얻을 수 있습니다. 코드 생성 모든 AI 도구는 뉴욕의 레스토랑에 대한 필요한 정보를 얻기 위한 전체 파이썬 스크립트를 제공했습니다. 실제로 흥미로운 점은 ChatGPT와 Copilot 모두 Google Places API를 직접 사용할 것을 제안한 반면, Perplexity는 유사한 솔루션을 검색하는 동안 발견한 링크 때문에 SerpApi 솔루션을 선택했다는 점입니다. 더욱 흥미로운 점은 새 페이지에서 Perplexity에 동일한 질문을 했을 때 코드가 아닌 Google Places API를 사용하라는 제안을 받았다는 점입니다: 콘텐츠 생성 여기서 흥미로운 점은 결과의 유사성입니다. 예를 들어 스토리텔러 솔루션과 ContentCraft는 모호한 설명이 제공되었음에도 불구하고 두 개 이상의 AI 도구에 포함된 것 같습니다. 소프트웨어 엔지니어로서 작업 속도를 높이기 위해 이러한 도구를 최대한 활용하려면 어떻게 해야 할까요? 코드에서 문제 찾기 ChatGPT와 Perplexity는 모두 이에 매우 적합합니다. ChatGPT를 사용하면 잠재적인 문제를 빠르게 식별할 수 있고, Perplexity는 읽을 만한 가치가 있는 소스를 제공합니다. 시스템 설계 및 아키텍처 스파링 파트너 주로 아키텍처 및 시스템 설계에 대한 아이디어를 시험해 볼 때 ChatGPT를 사용합니다. 다이어그램 작성과 목업 프레젠테이션에도 활용할 수 있는 여러 가지 추가 방법이 있어 매우 유용합니다. 현재 성장하고 있는 ChatGPT 빌더 커뮤니티는 여러 가지 방법으로 인공지능의 힘을 IT 세계에 완전히 도입하는 데 도움을 주고 있습니다. 소스 찾기 이 작업을 위해 보통 Perplexity와 Copilot을 모두 활용합니다. 두 가지 모두 정보를 수집하는 방식에 대한 많은 정보를 제공하여 검증에 도움이 됩니다. 결론 다양한 필요에 따라 사용할 수 있는 여러 가지 AI 도구가 있습니다. 이 글에서 소개한 것처럼 주어진 작업에 가장 적합한 도구를 이해하고 찾아서 그 기능을 최대한 활용하려고 노력하는 것이 중요합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Perplexity","slug":"Perplexity","permalink":"http://hgko1207.github.io/tags/Perplexity/"},{"name":"Microsoft Copilot","slug":"Microsoft-Copilot","permalink":"http://hgko1207.github.io/tags/Microsoft-Copilot/"}]},{"title":"커리어 성장을 촉진하는 25가지 ChatGPT 프롬프트","slug":"chatgpt-8","date":"2024-02-06T01:24:38.000Z","updated":"2024-02-06T01:51:03.163Z","comments":true,"path":"2024/02/06/chatgpt-8/","link":"","permalink":"http://hgko1207.github.io/2024/02/06/chatgpt-8/","excerpt":"","text":"오늘날과 같이 경쟁이 치열한 취업 시장에서 커리어를 성장시키고 발전시키려면 전략적인 계획과 지속적인 개선이 필요합니다. 다행히도 이 여정을 혼자서 헤쳐나갈 필요는 없습니다. 강력한 인공지능 언어 모델인 ChatGPT는 커리어의 다양한 측면에 걸쳐 귀중한 인사이트와 가이드를 제공할 수 있습니다. 이 글에서는 면접 준비부터 기업 내 커뮤니케이션 스킬까지 커리어 성장에 도움이 될 수 있는 25가지 ChatGPT 프롬프트를 살펴봅니다. 각 프롬프트는 커리어 목표를 달성하는 데 유용한 도구입니다. 면접 준비 프롬프트 예시 (특정 분야 또는 역할 언급)에서 곧 있을 면접을 위한 전략을 세울 수 있도록 도와주세요. 예상되는 질문의 유형은 무엇이며, 저의 강점과 이전 경험을 효과적으로 설명하려면 어떻게 해야 하나요? 잘 준비된 답변과 자신감으로 다음 면접에서 승리하세요. 이력서 향상 프롬프트 예시 이력서를 업데이트하고 있는데 (업종 또는 직무 명시) 직무에 대한 저의 역량을 최대한 반영하고 싶습니다. 어떤 레이아웃과 글꼴을 사용해야 하나요? 가장 효과적인 키워드를 찾는 데 도움을 주실 수 있나요? 세련되고 현대적인 이력서로 채용 담당자의 시선을 사로잡을 확률을 높이세요. LinkedIn 프로필 최적화 프롬프트 예시 (업종 또는 직무 명시)의 직무에 적합하도록 LinkedIn 프로필을 개선하기 위해 노력하고 있습니다. 제가 반드시 갖춰야 할 섹션은 무엇이며, 제 강점을 보여주기 위해 어떻게 최적화할 수 있을까요? LinkedIn 프로필을 원하는 분야에서 기회를 얻을 수 있는 핫스팟으로 바꿔보세요. 자기소개서 작성 프롬프트 예시 (업종 또는 직무 명시)의 직책에 지원하기 위해 자기 소개서 초안을 작성하고 있습니다. 이 기회에 대한 저의 열정을 보여 주면서 제가 해당 직무에 가장 적합하다는 것을 효과적으로 보여 주려면 어떻게 해야 할까요? 직무 적합성을 잘 드러내는 자기소개서로 기회의 문을 활짝 열어보세요. 네트워킹 전략 프롬프트 예시 (산업 또는 분야 지정) 분야에서 강력한 네트워크를 구축하고 싶습니다. 어디서부터 시작해야 하는지, 업계 전문가에게 어떻게 접근해야 하는지, 이러한 인맥을 장기적으로 유지할 수 있는지 안내해 주시겠습니까? 업계에서 귀중한 인맥을 구축하여 흥미로운 기회를 창출할 수 있는 기반을 마련하세요. 개인 브랜드 구축 프롬프트 예시 저는 (산업 또는 분야 지정) 분야에서 개인 브랜드를 구축하고자 합니다. 어떻게 하면 나만의 강점을 파악하고 활용하여 시장에서 뚜렷한 정체성을 만들 수 있을까요? 자신의 진정한 모습을 드러내는 강력한 개인 브랜드를 구축하여 해당 분야에서 자신의 위상을 높일 수 있습니다. 커리어 발전 프롬프트 예시 저는 현재 근무하고 있는 (분야 또는 역할 명시) 분야에서 커리어 사다리를 오르고 싶습니다. 제 기술을 향상시키고 조직에 없어서는 안 될 자산이 되기 위해 어떤 전략을 채택할 수 있을까요? 조직에서 주목받는 인재가 되어 빠르게 커리어를 성장시킬 수 있습니다. 협상 기술 프롬프트 예시 전문적인 환경에서 협상을 준비하고 있습니다. 효과적으로 협상하고 관련된 모든 당사자가 윈윈할 수 있는 결과를 보장하는 전략을 알려주시겠어요? 협상의 기술을 익히고 상호 이익이 되는 결과를 도출할 수 있도록 대화를 이끌 수 있습니다. 경력 전환 전략 프롬프트 예시 저는 (분야 또는 역할 명시) 분야로의 경력 전환을 고려하고 있습니다. 기존 기술과 경험을 활용하면서 원활하게 전환하려면 어떤 단계를 밟아야 하나요? 기존 기술을 효과적으로 활용하여 경력 전환을 원활하게 진행할 수 있습니다. 기술 개발 계획 프롬프트 예시 (분야 또는 역할 지정)과 관련된 새로운 기술을 개발하고 싶습니다. 집중해야 할 기술과 활용할 수 있는 리소스를 설명하는 기술 개발 계획을 세우는 데 도움을 주실 수 있나요? 지속적인 학습 접근 방식을 통해 중요한 기술을 연마하여 커리어에서 앞서 나가세요. 구직 전략 프롬프트 예시 (업종 또는 분야 지정)에서 구직 활동을 하고 있습니다. 사용할 플랫폼과 타겟팅해야 할 회사의 종류에 대한 전략을 세우는 데 도움을 주실 수 있나요? 적합한 플랫폼과 기업을 타겟팅하는 체계적인 전략을 통해 구직 활동을 보다 효과적으로 진행할 수 있습니다. 일과 삶의 균형 프롬프트 예시 저는 현재 (직무 명시) 직무를 수행하면서 일과 삶의 균형을 유지하는 데 어려움을 겪고 있습니다. 시간을 보다 효과적으로 관리하고 스트레스를 줄일 수 있는 방법을 제안해 주시겠습니까? 시간 관리를 효율화하고 스트레스를 줄이는 전략으로 일과 삶의 균형을 더욱 건강하게 유지하세요. 갈등 해결 프롬프트 예시 직장에서 (언급 관계 - 예: 동료, 상사)와 갈등을 겪고 있습니다. 이 상황을 헤쳐나가고 해결책을 찾는 데 도움을 주실 수 있나요? 상황에 맞는 조언을 통해 직장 내 갈등을 효과적으로 해결할 수 있습니다. 전문성 개발 프롬프트 예시 “저는 (분야 또는 역할 지정) 분야의 전문성 개발에 집중하고 싶습니다. 수강해야 할 강좌, 읽을 만한 책, 들을 만한 팟캐스트 등을 안내해 주시겠어요?” 자신의 분야와 관심사에 맞는 리소스와 방법을 통해 전문적인 성장을 강화할 수 있습니다. 리더십 기술 프롬프트 예시 곧 (역할 또는 책임 언급) 맡게 되어 리더십 기술을 개발하려고 합니다. 제가 리더로서 성장하는 데 도움이 되는 팁과 리소스를 제공해 주시겠습니까? 눈에 띄는 리더십 스킬을 갖추고 자신감을 가지고 새로운 역할을 맡으세요. 피드백 및 리뷰 프롬프트 예시 저는 (직책 명시) 역할을 맡고 있는 팀원의 성과 리뷰를 해야 합니다. 건설적이고 격려가 되는 피드백 초안을 작성하는 데 도움을 주실 수 있나요? 건설적인 피드백을 제공하여 팀원의 성장을 돕고 긍정적인 업무 환경을 조성할 수 있습니다. 직장 내 정신 건강 프롬프트 예시 팀/고용주와 함께 정신 건강이라는 주제를 다루고 싶습니다. 이 문제를 논의하기 위한 민감하고 포괄적인 접근 방식을 설명해 주시겠습니까? 정신 건강을 효과적이고 민감하게 다룸으로써 보다 건강한 직장 환경을 조성할 수 있습니다. 포트폴리오 구축 프롬프트 예시 (업종 또는 직무 명시)에서의 역할을 위한 포트폴리오를 구축하고 있습니다. 포트폴리오에 포함해야 할 필수 요소와 업무를 효과적으로 표현하는 방법을 알려주시겠습니까? 자신의 전문성과 기술을 효과적으로 보여줄 수 있는 매력적인 포트폴리오를 만들 수 있습니다. 원격 근무 생산성 프롬프트 예시 저는 (구체적인 직무 또는 업종 언급)과 관련된 역할에서 원격으로 근무하고 있습니다. 생산성과 건강한 일상을 유지할 수 있는 방법을 제안해 주시겠습니까? 생산성과 웰빙을 향상시키는 습관과 루틴을 통해 원격 근무 환경에서도 성공할 수 있습니다. 직장에서의 창의성과 혁신 프롬프트 예시 저는 (직책 명시) 제 역할에서 창의성과 혁신을 키우고 싶습니다. 틀에 박힌 사고에서 벗어나는 데 도움이 되는 전략이나 연습을 제공해 주실 수 있나요? 창의력을 키우고 업무에 혁신적인 접근 방식을 도입하여 자신의 역할에서 두각을 나타내세요. 연봉 협상 프롬프트 예시 저는 (직책 명시)의 역할로 연봉 협상을 준비하고 있습니다. 더 나은 패키지를 협상하기 위한 전략과 팁을 알려주시겠어요? 연봉 협상을 마스터하여 자신의 기술과 경험에 맞는 패키지를 확보할 수 있습니다. 새로운 직장에서의 문화적 적합성 프롬프트 예시 새로운 회사에 입사하여 기존 문화에 잘 적응하고 싶습니다. 새로운 직장 문화를 이해하고 적응할 수 있는 팁을 알려주시겠어요? 새로운 직장의 문화를 효과적으로 이해하고 적응함으로써 새로운 직장에 원활하게 통합할 수 있습니다. 팀 빌딩 프롬프트 예시 (산업 또는 분야 지정) 프로젝트를 위한 팀을 구성해야 하는 임무를 맡고 있습니다. 적합한 인재를 선발하고 협업 환경을 조성하기 위한 전략에 대해 도움을 주실 수 있나요? 적합한 인재를 선발하고 협업을 촉진하는 전략으로 높은 성과를 내는 팀을 구축할 수 있습니다. 프로젝트 관리 프롬프트 예시 (분야 또는 업종 지정) 프로젝트를 관리하고 있습니다. 프로젝트가 순조롭게 진행되고 성공을 보장할 수 있는 도구와 전략에 대해 도움을 주실 수 있나요? 모든 것을 순조롭게 진행할 수 있는 효과적인 도구와 전략으로 프로젝트를 성공으로 이끄세요. 기업 커뮤니케이션 프롬프트 예시 현재 맡고 있는 (직책 명시) 직무에서 기업 커뮤니케이션 기술을 향상시키고 싶습니다. 보다 효과적인 커뮤니케이션을 위한 팁과 연습을 도와주실 수 있나요? 기업 커뮤니케이션 기술을 향상시키고 자신의 역할에서 더욱 효과적인 커뮤니케이터가 될 수 있습니다. 결론 이 25가지 ChatGPT 프롬프트를 통해 여러분의 커리어 성장을 위한 종합적인 툴킷을 갖추게 되었습니다. 면접을 준비하든, 전문성을 강화하든, 다양한 커리어 관련 문제에 대한 조언을 구하든, ChatGPT는 성공으로 가는 길에 든든한 동반자가 되어줄 것입니다. 이 프롬프트를 전략적으로 활용하여 커리어를 새로운 차원으로 끌어올리고 꿈을 이루세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT-4","slug":"ChatGPT-4","permalink":"http://hgko1207.github.io/tags/ChatGPT-4/"},{"name":"커리어 성장","slug":"커리어-성장","permalink":"http://hgko1207.github.io/tags/%EC%BB%A4%EB%A6%AC%EC%96%B4-%EC%84%B1%EC%9E%A5/"}]},{"title":"초보자를 위한 ChatGPT-4 프롬프트 사용 방법","slug":"chatgpt-7","date":"2024-01-31T05:30:22.000Z","updated":"2024-02-06T15:02:01.116Z","comments":true,"path":"2024/01/31/chatgpt-7/","link":"","permalink":"http://hgko1207.github.io/2024/01/31/chatgpt-7/","excerpt":"","text":"소개 끊임없이 진화하는 언어 모델 기술 환경에서는 프롬프트 제작의 뉘앙스를 이해하는 것이 중요합니다. 숙련된 전문가든 ChatGPT-4와 같은 대규모 언어 모델(LLM)의 세계를 처음 접하는 사람이든, 상호작용을 최적화하기 위해서는 흔히 저지르는 실수를 인식하는 것이 중요합니다. 이 글에서는 이러한 함정에 대해 알아보고 ChatGPT-4의 잠재력을 최대한 발휘할 수 있는 효과적인 프롬프트를 작성하는 방법을 안내합니다. 기본 사항 이해하기 일반적인 실수를 살펴보기 전에 대규모 언어 모델(LLM)의 맥락에서 프롬프트가 무엇인지 간단히 정의해 보겠습니다. 프롬프트는 언어 모델에 제공되는 입력으로, 모델이 응답을 생성하도록 안내합니다. 프롬프트의 품질과 명확성은 ChatGPT-4의 응답의 관련성과 정확성에 직접적인 영향을 미칩니다. 모호하거나 지나치게 광범위한 프롬프트 1프롬프트 예시: &quot;기술에 대해 알려주세요.&quot; 이 프롬프트는 너무 광범위하고 구체성이 부족하여 일반적이거나 초점이 맞지 않는 응답을 유도할 수 있습니다. 더 나은 방법은 주제를 좁히거나 관심 있는 특정 측면을 지정하는 것입니다. 1개선된 프롬프트: &quot;블록체인 기술이 금융 거래에 미치는 영향을 설명할 수 있나요?&quot; 모델의 기능에 대한 오해 1프롬프트 예시: &quot;다음 주 주식 시장을 예측해 주세요.&quot; ChatGPT-4는 고급 기능이지만 미래를 예측하거나 실시간 데이터를 제공할 수는 없습니다. 따라서 사용자의 기대치를 모델의 실제 기능에 맞추는 것이 중요합니다. 1개선된 프롬프트: &quot;일반적으로 주식 시장 변동에 영향을 미치는 요인을 설명할 수 있나요?&quot; 지나치게 복잡하거나 혼란스러운 프롬프트 1프롬프트 예시: &quot;계산 복잡성과 분자 시뮬레이션을 고려할 때, 새로운 의약품 개발에 양자 컴퓨팅이 어떻게 사용되나요?&quot; 자세한 프롬프트는 좋지만 지나치게 복잡한 프롬프트는 혼란을 줄 수 있습니다. 쿼리를 더 간단하고 집중적인 질문으로 세분화하는 것이 좋습니다. 1개선된 프롬프트: &quot;제약 연구에서 양자 컴퓨팅의 역할은 무엇인가요?&quot; 이제부터는 ChatGPT-4가 대화를 기억하고 구축해 나가면서 첫 번째 프롬프트를 취소하지 않고 계속 프롬프트할 수 있습니다. 문맥 단서 무시하기 1프롬프트 예시: &quot;Python 코드를 설명해 주세요.&quot; 문맥이 없으면 모델은 사용자가 어떤 특정 Python 코드를 언급하는지 알 수 없습니다. 컨텍스트를 제공하면 더 정확한 답변을 얻는 데 도움이 됩니다. 1개선된 프롬프트: &quot;목록을 정렬하기 위한 다음 Python 코드 스니펫을 설명해 주시겠어요?&quot; 모델이 개인의 선호도나 경험을 이해하기를 기대하는 경우 1프롬프트 예시: &quot;내가 가장 좋아하는 영화는 무엇인가요?&quot; ChatGPT-4는 사용자에 대한 개인적인 지식을 가지고 있지 않습니다. 모델이 사용자의 개인적 선호도나 경험을 알고 있다고 가정하는 프롬프트는 피하세요. 대신 사용자가 먼저 해당 정보를 제공하면 됩니다. 1개선된 프롬프트: &quot;내가 좋아하는 &#39;백 투 더 퓨처&#39;, &#39;노팅힐&#39;, &#39;오피스 스페이스&#39;와 비슷한 인기 영화를 추천해 줄 수 있나요?&quot; 결론 프롬프트 제작 시 이러한 일반적인 실수를 피하면 ChatGPT-4 사용 경험이 향상될 뿐만 아니라 기능을 보다 효과적으로 탐색할 수 있습니다. 명확하고 집중적이며 상황에 맞는 프롬프트를 만들면 모델로부터 통찰력 있고 정확한 응답을 얻을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT-4","slug":"ChatGPT-4","permalink":"http://hgko1207.github.io/tags/ChatGPT-4/"},{"name":"초보자 팁","slug":"초보자-팁","permalink":"http://hgko1207.github.io/tags/%EC%B4%88%EB%B3%B4%EC%9E%90-%ED%8C%81/"}]},{"title":"2024년에 꼭 알아야 할 최고의 AI 디자인 도구","slug":"ai-13","date":"2024-01-30T04:46:32.000Z","updated":"2024-02-05T15:16:57.663Z","comments":true,"path":"2024/01/30/ai-13/","link":"","permalink":"http://hgko1207.github.io/2024/01/30/ai-13/","excerpt":"","text":"최신 AI 도구를 자신의 워크플로우에 통합함으로써 더 빠르고 스마트하게 작업하고 경쟁에서 앞서 나갈 수 있습니다. 이 글에서는 AI를 활용하여 다자인에 대해 새로운 차원으로 끌어올릴 수 있었던 기술과 리소스를 공유하고자 합니다. 아이디어 브레인스토밍부터 완성도 높은 결과물 제작까지, AI는 창작 과정에서 없어서는 안 될 자산이 되었습니다. Upscale을 사용하여 쉽게 이미지 크기 조정하기 https://upscales.ai/ko 디자이너는 전문가용으로 사용하기에 적합하지 않은 저해상도 이미지로 작업해야 하는 경우가 많습니다. 이미지를 손으로 힘들게 조정하는 대신 이제 무료 AI 도구인 Upscale을 사용하여 품질 저하 없이 이미지를 즉시 확대할 수 있습니다. Upscale 웹사이트에 이미지를 업로드한 후 업스케일링 유형과 원하는 크기를 선택하기만 하면 됩니다. 단 한 번의 클릭만으로 Upscale의 고급 AI 알고리즘이 딥러닝 기술을 통해 이미지를 이미지를 개선합니다. 그 결과 목업과 프레젠테이션에 사용할 수 있는 고해상도 버전이 완성됩니다. 이전에는 픽셀화된 이미지를 수동으로 확대하는 데 들였던 수많은 시간을 Upscale을 통해 절약할 수 있었습니다. 사용자 친화적인 인터페이스와 사용자 지정 가능한 옵션 덕분에 이미지 업스케일링에 필요한 모든 것을 해결해 줍니다. Khroma로 손쉽게 완벽한 색상 팔레트 찾기 https://www.khroma.co/ Khroma의 독창적인 인터페이스를 통해 좋아하는 색상을 선택하기만 하면 직관적으로 색상 팔레트를 만들 수 있습니다. Khroma의 방대한 라이브러리에서 제가 좋아하는 50가지 색상을 선택하면 도구의 알고리즘이 제가 선택한 색상을 분석하고 무한한 팔레트 옵션을 생성하여 탐색하고 사용자 지정할 수 있습니다. 예전에는 몇 시간이 걸리던 작업을 Khroma를 사용하면 몇 분 만에 완성할 수 있습니다. 새 프로젝트를 시작할 때마다 다양한 색 구성표를 빠르게 탐색하는 데 없어서는 안 될 리소스가 되었습니다. Fontjoy를 사용한 손쉬운 글꼴 페어링 https://fontjoy.com/ 프로세스의 첫 번째 단계를 Fontjoy의 AI 역량에 맡기세요. “Generate” 버튼을 한 번만 클릭하면 Fontjoy가 제 필요에 맞는 새로운 글꼴 페어링 세트를 생성합니다. 그런 다음 Fontjoy의 직관적인 편집 도구를 사용하여 페어링을 쉽게 다듬을 수 있습니다. Fontjoy는 방대한 글꼴 라이브러리에서 그리기 때문에 미처 생각하지 못했던 다양한 옵션을 실험해 볼 수 있습니다. Fontjoy는 타이포그래피 효과가 있는 디자인을 효율적으로 개발하는 데 획기적인 역할을 했습니다. Gamma로 프레젠테이션 디자인 간소화 https://gamma.app/?lng=ko 프레젠테이션 주제와 키워드를 입력하면 Gamma의 알고리즘이 작성된 콘텐츠, 이미지 및 그래픽 요소로 구성된 전체 프레젠테이션 데크를 생성합니다. Gamma의 AI 기능 덕분에 평소보다 훨씬 짧은 시간 안에 프레젠테이션을 즉시 개념화하고 만들 수 있습니다. 동적으로 생성된 콘텐츠와 디자인은 완벽한 출발점이 되어 창의적인 비전에 따라 조정할 수 있습니다. Canva를 사용하여 순식간에 디자인 자산 생성하기 https://www.canva.com/ Canva의 Magic Suite 섹션에 있는 Magic Brand, Magic Media와 같은 도구를 사용해 필요한 에셋을 간단히 설명하면 Canva의 AI가 몇 초 만에 고품질의 맞춤형 옵션을 생성해줍니다. 눈길을 사로잡는 Instagram 스토리, 미니멀한 로고, 배너 광고 등 어떤 것이 필요하든 Canva의 AI가 힘든 작업을 대신 처리해 주며 더 큰 그림의 창의적인 과제에 집중할 수 있습니다. Figma 플러그인으로 일상적인 디자인 작업 자동화하기 https://www.figma.com/ 디자인 도구가 놀랍게 발전했지만, 반복적인 작업은 생산성과 창의력을 떨어뜨리고 있습니다. 바쁜 작업을 자동화하고 아이디어에 집중할 수 있도록 도와주는 Figma 플러그인을 사용해봅시다. Figma의 Magician 클릭 한 번으로 텍스트 설명을 멋진 시각적 자산으로 바꿔줍니다. FigGPT는 텍스트 구절을 빠르게 바꾸고, 재배열하고, 확장할 수 있도록 도와줍니다. Wireframe Designer는 내가 입력한 설명을 바탕으로 즉시 앱 와이어프레임을 구축합니다. 그리고 Avatars generator는 모든 프로젝트 요구에 맞는 맞춤형 아바타 이미지를 생성합니다. 디자인 피드백 및 아이디어 도출에 ChatGPT 활용하기 https://chat.openai.com/ AI 디자인 도구도 유용하지만, ChatGPT와 같은 대화형 플랫폼에서 가장 큰 이점을 얻을 수 있다는 것을 알게 되었습니다. 진행 중인 채팅에서 특정 요구사항에 맞는 온디맨드(on-demand) 피드백과 안내를 받을 수 있습니다. 예를 들어, 웹사이트 레이아웃에 어떻게 접근해야 할지 잘 모르겠다면 ChatGPT에 프로젝트 세부 사항을 설명하면 맞춤형 레이아웃 제안을 받을 수 있습니다. 또는 특정 UI 요소에 대한 고민이 있을 경우 ChatGPT에게 사례 연구와 디자인 고려 사항을 제시해달라고 요청합니다. AI로 눈에 띄는 입사 지원 자료 제작 경쟁이 치열한 취업 시장에서 눈에 띄는 지원서를 작성하는 것은 꿈에 그리던 디자인 직군에 취업하기 위한 열쇠가 될 수 있습니다. 다행히 Resume Worded와 같은 AI 기반 플랫폼 덕분에 채용 담당자의 시선을 사로잡는 세련된 이력서와 LinkedIn 프로필을 만들 수 있게 되었습니다. https://resumeworded.com/ Resume Worded에 문서를 업로드하면 AI가 제 경력 수준과 분야에 맞는 맞춤형 피드백과 제안을 제공합니다. 채용 담당자가 찾는 최신 트렌드와 모범 사례에 맞춰 자료를 다듬을 수 있습니다. 중요한 직무의 경우, ChatGPT를 사용하여 맞춤형 커버레터를 작성하고 자주 묻는 질문을 시뮬레이션하여 면접을 준비하기도 합니다. AI의 미래 AI는 앞으로도 계속 발전할 것이지만, 이를 협업 도구로 받아들이는 전문가들이 성공할 것이라고 확신합니다. 크리에이티브 분야는 끊임없이 변화하고 있으며, 새로운 기술을 활용하는 데 적응하는 사람이 앞서 나갈 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"2024년","slug":"2024년","permalink":"http://hgko1207.github.io/tags/2024%EB%85%84/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"},{"name":"디자인 도구","slug":"디자인-도구","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%EB%8F%84%EA%B5%AC/"}]},{"title":"시간 낭비 그만! 더 빠르게 성과를 달성하는 데 도움이 되는 28가지 AI 도구","slug":"ai-12","date":"2024-01-29T05:51:21.000Z","updated":"2024-02-03T13:24:21.188Z","comments":true,"path":"2024/01/29/ai-12/","link":"","permalink":"http://hgko1207.github.io/2024/01/29/ai-12/","excerpt":"","text":"빠르게 변화하는 오늘날의 디지털 환경에서 인공지능은 우리가 일하고, 배우고, 소통하는 방식을 혁신적으로 바꾸고 있습니다. 이 블로그 게시물은 다양한 산업과 개인의 생산성을 재편하고 있는 가장 혁신적이고 유용한 AI 도구에 대한 최고의 가이드입니다. 업무와 개인 생활의 다양한 측면을 향상시키기 위해 각각 고유하게 설계된 광범위한 AI 기반 플랫폼 목록을 살펴봅니다. 시작하겠습니다! 🤖𝐀𝐈 𝐁𝐨𝐭🤖 ChatGPT: https://chat.openai.com/ Bing: https://www.microsoft.com/en-us/bing?ep=0&amp;es=31&amp;form=MA13FV Google Bard: https://bard.google.com/chat Claude: https://claude.ai/ 🗣𝐈𝐧𝐭𝐞𝐫𝐯𝐢𝐞𝐰𝐬 🗣 Interviewsbyai: https://interviewsby.ai/ Pramp: https://www.pramp.com/#/ Interview-warmup: https://grow.google/certificates/interview-warmup/ Yoodli: https://app.yoodli.ai/ 👨‍💻 𝐋𝐢𝐧𝐤𝐞𝐝𝐈𝐧 👩‍💻 Careerflow.ai: https://www.careerflow.ai/ PFPMaker: https://pfpmaker.com/ Crystal.ai: https://crystals.ai/ Engage.ai: https://engage-ai.co/ 🔎 𝐑𝐞𝐬𝐞𝐚𝐫𝐜𝐡 🔎 HARPA AI: https://harpa.ai/ Perplexity: https://www.perplexity.ai/ Glasp: https://glasp.co/ ChatPDF: https://www.chatpdf.com/ 👨‍🎨 𝐂𝐫𝐞𝐚𝐭𝐢𝐯𝐢𝐭𝐲 👩‍🎨 Runway: https://runwayml.com/ Pika: https://pika.art/ Midjourney: https://www.imagine.art/ Stability AI: https://stability.ai/ 🗓 𝐏𝐫𝐨𝐝𝐮𝐜𝐭𝐢𝐯𝐢𝐭𝐲🗓 Taskade: https://www.taskade.com/ AudioPen: https://audiopen.ai/ Notion: https://affiliate.notion.so/hsaconq7prdk Wand: https://wand.ai/ 🔝 위의 도구들을 사용해서 빠르게 성과를 만들어보세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"}]},{"title":"AI 디코딩: 인공 지능이 웹 개발에 미치는 영향에 대한 심층 분석","slug":"ai-11","date":"2024-01-29T05:36:35.000Z","updated":"2024-02-02T11:54:39.978Z","comments":true,"path":"2024/01/29/ai-11/","link":"","permalink":"http://hgko1207.github.io/2024/01/29/ai-11/","excerpt":"","text":"소개 인공 지능(AI)은 기술 분야에서 화두가 되어 우리가 기술을 인식하고 상호 작용하는 방식을 변화시키고 있습니다. 웹 개발 영역에서 AI의 통합은 수많은 이점을 가져다주며 웹사이트 제작 및 유지 관리에 혁신을 가져왔습니다. 이 글에서는 AI가 무엇인지 이해하고 웹 개발이라는 역동적인 분야에서 AI가 제공하는 구체적인 이점을 알아보는 여정을 시작하겠습니다. AI란 무엇인가? AI 또는 인공 지능(Artificial Intelligence)은 인간처럼 생각하고 학습하도록 프로그래밍된 기계에서 인간의 지능을 시뮬레이션하는 것을 말합니다. 컴퓨터 과학의 이 분야는 일반적으로 인간의 지능이 필요한 작업을 수행할 수 있는 지능형 에이전트를 만드는 것을 목표로 합니다. 머신 러닝: AI의 핵심 AI의 핵심에는 시스템이 경험을 통해 학습하고 개선할 수 있도록 하는 하위 집합인 머신 러닝이 있습니다. 이 학습 과정에는 방대한 데이터 세트에 대한 모델 학습이 포함되며, 이를 통해 AI 시스템은 명시적인 프로그래밍 없이도 예측이나 결정을 내릴 수 있습니다. 1234567891011121314151617181920# Example of a simple machine learning model in Python using scikit-learnfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import accuracy_score# Load the iris datasetiris = datasets.load_iris()X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=42)# Create a Random Forest classifierclf = RandomForestClassifier(n_estimators=100, random_state=42)clf.fit(X_train, y_train)# Make predictions on the test setpredictions = clf.predict(X_test)# Evaluate accuracyaccuracy = accuracy_score(y_test, predictions)print(f\"Accuracy: &#123;accuracy&#125;\") 웹 개발에서 AI의 이점 효율적인 코딩을 위한 스마트 자동화 AI는 반복적인 작업을 자동화하여 웹 개발을 간소화합니다. GitHub Copilot과 같은 도구는 머신러닝을 사용하여 개발자의 코드 스니펫 작성을 지원하므로 일상적인 코딩에 소요되는 시간과 노력을 줄일 수 있습니다. AI 기반 개인화로 사용자 경험 향상 웹 개발자는 사용자 데이터 분석을 위한 AI 알고리즘을 구현하여 콘텐츠를 동적으로 개인화할 수 있습니다. 예를 들어 개발자는 JavaScript 및 AI 라이브러리를 사용하여 사용자 선호도에 따라 웹사이트 콘텐츠를 조정하여 맞춤형의 매력적인 경험을 제공할 수 있습니다. 정보에 입각한 의사결정을 위한 예측 분석 AI의 예측 분석 기능은 웹 개발자는 정보에 입각한 의사결정을 내릴 수 있습니다. 개발자는 Google Analytics와 같은 도구를 통합하여 사용자 행동을 분석하고, 트렌드를 예측하고, 그에 따라 웹사이트 요소를 최적화할 수 있습니다. AI 기반 도구로 효율적인 버그 탐지 및 해결 Sentry 및 Rollbar와 같은 AI 기반 도구는 머신 러닝을 활용하여 실시간으로 버그를 감지하고 해결합니다. 이러한 도구는 패턴을 학습하여 문제를 신속하게 식별하고 해결하는 능력을 향상시킵니다. AI Insights를 통한 SEO 최적화 웹 개발자는 Yoast SEO와 같은 AI 도구를 사용하여 검색 엔진에 맞게 콘텐츠를 최적화할 수 있습니다. AI는 검색 패턴과 사용자 행동을 분석하여 귀중한 인사이트를 제공함으로써 SEO 친화적인 콘텐츠를 제작하는 데 도움을 줍니다. 결론 웹 개발에 AI를 도입하는 것은 단순한 트렌드가 아니라 개발자가 보다 효율적이고 개인화된 사용자 친화적인 웹사이트를 제작할 수 있도록 지원하는 기술 발전입니다. 웹 개발 환경에서 AI의 방대한 잠재력을 계속 탐구하고 있는 지금, 새로운 기술에 대한 최신 정보를 파악하고 AI 기반 솔루션을 통합하는 것이 웹 개발의 미래를 결정할 것입니다. AI의 힘을 받아들여 웹 사이트가 디지털 시대에 진화하는 사용자의 요구를 충족하는 역동적이고 지능적인 플랫폼으로 변모하는 모습을 지켜보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"AI 디코딩","slug":"AI-디코딩","permalink":"http://hgko1207.github.io/tags/AI-%EB%94%94%EC%BD%94%EB%94%A9/"}]},{"title":"초보자를 위한 Pandas 소개","slug":"python-5","date":"2024-01-26T14:45:16.000Z","updated":"2024-01-26T15:11:28.946Z","comments":true,"path":"2024/01/26/python-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/26/python-5/","excerpt":"","text":"Pandas는 가장 인기 있고 강력한 Python용 데이터 분석 라이브러리 중 하나입니다. 사용하기 쉬운 데이터 구조와 구조화된 데이터 작업을 위한 도구를 제공합니다. 이 글에서는 데이터 분석에 Pandas를 사용하는 방법에 대한 실용적인 소개를 살펴보겠습니다. Pandas 가져오기 Pandas를 사용하려면 먼저 Pandas를 가져와야 합니다. 1import pandas as pd 일반적으로 pd를 약어로 사용하여 Pandas를 가져오는 것이 일반적입니다. Pandas DataFrame 만들기 Pandas DataFrame은 다양한 데이터 유형(string, number, boolean 등)을 열에 저장할 수 있는 2차원 레이블이 지정된 데이터 구조입니다. 스프레드시트나 SQL 테이블과 비슷합니다. dictionary에서 간단한 DataFrame을 만들어 보겠습니다. 123data = &#123;'Name': ['John', 'Mary', 'Peter', 'Jeff', 'Bill'], 'Age': [28, 32, 47, 19, 55], 'Gender': ['Male', 'Female', 'Male', 'Male', 'Male'] 12df = pd.DataFrame(data)print(df) 123456 Name Age Gender0 John 28 Male1 Mary 32 Female2 Peter 47 Male3 Jeff 19 Male4 Bill 55 Male dictionary 키는 열 이름이 되고 값은 열의 데이터가 됩니다. 열 선택하기 dictionary 키와 같은 열 이름을 사용하여 Pandas에서 열을 선택할 수 있습니다. 12ages = df['Age']print(ages) 1234560 281 322 473 194 55Name: Age, dtype: int64 그러면 ‘Age’ 열 데이터만 포함된 Pandas Series가 반환됩니다. Pandas Series는 인덱싱된 데이터의 1 차원 배열입니다. 행 선택하기 integer 위치 또는 boolean 인덱싱을 통해 행을 선택할 수 있습니다. 처음 3개 행을 구해 보겠습니다. 1print(df[0:3]) 1234 Name Age Gender0 John 28 Male1 Mary 32 Female2 Peter 47 Male 그리고 'Age’가 30보다 큰 행은 다음과 같습니다. 1print(df[df['Age'] &gt; 30]) 1234 Name Age Gender1 Mary 32 Female2 Peter 47 Male4 Bill 55 Male CSV에서 데이터 로드하기 read_csv()를 사용하여 CSV 파일에서 DataFrame으로 데이터를 쉽게 로드할 수 있습니다. 1df = pd.read_csv('data.csv') 그러면 ‘data.csv’ 파일이 Pandas DataFrame에 로드됩니다. 날짜 구문 분석 및 누락된 값 처리와 같은 많은 추가 옵션을 지정할 수 있습니다. 기본 데이터 정리 Pandas를 사용하면 누락된 데이터를 쉽게 제거하고 지저분한 데이터를 정리할 수 있습니다. 12345678# 누락된 값이 있는 행 삭제df.dropna()# 누락된 값 채우기df.fillna(value)# 열 이름 변경df.rename(columns=&#123;'old_name': 'new_ name'&#125;) 유용한 연산 Pandas에는 데이터 정리를 빠르게 해주는 많은 벡터화된 기능이 포함되어 있습니다. 1234567891011# Age 열의 합계 계산df['Age'].sum()# Age 열의 평균 계산df['Age'].mean()# Age 열의 최대값 얻기df['Age'].max()# Age 열을 기준으로 정렬df.sort_values('Age') 데이터를 집계, 분할, 변환, 결합, 시각화하기 위한 더 많은 함수가 있습니다. 결론 지금까지 Python에서 실제 데이터 분석을 위해 Pandas를 사용하는 몇 가지 기본 사항을 다루었습니다. 핵심 내용은 다음과 같습니다. 표 형식 데이터 저장을 위한 DataFrame CSV 파일에서 데이터 읽기/쓰기 열 선택, 행 슬라이싱, boolean 인덱싱 데이터 정리, 병합, 변환을 위한 내장 메서드 제공 빠른 데이터 분석을 위한 벡터화된 연산 Pandas는 사용 편의성과 성능을 결합하여 데이터 과학 워크플로우에 없어서는 안 될 필수 요소입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","permalink":"http://hgko1207.github.io/tags/Pandas/"}]},{"title":"JavaScript 모범 사례","slug":"js-dev-14","date":"2024-01-25T06:13:15.000Z","updated":"2024-01-25T06:23:09.297Z","comments":true,"path":"2024/01/25/js-dev-14/","link":"","permalink":"http://hgko1207.github.io/2024/01/25/js-dev-14/","excerpt":"","text":"웹 개발의 근간이 되는 JavaScript는 단순한 스크립트 언어에서 복잡한 웹 애플리케이션을 제작하는 강력한 도구로 발전해 왔습니다. 이처럼 끊임없이 변화하는 환경에서는 코드 품질을 유지하고, 유지보수성을 보장하며, 성능을 최적화하는 것이 매우 중요합니다. 이 글에서는 JavaScript 개발자가 효율적이고 유지 관리가 용이하며 고품질의 코드를 작성하는 데 도움이 되는 모범 사례를 살펴봅니다. 실제 사례를 살펴보고 그 결과를 설명하여 이러한 관행이 관련성을 유지하고 지속적으로 유지될 수 있도록 합니다. 1. 읽기 쉽고 일관된 코드 예시 1234567891011// Badfunction calc(d) &#123; let r = 3.14; return d * r;&#125;// Goodfunction calculateArea(diameter) &#123; const PI = 3.14; return diameter * PI;&#125; 두 번째 함수는 가독성을 위해 명확한 이름(calculateArea)과 상수(PI)를 사용합니다. 설명적인 변수 이름과 상수를 사용하면 코드가 스스로 설명 가능해지기 때문에 가독성과 유지보수성이 향상됩니다. 2. 전역 변수 피하기 예시 123456789101112131415// Badlet counter = 0;function increment() &#123; counter += 1;&#125;// Goodfunction createCounter() &#123; let counter = 0; return function increment() &#123; counter += 1; return counter; &#125;;&#125; 두 번째 예제는 클로저를 사용하여 전역 변수를 피합니다. 이렇게 하면 코드의 다른 부분과 실수로 간섭하는 것을 방지하여 버그를 줄이고 유지보수성을 개선할 수 있습니다. 3. 효율적인 DOM 조작 예시 1234567891011// Badfor (let i = 0; i &lt; 1000; i++) &#123; document.getElementById('container').innerText += i;&#125;// Goodlet content = '';for (let i = 0; i &lt; 1000; i++) &#123; content += i;&#125;document.getElementById('container').innerText = content; 이 모범 사례는 모든 변경 사항을 결합하여 한 번에 적용함으로써 DOM 조작을 최소화하여 성능을 향상시킵니다. 4. 함수형 프로그래밍 활용 예시 12345678910// Badlet numbers = [1, 2, 3, 4, 5];let doubled = [];for (let i = 0; i &lt; numbers.length; i++) &#123; doubled.push(numbers[i] * 2);&#125;// Goodlet numbers = [1, 2, 3, 4, 5];let doubled = numbers.map((number) =&gt; number * 2); 두 번째 예제에서 .map()을 사용하면 배열 변환에 대한 간결하고 선언적인 접근 방식을 제공하여 가독성과 유지보수성을 향상시킬 수 있습니다. 5. 효율적인 오류 처리 예시 123456789101112131415161718// Badfunction fetchData() &#123; try &#123; // Fetch data &#125; catch (error) &#123; console.log('Error:', error); &#125;&#125;// Goodfunction fetchData() &#123; try &#123; // Fetch data &#125; catch (error) &#123; console.error('Error fetching data:', error); // Handle error appropriately &#125;&#125; 이 예시에는 디버깅을 돕고 보다 견고한 코드를 보장하는 상세한 오류 로깅 및 처리가 포함됩니다. 결론 JavaScript 개발 영역에서 모범 사례를 준수하는 것은 단순히 작동하는 코드를 작성하는 것만이 아닙니다. 읽기 쉽고, 유지 관리가 용이하며, 성능이 우수한 코드를 작성하는 것입니다. 가독성에 초점을 맞추고, 전역 변수를 피하고, DOM 조작을 최적화하고, 함수형 프로그래밍을 수용하고, 효과적인 오류 처리를 사용함으로써 개발자는 JavaScript 코드가 시간의 흐름에 따라 끊임없이 변화하는 웹 개발 환경에 맞춰 발전할 수 있도록 할 수 있습니다. 코드의 품질은 코드가 무엇을 할 수 있는지에 의해서만 측정되는 것이 아니라 어떻게 달성하는지에 의해서도 측정된다는 점을 기억하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"모범사례","slug":"모범사례","permalink":"http://hgko1207.github.io/tags/%EB%AA%A8%EB%B2%94%EC%82%AC%EB%A1%80/"}]},{"title":"2024년 AI 트렌드와 전망","slug":"ai-10","date":"2024-01-23T02:38:34.000Z","updated":"2024-01-23T03:07:58.751Z","comments":true,"path":"2024/01/23/ai-10/","link":"","permalink":"http://hgko1207.github.io/2024/01/23/ai-10/","excerpt":"","text":"2024년에 흥미로운 AI의 세계로 나아가기 위해서는 이 혁신적인 분야를 형성하는 중요한 트렌드와 기대치를 이해하는 것이 중요합니다. 이 글에서는 올해를 인공지능 분야에서 중추적인 해로 만들 최신 개발, 기술 및 사용 사례에 대해 자세히 살펴봅니다. 포괄적인 모델 출시 및 개선 2024년 AI 분야에서 가장 눈에 띄는 트렌드 중 하나는 포괄적인 AI 모델의 지속적인 발전입니다. ChatGPT4 및 해당 도구와 같은 이러한 모델은 이러한 모델은 추론과 상식적인 응용 분야에서 상당한 개선을 거쳤습니다. 인간과 유사한 텍스트를 이해하고 생성하는 데 점점 더 능숙해지면서 콘텐츠 생성부터 고객 지원에 이르기까지 다양한 애플리케이션에서 매우 유용하게 활용되고 있습니다. 오픈 소스 AI 발전 오픈 소스(Open-Source) AI 커뮤니티는 이 분야의 발전을 주도하는 데 중요한 역할을 해왔습니다. 2024년에는 오픈소스 AI 모델 내에서 추론과 상식적인 응용 분야에서 더욱 놀라운 만한 발전을 기대할 수 있습니다. 이러한 AI 기술의 민주화는 전 세계 수많은 개발자들의 공헌 덕분에 중소기업이 운영에서 AI의 힘을 활용할 수 있도록 지원합니다. 소규모 AI 모델의 부상 포괄적인 모델이 헤드라인을 장식하고 있지만, 특정 비즈니스 애플리케이션을 위해 설계된 전문화된 소규모 AI 모델에 대한 관심도 증가하고 있습니다. 이러한 모델은 리소스 효율성이 높고 정확한 요구 사항을 해결하도록 맞춤화할 수 있습니다. 이러한 전문화된 모델을 활용하여 각 산업에서 경쟁 우위를 확보하려는 중소기업이 점점 더 많아지고 있습니다. LLama 3, Google의 Gemini Ultra 및 GPT 4.5 출시 2024년에는 Meta, Google, OpenAI와 같은 거대 기술 기업에서 중요한 개발이 이루어질 것으로 예상됩니다. Meta의 LLama 3, Google의 Gemini Ultra, OpenAI의 GPT 4.5는 언어 모델의 기능을 재정의할 것으로 예상됩니다. 이러한 모델은 향상된 자연어 이해력을 제공하여 인간과 기계의 상호 작용을 더욱 원활하고 직관적으로 만들 것입니다. AI 안전에 집중 AI가 계속 진화함에 따라 안전성을 확보하는 것이 무엇보다 중요해지고 있습니다. 2024년의 기초 연구는 보다 안전한 AI 아키텍처와 훈련 방법을 개발하는 데 초점을 맞출 것입니다. AI 안전에 대한 이러한 노력은 첨단 AI 시스템과 관련된 잠재적인 위험을 완화하고, 다양한 산업 분야에 걸쳐 AI 애플리케이션에 대한 신뢰와 안정성을 높이는 것을 목표로 합니다. 맞춤형 AI 모델을 통한 개인정보 보호 강화 AI의 확산과 함께 개인정보 보호에 대한 우려도 커지고 있습니다. 2024년에는 맞춤형 AI 모델이 이러한 우려를 해결하는 데 중추적인 역할을 할 것입니다. 기업이 특정 개인정보 보호 요구사항에 맞는 AI 솔루션을 개발할 수 있도록 지원함으로써 기업은 데이터 보호를 보장하는 동시에 AI 기반 인사이트의 이점을 활용할 수 있습니다. Vision AI의 발전 Vision AI의 신뢰성과 적용은 2024년에 크게 발전할 것입니다. 이 기술의 향상된 기능은 의료, 자율 주행 차량, 감시와 같은 분야에서 활용될 것입니다. 향상된 정확도와 실시간 분석 기능으로 비전 AI는 다양한 산업 분야에서 필수적인 도구가 될 것입니다. 멀티모달 AI: 텍스트와 음성을 뛰어넘다 2024년은 텍스트, 음성, 이미지, 비디오 분석을 통합하는 멀티모달(Multimodal) AI가 널리 채택될 것입니다. 이러한 전체적인 접근 방식을 통해 보다 포괄적인 고객 인사이트, 고급 콘텐츠 제작, 향상된 제품 디자인이 가능해집니다. 소매, 마케팅, 엔터테인먼트와 같은 업계는 이러한 다차원적 AI를 통해 고객에게 더욱 몰입감 있고 개인화된 경험을 제공할 수 있어 엄청난 이점을 누릴 수 있습니다. 2024년 비즈니스를 위한 혁신적인 AI 활용 사례 개인화된 고객 서비스를 위한 더 스마트한 챗봇 고객의 질문에 답할 뿐만 아니라 과거 구매 내역을 기반으로 개인화된 추천을 제공하는 디지털 비서를 상상해 보세요. 2024년에는 AI 기반 챗봇이 고객 서비스를 한 단계 더 발전시켜 선제적인 지원을 제공하고 전반적인 고객 경험을 향상시킬 것입니다. AI 기반 자동화를 통한 운영 간소화 약속 예약부터 재고 관리까지, AI 도구는 일상적인 작업을 자동화하여 기업가들이 성장 전략에 집중할 수 있는 귀중한 시간을 확보해 줍니다. 이러한 자동화 혁명은 모든 규모의 비즈니스에서 효율성 향상과 비용 절감으로 이어질 것입니다. AI 분석을 통한 마케팅 인사이트 AI는 고객 데이터를 분석하여 트렌드를 예측하고 제한된 예산으로도 효과적으로 마케팅 전략을 맞춤화함으로써 마케팅에 혁명을 일으킬 것입니다. 기업은 소비자 행동에 대한 더 깊은 통찰력을 얻어 타겟 고객과 공감할 수 있는 타겟팅 캠페인을 제작할 수 있게 될 것입니다. 의료 진단 및 개인 맞춤형 의료 의료 분야에서 AI의 역할은 관리 업무 이상으로 확대될 것입니다. AI 알고리즘은 의료 이미지를 탁월한 정확도로 분석하여 질병을 조기에 발견하고 진단하는 데 도움을 줄 것입니다. 또한 AI는 유전자 연구에 기여하여 개인 맞춤형 치료 계획의 개발을 촉진하고 정밀 의학 분야를 발전시킬 것입니다. 결론 결론적으로, 2024년은 AI 분야에서 중추적인 해가 될 것입니다. 포괄적인 모델, 오픈소스 AI, 전문화된 모델의 발전, 안전과 개인정보 보호에 대한 새로운 관심으로 다양한 분야의 기업들은 혁신을 주도하고 운영을 개선하기 위해 AI의 혁신적 힘을 활용할 것입니다. 개인화된 고객 서비스부터 자동화된 운영까지, AI는 앞으로 우리가 일하고, 생활하고, 상호 작용하는 방식에 혁신을 가져올 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"2024년","slug":"2024년","permalink":"http://hgko1207.github.io/tags/2024%EB%85%84/"},{"name":"트렌드","slug":"트렌드","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A0%8C%EB%93%9C/"},{"name":"전망","slug":"전망","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%EB%A7%9D/"}]},{"title":"생성형 AI(Generative AI)의 힘과 가능성 소개","slug":"ai-9","date":"2024-01-22T06:43:44.000Z","updated":"2024-01-22T14:27:51.895Z","comments":true,"path":"2024/01/22/ai-9/","link":"","permalink":"http://hgko1207.github.io/2024/01/22/ai-9/","excerpt":"","text":"생성형 AI(Generative AI)는 인간 예술가처럼 독창적인 콘텐츠를 만들 수 있는 흥미로운 신기술입니다. 규칙을 따르는 일반 AI와 달리, 생성형 AI는 데이터에서 찾은 패턴을 기반으로 완전히 새로운 것을 찾아낼 수 있습니다. 즉, 글쓰기, 이미지, 음악 등을 스스로 생성할 수 있는 AI입니다. 생성형 AI는 어떻게 작동하나요? 생성형 AI는 인간의 뇌를 모델로 한 컴퓨팅 시스템인 신경망을 사용합니다. 두 가지 중요한 유형은 GAN(Generative Adversarial Networks)과 VAE(Varitional Auto-Encoder)입니다. GAN에는 콘텐츠를 생성하는 생성기와 콘텐츠가 얼마나 사실적인지 판단하는 판별기가 있습니다. 이들은 서로 경쟁함으로써 매우 설득력 있는 결과물을 만들어냅니다. VAE는 데이터의 구조를 학습하여 유사한 새로운 콘텐츠를 생성하는 데 중점을 둡니다. 생성형 AI의 실제 사례 Google의 DeepDream - AI를 사용하여 이미지를 변형하고 향상시켜 꿈속에서나 볼 수 있는 몽환적인 장면을 연출합니다. OpenAI의 GPT-3 - 사용자가 입력한 내용에 따라 놀라울 정도로 인간과 유사한 텍스트를 작성합니다. StyleGAN - 매우 사실적인 사람의 얼굴과 예술 작품을 생성합니다. 다양한 유형의 생성형 AI 모델 GAN- 사실적인 이미지, 동영상 등을 생성하는 데 적합합니다. VAE - 데이터의 패턴을 학습하여 새로운 콘텐츠를 생성합니다. 이미지, 압축에 사용됩니다. RNN - 텍스트나 음악과 같은 시퀀스를 생성합니다. Transformers - GPT-3와 같은 모델에서 사람과 유사한 텍스트를 생성하는 데 사용됩니다. 생성형 AI의 미래 생성형 AI는 AI가 할 수 있는 일을 새롭고 흥미로운 방식으로 재구성하고 있습니다. 기술이 발전함에 따라 예술, 글쓰기, 콘텐츠 제작과 같은 분야의 가능성은 무한해 보입니다. 생성형 AI의 미래는 밝습니다! 생성형 AI는 어디에 사용되고 있나요? 생성형 AI는 요즘 모든 곳에서 사용되고 있습니다. 다음은 생성형 AI가 활용되고 있는 몇 가지 멋진 방법들입니다. 예술 - StyleGAN과 같은 GAN 모델은 사람이 만든 것처럼 보이는 독창적인 예술 작품을 만들어냅니다. 심지어 일부 아티스트는 AI가 생성한 작품을 판매하기도 합니다. 쓰기 - GPT-3와 같은 도구는 몇 가지 프롬프트에 따라 기사, 스토리, 심지어 코드까지 자동 생성할 수 있습니다. 콘텐츠 초안을 빠르게 작성하는 데 유용할 수 있습니다. 음악 - Boomy 및 Amadeus Code와 같은 앱을 사용하면 흥얼거리거나 원하는 내용을 설명하는 것만으로 독창적인 음악을 생성할 수 있습니다. 비디오/영화 - GAN은 사실적인 가짜 얼굴, 장면, 심지어 전체 동영상을 생성할 수 있습니다. 이 기술은 딥페이크 동영상을 제작하는 데 사용되고 있습니다. 의료 - VAE는 환자의 개인정보를 보호하면서 의료 AI 모델을 훈련하기 위한 합성 환자 데이터를 생성하는 데 사용되고 있습니다. 게임 - 게임 개발자는 환경, 텍스처, 3D 모델과 같은 세부적인 게임 자산을 자동으로 생성하는 데 생성형 AI를 사용하고 있습니다. 생성형 AI의 다양한 얼굴 생성형 AI는 모델 유형에 따라 다양한 능력을 발휘합니다: 텍스트 생성기는 코드, 기사, 시, 농담, 가짜 뉴스(yikes), 심지어 심리 치료 챗봇까지 작성할 수 있습니다. 이미지 생성기는 로고, 예술 작품, 건물 디자인, 실존하지 않는 사람의 사진을 만들고 다양한 스타일로 사진을 편집할 수 있습니다. 3D 모델 생성기는 가구, 의류, 차량, 건축 설계 및 비디오 게임 자산을 만듭니다. 음악 생성기는 독창적인 노래와 백킹 트랙을 만들고 음악을 취향에 맞게 맞춤화합니다. 비디오 생성기는 딥페이크, 애니메이션을 만들고 텍스트 캡션이나 아트워크를 비디오로 변환합니다. 생성형 AI의 다음 단계는 무엇입니까? 생성형 AI의 급속한 발전은 매우 흥미진진합니다. 이 기술이 계속 발전함에 따라 가능한 몇 가지 가능성을 소개합니다. 더욱 개인화된 맞춤화된 콘텐츠 - 내 취향에 맞는 음악을 만들어주고, 나만의 스타일로 글을 써주는 AI. 창의성의 민주화 - 누구나 쉽게 전문가 수준의 콘텐츠를 제작할 수 있습니다. 고급 자연어 - AI와 사람처럼 대화할 수 있습니다. 생성형 AI 보조자 - 연구, 콘텐츠 제작, 디자인 작업을 대신 수행할 수 있는 AI. 생성형 AI가 계속 진화하며 디지털 세상을 만들어가고 있는 만큼 미래는 밝아 보입니다. 생성형 AI의 윤리 생성형 AI는 무한한 창의적 가능성을 허용하지만 고려해야 할 몇 가지 윤리적 문제도 있습니다. AI로 생성된 콘텐츠 - AI가 만든 콘텐츠로 분류되어야 하나요? 실제 저작물의 일부를 복사하는 경우 저작권 문제가 발생하나요? 잘못된 정보 - AI는 가짜 뉴스, 사기, 스팸을 대규모로 자동화할 수 있습니다. 보호 장치가 필요합니다. 일자리 손실 - 창작자, 작가, 예술가는 자동화로 인해 일자리를 잃을 수 있습니다. 하지만 더 많은 사람들이 창의력을 발휘할 수 있는 기회를 제공하기도 합니다. 편향성 - 모델 학습에 사용되는 데이터 세트는 주의 깊게 확인하지 않으면 유해한 편향을 전달할 수 있습니다. 보안 - 온라인에서 타인의 신원을 사칭하는 등 악의적으로 사용될 가능성이 있습니다. 이러한 위험에도 불구하고 생성형 AI는 윤리적으로 사용된다면 압도적으로 긍정적인 영향을 미칠 수 있다고 생각합니다. 다음은 이를 위한 몇 가지 방법입니다. 책임감 있는 데이터 소싱 - 유해한 편견을 최소화하기 위해 학습 데이터를 신중하게 선별합니다. 투명성 - AI는 적절한 경우 사람이 만든 콘텐츠가 아님을 밝혀야 합니다. 인간 증강에 집중 - AI를 대체물이 아닌 창의성 도구로 활용하세요. 규범 개발 - 생성형 AI를 책임감 있게 사용하기 위한 윤리적 기준을 수립합니다. 접근성 - AI 제작 도구에 더 많은 사람들이 접근할 수 있도록 합니다. 기술 산업이 윤리적 생성형 AI를 우선순위로 삼는다면, 사람들에게 힘을 실어주고 사회를 놀라운 방식으로 발전시킬 수 있을 것으로 기대합니다. 여기에는 창의성과 혁신의 잠재력이 무궁무진합니다. 하지만 우리는 이를 책임감 있게 육성해야 합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"Generative AI","slug":"Generative-AI","permalink":"http://hgko1207.github.io/tags/Generative-AI/"},{"name":"생성형 AI","slug":"생성형-AI","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%84%B1%ED%98%95-AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"}]},{"title":"JavaScript 이벤트 처리: 기본부터 고급 기법까지","slug":"js-dev-13","date":"2024-01-21T15:05:37.000Z","updated":"2024-01-21T15:32:36.644Z","comments":true,"path":"2024/01/22/js-dev-13/","link":"","permalink":"http://hgko1207.github.io/2024/01/22/js-dev-13/","excerpt":"","text":"역동적인 웹 개발 세계에서 JavaScript는 대화형 및 반응형 사용자 경험을 가능하게 하는 초석 기술입니다. 이러한 상호작용의 기본 요소는 클릭, 키보드 입력 등과 같은 사용자 동작에 JavaScript가 반응하는 메커니즘인 이벤트 처리입니다. 이 글에서는 프레임워크나 라이브러리에 의존하지 않고 순수 JavaScript에 집중하여 콘텐츠가 항상 최신 상태를 유지할 수 있도록 기본 개념부터 고급 기법까지 JavaScript 이벤트 처리에 대해 자세히 살펴봅니다. JavaScript의 이벤트 처리 이해 이벤트란 무엇입니까? JavaScript에서 이벤트는 브라우저에서 감지되는 동작 또는 발생으로, JavaScript를 사용하여 응답할 수 있습니다. 일반적인 이벤트에는 클릭( click), 키 누르기(keydown) 또는 페이지 로드(load)가 포함됩니다. Event Listener Event Listener는 특정 이벤트가 발생하기를 기다리는 JavaScript의 함수입니다. Event Listener는 모든 DOM(Document Object Model) 객체에 첨부할 수 있습니다. 구문은 간단합니다: 1element.addEventListener(event, function); 예를 들어 버튼의 클릭 이벤트를 수신하려면 다음과 같이 하세요. 1&lt;button id=\"myButton\"&gt;Click me&lt;/button&gt; 123document.getElementById('myButton').addEventListener('click', function () &#123; alert('Button clicked!');&#125;); 버튼이 클릭되면 경고창에 &quot;Button clicked!&quot;가 표시됩니다. 고급 이벤트 처리 기술 이벤트 전파: 버블링과 캡처 이벤트 전파(Event Propagation)는 이벤트가 DOM 트리를 통해 이동하는 방식입니다. 이벤트 전파에는 버블링(Bubbling)과 캡처(Capturing)의 두 단계가 있습니다. 버블링 단계에서는 이벤트가 대상 요소에서 루트까지 버블링됩니다. 캡처 단계에서는 루트에서 대상 요소로 이벤트가 내려갑니다. addEventListener 메서드에서 단계를 지정할 수 있습니다. 1element.addEventListener(event, function, useCapture); useCapture: Boolean 값으로, true면 이벤트 핸들러가 캡처 단계에 설정되고 false(기본값)면 버블링 단계에 설정됨을 의미합니다. 기본 동작 방지 일부 이벤트에는 양식 제출과 같은 기본 동작이 있습니다. event.preventDefault()를 사용하여 이를 방지할 수 있습니다. 1234document.getElementById('myForm').addEventListener('submit', function (event) &#123; event.preventDefault(); // Additional code here&#125;); 이렇게 하면 양식이 기존 방식으로 제출되는 것을 방지하고 대신 JavaScript를 사용하여 양식 데이터를 처리할 수 있습니다. 이벤트 위임 이벤트 위임(Event Delegation)은 단일 이벤트 리스너를 사용하여 하위 요소에 대한 특정 유형의 모든 이벤트를 관리하는 기술입니다. 이는 동적으로 추가된 요소에 대한 이벤트를 처리하는 데 특히 유용합니다. 12345&lt;ul id=\"myList\"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;!-- More items --&gt;&lt;/ul&gt; 12345document.getElementById('myList').addEventListener('click', function (event) &#123; if (event.target.tagName === 'LI') &#123; alert('Item clicked: ' + event.target.innerHTML); &#125;&#125;); 목록(ul) 항목을 클릭하면 해당 항목(li)의 내용을 보여주는 경고창이 보여집니다. 결론 JavaScript 이벤트 처리는 웹 개발자의 무기고에 있는 강력한 도구입니다. 기본적인 이벤트 리스너부터 이벤트 전파 및 위임과 같은 복잡한 기술까지, 사용자 상호작용에 대한 엄청난 제어 기능을 제공합니다. 이러한 개념을 이해하는 것은 반응성이 뛰어나고 사용자 친화적인 웹 애플리케이션을 구축하는 데 중요합니다. 웹 기술이 발전함에 따라 JavaScript 이벤트 처리에 대한 이러한 기본 원칙은 관련 분야의 모든 개발자에게 여전히 중요한 기초 지식으로 남아 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"이벤트","slug":"이벤트","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"}]},{"title":"무료라고는 믿기지 않을 10가지 AI 도구","slug":"ai-8","date":"2024-01-19T01:01:28.000Z","updated":"2024-01-26T01:10:40.727Z","comments":true,"path":"2024/01/19/ai-8/","link":"","permalink":"http://hgko1207.github.io/2024/01/19/ai-8/","excerpt":"","text":"일상 업무를 변화시키는 무료 AI 도구 AI는 빠르게 우리 일상의 일부가 되어가고 있습니다. 챗봇에서 가상 비서에 이르기까지, AI는 이제 우리의 일상이 되었습니다. AI가 계속 발전함에 따라 개발자들은 이 기술을 활용하여 창의력을 향상시키는 놀라운 무료 도구를 만들고 있습니다. 이 글에서는 창의성과 생산성을 높여줄 수 있는 무료 AI 도구 10가지를 소개합니다. 작가, 디자이너, 음악가 또는 영감을 얻고자 하는 모든 분들을 위한 AI 도구가 준비되어 있습니다. 오늘날의 소극적 소득 경제에서 AI를 활용하는 방법에 대한 가이드를 확인해 보시기 바랍니다. 1. Perplexity AI — 개성을 갖춘 스마트 검색 엔진 온라인에서 정보를 검색하는 것은 종종 좌절의 연속처럼 느껴질 수 있습니다. 검색 결과가 너무 모호하거나, 너무 압도적이거나, 너무 관련이 없는 경우가 많기 때문입니다. Perplexity AI는 대화형 검색 엔진을 통해 이러한 문제를 해결하고자 합니다. OpenAI의 GPT 자연어 처리로 구동되는 Perplexity는 자연어 쿼리를 이해합니다. 검색창에 질문을 입력하고 Enter 키를 누르세요. Perplexity는 인터넷을 검색하여 간결하고 정확한 답변을 인용된 출처와 함께 제공합니다. 이 검색 엔진은 특히 PDF에 액세스하여 분석할 수도 있습니다. 기존 검색 엔진에 비해 Perplexity가 빠르고 효율적입니다. 마치 실제 사람과 대화하는 것처럼 느껴집니다. 또한 인용된 출처를 통해 신뢰할 수 있는 곳에서 나온 정보라는 확신이 듭니다. 전반적으로 Perplexity AI를 사용하면 온라인에서 정보를 검색하는 것이 부드럽고 스마트하며 수월하게 느껴집니다. 복잡한 질문에 대한 자세한 답변을 찾고 조사할 때 자주 이용하고 있습니다. 2. Google Earth Studio - 시네마틱 가상 투어 제작하기 도시, 랜드마크, 자연 경관 위를 손쉽게 비행하는 것을 꿈꿔본 적이 있나요? Google Earth Studio를 사용하면 멋진 영화 같은 가상 투어를 쉽게 만들 수 있습니다. Earth Studio를 사용하면 위성 사진, 지형, 3D 건물 등 Google의 방대한 2D 및 3D 글로벌 이미지에 액세스할 수 있습니다. 그런 다음 이 콘텐츠를 사용하여 지점 간을 매끄럽게 이동하는 독특한 애니메이션 동영상을 제작할 수 있습니다. 애니메이션 기능은 매우 강력합니다. 카메라 움직임, 타이밍, 각도 및 전환을 사용자 지정할 수 있는 다양한 옵션이 있습니다. Earth Studio는 전문 애니메이션 및 모션 그래픽 도구와 유사한 직관적인 인터페이스로 설계되었습니다. 사전 경험이 없더라도 독특한 가상 투어 애니메이션을 빠르게 시작할 수 있습니다. &quot;빠른 시작&quot;을 통해 단 몇 분 만에 쉽게 동영상을 제작할 수 있는 템플릿을 제공합니다. 부동산을 소개하거나 이국적인 여행을 계획하거나 삼림 벌채와 같은 글로벌 이슈를 강조하고 싶을 때, Earth Studio를 사용하면 Google의 탁월한 지리 공간 이미지로 영화 같은 시각적 내러티브를 만들 수 있습니다. 3. Sunno AI — 가사를 맞춤 멜로디로 바꾸기 Sunno AI를 사용하면 텍스트를 보컬과 악기 멜로디가 포함된 완전한 오디오 트랙으로 바꿀 수 있습니다. Sunno AI를 사용하려면 Discord 서버에 가입하고 “/synth” 명령 뒤에 가사를 입력하기만 하면 됩니다. Sunno의 고급 AI는 가사에 맞는 독특한 멜로디와 보컬 트랙을 즉시 생성합니다. 놀라운 점은 사용자 지정 기능에 있습니다. 음계, 템포, 악기 등을 조정하여 가사에 맞는 완벽한 분위기를 만들 수 있습니다. 이 정도 수준의 제어는 다른 어떤 AI 작곡 도구와도 비교할 수 없는 수준입니다. 보통 몇 시간이 걸리는 음악 작업도 단 몇 분 만에 라디오 방송용 곡을 만들 수 있습니다. 영감이 떠오르지 않거나 간단한 곡 아이디어가 떠오를 때마다 이 도구를 사용하면 도움이 됩니다. 4. Luma AI — 사실적인 3D 모델 제작이 쉬워집니다. Luma AI는 무료 모바일 앱으로써 스마트폰 카메라만 사용해 실제 물체의 사실적인 3D 모델을 빠르게 캡처할 수 있습니다. Luma AI는 고급 3D 그래픽의 레이 트레이싱과 유사하게 작동하는 고급 AI 기술인 신경 방사 필드(Neural radiance field)를 사용합니다. 아무 물체나 몇 번 동그라미를 치기만 하면 Luma의 AR 오버레이를 통해 프로세스를 안내합니다. 몇 분 안에 세부적인 3D 모델을 내보낼 준비가 완료됩니다. 사진에서 바로 가져온 정확한 그림자, 반사 및 질감으로 놀랍도록 사실적인 결과물을 얻을 수 있습니다. Luma AI는 컵부터 건물 전체에 이르기까지 모든 크기의 물체를 처리할 수 있습니다. 심지어 애완동물과 관엽식물을 촬영하는 데도 사용했습니다. 3D 아티스트와 취미로 3D를 즐기는 분들을 위해 Luma AI는 3D 스캐닝과 모델링의 복잡성을 제거합니다. 누구나 실제 사물을 생생한 디지털 복제품으로 쉽게 보존할 수 있습니다. 5. LeiaPix — 3D로 사진에 생명력 불어넣기 LeiaPix는 좋아하는 2D 사진을 마법 같은 3D 애니메이션으로 변환할 수 있는 온라인 플랫폼입니다. 고급 AI 신경망으로 구동되는 LeiaPix 변환기는 사실적인 깊이와 시차를 추가하여 이미지가 화면에서 튀어나오게 만듭니다. 과정은 매우 간단합니다. 사진을 업로드하기만 하면 무료로 변환을 시작할 수 있습니다. AI는 이미지 콘텐츠를 분석하여 깊이와 상호 작용을 갖춘 3D 라이트필드를 재현합니다. 그런 다음 휴대폰, 태블릿, 스마트 TV를 포함한 모든 장치에서 생생한 사진을 볼 수 있습니다. 3D 효과는 마치 실제로 그곳에 있는 것처럼 그 순간에 빠져들게 합니다. 휴가, 이벤트, 가족과의 추억 등을 다시 추억할 수 있는 놀라운 방법입니다. 이제 특별한 추억을 생생한 3D 애니메이션으로 쉽게 변환하여 사랑하는 사람들과 공유할 수 있습니다. 6. CapCut — 간편한 시네마틱 동영상 편집 기능 스마트폰으로 동영상을 촬영하고 동영상 편집을 하는 경우 엄청나게 지루하고 시간이 많이 걸립니다. CapCut이 이를 바꿔놓았습니다. ByteDance(TikTok 제작자)가 개발한 CapCut을 사용하면 초보자도 쉽게 영화 같은 편집을 할 수 있도록 도와줍니다. CapCut에는 트리밍, 전환, 효과, 텍스트, 필터 등 여러분이 기대하는 모든 주요 기능이 있습니다. 하지만 가장 놀라운 점은 직관적인 AI 기반 편집 기능입니다. 자동 비트 동기화, 고스트 자르기, 동적 효과와 같은 스마트 기능으로 정밀한 편집을 손쉽게 할 수 있습니다. CapCut은 몇 분 안에 흔들리는 휴대폰 클립을 소셜 미디어에 올릴 수 있는 매끄러운 동영상으로 변환할 수 있습니다. AI 추천 기능으로 창의력을 발휘하는 동시에 기술적인 지루함을 해소할 수 있습니다. CapCut은 여러 플랫폼에서 원활하게 작동하므로 이동 중에도 쉽게 동영상을 초안을 작성할 수 있습니다. 소셜 미디어 전문가든 스필버그 감독을 꿈꾸는 사람이든, CapCut은 스마트한 AI 지원 도구로 가득한 완벽한 무료 동영상 편집기입니다. 7. TextFx — AI가 생성하는 글쓰기 프롬프트 TextFx는 새로운 아이디어와 창의적인 영감을 찾는 과정에서 막힌 곳을 뚫어주는 도구 중 하나가 되었습니다. 새로운 방향을 제시하도록 설계된 AI 기반 텍스트 효과의 무료 모음입니다. 음악가 Lupe Fiasco와 공동으로 제작한 TextFx에는 직유, POV 변경, 예상치 못한 스토리 방향, 약어, 감각적인 묘사 등을 위한 생성기가 포함되어 있습니다. 몇 가지 키워드를 입력하기만 하면 TextFx가 창의적인 글쓰기 프롬프트를 출력해 줍니다. 몇 초 안에 새로운 관점과 각도에서 주제를 탐색할 수 있습니다. 작가적 블록에 시달리는 모든 작가에게 TextFx는 재미있고 생산적인 브레인스토밍을 위한 완벽한 무료 도구입니다. 8. Meta AI로 움직이는 그림 정적인 스케치에 생동감을 불어넣고 싶을 때 Meta AI의 애니메이션 드로잉을 사용하면 가능합니다. 이 무료 웹 도구는 손으로 그린 ​스틱 피겨 스케치를 움직이는 캐릭터로 애니메이션화합니다. 그림을 업로드하기만 하면 애니메이션 드로잉이 자동으로 그림을 식별하고 추출하여 부드러운 애니메이션을 생성합니다. 춤, 점핑 잭, 무술 등 다양한 동작 중에서 선택할 수 있습니다. AI가 리깅과 애니메이션을 처리하므로 낙서에 개성이 넘치는 생동감을 불어넣을 수 있습니다. 이 도구는 그림을 식별하고 실제와 같은 움직임을 생성하는 데 놀라울 정도로 강력합니다. 애니메이터를 꿈꾸는 분이나 낙서하는 분이라면 정적인 스케치에 무료로 생동감을 불어넣을 수 있는 완벽한 도구입니다. 9. Google의 더 스마트해진 생성형 AI 검색 Google의 새로운 생성형 AI 검색이 매우 마음에 듭니다. 이 AI 기반 업데이트는 스마트하고 개인화된 응답으로 검색을 혁신하는 것을 목표로 합니다. 단순한 파란색 링크 대신 생성형 AI 검색은 주요 사실, 기사, 제품 추천, 후속 질문 등 사용자의 검색어에 대한 맞춤형 개요를 제공합니다. 이러한 개요는 고급 언어 모델을 사용하여 즉시 생성됩니다. 단순히 알고리즘 결과를 표시하는 것이 아니라 Google이 진정으로 사용자의 말에 귀 기울이고 응답하는 것처럼 느껴집니다. 이제 훨씬 더 빠르게 답을 찾고 새로운 검색 경로로 뛰어들 수 있다는 점이 마음에 듭니다. Google은 인사이트를 선제적으로 표시해줘서 토끼굴에서 클릭하는 시간을 절약해줍니다. 검색과 학습을 향상시키기 위해 AI를 훌륭하게 활용하고 있습니다. 전반적으로 생성형 AI 검색을 통해 Google을 더욱 대화적이고 직관적이며 도움이 되는 곳으로 느끼게 해줍니다. 혁신적인 인공 지능이 주도하는 검색의 미래를 엿볼 수 있습니다. 10. Futurepedia 새로운 AI 혁신이 끊임없이 등장하기 때문에 최신 정보를 파악하기 어려울 수 있습니다. 이럴 때 필요한 것이 바로 Futurepedia입니다. 이 웹사이트는 50개 이상의 카테고리에 걸쳐 3,500개 이상의 AI 도구에 대한 광범위한 디렉토리 역할을 합니다. Futurepedia는 매일 업데이트되는 뉴스를 통해 최신 AI 개발 동향을 파악할 수 있으며, AI 애호가들의 지원 커뮤니티와도 연결해 줍니다. 특정 산업에 맞춤화된 AI 도구를 검색하여 비즈니스 요구 사항을 개선할 수 있습니다. 이 사이트를 사용하면 농업, 금융, 로봇 공학 등 어떤 분야에서든 완벽한 AI 솔루션을 쉽게 찾을 수 있습니다. 새로운 기술에 관심이 있다면 Futurepedia는 꼭 방문해야 할 리소스입니다. AI 활용하기 창의성과 생산성을 높여주는 무료 인공 지능 도구 10가지를 소개해 드렸습니다. 각 도구는 AI의 힘을 통해 새로운 가능성을 열어줍니다. 주류 AI가 계속 발전함에 따라 더 혁신적인 도구가 등장할 것입니다. 하지만 사용자 친화적인 플랫폼을 통해 지금 바로 그 혜택을 누릴 수 있습니다. 그러니 탐색하고, 실험하고, 즐겨보세요! 어떤 매력적인 창작물을 만들 수 있는지, 일상적인 작업을 자동화할 수 있는지 알아보세요. 모든 종류의 새로운 혁신을 위해 도구를 혼합하고 결합하는 것도 두려워하지 마세요. AI는 앞으로 수십 년 동안 우리의 삶을 점점 더 변화시킬 것입니다. 하지만 지금 당장은 이러한 도구를 통해 나만의 방식으로 미래에 발을 담그고 불가능해 보였던 창의적인 잠재력을 발휘할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"},{"name":"무료도구","slug":"무료도구","permalink":"http://hgko1207.github.io/tags/%EB%AC%B4%EB%A3%8C%EB%8F%84%EA%B5%AC/"}]},{"title":"2024년 사회를 변화시킬 AI 트렌드","slug":"ai-7","date":"2024-01-18T01:53:19.000Z","updated":"2024-01-19T01:01:40.880Z","comments":true,"path":"2024/01/18/ai-7/","link":"","permalink":"http://hgko1207.github.io/2024/01/18/ai-7/","excerpt":"","text":"2024년: AI가 우리의 일상을 진정으로 변화시킬 때 2023년에 AI가 주류로 등장했지만, 이는 2024년에 일어날 일들을 위한 워밍업에 불과했습니다. 올해는 2023년에 형성된 많은 트렌드가 완전히 자리를 잡고 우리의 삶을 재편하는 것을 보게 될 것입니다. 이 글에서는 2024년에 주목해야 할 가장 중요한 AI 트렌드를 좀 더 분명한 것부터 시작해서 점점 더 추측 가능한 것까지 공유해 보겠습니다. 이러한 트렌드 중 일부는 전혀 예상치 못한 것일 수도 있습니다. 오늘날의 소극적 소득 경제에서 AI를 활용하는 방법에 대한 가이드를 확인해 보시기 바랍니다. 대규모 언어 모델은 계속 발전할 것입니다. ChatGPT, DALL-E 및 기타 대규모 언어 모델은 2023년에 폭발적으로 등장했습니다. 하지만 이들의 발전은 아직 끝나지 않았습니다. 대부분의 사람들은 아직 GPT-4를 사용해 보지 못했습니다. GPT Vision과 같은 기능 덕분에 텍스트와 함께 이미지를 생성할 수 있다는 사실도 잘 모릅니다. 일부 모델은 심지어 128,000개의 토큰 컨텍스트 창을 처리할 수도 있습니다. 우리는 이러한 확장된 기능을 결합하여 어떤 것이 가능한지 보고 있습니다. 예를 들어, 한 트위터 사용자는 GPT-4를 사용하여 구글의 AI 데모 Gemini를 재현했습니다. AI는 가위바위보를 하고 오리 그림을 묘사했는데, 구글은 아직 개발 중인 고급 모델이 필요하다고 주장했습니다. GPT-5와 같은 더욱 발전된 모델과 Google Gemini가 약속한 것과 같은 더 나은 비전 기능을 갖추게 되면 이러한 AI는 우리 삶의 더 많은 측면에 영향을 미치기 시작할 것입니다. 소셜 미디어를 재편할 AI 2023년에는 가짜 인플루언서 및 생성된 동영상과 같이 AI가 주도하는 소셜 미디어의 바이럴 콘텐츠를 볼 수 있습니다. 하지만 이 기술은 아직 갈 길이 멀었습니다. 2024년에는 소셜 미디어에서 AI가 생성한 콘텐츠가 훨씬 더 많아질 것으로 예상됩니다. 현재 대부분의 AI 소셜 미디어 콘텐츠는 품질이 낮습니다. 하지만 머지않아 AI는 설득력 있는 비디오와 각 사용자에게 맞는 맞춤형 콘텐츠를 만들 수 있게 될 것입니다. YouTube는 이미 AI가 생성한 동영상에 태그를 지정하는 시스템을 도입했습니다. 이는 합성 콘텐츠가 더 보편화될 것으로 예상하고 있음을 보여줍니다. 언젠가는 사람이 만든 콘텐츠와 AI가 만든 콘텐츠의 경계가 모호해질 것입니다. 그렇기 때문에 디지털 신원 확인이 중요해질 것입니다. AI가 생성한 음성, 이미지, 동영상이 확산됨에 따라 실제로 콘텐츠를 만들었는지 증명할 수 있는 방법이 필요하게 될 것입니다. 물론 AI의 중재 기능도 향상될 것입니다. AI는 자체적으로 아티팩트와 패턴을 감지하여 합성 콘텐츠를 식별하기 시작할 것입니다. 따라서 AI는 오용을 가능하게 하는 동시에 오용을 억제하는 데도 도움이 될 수 있습니다. 대부분의 소프트웨어가 AI 기능을 채택할 것 2023년에는 GitHub Copilot 및 Google Docs와 같은 앱이 기본적인 AI 기능을 통합하는 것을 보았습니다. 하지만 이것은 시작에 불과합니다. 머지않아 컴퓨터의 거의 모든 앱과 프로그램에 AI 기능이 탑재될 것입니다. GPT-5와 같은 새로운 모델이 출시되면 개발자들은 서둘러 이를 구현할 것입니다. 작년에 많은 스타트업이 회의 요약기나 노코드 챗봇과 같은 AI 앱을 만들었습니다. 하지만 Zoom이나 OpenAI와 같은 대기업은 이러한 기능을 기본적으로 복사했습니다. 스타트업은 중복되는 것을 피하기 위해 민첩성을 유지해야 합니다. 긍정적인 측면은 주요 플랫폼에 AI를 통합하면 수십억 명의 사람들이 접근할 수 있다는 것입니다. 하지만 대부분의 장기적인 가치는 상품화된 언어 모델 위에 있는 애플리케이션 계층에 있을 것입니다. 또한 AI API에 작업을 완료할 수 있는 자율성을 부여하는 ‘자동 코딩(auto-coder)’ 유형의 앱이 더 많이 등장할 것입니다. 더 넓은 컨텍스트 창과 더 나은 추론을 통해 이러한 AI는 작업을 완료하기 위해 독립적으로 행동하기 시작할 수 있습니다. 필수 불가결한 존재가 될 AI 어시스턴트 Siri와 Alexa가 신기하게 느껴졌던 때를 기억하시나요? 그들은 2024년까지 우리가 매일 사용하게 될 AI 비서의 희미한 선구자였을 뿐입니다. 휴대폰, 컴퓨터, 심지어 안경에 장착되어 주변 환경과 작업을 이해할 수 있는 AI 비서가 있다고 상상해 보세요. 공상 과학 소설처럼 들릴지 모르지만 생각보다 가까운 곳에 있습니다. Humane 핀과 같은 일부 실험적인 웨어러블은 오늘날 이러한 비전을 실현하는 것을 목표로 하고 있습니다. 하지만 가장 이상적인 폼 팩터(form factor)는 이미 여러분의 주머니 속에 있는 스마트폰일 가능성이 높습니다. 다른 옵션으로는 AR 안경이나 스마트워치가 있습니다. Tesla의 Optimus와 같은 휴머노이드 로봇은 시간이 더 걸릴 것입니다. 2025년에는 가정에서 볼 수 있을지도 모르지만 2024년의 주요 트렌드는 아닐 것입니다. AI 여자친구와 남자친구가 인기를 얻을 것이다. AI 컴패니언은 논란의 여지가 있지만, 오늘날의 사회에서 중요한 역할을 할 수 있습니다. 인간관계는 점점 온라인에서 시작되고 있습니다. 청소년들은 짧은 형식의 알고리즘 콘텐츠에 소비됩니다. 그 결과 사회성이 떨어지고 있습니다. 이러한 환경에서 AI 컴패니언은 사람들이 안전하게 정서적 기술을 연습할 수 있는 방법을 제공합니다. 외로움과 고립감의 증가라는 대안보다는 훨씬 낫습니다. AI 챗봇 Character.ai에는 이미 월 4억 7,800만 명의 방문자가 가상 인물과 대화하고 있습니다. 그리고 Replika와 같은 새로운 앱을 사용하면 24시간 연중무휴로 AI 친구에게 문자를 보낼 수 있습니다. 물론 어떤 기술이든 지나친 사용은 건강에 해로울 수 있습니다. 하지만 많은 사람들에게 AI 친구는 실제 관계를 형성하고 실제 세계에서 성공할 수 있도록 도와줄 수 있습니다. 비디오 게임에 혁신을 가져올 AI 게임을 즐기지 않더라도 AI가 게임을 어떻게 변화시킬지 주목하세요. 올해에는 대규모 언어 모델로 구동되는 게임 내 AI 캐릭터의 인상적인 데모가 몇 가지 있었습니다. 자유롭게 대화를 나눌 수 있는 NPC는 분명한 진화처럼 보입니다. 하지만 AI에는 더 많은 잠재력이 있습니다. AI는 각 플레이어에게 맞는 맞춤형 퀘스트와 환경을 생성할 수 있습니다. AI는 맞춤형 오디오와 그래픽을 즉석에서 생성할 수도 있습니다. 나만을 위해 만들어진 주변 소리와 캐릭터 목소리를 상상해 보세요. 2024년에 주요 스튜디오에서 이러한 큰 변화를 볼 수는 없을 것입니다. 하지만 AI 게이밍의 미래를 위한 토대는 마련될 것입니다. 트렌드를 결합하면 새로운 가능성이 열릴 것입니다. 이러한 AI 트렌드는 고립되어 존재하지 않습니다. 그들의 능력은 쌓이고 배가됩니다. 휴대폰의 AI 어시스턴트가 절차에 따라 생성된 나만을 위한 맞춤형 AI 여자 친구를 소환하는 모습을 볼 수 있습니다. 또는 AI가 작성한 기사에 맞춤형 AI 음성이 내레이션을 더할 수도 있습니다. 모델이 쉽게 상호 작용하고 데이터를 공유할 수 있게 되면 가능성은 무궁무진해집니다. 이러한 조합이 어떤 결과를 가져올지 상상조차 할 수 없습니다. 하지만 우리는 2024년부터 그 가능성을 보기 시작할 것입니다. 주요 내용 2024년에는 GPT-5와 같은 대규모 언어 모델이 AI의 가능성을 계속 확장할 것입니다. 소셜 미디어에는 그 어느 때보다 더 많은 AI가 생성한 콘텐츠가 등장할 것이며, 이로 인해 진위 여부에 대한 이슈가 발생할 것입니다. 즐겨 사용하는 대부분의 앱과 프로그램에서 AI 기능을 찾을 수 있을 것입니다. AI 비서는 일상 생활에서 없어서는 안 될 조력자가 될 것입니다. AI 컴패니언은 장점도 있지만 미묘한 논의가 필요한 위험도 있습니다. 비디오 게임은 대화형 NPC를 시작으로 AI를 점점 더 많이 통합할 것입니다. 다양한 AI 기능을 결합하면 현재 우리가 예측할 수 있는 것 이상의 새로운 가능성이 열릴 것입니다. 2024년은 AI가 등장하는 중요한 해가 될 것입니다. 이러한 주요 트렌드를 파악하고 있다면 점점 더 AI가 활성화되는 세상을 헤쳐나갈 준비를 갖추게 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"2024년","slug":"2024년","permalink":"http://hgko1207.github.io/tags/2024%EB%85%84/"},{"name":"트렌드","slug":"트렌드","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A0%8C%EB%93%9C/"}]},{"title":"[머신러닝] 알아야 할 5가지 알고리즘","slug":"ai-6","date":"2024-01-17T07:53:42.000Z","updated":"2024-01-31T23:27:47.427Z","comments":true,"path":"2024/01/17/ai-6/","link":"","permalink":"http://hgko1207.github.io/2024/01/17/ai-6/","excerpt":"","text":"머신러닝(Machine Learning)은 명시적으로 프로그래밍하지 않고도 컴퓨터에 학습할 수 있는 기능을 제공하는 데이터 과학 분야입니다. 머신러닝은 복잡한 문제를 해결하고 데이터에서 인사이트를 도출할 수 있는 가장 흥미롭고 강력한 기술 중 하나입니다. 머신러닝은 마케팅, 의료, 금융, 교육 등 다양한 산업 및 영역에서 다양하게 활용되고 있습니다. 성공적인 데이터 과학자가 되려면 데이터 분석 및 모델링에 사용되는 기본 머신러닝 알고리즘에 대한 탄탄한 기초가 있어야 합니다. 알고리즘은 컴퓨터가 계산이나 기타 문제 해결 작업을 수행하기 위해 따라야 하는 일련의 명령 또는 지침입니다. 알고리즘은 기능, 복잡성, 설계 등에 따라 다양한 범주로 분류할 수 있습니다. 이 블로그에서는 모든 데이터 과학 애호가가 알아야 할 5가지 기본 머신러닝 알고리즘을 소개합니다. 이러한 알고리즘은 분류, 회귀, 클러스터링, 차원 축소 및 신경망과 같은 다양한 주제를 다룹니다. 또한 Python, R, SQL, pandas, scikit-learn, TensorFlow, Keras 등과 같은 다양한 도구와 프레임워크를 사용합니다. 이러한 알고리즘은 완전하거나 포괄적인 것이 아닙니다. 단지 머신러닝으로 무엇을 할 수 있는지, 어떻게 학습할 수 있는지에 대한 예시일 뿐입니다. 관심분야, 선호도, 목표에 따라 언제든지 수정할 수 있습니다. 온라인에서 더 많은 알고리즘을 찾거나 자신만의 알고리즘을 만들 수도 있습니다. 알아야 할 5가지 머신러닝 알고리즘에 대해 살펴보겠습니다. 1. 선형 회귀(Linear Regression) 선형 회귀는 입력 변수를 기반으로 연속적인 수치 값을 예측하기 위해 가장 간단하고 널리 사용되는 머신러닝 알고리즘 중 하나입니다. 선형 회귀는 데이터 세트의 입력 변수(x)와 출력 변수(y) 사이에 선형 관계가 있다고 가정합니다. 선형 회귀 모델은 이 관계를 다음 방정식과 같이 표현합니다. 1y &#x3D; b0 + b1x y는 예측하고자 하는 값을 가진 종속 변수입니다. x는 종속 변수를 예측하는 데 사용되는 값을 갖는 독립변수입니다. b0과 b1은 각각 선의 절편과 기울기를 결정하는 계수 또는 매개변수입니다. 선형 회귀의 주요 목적은 y의 실제 값과 예측 값 사이의 오류 또는 차이를 최소화하는 b0 및 b1의 최적 값을 찾는 것입니다. 이 오차는 잔차 또는 비용 함수라고도 하며 평균 제곱 오차(MSE), 평균 제곱근 오차(RMSE) 등과 같은 다양한 방법으로 측정할 수 있습니다. 선형 회귀와 관련된 몇 가지 일반적인 단계는 다음과 같습니다. 사용자 환경에 데이터 세트 로드 기술통계 및 플롯(plot)을 사용하여 데이터 세트 탐색 및 시각화하기 데이터 세트를 훈련 및 테스트 세트로 분할하기 scikit-learn 또는 기타 라이브러리를 사용하여 선형 회귀 모델을 훈련 세트에 맞추기 MSE, RMSE, R-squared 등과 같은 메트릭을 사용하여 테스트 세트에서 모델 성능을 평가합니다. 새로운 데이터에 대해 모델 테스트하고 결과 분석하기 2. 로지스틱 회귀(Logistic Regression) 로지스틱 회귀는 이진 분류 문제, 즉 이벤트의 가능한 결과 또는 클래스가 두 가지(0 또는 1)만 있을 때 가장 인기 있고 널리 사용되는 머신 러닝 알고리즘 중 하나입니다. 예를 들어, 이메일이 스팸인지 스팸이 아닌지, 고객이 제품을 구매할지 또는 구매하지 않을지, 종양이 악성인지 양성인지 여부 등이 있습니다. 로지스틱 회귀는 데이터 세트의 입력 변수(x)와 출력 변수(y) 사이에 선형 관계가 있다고 가정한다는 점에서 선형 회귀와 유사합니다. 그러나 선형 회귀와 달리 로지스틱 회귀는 방정식에 의해 주어진 로지스틱(logistic) 또는 시그모이드(sigmoid) 함수라는 비선형 함수를 사용하여 예측 값을 0에서 1 사이의 범위에 있는 확률로 변환합니다. 1F(x) &#x3D; 1&#x2F;1+e^-x 로지스틱 함수는 모든 실제 값을 0과 1 사이의 값으로 매핑하는 S자형 곡선을 생성합니다. 로지스틱 회귀 방정식은 다음과 같습니다. 1P(x) &#x3D; e^(b0+b1x)&#x2F;1 + e^(b0+b1x) P(x)는 x가 주어진 경우 y가 1일 확률입니다. b0 및 b1은 각각 곡선의 절편과 기울기를 결정하는 계수 또는 매개변수입니다. 로지스틱 회귀의 주요 목표는 y의 클래스 레이블을 정확하게 예측할 가능성을 최대화하는 b0 및 b1의 최적 값을 찾는 것입니다. 이 가능성은 Log Likelihood 또는 비용 함수(cost function)라고도 하며 크로스 엔트로피(cross entropy), 로그 손실(Log loss) 등과 같은 다양한 방법으로 측정할 수 있습니다. 로지스틱 회귀와 관련된 몇 가지 일반적인 단계는 다음과 같습니다. 사용자 환경에 데이터 세트 로드 기술통계 및 플롯(plot)을 사용하여 데이터 세트 탐색 및 시각화하기 데이터 세트를 훈련 및 테스트 세트로 분할하기 scikit-learn 또는 기타 라이브러리를 사용하여 훈련 세트에 로지스틱 회귀 모델 맞추기 정확도(Accuracy), 정밀도(Precision), 재현율(Recall), F1 Score 등과 같은 메트릭을 사용하여 테스트 세트에서 모델 성능을 평가합니다. 새로운 데이터에 대해 모델을 테스트하고 결과 분석하기 3. K-평균 클러스터링(K-Means Clustering) K-평균 클러스터링은 레이블이 지정되지 않은 데이터에서 패턴이나 구조를 찾는 데 가장 간단하고 널리 사용되는 머신러닝 알고리즘 중 하나입니다. K-평균 클러스터링은 비지도 학습의 한 유형으로, 미리 정의된 레이블이나 결과 없이 데이터 분석하는 머신러닝의 한 분야입니다. K-평균 클러스터링은 유사성 또는 거리 측정값에 따라 데이터 세트를 k개의 클러스터 또는 그룹으로 분할하는 것을 목표로 합니다. 각 클러스터는 해당 클러스터에 있는 모든 점의 평균인 중심 또는 중심점으로 표시됩니다. 각 클러스터의 점은 다른 어떤 중심점보다 해당 중심점에 더 가깝습니다. k-평균 클러스터링의 알고리즘은 다음과 같습니다. 클러스터 수인 k 값을 선택합니다. 데이터 세트에서 무작위로 k개의 점을 초기 중심점으로 선택합니다. 유클리드 거리(Euclidean distance)와 거리 측정값을 기준으로 데이터 세트의 각 점을 가장 가까운 중심점에 할당합니다. 각 클러스터에 있는 모든 점의 평균을 구하여 중심점을 다시 계산합니다. 클러스터 할당을 변경하는 점이 없거나 최대 반복 횟수에 도달할 때까지 3단계와 4단계를 반복합니다. k-평균 클러스터링과 관련된 몇 가지 일반적인 단계는 다음과 같습니다. 사용자 환경에 데이터 세트 로드 기술통계 및 플롯(plot)을 사용하여 데이터 세트 탐색 및 시각화하기 필요한 경우 데이터 크기 조정 또는 정규화 Elbow method, 실루엣 점수(Silhouette score), Gap statistic 등과 같은 방법을 사용하여 k 값 선택하기 scikit-learn 또는 기타 라이브러리를 사용하여 데이터에 k-평균 클러스터링 모델 맞추기 클러스터 내 제곱합(within-cluster sum of squares), Davies-Bouldin 지수 등의 메트릭을 사용하여 클러스터링 성능 평가 클러스터 내 제곱 합계, 데이비스-볼딘 지수 등과 같은 메트릭을 사용해 클러스터링 성능 평가. 산점도, 평행 좌표도, 레이더 차트 등의 도표를 사용하여 클러스터를 시각화합니다. 각 클러스터의 특성과 프로필을 분석하여 인사이트와 권장 사항 도출하기 4. 주성분 분석(Principal Component Analysis) 주성분 분석(PCA)은 데이터 세트의 차원 또는 복잡성을 줄이기 위해 가장 인기 있고 널리 사용되는 머신러닝 알고리즘 중 하나입니다. PCA는 라벨이 없는 데이터에서 패턴이나 구조를 찾는 비지도 학습의 일종입니다. PCA는 많은 특징이나 변수가 있는 데이터 세트를 원본 데이터 세트의 분산 또는 정보를 대부분 포착하는 적은 특징 또는 변수가 있는 새로운 데이터 세트로 변환하는 것을 목표로 합니다. 새로운 특징 또는 변수를 주성분(PC)이라고 하며, 원래 특징 또는 변수의 선형 조합입니다. PCA의 알고리즘은 다음과 같습니다. 필요한 경우 데이터를 표준화 또는 정규화합니다. 데이터의 공분산 행렬을 계산합니다. 공분산 행렬의 고유값과 고유 벡터를 계산합니다. 고유값을 내림차순으로 정렬하고 가장 큰 분산에 해당하는 k개의 고유값을 선택합니다. k개의 고유 벡터를 열로 하는 행렬을 형성합니다. 원본 데이터에 행렬을 곱하여 k개의 주성분을 구합니다. PCA와 관련된 몇 가지 일반적인 단계는 다음과 같습니다. 사용자 환경에 데이터 세트 로드 기술통계 및 플롯(plot)을 사용하여 데이터 세트 탐색 및 시각화하기 필요한 경우 데이터 크기 조정 또는 정규화 Scree plot, 누적 분산 설명 플롯(Cumulative variance explained plot) 등의 방법을 사용하여 k의 값을 선택합니다. scikit-learn 또는 기타 라이브러리를 사용하여 데이터에 PCA 모델 맞추기 Explained Variance Ratio, 재구성 오류(Reconstruction error) 등과 같은 메트릭을 사용해 PCA 성능을 평가합니다. 산점도, Biplot 등의 플롯을 사용하여 주요 구성 요소를 시각화합니다. 각 주성분의 부하와 점수를 분석하여 인사이트와 권장 사항 도출하기 5. 신경망(Neural Networks) 신경망은 입력 데이터와 출력 데이터 간의 복잡하고 비선형적인 관계를 모델링하기 위한 가장 진보되고 강력한 머신러닝 알고리즘 중 하나입니다. 신경망은 인간 두뇌의 구조와 기능에서 영감을 얻었으며 정보를 처리하고 전송하는 뉴런이라는 상호 연결된 단위 또는 노드로 구성됩니다. 신경망은 분류, 회귀, 클러스터링, 차원 축소, 자연어 처리, 컴퓨터 비전 등과 같은 다양한 작업에 사용할 수 있습니다. 또한 신경망은 아키텍처에 따라 순방향 신경망(Feedforward Neural Networks, FNN), 순환 신경망(Recurrent Neural Networks, RNN), 합성곱 신경망(Convolutional Neural Networks, CNN) 등 여러 유형으로 분류할 수 있습니다. 신경망의 알고리즘은 다음과 같습니다. 네트워크의 입력층(input layer), 은닉층(hidden layer) 및 출력층(output layer)을 정의합니다. 네트워크의 weight와 bias를 무작위로 초기화합니다. 네트워크에 입력 데이터를 공급하고 sigmoid, tanh, ReLU 등과 같은 활성화 함수를 사용하여 각 뉴런의 출력을 계산합니다. 평균 제곱 오차(Mean squared error), 크로스 엔트로피(Cross entropy) 등과 같은 네트워크의 오차 또는 손실 함수를 선택합니다. 학습 알고리즘을 사용하여 네트워크의 가중치 및 편향을 업데이트합니다. 경사 하강(Gradient descen), 역전파(Backpropagation) 등과 같은 학습 알고리즘을 사용하여 네트워크의 weight와 bias를 업데이트합니다. 오차 또는 손실이 최소화되거나 최대 에포크(epoch) 수에 도달할 때까지 3~5단계를 반복합니다. 신경망과 관련된 몇 가지 일반적인 단계는 다음과 같습니다. 사용자 환경에 데이터 세트 로드 기술통계 및 플롯을 사용하여 데이터 세트 탐색 및 시각화하기 필요한 경우 데이터 크기 조정 또는 정규화 데이터 세트를 학습 및 테스트 세트로 분할하기 TensorFlow, Keras 또는 기타 라이브러리를 사용하여 네트워크의 입력층, 은닉층, 출력층 정의하기 네트워크의 weight와 bias를 임의로 초기화하기 각 뉴런의 활성화 함수(예: sigmoid, tanh, ReLU 등)를 선택합니다. 평균 제곱 오차(Mean squared error), 크로스 엔트로피(Cross entropy) 등과 같은 네트워크의 오차 또는 손실 함수를 선택합니다. 경사 하강(Gradient descen), 역전파(Backpropagation) 등과 같은 weight와 bias를 업데이트하기 위한 학습 알고리즘을 선택합니다. TensorFlow, Keras 또는 기타 라이브러리를 사용하여 신경망 모델을 훈련 세트에 맞추기 정확도(Accuracy), 정밀도(Precision), 재현율(Recall), F1 Score 등과 같은 메트릭을 사용하여 테스트 세트에서 모델 성능을 평가합니다. 새로운 데이터에 대해 모델을 테스트하고 결과 분석하기 결론 머신러닝에서 알아야 할 5가지 알고리즘에 관한 이 블로그를 재미있게 읽으셨기를 바랍니다. 이러한 알고리즘은 재미있고 흥미로울 뿐만 아니라 커리어에 도움이 되는 유익한 정보이기도 합니다. 새로운 기술을 배우고, 지식을 적용하고, 잠재력을 발휘하는 데 도움이 될 수 있습니다. 또한 이러한 알고리즘을 향후 고급 알고리즘이나 복잡한 알고리즘을 위한 출발점으로 활용할 수도 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hgko1207.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://hgko1207.github.io/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://hgko1207.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]},{"title":"원활한 원격 회의를 위한 최고의 AI 회의 도우미 살펴보기","slug":"ai-5","date":"2024-01-16T01:00:27.000Z","updated":"2024-01-16T01:16:27.490Z","comments":true,"path":"2024/01/16/ai-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/16/ai-5/","excerpt":"","text":"소개 빠르게 변화하는 현대 비즈니스 세계에서 원활하고 생산적인 회의에 대한 필요성이 그 어느 때보다 커졌습니다. 인공지능(AI) 회의 도우미의 출현으로 팀의 협업 방식에 혁신을 가져왔으며, 가상 회의를 더욱 효율적이고 즐겁게 만들어주었습니다. 1. Google Meet - 언어의 장벽을 허물다 AI 회의 도우미 분야의 선두주자 중 하나인 Google Meet은 언어 장벽을 허무는 데 탁월합니다. 실시간 언어 번역 기능을 통해 Google Meet는 언어 차이로 인해 효과적인 커뮤니케이션이 방해받지 않도록 합니다. 예시 시나리오 다국적 팀이 프로젝트를 위해 협력하는 시나리오를 생각해 보세요. Google Meet의 AI 기반 언어 번역은 음성 단어를 각 참가자가 선호하는 언어로 원활하게 변환하여 진정으로 포용적이고 협력적인 환경을 조성합니다. 2. Microsoft Teams - 자동화를 통한 더욱 스마트한 회의 Microsoft Teams는 AI 회의 도우미 기능으로 공동 작업의 수준을 한 단계 끌어올립니다. 바쁜 프로젝트 관리자가 여러 작업을 처리하는 모습을 상상해 보세요. Microsoft Teams는 회의 예약을 자동화하고, 미리 알림을 보내고, 참가자의 참석 가능 시간에 따라 최적의 회의 시간을 제안할 수도 있습니다. 예시 시나리오 이러한 수준의 자동화를 통해 팀은 회의을 설정하고 관리의 실행 계획보다는 당면한 안건에 계속 집중할 수 있습니다. 3. Zoom - 동등한 참여를 위한 안면 인식 기능 Zoom은 회의에서 AI를 혁신적으로 사용하는 것으로 유명합니다. 얼굴 인식 기능을 사용하면 가상 공간에 있는 모든 사람이 각자의 시간에 기여할 수 있도록 보장합니다. 대규모 팀 회의에서 Zoom의 AI 회의 도우미는 각 참가자를 식별하고 그들이 말할 때 강조 표시합니다. 이는 동등한 참여를 장려할 뿐만 아니라 목소리에 얼굴을 입혀 참여도를 높이고 가상 상호작용을 더욱 개인화합니다. 예시 시나리오 서로 다른 위치에 있는 팀원들이 참여하는 가상 회의실을 상상해 보십시오. Zoom의 얼굴 인식 기능은 각 사람이 동등한 관심을 받을 수 있도록 보장하여 포용성과 참여감을 고취합니다. AI 회의 도우미(AI Meeting Assistant)의 이점 시간 효율성 일상적인 작업을 자동화하여 보다 효율적인 회의를 진행하세요. 참가자의 참석 가능 여부에 따라 최적의 회의 시간을 제안합니다. 향상된 커뮤니케이션 실시간 언어 번역은 글로벌 협업을 촉진합니다. 얼굴 인식을 통해 참가자 참여도가 향상됩니다. 글로벌 협업 포용적인 토론을 위해 언어 장벽을 허물어줍니다. 다양한 시간대에 걸쳐 원활한 협업을 촉진합니다. 생산성 향상 자동화를 통해 수동 개입을 줄이고 시간을 절약합니다. 프로젝트 관리 도구와 통합되어 토론에서 실행 항목으로 보다 원활하게 전환할 수 있습니다. 참여도 향상 얼굴 인식을 통해 모든 사람이 동일한 목소리를 낼 수 있습니다. 자동화된 회의 요약 기능으로 참가자에게 정보를 제공하고 참여를 유도합니다. 결론 원격 근무와 글로벌 협업의 역동적인 환경에서는 AI 회의 도우미의 역할은 매우 중요합니다. 제공된 실제 사례는 이러한 어시스턴트가 어떻게 가상 ​​회의를 변화시켜 더욱 효율적이고 포용적이며 매력적인 회의로 만들 수 있는지 보여줍니다. 언어 포용성을 위해 Google Meet을 선택하든, 자동화를 위해 Microsoft Teams를 선택하든, 얼굴 인식을 위해 Zoom을 선택하든 AI 회의 도우미를 워크플로에 통합하는 것은 팀 협업의 잠재력을 최대한 발휘하기 위한 전략적인 조치입니다. AI 회의 도우미의 강력한 기능을 도입하여 효율성이 효율성과 혁신이 만나고 협업의 경계가 없는 새로운 차원의 가상 회의를 경험하세요. 효율적인 회의는 물론 특별한 회의를 위해 설계된 최첨단 솔루션으로 끊임없이 진화하는 원격 근무의 세계에서 앞서 나가세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"원격회의","slug":"원격회의","permalink":"http://hgko1207.github.io/tags/%EC%9B%90%EA%B2%A9%ED%9A%8C%EC%9D%98/"},{"name":"회의도우미","slug":"회의도우미","permalink":"http://hgko1207.github.io/tags/%ED%9A%8C%EC%9D%98%EB%8F%84%EC%9A%B0%EB%AF%B8/"},{"name":"AI Meeting Assistant","slug":"AI-Meeting-Assistant","permalink":"http://hgko1207.github.io/tags/AI-Meeting-Assistant/"}]},{"title":"Pandas 마스터하기: 데이터 조작을 위한 고급 기술","slug":"python-4","date":"2024-01-15T05:10:27.000Z","updated":"2024-01-26T15:09:14.365Z","comments":true,"path":"2024/01/15/python-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/15/python-4/","excerpt":"","text":"Pandas 여정을 진행하면서 기본을 넘어 데이터 조작 기술에 정교함을 더하는 몇 가지 강력한 기술을 살펴보겠습니다. 1. DataFrame 병합 및 연결 여러 소스의 데이터를 결합하는 기술을 자세히 살펴보세요. DataFrame 병합과 연결의 차이점을 이해하고 다양한 유형의 조인을 처리하는 방법을 알아보세요. 12# Concatenate DataFrames verticallyresult = pd.concat([df1, df2]) 12# Merge DataFrames based on a common columnmerged_df = pd.merge(left_df, right_df, on='common_column', how='inner') 설명 연결: pd.concat()은 DataFrame을 수직으로 쌓는 데 사용됩니다. 동일한 열을 가진 데이터 세트가 있고 행 단위로 결합하려는 경우에 유용합니다. 병합: pd.merge()는 공통 열(column)을 기준으로 DataFrame을 결합하는 데 사용됩니다. SQL 조인과 유사하며 데이터 세트와 관련 정보를 결합하려는 경우에 유용합니다. 사용 사례 연결: 여러 달 또는 여러 해의 데이터를 동일한 열로 결합합니다. 병합: 공통 식별자를 가진 데이터 세트 통합(예: 고객 ID를 기반으로 판매 데이터와 고객 정보 병합) 2. 피벗(Pivot) 테이블로 데이터 재구성 피벗 테이블을 사용하여 더 나은 분석을 위해 데이터 재구성하는 데 능숙해집니다. DataFrame을 피벗 형태로 변환하여 정보를 요약하여 더 나은 인사이트를 얻을 수 있습니다: 12# Create a pivot tablepivot_table = df.pivot_table(index='Category', columns='Month', values='Value', aggfunc='sum') 설명 df.pivot_table()은 데이터를 재구성하여 요약 테이블을 생성합니다. 인덱스, 열, 값 및 집계 함수를 지정합니다. 이 예에서는 합계를 사용하여 각 'Category’와 ‘Month’ 조합에 대한 ‘Value’ 열을 요약합니다. 사용 사례 제품 카테고리 및 월별로 분류된 판매 데이터를 분석하여 추세를 파악합니다. 3. 범주형 데이터 처리 범주형 데이터를 효율적으로 관리하여 분석을 향상합니다. 원-핫(one-hot) 인코딩 및 범주형 데이터 유형 변환과 같은 기술을 배워보세요. 12# Convert a column to categorical typedf['Category'] = pd.Categorical(df['Category']) 12# Perform one-hot encodingdf_encoded = pd.get_dummies(df, columns=['Category']) 설명 열을 범주형 유형으로 변환(pd.Categorical())하면 고유 값이 제한된 열의 메모리 사용량이 최적화할 수 있습니다. 원-핫(one-hot) 인코딩(pd.get_dummies())은 범주형 변수를 이진 열로 변환하는 데 사용됩니다. 각 카테고리는 1과 0이 포함된 고유한 열을 갖게 됩니다. 사용 사례 ‘성별(Gender)’ 또는 '국가(Country)'와 같은 범주형 변수를 머신 러닝 알고리즘에 적합한 형식으로 변환합니다. 4. 시간 효율적인 문자열 작업 문자열 조작을 위한 Pandas의 다양한 기능을 살펴보세요. 문자열 작업을 효율적으로 적용하여 텍스트 데이터를 정리하고 변환하는 방법을 배워보세요. 12# Convert text to lowercasedf['Text_Column'] = df['Text_Column'].str.lower() 12# Extract information using regular expressionsdf['Extracted_Info'] = df['Text_Column'].str.extract(r'(\\d+)') 설명 str.lower()는 열의 모든 텍스트를 소문자로 변환하여 일관성을 유지합니다. str.extract()는 정규식을 사용하여 텍스트에서 특정 정보를 추출합니다. 사용 사례 비교하기 쉽도록 모든 텍스트를 소문자로 만들어 텍스트 데이터를 표준화합니다. 제품 설명에서 제품 ID를 추출하는 등 텍스트 열에서 숫자 정보를 추출합니다. 5. 날짜/시간 데이터 처리 기본적인 날짜/시간 작업을 넘어 고급 기술을 살펴보세요. 특정 구성 요소를 추출하고, 시차를 계산하고, 표준 시간대로 작업하는 방법을 배워보세요. 123# Extract month and year from a datetime columndf['Month'] = df['Date'].dt.monthdf['Year'] = df['Date'].dt.year 설명 dt.month 및 dt.year는 각각 월과 연도를 추출하는 날짜/시간 접근자(dt)의 속성입니다. 사용 사례 월별 또는 연도별 추세 분석과 같은 더 나은 시간 기반 분석을 위해 날짜/시간 데이터를 구성 요소로 세분화합니다. 6. 메모리 최적화 DataFrame의 메모리 사용량을 최적화하여 보다 효율적으로 처리하세요. 데이터 무결성을 손상시키지 않고 메모리 사용량을 줄이는 방법을 알아보세요. 12# 숫자 열을 더 작은 데이터 유형으로 다운캐스트(Downcast)하기df = df.apply(pd.to_numeric, downcast='integer') 설명 pd.to_numeric()은 열을 숫자 유형으로 변환합니다. downcast='integer'는 데이터에 맞는 가장 작은 정수 유형을 선택하여 메모리 사용량을 더욱 최적화합니다. 사용 사례 대규모 데이터 세트의 메모리 사용을 최적화하며, 특히 메모리에 않을 수 있는 데이터 세트로 작업할 때 유용합니다. 결론 이러한 고급 Pandas 기술은 데이터 조작 기술을 향상시켜 복잡한 시나리오에 대한 솔루션을 제공합니다. 주요 내용은 다음과 같습니다. 포괄적인 데이터 통합을 위해 DataFrame을 병합하고 연결합니다. 데이터 재구성을 위해 피벗 테이블의 기능을 활용합니다. 범주형 데이터를 효율적으로 처리하고 원-핫(one-hot) 인코딩을 수행합니다. 시간 효율적인 문자열 및 날짜/시간 작업을 마스터합니다. 대규모 데이터 세트의 메모리 사용량을 최적화합니다. 이러한 고급 기술을 적용하면 다양한 데이터 시나리오에서 Pandas를 정확하게 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","permalink":"http://hgko1207.github.io/tags/Pandas/"}]},{"title":"콘텐츠 작성을 위한 ChatGPT: 50가지 이상의 프롬프트 시도하기","slug":"chatgpt-6","date":"2024-01-13T07:03:54.000Z","updated":"2024-01-27T03:47:54.866Z","comments":true,"path":"2024/01/13/chatgpt-6/","link":"","permalink":"http://hgko1207.github.io/2024/01/13/chatgpt-6/","excerpt":"","text":"디지털 시대에는 AI 기술의 발전으로 콘텐츠 작성이 더욱 역동적이고 혁신적으로 변했습니다. 이러한 발전 가운데 ChatGPT는 콘텐츠 제작자를 위한 혁신적인 도구로 주목받고 있습니다. 다양한 글쓰기 요구 사항을 충족할 수 있는 다양한 프롬프트를 제공하는 획기적인 도구입니다. 이 글에서는 ChatGPT와 함께 콘텐츠 작성을 향상하는 데 사용할 수 있는 50개 이상의 프롬프트를 살펴보겠습니다. ChatGPT 이해하기 프롬프트를 살펴보기 전에 ChatGPT가 무엇인지 간략하게 살펴보겠습니다. OpenAI에서 개발한 ChatGPT는 수신된 입력을 바탕으로 사람과 유사한 텍스트를 이해하고 생성하도록 설계된 AI 언어 모델입니다. 기사 작성, 창의적인 아이디어 생성, 이메일 작성 등에 도움이 될 수 있습니다. 콘텐츠 작성을 위한 50가지 이상의 ChatGPT 프롬프트 모든 틈새시장에 맞는 다양하고 매력적인 프롬프트를 탐색하면서 창의력을 발휘하여 글쓰기 기술을 향상하세요. 톡톡 튀는 아이디어부터 문장을 다듬는 것까지, 콘텐츠 작성의 수준을 한 단계 끌어올릴 수 있는 영감의 세계를 발견하세요. 블로그 게시물 아이디어: 재생 에너지 트렌드에 관한 5개의 블로그 게시물 아이디어를 생성하세요. 기사 소개: 원격 근무가 생산성에 미치는 영향에 대한 기사 소개를 작성하세요. SEO 친화적인 콘텐츠: 건강한 식습관에 관한 SEO 최적화된 기사의 개요를 작성하세요. 이메일 캠페인: 젊은 기업가를 대상으로 하는 마케팅 캠페인의 이메일 초안을 작성하세요. 소셜 미디어 게시물: 여행사를 위한 매력적인 소셜 미디어 게시물 아이디어 5개를 제안하세요. 제품 설명: 친환경 물병에 대한 매력적인 제품 설명을 작성하세요. 면접 질문: 모바일 앱 개발자에게 면접에서 물어볼 10가지 질문을 나열하세요. 보도 자료: 새로운 온라인 강좌 플랫폼 출시에 대한 보도 자료를 작성하세요. 전자책(E-Book) 챕터: 마음챙김과 정신 건강에 관한 전자책의 첫 번째 장의 개요를 작성하세요. 동영상 대본 작성: 인터넷의 역사에 관한 YouTube 동영상의 대본을 작성하세요. 창의적 글쓰기: 시간 여행 모험에 관한 단편 소설을 작성하세요. 시와 노래: 봄의 아름다움에 대한 시를 창작하세요. 기술 글쓰기: 블록체인 기술을 간단한 쉬운 용어로 설명하세요. 사례 연구: 성공적인 디지털 마케팅 캠페인을 위한 사례 연구 개요 개요를 작성하세요. 사업 계획: 비건 카페의 사업 계획서 작성을 도와주세요. 웨비나 콘텐츠: 지속 가능한 삶에 대한 웨비나 주제를 제안해 주세요. 사용자 가이드 및 매뉴얼: 피트니스 트래킹 앱 사용에 대한 단계별 가이드를 작성하세요. 코스 커리큘럼: 그래픽 디자인 강좌의 커리큘럼 개요를 개발하세요. 연구 제안서: 소셜 미디어가 정신 건강에 미치는 영향에 대한 연구 제안서를 작성하세요. 도서 요약: Daniel Kahneman의 'Thinking, Fast and Slow’의 요점을 요약하세요. 팟캐스트(Podcast) 스크립트: 기업가 정신에 관한 팟캐스트의 첫 번째 에피소드에 대한 대본 초안을 작성하세요. 퀴즈 및 설문조사: 디지털 마케팅 기술을 평가하는 퀴즈를 디자인하세요. 랜딩 페이지 카피: 새로운 마음챙김 앱에 대한 랜딩 페이지의 매력적인 문구를 작성하세요. 브로셔 콘텐츠: 웰니스 휴양지를 홍보하는 브로셔 콘텐츠를 개발하세요. 인포그래픽 텍스트: 재생 에너지원에 대한 인포그래픽의 텍스트를 작성하세요. 법률 문서: 새로운 모바일 앱의 서비스 약관 문서 초안을 작성하세요. 연설문 작성: 최근 대학을 졸업한 신입사원을 위한 동기 부여 연설문 작성하기. FAQ 섹션: 유기농 원예에 관한 웹사이트에 대한 FAQ를 생성하세요. 서평: James Clear의 ‘Atomic Habits’ 책에 대한 리뷰를 작성하세요. 뉴스 기사: AI(인공지능) 기술의 최신 발전에 관한 뉴스 기사 초안을 작성하세요. 여행 가이드: 주말 파리 여행을 위한 여행 가이드를 작성하세요. 피트니스 및 건강 팁: 더 건강한 라이프스타일을 위한 10가지 일상 습관을 나열하세요. 어린이를 위한 교육 콘텐츠: 어린이를 위한 물 순환에 대한 짧은 교육용 글을 작성하세요. 패션 및 라이프스타일 기사: 지속 가능한 패션 트렌드에 대한 기사 아이디어를 제안하세요. 부동산 목록: 해변 부동산에 대한 목록 설명을 작성하세요. 레시피 작성: 비건 초콜릿 케이크의 레시피를 작성하세요. 자기계발 조언: 시간 관리와 생산성에 대한 조언을 해주세요. 전기: Elon Musk의 짧은 전기를 써주세요. 이벤트 설명: 가상 기술 컨퍼런스에 대한 설명 초안을 작성하세요. 마케팅 전략: 새로운 피트니스 앱을 위한 마케팅 전략의 개요를 작성하세요. 자동차 리뷰: 최신 전기 자동차 모델에 대한 리뷰를 작성하세요. 건강 관리 기사: 정신 건강 인식에 관한 블로그의 주제를 제안하세요. 재무 계획 팁: 효과적인 개인 예산 책정을 위한 팁을 나열하세요. 기술 튜토리얼: 스마트 홈 시스템 설정에 대한 튜토리얼을 작성하세요. 문화 논평: 소셜 미디어가 현대 커뮤니케이션에 미치는 영향에 대해 토론하세요. ​​환경 인식 콘텐츠: 재활용을 장려하는 캠페인을 위한 콘텐츠를 개발하세요. ​유머와 엔터테인먼트:​ 원격 근무의 특이한 점에 대해 유머러스한 글을 작성하세요. ​동기 부여 콘텐츠:​ 팀 빌딩을 위한 일일 동기부여 메시지를 작성하세요. ​역사적 기사:​ 르네상스 시대의 중요성에 관한 기사 초안을 작성하세요. ​지속 가능성 관행:​ 중소기업을 위한 지속 가능한 관행에 대해 글을 작성하세요. ​DIY 및 공예 지침:​ 새집 만들기 위한 단계별 지침을 제공하세요. ​영양 가이드:​ 운동선수를 위한 다량 영양소 균형에 대한 가이드를 만드세요. ​육아 조언:​ 부모를 위한 자녀의 화면 시간 관리에 대한 조언을 제공하세요. ​원예 가이드:​ 텃밭을 시작하기 위한 초보자 가이드를 작성하세요. ​사진 촬영 팁:​ 더 나은 풍경 사진을 찍기 위한 5가지 팁을 나열하세요. 간소화된 콘텐츠 생성을 위한 ChatGPT ChatGPT는 글쓰기 과정을 간소화할 뿐만 아니라 창의력에도 영감을 줍니다.콘텐츠에 대화적 관점을 제공하는 ‘AI 채팅’ 역할을 할 수 있습니다 . 이 도구는 아이디어를 브레인스토밍하거나 다양한 관점을 모색할 때 특히 유용합니다. ChatGPT 활용 극대화하기 콘텐츠 작성에 ChatGPT를 최대한 활용하려면 다음과 같이 하세요. 구체적으로 작성하세요: 프롬프트가 구체적일수록 응답이 더욱 맞춤화되고 유용해집니다. 반복하세요: 받은 응답에 따라 주저하지 말고 프롬프트를 다듬거나 문구를 바꾸세요. 프롬프트 결합하기: 때로는 두 개 이상의 프롬프트를 결합하면 더 포괄적인 콘텐츠를 만들 수 있습니다. 창의성을 발휘하세요: ChatGPT를 출발점으로 삼아 창의력을 발휘하고 개성을 더하세요. 결론 ChatGPT는 콘텐츠 크리에이터에게 폭넓은 가능성을 제공하여 글쓰기를 보다 쉽게 ​​접근할 수 있고 효율적이며 창의적으로 만들어줍니다. 숙련된 작가든 이제 막 시작하는 작가든, 50개 이상의 프롬프트는 콘텐츠 지평을 탐색하고 확장할 수 있는 탄탄한 기반을 제공합니다. AI의 힘을 활용하고 ChatGPT로 콘텐츠 작성 프로세스를 혁신하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"콘텐츠","slug":"콘텐츠","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"}]},{"title":"ChatGPT로 파이썬을 처음부터 빠르게 배우는 방법","slug":"chatgpt-5","date":"2024-01-12T14:19:41.000Z","updated":"2024-01-23T01:04:37.558Z","comments":true,"path":"2024/01/12/chatgpt-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/12/chatgpt-5/","excerpt":"","text":"Chat GPT와 같은 챗봇이 등장하면서 많은 사람들이 인공지능 비서가 효과적인 교사가 될 수 있는지 궁금해하고 있습니다. 이 글에서는 완전 초보자로서 ChatGPT를 사용하여 Python을 배우는 방법에 알아보겠습니다. 1. 기초부터 시작하세요. 새로운 프로그래밍 언어를 배울 때는 기초부터 시작하는 것이 중요합니다. ChatGpt에 다음과 같은 질문을 할 것입니다. Python의 기본 데이터 유형은 무엇인가요? 변수를 할당하고 문자열을 print 하려면 어떻게 해야 하나요? Python에서 list, tuple, dictionary이란 무엇인가요? if/else와 같은 조건문을 어떻게 작성하나요? for 및 while 루프를 어떻게 구성하나요? 더 깊이 들어가기 전에 기본 구성 요소에 익숙해지는 것이 목표입니다. ChatGpt는 간단한 코드 예제와 개념에 대한 명확한 설명을 제공할 수 있습니다. 2. 간단한 프로그램 작성하기 기본 사항을 숙지한 후에는 배운 내용을 적용하기 위해 간단한 프로그램을 작성하기 시작합니다. ChatGPT에서 도움을 받을 수 있는 몇 가지 아이디어는 다음과 같습니다. 섭씨를 화씨로 변환하는 프로그램 목록에서 가장 큰 숫자를 찾는 스크립트 Mad Libs 단어 게임 텍스트 기반 계산기 숫자 맞추기 게임 미니 프로그램을 작성하면 새로운 구문을 익히고 개념을 연결하는 데 도움이 됩니다. ChatGpt에 시작 코드를 제공해 달라고 요청하고 예제를 통해 안내해 달라고 요청합니다. 3. 주요 라이브러리 배우기 Python의 핵심 기능에 대한 경험을 쌓은 후에는 데이터 과학자와 개발자가 사용하는 인기 있는 라이브러리를 배웁니다. 주요 라이브러리는 다음과 같습니다. 수치 계산을 위한 Numpy 데이터 분석을 위한 Pandas 데이터 시각화를 위한 Matplotlib 각 라이브러리에 대한 개요, 실제 예제, 적용을 위한 연습 문제를 ChatGpt에 요청합니다. 이러한 라이브러리를 사용하여 프로젝트를 구축하면 고급 Python 작업에 대비할 수 있습니다. 4. 프로젝트 아이디어 발굴하기 Python의 기초가 탄탄해지면 ChatGpt를 활용하여 기술 수준을 높이기 위해 구축할 수 있는 프로젝트 아이디어를 생성합니다. 영감을 얻기 위해 다음과 같이 질문합니다. Pandas와 Matplotlib를 사용하는 초보자 Python 프로젝트에는 어떤 것이 있나요? Python 숙련도를 입증할 수 있는 중급 코딩 프로젝트 아이디어를 제공해 주실 수 있나요? ChatGPT는 날씨 대시보드, 2D 게임, 데이터 분석 웹 앱과 같이 내 능력에 맞는 아이디어를 제공할 수 있습니다. 이러한 프로젝트를 구현하면 귀중한 실무 경험을 쌓을 수 있습니다. 결론 코딩을 배우는 데는 시간과 연습이 필요하지만 ChatGpt와 같은 AI 비서는 맞춤형 예제, 설명 및 프로젝트 아이디어를 제공함으로써 그 과정을 가속화할 수 있습니다. 실습 코딩을 대체할 수는 없지만, ChatGpt는 Python의 기초을 익히고 새로운 개념을 탐구하는 데 훌륭한 보조 도구입니다. 약간의 창의력만 있다면, 호기심 많은 초보자도 ChatGpt를 활용하여 Python 코딩 여정을 시작할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}]},{"title":"소프트웨어 개발의 미래로서의 DevOps","slug":"info-8","date":"2024-01-10T01:22:16.000Z","updated":"2024-01-22T01:20:21.317Z","comments":true,"path":"2024/01/10/info-8/","link":"","permalink":"http://hgko1207.github.io/2024/01/10/info-8/","excerpt":"","text":"최근 몇 년 동안 소프트웨어 개발 환경은 DevOps로 보다 협업적이고 효율적인 접근 방식으로 크게 변화하고 있습니다. &quot;development&quot;과 &quot;operations&quot;이 융합된 DevOps는 소프트웨어 개발자와 IT 운영팀 간의 통합과 협업을 강조합니다. 이 글에서는 DevOps의 인기가 높아지는 이유와 소프트웨어 개발의 미래를 바꿀 수 있는 잠재력에 대해 살펴봅니다. 속도에 대한 필요성 기존 소프트웨어 개발 방법론은 느리고 번거로운 프로세스로 인해 어려움을 겪는 경우가 많았습니다. 이러한 문제를 해결하기 위해 등장한 DevOps는 소프트웨어 개발 라이프사이클을 간소화하고 가속화하는 것을 목표로 합니다. DevOps는 개발, 테스트, 배포 및 운영을 원활한 워크플로우로 결합하여 소프트웨어 제품의 출시 기간을 단축하고 점점 증가하는 디지털 시대의 요구 사항을 충족합니다. 지속적인 통합 및 지속적인 배포(CI/CD) DevOps는 소프트웨어 변경 사항이 지속적으로 통합, 테스트 및 배포하는 CI/CD 방식의 채택을 권장합니다. 자동화를 핵심으로 하는 CI/CD 파이프라인을 통해 개발자는 새로운 기능과 버그 수정을 더 자주 그리고 안정적으로 제공할 수 있습니다. 이러한 반복적인 접근 방식은 소프트웨어 품질을 향상시키고 결함의 위험을 줄이며 조직이 고객 피드백에 신속하게 대응할 수 있도록 지원합니다. 협업과 커뮤니케이션 DevOps의 핵심 원칙 중 하나는 개발팀과 운영팀 간의 사일로를 허무는 것입니다. DevOps는 협업과 커뮤니케이션을 촉진함으로써 공동 책임과 상호 이해의 문화를 조성합니다. 개발자는 코드의 운영 측면에 대한 통찰력을 얻고 운영팀은 개발 프로세스에 대한 가시성을 얻습니다. 이러한 협업을 통해 효율성이 향상되고 오류가 줄어들며 비즈니스 목표에 더 잘 부합하게 됩니다. 사일로효과 조직의 부서들이 서로 다른 부서와는 교류하지 않고, 자기 부서의 이익만을 추구하는 현상을 빗댄 말. 경영학에서 주로 사용하는 부서 이기주의를 표현하는 용어이다. 자동화 및 IaC(Infrastructure as Code) 자동화는 DevOps에서 중요한 역할을 하며, 조직이 복잡한 소프트웨어 시스템을 쉽게 관리할 수 있도록 해줍니다. IaC(코드형 인프라)를 사용하면 개발자는 인프라 구성을 버전 제어 아티팩트로 처리하여 인프라 리소스를 프로그래밍 방식으로 정의하고 프로비저닝할 수 있습니다. 자동화를 통해 수동 오류를 제거하고 일관성을 보장하며 변화하는 비즈니스 요구 사항을 충족하기 위해 인프라를 신속하게 확장할 수 있습니다. 클라우드 기술 수용 클라우드 컴퓨팅은 소프트웨어 개발 및 배포 방식에 혁신을 가져왔습니다. DevOps는 클라우드 기술을 활용하여 확장 가능하고 유연하며 비용 효율적인 환경을 만듭니다. 클라우드 플랫폼은 자동 확장, 컨테이너화, 서버리스 컴퓨팅과 같은 DevOps 방식을 지원하는 데 필요한 인프라, 도구 및 서비스를 제공합니다. 클라우드의 힘을 활용함으로써 조직은 하드웨어와 인프라를 관리하는 대신 고객에게 가치를 제공하는 데 집중할 수 있습니다. 안정성과 복원력 향상 DevOps는 소프트웨어 시스템의 안정성과 복원력을 보장하는 데 중점을 둡니다. 지속적인 모니터링, 자동화된 테스트 및 사전 오류 감지를 통해 조직은 개발 주기 초기에 문제를 식별하고 해결할 수 있습니다. DevOps는 내결함성, 점진적 성능 저하, 재해 복구 계획과 같은 기술을 사용하여 강력하고 가용성이 높은 애플리케이션을 구축하는 데 도움을 줍니다. 이러한 안정성에 대한 집중은 고객의 신뢰와 충성도를 높여줍니다. 민첩하고 반복적인 개발 DevOps는 유연성, 적응성 및 고객 협업을 강조하는 Agile 방법론과 잘 맞습니다. Agile 방식을 DevOps와 통합함으로써 조직은 변화하는 고객 요구와 시장의 역학 관계에 신속하게 대응할 수 있습니다. 지속적인 피드백 루프의 지원을 받는 반복적인 개발 주기를 통해 팀은 소프트웨어를 지속적으로 개선하여 빠르게 변화하는 환경에서 관련성과 가치를 유지할 수 있습니다. 보안 및 규정 준수 개선 사이버 위협이 증가함에 따라 보안은 소프트웨어 개발에 있어서 가장 중요한 관심사가 되었습니다. DevOps는 개발 프로세스 전반에 걸쳐 보안 및 규정 준수 관행을 통합하여 이러한 문제를 해결합니다. DevOps를 확장한 DevSecOps는 소프트웨어 배포의 모든 단계에 보안 원칙과 프로세스를 통합합니다. 처음부터 보안 조치를 포함함으로써 조직은 개발 속도를 유지하면서 안전하고 규정을 준수하는 소프트웨어 시스템을 구축할 수 있습니다. 결론 디지털 환경이 계속 발전함에 따라 DevOps는 소프트웨어 개발에 대한 혁신적인 접근 방식으로 등장했습니다. DevOps는 협업, 자동화 및 지속적인 개선을 촉진함으로써 개발 속도, 안정성 및 보안을 향상시킵니다. DevOps 방식을 도입하면 조직이 최신 소프트웨어 개발 라이프사이클의 과제를 극복하고 고객 기대에 부응하는 고품질 소프트웨어 제품을 제공할 수 있습니다. 미래를 내다보면 DevOps는 소프트웨어 개발 산업을 형성하고 디지털 시대의 혁신을 주도하는 데 중추적인 역할을 할 것입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"DevOps","slug":"DevOps","permalink":"http://hgko1207.github.io/tags/DevOps/"},{"name":"Software Development","slug":"Software-Development","permalink":"http://hgko1207.github.io/tags/Software-Development/"},{"name":"Development","slug":"Development","permalink":"http://hgko1207.github.io/tags/Development/"}]},{"title":"ChatGPT를 최대한 활용하는 방법: 10가지 팁과 요령","slug":"chatgpt-4","date":"2024-01-09T13:32:00.000Z","updated":"2024-01-21T02:40:59.483Z","comments":true,"path":"2024/01/09/chatgpt-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/09/chatgpt-4/","excerpt":"","text":"ChatGPT는 사용자가 입력하는 프롬프트에 따라 텍스트를 생성할 수 있는 AI 언어 모델입니다. 아이디어를 생성하고, 텍스트를 요약하고, 심지어 언어를 번역하는 데 도움이 되는 강력한 도구입니다. 이 글에서는 ChatGPT를 최대한 활용하기 위한 10가지 팁과 요령을 살펴보겠습니다. 1) 직원처럼 대화하세요. ChatGPT의 가장 큰 장점 중 하나는 자연어를 이해할 수 있다는 것입니다. 즉, 사람과 대화할 때와 같은 방식으로 질문하고 요청할 수 있습니다. 예를 들어, &quot;개에 관한 텍스트를 생성하세요&quot;라고 말하는 대신 &quot;개에 대한 기사를 작성해줄 수 있어?&quot;라고 말할 수 있습니다. generate text about dogs -&gt; can you write an article about dogs? 2) 다양한 프롬프트로 실험해 보세요. ChatGPT는 사용자가 입력하는 프롬프트에 따라 텍스트를 생성하도록 설계되었습니다. 따라서 원하는 결과가 나오지 않는다면 다양한 프롬프트를 사용해 실험해 보세요. 예를 들어, &quot;고양이에 관한 이야기를 써주세요&quot;라고 말하는 대신 &quot;고양이에 대한 이야기를 들려줄 수 있나요?&quot;라고 말할 수 있습니다. write a story about a cat -&gt; can you tell me a story about a cat? 3) 맥락을 제공하세요. ChatGPT에 더 많은 컨텍스트를 제공할수록 사용자가 요청하는 내용을 더 잘 이해할 수 있습니다. 예를 들어, &quot;자동차에 관한 기사를 작성해 주세요&quot;라고 말하는 대신 &quot;전기 자동차와 그것이 환경에 미치는 영향에 대한 기사를 작성해 주실 수 있나요?&quot;라고 말할 수 있습니다. write an article about cars -&gt; can you write an article about electric cars and their impact on the environment? 4) 일괄 처리 한 번에 많은 양의 텍스트를 생성하는 경우 더 작은 배치로 배치로 나누어 작성하는 것이 좋습니다. 이렇게 하면 ChatGPT에 과부하가 걸리지 않고 고품질의 텍스트를 생성할 수 있습니다. 예를 들어, ChatGPT에 책 전체를 작성하도록 요청하는 대신 한 번에 한 장씩 작성하도록 요청할 수 있습니다. 5) 더 짧은 텍스트 프롬프트를 사용하세요. 짧은 프롬프트가 긴 프롬프트보다 더 잘 작동하는 경향이 있습니다. 이는 ChatGPT가 사용자의 프롬프트에 따라 짧은 텍스트를 생성하도록 설계되었기 때문입니다. 예를 들어, &quot;기후 변화에 관한 10페이지 분량의 보고서를 작성하세요&quot;라고 말하는 대신 &quot;기후 변화의 영향을 한 문단으로 요약해 주시겠습니까?&quot;라고 말할 수 있습니다. write a 10-page report on climate change -&gt; can you summarize the impact of climate change in one paragraph? 6) ChatGPT의 요약 기능을 활용하세요. 요약이 필요한 텍스트가 있다면 ChatGPT가 도움이 될 수 있습니다. 예를 들어, 특정 주제에 대한 기사 전체를 읽는 대신 ChatGPT에게 요약해 달라고 요청할 수 있습니다. 7) 번역에 ChatGPT를 사용하세요. ChatGPT는 한 언어에서 다른 언어로 텍스트를 번역하는 데 도움을 줄 수 있습니다. 예를 들어 이메일을 영어에서 스페인어로 번역해야 하는 경우 ChatGPT에 도움을 요청할 수 있습니다. 8) ChatGPT를 사용하여 아이디어를 창출하세요. 문제가 막혔거나 영감이 필요할 때 ChatGPT를 사용하여 아이디어를 생각해 보세요. 예를 들어, 신제품에 대한 아이디어를 얻으려는 경우 ChatGPT에 제안을 요청할 수 있습니다. 9) 단어 제한을 우회하려면 &quot;계속&quot;과 같은 간단한 프롬프트를 사용하세요. ChatGPT는 텍스트를 생성할 때 단어 수 제한이 있습니다. 이 제한을 우회하려면 “계속하기(go on)”, “계속 진행(keep going)” 또는 &quot;계속(continue)&quot;과 같은 간단한 프롬프트를 사용하세요. 예를 들어 ChatGPT가 500단어 이후에 텍스트 생성을 중지하는 경우 &quot;계속 진행&quot;이라고 말하면 더 많은 텍스트를 얻을 수 있습니다. 10) 인내심을 갖고 끈기 있게 기다리세요! ChatGPT는 여전히 매일 학습하고 개선되고 있으므로 항상 원하는 결과를 바로 나오지 않더라도 낙심하지 마세요. 원하는 결과를 얻을 때까지 다양한 프롬프트를 계속 실험하고 상황에 맞는 정보를 제공하세요. 결론 ChatGPT는 고품질 텍스트를 빠르고 쉽게 생성하는 데 도움이 되는 강력한 도구입니다. 이 10가지 팁과 요령을 따르면 ChatGPT를 최대한 활용하고 원하는 결과를 얻을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"}]},{"title":"한 줄로 완성하는 최신 CSS 레이아웃 10가지","slug":"web-design-5","date":"2024-01-08T00:53:46.000Z","updated":"2024-01-12T14:22:21.535Z","comments":true,"path":"2024/01/08/web-design-5/","link":"","permalink":"http://hgko1207.github.io/2024/01/08/web-design-5/","excerpt":"","text":"소개 역동적인 웹 개발 세계에서 CSS는 웹사이트의 시각적 매력을 형성하는 데 중요한 역할을 합니다. 수년에 걸쳐 개발자들은 레이아웃을 효율적으로 효율적으로 만들 수 있는 혁신적인 방법을 고안해 왔습니다. 이 글에서는 각각 단 한 줄의 코드로 구현할 수 있는 10가지 최신 CSS 레이아웃을 살펴보겠습니다.이러한 간결한 솔루션은 시간을 절약할 뿐만 아니라 CSS(Cascading Style Sheets)의 강력한 성능과 유연성을 보여줍니다. 1) Flexbox Centering 12345.container &#123; display: flex; justify-content: center; align-items: center;&#125; 2) Grid Centering 1234.container &#123; display: grid; place-items: center;&#125; 3) 전체 페이지 이미지 배경 123body &#123; background: url('image.jpg') center/cover no-repeat;&#125; 4) 반응형 Square 123.square &#123; aspect-ratio: 1/1;&#125; 5) 고정 바닥글 123456789body &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125; 6) 같은 너비의 열(Column) 123.column &#123; flex: 1;&#125; 7) 원형 요소(Element) 123.circle &#123; border-radius: 50%;&#125; 8) 유동적인 타이포그래피(Typography) 123body &#123; font-size: calc(1rem + 1vw);&#125; 9) Multi-column Text 1234.text &#123; column-count: 3; column-gap: 1rem;&#125; 10) 반응형 Square Grid 12345.grid &#123; display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem;&#125; 결론 모던하고 반응이 빠른 웹 디자인을 제작하려면 CSS 레이아웃 기술을 숙지하는 것이 필수적입니다. 이 한 줄짜리 솔루션은 CSS가 프로젝트에 가져올 수 있는 우아함과 단순함을 보여줍니다. 이러한 스니펫(Snippets)을 실험해보고 필요에 맞게 조정하여 최소한의 코드로 최대의 효과를 내면서 웹 개발의 수준을 높여보세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"C#에서 String과 string의 차이점 이해하기","slug":"csharp-7","date":"2024-01-07T07:47:47.000Z","updated":"2024-01-19T13:21:36.216Z","comments":true,"path":"2024/01/07/csharp-7/","link":"","permalink":"http://hgko1207.github.io/2024/01/07/csharp-7/","excerpt":"","text":"C#은 강력한 형식의 프로그래밍 언어입니다. 효과적인 C# 코드를 작성하려면 데이터 형식을 아는 것이 필수적입니다. C#에서 가장 자주 사용되는 데이터 유형 중 하나는 문자열 유형으로 String, string로 선언할 수 있습니다. 이로 인해 약간의 혼동이 발생할 수 있습니다. String과 string의 차이점은 무엇이며, 언제 각각을 사용해야 할까요? 이 글에서는 이 두 가지 유형을 자세히 살펴보고 유사점과 차이점을 이해하고 어느 쪽을 더 선호할 수 있는 몇 가지 시나리오를 살펴보겠습니다. String과 string은 무엇입니까? String String 클래스는 시스템 네임스페이스(System.String)의 일부입니다. Substring, Concat, Replace 등과 같은 문자열 조작을 위한 다양한 메소드를 제공하는 클래스입니다. 다음과 같이 사용할 수 있습니다. 12345678910111213using System;namespace StringExample&#123; class Program &#123; static void Main(string[] args) &#123; String name = \"HyeongGyun\"; Console.WriteLine(name.ToLower()); // \"hyeonggyun\" &#125; &#125;&#125; string 반면에 string은 C# 언어의 String의 별칭입니다. 문자열 변수를 선언하는 더 읽기 쉬운 방법이며 구문상 더 간단합니다. string은 단순히 System.String의 약어입니다. 1234567891011namespace StringExample&#123; class Program &#123; static void Main(string[] args) &#123; string name = \"HyeongGyun\"; Console.WriteLine(name.ToLower()); // \"hyeonggyun\" &#125; &#125;&#125; 유사점 상호 교환 가능: String과 string을 문제없이 바꿔서 사용할 수 있습니다. 12345String name1 = \"Ko\";string name2 = \"HyeongGyun\";// perfectly validstring fullName = name1 + \" \" + name2; 동일한 메서드: string은 System.String의 별칭일 뿐이므로 둘 모두에 동일한 메서드를 사용할 수 있습니다. 12345String name1 = \"Ko\";string name2 = \"HyeongGyun\";Console.WriteLine(name1.ToLower());Console.WriteLine(name2.ToUpper()); 차이점 기능적으로는 동일하지만 언제 어느 쪽을 사용해야 하는지에 대한 몇 가지 모범 사례가 있습니다. 가독성: 많은 개발자들은 string 사용하는 것이 int, bool, double과 같은 다른 단순한 유형과 잘 어울리기 때문에 가독성이 더 높다고 생각합니다. Namespacing: using System;을 사용하여 선언한 경우 문제없이 String을 사용할 수 있습니다. 그렇지 않으면 System.String으로 사용해야 합니다. 표준화: 대부분의 C# 코딩 표준에서는 지역 변수 및 메서드 매개 변수에 대해 string보다 String을 사용할 것을 권장합니다. 반환(return) 유형의 경우 둘 다 사용할 수 있지만 일반적으로 일관성을 유지하는 것이 좋습니다. String과 string 사용 시기 String 정적 메서드(Static Method)로 작업하기: String 클래스의 정적 메서드를 사용할 때는 String을 사용하는 것이 좋습니다. 12String.Concat(\"Hello, \", \"world!\");String.Format(\"&#123;0&#125; &#123;1&#125;\", var1, var2); 정규화된 이름 필요: 네임스페이스가 문제가 되는 환경에서 작업하는 경우(매우 드물지만) System.String을 지정해야 할 수 있습니다. string 지역 변수 및 매개변수: 로컬 변수 선언과 메서드 매개변수 유형에는 string을 사용하는 것이 일반적입니다. 12345public void SayHello(string name)&#123; string greeting = \"Hello, \" + name; Console.WriteLine(greeting);&#125; 가독성: string을 사용하면 다른 기본 제공 유형(int, bool 등)을 사용할 때와 코드의 일관성을 유지할 수 있습니다. 결론 C#의 String과 string 유형은 기능적으로 동일하지만 둘 중 하나를 선택할 때 고려해야 할 몇 가지 미묘한 모범 사례가 있습니다. 대부분의 개발자는 로컬 변수 및 매개변수에는 string을 사용하고 정적 메서드 호출에는 String을 사용하면 코드를 가독성 있고 일관성 있게 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"String","slug":"String","permalink":"http://hgko1207.github.io/tags/String/"},{"name":"string","slug":"string","permalink":"http://hgko1207.github.io/tags/string/"}]},{"title":"Vue.js 애플리케이션 개발을 위한 모범 사례","slug":"vue-4","date":"2024-01-05T02:23:02.000Z","updated":"2024-01-18T01:19:10.510Z","comments":true,"path":"2024/01/05/vue-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/05/vue-4/","excerpt":"","text":"Vue.js는 웹 애플리케이션 개발에 사용되는 널리 사용되는 자바스크립트 프레임워크입니다. 간단하고 적응 가능하며 확장성이 뛰어난 것으로 유명합니다. 그러나 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션을 개발하는 것은 어려울 수 있습니다. 이 글에서는 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션 개발을 위한 모범 사례에 대해 설명합니다. 모듈식 접근 방식 따르기 확장 가능하고 유지 관리 가능한 Vue.js 애플리케이션을 개발하기 위한 가장 중요한 모범 사례 중 하나는 모듈식 접근 방식을 따르는 것입니다. 이를 위해서는 애플리케이션을 보다 관리하기 쉽고 재사용 가능한 컴포넌트로 나누십시오. 각 컴포넌트에는 단일 책임이 있어야 이해하고 유지 관리하기 쉽습니다. 모듈식 접근 방식을 따르면 복잡한 Vue.js 애플리케이션을 더 쉽게 개발하고 유지 관리할 수 있습니다. 이를 통해 애플리케이션을 더 작고 관리하기 쉬운 부분으로 나눌 수 있으므로 문제를 더 쉽게 디버깅하고 해결할 수 있습니다. 또한 모듈화를 사용하면 테스트하기 쉬운 코드를 작성할 수 있으므로 오류가 줄어들고 성능이 향상될 수 있습니다. 애플리케이션을 더 작은 컴포넌트로 나누면 다른 개발자와 더 쉽게 협업할 수 있습니다. 애플리케이션을 모듈로 나누면 개별 개발자에게 특정 모듈을 할당할 수 있어 협업이 더 쉬워지고 충돌을 피할 수 있습니다. 상태 관리에 Vuex 사용 Vue.js 앱의 상태 관리 라이브러리를 Vuex라고 합니다. 이를 통해 중앙 집중식 저장소에서 애플리케이션 상태를 관리할 수 있습니다. 이는 문제를 깔끔하게 분리하고 예측 가능한 방식으로 애플리케이션 상태를 관리할 수 있도록 해줍니다. Vuex를 사용하면 애플리케이션의 상태 관리를 중앙 집중화하여 관리 및 업데이트를 더 쉽게 만들 수 있습니다. 이렇게 하면 여러 컴포넌트가 동일한 상태를 관리하려고 할 때 발생하는 일반적인 문제를 방지할 수 있습니다. 또한 Vuex는 문제를 깔끔하게 분리하여 애플리케이션을 더 쉽게 유지 관리하고 버그 위험을 줄일 수 있습니다. Vuex를 사용하면 애플리케이션 성능을 최적화하는 데에도 도움이 될 수 있습니다. 중앙 집중식 저장소에서 상태를 관리하면 중복 계산 및 업데이트를 방지하여 더 빠르고 효율적인 코드를 만들 수 있습니다. 탐색에 Vue Router 사용 Vue.js 앱의 표준 라우터를 Vue Router라고 합니다. 이를 통해 선언적 방식으로 애플리케이션의 탐색을 관리할 수 있습니다. 애플리케이션의 탐색을 일관되게 관리할 수 있는 방법을 제공하며 새 경로를 쉽게 추가할 수 있습니다. Vue Router를 사용하면 애플리케이션을 더 쉽게 탐색할 수 있습니다. Vue Router는 애플리케이션의 탐색을 관리하는 선언적 방법을 제공하므로 이해하고 유지 관리하기가 더 쉽습니다. 또한 Vue Router는 애플리케이션 전반에 걸쳐 일관된 사용자 경험을 만들어 사용자 만족도를 높이고 혼란을 줄일 수 있습니다. Vue Router는 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 지연 로딩을 사용하면 특정 경로에 필요한 컴포넌트만 로드할 수 있으므로 로드되는 불필요한 코드의 양이 줄어듭니다. 따라서 로드 시간이 빨라지고 전반적으로 성능이 향상될 수 있습니다. 모듈 번들링에 Webpack 사용 Webpack은 자바스크립트 애플리케이션을 위한 모듈 번들러입니다. 이를 통해 애플리케이션의 모듈을 단일 파일로 묶을 수 있습니다. 애플리케이션의 종속성을 깔끔하게 관리할 수 있는 방법을 제공하며 애플리케이션의 성능을 쉽게 최적화할 수 있습니다. Webpack을 사용하면 애플리케이션의 종속성 관리를 단순화할 수 있습니다. Webpack을 사용하면 애플리케이션의 모든 모듈을 단일 파일로 묶을 수 있으므로 관리 및 유지보수가 더 쉬워집니다. 또한 Webpack은 최종 파일의 크기를 최소화하여 애플리케이션 성능을 최적화하는 방법을 제공합니다. Webpack은 또한 코드를 모듈화하여 관리 및 유지보수를 더 쉽게 만드는 데 도움이 될 수 있습니다. 애플리케이션을 더 작고 재사용 가능한 컴포넌트로 분할하면 코드를 더 쉽게 개발하고 테스트할 수 있습니다. 또한 Webpack을 사용하면 다양한 플러그인과 로더를 활용할 수 있어 애플리케이션 빌드 프로세스를 더욱 유연하게 제어할 수 있습니다. 코드 품질을 위한 ESLint 사용 ESLint는 자바스크립트 애플리케이션을 위한 코드 품질 도구입니다. 이를 통해 일관된 코딩 표준을 적용하고 코드의 잠재적인 문제를 감지할 수 있습니다. 코드의 일관성, 가독성 및 일반적인 오류가 없는지 확인할 수 있는 방법을 제공합니다. ESLint를 사용하면 팀 전체에 코딩 표준을 적용할 수 있으므로 일관된 코드베이스를 더 쉽게 유지할 수 있습니다. 또한 ESLint는 사용되지 않는 변수나 정의되지 않은 함수 등 코드에서 잠재적인 문제를 감지하는 데 도움이 됩니다. 이를 통해 큰 문제가 되기 전에 잠재적인 오류를 잡아낼 수 있습니다. ESLint는 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 불필요한 코드나 최적화되지 않은 코드 등 잠재적인 성능 문제를 감지하여 애플리케이션을 더 빠르고 효율적으로 실행할 수 있습니다. 단위 테스트 작성 단위 테스트를 사용하면 애플리케이션의 개별 컴포넌트를 개별적으로 테스트하여 예상대로 작동하는지 확인할 수 있습니다. 단위 테스트를 작성하면 개발 프로세스 초기에 잠재적인 문제를 파악하여 심각한 문제가 발생하기 전에 문제를 쉽게 해결할 수 있습니다. 단위 테스트를 애플리케이션을 변경하거나 새로운 기능을 추가할 때에도 애플리케이션이 예상대로 작동하는지 확인할 수 있습니다. 또한 단위 테스트는 잠재적인 회귀를 파악하여 애플리케이션의 한 부분을 변경해도 다른 부분이 손상되지 않도록 하는 데 도움이 될 수 있습니다. 단위 테스트는 애플리케이션 성능을 최적화하는 데에도 도움이 됩니다. 잠재적인 성능 문제를 조기에 감지하면 코드를 변경함으로써 애플리케이션이 최대한 효율적으로 실행되도록 할 수 있습니다. 비동기 컴포넌트 사용 비동기 컴포넌트를 사용하면 컴포넌트를 한꺼번에 로드하지 않고 필요할 때만 로드할 수 있습니다. 이는 애플리케이션의 초기 로드 시간을 줄이고 전반적인 성능을 개선하는 데 도움이 될 수 있습니다. 비동기 컴포넌트를 사용하면 애플리케이션을 더 빠르고 효율적으로 실행할 수 있습니다. 모든 컴포넌트를 한 번에 로드하는 것이 아니라 필요할 때만 로드할 수 있어 불필요한 코드 로드량이 줄어듭니다. 이는 애플리케이션의 전반적인 성능을 개선하여 응답성이 향상되고 사용자 친화적인 애플리케이션을 만드는 데 도움이 됩니다. 또한 비동기 컴포넌트를 사용하면 코드를 모듈화하여 유지 관리와 이해가 쉬워집니다. 애플리케이션을 더 작고 재사용 가능한 컴포넌트로 분할하면 코드를 더 쉽게 개발하고 테스트할 수 있습니다. CSS 전처리기 사용 CSS 전처리기를 사용하면 표준 CSS에서 사용할 수 없는 변수, 함수 및 기타 기능을 사용하여 CSS를 작성할 수 있습니다. 이를 통해 CSS를 더 읽기 쉽고 유지 관리하기 쉽게 만들고 오류 위험을 줄이고 변경을 더 쉽게 만드는 데 도움이 됩니다. CSS 전처리기를 사용하면 CSS를 더욱 모듈화하여 애플리케이션 전체에서 코드를 더 쉽게 재사용할 수 있습니다. 또한 전처리기를 사용하면 보다 효율적인 CSS를 작성하여 로드되는 코드의 양을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다. CSS 전처리기는 애플리케이션의 유지보수성을 개선하는 데도 도움이 될 수 있습니다. 모듈화되고 재사용 가능한 CSS를 더 많이 작성할 수 있으므로 작성되는 중복 코드의 양을 줄일 수 있어 시간이 지나도 코드를 유지 관리하고 업데이트하기가 더 쉬워집니다. 사용자 정의 지시문(Directive) 사용 사용자 정의 지시문 사용하면 자신만의 지시문을 생성하여 Vue.js의 기능을 확장할 수 있습니다. 이는 코드를 더 모듈화하고 재사용할 수 있으므로 유지 관리와 이해가 더 쉬워집니다. 사용자 정의 지시문을 사용하면 Vue.js 컴포넌트에 새로운 기능을 추가하여 복잡한 애플리케이션을 더 쉽게 만들 수 있습니다. 또한 사용자 지정 지시문을 사용하면 코드를 더 읽기 쉽게 만들고 오류 위험을 줄이고 유지 관리가 더 쉬워집니다. 사용자 지정 지시문은 애플리케이션 성능을 최적화하는 데도 도움이 될 수 있습니다. 특정 작업에 최적화된 사용자 지정 지시문을 생성하면 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다. 서버 사이드 렌더링 사용 서버 사이드 렌더링(Server-Side Rendering, SSR)을 사용하면 사용자 브라우저가 아닌 서버에서 Vue.js 애플리케이션을 렌더링할 수 있습니다. SSR을 사용하면 초기 로드 시간을 줄이고 애플리케이션의 SEO를 개선하여 애플리케이션 성능을 향상시킬 수 있습니다. 또한 SSR은 자바스크립트 지원이 제한적이거나 전혀 없는 사용자도 애플리케이션에 액세스할 수 있도록 보장하여 접근성이 높은 애플리케이션을 만드는 데 도움이 됩니다. 또한 SSR은 애플리케이션의 상태를 중앙 집중식으로 관리함으로써 애플리케이션의 유지 관리성을 높이는 데 도움이 될 수 있습니다. 이렇게 하면 오류의 위험을 줄이고 시간이 지나도 코드를 더 쉽게 유지 관리할 수 있습니다. 코드 분할(Code Splitting) 사용 코드 분할을 사용하면 애플리케이션의 코드를 더 작고 관리하기 쉬운 덩어리로 분할할 수 있습니다. 코드 분할을 사용하면 로드되는 불필요한 코드의 양을 줄여 애플리케이션 성능을 향상시킬 수 있습니다. 또한 코드 분할을 사용하면 코드를 더 작고 관리하기 쉬운 덩어리로 나누어 애플리케이션을 더욱 모듈화하고 유지 관리하기 쉽게 만들 수 있습니다. 또한 코드 분할은 모든 코드를 한 번에 로드하는 대신 애플리케이션이 필요한 코드만 로드하도록 하여 보다 반응성이 뛰어나고 사용자 친화적인 애플리케이션을 만드는 데 도움이 될 수 있습니다. 결론 확장 가능하고 유지 관리가 가능한 Vue.js 애플리케이션을 개발하려면 모듈식 컴포넌트 사용, 성능 최적화, 코딩 표준 적용, ESLint, 단위 테스트 및 비동기 컴포넌트와 같은 도구 사용을 포함한 모범 사례의 조합이 필요합니다. 이러한 모범 사례를 따르면 Vue.js 애플리케이션을 더욱 확장 가능하고 유지 관리 가능하며 사용자 친화적으로 만들 수 있습니다. 또한 애플리케이션의 성능과 접근성을 향상시켜 자바스크립트 지원이 제한적이거나 전혀 없는 사용자도 애플리케이션에 더 쉽게 접근할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"Vuex","slug":"Vuex","permalink":"http://hgko1207.github.io/tags/Vuex/"}]},{"title":"WinUI와 WPF, WinForms, UWP, MFC 비교","slug":"window-1","date":"2024-01-04T06:16:49.000Z","updated":"2024-01-21T15:06:08.062Z","comments":true,"path":"2024/01/04/window-1/","link":"","permalink":"http://hgko1207.github.io/2024/01/04/window-1/","excerpt":"","text":"**Windows UI 라이브러리(WinUI)**는 Windows의 기본 레이어입니다. 여기에는 디자이너와 개발자가 Windows 애플리케이션을 구축하는 데 필요한 컨트롤과 유연한 디자인 시스템이 포함되어 있습니다. WinUI는 MFC(Microsoft Foundation Class Library) 프레임워크, WinForms, WPF(Windows Presentation Foundation) 및 UWP(Universal Windows Platform)와 같은 다양한 그래픽 사용자 인터페이스(GUI) 프레임워크의 최신 버전입니다. Microsoft는 데스크톱 앱(MFC, WinForms, WPF) 및 UWP 앱을 위한 포괄적인 최신 UI 프레임워크를 만들었으며, 새로운 Windows 애플리케이션 및 이전 애플리케이션에서 작동하도록 설계했습니다. 향상된 직관적인 기능을 통해 기본 애플리케이션을 빠르게 실행하거나 앱을 처음부터 새로 빌드할 수 있습니다. WinUI는 수년에 걸쳐 개선되었습니다. WinUI 2와 WinUI 3의 두 가지 버전이 있습니다. WinUI 2 라이브러리에는 UWP XAML 애플리케이션을 위한 UI 컨트롤과 스타일이 포함되어 있습니다. 이는 Windows 10 운영 체제에 내장된 XAML 및 시각적 계층과 운영 체제 위에 구축된 컨트롤 라이브러리로 구성됩니다. WinUI 3에는 전체 UWP XAML 코드베이스와 WinUI 2의 모든 컨트롤 및 스타일이 포함되어 있습니다. 또한 Windows 10 시각적 계층 내에 다른 강력한 Windows 기술 계층이 있으며, 이 모든 것이 단일 UI 프레임워크로 통합되어 있습니다. 이전 Windows 인터페이스를 좀 더 자세히 살펴보고 WinUI가 이전 버전과 어떻게 비교되는지 살펴보겠습니다. WinUI와 이전 프레임워크의 기능 비교하기 WinUI와 이전 프레임워크 간에는 몇 가지 차이점이 있습니다. MFC 1992년에는 최첨단 MFC(Microsoft Foundation Class Library)가 있었습니다. 이 라이브러리는 네이티브 C++ 및 객체 지향 UI 프레임워크로 구성되어 Windows 앱을 만들 수 있었습니다. 이 시기는 Windows의 기본 UI 계층에 Windows 애플리케이션 빌드하기 위한 스타일 및 컨트롤과 같은 기능이 포함되기 전이었습니다. MFC는 클래스 인스턴스화를 제공하고 데이터 구조나 객체를 동적으로 변환하여 나중에 저장, 전송 또는 재구성하는 방식으로 작동합니다. 또한 기본적인 입력 및 출력, 창 관리, 메뉴 및 대화 상자 컬렉션 저장을 위한 코드도 제공합니다. MFC 프레임워크는 재사용 가능한 클래스 세트를 통해 Windows 프로그래밍을 간소화하여 프로그래밍을 쉽게 만듭니다. 이 프레임워크는 문자열, 파일, 표준 Windows API 및 데이터 구조(예: Windows 및 Controls)와 같은 기본 프로그래밍에 사용되는 객체에 대한 클래스를 제공합니다. 오늘날 MFC 애플리케이션을 구축하는 개발자는 VSFlexGrid 및 True DBGrid와 같은 레거시 ActiveX 컨트롤을 사용할 수 있습니다. WinForms 2002년에 Microsoft는 .NET Framework와 함께 WinForms라는 또 다른 GUI를 출시했습니다. MFC와 마찬가지로 WinForms는 생산성을 크게 향상시켰지만 개발자가 .NET 애플리케이션에서만 사용할 수 있기 때문에 MFC를 대체하기에는 부족했습니다. WinForms는 .NET Framework 래퍼를 사용하며 Windows Forms에 고유한 컨트롤과 기능을 제공합니다. WinForms는 비주얼 디자이너 기반의 Visual Studio를 사용하여 데스크톱 또는 Win32 애플리케이션을 만듭니다. 또한 Visual Studio와 같은 끌어서 놓기 기능을 지원하므로 데스크톱 응용 프로그램 구축을 간소화할 수 있습니다. WinForms는 HTML 텍스트 형식을 지원하며 사용 가능한 HTML 서식 태그를 설명합니다. 이 기능 하나로 데이터를 필터링하는 UI를 구축할 수 있습니다. 거의 20년이 지난 지금, WinForms 개발은 ComponentOne의 .NET WinForms 컨트롤을 통해 더욱 강력해졌습니다. WPF 2006년에 Microsoft는 다양한 기능을 갖춘 개선된 WPF(Windows Presentation Foundation)를 출시했습니다. .NET 개발자를 대상으로 하는 WPF를 사용하면 Windows에서 Direct3D 렌더링을 사용하여 일부 그래픽 작업을 GPU로 오프로드할 수 있습니다. 이러한 오프로드는 컴퓨터 CPU의 작업 부하를 줄이는 데 도움이 됩니다. WPF는 최신 2D 및 3D 그래픽 하드웨어, 애니메이션, 스타일 및 미디어를 활용합니다. 마크업과 Code-behind를 모두 사용하여 애플리케이션을 개발할 수 있습니다. 마크업은 애플리케이션의 모양을 선언적으로 구현합니다. 예를 들어 대화 상자(Dialog box), 페이지 및 사용자 컨트롤의 모양을 디자인하고 도형과 그래픽으로 채웁니다. 반면, Code-behind는 애플리케이션의 동작을 구현하는 데 사용할 수 있는 관리되는 프로그래밍 언어입니다. WPF를 사용하면 XAML을 사용하여 UI를 만들 수 있습니다. 그래픽은 벡터 기반이므로 확장성이 뛰어나고 래스터 이미지에 비해 저장 용량을 덜 필요로 합니다. WPF는 데스크톱 애플리케이션을 쉽게 개발할 수 있는 최첨단 .NET 개발자 프레임워크였지만, UI에 초점을 맞추지 않았기 때문에 WinForms GUI 프레임워크를 대체하지는 못했습니다. WinForms 외에도 ComponentOne은 스타일과 현대화에 더 초점을 맞춘 유사한 WPF 컨트롤을 지원합니다. UWP 2006년 당시에는 서로 다른 선호도와 목표를 가진 Windows 개발자에게 적합한 클라이언트 애플리케이션 구축을 위한 세 가지 훌륭한 UI 프레임워크를 보유하고 있습니다. 그러다가 2012년에 Microsoft는 또 다른 GUI 프레임워크인 UWP XAML(Universal Windows Platform Extensible Application Markup Language)이 포함된 Windows 8을 출시했습니다. 이 프레임워크는 개발자가 Metro 또는 Store 앱이라고도 하는 모든 종류의 앱을 제작하는 데 도움이 됩니다. Microsoft는 최신 그래픽 엔진을 기반으로 UWP를 구축했으며, 개발자는 이를 C++ 및 .NET에서 사용할 수 있지만 제한 사항이 있습니다. 우선, UWP XAML은 UWP 앱에서만 작동하며, 이는 MFC, WinForms, WPF와 같은 프레임워크로 제작된 앱과는 다릅니다. MFC, WinForms 및 WPF로 빌드된 앱은 데스크톱 또는 Win32 앱이라고 하는 반면, UWP로 빌드된 앱은 UWP 앱이라고 합니다. 이들은 서로 다른 API 세트와 서로 다른 라이브러리 생태계를 가지고 있습니다. 예를 들어 MFC, WinForms 또는 WPF를 사용하는 Windows 개발자는 UWP XAML을 사용하기로 결정할 수 있습니다. 이 경우 UWP XAML은 UWP 앱에서만 작동하므로 엄격하게 UWP 앱을 빌드해야 합니다. 결과적으로 일부 개발자는 이를 꺼리게 됩니다. UWP 프레임워크는 WinRT(Windows Runtime) API를 사용하여 강력한 UI 기능을 제공하며, Windows 업데이트와 함께 배포되어 애플리케이션 수준을 한 단계 끌어올릴 수 있습니다. UWP는 가상 레지스트리와 시스템 파일을 사용하여 다른 앱과 충돌하지 않도록 작동합니다. 또한 Appx 패키지의 앱을 더 쉽게 제거하고 원활하게 업데이트하여 이미 설치된 앱에 새로운 기능을 추가할 수 있습니다. UWP가 마이크, 웹캠 또는 전체 파일 시스템과 같은 하드웨어에 액세스하려면 먼저 사용자가 액세스 권한을 부여해야 하므로 악성 앱이 손상을 입히는 것을 방지할 수 있습니다. 인기 있는 WPF 컨트롤을 기반으로 UWP 플랫폼용을 위한 유사한 컨트롤을 개발했으며, 여기에서 확인할 수 있습니다 . WinUI 이제 WinUI의 작동 방식을 살펴보겠습니다. WinUI와 이전 GUI 프레임워크 간의 중요한 차별화 요소 중 하나는 새로운 기능에 대한 이전 버전과의 호환성을 제공한다는 점입니다. Windows 10 장치하고만 호환되는 UWP와 달리 WinUI는 이전 버전의 Windows 10 및 11과도 호환됩니다. 예를 들어 WinUI 3을 사용하면 사용자가 최신 Windows 업데이트를 실행할 때까지 기다릴 필요 없이 새로운 기능이 포함된 앱을 빌드하고 출시할 수 있습니다. 또한 WinUI는 고도로 최적화되고 철저한 테스트를 거친 기본 Windows UI 플랫폼이며 개발자가 광범위하게 사용할 수 있습니다. 또한 사용자의 운영 체제 버전에 맞게 자동으로 조정되므로 앱을 더 쉽게 빌드할 수 있습니다. MAUI MAUI는 Google, Apple 및 Microsoft 기술을 하나로 통합하는 Xamarin과 유사한 최신 .NET 플랫폼입니다. MAUI는 다른 플랫폼에서 실행되는 앱이 공통된 비즈니스 로직을 공유할 수 있도록 Android, iOS, macOS 및 Windows API(WinUI)를 단일 API로 출력합니다. MAUI는 .NET 6 이상에서 지원되며, 지원되는 각 프레임워크에서 동일한 .NET Base Class Library(BCL)에 대한 액세스를 허용합니다. BCL은 기본 프레임워크의 세부 사항을 추상화하여 C# 코드를 한 번만 작성하면 여러 모바일 및 데스크톱 환경에서 애플리케이션을 출력할 수 있습니다. WinUI와 UWP 결합 기본적으로 WinUI 프레임워크로 구축된 대부분의 앱은 핵심이 UWP 앱입니다. 두 프레임워크는 동일한 기본 시각적 개체, 동일한 기본 Windows API 및 동일한 XAML 모델을 공유합니다. WinUI와 UWP의 기본 API 로직은 C이지만 이러한 프레임워크를 사용하는 개발자는 Windows 앱을 빌드할 때 C#, C, F#, Visual Basic .NET(VB.NET), JavaScript 등 다양한 프로그래밍 언어 중에서 선택할 수 있습니다. WinUI와 UWP의 이러한 모든 유사점에도 불구하고 차이점이 있습니다. 예를 들어 UWP는 Windows와 함께 배포되므로 사용자가 수정 사항, 개선 사항 및 새로운 UI 컨트롤에 액세스하려면 최신 Windows 버전으로 업데이트해야 합니다. 이러한 업데이트 필요성은 최신 버전의 Windows로 지속적으로 업데이트할 수 없는 사용자에게는 약간의 병목 현상이 될 수 있습니다. Microsoft는 이 문제를 해결하기 위해 WinUI를 설계했습니다. Windows와 분리되어 있고 UWP에서 추출된 API를 사용하므로 업데이트가 더 쉽습니다. 이 두 프레임워크를 결합하여 멋진 앱을 만들 수 있습니다. 개발자는 WinUI 2.x를 사용하여 UWP 애플리케이션을 만들 수 있습니다. UWP는 Windows에 배포되므로 WinUI와 UWP가 함께 작동하여 XAML Islands와 같은 기능을 기존 데스크톱 애플리케이션에 추가할 수 있습니다. WinUI 기능 WinUI의 많은 기능 중 하나는 이전 버전과 호환되는 Windows Creators Update입니다. WinUI에는 Windows용 React Native도 포함되어 있습니다. React와 비슷하지만 웹 구성 요소 대신 기본 구성 요소를 빌딩 블록으로 사용한다는 점이 다릅니다. WinUI의 새로운 기능인 React Native를 사용하면 새로운 코드를 배우거나 사용하지 않고도 새 앱을 만들거나 기존 앱을 업그레이드할 수 있습니다. Windows 스토어를 통해 이러한 JavaScript 앱을 패키징하고 배포할 수 있습니다. 그 기능에는 기본 모듈 자동 연결, 더 나은 테마 지원 및 탐색 메뉴가 포함됩니다. React Native는 Windows 10 SDK와 macOS 10.13 SDK를 모두 지원합니다. 개발자는 JavaScript를 사용하여 Windows 10과 macOS 데스크톱 및 노트북 생태계에서 지원되는 장치용 기본 Windows 앱을 구축할 수 있습니다. WinUI를 사용한 개발의 이점 다른 프레임워크와 비교하여 WinUI를 사용하여 앱을 빌드할 때 얻을 수 있는 몇 가지 이점을 살펴보겠습니다. 지속적인 업데이트: 다른 프레임워크와 비교하여 WinUI를 사용하면 Windows SDK를 업데이트할 필요 없이 최신 버전의 Fluent 디자인, 컨트롤 및 시각적 요소로 앱을 최신 상태로 유지할 수 있다는 이점이 있습니다. 뛰어난 유연성: 개발자들은 모든 버전의 운영 체제에 유연하게 적응할 수 있는 WinUI를 높이 평가합니다. 또한 네이티브 개발도 지원합니다. 예를 들어 100% C++이더라도 .NET 앱에서 사용할 수 있습니다. 이전 버전과의 호환성: WinUI는 다양한 Windows 10 버전과의 하위 호환성을 제공합니다. 예를 들어 최신 버전의 Windows 10을 사용하지 않는 사용자도 새로운 XAML 기능이 포함된 앱을 출시 직후에 빌드하여 출시할 수 있습니다. 버전 확인이 필요하지 않습니다: WinUI로 빌드된 애플리케이션은 UWP XAML의 주요 컨트롤이나 기능을 사용하기 위해 버전 확인이 필요하지 않습니다. 사용성: UWP와 달리 WinUI를 사용하면 개발자는 Windows를 업데이트하지 않고도 최신 UI 컨트롤을 사용할 수 있습니다. 확장성: MAUI로 개발하면 Android, iOS, macOS용 모바일 버전으로 즉시 확장할 수 있는 WinUI 애플리케이션을 만들 수 있습니다. WinUI 단점 WinUI는 이전 프레임워크에 비해 개선되었지만 몇 가지 단점이 있습니다. 우선, WinUI는 WPF 앱과 달리 Uno 플랫폼 없이 Windows 7에서 실행하거나 배포할 수 없습니다. 또한 WinForms와 비교할 때 WinUI는 빠른 UI 개발에 대한 평판이 좋지 않습니다. 예를 들어, 많은 Windows 개발자는 .NET 라이브러리에 대한 간단한 유틸리티 또는 UI Test harness를 만들 때 여전히 WinForms로 되돌아갑니다. Test harness 시스템 및 시스템 컴포넌트를 시험하는 환경의 일부분으로 시험을 지원하는 목적 하에 생성된 코드와 데이터. 시험 드라이버 (test driver)라고도 하며 일반적으로 단위 시험이나 모듈 시험에 사용하기 위해 코드 개발자가 만든다. 결론 WinUI는 다양한 GUI 프레임워크 중 최신 버전입니다. WinUI와 이전 프레임워크의 핵심 차이점은 SDK를 업데이트할 필요 없이 유연한 디자인과 업데이트된 컨트롤에 액세스할 수 있다는 점입니다. 이전 프레임워크에 비해 몇 가지 단점이 있지만 유연성, 이전 버전과의 호환성 및 범용성 때문에 많은 개발자가 WinUI로 전환했습니다. WinUI로 전환하는 경우에도 GrapeCity ComponentOne의 .NET 구성 요소 제품군(2021년 중반부터 WinUI에서 사용 가능)을 사용하여 개발 시간을 절약할 수 있습니다. 작고 유연한 데이터 그리드, 차트, 보고서, 달력, 입력, 비즈니스 인텔리전스 대시보드 및 기타 UI 요소를 WinUI 애플리케이션에 빠르게 추가하여 익숙한 컨트롤로 사용자 경험을 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WinUI","slug":"Programming/Frontend/WinUI","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WinUI/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"WinUI","slug":"WinUI","permalink":"http://hgko1207.github.io/tags/WinUI/"},{"name":"WinForms","slug":"WinForms","permalink":"http://hgko1207.github.io/tags/WinForms/"},{"name":"UWP","slug":"UWP","permalink":"http://hgko1207.github.io/tags/UWP/"},{"name":"MFC","slug":"MFC","permalink":"http://hgko1207.github.io/tags/MFC/"}]},{"title":"자바스크립트 프레임워크 소개","slug":"js-dev-12","date":"2024-01-03T01:36:32.000Z","updated":"2024-01-21T15:06:01.186Z","comments":true,"path":"2024/01/03/js-dev-12/","link":"","permalink":"http://hgko1207.github.io/2024/01/03/js-dev-12/","excerpt":"","text":"소개 자바스크립트(JavaScript)는 현대 웹 개발의 필수 구성 요소가 되었으며, 그 인기로 인해 복잡한 애플리케이션을 구축하는 과정을 간소화하는 많은 프레임워크가 만들어졌습니다. 이러한 프레임워크는 개발자가 웹 애플리케이션을 빠르고 효율적으로 제작하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서는 가장 인기 있는 자바스크립트 프레임워크 중 일부를 살펴보고 고유한 기능을 살펴보겠습니다. Vue Vue는 개발자들 사이에서 인기를 얻고 있는 경량 자바스크립트 프레임워크입니다. 쉽게 배우고 사용할 수 있도록 설계되었으며 다양한 기능을 제공하여 중소규모 애플리케이션을 구축하는 데 탁월한 선택입니다. Vue는 사용자 인터페이스 구축에 반응형 접근 방식을 사용합니다. 즉, 사용자 인터페이스의 변경 사항이 실시간으로 자동 업데이트됩니다. 또한 복잡한 애플리케이션 구축하는 과정을 간소화하는 다양한 내장 지시어와 플러그인을 제공합니다. React React는 Facebook에서 개발하여 널리 사용되는 자바스크립트 라이브러리입니다. 개발자가 크고 복잡한 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다. React는 사용자 인터페이스를 더 작은 컴포넌트로 나누어 애플리케이션 전체에서 쉽게 재사용할 수 있도록 하는 방식으로 작동합니다. 이러한 모듈식 접근 방식을 사용하면 복잡한 사용자 인터페이스를 쉽게 관리할 수 있으며 개발자는 사용자 인터페이스가 아닌 애플리케이션의 로직에 집중할 수 있습니다. 또한 React는 속도와 성능이 뛰어나 실시간 업데이트가 필요한 웹 애플리케이션을 구축하는 데 탁월한 선택입니다. Angular Angular는 Google에서 개발한 또 다른 인기 있는 자바스크립트 프레임워크입니다. 개발자가 동적이고 확장 가능한 웹 애플리케이션을 구축할 수 있도록 설계되었습니다. Angular는 사용자 인터페이스 구축하는 데 선언적 접근 방식을 사용하므로 복잡한 사용자 인터페이스를 쉽게 관리할 수 있습니다. 또한 종속성 주입, 양방향 데이터 바인딩, 내장 지시어 등 다양한 기능을 제공하므로 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Angular는 성능도 뛰어나 고성능 웹 애플리케이션을 구축하는 데 널리 사용됩니다. Ember Ember는 개발자가 야심 찬 웹 애플리케이션을 구축할 수 있도록설계된 강력한 자바스크립트 프레임워크입니다. 강력한 라우터, 데이터 레이어, 내장된 테스트 프레임워크 등 다양한 기능을 제공하므로 크고 복잡한 애플리케이션을 구축하는 데 탁월한 선택입니다. 또한 Ember는 개발자가 모범 사례를 쉽게 따르고 시간이 지나도 쉽게 유지 관리할 수 있는 애플리케이션을 쉽게 구축할 수 있도록 하는 일련의 규칙을 제공합니다. Backbone Backbone은 개발자가 중소규모 웹 애플리케이션을 구축할 수 있도록 설계된 경량 자바스크립트 프레임워크입니다. 간단한 이벤트 시스템, 모델 및 컬렉션, 강력한 라우터 등 다양한 기능을 제공합니다. Backbone은 단순하고 사용하기 쉬운 것으로 유명하여 간단한 애플리케이션을 빠르게 구축하는 데 탁월한 선택입니다. 결론 자바스크립트 프레임워크는 최신 웹 개발의 필수 구성 요소가 되었습니다. 개발자가 복잡한 애플리케이션을 빠르고 효율적으로 구축하는 데 도움이 되는 다양한 기능과 이점을 제공합니다. 이 글에서 논의한 프레임워크는 개발자가 사용할 수 있는 다양한 옵션 중 일부에 불과합니다. 프레임워크를 선택할 때 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다. 올바른 프레임워크와 숙련된 개발 팀이 있으면 복잡한 웹 애플리케이션을 구축하는 것이 그 어느 때보다 쉬워졌습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"}]},{"title":"예측 분석을 통한 인공지능(AI) 기반 상호 작용","slug":"ai-4","date":"2024-01-02T06:19:41.000Z","updated":"2024-01-02T07:06:48.139Z","comments":true,"path":"2024/01/02/ai-4/","link":"","permalink":"http://hgko1207.github.io/2024/01/02/ai-4/","excerpt":"","text":"인공 지능(AI)은 다양한 산업 분야에서 강력한 도구로 부상하여 기술과 상호 작용하는 방식에 혁명을 일으켰습니다. AI가 크게 발전한 분야 중 하나는 예측 분석 분야로, 기업이 데이터 기반 인사이트를 바탕으로 정보에 입각한 의사결정을 내릴 수 있도록 지원합니다. 이 글에서는 AI 기반 상호작용과 예측 분석이 어떻게 산업을 변화시키고 비즈니스의 미래를 만들어가는지 살펴봅니다. 인사이트는 통찰력이나 깊은 이해를 의미하는 단어로, 특히 비즈니스나 마케팅 분야에서는 데이터를 분석하여 얻은 유용한 정보나 통찰력을 의미하기도 합니다. 예측 분석의 힘 예측 분석은 기존 데이터 세트에서 정보를 추출하여 패턴을 파악하고 미래의 결과나 추세를 예측하는 작업입니다. 기업은 과거 데이터를 분석하여 고객 행동, 시장 동향, 운영 효율성에 대한 귀중한 인사이트를 얻을 수 있습니다. 데이터의 양이 방대하고 복잡하기 때문에 사람이 데이터를 효율적으로 처리하고 의미 있는 인사이트를 도출하기란 쉽지 않습니다. 바로 이 점이 인공지능이 필요한 이유입니다. 예측 분석에서 AI의 역할 AI 알고리즘은 방대한 양의 데이터를 매우 빠른 속도로 처리하여 인간이 놓칠 수 있는 패턴과 추세를 파악할 수 있습니다. AI의 하위 집합인 머신러닝 알고리즘은 과거 데이터를 통해 학습하고 패턴과 상관관계를 기반으로 예측할 수 있습니다. 기업은 AI 기반 예측 분석을 통해 이러한 알고리즘을 활용하여 데이터 기반 의사결정을 내리고 해당 산업에서 경쟁 우위를 확보할 수 있습니다. 고객 상호 작용 향상 예측 분석을 통한 AI 기반 상호 작용은 기업이 고객과 소통하는 방식을 변화시켰습니다. AI 알고리즘은 구매 내역, 검색 행동, 소셜 미디어 상호 작용 상호 작용과 같은 고객 데이터를 분석하여 고객 경험을 개인화할 수 있습니다. 예를 들어, 전자상거래 플랫폼은 개인별 선호도에 따라 제품을 추천하여 고객 만족도를 높이고 판매를 촉진할 수 있습니다. 또한 AI 기반의 챗봇은 실시간 고객 지원을 제공하여 문의에 답변하고 문제를 신속하게 해결할 수 있습니다. 공급망 관리 최적화 AI와 결합된 예측 분석은 수요를 예측하고 재고 관리를 개선하며 물류를 간소화하여 공급망 관리를 최적화할 수 있습니다. AI 알고리즘은 과거 판매 데이터를 분석하여 미래 수요 패턴을 예측함으로써 기업이 생산 수준을 조정하고 품절이나 과잉 재고를 방지할 수 있도록 지원합니다. 또한 AI 기반 알고리즘은 운송 경로를 최적화하여 운송 비용을 절감하고 배송 효율성을 개선할 수 있습니다. 사기 탐지 및 위험 완화 AI 기반 예측 분석은 사기 탐지 및 위험 완화에 있어 매우 유용하다는 것이 입증되었습니다. AI 알고리즘은 대량의 금융 데이터를 분석하여 사기 행위를 나타내는 의심스러운 패턴과 이상 징후를 식별할 수 있습니다. 이러한 사전 예방적 접근 방식을 통해 기업은 심각한 재정적 손실을 초래하기 전에 사기를 탐지하고 예방할 수 있습니다. 또한 AI는 여러 소스의 데이터를 분석하여 잠재적인 위험을 식별하고 완화 전략을 개발하여 잠재적인 위협으로부터 비즈니스를 보호할 수 있습니다. 의료 및 예측 분석 의료 업계에서는 AI 기반 상호 작용과 예측 분석이 환자 치료에 혁신을 일으키고 있습니다. AI 알고리즘은 환자 기록을 분석하여 질병 진행을 예측하고, 개인 맞춤형 치료 계획을 추천하며, 환자 치료 결과를 개선할 수 있습니다. 또한 AI는 잠재적인 건강 위험을 식별하여 조기 개입 및 예방 조치를 가능하게 합니다. AI 기반 챗봇과 가상 비서는 24시간 지원을 제공하여 환자의 질문에 답하고 의료 조언을 제공할 수 있습니다. 재무 예측 및 투자 결정 AI 기반 예측 분석은 정확한 예측과 투자 결정을 지원함으로써 금융 산업을 재편하고 있습니다. AI 알고리즘은 시장 동향, 경제 지표 및 과거 데이터를 분석하여 주식 시장 움직임을 예측하여 거래자가 정보에 입각한 결정을 내릴 수 있도록 돕습니다. 또한 AI 기반 로보 어드바이저는 개인의 위험 프로필을 기반으로 개인화된 투자 추천을 제공하여 금융 서비스의 효율성과 접근성을 향상시킬 수 있습니다. 결‍론 AI와 예측 분석의 결합은 다양한 산업 분야에서 엄청난 잠재력을 발휘하고 있습니다. 고객과의 상호작용을 강화하고 공급망 관리를 최적화하는 것부터 사기를 탐지하고 의료 결과를 개선하는 것까지, AI 기반 상호작용과 예측 분석의 결합은 비즈니스를 변화시키고 미래를 만들어가고 있습니다. 기술이 계속 발전함에 따라 전 세계 비즈니스에서 데이터 기반 의사결정을 내리고 새로운 기회를 창출하는 데 AI의 역할이 점점 더 중요해질 것으로 예상됩니다. 이러한 혁신적인 기술을 수용하는 것은 끊임없이 진화하는 디지털 환경에서 경쟁력을 유지하는 데 핵심이 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"예측분석","slug":"예측분석","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EC%B8%A1%EB%B6%84%EC%84%9D/"}]},{"title":"블록체인, 영향력 있는 새로운 트렌드","slug":"blockchain-3","date":"2024-01-02T01:52:51.000Z","updated":"2024-01-15T01:10:05.712Z","comments":true,"path":"2024/01/02/blockchain-3/","link":"","permalink":"http://hgko1207.github.io/2024/01/02/blockchain-3/","excerpt":"","text":"블록체인 기술은 전 세계적으로 다양한 산업에 혁명을 일으키고 있는 획기적인 혁신으로 등장했습니다. 처음에는 비트코인과 같은 암호화폐와의 연관성으로 알려졌던 블록체인은 이제 소프트웨어 개발에 광범위한 영향을 미치는 파괴적인 힘으로 인식되고 있습니다. 이 글에서는 블록체인이 어떻게 소프트웨어 개발에 영향력 있는 트렌드가 되어 다양한 애플리케이션 전반에 걸쳐 보안, 투명성 및 효율성을 향상시키는지 살펴봅니다. 보안 강화 블록체인 기술의 가장 중요한 장점 중 하나는 강력한 보안 기능입니다. 기존 소프트웨어 시스템은 중앙화된 기관이나 서버에 의존하는 경우가 많아 해킹과 데이터 침해에 취약합니다. 반면 블록체인은 데이터가 여러 노드에 분산되고 저장되는 탈중앙화 네트워크를 사용합니다. 이러한 고유한 탈중앙화와 암호화 알고리즘이 결합되어 블록체인에 저장된 데이터는 안전하고 위변조가 불가능합니다. 그 결과, 안전한 애플리케이션을 구축하고 민감한 정보를 보호하며, 사용자 신뢰를 높이기 위해 소프트웨어 개발에 블록체인 기술이 점점 더 많이 채택되고 있습니다. 투명성과 책임성 블록체인의 투명성과 불변성은 신뢰와 책임이 필요한 산업을 변화시키고 있습니다. 블록체인을 사용하면 모든 거래나 데이터 입력이 투명하고 영구적인 방식으로 기록되어 네트워크의 모든 참가자가 볼 수 있습니다. 이러한 투명성 덕분에 관련된 모든 당사자가 거래를 독립적으로 검증하고 감사할 수 있으므로 중개자가 필요하지 않습니다. 소프트웨어 개발에서 블록체인 기반 솔루션을 활용하여 감사 가능한 시스템을 만들고, 공급망을 간소화하며, 투표 시스템, 부동산 거래 및 지적 재산 관리의 투명성을 보장합니다. 분산형 애플리케이션(Decentralized Applications, DApps) 블록체인이 소프트웨어 개발에 미치는 영향은 보안과 투명성 그 이상입니다. 이는 탈중앙화 애플리케이션(DApps) 개발의 길을 열었습니다. DApps는 블록체인의 탈중앙화 아키텍처, 스마트 계약 및 분산 합의 메커니즘을 활용하여 단일 개체에 의해 제어되지 않고 자율적으로 운영되는 애플리케이션을 만듭니다. DApps는 중개자가 필요 없기 때문에 사용자가 자신의 데이터와 상호 작용을 더 잘 제어할 수 있는 P2P 생태계를 만듭니다. 소프트웨어 개발자들은 금융, 게임, 공급망 관리, 신원 확인과 같은 분야에서 DApps의 잠재력을 점점 더 많이 탐색하고 있습니다. 스마트 컨트랙트 스마트 컨트랙트는 특정 조건이 충족되면 미리 정의된 작업을 자동으로 실행하는 코드로 작성된 자체 실행 계약입니다. 블록체인의 스마트 컨트랙트 기능은 소프트웨어 개발자에게 새로운 길을 열어주었습니다. 개발자는 스마트 컨트랙트를 활용하여 복잡한 비즈니스 프로세스를 자동화하고, 중개자의 필요성을 줄이며, 투명하고 감사 가능한 계약의 실행을 보장할 수 있습니다. 이 기술은 신뢰, 투명성, 효율성이 가장 중요한 보험금 청구, 공급망 관리, 금융 거래와 같은 분야에서 특히 유용합니다. 토큰화 및 디지털 자산 블록체인 기술은 자산의 토큰화를 가능하게 하여 블록체인 상에서 실물 또는 디지털 아이템을 디지털 토큰으로 표현합니다. 이러한 토큰화는 안전하게 거래, 저장 및 검증할 수 있는 디지털 자산을 생성함으로써 소프트웨어 개발에 새로운 가능성을 열어줍니다. 예를 들어, 예술품, 수집품, 가상 부동산과 같은 고유한 디지털 자산을 소유하고 검증할 수 있는 대체 불가능한 토큰(NFT)이 큰 주목을 받고 있습니다. 소프트웨어 개발자들은 디지털 신원 확인, 디지털 투표, 탈중앙화 금융(DeFi)과 같은 분야에서 혁신적인 애플리케이션을 개발하기 위해 토큰화를 모색하고 있습니다. 상호운용성 및 확장성 블록체인 기술이 계속 발전함에 따라 블록체인 고유의 문제인 확장성과 상호운용성을 해결하기 위한 노력도 계속되고 있습니다. 다양한 프로젝트에서 서로 다른 블록체인이 원활하게 통신할 수 있도록 지원하여 협업과 데이터 교환을 향상시키는 솔루션을 개발하고 있습니다. 상호운용성을 통해 소프트웨어 개발자는 여러 블록체인 플랫폼의 강점을 활용하고 다양한 사용 사례에 맞는 애플리케이션을 구축할 수 있습니다. 블록체인의 트랜잭션 처리 기능의 한계를 극복하기 위해 레이어 2 프로토콜 및 샤딩과 같은 확장성 솔루션도 개발되고 있습니다. 결론 블록체인 기술은 소프트웨어 개발의 강력한 힘으로 부상하여 다양한 애플리케이션에 향상된 보안, 투명성 및 효율성을 제공합니다. 스마트 컨트랙트, 토큰화, 상호운용성과 같은 기능과 함께 탈중앙화된 특성은 산업을 재편하고 혁신적인 솔루션을 위한 길을 열어주고 있습니다. 소프트웨어 개발자들이 블록체인의 잠재력을 수용함에 따라 기존 비즈니스 프로세스를 재정의하고 사용자가 데이터와 디지털 자산을 더 잘 제어할 수 있도록 지원하는 파괴적인 애플리케이션이 등장할 것으로 예상됩니다. 소프트웨어 개발의 미래는 의심할 여지 없이 블록체인 기술의 영향력 있는 트렌드와 얽혀 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"암호화폐","slug":"암호화폐","permalink":"http://hgko1207.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"}]},{"title":"HTML과 CSS 기술을 향상시킬 수 있는 10가지 소규모 프로젝트 아이디어","slug":"web-design-4","date":"2023-12-29T15:13:09.000Z","updated":"2023-12-29T15:32:41.084Z","comments":true,"path":"2023/12/30/web-design-4/","link":"","permalink":"http://hgko1207.github.io/2023/12/30/web-design-4/","excerpt":"","text":"소개 HTML과 CSS를 배우는 것은 웹 개발에 관심이 있는 모든 사람에게 필수적인 단계입니다. 이러한 기본 기술은 인터넷에 있는 모든 웹사이트의 구성 요소입니다. 이를 익히려면 연습이 필요한데, 소규모 프로젝트에 참여하는 것보다 더 좋은 방법이 있을까요? 이 글에서는 HTML 및 CSS 기술을 연마하는 데 도움이 되는 10가지 소규모 프로젝트 아이디어를 살펴보겠습니다. 개인 포트폴리오 웹사이트 개인 포트폴리오 웹사이트를 만들어 자신의 기술, 프로젝트, 경험을 보여주세요. 이 프로젝트를 통해 콘텐츠 구조화를 위한 HTML과 레이아웃 및 디자인을 위한 CSS를 연습하면서 웹사이트를 디자인하고 스타일을 지정할 수 있습니다. 레시피 북 HTML과 CSS를 사용하여 디지털 요리책을 디자인하세요. 좋아하는 요리법을 나열하고, 이미지를 추가하고, 시각적으로 매력적으로 보이도록 레이아웃을 스타일링할 수 있습니다. 제품 랜딩 페이지 마음에 드는 제품을 선택하고 해당 제품의 랜딩 페이지를 디자인하세요. 제품 설명, 이미지, 클릭 유도 버튼을 포함하여 실제 전자상거래 페이지를 모방할 수 있습니다. 블로그 페이지 HTML과 CSS로 간단한 블로그 페이지를 만들어보세요. 블로그 게시물을 표시하고, 탐색을 위한 사이드바를 포함하며, 원하는 대로 스타일을 지정할 수 있습니다. 이 프로젝트는 레이아웃 및 반응형 디자인 작업에 도움이 됩니다. 헌정 페이지 존경하는 역사적인 인물이나 유명인을 선택하여 해당 인물에 대한 헌정 페이지를 만드세요. 이미지, 인용문, 간략한 소개를 포함하세요. HTML로 콘텐츠를 구조화하고 CSS로 스타일을 지정하는 연습을 할 수 있는 좋은 프로젝트입니다. 로그인/등록 양식 유효성 검사가 포함된 로그인 및 등록 양식을 작성하세요. 이 프로젝트는 양식 작성 및 사용자 입력 작업에 대한 인사이트를 얻을 수 있습니다. 이미지 갤러리 HTML과 CSS로 간단한 이미지 갤러리를 개발해 보세요. 이미지 썸네일을 추가하고, 라이트박스를 만들고, 부드러운 전환을 구현할 수 있습니다. 레이아웃과 인터랙션 디자인을 연습하기에 좋은 프로젝트입니다. 할 일 목록 할 일 목록 앱을 만들어 보세요. 기본 기능으로 작업을 추가, 편집, 제거할 수 있습니다. 이 프로젝트는 HTML과 CSS를 사용하여 DOM을 조작하는 방법을 이해하는 데 도움이 됩니다. 날씨 앱 API에서 날씨 데이터를 가져와 사용자 친화적인 인터페이스에 표시하는 날씨 앱을 만드세요. 이 프로젝트를 통해 외부 데이터 소스 및 동적 콘텐츠 작업에 대한 인사이트를 얻을 수 있습니다. CSS 애니메이션 로딩되는 스피너, 튀어 오르는 공 또는 슬라이딩 탐색 메뉴를 만들어 CSS 애니메이션을 실험해 보세요. 애니메이션은 CSS의 창의적인 측면을 탐색할 수 있는 재미있는 방법입니다. 결론 소규모 프로젝트 작업은 HTML과 CSS 기술을 향상시키는 훌륭한 방법입니다. 이러한 프로젝트는 실무 경험을 쌓는 데 도움이 될 뿐만 아니라 잠재적인 고용주나 고객에게 선보일 작업 포트폴리오를 구축하는 데도 도움이 됩니다. 이러한 프로젝트를 완료하면서 지속적으로 도전하고 HTML 및 CSS의 새로운 기술과 기능을 탐색하는 것을 잊지 마세요. 연습을 많이 할수록 웹 개발에 대한 자신감과 숙련도가 높아집니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"}]},{"title":"사용자 인터페이스 디자인의 기초: 종합 가이드","slug":"web-5","date":"2023-12-27T13:36:52.000Z","updated":"2023-12-27T13:58:08.491Z","comments":true,"path":"2023/12/27/web-5/","link":"","permalink":"http://hgko1207.github.io/2023/12/27/web-5/","excerpt":"","text":"소개 사용자 인터페이스(UI) 디자인은 사용자 친화적이고 시각적으로 매력적인 소프트웨어, 웹 사이트, 모바일 애플리케이션을 만드는 데 중요한 측면입니다. 잘 디자인된 UI는 성공적이고 직관적인 제품과 실망스러운 제품 사이의 차이를 만들 수 있습니다. 이 글에서는 사용자 인터페이스 디자인의 기본 사항을 살펴보고, 주요 원칙을 세분화하고, 이러한 개념을 설명하기 위한 실제 사례를 제공합니다. 사용자 이해 UI 디자인의 첫 번째 단계는 타겟 고객을 이해하는 것입니다. 효과적인 디자인은 사용자의 요구, 선호도, 기대치를 충족시켜야 합니다. 이 점을 설명하기 위해 Facebook의 예를 살펴보겠습니다. Facebook의 UI 디자인은 기술에 능숙한 밀레니얼 세대부터 노년층에 이르기까지 다양한 사용자층에 맞춰져 있습니다. 깔끔하고 탐색하기 쉬운 인터페이스로 모든 연령대의 사람들이 쉽게 접근할 수 있어 폭넓은 사용자층을 확보할 수 있습니다. 일관성과 단순성 UI 디자인의 일관성은 매우 중요합니다. 사용자가 시스템의 작동 방식을 쉽게 예측할 수 있기 때문입니다. 탐색 메뉴의 배치, 버튼 스타일, 색 구성표 등 모든 면에서 일관성을 유지하면 편안한 사용자 환경을 만들 수 있습니다. Google의 검색 엔진을 예로 들어 보겠습니다. 수년 동안 Google의 UI는 비교적 일관성을 유지해 왔습니다. 사용자는 무엇을 기대해야 할지 알고 있으며, 이러한 친숙함은 널리 사용되는 데 기여합니다. 단순성은 또 다른 핵심 요소입니다. 어수선하거나 지나치게 복잡한 UI는 사용자를 압도할 수 있습니다. Apple의 iPhone은 단순함의 힘을 보여주는 대표적인 예입니다. 깔끔하고 직관적인 인터페이스를 통해 사용자는 학습 곡선을 거의 또는 전혀 거치지 않고도 기기를 집어 들고 사용할 수 있습니다. 시각적 계층 UI 디자인에서 시각적 계층 구조는 화면에서 요소의 배열과 우선순위를 의미합니다. 시각적 계층 구조는 사용자의 주의를 유도하고 인터페이스를 효과적으로 탐색할 수 있도록 도와줍니다. 에어비앤비(Airbnb) 웹사이트를 생각해 보세요. 검색창과 클릭 유도 버튼은 페이지 상단에 눈에 잘 띄게 배치되어 가장 중요한 작업으로 사용자의 주의를 집중시킵니다. 피드백과 응답성 사용자는 UI와 상호작용할 때 피드백을 받아야 합니다. 버튼에 마우스를 갖다 대면 색이 바뀌거나 작업이 로드 중일 때 진행률 표시줄이 표시되는 등 간단한 방법으로도 피드백을 받을 수 있습니다. 인기 있는 팀 커뮤니케이션 플랫폼인 Slack은 실시간 입력 표시, 메시지 전송 확인 및 읽음 확인을 통해 뛰어난 피드백을 제공합니다. 이를 통해 사용자는 플랫폼 내에서 진행 중인 작업과 상호 작용에 대한 정보를 계속 확인할 수 있습니다. 접근성 UI 디자인은 장애인을 포함한 모든 사람이 애플리케이션을 사용할 수 있도록 접근성을 우선적으로 고려해야 합니다. Microsoft의 Windows 운영 체제는 접근성 기능을 개선하는 데 상당한 진전을 이루었습니다. 모든 사용자가 UI에 액세스할 수 있도록 화면 판독기 및 음성 명령과 같은 다양한 보조 기술을 제공합니다. 타이포그래피와 가독성 올바른 글꼴과 타이포그래피를 선택하는 것은 UI 디자인에 매우 중요합니다. 텍스트는 가독성이 뛰어나고 심미적으로도 아름다워야 합니다. 예를 들어 트위터의 UI는 트윗에 간단하고 가독성이 좋은 글꼴을 사용하여 사용자가 콘텐츠에 쉽게 참여할 수 있도록 합니다. 사용자 테스트 사용자 테스트에는 디자인 과정에서 실제 사용자로부터 피드백을 받는 과정이 포함됩니다. 이러한 피드백은 문제를 파악하고 UI를 개선하는 데 매우 중요합니다. 클라우드 스토리지 플랫폼인 Dropbox는 사용자 경험을 개선하기 위해 정기적으로 사용자 테스트를 실시합니다. 실제 사용자의 참여를 통해 인터페이스를 지속적으로 개선하고 사용자 친화적인 인터페이스를 만듭니다. 결론 사용자 인터페이스 디자인은 예술과 과학을 결합하여 사용자에게 매력적이고 직관적인 경험을 제공하는 종합 분야입니다. 사용자를 이해하고, 일관성을 유지하고, 단순성을 우선시하고, 시각적 계층 구조를 설정하고, 피드백을 제공하고, 접근성을 보장하고, 적절한 타이포그래피를 선택하고, 사용자 테스트를 수행하는 것은 모두 UI 디자인의 필수 요소입니다. Facebook, Google, Apple, Airbnb, Slack, Microsoft 및 Twitter와 같은 회사의 실제 사례를 통해 확인할 수 있습니다. 이러한 기본 원칙을 준수하면 원활한 사용자 경험을 제공하면서 잠재 고객의 마음을 사로잡고 참여를 유도하는 사용자 인터페이스를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"HTML, CSS, JavaScript 숙달하기","slug":"web-4","date":"2023-12-23T15:14:04.000Z","updated":"2023-12-27T13:25:09.272Z","comments":true,"path":"2023/12/24/web-4/","link":"","permalink":"http://hgko1207.github.io/2023/12/24/web-4/","excerpt":"","text":"능숙한 웹 개발자가 되기 위해서는 HTML, CSS, JavaScript와 같은 핵심 웹 기술을 마스터하는 것이 필수적입니다. 다음은 이러한 각 기술을 숙달하는 방법에 대한 분석입니다. 1. HTML (Hypertext Markup Language) 기본 사항 알아보기: 제목(h1, h2, …), 단락§, 목록(ul, li), 링크(a) 및 이미지(image)와 같은 기본적인 HTML 요소와 태그를 이해하는 것부터 시작하세요. 시맨틱 HTML: 콘텐츠에 의미와 구조를 부여하기 위해 &lt;header&gt;, &lt;nav&gt;, &lt;main&gt;, &lt;article&gt;, &lt;section&gt;, &lt;footer&gt;와 같은 시맨틱 HTML 태그를 사용하는 데 집중하세요. 양식(Forms): 입력 필드, 텍스트 영역, 라디오 버튼, 체크박스, submit 버튼 등 HTML을 사용하여 양식을 만드는 방법을 알아보세요. HTML5 기능: 비디오 및 오디오 요소, 그래픽을 위한 canvas, 클라이언트 측 데이터 저장을 위한 로컬 스토리지 API와 같은 HTML5 기능에 익숙해집니다. 유효성 검사: 온라인 유효성 검사기 또는 통합 개발 환경(IDE) 도구를 사용하여 HTML 코드의 유효성을 검사하는 방법을 이해합니다. 2. CSS (Cascading Style Sheets) 박스 모델: 요소의 크기(size)와 여백(margin), 테두리(border), 패딩(padding), 콘텐츠가 상호 작용하는 방식을 이해하는 등 CSS 박스 모델에 대해 알아보세요. 선택기(Selectors): 스타일 지정을 위해 특정 HTML 요소를 지정하는 CSS 선택기를 마스터하세요. 레이아웃 기법: 반응형 디자인을 만들기 위한 Flexbox 및 CSS 그리드와 같은 다양한 레이아웃 기법을 살펴보세요. 반응형 디자인: 미디어 쿼리와 반응형 디자인 원칙을 이해하여 다양한 기기와 화면 크기에서 웹 페이지가 멋지게 보이도록 만드세요. 전환(Transitions) and 애니메이션(Animations): 더 나은 사용자 경험을 위해 CSS를 사용하여 부드러운 전환과 애니메이션을 만드는 방법을 알아보세요. 전처리기: CSS 워크플로우와 유지보수성을 향상시키기 위해 SASS 또는 LESS와 같은 CSS 전처리기를 학습하는 것도 고려해 보세요. 3. JavaScript 구문과 기초: 변수, 데이터 유형, 연산자, 제어 구조(if 문, 루프) 등 JavaScript의 기초부터 시작하세요. DOM 조작: DOM(Document Object Model )과 상호 작용하여 HTML 콘텐츠와 스타일을 동적으로 변경하는 방법을 이해합니다. 이벤트 처리: 클릭, 키 누름, 양식(form) 제출과 같은 사용자 상호작용과 이벤트를 처리하는 방법을 알아보세요. 함수 및 범위: JavaScript의 기본 개념인 함수(function), 범위(scope), 클로저(closure)에 대해 자세히 알아보세요. AJAX와 Fetch: 서버에 요청하기 위한 AJAX 또는 최신 Fetch API를 사용한 비동기 프로그래밍을 살펴보세요. 프레임워크와 라이브러리: 대화형 웹 애플리케이션을 구축하기 위해 React, Angular 또는 Vue.js와 같은 인기 있는 JavaScript 프레임워크와 라이브러리를 학습해 보세요. ES6 이상: ES6(ECMAScript 2015)를 비롯한 최신 JavaScript 기능 및 표준에 대해 알아보세요. 테스트: 단위 테스트를 작성하고 Jest와 같은 테스트 프레임워크를 사용하여 JavaScript 코드의 안정성을 보장하는 방법을 알아보세요. 디버깅: 브라우저 개발자 도구와 디버깅 기술을 사용하여 JavaScript 오류를 해결하고 수정하세요. 결론 숙달하려면 시간과 연습이 필요하다는 것을 기억하세요. 작은 프로젝트부터 시작하여 점차 더 복잡한 프로젝트로 나아가세요. 온라인 튜토리얼, 강좌, 코딩 연습은 HTML, CSS, JavaScript 기술을 배우고 향상하는 데 유용한 자료가 될 수 있습니다. 정기적으로 연습하고, 피드백을 구하고, 웹 개발의 최신 동향을 파악하여 능숙한 웹 개발자가 되세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"}]},{"title":"웹 기술 디코딩: HTML, XML, JSON, AJAX에 대한 종합 가이드","slug":"web-3","date":"2023-12-23T14:45:36.000Z","updated":"2023-12-23T15:13:27.227Z","comments":true,"path":"2023/12/23/web-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/23/web-3/","excerpt":"","text":"소개 빠르게 발전하는 웹 개발 분야에서는 인터넷을 주도하는 핵심 기술에 대한 기초적인 이해가 가장 중요합니다. 이 블로그 게시물은 최신 웹 애플리케이션의 동적 기능에 기여하는 필수 구성 요소인 HTML, XML, JSON 및 AJAX의 복잡한 내용을 풀어내는 것을 목표로 합니다. HTML: 웹 페이지의 구성 요소 HTML(Hypertext Markup Language)은 웹 페이지 구성의 초석입니다. 표준화된 프레임워크 역할을 하는 HTML은 태그를 사용하여 제목, 단락§, 이미지 및 링크와 같은 다양한 요소를 정의합니다. 웹 브라우저는 HTML을 해석하여 다양한 기기에서 일관된 디스플레이를 보장합니다. 기본적인 HTML 구조를 살펴보겠습니다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My Web Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;p&gt;This is a simple web page.&lt;/p&gt; &lt;img src=\"image.jpg\" alt=\"An example image\" /&gt; &lt;a href=\"https://example.com\"&gt;Visit Example.com&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; XML: 유연한 데이터 표현 XML(eXtensible Markup Language)은 데이터 전송 및 저장에 맞게 조정되었습니다. XML은 사용자 정의 태그를 사용하여 정보를 계층적으로 구성하여 사람과 기계의 가독성을 높입니다. XML은 서로 다른 시스템 간의 데이터 교환에서 빛을 발하며 원활한 커뮤니케이션을 촉진합니다. 다음은 XML의 구조입니다. 12345&lt;person&gt; &lt;name&gt;John Doe&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;city&gt;New York&lt;/city&gt;&lt;/person&gt; JSON: 경량 데이터 교환 민첩한 데이터 교환 형식인 JSON(JavaScript Object Notation)은 사람이 읽을 수 있고 기계 친화적입니다. 비동기식 브라우저/서버 통신에 널리 사용되며 API(Application Programming Interfaces)에서 널리 사용되는 JSON은 데이터 표현을 간소화합니다. 12345&#123; \"name\": \"hg Ko\", \"age\": 35, \"city\": \"Daejeon\"&#125; AJAX: 동적 웹 상호 작용 AJAX(Asynchronous JavaScript and XML)는 HTML, CSS, JavaScript, XML 및 JSON을 통합하는 기술입니다. 브라우저와 서버 간의 비동기식 데이터 교환을 용이하게 하여 전체 재로드 없이 동적 웹 페이지 업데이트를 가능하게 합니다. 다음은 AJAX가 실제로 작동하는 모습을 보여줍니다. 123456789// Example AJAX request using JavaScriptvar xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function () &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById('demo').innerHTML = this.responseText; &#125;&#125;;xhttp.open('GET', 'ajax-example.txt', true);xhttp.send(); 모든 것 종합하기 개발자는 구조를 위한 HTML, 데이터 표현을 위한 XML, 가벼운 데이터 교환을 위한 JSON을 결합하여 강력하고 동적인 웹 애플리케이션을 만들 수 있습니다. 비동기 통신을 통해 AJAX는 원활한 상호 작용을 보장하여 사용자 경험을 향상시킵니다. 결론 HTML, XML, JSON, AJAX는 웹 개발에서 각각 고유한 역할을 수행합니다. HTML은 콘텐츠를 구조화하고, XML은 데이터를 표현하며, JSON은 상호 교환을 용이하게 하며, AJAX는 역동성을 구현합니다. 웹 개발 여정을 시작할 때 이러한 기술을 숙지하는 것은 필수적입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"XML","slug":"XML","permalink":"http://hgko1207.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://hgko1207.github.io/tags/JSON/"},{"name":"AJAX","slug":"AJAX","permalink":"http://hgko1207.github.io/tags/AJAX/"},{"name":"디코딩","slug":"디코딩","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%BD%94%EB%94%A9/"}]},{"title":"인공 지능(AI)과 머신 러닝(ML) 활용하기","slug":"ai-3","date":"2023-12-22T14:03:24.000Z","updated":"2024-01-12T13:38:56.142Z","comments":true,"path":"2023/12/22/ai-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/22/ai-3/","excerpt":"","text":"소개 빠르게 발전하는 기술 환경에서 인공 지능(AI)과 머신 러닝(ML)은 게임 체인저로 등장하여 우리가 세상과 상호 작용하고 인식하는 방식에 혁명을 일으켰습니다. 효율성 향상부터 복잡한 문제 해결까지 AI와 ML의 융합은 산업을 재편하고 전례 없는 속도로 혁신을 주도하고 있습니다. 인공지능과 머신러닝의 이해 인공 지능은 우리가 &quot;스마트&quot;하다고 생각하는 방식으로 작업을 수행할 수 있는 기계의 광범위한 개념입니다. 반면 머신러닝은 명시적으로 프로그래밍하지 않고도 기계가 데이터를 통해 학습할 수 있도록 하는 AI의 하위 집합입니다. 이 두 가지를 함께 사용하면 시간이 지남에 따라 성능을 향상할 수 있는 지능형 시스템을 만들 수 있습니다. 정의 인공 지능(AI): AI는 일반적으로 인간의 지능이 필요한 작업을 수행할 수 있는 기계나 시스템을 만드는 것을 목표로 하는 컴퓨터 과학의 광범위한 분야입니다. 여기에는 문제 해결, 학습, 지각, 언어 이해 등 기계가 인간의 지능을 시뮬레이션할 수 있도록 설계된 다양한 기법, 접근 방식, 기술이 포함됩니다. 머신 러닝(ML): 머신 러닝은 컴퓨터가 명시적인 프로그래밍 없이 작업을 수행할 수 있도록 하는 알고리즘 및 통계 모델 개발에 중점을 두는 AI의 하위 집합입니다. 즉, 머신러닝을 통해 기계는 특정 작업에 대해 명시적으로 프로그래밍하지 않고도 데이터를 통해 학습하고 시간이 지남에 따라 성능을 향상시킬 수 있습니다. 산업 전반에 걸친 응용 분야 의료: AI와 ML은 개인 맞춤형 치료 계획부터 질병 조기 발견에 이르기까지 의료 분야에 큰 변화를 일으키고 있습니다. 머신러닝 알고리즘으로 구동되는 예측 분석은 의사가 정보에 입각한 의사 결정을 내리는 데 도움을 주어 생명과 자원을 절약합니다. 금융: 금융 부문에서는 AI와 ML이 리스크 관리, 사기 탐지, 고객 서비스를 최적화하고 있습니다. 머신러닝 모델을 기반으로 하는 알고리즘 트레이딩은 방대한 데이터 세트를 분석하여 순식간에 결정을 내리고 수익을 극대화합니다. 소매업: 맞춤형 추천, 공급망 최적화, 수요 예측이 소매업 환경을 변화시키고 있습니다. AI 기반 챗봇과 가상 비서는 고객 경험을 향상시켜 실시간 지원을 제공합니다. 자율주행차: 자동차 산업은 AI와 ML로 인해 패러다임 전환을 겪고 있습니다. 자율주행차는 이러한 기술을 활용하여 실시간 데이터를 해석하고 대응함으로써 보다 안전하고 효율적인 운송을 보장합니다. 교육: AI 기반의 적응형 학습 플랫폼은 학생 개개인의 요구를 충족하여 맞춤형 학습 경험을 제공합니다. 머신러닝 알고리즘은 학생 성과 데이터를 분석하여 개선이 필요한 영역을 파악하고 그에 따라 교육 콘텐츠를 맞춤화합니다. 새로운 트렌드와 기술 설명 가능한 AI(XAI): AI 시스템이 점점 복잡해짐에 따라 의사 결정 과정을 투명하고 이해하기 쉽게 만드는 것이 점점 더 강조되고 있습니다. XAI는 AI 알고리즘을 해석하고 신뢰할 수 있도록 보장하는 중요한 트렌드입니다 엣지 컴퓨팅: AI 및 ML을 엣지 컴퓨팅과 통합하면 데이터 소스에 더 가까운 곳에서 처리가 수행하여 대기 시간을 줄이고 실시간 의사 결정을 향상시킬 수 있습니다. 이는 IoT 장치 및 자율주행차와 같은 애플리케이션에 특히 중요합니다. 자연어 처리(NLP): NLP의 발전으로 기계는 인간과 유사한 언어를 이해하고 해석하며 생성할 수 있게 되었습니다. 이는 챗봇, 가상 비서 및 언어 번역 서비스의 혁신을 주도하고 있습니다. AI 윤리 및 편향성 완화: AI 시스템이 더욱 널리 보급됨에 따라 윤리적 문제를 해결하고 알고리즘의 편견을 완화하는 것이 무엇보다 중요해졌습니다. 책임감 있는 AI 개발 및 배포에 초점을 맞춘 이니셔티브가 주목을 받고 있습니다. 인공 지능(AI)과 머신 러닝(ML)은 밀접하게 관련된 개념이지만 컴퓨터 과학과 기술의 서로 다른 측면을 나타냅니다. 예시 인공 지능(AI): 가상 개인 비서(예: Siri 또는 Alexa), 게임 플레이 알고리즘(예: 체스나 바둑에 사용되는 알고리즘) 및 전문가 시스템이 AI 애플리케이션의 예입니다. 기계 학습(ML): 넷플릭스나 아마존에서 사용하는 것과 같은 추천 시스템, 이미지 및 음성 인식, 예측 분석은 머신 러닝 기술을 많이 사용하는 애플리케이션의 예입니다. 결론 인공 지능과 기계 학습은 지능형 시스템이 인간의 능력을 보조할 뿐만 아니라 증강하는 미래로 우리를 이끌고 있습니다. 혁신의 잠재력은 무한해 보이며, 이러한 기술이 달성할 수 있는 한계를 뛰어넘는 혁신이 끊임없이 이루어지고 있습니다. 이러한 기술적 한계를 탐색할 때 윤리적 고려 사항을 항상 경계하고 모든 사람이 AI 및 ML의 이점에 접근할 수 있도록 하는 것이 중요합니다. 혁신적인 기술의 잠재력을 최대한 활용하면서 다음 발전의 물결을 계속 지켜봐 주시기 바랍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"ML","slug":"ML","permalink":"http://hgko1207.github.io/tags/ML/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hgko1207.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://hgko1207.github.io/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"}]},{"title":"최고의 무료 AI 이미지 생성기 살펴보기","slug":"ai-2","date":"2023-12-21T13:10:45.000Z","updated":"2024-01-08T00:44:27.832Z","comments":true,"path":"2023/12/21/ai-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/21/ai-2/","excerpt":"","text":"소개 디지털 콘텐츠 제작의 역동적인 영역에서 인공지능(AI) 이미지 생성기는 새로운 차원의 창의성을 발휘할 수 있는 강력한 도구로 부상했습니다. 그래픽 디자이너, 소셜 미디어 애호가 또는 시각적 콘텐츠를 향상시키고자 하는 사람 모두에게 AI 이미지 생성기의 세계는 흥미로운 가능성으로 가득합니다. 이 글에서는 아이디어를 멋진 비주얼로 손쉽게 변환할 수 있도록 도와주는 최고의 무료 AI 이미지 생성기 몇 가지를 소개합니다. Deep Dream Generator Deep Dream Generator로 초현실적인 여행을 떠나보세요. Google의 신경망으로 구동되는 이 도구는 평범한 이미지를 꿈같은 사이키델릭한 작품으로 바꿔줍니다. 다양한 필터와 스타일로 실험하면서 상상력을 발휘하여 독특하고 이색적인 비주얼을 만들어 보세요. Psychedelic은 주로 환각적인 경험을 일으키는 약물이나 물질을 가리키며, 이로 인해 감각이 왜곡되고 정신적으로 변화되는 경험을 의미합니다. 이러한 경험은 종종 색채, 모양, 패턴 등의 시각적 변화와 함께 음악이나 감각적인 자극에 대한 강한 반응을 포함합니다. https://deepdreamgenerator.com/ DALL-E by OpenAI OpenAI에서 개발한 AI 모델인 DALL-E와 함께 무한한 상상의 영역으로 들어가 보세요. 이 획기적인 이미지 생성기는 텍스트 설명을 기반으로 이미지를 생성하여 AI가 구현할 수 있는 한계를 뛰어넘습니다. 몇 가지 간단한 프롬프트만으로 신화 속 생물부터 미래 풍경까지 무엇이든 생성할 수 있습니다. https://openai.com/dall-e-2 Artbreeder Artbreeder를 사용하면 이미지를 혼합하고 변형하여 완전히 새로운 구성을 만들어 디지털 아티스트의 역할을 수행할 수 있습니다. 이 직관적인 플랫폼을 사용하면 색 구성표부터 얼굴 특징까지 작품의 모든 측면을 세밀하게 조정하여 시각적으로 멋지고 고도로 맞춤화된 이미지를 만들 수 있습니다. https://www.artbreeder.com/ RunwayML 다양한 AI 모델을 찾는 사람들에게 RunwayML은 보물창고와도 같습니다. 이 플랫폼은 다양한 크리에이티브 작업에 특화된 사전 학습된 모델을 호스팅합니다. 예술, 음악, 동영상 조작 등 어떤 작업을 하든 RunwayML은 최첨단 AI를 실험할 수 있는 사용자 친화적인 인터페이스를 제공합니다. https://runwayml.com/?ref=zguyun.com This Person Does Not Exist &quot;이 사람은 존재하지 않습니다.&quot;로 사실적이지만 완전히 가상의 얼굴을 만들어 보세요. GAN(Generative Adversarial Network)으로 구동되는 이 AI 이미지 생성기는 실존하지 않는 인물의 초상화를 제작합니다. 캐릭터 디자인부터 프로젝트에 미스터리한 느낌을 더하는 것까지 다양한 용도로 이 이미지를 사용하세요. https://this-person-does-not-exist.com/en 결론 AI 이미지 생성기의 시대가 열리면서 디지털 크리에이티브의 혁명이 시작되었고, 그 어느 때보다 더 쉽게 접근하고 흥미롭게 만들 수 있게 되었습니다. 아티스트, 디자이너, 콘텐츠 제작자 모두에게 이 무료 AI 이미지 생성기는 상상력을 발휘할 수 있는 놀이터를 제공합니다. 이러한 도구로 실험하고, 현실과 환상을 혼합하고, 디지털 영역에서 창의력을 마음껏 발휘하세요. 가능성은 무궁무진하며, 유일한 한계는 여러분의 창의력뿐입니다. 지금 바로 AI 기반 이미지 생성의 매혹적인 세계에 빠져보세요!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Generative Ai Tools","slug":"Generative-Ai-Tools","permalink":"http://hgko1207.github.io/tags/Generative-Ai-Tools/"},{"name":"이미지 생성기","slug":"이미지-생성기","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%83%9D%EC%84%B1%EA%B8%B0/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"}]},{"title":"거절을 마스터하기: 좌절을 성공으로 바꾸는 가이드","slug":"etc-1","date":"2023-12-21T06:09:02.000Z","updated":"2024-01-09T06:08:16.451Z","comments":true,"path":"2023/12/21/etc-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/21/etc-1/","excerpt":"","text":"거절은 직장이나 개인적인 영역 모두에서 피할 수 없는 삶의 일부입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 어떤 상황에서든 거절을 당하면 감당하기 어려울 수 있습니다. 하지만 거절에 어떻게 대응하느냐에 따라 미래의 성공과 행복에 큰 영향을 미칠 수 있습니다. 다음은 전문성과 회복탄력성을 가지고 거절을 처리하는 방법에 대한 가이드입니다. 감정 수용하기 감정을 수용한다는 것은 거절에 대한 반응으로 발생하는 감정을 인정하고 받아들이는 것을 포함합니다. 감정을 억누르거나 피하지 말고 스스로 감정을 느끼고 처리할 수 있도록 하세요. 이 단계는 진정성과 자기 인식을 바탕으로 어려움을 헤쳐 나갈 수 있는 기반을 마련하기 때문에 감성 지능, 회복탄력성, 개인적 성장을 촉진하는 데 매우 중요합니다. 건설적인 피드백 구하기 건설적인 피드백을 구하는 것은 개인적, 직업적 발전을 위한 적극적인 접근 방식입니다. 여기에는 특히 거절을 당했을 때 귀중한 통찰력을 얻기 위해 다른 사람의 의견을 적극적으로 구하는 것이 포함됩니다. 피드백을 수용함으로써 개선이 필요한 부분을 파악하고, 기술을 연마하며, 궁극적으로 좌절을 성장의 기회로 바꿀 수 있습니다. 전문성 유지 전문성을 유지하는 것은 거절을 우아하게 처리하는 데 있어 핵심적인 요소입니다. 여기에는 부정적인 반응을 자제하고 침착하고 정중한 태도로 좌절에 대응하는 것이 포함됩니다. 전문적 기준을 유지함으로써 자신의 평판을 유지하고, 회복력을 키우며, 미래의 기회에 기여할 수 있는 긍정적인 인상을 남길 수 있습니다. 목표에 대한 성찰 목표를 되돌아보는 것은 거절을 극복하는 데 있어 중요한 단계입니다. 여기에는 좌절에 직면했을 때 목표를 재평가하고 재조정하기 위해 잠시 멈추는 것이 포함됩니다. 이러한 성찰적 과정은 자기 인식을 향상시킬 뿐만 아니라 전략적인 조정을 가능하게 하여 개인 및 직업적 성장의 진화하는 여정에서 목표가 탄력적으로 유지되고 적응할 수 있도록 해줍니다. 성장 마인드 기르기 성장 마인드를 키우는 것은 거절에 직면했을 때 회복력을 키우는 데 필수적입니다. 여기에는 도전이 학습과 발전의 기회라는 믿음을 키우는 것이 포함됩니다. 성장 마인드로 도전을 받아들임으로써 좌절을 학습 과정의 자연스러운 일부로 간주하여 더 강하게 회복하고 적응하며 개인 및 직업적 성공을 향한 여정에서 지속적으로 발전할 수 있습니다. 지원 시스템과 연결하기 지원 시스템과 연결하는 것은 거절을 극복하는 데 있어 중요한 전략입니다. 여기에는 격려와 조언, 가치 있는 관점을 제공할 수 있는 친구, 멘토, 동료에게 연락하는 것이 포함됩니다. 강력한 지원 네트워크를 구축함으로써 어려운 시기에 다른 사람들로부터 힘을 얻고 회복력을 키우며 개인 및 직업적 성장을 향한 여정을 더욱 원활하게 진행할 수 있습니다. 자기 관리에 집중하기 자기 관리에 집중하는 것은 거절에 대처하는 데 있어 가장 중요한 측면입니다. 여기에는 휴식과 원기 회복을 촉진하는 활동에 참여하여 정신적, 정서적 웰빙을 우선시하는 것이 포함됩니다. 좌절 속에서도 자신을 돌봄으로써 회복력을 유지하고, 관점을 되찾고, 새로운 균형 감각과 긍정성을 가지고 도전에 접근할 수 있습니다. 새로운 목표 설정 새로운 목표를 설정하는 것은 거절에 대한 능동적인 대응으로, 적응력과 앞으로의 추진력을 의미합니다. 여기에는 열망을 재평가하고, 목표를 구체화하며, 미래의 성공을 위한 과정을 계획하는 것이 포함됩니다. 새로운 목표를 향해 집중력과 에너지를 재분배함으로써 개인은 좌절을 성장과 회복력, 지속적인 개인 및 전문성 개발의 기회로 전환할 수 있습니다. 작은 승리 축하하기 작은 승리를 축하하는 것은 거절에 직면한 후 회복의 여정에서 중요한 요소입니다. 여기에는 그 과정에서 작은 성과라도 인정하고 감사하는 것이 포함됩니다. 이러한 점진적인 승리를 인정함으로써 사기를 높이고 동기를 유지하며 긍정적인 사고방식을 함양하여 지속적인 개인 및 직업적 성장을 위한 기반을 마련할 수 있습니다. 끈기 유지 끈기를 유지하는 것이 거절에 맞서 승리하는 열쇠입니다. 여기에는 좌절에도 불구하고 흔들리지 않는 결단력과 회복력을 유지하는 것이 포함됩니다. 확고한 사고방식을 수용함으로써 도전을 헤쳐나가고, 경험을 통해 배우고, 목표를 끈질기게 추구할 수 있습니다. 끈기는 개인을 궁극적인 성공의 길로 나아가게 하는 원동력이며, 좌절을 지속적인 성취를 위한 디딤돌로 바꿔줍니다. 결론 거절은 업무적 영역과 개인적 영역을 모두 아우르는 우리의 여정에서 피할 수 없는 측면입니다. 입사 지원서, 사업 제안서, 개인적인 관계 등 그 어떤 것이든, 문제는 거절을 피할 수 없는 상황에서 어떻게 대응하느냐에 달려 있습니다. 이 글은 거절에 직면했을 때 전문성과 회복력을 키우고 좌절을 미래의 성공으로 가는 디딤돌로 삼을 수 있는 실행 가능한 단계를 제시합니다. 거절의 복잡한 지형을 헤쳐 나가면서 감정을 수용하고, 피드백을 구하고, 전문성을 유지하고, 성장 마인드를 키우는 방법을 배워보세요. 거절은 끝이 아니라 지속적인 성장과 성취를 향한 변화의 단계임을 기억하세요.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://hgko1207.github.io/categories/ETC/"}],"tags":[{"name":"거절","slug":"거절","permalink":"http://hgko1207.github.io/tags/%EA%B1%B0%EC%A0%88/"},{"name":"좌절","slug":"좌절","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%EC%A0%88/"},{"name":"성공","slug":"성공","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EA%B3%B5/"},{"name":"동기부여","slug":"동기부여","permalink":"http://hgko1207.github.io/tags/%EB%8F%99%EA%B8%B0%EB%B6%80%EC%97%AC/"},{"name":"긍정적인 생각","slug":"긍정적인-생각","permalink":"http://hgko1207.github.io/tags/%EA%B8%8D%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%9D%EA%B0%81/"},{"name":"Motivation","slug":"Motivation","permalink":"http://hgko1207.github.io/tags/Motivation/"}]},{"title":"[React vs Vue.js] Vue.js가 React보다 좋을까?","slug":"web-2","date":"2023-12-20T14:05:21.000Z","updated":"2024-01-12T13:38:15.432Z","comments":true,"path":"2023/12/20/web-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/20/web-2/","excerpt":"","text":"소개 끊임없이 진화하는 웹 개발 환경에서 올바른 프런트엔드 프레임워크를 선택하는 것은 때로는 혼란스러울 수 있습니다. 특히 선택할 수 있는 js 프레임워크가 많은 경우에는 더욱 그렇습니다. 가장 유명한 js 프런트엔드 프레임워크는 다음과 같습니다. 1. React Facebook에서 개발하고 유지 관리합니다. Virtual DOM, 컴포넌트 기반 아키텍처 및 성능으로 유명합니다. 광범위하게 채택되어 방대한 커뮤니티와 생태계를 보유하고 있습니다. 많은 기업이 대규모 애플리케이션을 위해 선택했습니다. 2. Angular Google에서 개발하고 유지관리합니다. 양방향 데이터 바인딩, 종속성 주입 및 대규모 애플리케이션 기능으로 잘 알려진 포괄적인 프런트엔드 프레임워크입니다. 동적 웹 애플리케이션 구축을 위한 완벽한 솔루션을 제공합니다. 3. Vue.js 커뮤니티에서 유지 관리하는 오픈 소스 프레임워크입니다. 단순성, 통합 용이성, 완만한 학습 곡선으로 잘 알려져 있습니다. React 및 Angular와 유사한 기능을 제공하지만 보다 접근하기 쉬운 방식으로 제공됩니다. 고성능(React 보다 빠름) 개발 속도가 빠릅니다. 4. Svelte 오픈 소스 프런트엔드 프레임워크입니다. DOM을 직접 조작하는 매우 효율적인 명령형 코드로 컴포넌트를 컴파일하여 차별화됩니다. 간단한 구문을 제공하고 더 나은 성능을 목표로 합니다. 5. Ember.js 오픈 소스 프런트엔드 프레임워크입니다. 구성 원칙에 대한 규칙을 따르기 때문에 크고 복잡한 애플리케이션에 적합한 강력한 선택입니다. 강력한 템플릿 엔진과 데이터 레이어를 제공합니다. 6. Backbone.js 오픈 소스 JavaScript 프레임워크입니다. Model, View, Collection, Router에 중점을 두고 웹 애플리케이션을 구축하는 데 필요한 최소한의 구조를 제공합니다. 다른 라이브러리와 함께 사용하여 더 복잡한 애플리케이션을 만드는 데 자주 사용됩니다. 7. Meteor 웹 및 모바일 애플리케이션 구축을 위한 오픈 소스 플랫폼입니다. React, Angular, Vue.js와 같은 프런트엔드 프레임워크와 통합되어 풀스택 솔루션을 제공합니다. 실시간 데이터 업데이트와 개발 용이성으로 잘 알려져 있습니다. 자바스크립트 프레임워크 영역에서 가장 눈에 띄는 두 경쟁자는 React와 Vue.js입니다. 각각 고유한 장점과 단점이 있으며 이를 뒷받침하는 대규모 커뮤니티가 있습니다. 이 글에서는 개발자의 관점으로 React와 Vue.js 차이점, 인기, 성능을 분석하고 비교할 것입니다. React와 Vue.js의 차이점 React와 Vue.js는 모두 널리 사용되는 자바스크립트 프레임워크이지만 구문, 학습 곡선, 생태계, 상태 관리 등 여러 측면에서 차이가 있습니다. 현명한 선택을 위해서는 이러한 차이점을 이해하는 것이 필수적입니다. React vs Vue.js: 인기 콘테스트 인기도는 기술 채택에 중요한 역할을 하는 경우가 많습니다. 현재 트렌드와 사용 통계를 살펴보고 이 경쟁 구도에서 React와 Vue.js가 어떻게 경쟁하고 있는지에 대한 인사이트를 제공하겠습니다. Vue.js GitHub Stars: 204k GitHub Commits: 3.2k GitHub 기여자: 404 스택 오버플로에 대한 질문: 91.9k Live Websites: 2071k React GitHub Stars: 208k GitHub Commits: 14.8k GitHub 기여자: 1.5k 스택 오버플로에 대한 질문: 376.4k Live Websites: 2609k 여기서 React가 Vue.js보다 더 인기가 있다는 것을 분명히 알 수 있지만, 그렇다고 해서 Vue.js를 사용하는 사람이 전혀 없다는 것을 의미하지는 않습니다. Vue.js는 React보다는 조금 적지만 자체적으로 많은 팔로워와 프로젝트에서 채택되고 있습니다. 사용 방법 비교 Vue.js: 디렉티브(Directive)를 사용한 HTML 템플릿 Vue.js를 사용하면 개발자가 템플릿에서 HTML 구문을 사용할 수 있으므로 HTML에 익숙한 사람들이 쉽게 시작할 수 있습니다. 또한 Vue.js는 HTML 요소의 렌더링 및 동작을 조건부로 제어하기 위해 v-if, v-else, v-show 등과 같은 강력한 디렉티브를 제공합니다. 이 접근 방식은 프로세스를 단순화하며 특히 초보자에게 친숙합니다. 다음은 Vue.js 템플릿에서 v-if 사용법을 보여주는 간단한 예입니다. 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt; &lt;p v-if=\"showMessage\"&gt;This message will be shown if showMessage is true.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; showMessage: true &#125;; &#125;&#125;;&lt;/script&gt; React: JavaScript 통합이 포함된 HTML과 유사한 구조를 위한 JSX React는 개발자가 JavaScript 파일 내에서 HTML과 유사한 코드를 작성할 수 있게 해주는 구문 확장인 JSX를 활용합니다. 처음에는 기존 HTML과 다르게 보일 수 있지만 JSX는 HTML 구조와 매우 유사하며 JavaScript 표현식 및 로직과의 완벽한 통합이라는 이점을 제공합니다. 다음은 JSX와 함께 React를 사용하는 유사한 예입니다. 1234567891011121314import React, &#123; useState &#125; from 'react';const MyComponent = () =&gt; &#123; const [showMessage, setShowMessage] = useState(true); return ( &lt;div&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &#123;showMessage &amp;&amp; &lt;p&gt;This message will be shown if showMessage is true.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;;export default MyComponent; 이 예제에서 단락(&lt;p&gt;) 요소는 showMessage 상태가 true인 경우에만 렌더링됩니다. JSX는 JavaScript 표현식(예: {showMessage &amp;&amp; ...})을 통합하여 조건부로 렌더링을 제어합니다. React와 Vue.js 성능 비교 성능은 프런트엔드 프레임워크를 선택할 때 중요한 요소입니다. 렌더링 속도, 번들 크기, 최적화 기술 등 두 프레임워크의 성능 측면을 자세히 살펴보겠습니다. 렌더링 속도 Vue.js Vue.js는 무언가 변경될 때 화면을 빠르게 업데이트하는 데 능숙합니다. 마치 필요한 것만 업데이트하는 가장 효율적인 방법을 알아내는 스마트 시스템을 갖춘 것과 같습니다. React React는 또한 화면을 효율적으로 업데이트합니다. 가장 좋은 방법으로 업데이트하는 방법을 계획하는 스마트 비서와 같아서 모든 일이 원활하게 진행됩니다. 번들 크기 Vue.js Vue.js는 특히 &quot;범위가 지정된 슬롯(Scoped Slots)&quot;이라는 기능을 사용하여 파일 크기를 작게 유지하는 데 도움이 됩니다. 공간을 덜 차지하는 방식으로 물건을 정리하는 것과 같습니다. React React는 필요한 것을 골라서 사용할 수 있는 툴킷과 같습니다. 하지만 어떻게 사용하느냐에 따라 추가 도구를 추가할 수 있기 때문에 툴킷이 조금 더 커질 수 있습니다. 최적화 기술 Vue.js Vue.js에는 캐싱 및 효율적인 데이터 처리와 같이 작업 속도를 높일 수 있는 기본 제공 방법이 있습니다. 단축키를 사용하여 작업을 빠르게 완료하는 것과 같습니다. React React에는 암기 및 지연 로딩과 같이 더 빠르게 작동하도록 하는 트릭도 있습니다. 게임에서 필살기를 사용하여 진행 속도를 높이는 것과 같습니다. 간단히 말해서 Vue.js와 React는 모두 작업을 빠르고 효율적으로 수행하는 데 도움이 되는 스마트 비서와 같습니다. Vue.js는 번들 크기가 더 작고 조금 더 빠르며, React는 더 유연한 툴킷이며 대규모 프로젝트에 본질적으로 사용되는 확장성이 있습니다. 결론 프리랜서이거나 소규모 스타트업을 운영하고 있다면 개발 속도가 빠르고, 성능이 뛰어나며, 상용구 코드가 훨씬 적은 Vue.js가 최선의 선택입니다. 대규모 프로젝트를 수행하는 대기업이라면 상용구 코드가 더 많지만 코드베이스가 커짐에 따라 프로젝트를 더 쉽게 처리할 수 있는 JSX를 사용하는 것이 좋습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"}]},{"title":"열정 없이 돈만을 위해 프로그래밍에 입문하면 안되는 5가지 이유","slug":"info-7","date":"2023-12-19T12:58:52.000Z","updated":"2023-12-22T13:56:08.054Z","comments":true,"path":"2023/12/19/info-7/","link":"","permalink":"http://hgko1207.github.io/2023/12/19/info-7/","excerpt":"","text":"바보라도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있습니다. 훌륭한 프로그래머는 인간이 이해할 수 있는 코드를 작성합니다. — 마틴 파울러 프로그래밍은 열정과 헌신이 필요한 분야입니다. 높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍을 할 충분한 이유가 될 수는 없습니다. 열정 없이 돈만 보고 프로그래밍에 뛰어들면 안 되는 5가지 이유는 다음과 같습니다. 프로그래밍은 끊임없는 학습과 개선이 필요한 도전적인 분야입니다. 열정이 없으면 동기를 유지하고 최신 기술과 트렌드를 따라가는 것이 어려울 수 있습니다. 프로그래밍은 문제 해결 능력과 고정 관념에서 벗어나는 능력을 요구하는 창의적인 분야입니다. 열정이 없으면 복잡한 문제에 대한 혁신적인 솔루션을 찾기가 어려울 수 있습니다. 프로그래밍은 팀워크와 의사소통 능력이 필요한 협업 분야입니다. 열정이 없으면 다른 사람들과 함께 일하고 팀에 기여하기가 어려울 수 있습니다. 프로그래밍은 세심한 주의와 높은 수준의 정확성이 요구되는 분야입니다. 열정이 없으면 집중력을 유지하고 실수를 피하는 것이 어려울 수 있습니다. 프로그래밍은 스트레스가 많고 까다로울 수 있는 분야입니다. 열정이 없으면 압박감을 견디고 일과 삶의 균형을 유지하기 어려울 수 있습니다. 열정이 없으면 기능적일 뿐만 아니라 이해하고 유지 관리하기 쉬운 코드를 작성하기 어려울 수 있으며, 반면에 열정이 부족한 프로그래머는 경력이 단절될 수 있습니다. 최신 기술과 트렌드를 따라잡는 데 어려움을 겪을 수 있으며, 이로 인해 경력 성장과 기회가 제한될 수 있습니다. 또한 다른 사람들과 협업하는 데 어려움을 겪을 수 있으며, 이로 인해 팀에 기여하는 능력이 저하될 수 있습니다. 또한 열정이 부족한 프로그래머는 업무의 스트레스와 요구를 감당하기 어려워 번아웃과 일과 삶의 균형이 깨질 수 있습니다. 스티브 잡스는 이렇게 말했습니다. 일이 인생의 많은 부분을 차지하게 될 것이며, 진정으로 만족할 수 있는 유일한 방법은 자신이 훌륭한 일이라고 믿는 일을 하는 것입니다. 그리고 훌륭한 일을 할 수 있는 유일한 방법은 자신이 하는 일을 사랑하는 것입니다. 이 인용문은 프로그래밍에서 열정의 중요성과 그것이 어떻게 만족스럽고 성공적인 커리어로 이어질 수 있는지를 강조합니다. 결론적으로, 열정은 프로그래밍에서 중요한 요소이며 프로그래머의 경력에 큰 차이를 만들 수 있습니다. 열정적인 프로그래머는 항상 자신의 기술을 배우고 향상시키기 위해 노력하며, 이는 끊임없이 진화하는 분야에서 필수적인 요소입니다. 또한 복잡한 문제에 대한 혁신적인 솔루션을 개발하는 데 필요한 창의적이고 틀에 박힌 사고방식을 벗어날 수 있는 능력을 갖추고 있습니다. 따라서 사람들의 삶을 변화시킬 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다. 높은 연봉이 매력적일 수는 있지만, 열정 없이 프로그래밍에 도전할 충분한 이유가 될 수는 없습니다. 프로그래밍에는 창의력, 문제 해결 능력, 팀워크, 세부 사항에 대한 주의력, 스트레스 처리 능력이 필요합니다. 유명한 프로그래머 도널드 어빈 크누스(Donald Ervin Knuth)는 이렇게 말했습니다. 프로그래밍은 컴퓨터가 무엇을 하길 원하는지 다른 사람에게 알려주는 기술이다. 따라서 사람들의 삶에 변화를 가져올 수 있는 아름답고 기능적인 소프트웨어를 만들 수 있으려면 프로그래밍에 대한 열정을 갖는 것이 중요합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"열정","slug":"열정","permalink":"http://hgko1207.github.io/tags/%EC%97%B4%EC%A0%95/"}]},{"title":"MVC, MVVM, MVP 이해 및 비교","slug":"web-1","date":"2023-12-18T13:53:01.000Z","updated":"2024-01-12T13:37:07.525Z","comments":true,"path":"2023/12/18/web-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/18/web-1/","excerpt":"","text":"소개 소프트웨어 개발 세계에는 개발자가 모듈성, 유지 관리성 및 확장성을 촉진하는 방식으로 코드를 설계하고 구성하는 데 도움이 되는 다양한 아키텍처 패턴이 있습니다. 이러한 인기 있는 세 가지 패턴은 MVC(Model-View-Controller), MVVM(Model-View-ViewModel) 및 MVP(Model-View-Presenter)입니다. 이 글에서는 이러한 아키텍처 패턴의 세부 사항을 자세히 살펴보고 주요 원칙, 장점 및 사용 사례를 알아보겠습니다. Model-View-Controller(MVC) MVC는 소프트웨어 개발에서 가장 오래되고 가장 널리 사용되는 아키텍처 패턴 중 하나입니다. 다음 구성 요소로 구성됩니다. Model: 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 데이터 조작, 저장 및 검색을 관리합니다. View: 사용자에게 데이터를 표시하는 역할을 담당합니다. Model의 정보를 표시하고 사용자 입력을 처리합니다. Controller: Model과 View 사이의 중개자 역할을 합니다. View로부터 사용자 입력을 받아 이를 처리하고, Model을 업데이트하고 그에 따라 View를 새로 고칩니다. MVC의 장점 관심사를 명확하게 분리하여 코드를 더욱 유지 관리하고 테스트할 수 있게 만듭니다. 서로 다른 View가 동일한 Model 과 Controller를 사용할 수 있으므로 코드 재사용성이 향상됩니다. 병렬 개발을 지원하여 UI 디자이너와 개발자가 독립적으로 작업할 수 있습니다. 사용 사례 MVC는 Spring Framework, Ruby on Rails, Django 및 ASP.NET과 같은 웹 개발 프레임워크에서 일반적으로 사용됩니다. Model-View-ViewModel(MVVM) MVVM은 특히 복잡하고 데이터가 풍부한 애플리케이션의 맥락에서 MVC의 일부 제한 사항에 대한 대응으로 등장한 디자인 패턴입니다. MVVM은 다음 구성 요소로 구성됩니다. Model: MVC 모델과 유사하게 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. View: 사용자 인터페이스를 나타내지만 MVC보다 더 수동적입니다. ViewModel에 의해 노출된 속성 및 명령에 바인딩됩니다. ViewModel: View의 상태와 동작을 추상화하는 역할을 합니다. Model과 View 간의 통신을 중재하고 View가 바인딩하는 데이터와 명령을 노출합니다. MVVM의 장점 View 와 Model 간의 결합을 줄여 MVC보다 더 나은 관심사 분리를 촉진합니다. 데이터 바인딩을 촉진하여 기본 데이터가 변경될 때 UI 업데이트를 단순화합니다. ViewModel을 UI와 독립적으로 테스트할 수 있으므로 테스트 가능성이 향상됩니다. 사용 사례 MVVM은 클라이언트 측 애플리케이션, 특히 Angular, React, Vue.js 및 Xamarin과 같은 프레임워크에서 널리 사용됩니다. Model-View-Presenter(MVP) MVP는 관심사 분리에 초점을 맞추지만 MVC 및 MVVM과는 다른 방식으로 수행되는 또 다른 아키텍처 패턴입니다. 다음 구성 요소로 구성됩니다. Model: MVC 및 MVVM과 유사하며 애플리케이션의 데이터와 비즈니스 로직을 캡슐화합니다. View: 사용자 인터페이스를 나타내지만 MVVM의 View에 비해 더 활동적입니다. View는 사용자 입력을 Presenter에게 직접 전달합니다. Presenter: MVC의 Controller와 유사하게 Model과 View 사이의 중개자 역할을 합니다. 그러나 MVP에서는 View가 일반적으로 더 수동적입니다. MVP의 장점 Presenter는 UI 없이 쉽게 단위 테스트할 수 있으므로 높은 수준의 테스트 가능성을 제공합니다. 관심사를 명확하게 분리하고 UI와 애플리케이션 로직을 강력하게 구분하도록 권장합니다. 개발자가 Presenter 및 Model에서 작업하는 동안 UI 디자이너가 View에서 작업할 수 있으므로 병렬 개발이 용이합니다. 사용 사례 MVP는 특히 WinForms, WPF 및 GWT와 같은 기술을 사용하여 데스크톱 애플리케이션 개발에 일반적으로 사용됩니다. MVC, MVVM, MVP 비교 데이터 바인딩: MVVM은 데이터 바인딩에 탁월하므로 UI와 기본 데이터의 동기화를 더 쉽게 유지할 수 있습니다. MVC와 MVP는 수동 동기화가 필요합니다. 테스트 가능성: MVP와 MVVM은 애플리케이션의 로직을 별도로 테스트할 수 있기 때문에 MVC에 비해 더 나은 테스트 가능성을 제공합니다. 복잡성: MVC는 더 간단하고 소규모에서 중간 정도 복잡한 애플리케이션에 더 적합할 수 있는 반면, MVVM과 MVP는 더 크고 복잡한 프로젝트에서 빛을 발합니다. 학습 곡선: MVVM 및 MVP는 추가 구성 요소 및 개념으로 인해 학습 곡선이 더 가파르게 느껴질 수 있습니다. 플랫폼: 이러한 패턴 간의 선택은 플랫폼에 따라 달라질 수도 있습니다. MVC는 웹 개발과 관련되는 경우가 많고, MVVM은 클라이언트 측 애플리케이션에 널리 사용되고 MVP는 데스크톱 애플리케이션에 일반적으로 사용됩니다. 테스트 가능성(Testability)은 과학과 과학적 방법의 주요 측면입니다. 테스트 가능성에는 반증 가능성 또는 실현 불가능성 두 가지 구성 요소가 있습니다. 이는 가설에 대한 반례가 논리적으로 가능함을 의미합니다. 위키백과 결론 결론적으로 MVC, MVVM, MVP 중에서 선택하는 것은 특정 프로젝트 요구 사항, 팀 전문 지식, 개발 대상 플랫폼에 따라 달라집니다. 각 패턴은 강력하고 유지보수가 가능한 소프트웨어를 구축하는 데 필요한 관심사 분리(Separation of concerns), 모듈성(Modularity) 및 테스트 가능성(Testability)을 달성하기 위한 다양한 접근 방식을 제공합니다. 각 패턴의 원리와 장점을 이해하면 다음 소프트웨어 애플리케이션을 설계할 때 정보에 입각한 결정을 내리는 데 도움이 될 수 있습니다. 컴퓨터 과학에서 관심사 분리(Separation of concerns)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙으로, 각 부문은 개개의 관심사를 해결한다. 관심사란 컴퓨터 프로그램 코드에 영향을 미치는 정보의 집합이다. 위키백과","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"MVC","slug":"MVC","permalink":"http://hgko1207.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://hgko1207.github.io/tags/MVP/"}]},{"title":"[ChatGPT] 코딩에서 활용하기 위한 5가지 팁","slug":"chatgpt-3","date":"2023-12-16T05:49:03.000Z","updated":"2024-01-12T13:36:27.909Z","comments":true,"path":"2023/12/16/chatgpt-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/16/chatgpt-3/","excerpt":"","text":"ChatGPT는 매우 빠르게 개발자들의 필수 도구가 되었습니다. 우리 모두는 이 도구가 루프 생성이나 if 조건 등을 사용하는 작은 알고리즘 등 코딩의 사소한 작업을 잘 처리한다는 것을 알고 있습니다. 또한 최근 또는 새로운 주요 변경 사항이 있는 라이브러리에 대한 코드를 생성하거나 적절하게 설명되지 않은 복잡한 대규모 작업의 경우 약점이 있다는 것을 알 수 있습니다. 팁 코딩에서 ChatGPT를 더 잘 사용하기 위한 5가지 팁에 대해 알아보겠습니다. 질문을 작은 작업으로 나누고 한 번에 한 단계씩 점진적으로 추가하여 코드를 생성하도록 요청하세요. 이 접근 방식은 복잡한 코드 블록과 관련하여 더 나은 코딩 결과를 제공하고 오류를 줄이는 것으로 나타났습니다. 외부 라이브러리 등이 포함된 복잡한 작업에 특히 유용합니다. 가능한 한 구체적인 용어와 전문 용어를 사용하여 명확하고 상세하게 프롬프트를 작성하세요. 지식이 풍부한 웹 개발자와 대화하는 것처럼 ChatGPT와 대화하고 아이디어를 전달하는 데 사용할 모든 용어를 사용하세요. 프롬프트를 단순화하기 위해 기술 용어를 사용하는 것을 주저하지 마십시오. 외부 라이브러리의 경우 ChatGPT에 의해 생성되는 오래된 구문에 주의하세요. ChatGPT에 의해 생성된 외부 라이브러리 사용 코드에 이상한 오류가 표시되면 항상 이를 의심해 보세요. 이 경우 해당 라이브러리의 설명서를 확인하는 것이 좋습니다. 대규모 작업을 구현하기 위한 계획을 찾을 때는 ChatGPT에 코딩 문제와 프로젝트에 대한 개요를 제공하고 여러 가지 방법과 제안을 요청하는 것이 좋습니다. 이렇게 하면 머릿속에 떠오르지 않았던 아이디어를 떠올릴 수 있습니다. 생성된 코드에 대한 설명을 ChatGPT에 묻는 것을 게을리하지 마십시오. Chatgpt는 생성된 코드를 매우 잘 설명할 수 있으며 코드가 무엇을 하고 있는지 명확하게 알려줌으로써 생성된 코드의 버그를 더 빨리 해결하는 데 도움이 됩니다. 결론 ChatGPT가 개발자를 그렇게 빨리 대체할 수 있다고 믿지 않습니다. 그러나 프로그래밍의 낮은 수준 작업을 자동화하여 개발자가 단조롭고 지루한 부분을 맡길 수 있습니다. ChatGPT를 잘 활용하면 개발자의 업무 효율을 최소 2배 향상시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"}]},{"title":"생성형 AI(Generative AI)의 미래","slug":"ai-1","date":"2023-12-15T01:41:28.000Z","updated":"2024-01-12T13:34:42.178Z","comments":true,"path":"2023/12/15/ai-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/15/ai-1/","excerpt":"","text":"소개 인공지능의 세계는 변혁의 시대를 맞이하고 있으며, 이 혁명의 중심에는 생성형 AI(Generative AI)가 있습니다. 이 고급 모델은 콘텐츠를 제작하고 복잡한 문제를 해결할 수 있는 힘을 가지고 있으며, 우리가 기술과 상호작용하는 방식과 그 가능성을 재정의하고 있습니다. 이 글에서는 생성형 AI의 현실감과 창의성 향상부터 윤리적, 환경적 영향에 이르기까지 생성형 AI의 미래에 대해 살펴볼 것입니다. 앞으로 펼쳐질 흥미진진한 여정에 대해 자세히 알아봅시다. 생성형 인공지능(generative artificial intelligence) 또는 생성형 AI(generative AI)는 프롬프트에 대응하여 텍스트, 이미지, 기타 미디어를 생성할 수 있는 일종의 인공지능(AI) 시스템이다. 생성형 AI는 입력 트레이닝 데이터의 패턴과 구조를 학습한 다음 유사 특징이 있는 새로운 데이터를 만들어낸다. 위키백과 현실감과 창의성 향상 생성형 AI는 많은 발전을 이루었지만 아직 시작에 불과합니다. 미래의 모델은 사실주의와 창의성의 경계를 넓혀 사실상 인간의 창조물과 구별할 수 없는 콘텐츠를 제작할 것입니다. 실제과 같은 텍스트, 이미지, 음악, 심지어 동영상을 생성하는 이러한 모델은 사람과 AI가 생성한 콘텐츠 사이의 경계를 계속해서 허물어뜨릴 것입니다. 다중 모드 기능 텍스트, 이미지, 오디오 등 다양한 데이터 유형을 동시에 원활하게 작업할 수 있는 AI 모델을 상상해 보세요. 이러한 다중 모드 기능은 이전에는 불가능하다고 여겨졌던 방식으로 내러티브에 생동감을 불어넣는 새로운 형태의 몰입형 스토리텔링을 가능하게 할 것입니다. 이야기 또는 '내러티브’란 어떤 사물이나 사실, 현상에 대하여 일정한 줄거리를 가지고 하는 말이나 글을 말한다. 문학에서 이야기는 배경, 인물, 구성, 이야기를 이루는 분위기인 톤으로 이루어진다. 위키백과 대규모 개인화 생성형 AI의 가장 유망한 측면 중 하나는 고도로 개인화된 경험을 대규모로 제공할 수 있는 잠재력입니다. 개별 학습 스타일에 맞춘 교육부터 개인 취향에 맞는 제품 추천에 이르기까지, 생성형 AI는 각 사용자의 고유한 요구 사항을 충족할 수 있습니다. 산업별 솔루션 맞춤형 생성 AI 모델은 의료, 금융, 교육, 제조 등 특정 산업을 위해 개발될 것입니다. 이러한 모델은 산업별 과제를 해결하여 전문가가 작업하고 문제를 해결하는 방식을 혁신을 가져올 것입니다. 인간과 기계의 협업 강화 생성형 AI는 인간을 대체하는 것이 아니라 오히려 인간의 능력을 보완할 것입니다. 인간과 AI 간의 효과적인 협업은 다양한 직업에서 표준이 되어 업무의 효율성을 높이고 새로운 가능성의 문을 열 것입니다. 콘텐츠 조정(Content Moderation) 및 검증 디지털 정보 시대에는 허위 정보와의 전쟁과 콘텐츠 무결성 유지가 매우 중요합니다. 생성형 AI는 콘텐츠 조정 및 사실 확인을 자동화하여 정확하고 신뢰할 수 있는 정보만 대중에게 전달되도록 하는 데 중요한 역할을 할 것입니다. 사용자에게 댓글을 게시하도록 요청하는 인터넷 웹사이트에서 콘텐츠 조정은 유용하거나 유익한 게시물과는 대조적으로 관련성이 없거나 외설적이거나 불법적이거나 유해하거나 공격적인 게시물을 감지하는 프로세스이며, 종종 반대 관점을 검열하거나 억제합니다. 위키백과 자연어 인터페이스 생성형 AI로 구동되는 고급 챗봇과 가상 비서는 보다 자연스럽고 인간과 유사한 대화 상호 작용을 제공할 것입니다. 사용자 경험과 고객 지원이 개선되면서 우리가 기술과 상호 작용하는 방식을 재정의할 것입니다. 예술과 디자인의 혁신 생성형 AI가 예술, 디자인, 건축의 경계를 허물면서 창조 산업에 혁명이 일어날 것입니다. 그리고 새로운 형태의 표현을 가능하게 하여 혁신과 창의성을 촉진할 것입니다. 음악 및 엔터테인먼트 생성형 AI로 생성된 음악, 영화 및 기타 형태의 엔터테인먼트가 더욱 보편화될 것입니다. 이는 완전히 새로운 장르와 경험의 출현으로 이어져 엔터테인먼트 세계에서 가능한 일의 지평을 넓힐 것입니다. 지속적인 학습과 자기 계발 미래의 생성형 AI 모델은 사람의 개입 없이도 새로운 데이터와 진화하는 트렌드에 적응하면서 지속적으로 학습할 수 있게 될 것입니다. 이를 통해 빠르게 변화하는 세계에서 관련성과 최신성을 유지할 수 있습니다. 책임감 있는 AI 개발 생성형 AI가 널리 보급됨에 따라 윤리적이고 책임감 있는 AI 개발에 대한 강조가 커질 것입니다. 회사와 연구자들은 AI가 사회 전체에 혜택을 줄 수 있도록 편견, 공정성, 투명성과 같은 문제를 해결하기 위한 보호 장치를 구현할 것입니다. 환경 고려 사항 AI의 에너지 소비는 우려의 대상이었지만 미래의 생성형 AI 모델은 환경의 지속 가능성을 염두에 두고 설계될 가능성이 높습니다. 탄소 배출량과 에너지 소비를 최소화하는 것이 최우선 과제가 될 것입니다. 법률 및 규제 프레임워크 생성형 AI가 우리 삶에 더욱 필수적인 요소가 되면서 지적 재산권, 개인정보 보호, 안전 문제를 해결하기 위한 법률 및 규제 프레임워크가 발전할 것입니다. 이러한 프레임워크는 AI가 책임감 있고 윤리적으로 사용되도록 보장할 것입니다. 과학적 발견 생성형 AI는 과학 연구에서 중추적인 역할을 하며 신약 개발, 재료 과학, 기후 모델링과 같은 분야의 발견을 가속화할 것입니다. 이는 연구자들이 방대한 양의 데이터를 처리하고 이전에 숨겨져 있던 패턴을 찾는 데 도움이 될 것입니다. 맞춤화 및 개인 비서 AI 개인 비서는 개별 사용자에게 더욱 맞춤화되어 지원뿐만 아니라 동반자 역할과 정서적 지원까지 제공할 것입니다. 이러한 개인적인 접촉은 인간과 AI 관계를 강화할 것입니다. 교육 생성형 AI는 개인화된 학습 경험을 제공하고, 교육 콘텐츠를 제작하고, 적응형 학습을 제공함으로써 교육에 혁명을 일으킬 것입니다. 이를 통해 학습의 몰입도와 효과를 높여 학생들이 필요한 교육을 받을 수 있게 될 것입니다. AI가 만들어낸 혁신 생성형 AI는 기술과 비즈니스의 경계를 허무는 새로운 아이디어, 발명품, 프로토타입을 생성하는 혁신의 원동력이 될 것입니다. 이는 오늘날 우리가 상상조차 할 수 없는 발전을 가져올 것입니다. 결론 생성형 AI의 미래는 엄청난 가능성을 갖고 있습니다. 이는 우리의 삶을 개선하고, 경제 성장을 촉진하며, 시급한 글로벌 과제를 해결할 수 있는 잠재력을 가지고 있습니다. 그러나 이는 생성형 AI가 계속 발전함에 따라 신중하게 고려하고 해결해야 할 윤리적, 사회적 문제도 제기되고 있습니다. 앞으로의 여정은 무한한 가능성으로 가득 차 있으며, 빠르게 변화하는 세상에서 생성형 AI가 선한 역할을 할 수 있도록 하는 것은 우리에게 달려 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Generative AI","slug":"Generative-AI","permalink":"http://hgko1207.github.io/tags/Generative-AI/"},{"name":"생성형 AI","slug":"생성형-AI","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%84%B1%ED%98%95-AI/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"}]},{"title":"[ChatGPT] 대화형 AI 활용","slug":"chatgpt-2","date":"2023-12-14T15:00:18.000Z","updated":"2023-12-23T15:12:58.255Z","comments":true,"path":"2023/12/15/chatgpt-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/15/chatgpt-2/","excerpt":"","text":"기술이 디지털 세계와 상호 작용하는 방식을 지속적으로 변화시키는 시대에 챗봇과 가상 비서는 인간과 컴퓨터의 상호 작용을 위한 강력한 도구로 등장했습니다. 이 분야의 최신 혁신 중에는 OpenAI가 개발한 최첨단 AI 모델인 ChatGPT가 있습니다. 이 글에서는 ChatGPT의 매혹적인 세계와 그 기능, 대화형 AI의 미래에 미치는 영향을 살펴봅니다. 챗봇과 가상 비서의 등장 챗봇(Chatbot)과 가상 비서(Virtual Assistant)는 처음부터 많은 발전을 이루었습니다. 처음에는 간단한 작업과 반복적인 쿼리를 위해 설계되었으나 인간과 유사한 텍스트를 이해하고 생성할 수 있는 매우 정교한 대화 에이전트로 발전했습니다. 오늘날 챗봇은 고객 서비스, 의료, 전자상거래, 엔터테인먼트 등 다양한 산업 분야에서 사용되고 있습니다. ChatGPT 소개 ChatGPT는 대화형 AI 세계에 탁월한 추가 기능을 제공합니다. GPT(Generative Pre-trained Transformer) 제품군의 일부로 개발된 이 제품은 이전 제품의 놀라운 자연어 이해 및 생성 기능을 물려받았습니다. ChatGPT는 의미 있는 대화에 사용자를 참여시키도록 설계되었으므로 다음을 포함한 광범위한 애플리케이션에 이상적인 후보입니다. 고객 지원: ChatGPT는 고객 문의 처리, 문제 해결, 지원을 연중무휴 24시간 제공하여 고객 만족도를 높일 수 있습니다. 콘텐츠 생성: 기사 초안 작성부터 마케팅 자료 작성까지 콘텐츠 생성을 지원하여 시간과 노력을 절약할 수 있습니다. 언어 번역: ChatGPT는 언어 간 텍스트를 번역하고 문화 간 의사소통을 촉진함으로써 언어 장벽을 허물 수 있습니다. 가상 교사: 맞춤형 학습 경험과 교육 지원을 제공하는 가상 교사 역할을 할 수 있는 잠재력이 있습니다. 대화형 캐릭터: 게임 개발자는 ChatGPT를 활용하여 역동적인 대화와 개성을 지닌 실물 같은 캐릭터를 만들 수 있습니다. ChatGPT 작동 방식 ChatGPT의 핵심은 딥 러닝 아키텍처입니다. 이 모델은 인터넷의 광범위한 텍스트 데이터세트를 통해 훈련되어 언어 패턴과 맥락을 학습할 수 있습니다. 사용자의 입력이 제공되면 ChatGPT는 입력과 해당 지식을 기반으로 가장 가능성이 높은 다음 단어를 예측하여 응답을 생성합니다. 맥락을 이해하고, 대화를 유지하며, 일관성 있고 맥락에 맞는 응답을 제공하는 모델의 능력이 ChatGPT를 차별화하는 요소입니다. 다양한 입력을 처리하고 다양한 대화 상황에 적응할 수 있어 다재다능하고 적응력이 뛰어납니다. ChatGPT를 통한 대화형 AI의 미래 ChatGPT는 대화형 AI 개발에 있어 중요한 도약을 의미합니다. 계속해서 개선되고 확장됨에 따라 우리는 예상할 수 있습니다. 향상된 고객 경험: ChatGPT가 제공하는 향상된 챗봇은 보다 효과적이고 개인화된 고객 상호 작용을 제공하여 고객 만족도와 충성도를 높입니다. 생산성 향상: 기업과 개인은 AI 기반 콘텐츠 생성, 자동화된 응답, 더 많은 작업을 수행할 수 있는 가상 비서의 이점을 누릴 수 있습니다. 원활한 다문화 커뮤니케이션: ChatGPT가 번역 및 언어 지원에 더욱 능숙해짐에 따라 언어 장벽이 더욱 낮아질 것입니다. 고급 교육 도구: 가상 교사와 맞춤형 학습 경험은 우리가 지식과 기술을 습득하는 방식에 혁명을 일으킬 것입니다. 몰입형 가상 세계: 게임 개발자는 ChatGPT 기반 캐릭터를 통해 더욱 몰입감 있고 대화형인 게임 경험을 만들 수 있습니다. 결론 ChatGPT는 대화형 AI 세계의 획기적인 발전입니다. 놀라운 기능, 다용성 및 적응성은 인간과 컴퓨터의 상호 작용이 더욱 자연스럽고 매력적인 미래를 위한 큰 가능성을 제시합니다. 고객 서비스를 개선하려는 기업, 지원이 필요한 콘텐츠 제작자, 사용자 경험을 향상시키려는 게이머 등 ChatGPT는 기술과 커뮤니케이션의 미래를 형성하는 데 중추적인 역할을 할 준비가 되어 있습니다. ChatGPT와 대화형 AI의 세계에서 앞으로 펼쳐질 흥미로운 발전에 계속 관심을 가져주세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"대화형 AI","slug":"대화형-AI","permalink":"http://hgko1207.github.io/tags/%EB%8C%80%ED%99%94%ED%98%95-AI/"}]},{"title":"다중 장치(Multi-Device)를 위한 반응형 디자인","slug":"web-design-3","date":"2023-12-13T02:39:42.000Z","updated":"2024-01-12T13:32:37.381Z","comments":true,"path":"2023/12/13/web-design-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/13/web-design-3/","excerpt":"","text":"오늘날의 디지털 환경에서 웹 페이지는 대형 데스크톱 모니터부터 소형 스마트폰에 이르기까지 다양한 장치에서 액세스됩니다. 웹 사이트가 이러한 모든 장치에서 멋지게 보이고 원활하게 작동하는지 확인하는 것은 현대 웹 디자인의 기본 측면입니다. 반응형 디자인이 중요한 역할을 하는 곳이 바로 여기입니다. 반응형 디자인이란 무엇입니까? 반응형 디자인은 웹 페이지를 다양한 화면 크기와 장치에 맞게 적절하게 적용하는 것을 목표로 하는 웹 디자인 접근 방식입니다. 이는 웹 사이트가 데스크톱 컴퓨터, 태블릿, 휴대폰 중 어느 기기에서 보이든 상관없이 원활한 사용자에 보이는 것입니다. 반응형 디자인을 사용하면 모든 기기에서 콘텐츠에 액세스할 수 있을 뿐만 아니라 사용자 친화적이기도 합니다. 미디어 쿼리(Media Query)의 역할 미디어 쿼리는 반응형 디자인의 초석입니다. 이는 화면 너비나 높이와 같은 특정 조건에서 웹 페이지가 표시되는 방법을 지정하는 CSS 규칙입니다. 미디어 쿼리를 사용하면 사용 중인 장치의 특성에 따라 다양한 스타일을 적용하거나 레이아웃을 조정할 수 있습니다. 미디어 쿼리 이해 미디어 쿼리의 작동 방식과 미디어 쿼리를 사용하여 반응형 웹 페이지를 만드는 방법을 분석해 보겠습니다. 1.미디어 쿼리 정의 미디어 쿼리는 CSS 파일의 @media 규칙을 사용하여 정의됩니다. 기본 구조는 다음과 같습니다. 123@media screen and (max-width: 768px) &#123; /* 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */&#125; 이 예에서 미디어 쿼리는 최대 너비가 768픽셀인 화면을 대상으로 합니다. 2. 조건 설정 미디어 쿼리 내에서 and, or, not과 같은 논리 연산자를 사용하여 조건을 지정합니다. 화면 너비, 높이, 방향 등 다양한 측면을 타겟팅할 수 있습니다. 123@media screen and (max-width: 768px) and (orientation: portrait) &#123; /* 세로 모드에서 최대 너비가 768픽셀인 화면에 대한 CSS 규칙 */&#125; 3. CSS 규칙 적용 미디어 쿼리 블록 내에서 조건이 충족될 때 적용되는 특정 CSS 규칙을 적용할 수 있습니다. 예를 들어 글꼴 크기를 변경하고, margin과 padding을 조정하고, 요소(element)를 숨기거나 표시하고, 레이아웃을 재구성할 수도 있습니다. 123456@media screen and (max-width: 768px) &#123; /* 작은 화면에 맞게 글꼴 크기 조정 */ body &#123; font-size: 16px; &#125;&#125; 반응형 디자인 원칙 미디어 쿼리 외에도 반응형 웹 페이지를 디자인할 때 명심해야 할 몇 가지 기본 원칙이 있습니다. 모바일 우선 접근 방식: 가장 작은 화면 크기를 염두에 두고 디자인을 시작한 다음 점차적으로 더 큰 화면에 맞게 향상시키세요. 이를 통해 사이트는 모바일 사용자에게 최적화됩니다. 유연한 그리드: 콘텐츠가 다양한 화면 크기에 맞게 조정되도록 하려면 백분율 기반 또는 유연한 그리드를 사용하세요. CSS Grid와 Flexbox는 이러한 목적을 위한 강력한 도구입니다. 이미지 최적화: 화면 크기에 맞게 조정되는 반응형 이미지를 사용하고 지연 로딩을 고려하여 모바일 장치의 페이지 로드 시간을 개선합니다. 콘텐츠 우선순위 지정: 작은 화면에 맞춰 콘텐츠의 우선순위를 지정하고 재구성하세요. 중요한 정보는 쉽게 접근할 수 있어야 하며, 필수적이지 않은 요소는 숨기거나 압축할 수 있어야 합니다. 테스트: 다양한 장치와 브라우저에서 웹사이트를 정기적으로 테스트하여 의도한 대로 모양과 기능이 작동하는지 확인합니다. 에뮬레이터와 브라우저 개발자 도구는 테스트에 매우 유용할 수 있습니다. 결론 반응형 디자인은 더 이상 있으면 좋은 기능이 아니라 오늘날의 다중 장치(Multi-Device) 세계에서 필수적인 기능입니다. 미디어 쿼리를 이해하고 반응형 디자인 원칙을 따르면 다양한 장치와 화면 크기에 맞게 최적의 사용자 경험을 제공하는 웹 페이지를 만들 수 있습니다. 사용자는 스마트폰, 태블릿, 노트북, 데스크톱 등 무엇을 사용하든 웹사이트를 접근성 있고 사용자 친화적으로 만들기 위해 기울이는 노력에 감사할 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"다중 장치","slug":"다중-장치","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%EC%A4%91-%EC%9E%A5%EC%B9%98/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"웹 개발자를 위한 CSS Flexbox 기술","slug":"web-design-2","date":"2023-12-12T05:07:36.000Z","updated":"2024-01-12T13:30:17.341Z","comments":true,"path":"2023/12/12/web-design-2/","link":"","permalink":"http://hgko1207.github.io/2023/12/12/web-design-2/","excerpt":"","text":"CSS Flexbox에 대해 자세히 알아보고 개념을 설명하는 몇 가지 코드 예제를 살펴보겠습니다. CSS Flexbox란 무엇입니까? CSS Flexbox(Flexible Box Layout)는 크기를 알 수 없거나 동적인 경우에도 컨테이너 내의 공간을 분배하고 항목을 정렬하여 복잡한 레이아웃의 디자인을 단순화하는 1차원 레이아웃 모델입니다. Flexbox는 내비게이션 메뉴(Navigation Menu), 카드 레이아웃(Card Layout), 콘텐츠 배포(Content Distribution) 등 반응성이 뛰어나고 유연한 디자인을 만드는 데 특히 유용합니다. CSS Flexbox의 기본 개념 Flex Container: Flex 항목을 포함하는 요소를 “Flex Container”라고 합니다. Flex 컨테이너(Container)를 만들려면 display: flex; HTML 요소에 속성을 적용합니다. 123.flex-container &#123; display: flex;&#125; Flex Items: Flex Container의 직계 하위 항목을 &quot;Flex Items&quot;이라고 합니다. 이러한 항목은 div, text, image 또는 기타 컨테이너와 같은 모든 HTML 요소가 될 수 있습니다. 12345&lt;div class=\"flex-container\"&gt; &lt;div class=\"flex-item\"&gt;Item 1&lt;/div&gt; &lt;div class=\"flex-item\"&gt;Item 2&lt;/div&gt; &lt;div class=\"flex-item\"&gt;Item 3&lt;/div&gt;&lt;/div&gt; Flex Container 속성 Flex 컨테이너의 동작을 제어하기 위한 몇 가지 필수 속성은 다음과 같습니다. flex-direction: 주축(행 또는 열)의 방향을 지정합니다. justify-content: 주축을 따라 항목이 배포되는 방식을 결정합니다. align-items: 항목이 교차축을 따라 정렬되는 방식을 정의합니다. flex-wrap: 플렉스 항목이 여러 줄로 줄 바꿈 되어야 하는지 여부를 지정합니다. align-content: 컨테이너 내에서 여러 줄의 정렬을 제어합니다( flex-wrap 활성화된 경우). 예제 코드 이러한 개념 중 일부를 설명하기 위해 간단한 예제를 만들어 보겠습니다. 1234567891011121314.flex-container &#123; display: flex; flex-direction: row; /* 행에 배치된 항목(기본값) */ justify-content: space-between; /* 항목이 고르게 분포됨 */ align-items: center; /* 항목을 수직으로 중앙에 배치 */&#125;.flex-item &#123; flex: 1; /* 각 항목은 동일한 공간을 차지합니다. */ padding: 10px; text-align: center; background-color: #007bff; color: white;&#125; 이 코드에서는 flex-container는 세 개의 Flex 항목이 있는 Flex 컨테이너를 정의합니다. flex-direction: row;는 항목을 일렬로 정렬합니다. justify-content: space-between; 주축을 따라 항목을 균등하게 분배합니다. align-items: center; 교차축을 따라 항목을 수직으로 중앙에 배치합니다. CSS Flexbox의 이점 복잡한 레이아웃을 단순화합니다. 알 수 없거나 동적 콘텐츠 크기를 적절하게 처리합니다. float 및 위치 지정의 필요성이 줄어듭니다. 정렬 및 분포 제어가 향상됩니다. 반응형 웹 디자인을 지원합니다. 결론 CSS Flexbox는 유연하고 반응이 빠른 웹 레이아웃을 간단하게 만들 수 있는 강력한 레이아웃 모델입니다. 웹 개발자는 개념을 이해하고 CSS를 통해 적용함으로써 컨테이너 내 요소의 배열과 정렬을 정밀하게 제어할 수 있습니다. Flexbox는 웹 레이아웃 코드의 효율성과 가독성을 향상시켜 최신 웹 개발에서 매우 유용한 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://hgko1207.github.io/tags/Flexbox/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"자바스크립트 성능 최적화 기술 익히기","slug":"js-dev-11","date":"2023-12-12T02:20:25.000Z","updated":"2023-12-25T14:26:12.521Z","comments":true,"path":"2023/12/12/js-dev-11/","link":"","permalink":"http://hgko1207.github.io/2023/12/12/js-dev-11/","excerpt":"","text":"빠르고 반응이 빠른 웹 애플리케이션을 만들려면 자바스크립트 실행 시간을 줄이는 것이 중요합니다. 자바스크립트는 강력하고 다재다능한 프로그래밍 언어이지만 제대로 최적화되지 않으면 웹 페이지 속도가 느려질 수 있습니다. 자바스크립트 코드를 실행하는 데 시간이 너무 오래 걸리면 사용자 경험이 느려지고 페이지 렌더링이 지연되며 이탈률이 증가할 수 있습니다. 따라서 원활한 사용자 경험을 보장하기 위해서는 자바스크립트 실행 시간을 최적화하는 것이 중요합니다. 전략 다음은 이를 달성하기 위한 몇 가지 전략입니다 자바스크립트 최소화 및 압축: 불필요한 코드를 제거하고 축소 및 압축 도구를 사용하여 웹페이지가 로드되는 자바스크립트 양을 줄입니다. 축소 및 압축된 자바스크립트 파일은 크기가 더 작으므로 다운로드가 더 빠르고 실행 시간이 단축됩니다. 비동기 로딩: 가능하면 자바스크립트 파일을 비동기식으로 로드하세요. 이렇게 하면 웹페이지의 다른 요소들이 자바스크립트와 동시에 로드되어 장기 실행 스크립트에 의해 차단되는 것을 방지할 수 있습니다. 로딩 연기: 중요한 렌더링 경로가 완료될 때까지 필수적이지 않은 자바스크립트 로딩을 연기합니다. 이렇게 하면 웹페이지가 처음에 더 빠르게 로드되고 브라우저가 덜 바쁠 때 자바스크립트를 실행할 수 있습니다. 지연 로딩: 페이지 로드 시 즉시 필요하지 않은 자바스크립트 모듈에 대한 지연 로딩(Lazy Loading)을 구현합니다. 이는 대용량 자바스크립트 파일이나 특정 사용자 상호 작용에만 필요한 파일에 특히 유용합니다. 코드 분할: 자바스크립트 코드를 더 작고 관리하기 쉬운 모듈로 분할하세요. 현재 사용자 경험에 필요한 모듈만 로드합니다. 이렇게 하면 초기 실행 시간이 줄어들고 시스템 리소스 사용이 최소화됩니다. 루프 및 반복 최적화: 자바스크립트 코드 내의 루프(Loop) 및 반복(Iteration)에 주의를 기울이십시오. 비효율적인 루프는 실행 시간을 크게 늘릴 수 있습니다. 특정 사용 사례에 최적화된 알고리즘과 데이터 구조를 사용하세요. DOM 조작을 줄이세요: DOM(Document Object Model)을 과도하게 조작하면 심각한 병목 현상을 일으킬 수 있습니다. DOM에 대한 불필요한 업데이트를 최소화하고 일괄 처리 및 requestAnimationFrame과 같은 기술을 사용하여 애니메이션과 Transition을 원활하게 하세요. 캐싱: 자주 변경되지 않는 데이터와 계산을 저장하는 캐싱 메커니즘을 구현하세요. 캐싱은 반복적인 자바스크립트 실행의 필요성을 줄여 성능을 향상시킬 수 있습니다. Web Worker 사용: 계산 집약적인 작업을 Web Worker에게 오프로드합니다. Web Worker를 사용하면 메인 스레드를 차단하지 않고 백그라운드에서 스크립트를 실행할 수 있으므로 자바스크립트가 사용자 상호 작용에 영향을 미치는 것을 방지할 수 있습니다. 프로파일링 및 최적화: 브라우저 개발자 도구를 활용하여 자바스크립트 코드를 프로파일링하고 성능 병목현상을 파악하세요. Chrome 개발자도구와 같은 도구는 코드 실행 시간과 메모리 사용량을 분석하는 기능을 제공하므로 개선이 필요한 부분을 정확히 찾아내는 데 도움이 됩니다. CDN 호스팅: CDN(Content Delivery Network)을 사용하여 널리 사용되는 라이브러리 및 프레임워크를 호스팅하세요. CDN은 이러한 리소스를 보다 효율적으로 제공하여 다운로드 및 실행에 필요한 시간을 단축할 수 있습니다. ES6 이상 사용: 최신 ECMAScript 기능과 최적화를 활용하세요. 최신 자바스크립트 버전에는 성능이 향상되고 코드를 간소화하는 데 도움이 되는 새로운 기능이 포함되는 경우가 많습니다. 테스트 및 벤치마킹: 정기적으로 웹 애플리케이션의 성능을 테스트하고 벤치마킹 도구를 사용하여 실행 시간을 측정하세요. 이를 통해 회귀를 감지하고 변경 사항이 자바스크립트 실행에 미치는 영향을 모니터링할 수 있습니다. 이미지(Image) 및 자산(Asset) 최적화: 웹 애플리케이션에 사용되는 이미지 및 자산의 크기를 줄이면 전체 로딩 프로세스의 속도를 높여 자바스크립트 실행 시간을 간접적으로 개선할 수 있습니다. 콘텐츠 전달 전략: 장치 및 네트워크 상태에 따라 사용자에게 다양한 자바스크립트 번들을 제공하는 등 스마트한 콘텐츠 전달 전략을 구현하세요. 이를 통해 사용자는 자신의 상황에 가장 최적화된 코드를 받을 수 있습니다. 결론 자바스크립트 실행 시간 최적화는 지속적으로 해야하며 높은 수준의 성능을 유지하려면 전략 실행, 도구(Tool) 사용 및 지속적인 관심이 필요합니다. 이러한 기술을 사용하고 웹 애플리케이션의 성능을 지속적으로 모니터링하면 자바스크립트 코드가 효율적으로 실행되어 더 나은 사용자 경험을 제공할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"}]},{"title":"반응형 웹 디자인을 사용해야 하는 10가지 이유","slug":"info-6","date":"2023-12-11T05:28:33.000Z","updated":"2023-12-21T14:07:38.017Z","comments":true,"path":"2023/12/11/info-6/","link":"","permalink":"http://hgko1207.github.io/2023/12/11/info-6/","excerpt":"","text":"전 세계가 점점 더 모바일화됨에 따라 반응형 웹 디자인의 중요성은 아무리 강조해도 지나치지 않습니다. 반응형 디자인은 웹 사이트를 보는 데 사용되는 기기의 화면 크기에 맞게 웹 사이트가 조정되도록 하는 웹 디자인 접근 방식입니다. 즉, 데스크톱 컴퓨터, 태블릿, 스마트폰 등 어떤 기기에서 사이트를 탐색하든 최적의 보기 환경을 제공합니다. 이 글에서는 반응형 웹 디자인 사용을 고려해야 하는 10가지 이유를 살펴봅니다. 1. 사용자 경험 개선 반응형 웹 디자인은 사용자가 웹사이트에 액세스하는 기기에 관계없이 일관된 경험을 할 수 있도록 합니다. 따라서 사용자가 사이트를 더 쉽게 탐색하고 원하는 정보를 쉽게 찾을 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 사이트에 더 오래 머무르고 콘텐츠에 더 많이 참여할 가능성이 높아집니다. 2. 모바일 트래픽 증가 점점 더 많은 사람들이 스마트폰을 사용하여 인터넷에 접속하기 때문에 모바일 기기에 최적화된 웹사이트를 만드는 것이 중요합니다. 반응형 디자인은 모든 화면 크기에서 웹사이트가 멋지게 보이도록 하여 모바일 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성을 높입니다. 3. 더 나은 SEO Google 및 기타 검색 엔진은 반응형 디자인이 적용된 웹사이트가 더 나은 사용자 경험을 제공하기 때문에 우선순위를 둡니다. 즉, 웹사이트가 반응형이면 검색 엔진 결과 페이지(Search Engine Results Pages, SERPs)에서 더 높은 순위를 차지할 가능성이 높아져 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도할 수 있습니다. 4. 이탈률 감소 이탈률은 한 페이지만 보고 웹사이트를 떠나는 방문자의 비율을 말합니다. 반응형 웹 디자인은 더 나은 사용자 경험을 제공하여 사용자가 사이트에 머무르며 콘텐츠를 탐색할 가능성이 높아지므로 이탈률을 낮추는 데 도움이 될 수 있습니다. 5. 더 빠른 웹사이트 로딩 시간 반응형 웹사이트는 동일한 콘텐츠의 여러 버전을 로드할 필요가 없기 때문에 일반적으로 비반응형 웹사이트보다 로딩 속도가 빠릅니다. 즉, 사용자가 느린 로딩 시간에 불만을 품고 사이트를 떠날 가능성이 줄어듭니다. 6. 손쉬운 유지 관리 반응형 웹사이트를 사용하면 사이트의 한 버전만 유지 관리하면 됩니다. 따라서 여러 버전의 사이트를 변경할 필요가 없으므로 콘텐츠를 업데이트하고 사이트를 변경하기가 더 쉬워집니다. 7. 비용 효율적 반응형 웹 디자인은 모든 기기에서 작동하는 하나의 버전의 웹 사이트만 만들면 되기 때문에 비용 효율적입니다. 즉, 여러 버전의 사이트를 만들거나 별도의 사이트 버전을 유지 관리하는 데 비용을 들일 필요가 없습니다. 8. 미래 보장 반응형 웹 디자인을 사용하면 웹 사이트는 시장에 출시되는 모든 새로운 장치에 대비할 수 있습니다. 즉, 새로운 기기가 대중화되어 사이트가 구식이 될까 봐 걱정할 필요가 없습니다. 9. 더 나은 분석 반응형 웹사이트를 사용하면 모든 기기에서 사용자 행동을 추적할 수 있습니다. 즉, 사용자가 사이트와 상호 작용하는 방식을 더 잘 이해하고 데이터에 기반한 의사 결정을 통해 사용자 경험을 개선할 수 있습니다. 10. 경쟁 우위 마지막으로 반응형 웹사이트는 경쟁 우위를 확보할 수 있습니다. 사용자가 사이트에서 긍정적인 경험을 하면 다른 사람에게 사이트를 추천할 가능성이 높아집니다. 이는 웹사이트의 가시성을 높이고 사이트로 더 많은 트래픽을 유도하는 데 도움이 될 수 있습니다. 결론 결론적으로 반응형 웹 디자인은 훌륭한 사용자 경험을 만들고 웹사이트의 가시성을 높이고자 하는 모든 사람에게 필수적입니다. 웹사이트가 모든 기기에서 멋지게 보이도록 하면 더 많은 방문자를 유치하고 참여도를 높이며 더 많은 전환을 유도할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"반응형 웹","slug":"반응형-웹","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/"}]},{"title":"ChatGPT란 무엇인가요? ChatGPT로 어떻게 돈을 벌까?","slug":"chatgpt-1","date":"2023-12-06T13:52:22.000Z","updated":"2024-01-12T13:29:17.913Z","comments":true,"path":"2023/12/06/chatgpt-1/","link":"","permalink":"http://hgko1207.github.io/2023/12/06/chatgpt-1/","excerpt":"","text":"ChatGPT는 다양한 질문에 답하고 사람들과 대화할 수 있도록 설계된 AI 기반 언어 모델입니다. AI 언어 모델로서 ChatGPT는 돈을 벌거나 금융 거래에 참여할 수 있는 능력이 없습니다. 하지만 ChatGPT를 사용하여 잠재적으로 수익을 창출할 수 있는 방법이 있습니다. 다음은 몇 가지 아이디어입니다. 사업 아이디어 조사 창업을 고려하고 있다면 ChatGPT를 사용하여 잠재적인 사업 아이디어를 조사할 수 있습니다. ChatGPT는 시장 동향, 소비자 행동 및 업계 모범 사례에 대한 통찰력을 제공할 수 있습니다. 잠재적인 사업 아이디어에 대해 ChatGPT에 질문을 하면 실행 가능하고 수익성 있는 옵션인지 더 잘 파악할 수 있습니다. 비즈니스를 위한 챗봇 구축하기 챗봇은 기업이 고객과 소통하고 고객 서비스 업무를 자동화하는 방법으로 점점 더 인기를 얻고 있습니다. 비즈니스에 챗봇을 구축하려는 경우 ChatGPT를 사용하여 매력적이고 유용한 대화형 인터페이스를 만들 수 있습니다. ChatGPT는 챗봇이 고객 문의에 응답하고 유용한 정보를 제공하도록 훈련시켜 고객 만족도를 높이고 판매를 촉진하는 데 도움이 될 수 있습니다. 글쓰기 실력 향상하기 작가나 콘텐츠 제작자라면 ChatGPT를 사용하여 글쓰기 실력을 향상할 수 있습니다. ChatGPT는 콘텐츠에 대한 아이디어를 생성하고, 글쓰기에 대한 피드백을 제공하며, 글쓰기 스타일을 개선할 수 있는 방법을 제안할 수 있습니다. ChatGPT를 사용하여 글쓰기 기술을 개선하면 잠재적으로 더 많은 고객을 유치하고 더 많은 수익을 올릴 수 있습니다. 새로운 기술 배우기 ChatGPT는 새로운 기술을 배우기 위한 도구로도 사용할 수 있습니다. 특정 주제나 관심 분야에 대해 ChatGPT에 질문할 수 있으며 관련 정보와 리소스를 제공받을 수 있습니다. ChatGPT를 통해 새로운 기술을 배우면 잠재적으로 취업 가능성을 높이거나 현재 직업에서 더 많은 돈을 벌 수 있습니다. 시간 절약하기 마지막으로, 많은 조사나 수작업이 필요한 작업의 시간을 절약하기 위해 ChatGPT를 사용할 수 있습니다. 예를 들어, 특정 주제에 대한 정보를 찾아야 하는 경우 인터넷 검색에 시간을 소비하는 대신 ChatGPT에 물어볼 수 있습니다. ChatGPT를 사용하여 워크플로우를 간소화하면 잠재적으로 수입을 창출하는 작업에 집중할 수 있는 시간을 더 많이 확보할 수 있습니다. 결론 결론적으로, ChatGPT 자체는 돈을 벌 수 있는 기능이 없지만, 잠재적으로 더 많은 돈을 벌 수 있는 방법이 있습니다. 연구, 글쓰기, 학습 및 자동화를 위한 기능을 활용하여 비즈니스 또는 경력 전망을 개선하고 재정적 목표를 달성할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"아이디어","slug":"아이디어","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4/"}]},{"title":"차세대 웹 앱을 위한 인기있는 상위 10개 Angular 라이브러리","slug":"angular-32","date":"2023-12-04T02:44:19.000Z","updated":"2024-01-12T13:28:47.078Z","comments":true,"path":"2023/12/04/angular-32/","link":"","permalink":"http://hgko1207.github.io/2023/12/04/angular-32/","excerpt":"","text":"차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것은 어려운 작업일 수 있습니다. 사용 가능한 옵션이 너무 많기 때문에 프로젝트에 가장 적합한 라이브러리를 결정하기가 어려울 수 있습니다. 하지만 프로젝트의 규모, 앱의 복잡성, 필요한 기능 등의 요소를 고려하면 선택의 폭을 좁히고 정보에 입각한 결정을 내릴 수 있습니다. 또한 라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려하는 것도 중요합니다. 이 글에서는 사용 가능한 라이브러리에 대한 개요와 프로젝트에 적합한 라이브러리를 선택할 때 고려해야 할 요소에 대해 설명합니다. Angular 무엇입니까? Angular는 Google에서 개발하고 유지 관리하는 오픈 소스 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션에서 자주 사용되는 구성 요소와 함께 클라이언트 측 MVC(Model-View-Controller) 및 MVVM(Model-View-View Model) 아키텍처를 위한 프레임워크를 제공함으로써 단일 페이지 애플리케이션을 구성하는 데도 사용되며 개발 및 테스트를 보다 쉽게 수행할 수 있도록 설계되었습니다. Angular 애플리케이션을 빌드할 때는 프로젝트의 성공을 보장하기 위해 올바른 라이브러리와 프레임워크를 선택하는 것이 중요합니다. 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하려면 필요한 기능, 프로젝트의 규모와 복잡성, 학습 및 구현에 투자해야 하는 시간 등을 신중하게 고려해야 합니다. 신뢰할 수 있고, 지원이 잘 제공되며, 정기적으로 업데이트되는 라이브러리를 선택하는 것이 중요합니다. 또한 서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택하는 것도 중요합니다. 시간을 들여 사용 가능한 라이브러리를 조사하고 비교하면 프로젝트에 적합한 라이브러리를 선택할 수 있습니다. 올바른 Angular 라이브러리를 선택하는 방법은 무엇입니까? 라이브러리를 선택할 때 고려해야 할 몇 가지 중요한 요소가 있습니다. 웹 앱에 필요한 기능을 고려합니다. 프로젝트의 규모와 복잡성을 평가합니다. 라이브러리를 학습하고 구현하는 데 투자해야 하는 시간을 고려합니다. 신뢰할 수 있고, 지원이 잘 되며, 정기적으로 업데이트되는 라이브러리를 선택합니다. 서로 호환되고 앱과 원활하게 통합되는 라이브러리를 선택합니다. 사용 가능한 라이브러리를 조사하고 비교하여 프로젝트에 적합한 라이브러리를 선택해야 합니다. Angular 웹 애플리케이션을 개발할 때 사용할 수 있는 몇 가지 인기 있는 라이브러리가 있습니다. 각 라이브러리에는 고유한 기능과 장점이 있으므로 프로젝트에 가장 적합한 라이브러리를 선택하는 것이 중요합니다. 다음은 가장 인기 있는 Angular 라이브러리 중 일부입니다. Angular Material GitHub Stars: 23.2k License: MIT Angular Material은 사용자 인터페이스 디자인을 위한 다양한 컴포넌트를 제공하는 Angular 애플리케이션용 UI 컴포넌트 라이브러리입니다. Google의 Material Design 언어를 기반으로 하며 반응형 및 접근성 높은 웹 애플리케이션을 만드는 데 사용됩니다. Material Design 시스템을 기반으로 재사용 가능하고 충분한 테스트를 거친 접근 가능한 UI 컴포넌트 세트를 제공합니다. 또한 Angular Material은 광범위한 테마 시스템을 제공하여 개발자가 웹 애플리케이션의 모양과 느낌을 쉽게 커스터마이징할 수 있습니다. Angular Material 라이브러리의 주요 기능은 다음과 같습니다. Material 디자인 시스템을 기반으로 재사용 가능하고 잘 테스트되었으며 액세스 가능한 UI 컴포넌트 세트입니다. 직관적이고 효율적인 방법으로 현대적인 대화형 웹 앱을 제작할 수 있습니다. 웹 앱의 모양과 느낌을 쉽게 커스터마이징 할 수 있는 광범위한 테마 시스템입니다. 완벽하게 반응하는 디자인으로 웹 앱이 모든 기기에서 멋지게 보입니다. 방대한 문서화 및 지원을 통해 필요한 경우 쉽게 도움을 받을 수 있습니다. button, card, input field, slider 등과 같은 구현하기 쉬운 컴포넌트입니다. AngularFire GitHub Stars: 7.5k License: MIT AngularFire는 Firebase 실시간 데이터베이스와 상호 작용하기 위한 사용하기 쉬운 API를 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 데이터 동기화, 인증 등과 같은 실시간 기능을 웹 앱에 더 쉽게 추가할 수 있도록 설계되었습니다. 또한 개발자가 Cloud Storage, Cloud Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스할 수 있는 인터페이스를 제공합니다. AngularFire는 개발자가 실시간 기능을 갖춘 웹 앱을 보다 쉽게 ​​구축할 수 있도록 하는 다양한 기능을 제공합니다. Firebase 실시간 데이터베이스와 상호작용하기 위한 사용하기 쉬운 API입니다. 여러 클라이언트에서 데이터의 실시간 동기화를 지원합니다. 사용자가 앱에 쉽게 가입하고 로그인할 수 있는 인증 시스템을 제공합니다. Cloud Storage, Functions, Firebase 호스팅과 같은 Firebase 서비스에 액세스합니다. 개발자가 프로젝트를 빠르게 시작하고 실행할 수 있는 간단하고 직관적인 인터페이스입니다. Angular, React, Vue 등 다양한 플랫폼을 지원합니다. Angular CLI GitHub Stars: 26.4k License: MIT Angular CLI는 Angular 애플리케이션을 생성, 구축 및 배포하기 위한 명령줄(Command line) 인터페이스입니다. 개발자가 앱을 빠르게 생성, 빌드 및 배포할 수 있도록 설계되었습니다. 새 프로젝트를 빠르게 설정할 수 있는 직관적인 스캐폴딩 시스템을 제공하며 라우팅, 테스트 및 컴포넌트와 같은 일반적인 작업을 위한 코드를 생성합니다. 또한 개발자는 한 번의 명령으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다. Angular CLI 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션을 생성, 구축, 배포하기 위한 명령줄 인터페이스입니다. 새로운 프로젝트를 빠르게 설정하기 위한 직관적인 스캐폴딩 시스템을 제공합니다. 라우팅, 테스트, 컴포넌트 등 일반적인 작업을 위한 코드를 생성합니다. 명령 한 번으로 앱을 로컬에서 쉽게 서비스하고 프로덕션 환경에 배포할 수 있습니다. 다양한 타사 라이브러리를 지원하여 다른 도구와 프레임워크를 쉽게 통합할 수 있습니다. 개발자가 프로젝트를 빠르게 설정하는 데 도움이 되는 다양한 도구와 명령을 제공합니다. Angular UI Bootstrap GitHub Stars: 14.3k License: MIT Angular UI Bootstrap은 Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트를 제공하는 라이브러리입니다. 개발자가 반응형 모바일 친화적인 웹 애플리케이션을 더 쉽게 만들 수 있도록 설계되었습니다 Angular UI Bootstrap 라이브러리의 주요 기능은 다음과 같습니다. Twitter Bootstrap을 기반으로 사용자 인터페이스를 생성하기 위한 Directive 세트입니다. 반응성이 뛰어나고 모바일 친화적인 웹 애플리케이션을 만들 수 있습니다. alert, button, carousel 등과 같은 다양한 컴포넌트를 사용하여 시각적으로 매력적인 대화형 사용자 인터페이스를 만들 수 있습니다. 웹 애플리케이션에 쉽게 통합할 수 있는 사전 구축된 컴포넌트입니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 시각적으로 매력적인 대화형 사용자 인터페이스를 만드는 직관적이고 효율적인 방법입니다. Angular Flex Layout GitHub Stars: 5.9k License: MIT Angular Flex-Layout은 Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공하는 라이브러리입니다. 개발자가 기기나 화면 크기에 관계없이 유연하고 반응이 빠른 사용자 인터페이스를 쉽게 만들 수 있도록 설계되었습니다. Angular Flex-Layout 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션 구축을 위한 반응형 레이아웃 시스템을 제공합니다. fxLayout 및 fxFlex와 같은 다양한 Directive를 사용하여 유연하고 반응이 빠른 레이아웃을 만들 수 있습니다. 맞춤형 반응형 레이아웃 및 컴포넌트를 생성하기 위한 API입니다. 레이아웃 크기와 중단점을 쉽게 관리하는 기능을 제공합니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 개발자가 유연하고 반응이 빠른 사용자 인터페이스를 만들 수 있습니다. NgRx GitHub Stars: 7.8k License: MIT NgRx는 복잡한 애플리케이션에서 데이터를 관리하기 위한 상태 관리 시스템을 제공하는 Angular 애플리케이션용 라이브러리입니다. 개발자가 애플리케이션을 보다 쉽게 ​​생성, 유지 관리 및 테스트할 수 있도록 설계되었습니다. NgRx 라이브러리의 주요 기능은 다음과 같습니다. 복잡한 애플리케이션의 데이터를 관리하기 위한 상태 관리 시스템을 제공합니다. 예측 가능하고 일관되게 데이터를 관리하기 위한 API 및 도구 세트입니다. 애플리케이션 상태 업데이트를 쉽게 관리하기 위한 직관적인 인터페이스입니다. 상태 변경을 추적하고 추적하기 위한 강력한 디버깅 도구입니다. 문서화가 잘 되어 있어 필요한 경우 쉽게 도움을 받을 수 있습니다. 애플리케이션을 더욱 쉽게 생성, 유지 관리 및 테스트할 수 있습니다. Angular Charts GitHub Stars: 2.3k License: MIT Angular Charts 라이브러리는 Angular 팀에서 만든 오픈 소스 라이브러리로, Angular 애플리케이션에서 대화형 차트를 만들기 위한 선언형 API를 제공합니다. 선형, 막대형, 영역형, 원형, 도넛형, 분산형 차트를 포함한 다양한 차트 유형을 지원합니다. 또한 스타일과 애니메이션에 대한 다양한 커스터마이징 옵션도 제공합니다. Angular Charts 라이브러리의 주요 기능은 다음과 같습니다. Angular 애플리케이션에서 차트를 생성하기 위한 선언형 API line, bar, area, pie, doughnut 및 scatter 차트를 포함한 다양한 차트 유형 지원 차트의 스타일, 애니메이션 및 기타 속성을 사용자에 맞게 설정하는 옵션 제공 확대/축소 및 hovering 과 같은 대화형 기능 지원 고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능 정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원 Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원 Angular2-Google-Maps GitHub Stars: 2k License: MIT Angular2-Google-Maps는 Angular 팀에서 만든 오픈 소스 라이브러리로, Google 지도를 Angular 애플리케이션에 통합하기 위한 사용하기 쉬운 인터페이스를 제공합니다. Angular2-Google-Maps 라이브러리의 주요 기능은 다음과 같습니다. Google 지도 컴포넌트 생성을 위한 선언형 API center, zoom level, marker 등과 같은 다양한 속성을 지정하는 기능 스타일링, 애니메이션 등 다양한 커스터마이징 옵션 지원 고급 기능을 위해 D3.js와 같은 다른 라이브러리와 통합하는 기능 정적 데이터, 원격 REST API, 실시간 데이터 스트림을 포함한 여러 데이터 소스 지원 Chrome, Firefox, Safari, Edge 등 다양한 브라우저 지원 Angular-Draggable GitHub Stars: 132 License: MIT Angular-Draggable 라이브러리는 널리 사용되는 JavaScript 프레임워크인 Angular를 사용하여 드래그(draggable) 및 크기 조정(resizable)이 가능한 사용자 인터페이스를 만들기 위한 오픈 소스 라이브러리입니다. Angular-Draggable의 주요 기능 중 일부는 다음과 같습니다. 사용자 맞춤형 옵션이 포함된 드래그 앤 드롭 기능 스냅 옵션으로 크기 조정 가능한 요소 사용자 맞춤형 드래그 handle Placeholder 지원 맞춤형 스타일 다른 Angular 컴포넌트와 쉽게 통합 Ngx-datatable GitHub Stars: 4.6k License: MIT Ngx-datatable은 개발자가 Sorting, Filtering, Pagination과 같은 고급 기능을 사용하여 동적이고 반응이 빠른 테이블을 쉽게 만들 수 있는 오픈 소스 라이브러리입니다. 또한 성능에 최적화되어 개발자가 성능 저하 없이 대규모 데이터 세트를 신속하게 렌더링할 수 있습니다. Ngx-datatable은 JSON, CSV, OData를 포함한 광범위한 데이터 소스를 지원합니다. 또한 클라이언트 또는 서버 측 데이터 처리를 지원하며 사용자에 맞는 템플릿 및 스타일을 설정할 수 있습니다. Ngx-datatable 라이브러리의 주요 기능은 다음과 같습니다. 유연한 데이터 바인딩: Ngx-datatable은 로컬 및 원격 데이터 바인딩을 모두 지원하므로 다양한 데이터 소스의 데이터를 쉽게 바인딩할 수 있습니다. 고급 필터링 및 정렬: Ngx-datatable을 사용하면 데이터를 빠르게 필터링하고 정렬하여 필요한 정보를 더 쉽게 찾을 수 있습니다. 열 크기 조정: 테이블 너비에 맞게 열 크기를 조정하거나 다양한 데이터 유형을 수용할 수 있습니다. 행 가상화(Virtualization): Ngx-datatable은 행이 표시되는 경우에만 행을 렌더링하므로 성능 문제 없이 대규모 데이터 세트를 스크롤할 수 있습니다. 열 재정렬: 열을 재정렬하여 테이블 레이아웃을 커스터마이징 할 수 있습니다. 편집 가능한 cell: 테이블의 특정 셀을 편집 가능하게 만들어 사용자가 데이터를 빠르게 업데이트할 수 있습니다. 결론 성공적인 웹 애플리케이션을 제작하려면 차세대 웹 앱에 적합한 Angular 라이브러리를 선택하는 것이 필수적입니다. 올바른 라이브러리를 사용하면 개발에 많은 시간과 노력을 들이지 않고도 앱을 빠르게 구축할 수 있습니다. 라이브러리를 선택할 때는 라이브러리가 제공하는 기능뿐만 아니라 라이브러리의 성능과 확장성을 고려하는 것이 중요합니다. 또한 라이브러리의 비용과 라이브러리가 제공하는 지원 수준도 고려하세요. 요구 사항을 평가하고 사용 가능한 Angular 라이브러리를 조사하여 정보에 입각한 결정을 내리고 웹 애플리케이션에 가장 적합한 라이브러리를 선택할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"Angularjs","slug":"Angularjs","permalink":"http://hgko1207.github.io/tags/Angularjs/"},{"name":"차세대 웹 앱","slug":"차세대-웹-앱","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%84%B8%EB%8C%80-%EC%9B%B9-%EC%95%B1/"}]},{"title":"Vue 2와 Vue 3의 차이점","slug":"vue-3","date":"2023-12-01T06:15:09.000Z","updated":"2023-12-09T13:17:15.284Z","comments":true,"path":"2023/12/01/vue-3/","link":"","permalink":"http://hgko1207.github.io/2023/12/01/vue-3/","excerpt":"","text":"프런트엔드 개발 세계에서는 Vue.js가 인기 있는 선택이 되었습니다. Vue.js는 최신 웹 애플리케이션 개발에 널리 사용되는 사용자 친화적인 JavaScript 프레임워크입니다. 그러나 Vue.js의 최신 버전인 Vue 3은 중요한 업데이트와 개선 사항을 도입한다는 점에서 Vue 2와 다릅니다. 이 글에서는 Vue 2와 Vue 3의 주요 차이점을 자세히 살펴보겠습니다. Virtual DOM Vue.js의 기초는 Virtual DOM(Document Object Model) 기술에 있습니다. Vue 2에서는 Virtual DOM이 Vue.js의 이벤트 루프에 완벽하게 통합됩니다. 그러나 Vue 3에서는 Virtual DOM이 재설계되어 더욱 효율적으로 만들어졌습니다. Vue 3에서는 Virtual DOM이 더 빠르게 처리되고 더 적은 메모리를 사용합니다. 이는 성능과 애플리케이션 응답 시간을 크게 향상시킵니다. Composition API Vue 3에서는 가장 주목할만한 기능 중 하나인 Composition API를 도입했습니다. Composition API는 Vue 2의 Options API와 다르며 코드를 더욱 체계화하고 유지 관리 및 재사용 가능하게 만듭니다. Vue 2에서 컴포넌트는 data, methods, computed 및 watch와 같은 옵션을 사용하여 정의됩니다. Vue 3에서는 코드를 보다 기능적으로 구성할 수 있습니다. Composition API를 사용하면 더 작고 재사용이 가능하며 사용자 맞춤형 기능을 만들 수 있습니다. TypeScript Integration Vue.js는 TypeScript와 같은 정적 유형 검사 도구를 사용하는 프로젝트에 널리 사용됩니다. Vue 2에서는 TypeScript 통합이 가능했지만 개발자는 몇 가지 어려움과 문제에 직면했을 수 있습니다. Vue 3에서는 TypeScript 통합이 크게 향상되었습니다. Vue 3에서 TypeScript를 사용하면 더 나은 정적 유형 제어와 더 부드러운 TypeScript 경험을 얻을 수 있습니다. Bundle Size 번들 크기는 대규모 프런트엔드 프로젝트에서 중요한 요소입니다. Vue 2에서는 번들 크기를 줄이기 위해 다양한 최적화 기술과 플러그인이 필요할 수 있습니다. 그러나 Vue 3에서는 최적화된 매칭 알고리즘 및 소스 코드 압축과 같은 개선으로 번들 크기가 크게 줄었습니다. 그 결과 번들 크기가 작아지고 로딩 시간이 빨라지며 성능이 향상됩니다. Compatibility Vue 3은 Vue 2 프로젝트에서 전환하는 개발자에게 호환성 문제를 일으킬 수 있습니다. Vue 3는 일부 API 또는 컴포넌트를 삭제하거나 다른 이름을 바꾸거나 변경할 수 있습니다. 따라서 기존 Vue 2 프로젝트를 Vue 3으로 업그레이드하려는 경우 몇 가지 호환성 문제가 발생할 수 있습니다. Vue 3에 대한 자세한 마이그레이션 가이드가 있으며, 이 가이드를 참조하면 전환 과정에서 지침을 얻을 수 있습니다. 결론 Vue 2와 Vue 3의 주요 차이점을 검토하는 이 글에서는 재설계된 Virtual DOM, Composition API 도입, 향상된 TypeScript 통합 및 더 작은 번들 크기와 같은 요소를 다루었습니다. 이러한 요소로 인해 Vue 3는 프런트엔드 개발을 위한 강력한 선택이 되었습니다. 새로운 기능과 개선 사항에도 불구하고 기존 프로젝트를 Vue 2에서 Vue 3으로 전환하면 호환성 문제가 발생할 수 있습니다. 따라서 Vue 3으로의 전환을 고려하고 있다면 신중한 계획과 호환성 문제에 대한 주의가 중요합니다. Vue.js는 빠르고 강력하며 사용자 친화적인 프레임워크로서 인기를 계속 유지하고 있으며 Vue 3을 사용하면 더 많은 유연성을 도입할 수 있습니다. 개발 프로세스에 성능을 추가합니다. 자세한 내용은 공식 Vue.js 설명서를 참조하세요.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Vue 2","slug":"Vue-2","permalink":"http://hgko1207.github.io/tags/Vue-2/"},{"name":"Vue 3","slug":"Vue-3","permalink":"http://hgko1207.github.io/tags/Vue-3/"}]},{"title":"버전 관리 이해하기","slug":"info-5","date":"2023-12-01T05:41:14.000Z","updated":"2023-12-01T06:48:11.782Z","comments":true,"path":"2023/12/01/info-5/","link":"","permalink":"http://hgko1207.github.io/2023/12/01/info-5/","excerpt":"","text":"소개 끊임없이 진화하는 소프트웨어 개발 환경에서 버전 제어 개념은 초석이 됩니다. 단독 프로젝트를 진행하든 팀과 협업하든 관계없이 버전 제어 시스템(Version Control System, VCS)은 코드 변경을 관리하고 프로젝트 무결성을 유지하며 원활한 협업을 촉진하는 데 중요한 역할을 합니다. 이 글에서는 버전 제어의 세계에 대해 자세히 알아보고 버전 제어의 이점, 유형, 널리 사용되는 도구 및 모범 사례를 살펴보겠습니다. 버전 관리 이해 버전 제어는 시간이 지남에 따라 프로젝트(일반적으로 소스 코드)의 변경 사항을 관리하기 위한 체계적인 접근 방식입니다. 이는 개발자에게 수정 사항을 추적하고 효과적으로 협업하며 필요한 경우 이전 상태로 되돌릴 수 있는 기능을 제공합니다. 이 프로세스를 통해 프로젝트는 체계적으로 정리되고 기록이 보존되며 팀 구성원은 충돌 없이 동시에 작업할 수 있습니다. 버전 관리의 이점 변경 사항 추적(Change Tracking): 버전 제어 시스템은 코드베이스에 적용된 모든 변경 사항을 꼼꼼하게 기록합니다. 이 감사 추적을 통해 변경이 발생했을 때 변경한 사람과 변경 이유를 쉽게 식별할 수 있습니다. 협업(Collaboration): 개발자 팀은 프로젝트의 여러 부분에서 동시에 작업할 수 있습니다. 버전 제어 시스템을 사용하면 변경 사항을 원활하게 병합하고 충돌을 방지하며 효율적인 협업을 촉진할 수 있습니다. 롤백 및 복구(Rollback and Recovery): 실수는 발생하지만 버전 제어를 통해 코드베이스의 이전 상태로 되돌릴 수 있습니다. 이 기능은 위험을 완화하고 오류의 영향을 줄입니다. 분기 및 병합(Branching and Merging): 버전 제어 시스템은 개발의 병렬 라인인 분기를 생성하는 기능을 제공하므로 팀은 기본 코드베이스에 영향을 주지 않고 새로운 기능을 실험할 수 있습니다. 이러한 분기를 기본 코드베이스에 다시 병합하는 것은 원활한 프로세스입니다. 문서화 및 통신(Documentation and Communication): 버전 제어의 커밋 메시지는 문서 형식으로 작동하여 특정 변경 사항이 적용된 이유에 대한 통찰력을 제공합니다. 이는 팀 의사소통과 지식 공유에 도움이 됩니다. 버전 관리 시스템의 유형 중앙 버전 제어 시스템(Centralized Version Control System, CVCS): CVCS에는 전체 프로젝트 기록을 보관하는 중앙 저장소가 있습니다. 개발자는 이 저장소에서 코드를 체크아웃하고 작업한 다음 변경 사항을 다시 커밋합니다. 예로는 CVS 및 Subversion(SVN)이 있습니다. 분산 버전 제어 시스템(Distributed Version Control System, DVCS): Git 및 Mercurial과 같은 DVCS는 각 개발자의 컴퓨터에 저장소의 전체 복사본(클론)을 생성합니다. 이러한 중복성은 협업을 강화하고 변경 사항을 중앙 저장소에 동기화하기 전에 로컬 커밋을 허용합니다. 인기 있는 버전 관리 도구 Git: 가장 널리 사용되는 DVCS인 Git은 속도, 유연성 및 분기 기능으로 잘 알려져 있습니다. 개인 개발자부터 Linux와 같은 대규모 오픈 소스 프로젝트에 이르기까지 모든 규모의 프로젝트에서 사용됩니다. Subversion(SVN): SVN은 비교적 사용자 친화적인 중앙 집중식 버전 제어 시스템입니다. 단순성과 기존 인프라와의 원활한 통합으로 인해 종종 선택됩니다. Mercurial: Git과 유사하게 Mercurial은 또 다른 분산 버전 제어 시스템입니다. 사용하기 쉽고 학습 곡선이 간단한 것으로 알려져 있습니다. 버전 제어 모범 사례 설명이 포함된 커밋 메시지 사용: 커밋 메시지는 변경 목적을 간결하게 설명해야 합니다. 잘 작성된 커밋 메시지는 협업과 이해를 돕는 데 큰 도움이 됩니다. 빈번한 커밋(Commit): 특정 변경 사항에 초점을 맞춘 작고 논리적인 커밋을 만듭니다. 이렇게 하면 기록을 더 쉽게 이해하고 문제를 격리할 수 있습니다. 전략적으로 분기(Branch): 새로운 개발을 위한 기능 분기와 문제 해결을 위한 버그 수정 분기를 만듭니다. 이는 메인 브랜치를 안정적으로 유지합니다. 정기적으로 끌어오기(Pull) 및 푸시(Push): 로컬 저장소를 원격 저장소와 동기화하여 최신 변경 사항이 있는지 확인하고 차이를 방지합니다. 신중한 검토(Review) 및 병합(Merge): 분기를 병합하기 전에 코드 변경 사항을 철저히 검토하고 잠재적인 충돌이 있는지 테스트하십시오. 결론 버전 제어 시스템은 소프트웨어 개발 프로세스를 혁신하여 효율적인 협업, 변경 관리 및 프로젝트 구성을 가능하게 했습니다. 숙련된 개발자이든 이제 막 시작하는 개발자이든 버전 제어 방식을 수용하고 Git과 같은 도구를 활용하면 개발 워크플로우를 크게 향상시킬 수 있습니다. 프로젝트 발전에 대한 체계적인 기록을 유지함으로써 문제를 해결하고 진행 상황을 추적하며 고품질 소프트웨어를 제공할 수 있는 능력을 더 잘 갖추게 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"버전 관리","slug":"버전-관리","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"코드 관리","slug":"코드-관리","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%93%9C-%EA%B4%80%EB%A6%AC/"},{"name":"공동 개발","slug":"공동-개발","permalink":"http://hgko1207.github.io/tags/%EA%B3%B5%EB%8F%99-%EA%B0%9C%EB%B0%9C/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"작업 흐름","slug":"작업-흐름","permalink":"http://hgko1207.github.io/tags/%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84/"},{"name":"VCS","slug":"VCS","permalink":"http://hgko1207.github.io/tags/VCS/"}]},{"title":"Vue JS 기본 설명","slug":"vue-2","date":"2023-11-30T01:27:22.000Z","updated":"2024-01-12T13:27:44.963Z","comments":true,"path":"2023/11/30/vue-2/","link":"","permalink":"http://hgko1207.github.io/2023/11/30/vue-2/","excerpt":"","text":"Vue 애플리케이션을 시작하려면 명령어을 사용 하세요. 1npm create vue@latest 공식 Vue 프로젝트 스캐폴딩 도구인 create-vue를 설치하고 실행합니다. 설치 시 프로젝트 이름, TypeScript 설정, JSX 및 테스트 지원과 같은 몇 가지 선택적 기능에 대한 프롬프트가 표시됩니다: 123456789101112✔ Project name: … &lt;your-project-name&gt;✔ Add TypeScript? … No / Yes✔ Add JSX Support? … No / Yes✔ Add Vue Router for Single Page Application development? … No / Yes✔ Add Pinia for state management? … No / Yes✔ Add Vitest for Unit testing? … No / Yes✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright✔ Add ESLint for code quality? … No / Yes✔ Add Prettier for code formatting? … No / YesScaffolding project in ./&lt;your-project-name&gt;...Done. SPA(단일 페이지 애플리케이션)의 경우 Vue 라우터를 포함해야 합니다. SPA를 생성하라는 메시지가 표시되면 긍정적으로 응답합니다. 옵션에 대해 확신이 서지 않는다면 일단 엔터키를 눌러 No를 선택하면 됩니다. 프로젝트가 생성되면 지침에 따라 종속 패키지를 설치하고 개발 서버를 시작합니다. 123cd &lt;your-project-name&gt;npm installnpm run dev Single-Page Application(SPA) 폴더 구조 1234567891011121314151617181920212223my-vue-app&#x2F;|-- public&#x2F;| |-- index.html||-- src&#x2F;| |-- assets&#x2F;| | |-- logo.png|| |-- components&#x2F;| | |-- HelloWorld.vue|| |-- views&#x2F;| | |-- Home.vue| | |-- About.vue|| |-- App.vue| |-- main.js||-- .gitignore|-- babel.config.js|-- package.json|-- README.md|-- vue.config.js 일반적인 Vue SPA 구조에는 다음이 포함됩니다. public/: 웹 서버에서 직접 제공하는 index.html 및 기타 assets을 포함합니다. src/: assets, components, views, router, App.vue 및 main.js를 포함하여 Vue 애플리케이션의 소스 코드를 보유합니다. assets/: 이미지 및 글꼴과 같은 정적 리소스를 포함합니다. components/: 재사용 가능한 Vue 컴포넌트를 포함합니다. views/: 다양한 views 나 pages를 나타내는 다양한 컴포넌트가 포함되어 있습니다. router/: Vue Router 관련 파일 및 경로 정의를 포함합니다. store/: 상태 관리를 위해 Vuex를 사용하는 경우 이 폴더에는 Vuex 스토어 관련 파일이 저장됩니다. App.vue: 전체 애플리케이션의 루트 Vue 컴포넌트 및 진입점 역할을 합니다. main.js: Vue 앱을 초기화하고, 라우터를 구성하고, 앱을 DOM에 마운트 합니다. main.js 파일은 애플리케이션을 설정합니다. 1234567import &#123; createApp &#125; from 'vue';import App from './App.vue';import router from './router';const app = createApp(App);app.use(router);app.mount('#app'); App.vue 파일 12345&lt;template&gt; &lt;main&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/main&gt;&lt;/template&gt; Script 기본 포트를 변경하려면 package.json의 script 태그를 사용자 정의 스크립트로 수정하세요. 123\"scripts\": &#123; \"dev-local\": \"vite --port 3000 --host 0.0.0.0\"&#125; 업데이트된 포트에서 애플리케이션을 시작하려면 명령어를 실행하세요. 1npm run dev-local Navigation MPA(Multi-Page Application)와 SPA(Single Page Application)는 웹 애플리케이션 구축을 위한 두 가지 서로 다른 아키텍처 접근 방식입니다. 주요 차이점은 콘텐츠 탐색 및 렌더링을 처리하는 방법에 있습니다. MPA MPA에서 각 페이지는 일반적으로 별도의 HTML 파일에 해당합니다. 각 링크나 상호 작용이 서버에 대한 요청을 트리거하고 전체 페이지가 대체되므로 페이지 간 탐색에는 전체 페이지 다시 로드가 포함됩니다. 서버는 각 페이지의 HTML을 렌더링 하고 제공하는 일을 담당합니다. SPA SPA에는 애플리케이션의 진입점 역할을 하는 단일 HTML 파일이 있습니다. 애플리케이션 내 탐색은 일반적으로 Vue Router와 같은 클라이언트 측 라우터를 사용하여 JavaScript로 처리됩니다. 사용자가 애플리케이션과 상호 작용할 때 필요한 구성 요소만 DOM 안팎으로 동적으로 로드되고 교체됩니다. Performance MPA 전체 페이지를 다시 로드하면 특히 콘텐츠가 많은 페이지에서 성능이 느려질 수 있습니다. CSS 및 JavaScript와 같은 리소스는 각 페이지 요청마다 새로 로드됩니다. SPA SPA는 필요한 데이터만 서버에서 가져오고 전체 페이지를 다시 로드하지 않고도 페이지 전환이 더 원활해지기 때문에 더 빠르고 원활한 사용자 환경을 제공할 수 있습니다. 초기 페이지와 자산이 로드되면 후속 상호 작용에 추가 서버 요청이 필요하지 않으므로 사용자 경험이 더 빨라질 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"기본","slug":"기본","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8/"}]},{"title":"[Angular] 컴포넌트 데코레이터(Component Decorator) 사용 방법","slug":"angular-31","date":"2023-11-28T01:59:13.000Z","updated":"2024-01-12T13:27:08.843Z","comments":true,"path":"2023/11/28/angular-31/","link":"","permalink":"http://hgko1207.github.io/2023/11/28/angular-31/","excerpt":"","text":"Angular에서 @Component 데코레이터는 재사용 가능한 UI 컴포넌트(Component)를 구축하는 초석입니다. Angular 애플리케이션 내에서 컴포넌트를 처리하고, 인스턴스화하고, 사용하는 방법을 정의하는 메타데이터를 제공합니다. 이 글에서는 @Component 데코레이터를 심층적으로 살펴보고, 다양한 속성에 대해 논의하고, 이러한 속성을 사용하여 코드 복잡성을 관리하는 방법을 설명합니다. 기본 사항 @Component 데코레이터는 구성 개체를 인수로 사용하는 함수입니다. 메타데이터를 컴포넌트 클래스와 연결하는 데 사용되므로 Angular가 컴포넌트를 생성하고 렌더링 하는 방법을 이해할 수 있습니다. @Component 데코레이터를 사용하는 간단한 예는 다음과 같습니다. 12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.scss'],&#125;)export class ExampleComponent &#123; // Component logic&#125; 속성 @Component 데코레이터는 컴포넌트의 다양한 측면을 정의하는 다양한 속성을 허용합니다. 가장 일반적으로 사용되는 속성 중 일부를 살펴보겠습니다. selector: 템플릿에서 이 컴포넌트를 식별하는 CSS 선택자(selector)입니다. Angular는 템플릿에서 해당 선택자를 찾을 때마다 컴포넌트의 인스턴스를 생성하고 삽입합니다. templateUrl: 컴포넌트의 템플릿이 포함된 외부 HTML 파일의 URL입니다. template: 컴포넌트의 인라인 HTML 템플릿입니다. templateUrl 또는 template 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다. styleUrls: 컴포넌트의 템플릿에 적용할 외부 CSS 파일의 배열입니다. styles: 컴포넌트의 템플릿에 적용할 인라인 CSS 스타일의 배열입니다. styleUrls 또는 styles 중 하나를 사용할 수 있지만 둘 다 사용할 수는 없습니다. providers: 이 컴포넌트와 해당 하위 컴포넌트에 대한 종속성 주입 공급자의 배열입니다. encapsulation: 컴포넌트의 템플릿에 스타일이 적용되는 방식을 결정하는 속성입니다. ViewEncapsulation.None, ViewEncapsulation.Emulated 또는 ViewEncapsulation.ShadowDom으로 설정할 수 있습니다. changeDetection: 컴포넌트의 변경 감지 전략을 결정하는 속성입니다. ChangeDetectionStrategy.Default 또는 ChangeDetectionStrategy.OnPush 로 설정할 수 있습니다. 코드 복잡성 관리 @Component 데코레이터에서 사용할 수 있는 다양한 속성을 사용하면 문제를 명확하게 분리하고 컴포넌트의 리소스를 구성하여 코드 복잡성을 관리할 수 있습니다. 다음은 코드 복잡성 관리에 대한 몇 가지 팁입니다. 템플릿(templateUrl)과 스타일(styleUrls)에 별도의 파일 사용: HTML 템플릿과 CSS 스타일을 별도의 파일에 배치하면 컴포넌트 클래스를 로직에 집중하고 유지 관리하기 쉽게 할 수 있습니다. 캡슐화(encapsulation) 활용: ViewEncapsulation을 활용하면 컴포넌트 스타일의 범위를 제어하여 원치 않는 부작용을 방지하고 스타일을 더욱 모듈화할 수 있습니다. 변경 감지 최적화: 적절한 changeDetection 전략을 선택하면 특히 크고 복잡한 애플리케이션에서 컴포넌트의 성능을 향상시킬 수 있습니다. 예: 12345678910111213import &#123; Component, ViewEncapsulation, ChangeDetectionStrategy &#125; from '@angular/core';@Component(&#123; selector: 'app-complex', templateUrl: './complex.component.html', styleUrls: ['./complex.component.scss'], encapsulation: ViewEncapsulation.Emulated, changeDetection: ChangeDetectionStrategy.OnPush, providers: [CustomService],&#125;)export class ComplexComponent &#123; // Component logic&#125; 결론 강력하고 효율적인 Angular 컴포넌트를 생성하려면 @Component 데코레이터와 해당 속성을 이해하는 것이 필수적입니다. 다양한 속성을 활용하여 코드 복잡성을 관리하고, 성능을 개선하고, 유지 관리 가능한 모듈식 애플리케이션을 만들 수 있습니다. 계속해서 Angular를 탐색하고 컴포넌트로 작업하면서 코드를 최적화하고 원활한 사용자 경험을 만드는 새로운 방법을 발견하게 될 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular CLI] 명령어 사용 및 활용 방법","slug":"angular-30","date":"2023-11-23T05:40:39.000Z","updated":"2023-12-17T13:17:48.356Z","comments":true,"path":"2023/11/23/angular-30/","link":"","permalink":"http://hgko1207.github.io/2023/11/23/angular-30/","excerpt":"","text":"Angular CLI는 개발자가 Angular 애플리케이션을 쉽게 생성, 유지 및 관리하는 데 도움이 되는 강력한 명령줄 인터페이스입니다. 개발 워크플로우를 간소화하고 생산성을 향상시키는 다양한 기능을 제공합니다. 이 글에서는 필수 Angular CLI 명령어와 이 명령어가 복잡하고 정교한 Angular 애플리케이션을 개발하는 데 어떻게 도움이 되는지 살펴보겠습니다. Angular CLI 설치 Angular CLI를 사용하려면 시스템에 전역적으로 설치해야 합니다. Node.js와 npm이 설치되어 있는지 확인한 후 다음 명령어를 실행하세요. 1npm install -g @angular/cli 새로운 Angular 애플리케이션 생성 새로운 Angular 애플리케이션을 만들려면 ng new 명령어 뒤에 프로젝트 이름을 사용하세요. 1ng new my-app 이 명령어는 Angular 애플리케이션에 필요한 파일과 폴더를 포함하여 새 프로젝트 디렉터리를 생성합니다. 또한 필요한 종속성을 설치하고 로컬 개발 서버를 설정합니다. 실행 라이브 리로딩(live reloading)으로 로컬 개발 서버를 시작하려면 프로젝트의 루트 디렉터리로 이동하여 명령어를 실행하세요. 1ng serve 기본적으로 http://localhost:4200/ 주소로 애플리케이션이 실행됩니다. Component, Directive, Service 생성 Angular CLI를 사용하면 Component, Directive, Service, Pipe 및 Guard 와 같은 Angular 애플리케이션의 다양한 파일을 빠르게 생성할 수 있습니다. Component 생성 123ng generate component my-component# orng g c my-component Directive 생성 123ng generate directive my-directive# orng g d my-directive Service 생성 123ng generate service my-service# orng g s my-service Module 생성 123ng generate module my-module# orng g m my-module 이 명령어는 필요한 파일을 생성하고 해당 NgModule을 업데이트하여 새 요소를 등록합니다. 빌드 Angular 애플리케이션의 프로덕션 모드로 빌드를 하려면 다음 명령어를 실행하세요. 1ng build --prod 이 명령어는 dist/ 폴더에 최적화된 빌드를 생성합니다. 테스트 실행 및 Linting Angular CLI에는 테스트 실행 및 코드 Linting에 대한 지원이 내장되어 있습니다. 다음 명령어를 실행하세요. Karma로 단위 테스트 실행 1ng test Protractor를 사용하여 end-to-end 테스트 실행 1ng e2e TSLint로 코드 Lint 1ng lint Custom 빌드 구성 Angular CLI는 angular.json 파일을 사용하여 프로젝트 구성을 관리합니다. 이 파일을 수정하여 출력 경로, 파일 이름, 최적화 옵션과 같은 빌드 설정을 사용자에 맞게 설정할 수 있습니다. 예를 들어, outputPath 속성을 업데이트하여 프로덕션 모드 빌드의 출력 경로를 변경할 수 있습니다. 123456\"configurations\": &#123; \"production\": &#123; \"outputPath\": \"custom-output-folder\", ... &#125;&#125; 코드 복잡성 및 테마 Angular CLI를 사용하면 코드를 Component, Directive, Service로 모듈화하여 애플리케이션의 복잡성을 관리할 수 있습니다. 이는 깨끗하고 체계적인 코드베이스를 유지하는 데 도움이 되므로 애플리케이션을 더 쉽게 확장하고 수정할 수 있습니다. 테마 설정과 관련하여 Angular CLI는 테마를 직접 처리하지 않지만 CSS나 SCSS 또는 LESS와 같은 전처리기를 사용하여 테마를 프로젝트에 통합할 수 있습니다. Bootstrap, Bulma 또는 Angular Material과 같은 널리 사용되는 CSS 프레임워크를 사용하여 일관되고 시각적으로 매력적인 사용자 인터페이스를 만들 수도 있습니다. 결론 Angular CLI는 복잡하고 정교한 Angular 애플리케이션을 쉽게 개발하는 데 도움이 되는 강력한 도구입니다. 프로젝트 생성, 유지 관리를 위한 필수 명령어로 워크플로우를 간소화함으로써 고품질 코드를 작성하고 최고의 사용자 경험을 제공하는 데 집중할 수 있습니다. Angular CLI와 그 기능을 계속 탐색하면서 생산성을 향상하고 강력하고 확장 가능한 애플리케이션을 구축할 수 있는 더 많은 방법을 찾을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Angular CLI","slug":"Angular-CLI","permalink":"http://hgko1207.github.io/tags/Angular-CLI/"}]},{"title":"JavaScript 프레임워크 비교: Angular, React, Vue.js","slug":"js-dev-10","date":"2023-11-17T06:32:56.000Z","updated":"2023-12-01T06:13:09.819Z","comments":true,"path":"2023/11/17/js-dev-10/","link":"","permalink":"http://hgko1207.github.io/2023/11/17/js-dev-10/","excerpt":"","text":"웹 개발 세계에서 Angular, React 및 Vue.js와 같은 JavaScript 프레임워크는 개발자가 웹 애플리케이션을 구축할 수 있는 다양한 도구를 제공합니다. 그러나 각각은 서로 다른 디자인 철학, 학습 곡선(learning curve) 및 사용 사례를 가지고 있습니다. 다음은 이 세 가지 프레임워크를 비교한 것입니다. Angular 장점 모든 기능을 갖춘 프레임워크 Angular는 광범위한 기능들을 자랑하며 필요한 모든 도구를 포함합니다. 따라서 크고 복잡한 애플리케이션에 적합합니다. Type Safety TypeScript 사용 덕분에 컴파일 타임(compile-time) 오류 감지 기능을 제공하여 보다 안전한 코드를 보장합니다. 강력한 데이터 바인딩 Angular의 강력한 기능인 양방향 데이터 바인딩은 원활한 데이터 동기화를 촉진합니다. 단점 학습 곡선(Learning Curve) Angular는 학습 곡선이 더 가파르기 때문에 즉 초기에 습득해야 하는 기술 양이 많기 때문에 초보자에게는 다소 어려울 수 있습니다. 무게 Angular는 어떤 경우에는 다른 프레임워크에 비해 무거워서 성능 제한이 발생할 수 있습니다. React 장점 속도와 성능 React는 가상 DOM을 사용하여 신속하고 효율적으로 작동하여 애플리케이션 성능을 향상시킵니다. 모듈성 컴포넌트 기반 아키텍처를 통해 React는 모듈식 애플리케이션 구조를 허용합니다. 광범위한 생태계 React는 대규모 커뮤니티를 자랑하며 광범위한 도구 및 라이브러리 생태계의 지원을 받습니다. 단점 완전한 프레임워크가 아님 React는 오로지 사용자 인터페이스 라이브러리이므로 완전한 프레임워크를 형성하기 위해 다른 라이브러리나 도구와 함께 사용해야 합니다. 학습 곡선(Learning Curve) JSX 및 Virtual DOM과 같은 개념은 일부 개발자의 학습 곡선을 약간 증가시킬 수 있습니다. Vue.js 장점 경량 Vue.js는 가벼운 성능을 갖춘 작은 크기의 라이브러리입니다. 쉬운 통합 Vue.js는 기존 프로젝트에 쉽게 통합되고 점진적으로 채택될 수 있습니다. 문서 Vue.js는 사용자 친화적인 문서를 제공하여 학습 과정을 촉진합니다. 단점 소규모 커뮤니티 다른 두 프레임워크에 비해 커뮤니티가 더 작기 때문에 특정 영역에서는 리소스가 더 제한될 수 있습니다. 엔터프라이즈 수준 애플리케이션에는 적합하지 않습니다. Vue.js는 대규모의 복잡한 프로젝트에서 Angular 및 React에 비해 몇 가지 단점이 있을 수 있습니다. 결론 이 글에서는 각 프레임워크의 기능을 정리했습니다. 어떤 프레임워크를 사용할지는 프로젝트 요구 사항, 팀의 전문 지식, 선호도에 따라 선택됩니다. Angular, React 및 Vue.js는 모두 강력하고 효과적인 도구이므로 선택 시 프로젝트의 요구 사항과 개발 팀의 기술을 고려하는 것이 중요합니다. 참고 https://angular.io/ https://react.dev/ https://vuejs.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"}]},{"title":"[Visual Studio Code] 생산성 향상을 위한 팁","slug":"info-4","date":"2023-11-03T06:54:32.000Z","updated":"2023-12-04T07:20:48.723Z","comments":true,"path":"2023/11/03/info-4/","link":"","permalink":"http://hgko1207.github.io/2023/11/03/info-4/","excerpt":"","text":"Visual Studio Code(VS Code)는 개발 세계를 강타한 인기 있고 강력한 소스 코드 편집기입니다. 유연성, 확장성 및 풍부한 생태계 덕분에 많은 개발자가 선택합니다. 이 글에서는 코딩 경험을 향상하고 생산성을 높이는 데 도움이 되는 몇 가지 유용한 팁과 테마를 공유하겠습니다. 키보드 단축키 익히기 키보드 단축키를 사용하면 시간과 노력을 절약하여 효율성을 높일 수 있습니다. 시작하는 데 도움이 되는 몇 가지 필수 단축키는 다음과 같습니다. Ctrl+P 또는Cmd+P: 작업 공간에서 파일을 빠르게 엽니다. Ctrl+Shift+F 또는 Cmd+Shift+F: 전체 프로젝트에서 검색합니다. Alt+Up 또는 Alt+Down: 현재 줄을 위나 아래로 이동합니다. Ctrl+D 또는 Cmd+D: 현재 단어의 다음 항목을 선택합니다. Ctrl+Shift+L 또는 Cmd+Shift+L: 현재 단어와 일치하는 항목을 모두 선택합니다. File &gt; Preferences &gt; Keyboard Shortcuts 로 이동하여 커스텀 키보드 단축키를 만들 수도 있습니다. 통합 터미널 활용 VS Code에는 워크플로우를 간소화하는 데 도움이 되는 통합 터미널이 함께 제공됩니다. 몇 가지 편리한 단축키가 포함되어 있습니다. Ctrl+ 또는 Cmd+: 터미널을 열거나 닫습니다. Ctrl+Shift+5 또는 Cmd+Shift+5: 터미널을 분할합니다. File &gt; Preferences &gt; Settings 으로 이동하여 &quot;terminal&quot;을 검색하여 터미널을 커스터 마이징할 수도 있습니다. 방해 없는 코딩을 위한 Zen 모드 Zen 모드는 모든 UI(상태 표시줄, 활동 표시줄, 패널 및 사이드바)를 숨기고 전체 화면에 편집기만 표시하는 VS Code의 기능입니다. Ctrl+K Z 또는 Cmd+K Z로 활성화하세요. Zen 모드를 종료하려면 Esc를 두 번 누릅니다. 더 빠른 개발을 위한 코드 조각(Snippets) 코드 조각(Snippets)은 자동으로 코드를 삽입하는 템플릿입니다. VS Code에는 널리 사용되는 언어에 대한 코드 조각이 내장되어 있으며 File &gt; Preferences &gt; Configure User Snippets 으로 이동하여 자신만의 코드 조각을 만들 수 있습니다. 다양한 언어 및 프레임워크에 대해 미리 만들어진 코드 조각을 사용하여 확장 프로그램을 설치할 수도 있습니다. 편안한 코딩 환경을 위한 테마(Theme) VS Code는 코딩 환경을 커스터 마이징 할 수 있는 다양한 테마를 제공합니다. 다음은 인기 있는 것들입니다. Dark+ (default dark theme) Light+ (default light theme) Monokai Solarized Dark Dracula File &gt; Preferences &gt; Theme &gt; Color Theme 로 이동하여 테마를 변경할 수 있습니다. 더 많은 테마를 탐색하려면 Visual Studio Code Marketplace를 방문하여 &quot;theme&quot;를 검색하세요. 향상된 기능을 위한 확장(Extension) Extension 은 VS Code의 기능을 크게 확장할 수 있습니다. 일부 인기 있는 확장 기능은 다음과 같습니다. Prettier: 일련의 규칙에 따라 코드 형식을 자동으로 지정하는 코드 포맷터입니다. ESLint: 코드 일관성을 유지하고 버그를 조기에 발견하는 데 도움이 되는 린터(linter)입니다. Live Server: 정적 및 동적 페이지에 대한 라이브 다시 로드를 통해 로컬 개발 서버를 시작합니다. GitLens: VS Code 내에서 Git 기능을 강화하세요. 확장 프로그램을 관리하려면 활동 표시줄에서 확장 프로그램(Extensions) 아이콘을 클릭하거나 Ctrl+Shift+X 또는 Cmd+Shift+X를 누르세요. 결론 Visual Studio Code는 생산성을 높이고 코딩 환경을 향상할 수 있는 수많은 방법을 제공합니다. 키보드 단축키를 익히고, 통합 터미널을 활용하고, Zen 모드를 사용하고, 코드 조각을 만들고, 테마를 커스터 마이징하고, 강력한 확장 기능을 설치함으로써 이 다재다능한 편집기의 잠재력을 진정으로 활용할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://hgko1207.github.io/tags/Visual-Studio-Code/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://hgko1207.github.io/tags/VS-Code/"},{"name":"편집기","slug":"편집기","permalink":"http://hgko1207.github.io/tags/%ED%8E%B8%EC%A7%91%EA%B8%B0/"}]},{"title":"[Angular] ChangeDetectorRef: 수동 변경 감지에 대해 자세히 알아보기","slug":"angular-29","date":"2023-11-02T00:54:27.000Z","updated":"2024-01-12T13:24:53.764Z","comments":true,"path":"2023/11/02/angular-29/","link":"","permalink":"http://hgko1207.github.io/2023/11/02/angular-29/","excerpt":"","text":"변경 감지(Change Detection)는 Angular 애플리케이션의 중요한 측면으로, UI가 애플리케이션 상태와 동기화된 상태를 유지하도록 보장합니다. Angular는 효율적인 기본(default) 변경 감지 전략을 제공하지만 성능 최적화나 복잡한 사용 사례에는 보다 세부적인 접근 방식이 필요한 경우가 있습니다. 이 글에서는 ChangeDetectorRef의 강력한 기능을 심층적으로 살펴보고 해당 방법을 검토하고 잠재력을 최대한 보여주는 예를 보여 드리겠습니다. ChangeDetectorRef 이해 ChangeDetectorRef는 변경 감지 메커니즘에 대한 직접적인 인터페이스를 제공하는 Angular 클래스입니다. 이를 통해 개발자는 변경 감지를 수동으로 트리거(trigger)하고, 변경 감지 트리에서 컴포넌트를 분리하거나 다시 연결하고, 향후 변경 감지를 위해 컴포넌트를 표시할 수 있습니다. ChangeDetectorRef를 사용하면 개발자는 변경 감지 프로세스를 더 효과적으로 제어할 수 있어 애플리케이션의 성능과 유연성이 향상됩니다. ChangeDetectorRef가 제공하는 주요 메서드는 다음과 같습니다. detectorChanges(): 현재 컴포넌트와 해당 하위 컴포넌트에 대한 변경 감지를 수동으로 트리거합니다. markForCheck(): 다음 변경 감지 주기 동안 현재 컴포넌트와 해당 상위 컴포넌트에 변경 감지가 필요한 것으로 표시합니다. detach(): 변경 감지 트리에서 현재 컴포넌트를 분리하여 이 컴포넌트와 해당 하위 컴포넌트에 대한 자동 변경 감지를 효과적으로 중지합니다. reattach(): 현재 컴포넌트를 변경 감지 트리에 다시 연결하여 자동 변경 감지를 다시 한번 활성화합니다. 예제 1: 동적 컴포넌트 로딩 및 변경 감지 사용자 상호 작용에 따라 컴포넌트가 동적으로 로드되는 애플리케이션을 상상해 보세요. 이러한 시나리오에서는 ChangeDetectorRef를 사용하여 변경 감지를 최적화하고 필요한 경우에만 UI가 업데이트되도록 할 수 있습니다. 먼저 컴포넌트를 동적으로 로드하는 디렉티브을 만들어 보겠습니다. 123456789101112131415import &#123; ComponentFactoryResolver, Directive, Input, OnInit, ViewContainerRef &#125; from '@angular/core';@Directive(&#123; selector: '[appDynamicComponentLoader]',&#125;)export class DynamicComponentLoaderDirective implements OnInit &#123; @Input('appDynamicComponentLoader') component: any; constructor(private viewContainerRef: ViewContainerRef, private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125; ngOnInit() &#123; const factory = this.componentFactoryResolver.resolveComponentFactory(this.component); this.viewContainerRef.createComponent(factory); &#125;&#125; 이제 사용자 입력에 따라 동적으로 다양한 컴포넌트를 로드하는 컨테이너 컴포넌트를 만들어 보겠습니다. 123456789101112131415161718192021import &#123; Component, ComponentRef, ViewChild &#125; from '@angular/core';import &#123; DynamicComponentLoaderDirective &#125; from './dynamic-component-loader.directive';@Component(&#123; selector: 'app-container', template: ` &lt;ng-container *appDynamicComponentLoader=\"selectedComponent\"&gt;&lt;/ng-container&gt; &lt;button (click)=\"loadComponent('A')\"&gt;Load Component A&lt;/button&gt; &lt;button (click)=\"loadComponent('B')\"&gt;Load Component B&lt;/button&gt; `,&#125;)export class ContainerComponent &#123; @ViewChild(DynamicComponentLoaderDirective, &#123; static: true &#125;) dynamicComponentLoader: DynamicComponentLoaderDirective; selectedComponent: any; loadComponent(type: string) &#123; this.selectedComponent = type === 'A' ? ComponentA : ComponentB; this.dynamicComponentLoader.detectChanges(); &#125;&#125; 이 예에서는 새 컴포넌트가 로드될 때 변경 감지를 수동으로 트리거하기 위해 discoverChanges() 메서드를 사용하고 있습니다. 예제 2: Observable을 사용한 고급 변경 감지 다양한 컴포넌트가 Observable을 통해 데이터 업데이트를 받는 애플리케이션을 생각해 보세요. 우리는 특정 컴포넌트가 새 데이터를 수신할 때만 발생하도록 변경 감지를 최적화하려고 합니다. 먼저 데이터 서비스를 만듭니다. 1234567891011import &#123; Injectable &#125; from '@angular/core';import &#123; BehaviorSubject &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class DataService &#123; private dataSubject = new BehaviorSubject&lt;any[]&gt;([]); data$ = this.dataSubject.asObservable();&#125; 이제 데이터 서비스를 사용하고 여러 하위 컴포넌트가 있는 상위 컴포넌트를 만들어 보겠습니다. 123456789101112131415161718192021import &#123; Component, OnInit &#125; from '@angular/core';import &#123; DataService &#125; from './data.service';@Component(&#123; selector: 'app-parent', template: ` &lt;h2&gt;Parent Component&lt;/h2&gt; &lt;app-child *ngFor=\"let item of items; index as i\" [data]=\"item\" [index]=\"i\"&gt;&lt;/app-child&gt; `,&#125;)export class ParentComponent implements OnInit &#123; items: any[] = []; constructor(private dataService: DataService) &#123;&#125; ngOnInit() &#123; this.dataService.data$.subscribe((data) =&gt; &#123; this.items = data; &#125;); &#125;&#125; 마지막으로 데이터 업데이트를 수신하고 ChangeDetectorRef를 사용하는 하위 컴포넌트를 만듭니다. 12345678910111213141516171819202122232425262728293031import &#123; Component, Input, OnInit, ChangeDetectorRef &#125; from '@angular/core';import &#123; DataService &#125; from './data.service';@Component(&#123; selector: 'app-child', template: ` &lt;div *ngIf=\"data\"&gt; &lt;h3&gt;Child Component &#123;&#123; index &#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123; data &#125;&#125;&lt;/p&gt; &lt;/div&gt; `,&#125;)export class ChildComponent implements OnInit &#123; @Input() data: any; @Input() index: number; constructor(private cdr: ChangeDetectorRef, private dataService: DataService) &#123;&#125; ngOnInit() &#123; this.cdr.detach(); this.dataService.data$.subscribe((data) =&gt; &#123; const newData = data[this.index]; if (newData !== this.data) &#123; this.data = newData; this.cdr.markForCheck(); &#125; &#125;); &#125;&#125; 이 예에서는 detach()를 사용하여 변경 감지 트리에서 하위 컴포넌트를 분리했습니다. 그런 다음 markForCheck()를 사용하여 새 데이터가 수신될 때 변경 사항 감지를 위한 컴포넌트를 표시했습니다. 결론 ChangeDetectorRef는 개발자에게 Angular의 변경 감지 프로세스를 수동으로 제어할 수 있는 강력한 방법을 제공합니다. 기능을 이해하고 방법을 활용하면 성능을 위해 애플리케이션을 최적화하고 복잡한 사용 사례를 쉽게 처리할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"ChangeDetectorRef","slug":"ChangeDetectorRef","permalink":"http://hgko1207.github.io/tags/ChangeDetectorRef/"},{"name":"변경감지","slug":"변경감지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80/"}]},{"title":"[Angular] Pipe 소개 및 사용방법","slug":"angular-28","date":"2023-11-01T06:33:00.000Z","updated":"2024-01-12T13:22:22.401Z","comments":true,"path":"2023/11/01/angular-28/","link":"","permalink":"http://hgko1207.github.io/2023/11/01/angular-28/","excerpt":"","text":"Angular 파이프(Pipe)는 Angular 애플리케이션의 필수 부분으로, 데이터를 변환하고 형식을 지정하는 간단한 방법을 제공합니다. 파이프를 사용하면 필요에 맞게 데이터를 쉽게 조작하고 이해하기 쉬운 형식으로 표시할 수 있습니다. 이 글에서는 AsyncPipe, CurrentPipe, DatePipe, DecimalPipe, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe 및 UpperCasePipe를 포함한 다양한 유형의 Angular 파이프를 살펴보겠습니다. 또한 Angular 파이프를 효과적으로 사용하기 위한 모범 사례에 대해서도 알아보겠습니다. AsyncPipe AsyncPipe는 Angular에서 비동기 데이터를 처리하는 데 사용됩니다. 이를 통해 HTTP 요청 또는 Promise와 같은 비동기 작업에서 반환된 데이터를 표시할 수 있습니다. AsyncPipe는 Observable 또는 Promise를 구독(subscribe)하고 데이터가 변경되면 자동으로 뷰를 업데이트합니다. 다음은 AsyncPipe를 사용하여 비동기 데이터를 처리하는 예입니다. 1&lt;p&gt;&#123;&#123; (data$ | async)?.name &#125;&#125;&lt;/p&gt; CurrencyPipe CurrencyPipe는 Angular에서 통화(currency) 값의 형식을 지정하는 데 사용됩니다. 통화 기호, 천 단위 및 소수 구분 기호를 사용하여 특정 통화 형식으로 숫자를 표시할 수 있습니다. 다음은 통화 값 형식을 지정하기 위해 CurrencyPipe를 사용하는 예입니다. 12&lt;p&gt;&#123;&#123; 10000 | currency:'USD':'symbol':'1.2-2' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '$10,000.00' --&gt; DatePipe DatePipe는 Angular에서 날짜 형식을 지정하는 데 사용됩니다. ‘short’, ‘medium’, ‘long’ 등 특정 형식으로 날짜를 표시할 수 있습니다. 커스텀(custom) 날짜 형식을 지정할 수도 있습니다. 다음은 DatePipe를 사용하여 날짜 형식을 지정하는 예입니다. 12&lt;p&gt;&#123;&#123; today | date:'shortDate' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '11/1/23' --&gt; DecimalPipe DecimalPipe는 Angular에서 십진수 값의 형식을 지정하는 데 사용됩니다. 소수 구분 기호와 천 단위 구분 기호를 사용하여 특정 소수 형식으로 숫자를 표시할 수 있습니다. 다음은 DecimalPipe를 사용하여 10진수 값의 형식을 지정하는 예입니다. 12&lt;p&gt;&#123;&#123; 1000.5 | number:'1.2-2' &#125;&#125;&lt;/p&gt;&lt;!-- Output: '1,000.50' --&gt; I18nPluralPipe I18nPluralPipe는 Angular에서 복수형을 처리하는 데 사용됩니다. 항목 수에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nPluralPipe를 사용하여 복수화를 처리하는 예입니다. 1items = ['Message 1']; 12&lt;p&gt;&#123;&#123; items.length &#125;&#125; / &#123;&#123; items.length | i18nPlural : &#123; '=0': 'No items', '=1': '1 item', other: '# items' &#125; &#125;&#125;&lt;/p&gt;&lt;!-- Output: '1 / 1 item' --&gt; I18nSelectPipe I18nSelectPipe는 Angular에서 select 문을 처리하는 데 사용됩니다. 조건에 따라 다른 텍스트를 표시할 수 있습니다. 다음은 I18nSelectPipe를 사용하여 select 문을 처리하는 예입니다. 1&lt;p&gt;&#123;&#123; gender | select: &#123; 'male': 'He', 'female': 'She', 'other': 'They' &#125; &#125;&#125;&lt;/p&gt; JsonPipe JsonPipe는 Angular에서 JSON 데이터를 표시하는 데 사용됩니다. JSON 데이터를 읽을 수 있는 형식으로 표시할 수 있습니다. 다음은 JsonPipe를 사용하여 JSON 데이터를 표시하는 예입니다. 1&lt;p&gt;&#123;&#123; data | json &#125;&#125;&lt;/p&gt; LowerCasePipe LowerCasePipe는 문자열을 소문자로 변환하는 데 사용됩니다. 12&#123;&#123; 'HELLO WORLD' | lowercase &#125;&#125;&lt;!-- Output: hello world --&gt; PercentPipe PercentPipe는 숫자를 백분율로 형식화하는 데 사용됩니다. 12&#123;&#123; 0.25 | percent &#125;&#125;&lt;!-- Output: 25% --&gt; SlicePipe SlicePipe는 배열 또는 문자열의 조각을 추출하는 데 사용됩니다. 12&#123;&#123; 'abcdefghijk' | slice:0:5 &#125;&#125;&lt;!-- Output: abcde --&gt; TitleCasePipe TitleCasePipe는 문자열을 title 케이스로 변환하는 데 사용됩니다(각 단어의 첫 글자를 대문자로 표시). 12&#123;&#123; 'hello world' | titlecase &#125;&#125;&lt;!-- Output: Hello World --&gt; UpperCasePipe UpperCasePipe는 문자열을 대문자로 변환하는 데 사용됩니다. 12&#123;&#123; 'hello world' | uppercase &#125;&#125;&lt;!-- Output: HELLO WORLD --&gt; 결론 이 글에서는 다양한 Angular 파이프와 그 기능을 살펴보았습니다. 파이프는 애플리케이션에서 데이터를 쉽게 변환하고 형식을 지정할 수 있게 해주는 Angular의 중요한 기능입니다. 이러한 파이프를 이해하고 활용함으로써 Angular 애플리케이션을 보다 효율적이고 동적이고 사용자 친화적으로 만들 수 있습니다. 특정 사용 사례에 적합한 파이프를 사용하고 파이프를 철저히 테스트하는 것을 잊지 마세요. 이 글을 통해 Angular 파이프에 대한 더 나은 이해와 응용 프로그램에서 이를 효과적으로 사용하는 방법을 얻을 수 있기를 바랍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Pipe","slug":"Pipe","permalink":"http://hgko1207.github.io/tags/Pipe/"},{"name":"파이프","slug":"파이프","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84/"}]},{"title":"[Angular] 데코레이터(Decorator) 소개 및 사용방법(2)","slug":"angular-27","date":"2023-10-31T02:32:38.000Z","updated":"2024-01-12T13:21:46.390Z","comments":true,"path":"2023/10/31/angular-27/","link":"","permalink":"http://hgko1207.github.io/2023/10/31/angular-27/","excerpt":"","text":"Angular Decorator는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다. 이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다. @NgModule @NgModule은 Angular 모듈을 생성하고 구성하는 데 사용되는 데코레이터입니다. Angular 모듈은 components, services, directives, pipes 등과 같은 애플리케이션의 다양한 부분을 위한 컨테이너입니다. 이는 애플리케이션의 여러 부분 간의 종속성을 구성하고 관리하는 데 사용됩니다. @NgModule 데코레이터를 사용하는 방법의 예는 다음과 같습니다. 1234567891011import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 위의 예에서는 BrowserModule과 AppComponent를 가져오고 declarations 배열에서 AppComponent를 선언합니다. 또한 bootstrap 컴포넌트를 AppComponent로 지정합니다. @NgModule 데코레이터에는 구성할 수 있는 여러 속성이 있습니다. declarations: 이 모듈에 속하는 components, directives 및 pipes의 배열입니다. imports: 이 모듈이 의존하는 모듈의 배열입니다. exports: 다른 모듈에서 사용할 수 있는 components, directives 및 pipes의 배열입니다. providers: 이 모듈에서 제공하는 서비스 배열입니다. bootstrap: 이 모듈에 의해 부트스트랩되어야 하는 주요 컴포넌트입니다. @NgModule 데코레이터를 사용하면 Angular 애플리케이션에서 모듈을 쉽게 만들고 관리할 수 있습니다. @Optional @Optional 데코레이터는 종속성을 컴포넌트나 서비스에 주입할 때 종속성을 선택적으로 허용하는 데 사용됩니다. 종속성을 찾을 수 없는 경우 injector 는 오류를 발생시키지 않고 대신 종속성에 대해 null 값을 제공합니다. 예는 다음과 같습니다. 123456789101112131415161718import &#123; Component, Optional &#125; from '@angular/core';import &#123; MyService &#125; from './my.service';@Component(&#123; selector: 'my-component', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;',&#125;)export class MyComponent &#123; constructor(@Optional() private myService: MyService) &#123;&#125; get message(): string &#123; if (this.myService) &#123; return this.myService.getMessage(); &#125; else &#123; return 'MyService not available.'; &#125; &#125;&#125; 이 예에서 MyService 종속성은 @Optional 데코레이터를 사용하여 선택 사항으로 표시됩니다. 서비스를 찾을 수 없으면 message() 메서드는 오류를 발생시키는 대신 기본 문자열을 반환합니다. 선택 사항으로 표시된 종속성이 실제로 컴포넌트나 서비스의 올바른 작동을 위해 필요한 경우 @Optional 데코레이터를 사용해서는 안 된다는 점에 유의하는 것이 중요합니다. 대신 종속성을 필수로 표시하고 적절한 오류 처리를 구현해야 합니다. @Self @Self 데코레이터는 종속성 해결 범위를 현재 컴포넌트 또는 디렉티브 인스턴스로 제한하는 데 사용됩니다. 즉, Angular는 컴포넌트나 디렉티브의 자체 인젝터에서만 종속성을 찾고 상위 인젝터에서는 찾지 않습니다. @Self를 사용하는 방법의 예는 다음과 같습니다. 1234567891011121314151617import &#123; Component, OnInit, Self &#125; from '@angular/core';import &#123; MyService &#125; from './my-service';@Component(&#123; selector: 'my-component', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;', providers: [MyService],&#125;)export class MyComponent implements OnInit &#123; message: string; constructor(@Self() private myService: MyService) &#123;&#125; ngOnInit() &#123; this.message = this.myService.getMessage(); &#125;&#125; 이 예에서는 @Self 데코레이터를 사용하여 MyService 종속성을 MyComponent 컴포넌트에 주입합니다. MyService 종속성은 컴포넌트 수준에서 정의됩니다. 즉, 현재 컴포넌트에만 사용할 수 있고 상위 컴포넌트에는 사용할 수 없습니다. MyService 종속성이 AppModule 또는 상위 컴포넌트와 같이 더 높은 수준에서 정의된 경우 Angular는 이를 찾을 때까지 현재 컴포넌트의 인젝터, 그 다음 상위 인젝터 등에서 이를 찾습니다. 그러나 @Self데코레이터를 사용하면 종속성 해결 범위를 현재 컴포넌트로만 제한합니다. 요약하자면, @Self 데코레이터는 상위 컴포넌트나 디렉티브가 아닌 현재 컴포넌트나 디렉티브의 컨텍스트 내에서만 종속성을 확인하는 데 사용됩니다. @SkipSelf @SkipSelf 데코레이터는 Angular에서 컴포넌트 계층 내 서비스의 가시성과 주입을 제어하는 데 사용됩니다. 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 이를 찾기 시작하고 요청된 서비스를 찾거나 트리 상단에 도달할 때까지 인젝터 트리를 탐색합니다. 기본적으로 컴포넌트나 디렉티브가 서비스를 요청하면 Angular는 현재 인젝터에서 해당 서비스를 찾습니다. 즉, 컴포넌트와 모든 하위 컴포넌트에서 서비스를 사용할 수 있다는 뜻입니다. 그러나 어떤 경우에는 현재 인젝터를 건너뛰고 상위 인젝터에서 서비스를 찾을 수 있습니다. 이는 서비스가 동일한 상위를 가진 여러 컴포넌트 간에 공유된다는 의미입니다. @SkipSelf 데코레이터는 Angular에게 현재 인젝터를 건너뛰고 상위 인젝터에서 요청된 서비스를 찾도록 지시하는 데 사용됩니다. 이는 상위가 동일하지만 서로 직접적으로 관련되지 않은 여러 컴포넌트 간에 서비스를 공유하려는 경우에 유용합니다. @SkipSelf 데코레이터를 사용하는 방법의 예는 다음과 같습니다. 123456789101112131415import &#123; Component, Inject, SkipSelf &#125; from '@angular/core';import &#123; MyService &#125; from './my.service';@Component(&#123; selector: 'my-child-component', template: ` &lt;p&gt;My Child Component&lt;/p&gt; `, providers: [&#123; provide: MyService, useValue: &#123; message: 'Hello from child component!' &#125; &#125;],&#125;)export class MyChildComponent &#123; constructor(@SkipSelf() private myService: MyService) &#123;&#125; ngOnInit() &#123; console.log(this.myService.message); // Output: \"Hello from parent component!\" &#125;&#125; 이 예에서 MyChildComponent는 @SkipSelf 데코레이터를 사용하여 상위 인젝터에서 MyService를 요청합니다. 상위 컴포넌트는 providers 배열을 사용하여 MyService를 제공합니다. 이는 모든 하위 컴포넌트에서 서비스를 사용할 수 있음을 의미합니다. MyChildComponent가 초기화되면 상위 컴포넌트의 메시지를 기록합니다. 전반적으로 @SkipSelf 데코레이터는 동일한 부모를 가진 여러 컴포넌트 간에 서비스를 공유하고 동일한 컴포넌트 계층 내에서 동일한 서비스를 여러 번 주입하지 않으려는 경우에 유용합니다. @ViewChild @ViewChild 데코레이터는 컴포넌트의 템플릿 보기에서 element 또는 컴포넌트의 참조를 가져오는 데 사용됩니다. 하위 컴포넌트 또는 상위 컴포넌트에 있는 element의 속성 및 메서드에 액세스하는 데 사용할 수 있습니다. @ViewChild와 함께 사용할 수 있는 selectors에는 두 가지 유형이 있습니다. Component Selector가 사용되면 @ViewChild는 컴포넌트 인스턴스에 대한 참조를 반환합니다. 다음은 Component Selector와 함께 @ViewChild를 사용하는 예입니다. 1234567891011121314import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; ChildComponent &#125; from './child.component';@Component(&#123; selector: 'parent-component', template: '&lt;child-component&gt;&lt;/child-component&gt;',&#125;)export class ParentComponent &#123; @ViewChild(ChildComponent) childComponentRef: ChildComponent; ngAfterViewInit() &#123; this.childComponentRef.doSomething(); &#125;&#125; 이 예제에서는 @ViewChild를 사용하여 ChildComponent 인스턴스에 대한 참조를 가져온 다음 doSomething 메서드를 호출하는 데 사용합니다. 템플릿 참조 변수(Template Reference Variable): 템플릿 참조 변수가 사용되면 @ViewChild는 해당 변수와 연결된 요소 또는 컴포넌트에 대한 참조를 반환합니다. 다음은 템플릿 참조 변수와 함께 @ViewChild를 사용하는 예입니다. 1&lt;child-component #child&gt;&lt;/child-component&gt; 1234567891011121314import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; ChildComponent &#125; from './child.component';@Component(&#123; selector: 'parent-component', template: '&lt;child-component #child&gt;&lt;/child-component&gt;',&#125;)export class ParentComponent &#123; @ViewChild('child') childComponentRef: ChildComponent; ngAfterViewInit() &#123; this.childComponentRef.doSomething(); &#125;&#125; 이 예에서 @ViewChild는 템플릿 참조 변수 #child를 사용하여 ChildComponent 인스턴스에 대한 참조를 가져오는 데 사용됩니다. @ViewChild는 하위 컴포넌트가 상위 컴포넌트보다 먼저 렌더링되는 경우에만 작동한다는 점에 유의하는 것이 중요합니다. 상위 컴포넌트가 렌더링되기 전에 하위 컴포넌트에 액세스하려고 하면 결과가 정의되지 않습니다. 이를 방지하려면 ngAfterViewInit() 생명주기 훅 메소드를 사용하여 @ViewChild로 액세스를 시도하기 전에 하위 컴포넌트가 렌더링되었는지 확인할 수 있습니다. @ViewChildren @ViewChildren 데코레이터는 컴포넌트 또는 디렉티브의 템플릿에서 selector와 일치하는 요소의 QueryList를 가져오는 데 사용됩니다. 다음은 @ViewChildren을 사용하여 특정 디렉티브가 있는 하위 요소의 QueryList를 가져오는 방법에 대한 예입니다. 12345678910111213141516171819202122232425import &#123; Component, Directive, ViewChildren &#125; from '@angular/core';@Directive(&#123; selector: '[myDirective]',&#125;)export class MyDirective &#123;&#125;@Component(&#123; selector: 'my-component', template: ` &lt;div myDirective&gt;&lt;/div&gt; &lt;div myDirective&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; `,&#125;)export class MyComponent &#123; @ViewChildren(MyDirective) myDirectives: QueryList&lt;MyDirective&gt;; ngAfterViewInit() &#123; // Access the elements with MyDirective this.myDirectives.forEach((directive) =&gt; &#123; console.log(directive); &#125;); &#125;&#125; 이 예에서는 @ViewChildren을 사용하여 MyComponent 템플릿의 MyDirective 디렉티브가 있는 요소의 QueryList를 가져옵니다. ngAfterViewInit 생명주기 훅 메소드는 요소에 액세스하고 이를 콘솔에 기록하는 데 사용됩니다. @ViewChildren 데코레이터는 템플릿의 요소와 일치하도록 디렉티브 유형 대신 문자열 selector를 사용할 수도 있습니다. 결론 이러한 데코레이터를 적절하게 사용하면 Angular 컴포넌트, 디렉티브 및 서비스의 기능을 향상하고 필요한 상용구 코드의 양을 줄일 수 있습니다. 각 데코레이터는 고유한 목적을 수행하며 사용법을 익히면 강력하고 효율적인 Angular 애플리케이션을 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular] 데코레이터(Decorator) 소개 및 사용방법(1)","slug":"angular-26","date":"2023-10-30T03:24:03.000Z","updated":"2024-01-12T08:30:30.068Z","comments":true,"path":"2023/10/30/angular-26/","link":"","permalink":"http://hgko1207.github.io/2023/10/30/angular-26/","excerpt":"","text":"Angular Decorator는 Angular 애플리케이션 구축의 기본 측면입니다. 이는 Angular에 처리 및 사용 방법을 알려주는 메타데이터를 제공하여 클래스, 속성, 메서드 및 매개 변수의 동작을 향상시키는 데 사용됩니다. 이 글에서는 Angular의 다양한 데코레이터 유형을 살펴보고 이를 효과적으로 사용하는 시기와 방법을 알아봅니다. @Component @Component 데코레이터는 Angular에서 새 컴포넌트(Component)를 정의하는 데 사용됩니다. selector, template, styles 등과 같은 컴포넌트에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 12345@Component(&#123; selector: 'app-my-component', template: '&lt;h1&gt;Hello World!&lt;/h1&gt;',&#125;)export class MyComponent &#123;&#125; @Directive @Directive 데코레이터는 Angular에서 새로운 디렉티브(Directive)을 만드는 데 사용됩니다. selector, inputs, outputs 등과 같은 지시어에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 123456@Directive(&#123; selector: '[appMyDirective]',&#125;)export class MyDirective &#123; @Input() appMyDirective: string;&#125; @Injectable @Injectable 데코레이터는 Angular에서 새로운 서비스를 정의하는 데 사용됩니다. dependencies, scope 등과 같은 서비스에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 1234@Injectable(&#123; providedIn: 'root',&#125;)export class MyService &#123;&#125; @Pipe @Pipe 데코레이터는 Angular에서 새 파이프를 만드는 데 사용됩니다. name, pureness 등과 같은 파이프에 대한 메타데이터를 제공하는 데 사용됩니다. 구성 개체를 매개 변수로 사용하는 클래스 데코레이터입니다. 123456789@Pipe(&#123; name: 'myPipe', pure: true,&#125;)export class MyPipe implements PipeTransform &#123; transform(value: any): any &#123; return value.toUpperCase(); &#125;&#125; @Input @Input 데코레이터는 컴포넌트나 디렉티브에서 입력 속성을 정의하는 데 사용됩니다. name, type 등 입력에 대한 메타데이터를 제공하는 데 사용됩니다. 입력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다. 1234567@Component(&#123; selector: 'app-my-component', template: '&lt;h1&gt;&#123;&#123;myInput&#125;&#125;&lt;/h1&gt;',&#125;)export class MyComponent &#123; @Input() myInput: string;&#125; @Output @Output 데코레이터는 컴포넌트나 디렉티브에서 출력 속성을 정의하는 데 사용됩니다. name, type 등 출력에 대한 메타데이터를 제공하는 데 사용됩니다. 출력 속성의 이름을 지정하는 선택적 매개 변수를 사용하는 속성 데코레이터입니다. 1234567891011@Component(&#123; selector: 'app-my-component', template: '&lt;button (click)=\"onClick()\"&gt;Click Me&lt;/button&gt;',&#125;)export class MyComponent &#123; @Output() myOutput: EventEmitter&lt;any&gt; = new EventEmitter(); onClick() &#123; this.myOutput.emit(); &#125;&#125; @HostBinding @HostBinding 데코레이터는 디렉티브이나 컴포넌트의 host element 속성을 디렉티브이나 컴포넌트 클래스의 속성에 바인딩하는 데 사용됩니다. 바인딩할 host 속성의 이름을 지정하는 매개변수를 받는 속성 데코레이터입니다. 123456789101112131415161718@Directive(&#123; selector: '[appHighlight]',&#125;)export class HighlightDirective &#123; @Input('appHighlight') isHighlighted: boolean; @HostBinding('style.backgroundColor') backgroundColor: string; constructor() &#123;&#125; ngOnChanges() &#123; if (this.isHighlighted) &#123; this.backgroundColor = 'blue'; &#125; else &#123; this.backgroundColor = 'transparent'; &#125; &#125;&#125; 이 예에서 @HostBinding 데코레이터는 디렉티브의 backgroundColor 속성을 호스트 요소의 style.BackgroundColor 속성에 바인딩하는 데 사용됩니다. 이는 isHighlighted 입력이 변경되면 그에 따라 backgroundColor 속성이 업데이트된다는 의미입니다. @HostBinding 데코레이터를 사용하여 클래스 이름과 같은 호스트 요소의 다른 속성을 바인딩할 수도 있습니다. 1234567@Directive(&#123; selector: '[appButton]',&#125;)export class ButtonDirective &#123; @HostBinding('class.btn') isButton = true; @HostBinding('class.btn-primary') isPrimary = true;&#125; 이 예에서 @HostBinding 데코레이터는 isButton 속성을 호스트 요소의 btn 클래스에 바인딩하고 isPrimary 속성을 호스트 요소의 btn-primary 클래스에 바인딩하는 데 사용됩니다. 이 지시어는 모든 요소에 사용되어 부트스트랩 스타일 버튼 모양을 제공할 수 있습니다. @HostBinding을 다른 지시어 및 서비스와 함께 사용하면 Angular 애플리케이션에서 복잡하고 동적인 UI 요소를 쉽게 생성할 수 있습니다. @Attribute @Attribute 데코레이터는 호스트 요소의 속성 값을 디렉티브에 삽입하는 데 사용됩니다. 이 데코레이터는 HTML 요소에서 값을 가져와 디렉티브에 사용해야 할 때 사용됩니다. @Attribute를 사용하는 방법의 예는 다음과 같습니다. 12345678910111213import &#123; Directive, Input, Attribute &#125; from '@angular/core';@Directive(&#123; selector: '[myDirective]',&#125;)export class MyDirective &#123; @Input() myInput: string; myAttribute: string; constructor(@Attribute('my-attribute') myAttribute: string) &#123; this.myAttribute = myAttribute; &#125;&#125; 이 예에서 @Attribute 데코레이터는 호스트 요소의 my-attribute 속성 값을 디렉티브의 myAttribute 속성에 삽입하는 데 사용됩니다. 속성 값은 문자열로 삽입되므로 다른 형식의 값이 필요한 경우 추가 구문 분석이나 유형 변환을 수행해야 할 수도 있습니다. @Attribute 데코레이터는 HTML 요소에서 값을 가져와 디렉티브 로직에 사용해야 할 때 유용할 수 있습니다. 그러나 이 접근 방식은 앱의 HTML 구조가 변경되면 취약한 코드로 이어질 수 있다는 점을 명심하는 것이 중요합니다. @ContentChild @ContentChild 데코레이터를 사용하면 컴포넌트가 해당 콘텐츠에 투영되는 디렉티브 또는 컴포넌트의 단일 인스턴스를 쿼리 할 수 있습니다. 사용 @ContentChild 데코레이터는 두 가지 방법으로 사용할 수 있습니다. 유형별로 디렉티브나 컴포넌트를 쿼리합니다. 12@ContentChild(MyDirective) myDirective!: MyDirective;@ContentChild(MyComponent) myComponent!: MyComponent; 템플릿 참조 변수로 디렉티브나 컴포넌트를 쿼리합니다. 1&lt;my-component #myComponentRef&gt;&lt;/my-component&gt; 1@ContentChild('myComponentRef', &#123; static: true &#125;) myComponent!: MyComponent; Options @ContentChild 데코레이터는 다음 속성을 가진 옵션 개체를 사용할 수 있습니다. static (boolean): 변경 감지가 실행되기 전에 쿼리를 해결할지 여부(기본값은 false). Example 다음은 @ContentChild 데코레이터를 사용하여 투영된 컴포넌트를 쿼리하는 예입니다. 123&lt;my-component&gt; &lt;my-child-component&gt;&lt;/my-child-component&gt;&lt;/my-component&gt; 1234567@Component(&#123; selector: 'my-component', template: ` &lt;ng-content&gt;&lt;/ng-content&gt; `,&#125;)export class MyComponent &#123; @ContentChild(MyChildComponent) myChildComponent!: MyChildComponent;&#125; 이 예에서 MyComponent 컴포넌트는 해당 콘텐츠에 투영되는 MyChildComponent 인스턴스를 쿼리합니다. 사용 시기 컴포넌트의 콘텐츠에 프로젝션되는 디렉티브나 컴포넌트의 단일 인스턴스를 쿼리해야 하는 경우 @ContentChild 데코레이터를 사용하세요. Notes 쿼리된 디렉티브 또는 컴포넌트의 여러 인스턴스가 콘텐츠에 프로젝션되는 경우 발견된 첫 번째 인스턴스가 반환됩니다. 쿼리된 디렉티브나 컴포넌트의 인스턴스가 콘텐츠에 프로젝션되지 않으면 쿼리는 undefined를 반환합니다. 정적 옵션이 true로 설정된 경우 변경 감지가 실행되기 전에 쿼리가 해결됩니다. 이는 ngOnInit() 또는 ngAfterViewInit()에서 쿼리된 인스턴스에 액세스해야 하는 경우 유용할 수 있습니다. @ContentChildren @ContentChildren 데코레이터는 컴포넌트 또는 디렉티브의 하위 콘텐츠를 쿼리하고 액세스하는 데 사용됩니다. 이를 통해 컴포넌트는 콘텐츠 영역에 프로젝션된 하위 컴포넌트 및 디렉티브에 액세스할 수 있습니다. 데코레이터는 두 가지 인수를 사용합니다. 삽입할 디렉티브를 식별하는 selector 문자열입니다. injection에 대한 추가 옵션을 지정하는 선택적 구성 개체입니다. 다음은 @ContentChildren 데코레이터를 사용하여 투영된 하위 컴포넌트를 쿼리하고 액세스하는 예입니다. 1234567891011121314import &#123; Component, ContentChildren, QueryList &#125; from '@angular/core';import &#123; TabComponent &#125; from './tab.component';@Component(&#123; selector: 'app-tabs', template: ` &lt;ng-content&gt;&lt;/ng-content&gt; `,&#125;)export class TabsComponent &#123; @ContentChildren(TabComponent) tabs: QueryList&lt;TabComponent&gt;; ngAfterContentInit() &#123; console.log(this.tabs); &#125;&#125; 이 예에서 TabsComponent는 @ContentChildren 데코레이터를 사용하여 예상되는 모든 TabComponent 하위 항목을 쿼리합니다. 결과 QueryList는 컴포넌트의 tabs 속성에서 사용할 수 있습니다. ngAfterContentInit 생명주기 훅 메서드는 프로젝션된 콘텐츠가 초기화된 후 tabs 속성에 액세스하는 데 사용됩니다. 기본적으로 @ContentChildren 데코레이터는 요청된 하위 컴포넌트 또는 디렉티브가 처음으로 나타나는 경우만 반환합니다. 모든 항목을 얻으려면 read 옵션을 사용할 수 있습니다. 1@ContentChildren(TabComponent, &#123; read: ElementRef &#125;) tabs: QueryList&lt;ElementRef&gt;; 이 예제에서는 ElementRef가 읽기 토큰으로 지정되어 @ContentChildren 데코레이터가 TabComponent 대신 ElementRef를 반환하게 됩니다. 전반적으로 @ContentChildren 데코레이터는 Angular 컴포넌트 및 디렉티브의 하위 콘텐츠에 액세스하고 상호 작용하기 위한 강력한 도구입니다. @Host @Host 데코레이터는 주어진 토큰과 일치하는 가장 가까운 호스트 요소의 종속성을 주입하는 데 사용됩니다. 이는 하위 요소에 디렉티브를 적용했지만 상위 요소의 속성이나 서비스에 액세스하려는 경우에 특히 유용합니다. @Host 데코레이터의 사용 예는 다음과 같습니다. 123456789101112131415import &#123; Directive, Host, Optional &#125; from '@angular/core';import &#123; ParentDirective &#125; from './parent.directive';@Directive(&#123; selector: '[child]',&#125;)export class ChildDirective &#123; constructor(@Host() @Optional() private parentDirective?: ParentDirective) &#123;&#125; ngOnInit() &#123; if (this.parentDirective) &#123; this.parentDirective.doSomething(); &#125; &#125;&#125; 위의 예에는 ParentDirective가 적용된 요소의 하위 요소에 적용되는 child 디렉티브가 있습니다. @Host 데코레이터는 ParentDirective가 적용된 가장 가까운 호스트 요소에서 ParentDirective 인스턴스를 주입하는 데 사용됩니다. @Optional 데코레이터는 ParentDirective가 포함된 호스트 요소가 없는 경우 생성자가 오류를 발생시키지 않도록 하는 데 사용됩니다. @HostListener @HostListener 데코레이터는 디렉티브의 호스트 요소에 이벤트 리스너를 등록하는 데 사용됩니다. 이 데코레이터는 @Directive 데코레이터의 host 속성과 함께 사용됩니다. 12345678910111213import &#123; Directive, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[appMyDirective]', host: &#123; '(click)': 'onClick($event)', &#125;,&#125;)export class MyDirective &#123; onClick(event: MouseEvent) &#123; console.log('Clicked!', event); &#125;&#125; 이 예에서는 @HostListener 데코레이터가 명시적으로 사용되지 않지만 host 속성에 암시되어 있습니다. 'click' 이벤트는 (click) 구문을 사용하여 onClick() 메서드에 등록됩니다. @HostListener 데코레이터를 명시적으로 사용할 수도 있습니다. 1234567891011import &#123; Directive, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[appMyDirective]',&#125;)export class MyDirective &#123; @HostListener('click', ['$event']) onClick(event: MouseEvent) &#123; console.log('Clicked!', event); &#125;&#125; 이 예제에서는 @HostListener 데코레이터를 명시적으로 사용하여 onClick() 메서드에 'click' 이벤트를 등록합니다. '$event' 인수는 이벤트 객체를 메서드에 전달하는 데 사용됩니다. @HostListener 데코레이터는 클릭 이벤트뿐만 아니라 모든 호스트 요소 이벤트와 함께 사용할 수 있습니다. @Inject @Inject 데코레이터를 사용하면 클래스의 종속성을 해결하는 데 사용할 토큰을 지정할 수 있습니다.@Injectable 및 @InjectableProvider와 함께 사용하여 종속성에 대한 custom provider를 제공할 수 있습니다. 예는 다음과 같습니다. 12345678import &#123; Injectable, Inject &#125; from '@angular/core';import &#123; ConfigService &#125; from './config.service';import &#123; AppConfig &#125; from './app.config';@Injectable()export class MyService &#123; constructor(@Inject(ConfigService) private config: AppConfig) &#123;&#125;&#125; 이 예에서는 ConfigService 토큰과 함께 @Inject 데코레이터를 사용하여 ConfigService 인스턴스를 MyService에 주입합니다. 이는 Angular가 ConfigService 공급자를 사용하여 종속성을 해결하도록 지시합니다. 다음과 같이 문자열 토큰과 함께 @Inject 데코레이터를 사용할 수도 있습니다. 123456import &#123; Injectable, Inject &#125; from '@angular/core';@Injectable()export class MyService &#123; constructor(@Inject('MY_CONFIG') private config: any) &#123;&#125;&#125; 이 예에서는 'MY_CONFIG' 토큰과 함께 값을 주입합니다. 원하는 문자열 토큰을 사용할 수 있지만 오타를 방지하려면 상수 값을 사용하는 것이 가장 좋습니다. 전반적으로 @Inject 데코레이터는 애플리케이션의 종속성 주입 동작을 커스터 마이징할 수 있는 강력한 도구입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"}]},{"title":"[Angular] ViewRef: 뷰(View) 변경 감지 및 업데이트 알아보기","slug":"angular-25","date":"2023-10-26T02:43:28.000Z","updated":"2024-01-12T08:29:13.962Z","comments":true,"path":"2023/10/26/angular-25/","link":"","permalink":"http://hgko1207.github.io/2023/10/26/angular-25/","excerpt":"","text":"Angular는 개발자가 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있는 강력한 프런트 엔드 프레임워크입니다. Angular의 주요 기능 중 하나는 데이터가 변경될 때마다 뷰를 자동으로 업데이트하는 변경 감지 시스템입니다. 이 글에서는 Angular의 ViewRef 클래스에 대해 자세히 알아보고 이 클래스를 사용하여 변경 감지 프로세스 및 뷰 업데이트를 제어하는 방법을 살펴보겠습니다. Angular의 변경 감지 이해 변경 감지는 뷰가 항상 데이터와 함께 최신 상태를 유지하도록 보장하므로 Angular 프레임워크의 중요한 부분입니다. Angular는 데이터 변경 사항을 자동으로 추적하고 그에 따라 뷰를 업데이트하는 영역 기반 변경 감지 시스템을 사용합니다. 이 변경 감지 프로세스는 사용자 입력이나 데이터 업데이트 등 애플리케이션에서 이벤트가 발생할 때마다 트리거 됩니다. 자동 변경 감지 프로세스 외에도 Angular는 개발자에게 ViewRef 클래스를 사용하여 수동 변경 감지를 트리거하는 기능도 제공합니다. ViewRef 클래스는 컴포넌트의 뷰에 대한 참조이며 보기와 상호 작용하고 변경 감지 프로세스를 제어하는 데 사용할 수 있습니다. ViewRef 클래스 이해 ViewRef 클래스는 Angular 변경 감지 시스템의 핵심 컴포넌트입니다. 이는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공합니다. ViewRef 클래스에는 개발자가 뷰를 관리하는 데 사용할 수 있는 몇 가지 주요 메서드와 속성이 있습니다. discoverChanges(): 이 메서드는 뷰에 대한 변경 감지 프로세스를 트리거합니다. 이는 Angular에게 데이터 변경 사항을 확인하고 그에 따라 뷰를 업데이트하도록 지시합니다. markForCheck(): 이 메서드는 Angular가 다음 변경 감지 주기 동안 변경 사항을 확인하도록 뷰에 표시합니다. detach(): 이 메서드는 변경 감지 시스템에서 뷰를 분리합니다. 이는 변경 감지를 트리거하지 않고 뷰를 수동으로 업데이트하려는 상황에서 유용할 수 있습니다. destroy(): 이 메서드는 뷰를 파괴하고 DOM에서 제거합니다. ViewRef를 사용하여 변경 감지 제어 ViewRef 클래스는 개발자에게 Angular의 변경 감지 프로세스를 제어하는 방법을 제공합니다. detectorChanges() 메서드를 사용하면 개발자가 수동으로 변경 감지를 트리거하고 뷰를 업데이트할 수 있습니다. 이는 사용자 입력을 기반으로 뷰를 업데이트하는 경우와 같이 자동 변경 감지 시스템이 충분하지 않은 상황에서 유용할 수 있습니다. 변경 감지를 수동으로 트리거하는 것 외에도 개발자는 markForCheck() 메서드를 사용하여 변경 감지 프로세스를 최적화할 수도 있습니다. 이 메서드가 호출되면 Angular는 전체 컴포넌트 트리를 확인하는 대신 뷰와 해당 하위 항목의 변경 사항만 확인합니다. 이는 대규모 애플리케이션의 성능을 크게 향상시킬 수 있습니다. 예제 다음은 Angular에서 ViewRef를 사용하기 위한 몇 가지 코드 예제입니다. 예 1) 현재 컴포넌트의 뷰에 대한 참조 가져오기 1234567891011121314import &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `,&#125;)export class AppComponent implements AfterViewInit &#123; @ViewChild('header', &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef; ngAfterViewInit() &#123; const viewRef = this.headerRef['_view']; console.log(viewRef); &#125;&#125; 예 2) 동적으로 뷰를 생성하고 컴포넌트에 연결 123456789101112131415161718192021222324252627import &#123; Component, OnInit, ViewContainerRef, ViewChild, ComponentFactoryResolver &#125; from '@angular/core';import &#123; ViewRef &#125; from '@angular/core';import &#123; CustomComponent &#125; from './custom.component';@Component(&#123; selector: 'app-root', template: ` &lt;div #container&gt;&lt;/div&gt; `,&#125;)export class AppComponent implements OnInit &#123; @ViewChild('container', &#123; read: ViewContainerRef &#125;) containerRef: ViewContainerRef; constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125; ngOnInit() &#123; // Create a reference to the custom component factory const customComponentFactory = this.componentFactoryResolver.resolveComponentFactory(CustomComponent); // Create a new instance of the custom component and attach it to the view const customComponentRef = customComponentFactory.create(this.containerRef.injector); this.containerRef.insert(customComponentRef.hostView); // Get a reference to the newly created view const viewRef = customComponentRef.hostView as ViewRef; console.log(viewRef); &#125;&#125; 예 3) 컴포넌트에서 뷰 분리 123456789101112131415161718192021import &#123; Component, ViewChild, ViewContainerRef, AfterViewInit &#125; from '@angular/core';import &#123; ViewRef &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1 #header&gt;Hello, World!&lt;/h1&gt; `,&#125;)export class AppComponent implements AfterViewInit &#123; @ViewChild('header', &#123; read: ViewContainerRef &#125;) headerRef: ViewContainerRef; ngAfterViewInit() &#123; const viewRef = this.headerRef['_view']; console.log(viewRef); // Detach the view from the component viewRef.detach(); // Check if the view is still attached to the component console.log(viewRef['_attached']); &#125;&#125; 결론 결론적으로 ViewRef 클래스는 개발자에게 뷰와 상호 작용하고 변경 감지 프로세스를 제어할 수 있는 방법을 제공하는 Angular 프레임워크의 강력한 도구입니다. ViewRef 클래스를 사용하여 개발자는 수동으로 변경 감지를 트리거하고, 변경 감지 프로세스를 최적화하고, View 생명 주기를 제어할 수 있습니다. ViewRef 클래스를 사용하는 방법을 이해하는 것은 복잡하고 반응성이 뛰어난 Angular 애플리케이션을 개발하는 데 필수적인 부분입니다. 이 글에 설명된 모범 사례를 따르면 ViewRef 클래스를 사용하여 변경 감지 프로세스를 최적화하고 뷰를 최신 데이터로 최신 상태로 유지할 수 있습니다. Angular의 변경 감지 시스템을 손쉽게 활용하면 원활한 사용자 경험을 제공하는 동적이고 반응성이 뛰어난 애플리케이션을 구축할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"ViewRef","slug":"ViewRef","permalink":"http://hgko1207.github.io/tags/ViewRef/"},{"name":"뷰","slug":"뷰","permalink":"http://hgko1207.github.io/tags/%EB%B7%B0/"}]},{"title":"[Angular] ViewEncapsulation: 다양한 모드 및 사용 방법 알아보기","slug":"angular-24","date":"2023-10-25T05:35:34.000Z","updated":"2023-12-11T04:28:52.307Z","comments":true,"path":"2023/10/25/angular-24/","link":"","permalink":"http://hgko1207.github.io/2023/10/25/angular-24/","excerpt":"","text":"Angular는 개발자에게 ViewEncapsulation을 포함하여 컴포넌트를 빌드하고 스타일을 지정할 수 있는 여러 도구를 제공합니다. 이 글에서는 ViewEncapsulation이 무엇인지, ViewEncapsulation이 제공하는 다양한 모드와 각 모드를 언제 사용하는지 살펴보겠습니다. ViewEncapsulation 이란 ViewEncapsulation은 컴포넌트의 스타일을 캡슐화하는 Angular 기능입니다. 즉, 원치 않는 스타일 충돌을 방지하기 위해 컴포넌트의 스타일을 애플리케이션의 다른 부분과 분리합니다. 또한 ViewEncapsulation을 사용하면 컴포넌트가 다른 컴포넌트에 영향을 주지 않는 자체 비공개 스타일을 가질 수 있습니다. Angular는 Emulated, None 및 Shadow DOM의 세 가지 ViewEncapsulation 모드를 제공합니다. 각 모드를 자세히 살펴보고 각 모드를 언제 사용해야 하는지 알아보겠습니다. Emulated Emulated는 Angular의 기본 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 스타일 범위를 해당 요소에만 적용하기 위해 컴포넌트의 HTML 요소에 고유한 속성을 추가합니다. 예는 다음과 같습니다. 123456789101112@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ],&#125;)export class ExampleComponent &#123;&#125; Emulated 모드에서 Angular는 위 컴포넌트의 HTML과 CSS를 다음과 같이 변환합니다. 123&lt;app-example _ngcontent-abc&gt; &lt;h1 _ngcontent-abc&gt;Hello World!&lt;/h1&gt;&lt;/app-example&gt; 123h1[_ngcontent-abc] &#123; color: red;&#125; h1 요소의 스타일 범위를 해당 컴포넌트로만 지정하는 _ngcontent-abc 속성이 추가되었습니다. 컴포넌트의 스타일을 캡슐화하고 원치 않는 스타일 충돌을 방지하려면 Emulated 모드를 사용하십시오. None None은 캡슐화를 완전히 제거하는 Angular의 또 다른 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 컴포넌트의 HTML 요소에 속성을 추가하지 않으므로 스타일이 컴포넌트 밖으로 누출되어 애플리케이션의 다른 부분에 영향을 미칠 수 있습니다. 예는 다음과 같습니다. 12345678910111213@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ], encapsulation: ViewEncapsulation.None,&#125;)export class ExampleComponent &#123;&#125; None 모드에서 Angular는 컴포넌트의 HTML과 CSS를 어떤 방식으로든 변환하지 않습니다. 전역 스타일을 적용해야 하거나 다른 컴포넌트의 스타일을 재정의하려는 경우 None 모드를 사용하세요. Shadow DOM Shadow DOM은 Angular의 최종 ViewEncapsulation 모드입니다. 이 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 스타일을 캡슐화합니다. Shadow DOM은 컴포넌트의 HTML 및 CSS에 대해 별도의 DOM 트리를 생성하여 컴포넌트의 스타일을 애플리케이션의 다른 부분과 격리합니다. 예는 다음과 같습니다. 12345678910111213@Component(&#123; selector: 'app-example', template: ` &lt;h1&gt;Hello World!&lt;/h1&gt; `, styles: [ ` h1 &#123; color: red; &#125; `, ], encapsulation: ViewEncapsulation.ShadowDom,&#125;)export class ExampleComponent &#123;&#125; Shadow DOM 모드에서 Angular는 브라우저의 기본 Shadow DOM을 사용하여 컴포넌트의 HTML 및 CSS에 대한 별도의 DOM 트리를 생성합니다. 최고 수준의 캡슐화를 원하고 컴포넌트 스타일이 애플리케이션의 나머지 부분에 영향을 받는 것을 원하지 않을 때 Shadow DOM 모드를 사용하세요. 결론 Angular의 ViewEncapsulation을 이해하면 재사용 및 유지 관리가 가능한 컴포넌트를 만드는 능력이 크게 향상될 수 있습니다. ViewEncapsulation을 적절하게 사용하면 컴포넌트 간의 스타일 및 레이아웃 충돌을 방지하고 일관된 사용자 인터페이스를 유지할 수 있습니다. Emulated, Native 또는 None ViewEncapsulation 중 무엇을 사용하든 각 옵션과 관련된 장단점을 염두에 두고 프로젝트 요구 사항에 가장 적합한 옵션을 선택하는 것이 중요합니다. 전반적으로 ViewEncapsulation은 간과해서는 안 되는 Angular 개발의 중요한 측면입니다. 모범 사례를 따르고 정보에 입각한 결정을 내리면 확장 가능하고 유지 관리 가능한 고품질 Angular 애플리케이션을 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"ViewEncapsulation","slug":"ViewEncapsulation","permalink":"http://hgko1207.github.io/tags/ViewEncapsulation/"},{"name":"캡슐화","slug":"캡슐화","permalink":"http://hgko1207.github.io/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"}]},{"title":"[Angular] 생명주기(Lifecycle) 와 훅(Hook) 메서드 이해","slug":"angular-23","date":"2023-10-24T02:00:01.000Z","updated":"2024-01-12T08:28:29.764Z","comments":true,"path":"2023/10/24/angular-23/","link":"","permalink":"http://hgko1207.github.io/2023/10/24/angular-23/","excerpt":"","text":"Angular는 개발자가 동적이고 반응성이 뛰어난 웹 애플리케이션을 구축할 수 있는 강력한 프레임워크입니다. Angular의 주요 기능 중 하나는 각 컴포넌트가 고유한 생명주기(Lifecycle)를 갖는 컴포넌트 기반 아키텍처입니다. 이러한 생명주기를 이해하는 것은 효율적이고 성능이 뛰어난 애플리케이션을 구축하는 데 중요합니다. 이 글에서는 Angular에서 사용할 수 있는 다양한 생명주기 훅(Hook) 메서드와 차이점, 그리고 이를 사용하는 모범 사례를 살펴보겠습니다. 생명주기 훅 메서드이란 무엇입니까? Angular 생명주기 훅 메서드는 컴포넌트 생명 주기 중 특정 지점에서 호출되는 메서드입니다. 이러한 훅 메서드를 사용하면 컴포넌트(component)의 초기화, 생성 및 삭제와 같은 특정 시점에 작업을 수행할 수 있습니다. Angular에는 8개의 생명주기 메서드가 있습니다. ngOnChanges(): 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다. ngOnInit(): 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다. ngDoCheck(): 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다. ngAfterContentInit(): 컴포넌트의 콘텐츠가 해당 뷰에 투영된 후에 호출됩니다. ngAfterContentChecked(): 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다. ngAfterViewInit(): 컴포넌트의 뷰가 초기화된 후에 호출됩니다. ngAfterViewChecked(): 컴포넌트 뷰를 확인할 때마다 호출됩니다. ngOnDestroy(): 컴포넌트가 파괴되기 직전에 호출됩니다. 이러한 각 메서드는 컴포넌트 생명 주기에서 특정 목적을 수행하므로 특정 시점에 작업을 수행할 수 있습니다. 차이점 이러한 생명 주기 훅 메서드 간의 몇 가지 차이점을 자세히 살펴보겠습니다. ngOnChanges() vs ngOnInit() ngOnChanges() 메서드는 컴포넌트의 입력 속성 중 하나 이상이 변경될 때 호출됩니다. 컴포넌트 입력 데이터의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. 반면에 ngOnInit()은 컴포넌트의 입력 속성이 초기화된 후 컴포넌트가 표시되기 전에 호출됩니다. 초기화 작업을 수행하거나 서비스에서 데이터를 검색해야 할 때 유용합니다. ngDoCheck() vs ngAfterContentChecked() ngDoCheck() 메서드는 모든 변경 감지 주기 동안 호출되므로 변경 사항을 감지하고 그에 따라 조치를 취할 수 있습니다. 사용자 정의(Custom) 변경 감지를 수행해야 하거나 사용자 정의 변경 감지 전략을 구현해야 할 때 유용합니다. 반면에 ngAfterContentChecked()는 컴포넌트의 콘텐츠를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 콘텐츠의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. ngAfterViewInit() vs ngAfterViewChecked() ngAfterViewInit() 메서드는 컴포넌트의 뷰가 초기화된 후에 호출됩니다. 컴포넌트의 뷰에 액세스해야 하는 초기화 작업을 수행해야 할 때 유용합니다. 반면에 ngAfterViewChecked()는 컴포넌트 뷰를 확인할 때마다 호출됩니다. 뷰 업데이트와 같이 컴포넌트 뷰의 변경 사항에 따라 작업을 수행해야 할 때 유용합니다. 모범사례 ngOnInit() 메서드에서 복잡한 논리를 피하십시오. 컴포넌트 속성을 초기화하고 기본 설정 작업을 수행하는 데에만 사용해야 합니다. 더 복잡한 로직을 수행해야 하는 경우 별도의 서비스나 기능으로 이동하는 것을 고려해 보세요. 반응형 입력 처리를 위해 ngOnChanges()를 사용하세요. 입력 속성에 대한 변경 사항을 처리하기 위해 특별히 설계되었습니다. 이를 사용하여 컴포넌트 상태를 업데이트하거나 입력 값의 변경 사항에 따라 다른 작업을 수행합니다. DOM 조작을 위해 ngAfterViewInit() 메서드를 사용하세요. 뷰가 초기화된 후에 호출되며 DOM을 조작하기에 적합한 위치입니다. 이를 사용하여 이벤트 리스너를 설정하고 요소를 추가 또는 제거하거나 기타 DOM 관련 작업을 수행합니다. 정리를 위해 ngOnDestroy()를 사용하지 마세요. 컴포넌트 리소스를 정리하도록 설계되었지만 항상 신뢰할 수 있는 것은 아닙니다. 대신 서비스를 사용하거나 컴포넌트의 ngOnDestroy 이벤트를 구독하여 정리 작업을 수행하는 것을 고려해 보세요. 다음은 ngOnDestroy()에만 의존하는 대신 서비스를 사용하여 정리 작업을 수행하는 방법에 대한 예입니다. 1234567891011121314151617import &#123; Injectable &#125; from '@angular/core';import &#123; Subscription &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class CleanupService &#123; private subscriptions: Subscription[] = []; addSubscription(subscription: Subscription): void &#123; this.subscriptions.push(subscription); &#125; cleanup(): void &#123; this.subscriptions.forEach((subscription) =&gt; subscription.unsubscribe()); &#125;&#125; 그런 다음 컴포넌트에 CleanupService를 삽입하고 이를 사용하여 Subscription(구독)을 관리할 수 있습니다. 123456789101112131415161718192021222324252627import &#123; Component, OnInit, OnDestroy &#125; from '@angular/core';import &#123; interval, Subscription &#125; from 'rxjs';import &#123; CleanupService &#125; from './cleanup.service';@Component(&#123; selector: 'app-example', template: '&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;',&#125;)export class ExampleComponent implements OnInit, OnDestroy &#123; message: string; private subscription: Subscription; constructor(private cleanupService: CleanupService) &#123;&#125; ngOnInit(): void &#123; this.subscription = interval(1000).subscribe(() =&gt; &#123; this.message = 'Hello, world!'; &#125;); this.cleanupService.addSubscription(this.subscription); &#125; ngOnDestroy(): void &#123; // Don't use ngOnDestroy for cleanup! // Instead, use the CleanupService to perform cleanup tasks. this.cleanupService.cleanup(); &#125;&#125; 위의 예에서는 CleanupService를 사용하여 컴포넌트의 Subscription을 관리합니다. addSubscription() 메서드는 Subscription 배열에 추가하고 cleanup() 메서드는 배열의 각 Subscription에 대해 unsubscribe()를 호출합니다. 그런 다음 컴포넌트의 ngOnDestroy() 메서드에서 ngOnDestroy()에만 의존하는 대신 CleanupService를 사용하여 정리 작업을 수행합니다. 이렇게 하면 어떤 이유로 ngOnDestroy()가 호출되지 않더라도 컴포넌트의 리소스가 적절하게 정리됩니다. 이러한 사례를 따르면 일반적인 함정을 피하고 성능을 향상시키면서 컴포넌트가 현재 작업에 적합한 생명 주기를 사용하고 있는지 확인할 수 있습니다. 결론적으로, 고품질의 고성능 Angular 애플리케이션을 구축하려면 Angular 생명 주기를 이해하는 것이 중요합니다. 각 훅 메서드 간의 차이점을 살펴보고 사례를 따르면 Angular 프레임워크를 최대한 활용하고 강력하고 유지 관리가 가능한 애플리케이션을 구축할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"http://hgko1207.github.io/tags/Lifecycle/"},{"name":"생명주기","slug":"생명주기","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"},{"name":"Hook","slug":"Hook","permalink":"http://hgko1207.github.io/tags/Hook/"},{"name":"훅","slug":"훅","permalink":"http://hgko1207.github.io/tags/%ED%9B%85/"}]},{"title":"[.NET Core] 코드 예제를 통해 멀티스레딩 마스터하기","slug":"csharp-6","date":"2023-10-23T01:09:59.000Z","updated":"2023-11-10T12:32:50.178Z","comments":true,"path":"2023/10/23/csharp-6/","link":"","permalink":"http://hgko1207.github.io/2023/10/23/csharp-6/","excerpt":"","text":"C# .NET Core의 멀티스레딩과 관련하여 최적의 성능을 달성하고 일반적인 함정을 피하기 위해 명심해야 할 몇 가지 모범 사례가 있습니다. 몇 가지 코드 예제를 통해 각각에 대해 자세히 살펴보겠습니다. 과도한 잠금 방지 다중 스레드 코드로 작업할 때 흔히 저지르는 실수 중 하나는 너무 많은 잠금을 사용하는 것입니다. 여러 스레드가 동시에 액세스하지 못하도록 공유 리소스를 보호하려면 잠금이 필요하지만 과도한 잠금은 스레드 경합 및 성능 저하를 초래할 수 있습니다. 대신 필요한 경우에만 잠금을 사용하고 적절한 경우 Interlocked 작업 또는 Concurrent 컬렉션 클래스와 같은 다른 동기화 메커니즘을 사용하는 것을 고려하십시오. 12345678910private readonly object _lock = new object();private int _count;public void IncrementCount()&#123; lock (_lock) &#123; _count++; &#125;&#125; Thread-Safe 데이터 구조 사용 공유 데이터 구조로 작업할 때 데이터 손상이나 경합 조건을 방지하기 위해 thread-safe 컬렉션을 사용하는 것이 중요합니다. .NET Core 라이브러리는 스레드 간에 데이터를 안전하게 공유하는 데 사용할 수 있는 ConcurrentDictionary 및 ConcurrentQueue 와 같은 여러 스레드로부터 안전한 컬렉션을 제공합니다. 123456private readonly ConcurrentDictionary&lt;string, int&gt; _dict = new ConcurrentDictionary&lt;string, int&gt;();public void AddOrUpdateDict(string key, int value)&#123; _dict.AddOrUpdate(key, value, (k, v) =&gt; v + value);&#125; ThreadPool 사용 스레드를 만들고 관리하는 작업은 비용이 많이 들 수 있으므로 가능하면 .NET Core ThreadPool을 사용하는 것이 가장 좋습니다. ThreadPool은 재사용할 수 있는 스레드 풀을 관리하므로 스레드 생성 및 삭제에 따른 오버헤드를 줄여 성능을 향상시킬 수 있습니다. 123ThreadPool.QueueUserWorkItem((state) =&gt; &#123; // Do some work on a background thread&#125;); 교착상태 주의 교착 상태는 두 개 이상의 스레드가 서로 리소스를 해제할 때까지 기다리면서 차단되어 더 이상 진행이 불가능한 상황이 발생하는 경우에 발생합니다. 교착 상태를 방지하려면 잠금을 올바른 순서로 획득 및 해제하고 장기간 잠금을 유지하지 않는 것이 중요합니다. 1234567891011121314private readonly object _lock1 = new object();private readonly object _lock2 = new object();public void DoWork()&#123; lock (_lock1) &#123; // Do some work lock (_lock2) &#123; // Do some more work &#125; &#125;&#125; 비동기 프로그래밍 사용 비동기 프로그래밍은 다중 스레드 코드로 작업할 때 호출 스레드를 차단하지 않고 여러 작업을 동시에 수행할 수 있는 강력한 도구가 될 수 있습니다. async 및 await 키워드를 사용하면 동기적인 것처럼 보이지만 실제로는 별도의 스레드에서 비동기적으로 실행되는 코드를 작성할 수 있습니다. 12345678public async Task&lt;string&gt; DownloadAsync(string url)&#123; using (var client = new HttpClient()) &#123; var response = await client.GetAsync(url); return await response.Content.ReadAsStringAsync(); &#125;&#125; 모범 사례 이러한 모범 사례를 따르면 C# .NET Core에서 확장 가능한 고성능 다중 스레드 코드를 작성할 수 있습니다. 다음은 .NET Core의 다중 스레딩에 대한 모범 사례를 사용하는 몇 가지 실제 예입니다. 비동기식 HTTP 요청 웹 애플리케이션에서는 다른 서비스에 HTTP 요청을 보내는 것이 일반적입니다. 기본 스레드를 차단하지 않으려면 이러한 요청은 HttpClient를 사용하여 비동기적으로 이루어져야 합니다. 123456public async Task&lt;string&gt; GetApiDataAsync(string apiUrl)&#123; using var client = new HttpClient(); var response = await client.GetAsync(apiUrl); return await response.Content.ReadAsStringAsync();&#125; CPU 바인딩된 작업 병렬화 CPU 바인딩된(CPU-bound) 작업을 수행할 때 여러 스레드에 걸쳐 작업을 병렬화하여 성능을 향상시키는 것이 유용한 경우가 많습니다. .NET Core의 Parallel 클래스는 루프를 병렬화하는 쉬운 방법을 제공합니다. 123Parallel.For(0, 100000, (i) =&gt; &#123; // Perform CPU-bound work here&#125;); 경쟁 조건을 피하기 위해 잠금 사용 여러 스레드가 공유 리소스에 액세스하면 한 스레드가 리소스를 읽거나 수정하는 동안 다른 스레드도 리소스에 액세스하는 경쟁 조건이 발생할 위험이 있습니다. 이를 방지하기 위해 잠금을 사용하여 한 번에 하나의 스레드만 공유 리소스에 액세스할 수 있도록 할 수 있습니다. 12345678910private readonly object _lock = new object();private int _sharedResource = 0;public void IncrementSharedResource()&#123; lock (_lock) &#123; _sharedResource++; &#125;&#125; 메인 스레드에서 blocking 방지 UI 애플리케이션에서는 기본 스레드를 blocking하고 애플리케이션이 응답하지 않게 만드는 것을 방지하기 위해 파일 I/O 또는 데이터베이스 쿼리와 같은 blocking 작업을 백그라운드 스레드에서 수행해야 합니다. 12345678910public async Task LoadDataAsync()&#123; var data = await GetDataFromDatabaseAsync(); // Update UI with data on the main thread await Task.Run(() =&gt; &#123; // Perform file I/O or other blocking operation on a background thread &#125;); // Continue updating UI with more data on the main thread&#125; 예제 제품 정보, 가격 및 가용성에 대한 대량의 동시 요청을 처리하는 대규모 전자 상거래 웹 사이트용 애플리케이션을 구축한다고 가정해 보겠습니다. 웹사이트는 각 제품 카테고리에 대해 별도의 서비스를 제공하는 마이크로서비스 아키텍처를 사용하며, 각 서비스는 여러 클라이언트의 요청을 처리합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProductService&#123; private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(); private readonly ConcurrentDictionary&lt;int, Product&gt; _products = new ConcurrentDictionary&lt;int, Product&gt;(); public async Task&lt;Product&gt; GetProductAsync(int productId) &#123; // Use a read lock to allow multiple threads to read from the dictionary simultaneously _lock.EnterReadLock(); try &#123; if (_products.TryGetValue(productId, out Product product)) &#123; return product; &#125; else &#123; // If the product is not found in the dictionary, use a write lock to add it _lock.ExitReadLock(); _lock.EnterWriteLock(); try &#123; product = await GetProductFromServiceAsync(productId); _products.TryAdd(productId, product); return product; &#125; finally &#123; _lock.ExitWriteLock(); _lock.EnterReadLock(); &#125; &#125; &#125; finally &#123; _lock.ExitReadLock(); &#125; &#125; private async Task&lt;Product&gt; GetProductFromServiceAsync(int productId) &#123; // Use async/await to make an asynchronous API call using (HttpClient client = new HttpClient()) &#123; string url = $\"https://api.example.com/products/&#123;productId&#125;\"; HttpResponseMessage response = await client.GetAsync(url); string json = await response.Content.ReadAsStringAsync(); return JsonConvert.DeserializeObject&lt;Product&gt;(json); &#125; &#125;&#125; 이 예에서는 여러 스레드가 _products에서 동시에 읽을 수 있도록 ReaderWriterLockSlim을 사용하고 있습니다. Dictionary에 없는 제품이 요청되면 write lock을 사용하여 추가합니다. 또한 제품 데이터를 검색하기 위해 비동기 API 호출을 만들기 위해 async/await를 사용하고 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"스레드","slug":"스레드","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"}]},{"title":"Node.js, Express를 사용하여 간단한 웹 크롤러 만들기","slug":"nodejs-6","date":"2023-10-19T02:49:28.000Z","updated":"2023-12-14T14:38:53.252Z","comments":true,"path":"2023/10/19/nodejs-6/","link":"","permalink":"http://hgko1207.github.io/2023/10/19/nodejs-6/","excerpt":"","text":"스파이더라고도 알려진 웹 크롤러(Web crawler)는 인터넷을 탐색하고, 웹사이트를 방문하고, 다양한 목적으로 데이터를 추출하는 자동화된 프로그램입니다. 웹 크롤러를 구축하는 것은 복잡한 작업일 수 있지만 올바른 도구와 지침을 사용하면 보람 있는 경험이 될 수 있습니다. 이 글에서는 Node.js, Express 및 TypeScript를 사용하여 간단한 웹 크롤러를 구축하는 방법을 살펴보겠습니다. 1. 프로젝트 설정 시작하려면 새 Node.js 프로젝트를 만들고 필요한 종속성을 설치해야 합니다. 우리는 다음 패키지를 사용할 것입니다. Express — 쉽게 서버를 생성하고 HTTP 요청을 처리할 수 있게 해주는 인기 있는 Node.js 웹 프레임워크입니다. Cheerio — HTML 및 XML 문서를 탐색하고 조작할 수 있게 해주는 jQuery와 유사한 Node.js용 라이브러리입니다. Request — HTTP 요청을 쉽게 보내고 응답을 처리할 수 있게 해주는 간단한 Node.js용 HTTP 클라이언트입니다. 새 Node.js 프로젝트를 생성한 후 다음 명령을 사용하여 패키지를 설치할 수 있습니다. 1npm install express cheerio request 다음을 실행하여 TypeScript를 dev 종속성(devDependencies)으로 설치할 수도 있습니다. 1npm install -D typescript @types/node @types/express @types/cheerio @types/request 2. 서버 설정 이 섹션에서는 HTTP 요청을 수신하고 응답을 반환하는 간단한 Express 서버를 만듭니다. 또한 웹 크롤러가 크롤링을 시작할 수 있는 경로를 추가할 것입니다. 먼저 server.ts라는 새 파일을 만들고 다음 코드를 추가하겠습니다. 12345678910111213141516import express, &#123; Request, Response &#125; from 'express';const app = express();const port = 3000;app.get('/', (req: Request, res: Response) =&gt; &#123; res.send('Welcome to the Web Crawler');&#125;);app.get('/crawl', (req: Request, res: Response) =&gt; &#123; // Add code for crawling here&#125;);app.listen(port, () =&gt; &#123; console.log(`Server running on port $&#123;port&#125;`);&#125;); 이 코드는 새로운 Express 애플리케이션을 생성하고 / 및 /crawl이라는 두 가지 경로를 정의합니다. / 경로는 단순히 사용자에게 환영 메시지를 반환하는 반면 /crawl 경로는 크롤링 프로세스를 시작하는 데 사용됩니다. 3. 웹사이트 크롤링 이제 서버를 설정했으므로 웹사이트 크롤링을 시작할 수 있습니다. 이 예에서는 Google 홈페이지를 크롤링하고 페이지 제목을 추출합니다. /crawl 경로 내에 다음 코드를 추가합니다. 12345678910111213141516import request from 'request';import cheerio from 'cheerio';app.get('/crawl', (req: Request, res: Response) =&gt; &#123; const url = 'https://www.google.com'; request(url, (error, response, html) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; const $ = cheerio.load(html); const title = $('title').text(); res.send(`The title of $&#123;url&#125; is: $&#123;title&#125;`); &#125; else &#123; res.send(`Error crawling $&#123;url&#125;`); &#125; &#125;);&#125;); 이 코드는 HTTP GET 요청을 지정된 URL로 보내고 HTML 응답을 Cheerio 개체에 로드합니다. 그런 다음 Cheerio를 사용하여 페이지 제목을 추출하고 이를 사용자에게 응답으로 다시 보낼 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Express","slug":"Express","permalink":"http://hgko1207.github.io/tags/Express/"},{"name":"웹 크롤러","slug":"웹-크롤러","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC/"},{"name":"Cheerio","slug":"Cheerio","permalink":"http://hgko1207.github.io/tags/Cheerio/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"}]},{"title":"[Angular] Tree Shaking: 애플리케이션 크기 최적화","slug":"angular-22","date":"2023-10-16T07:03:12.000Z","updated":"2024-01-12T08:27:11.891Z","comments":true,"path":"2023/10/16/angular-22/","link":"","permalink":"http://hgko1207.github.io/2023/10/16/angular-22/","excerpt":"","text":"Angular는 단일 페이지 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 애플리케이션이 복잡해지면 크기도 커지며 이로 인해 로드 시간이 느려지고 성능이 저하될 수 있습니다. Angular 애플리케이션의 크기를 최적화하는 한 가지 기술은 트리 쉐이킹(Tree Shaking)을 이용하는 것입니다. 이 글에서는 트리 쉐이킹이 무엇인지, 어떻게 작동하는지, Angular 프로젝트에서 구현하는 방법을 살펴보겠습니다. 트리 쉐이킹(Tree Shaking)이란 무엇입니까? 트리 쉐이킹은 애플리케이션에서 사용되지 않는 코드를 제거하는 프로세스입니다. 코드와 해당 종속성을 분석하고 사용되지 않는 부분을 식별한 다음 안전하게 제거할 수 있는 방식으로 작동합니다. 트리 쉐이킹은 모듈과 종속성이 많은 대규모 애플리케이션에 특히 유용합니다. 트리 쉐이킹은 어떻게 작동하나요? 트리 쉐이킹은 JavaScript 모듈의 정적 특성에 의존합니다. 모듈을 임포트 하면 모듈 전체가 로드되지만 실제로 사용되는 부분만 실행됩니다. 사용되지 않은 코드는 실행되지 않으므로 최종 번들에 포함되지 않습니다. 이렇게 하면 애플리케이션의 크기가 크게 줄어들고 성능이 향상될 수 있습니다. Angular에서 트리 쉐이킹 구현 Angular 애플리케이션에서 트리 쉐이킹을 구현하려면 Webpack과 같은 이를 지원하는 빌드 도구를 사용해야 합니다. 애플리케이션을 빌드할 때 Webpack은 코드를 분석하고 사용되지 않는 코드를 제거하여 번들 크기를 더 작게 만듭니다. 지연 로딩을 사용하여 필요한 모듈만 로드하고, 전역 변수를 피하고, 실제로 사용되는 모듈 부분만 가져오는 등 Angular 개발에 대한 모범 사례를 따르면 트리 쉐이킹 프로세스에 도움이 될 수도 있습니다. 트리 쉐이킹 검증 응용 프로그램에서 트리 쉐이킹이 실제로 작동하는지 확인하는 것이 중요합니다. 트리 쉐이킹을 구현하기 전과 후에 번들로 제공되는 JavaScript 파일의 크기를 분석하여 이를 수행할 수 있습니다. 또한 사용되지 않더라도 여전히 포함되어 있는 애플리케이션 부분을 식별하려면 Webpack Bundle Analyser와 같은 도구를 사용해야 합니다. 일반적인 함정 및 팁 트리 쉐이킹을 구현할 때 흔히 발생하는 함정 중 하나는 트리 쉐이킹에 최적화되지 않은 타사 라이브러리에 너무 많이 의존한다는 것입니다. 트리 쉐이킹을 지원하는 라이브러리를 사용하거나 이 기술에 최적화된 대체 라이브러리를 사용하십시오. 또 다른 팁은 Webpack이 코드를 분석하고 트리 쉐이킹을 적절하게 적용하기 어렵게 만들 수 있는 동적 가져오기를 사용하지 않는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Tree Shaking","slug":"Tree-Shaking","permalink":"http://hgko1207.github.io/tags/Tree-Shaking/"},{"name":"트리 쉐이킹","slug":"트리-쉐이킹","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9/"}]},{"title":"[Angular] Zone.js 파일: 성능 향상을 위해 이해하고 사용하기","slug":"angular-21","date":"2023-10-08T14:01:36.000Z","updated":"2023-12-14T14:39:06.353Z","comments":true,"path":"2023/10/08/angular-21/","link":"","permalink":"http://hgko1207.github.io/2023/10/08/angular-21/","excerpt":"","text":"Angular는 가장 널리 사용되는 JavaScript 프레임워크 중 하나이며 개발을 보다 효율적으로 만들어주는 많은 도구와 기능을 갖추고 있습니다. 그러한 도구 중 하나가 개발자가 애플리케이션의 변경 사항을 추적하고 성능을 향상시키는 데 도움이 되는 라이브러리인 Zone.js입니다. 이 글에서는 Zone.js가 무엇인지, 어떻게 작동하는지, 그리고 이를 사용하여 Angular 애플리케이션을 최적화할 수 있는 방법에 대해 자세히 살펴보겠습니다. Zone.js 란 무엇입니까? Zone.js는 개발자가 애플리케이션의 변경 사항을 추적하는 데 도움이 되는 JavaScript 라이브러리입니다. 타이머, 이벤트, XHR 요청과 같은 브라우저의 API에 연결하여 이를 수행합니다. Zone.js가 설치되면 추적하려는 코드 주위에 “zone” 이 생성됩니다. 이 영역은 그 안에서 발생하는 모든 변경 사항을 추적하며 성능을 최적화하는 데 사용될 수 있습니다. Zone.js는 어떻게 작동하나요? Zone.js는 코드 주위에 &quot;zone&quot;이라고 하는 wrapper를 생성하여 작동합니다. 이 영역에는 변경 사항을 포함하여 애플리케이션 상태에 대한 정보가 포함되어 있습니다. 영역 내에서 변경 사항이 발생할 때마다 Zone.js는 이를 기록하고 그에 따라 애플리케이션을 업데이트합니다. 예를 들어, HTTP 요청을 하는 Angular 컴포넌트가 있는 경우 Zone.js는 컴포넌트의 코드 주위에 영역을 만듭니다. HTTP 요청이 이루어지면 Zone.js는 이를 추적하고 그에 따라 컴포넌트의 상태를 업데이트합니다. 성능 최적화를 위해 Zone.js 사용 Zone.js는 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키는 등 다양한 성능 최적화 작업에 사용할 수 있습니다. Zone.js를 사용하는 한 가지 방법은 HTTP 요청을 그룹화하여 HTTP 요청 수를 줄이는 것입니다. 예를 들어 zone.runOutsideAngular() 메서드를 사용하여 Angular 영역 외부에서 HTTP 요청을 실행할 수 있습니다. 이렇게 하면 요청이 Zone.js에 의해 추적되지 않고 성능 향상을 위해 다른 요청과 함께 그룹화될 수 있습니다. 성능 최적화를 위해 Zone.js를 사용하는 또 다른 방법은 애플리케이션의 응답성을 향상시키는 것입니다. zone.run() 메서드를 사용하여 영역 내에서 애플리케이션의 상태를 업데이트할 수 있습니다. 이렇게 하면 다음 변경 감지 주기를 기다리지 않고 즉시 변경이 이루어집니다. 고급 Zone.js 기술 Zone.js에는 보다 복잡한 성능 최적화 작업에 사용할 수 있는 몇 가지 고급 기능이 있습니다. 그러한 기능 중 하나는 사용자 정의 영역(custom zone)을 생성하는 기능입니다. 사용자 정의 영역을 사용하면 전체 애플리케이션이 아닌 애플리케이션의 특정 부분의 변경 사항을 추적할 수 있습니다. 또 다른 고급 기술은 Zone.js를 사용하여 변경 감지를 제어하는 ​​기능입니다. 기본적으로 Angular는 NgZone 클래스를 사용하여 변경 감지를 처리합니다. 그러나 Zone.js를 사용하여 변경 감지를 제어하고 특정 애플리케이션에 맞게 최적화할 수 있습니다. 결론 결론적으로 Zone.js는 Angular 애플리케이션의 성능 최적화를 위한 강력한 도구입니다. 코드 주위에 영역을 생성하여 변경 사항을 추적하고 그에 따라 애플리케이션을 업데이트하는 방식으로 작동합니다. Zone.js를 사용하면 HTTP 요청 수를 줄이고 애플리케이션의 응답성을 향상시키며 성능 향상을 위해 변경 감지를 제어할 수 있습니다. 이 글에서 다루는 기술을 사용하면 Zone.js를 사용하여 더 나은 성능을 위해 Angular 애플리케이션을 최적화할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Zone.js","slug":"Zone-js","permalink":"http://hgko1207.github.io/tags/Zone-js/"},{"name":"성능향상","slug":"성능향상","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"}]},{"title":"[.NET Core] RabbitMQ 사용 가이드","slug":"csharp-5","date":"2023-09-13T01:06:18.000Z","updated":"2023-11-17T06:28:00.005Z","comments":true,"path":"2023/09/13/csharp-5/","link":"","permalink":"http://hgko1207.github.io/2023/09/13/csharp-5/","excerpt":"","text":"RabbitMQ는 안정적이고 확장 가능한 메시징을 위해 최신 분산 시스템에서 널리 사용되는 오픈 소스 메시지 브로커 소프트웨어입니다. Erlang으로 작성되었으며 AMQP, MQTT, STOMP와 같은 여러 프로토콜을 지원합니다. RabbitMQ는 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다. 이 글에서는 크로스 플랫폼 웹 애플리케이션 구축을 위한 인기 있고 강력한 프레임워크인 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보겠습니다. RabbitMQ의 기본 사항, 아키텍처 및 개념, .NET Core 애플리케이션과 통합하는 방법을 다룹니다. 1. RabbitMQ란 무엇입니까? RabbitMQ는 다양한 소프트웨어 애플리케이션 간의 통신을 가능하게 하는 메시지 브로커 소프트웨어입니다. 이는 AMQP(Advanced Message Queuing Protocol)를 기반으로 하며 최신 분산 시스템을 위한 안정적이고 확장 가능한 메시징 솔루션을 제공합니다. RabbitMQ는 다양한 애플리케이션과 서비스 간의 비동기 통신을 허용합니다. 확장성이 뛰어나며 다양한 프로그래밍 언어 및 프레임워크와 통합될 수 있습니다. 2. RabbitMQ 아키텍처 및 개념 RabbitMQ는 서버가 메시지 저장 및 전달을 담당하고 클라이언트가 메시지 생성 및 소비를 담당하는 client-server 모델을 따릅니다. 이는 메시지가 대기열에 배치된 다음 클라이언트에서 사용되는 대기열 기반 모델을 사용합니다. RabbitMQ는 AMQP, MQTT, STOMP와 같은 여러 메시징 프로토콜을 지원합니다. 또한 메시지 라우팅, 메시지 확인, 메시지 지속성과 같은 고급 기능도 지원합니다. 3. RabbitMQ 서버 설치 .NET Core에서 RabbitMQ를 사용하려면 먼저 RabbitMQ 서버를 설치해야 합니다. RabbitMQ는 Windows, macOS, Linux 등 다양한 플랫폼에서 사용할 수 있습니다. Windows에 RabbitMQ를 설치하려면 공식 웹사이트에서 설치 프로그램을 다운로드하고 실행합니다. Linux에서는 패키지 관리자를 사용하여 RabbitMQ를 설치할 수 있습니다. 4. .NET Core에서 RabbitMQ 설정 .NET Core에서 RabbitMQ를 사용하려면 RabbitMQ.Client NuGet 패키지를 설치해야 합니다. 이 패키지에는 RabbitMQ와 상호 작용하는 데 필요한 클래스와 메서드가 포함되어 있습니다. 또한 RabbitMQ에 대한 연결 설정을 구성해야 합니다. 연결 설정에는 RabbitMQ 서버의 호스트 이름(hostname), 포트(port), 사용자 이름(username) 및 비밀번호(password)가 포함됩니다. 5. 메시지 Publishing 및 Consuming .NET Core 애플리케이션에서 RabbitMQ를 설정하고 나면 메시지 게시(Publishing) 및 소비(Consuming)를 시작할 수 있습니다. 메시지를 게시하려면 RabbitMQ에 대한 연결을 만든 다음 채널을 만들어야 합니다. 그런 다음 채널을 사용하여 메시지를 대기열에 게시할 수 있습니다. 메시지를 소비하려면 대기열을 수신하고 메시지를 처리하는 소비자(Consumers)를 생성해야 합니다. BasicConsume 메서드 또는 EventingBasicConsumer 클래스와 같은 다양한 메시지 소비 전략을 사용할 수 있습니다. 6. .NET Core와 함께 RabbitMQ를 사용하는 모범 사례 .NET Core와 함께 RabbitMQ를 사용할 때 최고의 성능과 안정성을 보장하려면 몇 가지 모범 사례를 따라야 합니다. 여기에는 연결 풀링 설정, 메시지 승인 사용, 메시지 재시도 구성이 포함됩니다. 또한 오류나 문제가 있는지 RabbitMQ 서버를 모니터링하고 적절한 로깅 및 오류 처리를 구성해야 합니다. 결론 RabbitMQ는 최신 분산 시스템을 위한 강력하고 안정적인 메시징 솔루션입니다. 이 글에서는 .NET Core와 함께 RabbitMQ를 사용하는 방법을 살펴보았습니다. 다음은 .NET Core에서 RabbitMQ를 사용하기 위한 몇 가지 코드 예제입니다. RabbitMQ 클라이언트 라이브러리 설치 1dotnet add package RabbitMQ.Client RabbitMQ에 연결 12345678910using RabbitMQ.Client;var factory = new ConnectionFactory() &#123; HostName = \"localhost\" &#125;;using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; // Do something with the channel &#125;&#125; 대기열 선언 1234using RabbitMQ.Client;var queueName = \"my-queue\";channel.QueueDeclare(queueName, false, false, false, null); 메시지 게시 12345678using RabbitMQ.Client;using System.Text;var queueName = \"my-queue\";var message = \"Hello, World!\";var body = Encoding.UTF8.GetBytes(message);channel.BasicPublish(\"\", queueName, null, body); 메시지 소비 1234567891011121314151617using RabbitMQ.Client;using RabbitMQ.Client.Events;using System.Text;var queueName = \"my-queue\";var consumer = new EventingBasicConsumer(channel);consumer.Received += (model, ea) =&gt;&#123; var body = ea.Body.ToArray(); var message = Encoding.UTF8.GetString(body); // Do something with the message channel.BasicAck(ea.DeliveryTag, false);&#125;;channel.BasicConsume(queueName, false, consumer); 참고: 이러한 코드 예제는 시작점일 뿐이며 특정 사용 사례에 맞게 조정해야 할 수도 있습니다. .NET Core에서 RabbitMQ를 사용하는 방법에 대한 자세한 내용은 공식 RabbitMQ 설명서를 참조하는 것이 좋습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://hgko1207.github.io/tags/RabbitMQ/"},{"name":"메시지","slug":"메시지","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%8B%9C%EC%A7%80/"}]},{"title":"OAuth와 JWT 차이점 및 사용 사례","slug":"backend-1","date":"2023-09-10T12:33:10.000Z","updated":"2024-01-12T08:26:04.177Z","comments":true,"path":"2023/09/10/backend-1/","link":"","permalink":"http://hgko1207.github.io/2023/09/10/backend-1/","excerpt":"","text":"OAuth와 JWT는 웹 애플리케이션에서 일반적으로 사용되는 두 가지 보안 메커니즘입니다. 둘 다 인증 기능을 제공하지만 접근 방식과 사용 사례가 다릅니다. 이 글에서는 OAuth와 JWT의 차이점과 각각을 언제 사용하는지 살펴보겠습니다. Section 1: OAuth OAuth는 자격 증명을 노출하지 않고 타사 애플리케이션이 사용자의 리소스에 액세스 할 수 있도록 하는 개방형 인증 표준입니다. OAuth 흐름에는 리소스 소유자(사용자), 클라이언트(애플리케이션) 및 권한 부여 서버 이 세 가지가 관련됩니다. 클라이언트는 Authorization Server를 통해 리소스 소유자에게 Authorization(권한부여)을 요청하고, 승인이 나면 클라이언트는 리소스에 접근하기 위한 Access Token을 받습니다. OAuth는 일반적으로 사용자가 Facebook 또는 Google 자격 증명을 사용하여 애플리케이션에 로그인할 수 있는 소셜 미디어 로그인에 사용됩니다. Section 2: JWT JWT(JSON Web Token)는 두 당사자 간에 전송될 클레임(claim)을 표현하는 URL 안전의 컴팩트한 수단입니다. 헤더(header), 페이로드(payload), 서명(signature)의 세 부분으로 구성됩니다. 헤더는 토큰 유형과 서명 알고리즘을 지정하고, 페이로드에는 클레임이 포함되며, 서명은 토큰의 무결성을 확인하는 데 사용됩니다. JWT는 일반적으로 사용자가 애플리케이션에 로그인하고 JWT를 응답으로 받는 인증에 사용됩니다. 그런 다음 JWT를 사용하여 애플리케이션 내의 보호된 리소스에 액세스 할 수 있습니다. Section 3: OAuth와 JWT의 차이점 OAuth와 JWT는 서로 다른 목적으로 사용되며 사용 사례도 다릅니다. OAuth는 권한부여(authorization)에 사용되고 JWT는 인증(authentication)에 사용됩니다. OAuth는 타사 애플리케이션에 리소스에 대한 액세스 권한을 부여하는 데 사용되는 반면, JWT는 애플리케이션 내의 보호된 리소스에 액세스 하는 데 사용됩니다. OAuth에는 인증 서버가 필요하지만 JWT에는 그렇지 않습니다. OAuth 흐름에는 여러 단계와 당사자가 포함되는 반면, JWT 흐름은 더 간단하고 두 당사자만 포함합니다. Section 4: OAuth를 사용해야 하는 경우 OAuth는 자격 증명을 노출하지 않고 사용자 리소스에 대한 액세스 권한을 타사 애플리케이션에 부여해야 할 때 유용합니다. 예를 들어 소셜 미디어 앱을 구축하는 경우 사용자가 Facebook 또는 Google 계정으로 로그인하도록 허용할 수 있습니다. 이 경우 OAuth를 사용하면 자격 증명을 입력하지 않고도 사용자를 인증할 수 있습니다. Section 5: JWT를 사용해야 하는 경우 JWT는 사용자를 인증하고 애플리케이션 내의 보호된 리소스에 대한 액세스 권한을 부여해야 할 때 유용합니다. 예를 들어 사용자가 로그인해야 하는 웹 애플리케이션을 구축하는 경우 JWT를 사용하여 사용자를 인증하고 애플리케이션의 특정 부분에 대한 액세스를 보호할 수 있습니다. JWT를 사용하여 당사자 간에 데이터를 안전하게 전송할 수도 있습니다. 결론 OAuth와 JWT는 모두 웹 애플리케이션 보안을 위한 강력한 도구입니다. 유사해 보일 수도 있지만 용도가 다르며 사용 사례도 다릅니다. OAuth와 JWT의 차이점을 이해하면 특정 사용 사례에 적합한 도구를 선택하고 애플리케이션의 보안을 보장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"}],"tags":[{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"},{"name":"OAuth","slug":"OAuth","permalink":"http://hgko1207.github.io/tags/OAuth/"},{"name":"JWT","slug":"JWT","permalink":"http://hgko1207.github.io/tags/JWT/"},{"name":"인증","slug":"인증","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"보안","slug":"보안","permalink":"http://hgko1207.github.io/tags/%EB%B3%B4%EC%95%88/"}]},{"title":".NET Core에서 Swagger를 사용하는 방법","slug":"csharp-4","date":"2023-09-07T02:41:41.000Z","updated":"2024-01-12T08:25:34.860Z","comments":true,"path":"2023/09/07/csharp-4/","link":"","permalink":"http://hgko1207.github.io/2023/09/07/csharp-4/","excerpt":"","text":"Swagger는 RESTful API를 문서화하고 테스트하는 데 널리 사용되는 오픈 소스 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다. 이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보겠습니다. Endpoint는 API가 RESTful API를 인터페이스를 통해 서버의 리소스에 액세스 할 수 있도록 해주는 URL입니다. 전제 조건 🛠️ 컴퓨터에 .NET Core 3.1 이상이 설치되어 있어야 함 RESTful API 아키텍처에 대한 기본 이해 Visual Studio Code 또는 Visual Studio 2019 이상 시작하기 🚀 1단계: .NET Core 웹 API 프로젝트 만들기 첫 번째 단계는 새 .NET Core Web API 프로젝트를 만드는 것입니다. Visual Studio 또는 Visual Studio Code를 열고 새 .NET Core Web API 프로젝트를 만듭니다. 2단계: Swashbuckle.AspNetCore NuGet 패키지 설치 Swagger는 .NET Core용 NuGet 패키지로 제공됩니다. 설치하려면 IDE에서 NuGet 패키지 관리자를 열고 Swashbuckle.AspNetCore를 검색하세요. 최신 버전의 패키지를 설치하십시오. 3단계: 애플리케이션 파이프라인에 Swagger 미들웨어 추가 Startup.cs 파일의 구성 메서드에 다음 코드를 추가하여 Swagger 미들웨어를 애플리케이션 파이프라인에 추가합니다. 12345app.UseSwagger();app.UseSwaggerUI(c =&gt;&#123; c.SwaggerEndpoint( \"/swagger/v1/swagger.json\" , \"My API V1\" );&#125;); 그러면 미들웨어 파이프라인에 Swagger가 추가되고 개발자가 API를 테스트할 수 있는 UI가 생성됩니다. 4단계: Swagger 구성 SwaggerGenOptions 클래스를 사용하여 Swagger를 구성할 수 있습니다. 이 클래스는 Swagger에서 생성된 문서를 커스터마이징 하는 메서드를 제공합니다. Swagger를 구성하려면 Startup.cs 파일의 ConfigureServices 메서드에 다음 코드를 추가하세요. 1234services.AddSwaggerGen(c =&gt;&#123; c.SwaggerDoc( \"v1\" , new OpenApiInfo &#123; Title = \"My API\" , Version = \"v1\" &#125;);&#125;); 그러면 SwaggerGen 미들웨어가 애플리케이션 파이프라인에 추가되고 Swagger UI가 구성됩니다. 5단계: API Endpoint 문서 생성 Swagger는 XML 문서 주석을 사용하여 API Endpoint에 대한 문서를 생성합니다. API Endpoint에 XML 주석을 추가하여 문서화하세요. 다음은 GET 엔드포인트에 XML 문서 주석을 추가하는 방법의 예입니다. 123456789/// &lt;summary&gt;/// Gets all items./// &lt;/summary&gt;/// &lt;returns&gt;All items.&lt;/returns&gt;[HttpGet]public IEnumerable&lt;Item&gt; GetAll ()&#123; return repository.GetAll();&#125; 6단계: Swagger UI를 사용하여 API Endpoint 테스트 애플리케이션을 실행하고 Swagger UI Endpoint로 이동합니다. 그러면 개발자가 API Endpoint를 테스트할 수 있는 사용자 친화적인 인터페이스를 제공하는 Swagger UI가 열립니다. 결론 Swagger는 RESTful API를 문서화하고 테스트하기 위한 강력한 도구입니다. 개발자가 API를 테스트하고 실시간으로 문서를 생성할 수 있는 사용자 친화적인 인터페이스를 제공합니다. 이 글에서는 .NET Core와 함께 Swagger를 사용하여 API Endpoint를 문서화하고 테스트하는 방법을 살펴보았습니다. Swagger를 사용하면 API가 잘 문서화되고 테스트되어 개발자가 더 쉽게 API를 사용할 수 있도록 보장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"}]},{"title":"웹 개발자를 위한 AWS 소개 🚀","slug":"aws-1","date":"2023-09-06T14:28:39.000Z","updated":"2024-01-12T08:25:13.024Z","comments":true,"path":"2023/09/06/aws-1/","link":"","permalink":"http://hgko1207.github.io/2023/09/06/aws-1/","excerpt":"","text":"Amazon Web Services(AWS)는 웹 애플리케이션 구축, 배포 및 관리를 위한 다양한 서비스를 제공하는 클라우드 기반 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 네트워킹 기능을 포함한 다양한 서비스를 제공합니다. 이 글에서는 AWS의 기본 사항과 AWS가 웹 개발자에게 어떤 이점을 줄 수 있는지 살펴보겠습니다. AWS 서비스 📦 AWS는 웹 애플리케이션을 구축하는 데 사용할 수 있는 다양한 서비스를 제공합니다. 가장 인기 있는 서비스 중 일부는 다음과 같습니다. EC2(Elastic Compute Cloud): 클라우드에서 크기 조정 가능한 컴퓨팅 용량을 제공하는 서비스입니다. S3(Simple Storage Service): 안전하고 내구성이 뛰어나며 확장성이 뛰어난 객체 스토리지를 제공하는 서비스입니다. RDS(관계형 데이터베이스 서비스): MySQL, PostgreSQL, Oracle 및 Microsoft SQL Server에 관리형 데이터베이스 서비스를 제공하는 서비스입니다. Lambda: 서버를 프로비저닝 하거나 관리하지 않고도 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다. API 게이트웨이: API를 쉽게 생성, 게시, 관리할 수 있게 해주는 서비스입니다. CloudFront: 웹 콘텐츠를 사용자에게 빠르게 전달하는 콘텐츠 전달 네트워크(CDN)입니다. AWS 배포 🚀 AWS는 웹 애플리케이션을 클라우드에 배포하기 위한 다양한 도구를 제공합니다. 가장 널리 사용되는 도구는 다음과 같습니다. Elastic Beanstalk: 웹 애플리케이션 배포 및 확장을 위한 완전관리형 서비스입니다. CodeDeploy: Amazon EC2 인스턴스 및 온프레미스에서 실행되는 인스턴스를 포함하여 모든 인스턴스에 대한 코드 배포를 자동화하는 서비스입니다. CloudFormation: Amazon Web Services 리소스를 모델링하고 설정하여 해당 리소스를 관리하는 데 드는 시간을 줄이고 AWS에서 실행되는 애플리케이션에 더 많은 시간을 집중할 수 있도록 도와주는 서비스입니다. OpsWorks: 애플리케이션 배포, 확장 및 관리 자동화를 위해 Chef 및 Puppet의 관리형 인스턴스를 제공하는 서비스입니다. AWS 보안 🔒 AWS는 웹 애플리케이션을 보호하는 데 도움이 되는 다양한 보안 서비스와 기능을 제공합니다. 가장 중요한 보안 기능 중 일부는 다음과 같습니다. IAM(Identity and Access Management): AWS 리소스에 대한 액세스를 안전하게 제어하는 ​​데 도움이 되는 서비스입니다. WAF(웹 애플리케이션 방화벽): 일반적인 웹 공격으로부터 웹 애플리케이션을 보호하는 데 도움이 되는 웹 애플리케이션 방화벽입니다. 키 관리 서비스(KMS): 데이터를 암호화하는 데 사용되는 암호화 키를 쉽게 생성하고 제어할 수 있게 해주는 서비스입니다. 결론🔑 AWS는 웹 애플리케이션을 구축, 배포 및 관리하기 위한 강력한 플랫폼을 제공합니다. 다양한 서비스와 기능을 통해 애플리케이션을 빠르고 쉽게 구축하고 확장할 수 있습니다. 이 글에서는 AWS 서비스, 배포 도구 및 보안 기능에 대한 개요를 제공했습니다. 이러한 지식을 바탕으로 AWS를 시작하고 강력한 클라우드 기반 플랫폼을 활용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"},{"name":"Amazon Web Services","slug":"Amazon-Web-Services","permalink":"http://hgko1207.github.io/tags/Amazon-Web-Services/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"}]},{"title":"효율적인 버전 제어를 위한 Git 명령","slug":"git-2","date":"2023-09-05T08:21:34.000Z","updated":"2024-01-12T08:24:43.511Z","comments":true,"path":"2023/09/05/git-2/","link":"","permalink":"http://hgko1207.github.io/2023/09/05/git-2/","excerpt":"","text":"Git은 코드베이스를 효율적으로 관리할 수 있는 강력한 버전 제어 시스템입니다. 이는 협업, 디버깅 및 깔끔한 코드베이스 유지에 필수적입니다. 이 글에서는 효율적인 버전 관리를 위해 알아야 할 몇 가지 필수 Git 명령을 다룰 것입니다. 🚀 1. Git 시작하기 Git은 일반적으로 대부분의 시스템에 사전 설치되어 있지만, 그렇지 않은 경우 공식 웹사이트에서 다운로드할 수 있습니다. 설치가 완료되면 다음 명령을 사용하여 사용자 이름과 이메일을 구성해야 합니다. 12git config --global user.name \"Your Name\"git config --global user.email \"youremail@domain.com\" Git이 올바르게 설치 및 구성되었는지 확인하려면 다음 명령을 실행하십시오. 1git --version 그러면 시스템에 설치된 Git의 현재 버전이 반환됩니다. 🚀 2. Git 저장소 만들기 새 Git 리포지토리를 생성하려면 코드가 포함된 디렉터리로 이동하여 다음 명령을 실행하세요. 1git init 그러면 현재 디렉터리에 새 Git 저장소가 생성됩니다. 이제 코드 변경 사항 추적을 시작할 수 있습니다. 🚀 3. 코드 변경 Git 리포지토리를 생성한 후에는 코드 변경을 시작할 수 있습니다. 준비 영역에 변경 사항을 추가하려면 다음 명령을 실행하십시오. 1git add &lt;filename&gt; 그러면 지정된 파일이 준비 영역에 추가됩니다. 다음 명령을 사용하여 모든 변경 사항을 추가할 수도 있습니다. 1git add . 변경 사항을 저장소에 커밋하려면 다음 명령어를 실행하세요. 1git commit -m \"Commit message\" 그러면 지정된 커밋 메시지를 사용하여 저장소에 대한 변경 사항이 커밋됩니다. 🚀 4. 분기 및 병합 분기(Branch) 및 병합(Merge)은 코드베이스의 다양한 기능을 동시에 작업할 수 있게 해주는 Git의 필수 기능입니다. 새 분기를 만들려면 다음 명령을 실행합니다. 1git branch &lt;branch명&gt; 그러면 지정된 이름을 가진 새 분기가 생성됩니다. 새 분기로 전환하려면 다음 명령을 실행합니다. 1git checkout &lt;branch명&gt; 한 분기의 변경 사항을 다른 분기에 병합하려면 다음 명령을 실행하세요. 1git merge &lt;branch명&gt; 그러면 지정된 분기의 변경 사항이 현재 분기에 병합됩니다. 🚀 5. 원격으로 작업하기 원격 저장소는 협업에 필수적이며 코드베이스를 다른 사람과 공유할 수 있게 해 줍니다. 원격 저장소를 추가하려면 다음 명령을 실행하세요. 1git remote add origin &lt;원격 저장소 URL&gt; 그러면 지정된 이름과 URL을 가진 새 원격 저장소가 추가됩니다. 변경 사항을 원격 저장소에 푸시하려면 다음 명령어를 실행하세요. 1git push origin &lt;branch명&gt; 그러면 지정된 분기의 변경 사항이 지정된 원격 저장소로 푸시됩니다. 🚀 6. 고급 Git 명령 Git에는 코드베이스를 효율적으로 관리할 수 있는 다양한 고급 명령이 있습니다. 가장 유용한 명령 중 일부는 다음과 같습니다. git log: 저장소의 모든 커밋 목록을 표시합니다. git reset: 스테이징 영역에서 변경 사항을 제거합니다. git stash: 커밋할 준비가 되지 않은 변경 사항을 임시로 저장합니다. 결론 Git은 코드베이스를 효율적으로 관리하는 데 도움이 되는 강력한 버전 제어 시스템입니다. 이러한 필수 Git 명령을 익히면 효과적으로 협업하고 효율적으로 디버그 하며 깔끔한 코드베이스를 유지할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"Git 명령","slug":"Git-명령","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9/"},{"name":"버전 제어","slug":"버전-제어","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EC%A0%9C%EC%96%B4/"}]},{"title":"소프트웨어 개발에서 테스트의 중요성","slug":"info-3","date":"2023-09-04T01:49:32.000Z","updated":"2023-11-02T00:58:13.185Z","comments":true,"path":"2023/09/04/info-3/","link":"","permalink":"http://hgko1207.github.io/2023/09/04/info-3/","excerpt":"","text":"테스트는 소프트웨어 개발의 필수적인 부분으로, 개발자가 오류를 파악하고 코드 품질을 보장할 수 있도록 해줍니다. 이 글에서는 테스트의 중요성을 살펴보고 다양한 테스트 유형의 예를 제공합니다. 테스트가 중요한 이유 테스트를 통해 코드가 의도한 대로 작동하고 이해관계자가 설정한 요구 사항을 충족하는지 확인합니다. 테스트하지 않으면 오류와 버그가 쉽게 빠져나가 사용자에게 문제를 일으키고 소프트웨어의 평판을 손상시킬 수 있습니다. 또한 테스트를 통해 개발 초기에 문제를 파악하고 장기적으로 시간과 리소스를 절약할 수 있습니다. 테스트 유형 단위 테스트 단위 테스트는 메서드나 함수와 같은 단일 코드 단위의 기능을 확인하는 자동화된 테스트입니다. 이는 일반적으로 개발자가 작성하며 개발 프로세스 초기에 오류를 포착할 수 있습니다. 통합 테스트 통합 테스트는 서로 다른 코드 단위 또는 시스템 간의 상호 작용을 확인합니다. 이는 다양한 구성 요소의 통합으로 인해 발생할 수 있는 문제를 파악하는 데 유용합니다. 승인 테스트 end-to-end 테스트라고도 알려진 승인 테스트는 전체 시스템이 사용자 관점에서 예상대로 작동하는지 확인합니다. 일반적으로 테스터나 품질 보증 전문가가 작성합니다. Test-Driven Development(TDD) TDD(테스트 중심 개발)는 코드를 작성하기 전에 테스트 작성을 강조하는 소프트웨어 개발 방식입니다. 이 접근 방식을 사용하면 모든 기능에 대한 테스트가 작성되고 개발 프로세스 초기에 오류를 포착할 수 있습니다. 지속적인 통합 및 제공 CI(지속적 통합) 및 CD(지속적 전달)는 코드 변경 사항이 의도한 대로 작동하는지 확인하기 위해 정기적으로 코드 변경 사항을 구축하고 테스트하는 방식입니다. CI/CD 파이프라인은 코드 변경 사항을 빌드, 테스트 및 배포하는 프로세스를 자동화하여 더 빠르고 빈번한 릴리스를 가능하게 합니다. 결론 테스트는 소프트웨어 개발의 중요한 부분이므로 처음부터 개발 프로세스에 통합되어야 합니다. 자동화된 테스트를 작성하고 이를 CI/CD 파이프라인에 통합함으로써 개발자는 오류를 조기에 포착하고 코드 변경 사항이 사용자에게 빠르고 안전하게 전달되도록 할 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"소프트웨어","slug":"소프트웨어","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"},{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"}]},{"title":"[HTTP] POST와 GET 차이점 및 사용 시기","slug":"info-2","date":"2023-09-03T13:37:45.000Z","updated":"2023-12-18T14:38:05.855Z","comments":true,"path":"2023/09/03/info-2/","link":"","permalink":"http://hgko1207.github.io/2023/09/03/info-2/","excerpt":"","text":"HTTP(Hypertext Transfer Protocol)는 인터넷을 통해 데이터를 전송하는 데 사용되는 프로토콜입니다. 다양한 HTTP 방법이 있지만 가장 일반적으로 사용되는 두 가지 방법은 HTTP POST와 HTTP GET입니다. 이러한 방법에는 서로 다른 목적이 있으므로 효과적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 필수적입니다. 이 글에서는 HTTP POST와 HTTP GET의 차이점을 살펴보고 각 방법을 사용하는 경우의 예를 제공합니다. 또한 웹 애플리케이션에서 이러한 방법을 사용하는 몇 가지 모범 사례에 대해서도 알아보겠습니다. HTTP POST와 GET이란 무엇입니까? HTTP POST 및 HTTP GET은 웹 서버에 데이터를 보내는 데 사용되는 두 가지 방법입니다. 두 방법의 주요 차이점은 데이터가 전송되는 방식입니다. HTTP GET은 URL의 일부로 데이터를 보내는 반면, HTTP POST는 HTTP 요청 본문의 일부로 데이터를 보냅니다. 다음은 HTTP GET 요청의 예입니다. 1https://example.com?param1=value1&amp;param2=value2 다음은 HTTP POST 요청의 예입니다. 123456POST /submit-form HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 33param1=value1&amp;param2=value2&amp;param3=value3 HTTP GET 요청에서 데이터는 URL의 일부로 전송됩니다. HTTP POST 요청에서 데이터는 요청 본문에 key-value 쌍 집합으로 전송됩니다. HTTP GET을 사용하는 경우 HTTP GET은 일반적으로 서버가 데이터 검색만 예상하고 서버에 데이터를 보낼 필요가 없을 때 사용됩니다. 요청된 데이터가 민감하지 않거나 비공개인 경우에도 유용합니다. 다음은 HTTP GET을 사용하는 경우에 대한 몇 가지 예입니다. 서버에서 데이터 검색 데이터 필터링 데이터 페이지 매기기 데이터 검색 중 정적 리소스 가져오기(예: 이미지, CSS) HTTP POST를 사용하는 경우 HTTP POST는 일반적으로 서버가 데이터를 생성, 업데이트 또는 삭제해야 할 때 사용됩니다. URL에 표시되어서는 안 되는 대량의 데이터나 민감한 정보를 보낼 때도 유용합니다. 다음은 HTTP POST를 사용하는 경우에 대한 몇 가지 예입니다. 서버에 새 리소스 생성 서버의 기존 리소스 업데이트 서버에서 리소스 삭제 많은 양의 데이터가 포함된 양식 제출 파일 업로드 모범 사례 HTTP GET 또는 HTTP POST를 사용할 때 웹 애플리케이션이 안전하고 효율적인지 확인하기 위해 몇 가지 모범 사례를 따르는 것이 중요합니다. 따라야 할 몇 가지 모범 사례는 다음과 같습니다. 안전한 멱등성 작업을 위해 HTTP GET을 사용하세요. 서버의 데이터를 수정하는 안전하지 않은 작업에는 HTTP POST를 사용합니다. HTTPS를 사용하여 인터넷을 통해 전송되는 데이터를 암호화합니다. 단일 요청으로 전송되는 데이터의 양을 제한합니다. 주입 공격을 방지하기 위해 모든 사용자 입력을 검증합니다. SQL 삽입 공격을 방지하려면 매개변수화된 쿼리를 사용하세요. 멱등법칙 또는 멱등성은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. 위키백과 결론 HTTP POST 및 HTTP GET은 웹 애플리케이션에서 사용되는 두 가지 중요한 HTTP 방법입니다. 안전하고 효율적인 웹 애플리케이션을 개발하려면 각 방법을 언제 사용해야 하는지 아는 것이 중요합니다. 모범 사례를 따르고 이러한 방법을 적절하게 사용하면 안정적이고 확장 가능하며 안전한 웹 애플리케이션을 만들 수 있습니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://hgko1207.github.io/tags/HTTP/"},{"name":"POST","slug":"POST","permalink":"http://hgko1207.github.io/tags/POST/"},{"name":"GET","slug":"GET","permalink":"http://hgko1207.github.io/tags/GET/"},{"name":"Https","slug":"Https","permalink":"http://hgko1207.github.io/tags/Https/"}]},{"title":"Angular 패키지 생성 및 NPM에 게시","slug":"angular-20","date":"2023-09-02T05:13:46.000Z","updated":"2023-11-02T00:56:58.364Z","comments":true,"path":"2023/09/02/angular-20/","link":"","permalink":"http://hgko1207.github.io/2023/09/02/angular-20/","excerpt":"","text":"Angular 패키지를 만드는 것은 여러 프로젝트에서 코드를 재사용하는 효율적인 방법이므로 시간과 노력을 절약할 수 있습니다. 이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명합니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 진행하겠습니다. 1단계: 프로젝트 설정 첫 번째 단계는 프로젝트를 설정하는 것입니다. Angular CLI를 사용하여 새 프로젝트를 생성하겠습니다. 터미널을 열고 다음 명령을 실행하십시오. 1ng new my-package --create-application=false 그러면 애플리케이션 없이 새로운 Angular 프로젝트가 생성됩니다. 이제 다음 명령을 사용하여 프로젝트 폴더로 이동할 수 있습니다. 1cd my-package 2단계: 새 모듈 만들기 다음 단계는 패키지에 대한 새 모듈을 만드는 것입니다. 다음 명령을 실행하여 새 모듈을 만듭니다. 1ng g module my-module 그러면 프로젝트에 새 모듈이 생성됩니다. 이제 모듈에 코드를 추가할 수 있습니다. 3단계: 모듈에 코드 추가 이제 모듈에 코드를 추가할 수 있습니다. 다음 명령을 사용하여 새 컴포넌트를 만듭니다. 1ng g component my-component 그러면 모듈에 새 컴포넌트가 생성됩니다. 이제 컴포넌트에 코드를 추가할 수 있습니다. 4단계: 패키지 빌드(Build) 다음 단계는 패키지를 빌드하는 것입니다. 다음 명령을 실행하여 패키지를 빌드합니다. 1ng build my-package 그러면 프로젝트 디렉터리에 dist 라는 새 폴더가 생성됩니다. 5단계: 패키지 게시(Publish) 마지막 단계는 NPM에 패키지를 게시하는 것입니다. NPM 계정이 없다면 무료로 만들 수 있습니다. 다음 명령을 실행하여 NPM 계정에 로그인하세요. 1npm login NPM 사용자 이름, 비밀번호, 이메일 주소를 입력하세요. 로그인한 후 다음 명령을 실행하여 패키지를 게시합니다. 1npm publish dist/my-package-0.0.1.tgz 그러면 NPM 레지스트리에 패키지가 게시됩니다. 결론 이 글에서는 Angular 패키지를 생성하고 이를 NPM 레지스트리에 게시하는 방법에 대해 설명했습니다. 새 패키지를 만들고, 새 모듈을 만들고, 패키지에 코드를 추가하는 데 필요한 단계를 거쳤습니다. NPM에 패키지를 게시한 후에는 여러 프로젝트에서 코드를 재사용하여 시간과 노력을 절약할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"Package","slug":"Package","permalink":"http://hgko1207.github.io/tags/Package/"},{"name":"Creating","slug":"Creating","permalink":"http://hgko1207.github.io/tags/Creating/"},{"name":"Publishing","slug":"Publishing","permalink":"http://hgko1207.github.io/tags/Publishing/"}]},{"title":"사용자 정의 스크립트로 Angular 워크플로우(Workflow) 자동화","slug":"angular-19","date":"2023-09-01T02:27:04.000Z","updated":"2023-12-18T14:37:59.763Z","comments":true,"path":"2023/09/01/angular-19/","link":"","permalink":"http://hgko1207.github.io/2023/09/01/angular-19/","excerpt":"","text":"Angular는 확장 가능한 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 그러나 이를 사용하는 것은 때로는 시간이 많이 걸리고 지루할 수 있습니다. 특히 반복적인 작업의 경우 더욱 그렇습니다. 다행히 약간의 자동화를 통해 작업 흐름을 간소화하고 일반적인 작업에 소요되는 시간을 절약할 수 있습니다. 이 글에서는 사용자 정의 스크립트(Custom Scripts)를 사용하여 Angular 워크플로를 자동화하는 방법을 살펴보겠습니다. 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 알아보겠습니다. 환경 설정 사용자 정의 스크립트를 시작하기 전에 환경을 설정해야 합니다. 먼저 시스템에 Node.js와 NPM이 설치되어 있는지 확인하세요. 공식 웹사이트에서 최신 버전의 Node.js를 다운로드할 수 있습니다. 다음으로 Angular 프로젝트를 생성해야 합니다. 아직 수행하지 않은 경우 터미널에서 다음 명령을 실행하여 새 프로젝트를 생성할 수 있습니다. 1ng new my-app 프로젝트를 설정한 후에는 사용자 정의 스크립트를 생성하여 작업 흐름을 자동화할 수 있습니다. 일반적인 사용 사례 다음은 Angular 프로젝트의 사용자 정의 스크립트에 대한 몇 가지 일반적인 사용 사례입니다. 1. 애플리케이션 구축 및 배포 애플리케이션을 구축하고 배포하는 것은 시간이 많이 걸리는 프로세스일 수 있으며, 특히 수동으로 수행하는 경우 더욱 그렇습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 시간을 절약할 수 있습니다. 다음은 애플리케이션을 빌드하고 원격 서버에 배포하는 예제 스크립트입니다. 1234#!/bin/bashng build --prodscp -r dist/my-app/* user@remote-server:/usr/share/nginx/html 이 스크립트는 production 모드에서 Angular 애플리케이션을 구축한 다음 **SCP(Secure Copy)**를 사용하여 원격 서버에 배포합니다. 시큐어 카피(Secure copy) 또는 SCP는 로컬 호스트와 원격 호스트 간 또는 두 개의 원격 호스트 간에 컴퓨터 파일을 안전하게 전송하는 수단이다. 시큐어 셸 프로토콜 기반이다. SCP라는 용어는 SCP 프로토콜 또는 SCP 프로그램 중 하나를 가리킬 수 있다. 위키백과 2. Linters and Code Formatters 실행 린터와 코드 포맷터는 코드 품질과 일관성을 유지하는 데 필수적인 도구입니다. 그러나 수동으로 실행하는 것은 번거로울 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 코드가 항상 올바른 형식으로 지정되고 린트되도록 할 수 있습니다. 다음은 프로젝트에서 Prettier 코드 포맷터와 ESLint 린터를 실행하는 예제 스크립트입니다. 1234#!/bin/bashnpm run formatnpm run lint 이 스크립트는 npm run format 및 npm run lint 명령을 실행합니다. 이 명령은 각각 Prettier로 코드 형식을 지정하고 ESLint로 lint합니다. 3.테스트 실행 테스트 실행은 개발 프로세스에서 중요한 부분이지만 수동으로 수행해야 하는 경우 시간이 많이 걸릴 수 있습니다. 사용자 정의 스크립트를 사용하면 이 프로세스를 자동화하고 단일 명령으로 테스트를 실행할 수 있습니다. 다음은 테스트를 실행하고 결과를 콘솔에 출력하는 예제 스크립트입니다. 123#!/bin/bashng test --watch=false --code-coverage=true 이 스크립트는 ng test 명령을 사용하여 테스트를 실행하고 결과를 콘솔에 출력합니다. 또한 프로젝트에 대한 코드 적용 범위 보고서도 생성됩니다. 결론 사용자 정의 스크립트를 사용하면 Angular 프로젝트의 일반적인 작업을 자동화하고 많은 시간과 번거로움을 줄일 수 있습니다. 이 문서에서는 몇 가지 일반적인 사용 사례를 다루고 시작하는 데 도움이 되는 몇 가지 코드 예제를 제공했습니다. 항상 스크립트를 철저히 테스트하고 주의해서 사용하세요. 약간의 자동화를 통해 Angular 워크플로를 한 단계 더 발전시킬 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Script","slug":"Script","permalink":"http://hgko1207.github.io/tags/Script/"},{"name":"Workflow","slug":"Workflow","permalink":"http://hgko1207.github.io/tags/Workflow/"},{"name":"사용자 정의 스트립트","slug":"사용자-정의-스트립트","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8/"},{"name":"워크플로우 자동화","slug":"워크플로우-자동화","permalink":"http://hgko1207.github.io/tags/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9E%90%EB%8F%99%ED%99%94/"}]},{"title":"[Angular] Http Client 사용 방법","slug":"angular-18","date":"2023-08-31T08:06:13.000Z","updated":"2024-01-12T08:21:53.089Z","comments":true,"path":"2023/08/31/angular-18/","link":"","permalink":"http://hgko1207.github.io/2023/08/31/angular-18/","excerpt":"","text":"Angular의 HttpClient 모듈은 HTTP 요청을 만들고 응답을 처리하는 간단한 방법을 제공합니다. @angular/common/http 패키지의 일부이며 XMLHttpRequest API 위에 구축되었습니다. 이 글에서는 HttpClient 모듈의 다양한 기능을 자세히 살펴보고 이를 사용하여 Angular에서 HTTP 요청을 만드는 방법을 알아봅니다. Getting started Angular 애플리케이션에서 HttpClient 모듈을 사용하려면 루트 모듈(일반적으로 app.module.ts)에서 HttpClientModule을 가져와야 합니다. 12345678import &#123; NgModule &#125; from '@angular/core';import &#123; HttpClientModule &#125; from '@angular/common/http';@NgModule(&#123; imports: [HttpClientModule], // ...&#125;)export class AppModule &#123;&#125; HttpClientModule을 가져오면 이제 HttpClient 서비스를 사용하여 HTTP 요청을 할 수 있습니다. HTTP 요청하기 HttpClient 서비스를 사용하여 HTTP 요청을 만들려면 get(), post(), put(), delete() 및 patch() 메서드 중 하나를 호출하면 됩니다. 이 메서드는 요청 완료 시 응답을 내보내는 Observable을 반환합니다. 다음은 HttpClient 서비스를 사용하여 GET 요청을 만드는 방법에 대한 예입니다. 123456789101112import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; return this.http.get&lt;any&gt;('https://api.example.com/data'); &#125;&#125; 위의 예에서는 HttpClient 서비스를 ApiService 라는 서비스에 주입합니다. 그런 다음 any 유형의 Observable 을 반환하는 getData() 라는 메서드를 정의합니다. HttpClient 서비스의 get() 메서드는 지정된 URL에 대한 GET 요청을 만드는 데 사용됩니다. 마찬가지로, 다른 HTTP 메서드를 사용하여 요청을 수행하고 적절한 데이터를 메서드의 두 번째 인수로 전달할 수 있습니다. HTTP 응답 처리 HttpClient 서비스는 도착 시 응답을 내보내는 Observable 을 반환합니다. 응답을 처리하기 위해 Observable 의 subscribe() 메서드를 사용할 수 있습니다. 다음은 getData() 메서드의 응답을 처리하는 방법에 대한 예입니다. 12345678this.apiService.getData().subscribe( (response) =&gt; &#123; // handle the response here &#125;, (error) =&gt; &#123; // handle the error here &#125;); 위의 예에서는 ApiService 서비스의 getData() 메서드를 호출하고 Observable 의 subscribe() 메서드를 사용하여 응답을 구독합니다. subscribe() 메서드의 첫 번째 콜백은 응답이 도착할 때 호출되고, 두 번째 콜백은 오류가 있을 때 호출됩니다. HTTP 헤더 HttpHeaders 클래스의 set() 메서드를 사용하여 요청에 대한 HTTP 헤더를 설정할 수도 있습니다. Authorization 헤더를 설정하는 방법의 예는 다음과 같습니다. 12345678910111213141516import &#123; HttpClient, HttpHeaders &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; const headers = new HttpHeaders(&#123; Authorization: 'Bearer my-token', &#125;); return this.http.get&lt;any&gt;('https://api.example.com/data', &#123; headers &#125;); &#125;&#125; 위의 예에서는 HttpHeaders 클래스의 새 인스턴스를 생성하고 Authorization 헤더를 Bearer my-token 으로 설정합니다. 그런 다음 헤더 개체를 HttpClient 서비스의 get() 메서드에 대한 두 번째 인수로 전달합니다. Query parameters HttpParams 클래스를 사용하여 HTTP 요청에 쿼리 매개변수를 전달할 수도 있습니다. 쿼리 매개변수를 전달하는 방법의 예는 다음과 같습니다. 12345678910111213141516import &#123; HttpClient, HttpParams &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(page: number, limit: number): Observable&lt;any&gt; &#123; let params = new HttpParams(); params = params.append('page', page.toString()); params = params.append('limit', limit.toString()); return this.http.get&lt;any&gt;('https://api.example.com/data', &#123; params &#125;); &#125;&#125; 위의 예에서는 HttpParams 클래스의 새 인스턴스를 만들고 append() 메서드를 사용하여 page 및 limit 매개변수를 여기에 추가합니다. 그런 다음 params 개체를 HttpClient 서비스의 get() 메서드에 대한 두 번째 인수로 전달합니다. 오류 처리 HTTP 요청을 할 때 오류를 적절하게 처리하는 것이 중요합니다. HttpClient 서비스는 rxjs 라이브러리의 catchError() 연산자를 사용하여 오류를 처리하는 방법을 제공합니다. 다음은 getData() 메서드에서 오류를 처리하는 방법에 대한 예입니다. 1234567891011121314151617181920212223242526272829import &#123; HttpClient, HttpErrorResponse &#125; from '@angular/common/http';import &#123; catchError &#125; from 'rxjs/operators';import &#123; throwError &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor(private http: HttpClient) &#123;&#125; getData(): Observable&lt;any&gt; &#123; return this.http.get&lt;any&gt;('https://api.example.com/data').pipe( catchError((error: HttpErrorResponse) =&gt; &#123; let errorMessage = ''; if (error.error instanceof ErrorEvent) &#123; // client-side error errorMessage = `Error: $&#123;error.error.message&#125;`; &#125; else &#123; // server-side error errorMessage = `Error Code: $&#123;error.status&#125;\\nMessage: $&#123;error.message&#125;`; &#125; console.error(errorMessage); return throwError(errorMessage); &#125;) ); &#125;&#125; 위의 예에서는 rxjs 라이브러리의 catchError() 연산자를 사용하여 오류를 처리합니다. 오류가 발생하면 catchError() 연산자는 오류를 발생시키고 Observable 체인을 중지합니다. 그런 다음 rxjs 라이브러리의 throwError() 함수를 사용하여 오류를 내보내고 Observable 체인을 계속합니다. 다음은 HttpClient 모듈의 많은 기능을 사용하는 예입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpHeaders, HttpErrorResponse &#125; from '@angular/common/http';import &#123; Observable, throwError &#125; from 'rxjs';import &#123; catchError &#125; from 'rxjs/operators';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; private baseUrl = 'https://example.com/api'; private headers = new HttpHeaders(&#123; 'Content-Type': 'application/json', &#125;); constructor(private http: HttpClient) &#123;&#125; private handleError(error: HttpErrorResponse) &#123; if (error.error instanceof ErrorEvent) &#123; console.error('An error occurred:', error.error.message); &#125; else &#123; console.error(`Backend returned code $&#123;error.status&#125;, ` + `body was: $&#123;error.error&#125;`); &#125; return throwError('Something bad happened; please try again later.'); &#125; private getAuthHeaders() &#123; return new HttpHeaders(&#123; 'Content-Type': 'application/json', Authorization: `Bearer $&#123;localStorage.getItem('access_token')&#125;`, &#125;); &#125; public get&lt;T&gt;(path: string): Observable&lt;T&gt; &#123; return this.http .get&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public post&lt;T&gt;(path: string, data: any): Observable&lt;T&gt; &#123; return this.http .post&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, data, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public put&lt;T&gt;(path: string, data: any): Observable&lt;T&gt; &#123; return this.http .put&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, data, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125; public delete&lt;T&gt;(path: string): Observable&lt;T&gt; &#123; return this.http .delete&lt;T&gt;(`$&#123;this.baseUrl&#125;$&#123;path&#125;`, &#123; headers: this.getAuthHeaders(), &#125;) .pipe(catchError(this.handleError)); &#125;&#125; HTTP 요청 테스트 @angular/common/http/testing 모듈은 HttpClient 서비스로 생성된 HTTP 요청을 테스트하기 위한 유틸리티 세트를 제공합니다. 이 모듈에서 제공하는 주요 클래스는 HttpTestingController 입니다. 이 클래스를 사용하여 HTTP 요청 및 응답을 모의하고 테스트 중인 애플리케이션에서 올바른 요청이 이루어졌는지 확인할 수 있습니다. HttpTestingController 를 사용하려면 먼저 테스트 케이스에 삽입해야 합니다. 123456789101112131415import &#123; TestBed &#125; from '@angular/core/testing';import &#123; HttpClientTestingModule, HttpTestingController &#125; from '@angular/common/http/testing';describe('MyComponent', () =&gt; &#123; let httpTestingController: HttpTestingController; beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [HttpClientTestingModule], providers: [MyComponent], &#125;); httpTestingController = TestBed.inject(HttpTestingController); &#125;);&#125;); Mocking HTTP Requests HTTP 요청을 모의하려면 HttpTestingController 인스턴스에서 ExpectOne() 메서드를 호출하여 URL 또는 HttpRequest 객체를 전달할 수 있습니다. 이 메서드는 요청에 대한 응답을 제어하는 데 사용할 수 있는 TestRequest 객체를 반환합니다. 다음은 ExpectOne() 을 사용하여 HTTP GET 요청을 모의하는 방법에 대한 예입니다. 123456789101112it('should make an HTTP GET request', () =&gt; &#123; const expectedData = &#123; id: 1, name: 'John Doe' &#125;; const url = '/api/user/1'; myComponent.getUser(1).subscribe((data) =&gt; &#123; expect(data).toEqual(expectedData); &#125;); const req = httpTestingController.expectOne(url); expect(req.request.method).toEqual('GET'); req.flush(expectedData);&#125;); 이 예에서는 MyComponent 인스턴스에서 getUser() 메서드를 테스트하고 있습니다. 이 메서드는 /api/user/1 에 대한 HTTP GET 요청을 만들고 응답 데이터를 내보내는 Observable 을 반환합니다. 이 메서드를 테스트하기 위해 getUser() 를 호출하고 그것이 반환하는 Observable 을 구독합니다. 그런 다음 요청과 동일한 URL을 사용하여 httpTestingController.expectOne() 을 호출하고 반환된 TestRequest 객체를 사용하여 예상 데이터가 포함된 응답을 flush 합니다. HTTP 요청 확인 HttpTestingController 를 사용하여 HTTP 요청을 모의한 후 해당 메서드를 사용하여 예상되는 요청이 테스트 중인 애플리케이션에서 이루어졌는지 확인할 수 있습니다. 예를 들어, verify() 메서드를 사용하여 예기치 않은 요청이 발생하지 않았는지 확인할 수 있습니다. 12345678910it('should make an HTTP GET request', () =&gt; &#123; myComponent.getUser(1).subscribe((data) =&gt; &#123; expect(data).toEqual(expectedData); &#125;); const req = httpTestingController.expectOne('/api/user/1'); req.flush(expectedData); httpTestingController.verify();&#125;); 이 예에서는 httpTestingController.verify() 를 사용하여 테스트 중인 애플리케이션에서 다른 요청이 이루어지지 않았는지 확인합니다. 다른 요청이 이루어진 경우 이 메서드는 오류를 발생시킵니다. expectNone() 메서드를 사용하여 요청이 이루어지지 않았는지 확인할 수도 있습니다. 1234567it('should not make an HTTP GET request with incorrect ID', () =&gt; &#123; myComponent.getUser(2).subscribe((data) =&gt; &#123; expect(data).toBeUndefined(); &#125;); httpTestingController.expectNone('/api/user/2');&#125;); 이 예에서는 getUser() 메서드가 /api/user/2 에 HTTP 요청을 하지 않는지 테스트하고 있습니다. 요청과 동일한 URL로 httpTestingController.expectNone() 을 호출하고 요청이 없으므로 테스트가 통과됩니다. 결론 Angular의 HttpClient 모듈의 다양한 기능을 살펴보았습니다. HTTP 요청을 작성하고 응답을 처리하고, HTTP 헤더 및 쿼리 매개변수를 설정하고, 오류를 처리하는 방법을 배웠습니다. HttpClient 모듈은 Angular 애플리케이션에서 HTTP 요청을 만들기 위한 강력하고 사용하기 쉬운 API를 제공합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"}]},{"title":"[JavaScript] Array Methods","slug":"js-dev-9","date":"2023-08-30T04:43:21.000Z","updated":"2024-01-12T08:20:20.051Z","comments":true,"path":"2023/08/30/js-dev-9/","link":"","permalink":"http://hgko1207.github.io/2023/08/30/js-dev-9/","excerpt":"","text":"JavaScript는 배열 작업을 위한 많은 강력한 도구를 제공하는 다용도 언어입니다. 가장 일반적으로 사용되는 도구 중 하나는 배열을 조작하고 변환하기 위한 다양한 메서드를 제공하는 Array 개체입니다. 이 글에서는 JavaScript에서 가장 중요하고 유용한 배열 메서드 중 일부를 자세히 살펴보겠습니다. forEach() forEach() 메서드는 배열을 반복하고 각 요소에 대해 콜백 함수를 실행합니다. 예는 다음과 같습니다. 12345const numbers = [1, 2, 3, 4, 5];numbers.forEach((number) =&gt; &#123; console.log(number);&#125;); 그러면 다음이 출력됩니다. 1234512345 map() map() 메서드는 배열의 각 요소에 콜백 함수를 적용하여 새 배열을 만듭니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const doubledNumbers = numbers.map((number) =&gt; &#123; return number * 2;&#125;);console.log(doubledNumbers); 그러면 다음이 출력됩니다. 1[2, 4, 6, 8, 10] filter() filter() 메서드는 특정 테스트를 통과한 모든 요소가 포함된 새 배열을 만듭니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const evenNumbers = numbers.filter((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(evenNumbers); 그러면 다음이 출력됩니다. 1[2, 4] reduce() reduce() 메서드는 배열의 각 요소에 콜백 함수를 적용하여 배열을 단일 값으로 줄입니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const sum = numbers.reduce((accumulator, currentValue) =&gt; &#123; return accumulator + currentValue;&#125;, 0);console.log(sum); 그러면 다음이 출력됩니다. 115 find() find() 메서드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 값을 반환합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const firstEvenNumber = numbers.find((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(firstEvenNumber); 그러면 다음이 출력됩니다. 12 findIndex() findIndex() 메서드는 배열에서 특정 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const firstEvenNumberIndex = numbers.findIndex((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(firstEvenNumberIndex); 그러면 다음이 출력됩니다. 11 some() some() 메서드는 배열의 요소 중 하나 이상이 특정 조건을 만족하는지 확인합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const hasEvenNumbers = numbers.some((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(hasEvenNumbers); 그러면 다음이 출력됩니다. 1true every() every() 메서드는 배열의 모든 요소가 특정 기준을 충족하는지 확인합니다. 예는 다음과 같습니다. 1234567const numbers = [2, 4, 6, 8, 10];const allEven = numbers.every((number) =&gt; &#123; return number % 2 === 0;&#125;);console.log(allEven); sort() sort() 메서드는 배열의 요소를 정렬합니다. 예는 다음과 같습니다. 12345const fruits = ['apple', 'orange', 'banana'];const sortedFruits = fruits.sort();console.log(sortedFruits); 그러면 다음이 출력됩니다. 1[\"apple\", \"banana\", \"orange\"] includes() include() 메서드는 배열에 특정 값이 포함되어 있는지 확인합니다. 예는 다음과 같습니다. 12345const numbers = [1, 2, 3, 4, 5];const hasNumberThree = numbers.includes(3);console.log(hasNumberThree); 그러면 다음이 출력됩니다. 1true flat() flat() 메서드는 모든 하위 배열 요소가 지정된 깊이까지 반복적으로 연결되어 있는 새 배열을 만듭니다. 예는 다음과 같습니다. 12345const numbers = [1, [2, 3], [4, [5, 6]]];const flattenedNumbers = numbers.flat(2);console.log(flattenedNumbers); 그러면 다음이 출력됩니다. 1[1, 2, 3, 4, 5, 6] flatMap() flatMap() 메서드는 먼저 매핑 함수를 사용하여 각 요소를 매핑한 다음 결과를 새 배열로 평면화합니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3, 4, 5];const doubledAndFlattenedNumbers = numbers.flatMap((number) =&gt; &#123; return [number * 2];&#125;);console.log(doubledAndFlattenedNumbers); 그러면 다음이 출력됩니다. 1[2, 4, 6, 8, 10] from() from() 메서드는 배열 유사 객체 또는 반복 가능 객체에서 새 배열을 만듭니다. 예는 다음과 같습니다. 12345const arrayLikeObject = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3 &#125;;const newArray = Array.from(arrayLikeObject);console.log(newArray); 그러면 다음이 출력됩니다. 1[\"a\", \"b\", \"c\"] Array Destructuring Array Destructuring를 사용하면 배열에서 값을 추출하여 변수에 할당할 수 있습니다. 예는 다음과 같습니다. 1234567const numbers = [1, 2, 3];const [a, b, c] = numbers;console.log(a);console.log(b);console.log(c); 그러면 다음이 출력됩니다. 123123 결론 이 글에서는 JavaScript 에서 가장 중요하고 유용한 Array 메소드 중 일부를 살펴보았습니다. 이러한 메서드는 배열 작업을 위한 강력한 도구를 제공하며 코드를 더욱 간결하고 표현력있게 만들 수 있습니다. 이러한 방법을 익히면 더욱 효율적이고 효과적인 JavaScript 개발자가 될 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"http://hgko1207.github.io/tags/Array/"},{"name":"Array Methods","slug":"Array-Methods","permalink":"http://hgko1207.github.io/tags/Array-Methods/"}]},{"title":"[Angular] Error Handling","slug":"angular-17","date":"2023-08-29T00:42:08.000Z","updated":"2024-01-12T08:18:42.281Z","comments":true,"path":"2023/08/29/angular-17/","link":"","permalink":"http://hgko1207.github.io/2023/08/29/angular-17/","excerpt":"","text":"Error Handling는 모든 애플리케이션의 필수적인 부분이며 Angular도 예외는 아닙니다. Angular 프레임워크는 다양한 시나리오에서 오류를 처리할 수 있는 강력한 도구 세트를 제공합니다. 이번 글에서는 Angular의 다양한 오류 유형과 이를 효과적으로 처리하는 방법을 살펴보겠습니다. Types of Errors in Angular Angular 애플리케이션에서 발생할 수 있는 오류에는 주로 두 가지 유형이 있습니다. 컴파일 시간 오류: 이러한 오류는 Angular 애플리케이션이 빌드되는 컴파일 단계에서 발생합니다. 컴파일 시간 오류는 일반적으로 코드의 구문 또는 논리적 오류를 나타내며 애플리케이션이 실행되지 못하게 합니다. 런타임 오류: 이러한 오류는 Angular 애플리케이션을 실행하는 동안 발생합니다. 런타임 오류는 네트워크 문제, 서버 오류, 코드의 논리적 오류 등 다양한 원인으로 인해 발생할 수 있습니다. Handling Compile-time Errors 컴파일 시간 오류는 일반적으로 쉽게 수정할 수 있으며 Angular CLI는 개발자가 문제를 신속하게 식별하는 데 도움이 되는 자세한 오류 메시지를 제공합니다. 오류 메시지에는 오류가 발생한 줄 번호와 파일 이름이 포함됩니다. 개발자는 오류 메시지를 사용하여 문제를 해결하고 애플리케이션을 다시 빌드할 수 있습니다. Handling Runtime Errors 런타임 오류는 컴파일 타임 오류보다 처리하기가 더 복잡합니다. 이러한 오류는 네트워크 문제나 서버 오류 등 다양한 이유로 인해 발생할 수 있습니다. 이러한 시나리오에서 애플리케이션은 오류를 적절하게 처리하고 사용자에게 유용한 피드백을 제공해야 합니다. Angular는 ErrorHandler 클래스와 같은 런타임 오류를 처리하기 위한 내장 오류 처리기 세트를 제공합니다. ErrorHandler 클래스는 오류 처리를 위한 기본 구현을 제공하는 추상 클래스입니다. 개발자는 ErrorHandler 클래스를 확장하고 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다. Custom Error Handling 개발자는 ErrorHandler 클래스를 사용하여 사용자에 맞게 오류 처리 로직을 구현할 수 있습니다. ErrorHandler 클래스에는 응용 프로그램에서 오류가 발생할 때 호출되는 handlerError(error: any)라는 단일 메서드가 있습니다. 이 메서드는 오류 개체를 매개 변수로 사용하고 개발자에게 오류를 처리할 수 있는 기회를 제공합니다. 다음은 커스텀 오류 처리기 구현의 예입니다. 12345678import &#123; ErrorHandler &#125; from '@angular/core';export class CustomErrorHandler implements ErrorHandler &#123; handleError(error: any) &#123; // Implement custom error handling logic here console.error(error); &#125;&#125; 위의 예에서는 ErrorHandler 클래스를 implements 하고 handlerError() 메서드를 재정의하는 CustomErrorHandler 클래스를 만들었습니다. 이 예에서는 단순히 오류를 콘솔에 기록하지만 개발자는 사용자에게 친숙한 오류 메시지를 표시하는 등 사용자 지정 오류 처리 로직을 구현할 수 있습니다. Error Interceptors Angular는 인터셉터를 사용하여 HTTP 응답을 가로채고 전역적으로 오류를 처리하는 메커니즘을 제공합니다. 인터셉터를 사용하면 개발자는 HTTP 응답이 호출 컴포넌트에 반환되기 전에 이를 가로챌 수 있습니다. 개발자는 인터셉터를 사용하여 오류를 전체적으로 처리하고 일관된 사용자 경험을 제공할 수 있습니다. 다음은 HTTP 오류 인터셉터의 예입니다. 123456789101112131415161718192021222324import &#123; Injectable &#125; from '@angular/core';import &#123; HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse &#125; from '@angular/common/http';import &#123; catchError &#125; from 'rxjs/operators';import &#123; throwError &#125; from 'rxjs';@Injectable()export class HttpErrorInterceptor implements HttpInterceptor &#123; intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler) &#123; return next.handle(request).pipe( catchError((error: HttpErrorResponse) =&gt; &#123; let errorMessage = ''; if (error.error instanceof ErrorEvent) &#123; // client-side error errorMessage = `Error: $&#123;error.error.message&#125;`; &#125; else &#123; // server-side error errorMessage = `Error Code: $&#123;error.status&#125;\\nMessage: $&#123;error.message&#125;`; &#125; console.error(errorMessage); return throwError(errorMessage); &#125;) ); &#125;&#125; 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpClientModule, HTTP_INTERCEPTORS &#125; from '@angular/common/http';import &#123; AppComponent &#125; from './app.component';import &#123; HttpErrorInterceptor &#125; from './http-error.interceptor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, HttpClientModule], providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true &#125;], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Component(&#123; selector: 'app-root', template: ` &lt;button (click)=\"makeRequest()\"&gt;Make Request&lt;/button&gt; &lt;div *ngIf=\"error\"&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt; `,&#125;)export class AppComponent &#123; error: string; constructor(private http: HttpClient) &#123;&#125; makeRequest() &#123; this.http.get('https://someURL.con/posts/1').subscribe( (data) =&gt; console.log(data), (error) =&gt; (this.error = error) ); &#125;&#125; 위 코드에서는 HttpClient 서비스를 사용하여 API 에 GET 요청을 보냅니다. 요청이 성공하면 응답 데이터가 콘솔에 기록됩니다. 오류가 있는 경우 템플릿에 오류 메시지가 표시됩니다. HttpErrorInterceptor를 사용하면 요청 중에 발생하는 모든 오류가 인터셉터에 의해 차단되어 처리됩니다. 오류 메시지는 콘솔에 기록되고 관찰 가능한 오류로 발생하며 컴포넌트에서 이를 포착하고 처리할 수 있습니다. Angular 앱에서 오류 인터셉터를 사용하면 오류 처리 로직을 중앙 집중화하고 모든 HTTP 요청에서 오류를 처리하는 일관된 방법을 제공할 수 있습니다. 이를 통해 코드 유지 관리가 더 용이해지고 앱에 대한 사용자 경험이 더 좋아질 수 있습니다. 결론 오류 처리는 강력하고 안정적인 애플리케이션을 구축하는 데 필수적인 부분입니다. Angular에는 try/catch 블록 사용, 컴포넌트 수준에서 오류 처리, 오류 인터셉터 사용 등 오류를 처리하는 다양한 방법이 있습니다. 포괄적인 오류 처리 전략을 구현하면 애플리케이션이 사용자에게 원활하고 오류 없는 환경을 제공하도록 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"},{"name":"Handling","slug":"Handling","permalink":"http://hgko1207.github.io/tags/Handling/"},{"name":"오류처리","slug":"오류처리","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"}]},{"title":"Node.js 와 TypeScript 콜백(callback) 지옥 피하는 방법","slug":"nodejs-5","date":"2023-08-28T04:16:12.000Z","updated":"2024-01-12T08:17:58.628Z","comments":true,"path":"2023/08/28/nodejs-5/","link":"","permalink":"http://hgko1207.github.io/2023/08/28/nodejs-5/","excerpt":"","text":"Node.js는 Chrome의 V8 JavaScript 엔진을 기반으로 구축된 이벤트 중심의 non-blocking I/O 플랫폼입니다. 웹 서버를 포함하여 확장 가능한 네트워크 애플리케이션을 구축하는 데 널리 사용됩니다. 이러한 애플리케이션을 구축할 때 콜백 지옥(callback hell) 문제가 발생할 수 있습니다. 이는 여러 개의 중첩된 콜백이 있어 코드를 읽고 유지 관리하기 어렵게 만드는 문제를 의미합니다. 이 글에서는 Express 웹 프레임워크와 TypeScript를 사용하여 Node.js 애플리케이션을 구축할 때 콜백 지옥을 피하는 방법에 대해 설명합니다. Promises Promises 은 보다 읽기 쉽고 관리하기 쉬운 방식으로 비동기 작업을 처리하는 방법입니다. 이는 아직 사용할 수 없지만 미래에는 사용할 수 있는 값을 나타냅니다. Promise를 서로 연결하면 여러 비동기 작업을 순차적으로 처리할 수 있습니다. Node.js에서 Promise를 사용하는 예는 다음과 같습니다. 123456789101112131415function getData() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Data received!'); &#125;, 1000); &#125;);&#125;getData() .then((data) =&gt; &#123; console.log(data); &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); 이 예에서 getData 는 1초 후에 해결되는 약속을 반환합니다. 그런 다음 .then 메서드를 사용하여 확인된 값을 처리하고 .catch 메서드를 사용하여 오류를 처리할 수 있습니다. Async/Await Async/await 는 Promise 위에 추가되는 Syntatic Sugar(문법 설탕) 으로, 비동기 작업 작업을 더 쉽게 만듭니다. 이를 통해 동기적으로 보이는 비동기 코드를 작성할 수 있으므로 읽고 유지하기가 더 쉬워집니다. 컴퓨터 과학에서 Syntactic sugar(구문 설탕)은 더 쉽게 읽거나 표현하도록 설계된 프로그래밍 언어 내의 구문입니다. 그것은 인간이 사용하기에 언어를 &quot;더 달콤&quot;하게 만듭니다. 사물을 더 명확하고 간결하게 표현하거나 일부 사람들이 선호하는 대체 스타일로 표현할 수 있습니다. 위키백과 Node.js에서 async/await를 사용하는 예는 다음과 같습니다. 123456789101112131415161718function getData() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Data received!'); &#125;, 1000); &#125;);&#125;async function main() &#123; try &#123; const data = await getData(); console.log(data); &#125; catch (error) &#123; console.error(error); &#125;&#125;main(); 이 예에서 main 은 wait 키워드를 사용하여 getData 함수의 확인된 값을 기다리는 비동기 함수입니다. try/catch 블록을 사용하여 오류를 처리할 수 있습니다. Promisify Promisify는 callback-based 함수를 promise-based 함수로 변환할 수 있도록 Node.js에서 제공하는 유틸리티 함수입니다. 이는 Promise를 사용하지 않는 오래된 라이브러리나 모듈로 작업할 때 유용할 수 있습니다. Node.js에서 promisify를 사용하는 예는 다음과 같습니다. 123456789101112131415const fs = require('fs');const &#123; promisify &#125; = require('util');const readFile = promisify(fs.readFile);async function main() &#123; try &#123; const data = await readFile('file.txt', 'utf8'); console.log(data); &#125; catch (error) &#123; console.error(error); &#125;&#125;main(); 예에서는 util.promisify 를 사용하여 Node.js의 fs.readFile 함수를 promise-based 함수로 변환합니다. 그런 다음 Promise 기반 함수를 사용하여 file.txt 파일의 내용을 읽습니다. Use Control Flow Libraries 복잡한 비동기 코드로 작업하는 경우 Promise와 async/await 만으로는 코드를 깔끔하고 유지 관리하기 쉽도록 유지하는 데 충분하지 않다는 것을 알 수 있습니다. 이 경우 제어 흐름(flow library) 라이브러리를 사용하여 비동기 코드를 관리하는 데 도움을 받을 수 있습니다. 제어 흐름 라이브러리는 비동기 작업의 흐름을 관리하는 방법을 제공하여 해당 작업이 올바른 순서로 실행되고 오류가 적절하게 처리되도록 합니다. Node.js의 인기 있는 제어 흐름 라이브러리로는 Async, Bluebird 및 Q가 있습니다. 다음은 Async 라이브러리를 사용하여 일련의 비동기 작업을 관리하는 방법에 대한 예입니다. 1234567891011121314151617181920212223const async = require('async');const fs = require('fs');async.series( [ (callback) =&gt; &#123; fs.readFile('file1.txt', 'utf8', callback); &#125;, (callback) =&gt; &#123; fs.readFile('file2.txt', 'utf8', callback); &#125;, (callback) =&gt; &#123; fs.readFile('file3.txt', 'utf8', callback); &#125;, ], (error, results) =&gt; &#123; if (error) &#123; console.error(error); &#125; else &#123; console.log(results); &#125; &#125;); 이 예에서는 async.series 메서드를 사용하여 일련의 비동기 작업(이 경우 세 파일의 내용 읽기)을 순서대로 실행합니다. 모든 작업이 완료되면 최종 콜백이 호출되고 결과 배열을 받습니다. 결론 콜백 지옥은 Node.js에서 비동기 코드 작업을 어렵고 실망스럽게 만들 수 있지만, 이를 방지하기 위해 사용할 수 있는 많은 전략은 위과 같습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"callback","slug":"callback","permalink":"http://hgko1207.github.io/tags/callback/"},{"name":"Promise","slug":"Promise","permalink":"http://hgko1207.github.io/tags/Promise/"},{"name":"Async/Await","slug":"Async-Await","permalink":"http://hgko1207.github.io/tags/Async-Await/"},{"name":"콜백","slug":"콜백","permalink":"http://hgko1207.github.io/tags/%EC%BD%9C%EB%B0%B1/"}]},{"title":"C# and .NET Core 멀티스레딩(multithreading)","slug":"csharp-3","date":"2023-08-27T12:44:48.000Z","updated":"2024-01-12T08:17:04.156Z","comments":true,"path":"2023/08/27/csharp-3/","link":"","permalink":"http://hgko1207.github.io/2023/08/27/csharp-3/","excerpt":"","text":"멀티스레딩은 프로그램을 여러 스레드로 나누는 방식을 의미하며, 각 스레드는 독립적으로 동시에 실행될 수 있습니다. 이로 인해 특히 I/O 또는 네트워크 통신과 같은 작업의 경우 성능과 응답성이 향상될 수 있습니다. C# 및 .NET Core에서는 System.Threading 네임스페이스를 사용하여 스레드를 만들고 관리할 수 있습니다. 다음은 Thread 클래스를 사용하여 C#에서 새 스레드를 만드는 예입니다. 12345678910111213141516using System;using System.Threading;class Program &#123; static void Main(string[] args) &#123; Thread thread = new Thread(new ThreadStart(Worker)); thread.Start(); Console.WriteLine(\"Main thread is running.\"); Console.ReadLine(); &#125; static void Worker() &#123; Console.WriteLine(\"Worker thread is running.\"); &#125;&#125; 이 예제에서는 Thread 클래스를 사용하여 새 스레드를 만들고 Worker 메서드에 대리자를 전달합니다. 그런 다음 Start 메서드를 사용하여 스레드를 시작하고 Worker 메서드는 Main 메서드와 동시에 실행됩니다. 이 프로그램을 실행하면 다음과 같은 출력이 표시됩니다. 12Main thread is running.Worker thread is running. .NET Core는 다중 스레드 코드 작업을 위한 다양한 클래스와 구문도 제공합니다. 그중 하나는 병렬 작업을 실행하는 간단한 방법을 제공하는 TPL(작업 병렬 라이브러리)입니다. 다음은 TPL을 사용하여 병렬 루프를 실행하는 예입니다. 1234567891011using System;using System.Threading.Tasks;class Program &#123; static void Main(string[] args) &#123; Parallel.For(0, 10, i =&gt; &#123; Console.WriteLine(\"Processing item &#123;0&#125; on thread &#123;1&#125;\", i, Task.CurrentId); &#125;); Console.ReadLine(); &#125;&#125; 이 예제에서는 Parallel.For 메서드를 사용하여 루프를 병렬로 실행하며 각 반복은 별도의 스레드에서 실행됩니다. Task.CurrentId 속성을 사용하여 현재 반복을 실행하는 스레드의 ID를 표시합니다. 이 프로그램을 실행하면 다음과 유사한 출력이 표시됩니다. 12345678910Processing item 0 on thread 4Processing item 1 on thread 6Processing item 2 on thread 5Processing item 3 on thread 7Processing item 4 on thread 8Processing item 5 on thread 4Processing item 6 on thread 6Processing item 7 on thread 5Processing item 8 on thread 7Processing item 9 on thread 8 이는 C# 및 .NET Core가 다중 스레드 프로그래밍을 지원하는 다양한 방식 중 작은 예일뿐입니다. 이미지 처리 또는 비디오 트랜스코딩과 같이 CPU를 많이 사용하는 장기 실행 작업을 수행해야 하는 웹 API가 있는 시나리오를 생각해 보세요. 메인 스레드에서 이 작업을 수행하면 다른 수신 요청이 차단되고 API의 응답 속도가 느려집니다. 이 문제를 해결하려면 멀티스레딩을 사용하여 별도의 스레드에서 작업을 수행하고 기본 스레드가 들어오는 요청을 처리할 수 있도록 남겨둘 수 있습니다. 다음은 작업 병렬 라이브러리를 사용하여 .NET Core 웹 API에서 이를 달성할 수 있는 방법의 예입니다. 12345678910111213141516171819202122using System.Threading.Tasks;using Microsoft.AspNetCore.Mvc;[ApiController][Route(\"[controller]\")]public class ImageController : ControllerBase &#123; [HttpPost] public async Task&lt;IActionResult&gt; ProcessImage() &#123; // Parse incoming request and extract image data // ... // Start processing on a separate thread Task&lt;byte[]&gt; task = Task.Run(() =&gt; &#123; // Perform CPU-intensive image processing // ... return processedImageData; &#125;); // Return a response immediately, while the image is being processed return await task; &#125;&#125; 이 예에서는 이미지 데이터가 포함된 수신 HTTP POST 요청을 처리하는 웹 API 컨트롤러에 ProcessImage 작업 메서드를 정의합니다. 그런 다음 별도의 스레드에서 지정된 대리자를 실행하는 새 Task을 만드는 Task.Run 메서드를 사용하여 별도의 스레드에서 이미지 처리를 시작합니다. 처리가 완료될 때까지 기다리고 처리된 이미지 데이터를 반환하기 위해 wait 키워드를 사용하여 Task를 응답으로 즉시 반환합니다. 이 방식을 사용하면 웹 API의 기본 스레드가 들어오는 요청에 계속 응답하는 동시에 이미지 처리가 별도의 스레드에서 수행됩니다. 이는 API의 전반적인 성능과 확장성을 향상시키는 데 도움이 될 수 있습니다. 첫 번째 예에서는 System.Threading 네임스페이스를 사용하여 C# 및 .NET Core에서 스레드를 만들고 관리하는 방법을 살펴보았습니다. 우리는 새로운 스레드를 생성하고 해당 스레드에서 별도의 메서드를 실행하는 간단한 프로그램을 만들었습니다. 이를 통해 두 개의 별도 코드 조각을 동시에 실행할 수 있어 특정 시나리오에서 성능과 응답성을 향상시킬 수 있습니다. 두 번째 예에서는 .NET Core 웹 API에서 고급 멀티스레딩 기술을 사용하는 방법을 살펴보았습니다. 우리는 Task Parallel 라이브러리를 사용하여 별도의 스레드에서 long-running, CPU-intensive 작업을 시작하는 동시에 기본 스레드는 들어오는 요청을 처리할 수 있도록 자유롭게 유지했습니다. 이는 특히 long-running 작업으로 인해 들어오는 요청이 차단될 수 있는 시나리오에서 API의 전반적인 성능과 확장성을 개선하는 데 도움이 될 수 있습니다. 전반적으로 멀티스레딩은 C# 및 .NET Core 애플리케이션의 성능과 응답성을 향상시키는 강력한 도구가 될 수 있습니다. 그러나 이를 현명하게 사용하고 복잡성 증가, 잠재적 경합 조건 또는 동기화 문제, 리소스 사용량 증가와 같은 잠재적인 절충안을 이해하는 것이 중요합니다. 특정 시나리오에 적합한 스레딩 구성 및 기술을 사용하면 이러한 잠재적 위험을 피하면서 멀티스레딩의 이점을 활용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"multithreading","slug":"multithreading","permalink":"http://hgko1207.github.io/tags/multithreading/"},{"name":"Thread","slug":"Thread","permalink":"http://hgko1207.github.io/tags/Thread/"}]},{"title":"[Angular] 재사용 가능한 컴포넌트(Component)","slug":"angular-16","date":"2023-08-26T06:33:52.000Z","updated":"2024-01-12T08:15:56.431Z","comments":true,"path":"2023/08/26/angular-16/","link":"","permalink":"http://hgko1207.github.io/2023/08/26/angular-16/","excerpt":"","text":"웹 애플리케이션 구축에 Angular를 사용하는 주요 이점 중 하나는 재사용 가능한 컴포넌트를 생성할 수 있다는 것입니다. 이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보겠습니다. 1. Component Structure Angular에서 재사용 가능한 컴포넌트를 만들려면 다양한 상황에서 쉽게 사용할 수 있는 방식으로 컴포넌트를 구성하는 것이 중요합니다. 컴포넌트에는 입력 및 출력 속성이 잘 정의된 명확한 API가 있어야 하며 다양한 사용 사례를 처리할 수 있을 만큼 유연해야 합니다. 다음은 항목 목록을 표시하는 재사용 가능한 간단한 컴포넌트의 예입니다. 12345678910111213import &#123; Component, Input &#125; from '@angular/core';@Component(&#123; selector: 'app-item-list', template: ` &lt;ul&gt; &lt;li *ngFor=\"let item of items\"&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; `,&#125;)export class ItemListComponent &#123; @Input() items: string[];&#125; 이 예에서 ItemListComponent 에는 문자열 배열인 항목이라는 Single Input 속성이 있습니다. 컴포넌트는 *ngFor 지시문을 사용하여 items 배열을 반복하고 목록의 각 항목을 표시합니다. 2. Input and Output Properties 입력 및 출력 속성은 Angular에서 재사용 가능한 컴포넌트를 만드는 데 중요한 부분입니다. Input 속성을 사용하면 상위 컴포넌트에서 데이터를 컴포넌트로 전달할 수 있고, Output 속성을 사용하면 컴포넌트에서 상위 컴포넌트로 이벤트를 내보낼 수 있습니다. 다음은 사용자가 목록에서 값을 선택할 수 있도록 하는 재사용 가능한 컴포넌트의 예입니다. 123456789101112131415import &#123; Component, Input, Output, EventEmitter &#125; from '@angular/core';@Component(&#123; selector: 'app-select', template: ` &lt;select [ngModel]=\"selectedValue\" (ngModelChange)=\"selectValue.emit($event)\"&gt; &lt;option *ngFor=\"let option of options\" [value]=\"option\"&gt;&#123;&#123; option &#125;&#125;&lt;/option&gt; &lt;/select&gt; `,&#125;)export class SelectComponent &#123; @Input() options: string[]; @Input() selectedValue: string; @Output() selectValue = new EventEmitter&lt;string&gt;();&#125; 이 예에서 SelectComponent 에는 두 개의 입력 속성인 options 와 selectedValue 와 하나의 출력 속성인 selectValue 가 있습니다. 컴포넌트는 ngModel 지시문을 사용하여 선택한 값을 selectedValue 속성에 바인딩하고 사용자가 목록에서 새 값을 선택할 때 selectValue 이벤트를 발생시킵니다. 3. Content Projection 콘텐츠 프로젝션은 Angular에서 재사용 가능한 컴포넌트를 구축하는 또 다른 주요 기능입니다. 콘텐츠 프로젝션을 통해 컴포넌트는 상위 항목의 임의 콘텐츠를 허용할 수 있으며, 이는 컴포넌트의 모양이나 동작을 사용자 지정하는 데 사용할 수 있습니다. 콘텐츠 프로젝션의 예는 다음과 같습니다. 1234567891011121314151617181920212223242526import &#123; Component, Input &#125; from '@angular/core';@Component(&#123; selector: 'app-section', template: ` &lt;div class=\"section\"&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/div&gt; `, styles: [ ` .section &#123; border: 1px solid black; padding: 10px; margin-bottom: 20px; &#125; h2 &#123; margin-bottom: 10px; &#125; `, ],&#125;)export class SectionComponent &#123; @Input() title: string;&#125; 123456789101112131415161718import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-parent', template: ` &lt;app-section title=\"Section 1\"&gt; &lt;p&gt;Content for section 1 goes here.&lt;/p&gt; &lt;/app-section&gt; &lt;app-section title=\"Section 2\"&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; &lt;/app-section&gt; `,&#125;)export class ParentComponent &#123;&#125; title 이 상위 컴포넌트에서 전달될 수 있도록 title 속성에 @Input 데코레이터를 추가했습니다. SectionComponent 템플릿은 보간을 사용하여 제목을 표시하고 ng-content 지시문은 상위 컴포넌트의 임의 콘텐츠를 투영하는 데 사용됩니다. 각 SectionComponent 인스턴스에 대한 입력으로 제목을 전달하고 있으며, 각 섹션의 콘텐츠는 ng-content 지시어를 사용하여 상위 컴포넌트에서 투영됩니다. 결론 이 글에서는 컴포넌트 구조, 입력 및 출력 속성, 콘텐츠 프로젝션을 포함하여 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하기 위한 사례를 살펴보았습니다. 또한 이러한 기능을 사용하여 다양한 상황에서 사용할 수 있는 간단한 재사용 가능한 컴포넌트를 만드는 방법에 대한 몇 가지 예도 살펴보았습니다. 이러한 사례를 따르면 사용 및 유지 관리가 쉽고 Angular 애플리케이션의 전반적인 품질을 향상하는 데 도움이 되는 컴포넌트를 만들 수 있습니다. Angular에서 재사용 가능한 컴포넌트를 사용하는 주요 이점 중 하나는 코드 중복을 줄이고 코드 유지 관리성을 높이는 기능입니다. 잘 설계되고 잘 문서화된 컴포넌트 세트를 만들면 다른 개발자가 우리 애플리케이션에서 더 쉽게 작업할 수 있을 뿐만 아니라 시간이 지남에 따라 코드를 더 쉽게 유지 관리하고 업데이트할 수도 있습니다. 전반적으로 Angular를 사용하여 재사용 가능한 컴포넌트를 구축하는 것은 웹 애플리케이션의 품질과 유지 관리성을 향상시키는 강력한 기술입니다. 이러한 사례를 따르고 다양한 컴포넌트 디자인을 실험함으로써 다양한 웹 애플리케이션을 구축하는 데 사용할 수 있는 강력하고 유연한 컴포넌트 세트를 만들 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"}]},{"title":"[Angular] 애니메이션(Animation) 설명","slug":"angular-15","date":"2023-08-25T13:36:44.000Z","updated":"2023-12-04T07:21:38.585Z","comments":true,"path":"2023/08/25/angular-15/","link":"","permalink":"http://hgko1207.github.io/2023/08/25/angular-15/","excerpt":"","text":"Angular는 동적 웹 애플리케이션을 생성하기 위한 다양한 도구와 기능을 제공하는 강력한 JavaScript 프레임워크입니다. Angular의 주요 기능 중 하나는 애니메이션을 만드는 기능입니다. Angular 애니메이션은 움직임, 전환 및 기타 시각 효과를 추가하여 웹 애플리케이션에 생기를 불어넣는 방법을 제공합니다. 이 글에서는 interfaces, functions, classes, type aliases 및 lifecycle hooks 등을 포함하여 Angular 애니메이션의 다양한 측면을 다룰 것입니다. Animations Module Angular 애니메이션 모듈은 Angular 애플리케이션에서 애니메이션을 정의하고 관리하는 기본 모듈입니다. 복잡하고 아름다운 애니메이션을 만드는 데 사용할 수 있는 다양한 인터페이스, 클래스 및 기능을 제공합니다. Animation Metadata AnimationMetadata 인터페이스는 애니메이션 메타데이터를 정의하는 데 사용되는 기본 인터페이스입니다. AnimationStyleMetadata, AnimationKeyframesSequenceMetadata 및 AnimationAnimateMetadata를 포함한 여러 하위 인터페이스가 있습니다. 이러한 인터페이스는 생성할 수 있는 다양한 유형의 애니메이션을 정의하는 데 사용됩니다. AnimationStyleMetadata AnimationStyleMetadata 인터페이스는 애니메이션 스타일을 정의하는 데 사용됩니다. 여기에는 애니메이션의 타이밍과 모양을 정의하는 데 사용할 수 있는 offset, style 및 animateChild 와 같은 속성이 있습니다. AnimationKeyframesSequenceMetadata AnimationKeyframesSequenceMetadata 인터페이스는 애니메이션 키프레임 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 키프레임과 옵션을 정의하는 데 사용할 수 있는 steps 및 options 과 같은 속성이 있습니다. AnimationAnimateMetadata AnimationAnimateMetadata 인터페이스는 애니메이션 시퀀스를 정의하는 데 사용됩니다. 여기에는 애니메이션의 스타일, 키프레임 및 옵션을 정의하는 데 사용할 수 있는 style, keyframes 및 options 과 같은 속성이 있습니다. AnimationTriggerMetadata AnimationTriggerMetadata 인터페이스는 애니메이션 트리거를 정의하는 데 사용됩니다. 여기에는 트리거 이름, 애니메이션 정의 및 트리거 옵션을 정의하는 데 사용할 수 있는 name, definitions 및 options 과 같은 속성이 있습니다. AnimationBuilder AnimationBuilder 클래스는 애니메이션을 생성하고 구성하는 데 사용됩니다. 여기에는 애니메이션 시퀀스를 사용자에 맞게 사용할 수 있는 build, before, after 및 delay 과 같은 메서드가 있습니다. AnimationFactory AnimationFactory 클래스는 애니메이션 팩토리를 만드는 데 사용됩니다. 여기에는 새 애니메이션 팩토리를 만드는 데 사용할 수 있는 create 와 같은 메서드가 있습니다. AnimationPlayer AnimationPlayer 클래스는 애니메이션을 관리하는 데 사용됩니다. 여기에는 애니메이션 수명주기를 관리하는 데 사용할 수 있는 play, pause, reset, finish 와 같은 메서드가 있습니다. AnimationEvent AnimationEvent 클래스는 애니메이션 이벤트를 나타내는 데 사용됩니다. 여기에는 애니메이션 이벤트에 대한 정보를 검색하는 데 사용할 수 있는 fromState, toState 및 totalTime 과 같은 속성이 있습니다. AnimationDriver AnimationDriver 인터페이스는 애니메이션 드라이버를 정의하는 데 사용됩니다. 여기에는 애니메이션을 생성하고 관리하는 데 사용할 수 있는 animate, Listen 및 Flush 와 같은 메서드가 있습니다. Animation Types Angular는 역동적이고 매력적인 웹 애플리케이션을 만드는 데 사용할 수 있는 다양한 유형의 애니메이션을 제공합니다. 이러한 애니메이션 유형은 다음과 같습니다. Transition Animation Transition Animation은 상태나 뷰 간의 원활한 전환을 만드는 데 사용됩니다. fades, slides, rotations 과 같은 애니메이션을 만드는 데 사용할 수 있습니다. Animation Sequencing Animation Sequencing은 특정 순서로 발생하는 애니메이션을 만드는 데 사용됩니다. 여러 단계나 시퀀스가 포함된 복잡한 애니메이션을 만드는 데 사용할 수 있습니다. Keyframe Animation Keyframe Animation은 특정 키프레임이나 시점에 발생하는 애니메이션을 만드는 데 사용됩니다. 진동하는 버튼이나 깜박이는 배너와 같은 애니메이션을 만드는 데 사용할 수 있습니다. State Change Animation 상태 변경 애니메이션은 상태가 변경될 때 발생하는 애니메이션을 만드는 데 사용됩니다. 확인란을 전환하거나 패널을 확장하는 등의 애니메이션을 만드는 데 사용할 수 있습니다. Animations Interfaces 앞서 설명한 AnimationMetadata 및 AnimationTriggerMetadata 인터페이스 외에도 Angular에서 애니메이션을 만드는 데 사용할 수 있는 다른 인터페이스가 몇 가지 있습니다. 이러한 인터페이스에는 다음이 포함됩니다. AnimationStateMetadata AnimationStateMetadata 인터페이스는 애니메이션 상태를 정의하는 데 사용됩니다. 여기에는 상태 이름과 스타일을 정의하는 데 사용할 수 있는 name 및 style 과 같은 속성이 있습니다. AnimationTransitionMetadata AnimationTransitionMetadata 인터페이스는 애니메이션 전환을 정의하는 데 사용됩니다. 여기에는 한 상태에서 다른 상태로의 전환을 정의하는 데 사용할 수 있는 fromState, toState 및 animation 과 같은 속성이 있습니다. AnimationQueryMetadata AnimationQueryMetadata 인터페이스는 애니메이션 쿼리를 정의하는 데 사용됩니다. 여기에는 쿼리에 대한 선택기, 애니메이션 및 제한을 정의하는 데 사용할 수 있는 selector, animation 및 limit 과 같은 속성이 있습니다. AnimationStaggerMetadata AnimationStaggerMetadata 인터페이스는 애니메이션 스태거를 정의하는 데 사용됩니다. 여기에는 애니메이션 순서와 타이밍을 정의하는 데 사용할 수 있는 animate, start, interval 및 by 과 같은 속성이 있습니다. AnimationGroupMetadata AnimationGroupMetadata 인터페이스는 애니메이션 그룹을 정의하는 데 사용됩니다. 여기에는 애니메이션 그룹의 단계를 정의하는 데 사용할 수 있는 steps 와 같은 속성이 있습니다. Animation Functions Angular는 애니메이션을 만드는 데 사용할 수 있는 여러 내장 함수를 제공합니다. 이러한 기능에는 다음이 포함됩니다. animate() animate() 함수는 키프레임 애니메이션을 만드는 데 사용됩니다. 지속 시간과 일련의 키프레임을 매개변수로 사용합니다. transition() transition() 함수는 전환 애니메이션을 생성하는 데 사용됩니다. 두 가지 상태, 스타일 세트, 선택적 타이밍 기능을 매개변수로 사용합니다. trigger() trigger() 함수는 애니메이션 트리거를 정의하는 데 사용됩니다. 이름과 일련의 애니메이션 정의를 매개변수로 사용합니다. Animation Enums Angular는 애니메이션을 구성하는 데 사용할 수 있는 여러 열거형도 제공합니다. 이러한 열거형에는 다음이 포함됩니다. AnimationStyleMetadata AnimationStyleMetadata 열거형은 애니메이션의 타이밍과 모양을 정의하는 데 사용됩니다. 여기에는 애니메이션의 모양과 타이밍을 정의하는 데 사용할 수 있는 opacity, transform 및 display 와 같은 속성이 있습니다. AnimationMetadataType AnimationMetadataType 열거형은 애니메이션 메타데이터 유형을 정의하는 데 사용됩니다. 여기에는 다양한 유형의 애니메이션 메타데이터에 해당하는 Style, Keyframes, Animate 과 같은 값이 있습니다. Animation Consts 마지막으로 Angular는 애니메이션을 구성하는 데 사용할 수 있는 몇 가지 내장 상수를 제공합니다. 이러한 상수에는 다음이 포함됩니다. AUTO_STYLE AUTO_STYLE 상수는 요소의 스타일을 자동 스타일로 설정하는 데 사용됩니다. 요소의 자연 상태에 적응하는 동적 애니메이션을 만드는 데 사용할 수 있습니다. TIME TIME 상수는 애니메이션의 타이밍을 설정하는 데 사용됩니다. 특정 기간 동안 발생하는 애니메이션을 만드는 데 사용할 수 있습니다. Animation Lifecycle Hooks Angular는 애니메이션을 제어하는 데 사용할 수 있는 여러 수명 주기 후크를 제공합니다. 이러한 후크에는 다음이 포함됩니다. AnimationStart AnimationStart Hook 는 애니메이션 재생이 시작될 때 호출됩니다. AnimationDone AnimationDone Hook 는 애니메이션이 완료되면 호출됩니다. AnimationDestroy AnimationDestroy Hook 는 애니메이션이 삭제될 때 호출됩니다. 이러한 Hook 를 사용하면 애니메이션이 완료될 때 다른 애니메이션을 시작하거나 중지하는 등의 추가 작업을 수행할 수 있습니다. Animation Testing Angular는 단위 및 통합 테스트에서 애니메이션을 테스트하기 위한 여러 도구를 제공합니다. 이러한 도구에는 다음이 포함됩니다. MockAnimationPlayer MockAnimationPlayer 클래스는 테스트에 사용할 수 있는 모의 애니메이션 플레이어를 만드는 데 사용됩니다. 애니메이션 재생, 일시정지, 완료 등 애니메이션을 시뮬레이션하는 방법을 제공합니다. NoopAnimationsModule NoopAnimationsModule은 테스트에서 애니메이션을 비활성화하는 데 사용됩니다. 실제로 애니메이션을 실행하지 않고 애니메이션을 사용하는 컴포넌트를 테스트하는 데 사용할 수 있습니다. 다음은 Angular 애니메이션의 사용을 보여주는 예입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component, OnInit &#125; from '@angular/core';import &#123; trigger, state, style, transition, animate, AnimationEvent, AnimationBuilder, AnimationFactory, AnimationPlayer,&#125; from '@angular/animations';@Component(&#123; selector: 'app-animation-example', template: ` &lt;div (click)=\"toggleState()\" [@myTrigger]=\"currentState\"&gt; &#123;&#123; currentState &#125;&#125; &lt;/div&gt; `, animations: [ trigger('myTrigger', [ state('one', style(&#123; transform: 'translateX(0)' &#125;)), state('two', style(&#123; transform: 'translateX(100%)' &#125;)), transition('one =&gt; two', animate('500ms ease-in')), transition('two =&gt; one', animate('500ms ease-out')), ]), ],&#125;)export class AnimationExampleComponent implements OnInit &#123; currentState = 'one'; private player: AnimationPlayer; constructor(private builder: AnimationBuilder) &#123;&#125; ngOnInit(): void &#123; this.createPlayer(); &#125; toggleState(): void &#123; this.currentState = this.currentState === 'one' ? 'two' : 'one'; this.player.play(); &#125; private createPlayer(): void &#123; const factory: AnimationFactory = this.builder.build([style(&#123; opacity: 0 &#125;), animate('1s', style(&#123; opacity: 1 &#125;))]); this.player = factory.create(document.querySelector('div')); this.player.play(); &#125; onAnimationStart(event: AnimationEvent): void &#123; console.log(`Animation started: $&#123;event.triggerName&#125;`); &#125; onAnimationDone(event: AnimationEvent): void &#123; console.log(`Animation ended: $&#123;event.triggerName&#125;`); &#125;&#125; 이 예에는 [@myTrigger] 애니메이션 트리거를 사용하여 두 상태 간을 전환하는 간단한 컴포넌트가 있습니다. 트리거 이름과 상태 및 전환 배열을 사용하는 trigger() 함수를 사용하여 트리거를 정의합니다. 또한 컴포넌트에 대한 페이드인 애니메이션을 생성하는 AnimationBuilder 클래스를 사용하여 두 번째 애니메이션을 정의합니다. 컴포넌트가 초기화되면 AnimationFactory 클래스와 AnimationBuilder 를 사용하여 AnimationPlayer 클래스의 인스턴스를 만듭니다. 이 플레이어를 사용하여 컴포넌트가 로드될 때 페이드인 애니메이션을 재생합니다. 사용자가 컴포넌트를 클릭하면 현재 상태를 전환하고 AnimationPlayer 를 사용하여 전환 애니메이션을 재생합니다. 마지막으로 애니메이션이 시작되고 끝날 때 각각 호출되는 onAnimationStart 및 onAnimationDone 이라는 두 개의 수명 주기 Hook 를 정의합니다. 이 예에서는 이러한 Hook 가 호출될 때 콘솔에 메시지를 기록합니다. 다음은 Angular 애니메이션을 사용하여 커스터마이징 애니메이션 로딩 스피너를 만드는 방법을 보여주는 좀 더 복잡한 예입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import &#123; Component, Input, OnInit &#125; from '@angular/core';import &#123; trigger, style, animate, transition, keyframes, AnimationBuilder, AnimationFactory, AnimationPlayer,&#125; from '@angular/animations';@Component(&#123; selector: 'app-spinner', template: ` &lt;div class=\"spinner\" *ngIf=\"show\"&gt; &lt;div class=\"bar\" *ngFor=\"let bar of bars; let i = index\" [@loadingState]=\"i + 1\"&gt;&lt;/div&gt; &lt;/div&gt; `, styles: [ ` .spinner &#123; display: flex; justify-content: center; align-items: center; height: 100%; &#125; .bar &#123; width: 5px; height: 20px; margin: 0 5px; border-radius: 2px; &#125; `, ], animations: [ trigger('loadingState', [ transition( '* =&gt; 1', animate( '&#123;&#123;duration&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 2', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 3', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 4', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), transition( '* =&gt; 5', animate( '&#123;&#123;duration&#125;&#125; &#123;&#123;delay&#125;&#125;', keyframes([ style(&#123; transform: 'scaleY(0)', offset: 0 &#125;), style(&#123; transform: 'scaleY(1)', offset: 0.5 &#125;), style(&#123; transform: 'scaleY(0)', offset: 1 &#125;), ]) ) ), ]), ],&#125;)export class SpinnerComponent implements OnInit &#123; @Input() duration = '500ms'; @Input() delay = '100ms'; @Input() count = 5; show = false; bars: number[] = []; constructor(private builder: AnimationBuilder) &#123;&#125; ngOnInit(): void &#123; this.bars = new Array(this.count).fill(0); this.show = true; this.createPlayer(); &#125; private createPlayer(): void &#123; const factory: AnimationFactory = this.builder.build([ style(&#123; opacity: 0 &#125;), animate('1s', style(&#123; opacity: 1 &#125;)), animate('1s', style(&#123; opacity: 0 &#125;)), ]); this.player = factory.create(document.querySelector('.spinner')); this.player.onDone(() =&gt; (this.show = false)); this.player.play(); &#125;&#125; 이 예에는 사용자에 맞게 애니메이션 로딩 스피너를 표시하는 컴포넌트가 있습니다. 스피너는 순차적으로 펄스 및 크기 증가 및 감소하는 5개의 수직 막대로 구성됩니다. 애니메이션 키프레임을 지정하기 위해 trigger() 함수와 keyframes() 함수를 사용하여 애니메이션을 정의합니다. 결론 요약하면 Angular는 웹 애플리케이션에서 애니메이션을 생성, 제어 및 테스트하기 위한 포괄적인 도구 세트를 제공합니다. 이러한 도구에는 사용자 경험을 향상하고 애플리케이션에 생명을 불어넣는 복잡하고 매력적인 애니메이션을 만드는 데 사용할 수 있는 interfaces, functions, classes, type aliases 및 lifecycle hooks 가 포함됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"애니메이션","slug":"애니메이션","permalink":"http://hgko1207.github.io/tags/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/"}]},{"title":"[Angular] 성능 최적화(Performance optimization)","slug":"angular-14","date":"2023-08-25T05:31:23.000Z","updated":"2024-01-12T08:14:29.301Z","comments":true,"path":"2023/08/25/angular-14/","link":"","permalink":"http://hgko1207.github.io/2023/08/25/angular-14/","excerpt":"","text":"Angular는 개발자가 고성능 웹 애플리케이션을 구축하는 데 도움을 줄 수 있는 강력한 프런트 엔드 프레임워크입니다. 그러나 애플리케이션이 복잡해짐에 따라 원하는 수준의 성능을 유지하는 것이 더욱 어려워질 수 있습니다. 이 글에서는 Angular 성능을 최적화하는 몇 가지 기술을 살펴보겠습니다. 1. 지연 로딩 모듈(Lazy Loading Modules) 애플리케이션 성능이 저하되는 주요 이유 중 하나는 애플리케이션을 로드하는 데 걸리는 시간입니다. 이 문제를 해결하는 한 가지 방법은 지연 로딩을 사용하는 것입니다. 지연 로딩은 특정 경로에 필요한 모듈만 로드하는 기술입니다. 즉, 초기 로드 시간이 줄어들고 애플리케이션의 응답 속도가 빨라집니다. 다음은 Angular 애플리케이션에서 지연 로딩을 구현하는 방법에 대한 예입니다. 123456const routes: Routes = [ &#123; path: 'admin', loadChildren: () =&gt; import('./admin/admin.module').then((m) =&gt; m.AdminModule), &#125;,]; 이 예에서는 admin 경로에 액세스할 때 AdminModule 모듈을 지연 로딩합니다. 이 모듈은 필요할 때만 로드되므로 애플리케이션의 초기 로드 시간을 줄이는 데 도움이 됩니다. 2. 변화 감지 전략(Change Detection Strategies) Angular는 변경 감지를 사용하여 데이터 변경 사항을 추적하고 그에 따라 뷰를 업데이트합니다. 기본적으로 Angular는 모든 변경 감지 주기에서 모든 컴포넌트를 확인하는 Default 라는 전략을 사용합니다. 특히 컴포넌트가 많은 대규모 애플리케이션의 경우 비용이 매우 많이 들 수 있습니다. 이 문제를 해결하기 위해 Angular는 몇 가지 변경 감지 전략을 제공합니다. 가장 일반적으로 사용되는 전략은 OnPush 입니다. 이 전략을 사용하면 컴포넌트의 입력 속성이 변경되거나 이벤트가 트리거 될 때만 변경 감지가 실행됩니다. 이를 통해 불필요한 변경 감지 주기 수를 크게 줄일 수 있습니다. 다음은 OnPush 변경 감지 전략을 사용하는 방법에 대한 예입니다. 123456789101112@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html', changeDetection: ChangeDetectionStrategy.OnPush,&#125;)export class MyComponentComponent implements OnInit &#123; @Input() myData: any; constructor() &#123;&#125; ngOnInit(): void &#123;&#125;&#125; 이 예에서는 MyComponentComponent 에 대한 OnPush 변경 감지 전략을 사용하고 있습니다. 즉, 변경 감지는 myData 입력 속성이 변경되거나 이벤트가 트리거 될 때만 실행됩니다. 3. 변경 감지 최적화(Change Detection Optimization) OnPush 변경 감지 전략을 사용하더라도 불필요한 변경 감지 주기로 인해 성능 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해 여러 가지 최적화 기술을 사용할 수 있습니다. a. Immutable Objects 불변 객체(Immutable Objects)는 생성된 후에는 변경할 수 없는 객체입니다. 애플리케이션에서 불변 객체를 사용함으로써 불필요한 변경 감지 주기 수를 줄일 수 있습니다. 변경 감지는 기존 객체가 업데이트될 때가 아니라 새 객체가 생성될 때만 실행되어야 하기 때문입니다. 다음은 Angular 애플리케이션에서 불변 객체를 사용하는 방법에 대한 예입니다. 12345export interface User &#123; readonly id: number; readonly name: string; readonly email: string;&#125; 이 예에서는 readonly 키워드를 사용하여 User 인터페이스의 속성을 변경할 수 없게 만듭니다. b. TrackBy Function trackBy 함수는 Angular에 내장된 최적화 기술입니다. 항목 목록의 변경 사항을 추적하는 방법을 Angular에 알려주는 데 사용됩니다. 기본적으로 Angular는 목록에 있는 각 항목의 ID를 비교하여 변경 사항을 추적합니다. 그러나 이는 특히 큰 목록의 경우 비용이 매우 많이 들 수 있습니다. 다음은 Angular 애플리케이션에서 trackBy 함수를 사용하는 방법에 대한 예입니다. 12345&lt;ul&gt; &lt;li *ngFor=\"let user of users; trackBy: trackByUserId\"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 이 예에서는 trackBy 함수를 사용하여 Angular 에 id 속성으로 users 목록의 변경 사항을 추적하도록 지시합니다. 이는 목록에 있는 항목의 id 속성이 변경될 때만 변경 감지가 실행되어야 함을 의미합니다. 123trackByUserId(index: number, user: User): number &#123; return user.id;&#125; 이 예제에서는 인덱스와 사용자 개체를 가져와 사용자 개체의 id 속성을 반환하는 trackByUserId 함수를 구현합니다. 4. NgZone NgZone 은 Angular 영역 외부에서 코드를 실행하는 방법을 제공하는 Angular 에 내장된 서비스입니다. Angular 영역은 변경 감지 및 기타 Angular 관련 작업을 담당하는 실행 컨텍스트입니다. Angular 영역 외부에서 코드를 실행하면 애플리케이션 성능을 향상시킬 수 있습니다. 다음은 Angular 애플리케이션에서 NgZone을 사용하는 방법에 대한 예입니다. 123456789101112131415import &#123; Component, NgZone &#125; from '@angular/core';@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html',&#125;)export class MyComponentComponent &#123; constructor(private ngZone: NgZone) &#123;&#125; runOutsideAngular(): void &#123; this.ngZone.runOutsideAngular(() =&gt; &#123; // Code to run outside of the Angular zone &#125;); &#125;&#125; 이 예에서는 NgZone 서비스를 사용하여 Angular 영역 외부에서 코드를 실행합니다. runOutsideAngular 메서드를 호출하고 Angular 영역 외부에서 실행되는 코드가 포함된 콜백 함수를 전달하여 이를 수행합니다. 외부 API 에서 일부 데이터를 가져와서 화면에 표시하는 컴포넌트가 있다고 가정해 보겠습니다. API 호출을 완료하는 데 오랜 시간이 걸릴 수 있으며, 이로 인해 애플리케이션이 정지되고 응답하지 않게 될 수 있습니다. 이러한 일이 발생하지 않도록 하려면 NgZone을 사용하여 Angular 영역 외부에서 API 호출을 실행하면 애플리케이션이 계속해서 원활하게 실행될 수 있습니다. 컴포넌트의 코드는 다음과 같습니다. 123456789101112131415161718192021222324252627282930import &#123; Component, NgZone &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Component(&#123; selector: 'app-my-component', templateUrl: './my-component.component.html',&#125;)export class MyComponentComponent &#123; data: any; constructor(private http: HttpClient, private ngZone: NgZone) &#123;&#125; fetchData(): void &#123; // Run the API call outside of the Angular zone this.ngZone.runOutsideAngular(() =&gt; &#123; // Make the API call this.http.get('https://api.example.com/data').subscribe( (data) =&gt; &#123; // Update the data property with the fetched data this.ngZone.run(() =&gt; &#123; this.data = data; &#125;); &#125;, (error) =&gt; &#123; console.error(error); &#125; ); &#125;); &#125;&#125; 이 예에서는 HttpClient 서비스를 사용하여 https://api.example.com/data에 대한 API 호출을 만듭니다. 또한 NgZone 서비스를 사용하여 Angular 영역 외부에서 API 호출을 실행한 다음 Angular 영역 내부에서 가져온 데이터로 data 속성을 업데이트합니다. 이렇게 하면 API 호출이 진행되는 동안 애플리케이션의 응답성이 유지됩니다. 또한 API 호출 중에 발생할 수 있는 모든 오류를 콘솔에 기록하여 처리하고 있습니다. 템플릿에서 이 컴포넌트를 사용하려면 다음과 같이 할 수 있습니다. 123456789&lt;button (click)=\"fetchData()\"&gt;Fetch Data&lt;/button&gt;&lt;div *ngIf=\"data\"&gt; &lt;ul&gt; &lt;li *ngFor=\"let item of data\"&gt; &#123;&#123; item.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 결론 Angular 성능을 최적화하기 위한 몇 가지 기술을 살펴보았습니다. 지연 로딩, 변경 감지 전략, 변경 감지 최적화 기술 및 NgZone을 사용하여 애플리케이션 성능을 향상하고 더 나은 사용자 경험을 제공할 수 있습니다. 성능 최적화는 지속적인 프로세스라는 점을 명심하는 것이 중요하며 잠재적인 개선 영역이 있는지 애플리케이션을 지속적으로 평가해야 합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Performance","slug":"Performance","permalink":"http://hgko1207.github.io/tags/Performance/"}]},{"title":"[C#] 콘솔 프로그램 백그라운드(창 없이) 실행 방법","slug":"csharp-2","date":"2023-07-31T13:25:39.000Z","updated":"2024-01-12T08:13:50.514Z","comments":true,"path":"2023/07/31/csharp-2/","link":"","permalink":"http://hgko1207.github.io/2023/07/31/csharp-2/","excerpt":"","text":"일반적으로 C#에서 외부 프로그램(.exe 등)을 실행시킬 때 Process를 많이 사용합니다. 콘솔(Console; 도스 커맨드 창)로 실행되는 프로그램을 실행하는 경우 콘솔 창이 화면에 나타나서 UI 상으로 불편한 경우가 있습니다. Process로 콘솔 창을 띄우는 외부 프로그램을 실행 시 콘솔 창을 백그라운드로 실행해 안보이도록 하려면 아래와 같이 합니다. 1234567891011121314151617181920212223using System;using System.Diagnostics;namespace Test.Utils&#123; public class Program &#123; public static void Main(string[] args) &#123; string arg = \"...\"; Process process = new Process(); process.StartInfo.FileName = @\".\\ffmpeg.exe\"; process.StartInfo.Arguments = arg; process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; // 윈도우 속성을 windows hidden 으로 지정 process.StartInfo.CreateNoWindow = true; // hidden 을 시키기 위해서 이 속성도 true 로 체크해야 함 process.Start(); process.WaitForExit(); // 종료시까지 대기 &#125; &#125;&#125; 추가로 외부 프로그램에서 출력한 값을 읽어와서 출력하는 방법은 아래와 같습니다. 12345678910111213141516171819202122232425262728using System;using System.Diagnostics;namespace Test.Utils&#123; public class Program &#123; public static void Main(string[] args) &#123; string arg = \"...\"; Process process = new Process(); process.StartInfo.FileName = @\".\\ffmpeg.exe\"; process.StartInfo.Arguments = arg; process.StartInfo.UseShellExecute = false; // 스트림을 읽는데 필요 process.StartInfo.CreateNoWindow = false; process.StartInfo.RedirectStandardOutput = true; // 실행한 프로그램의 출력을 얻는다. process.Start(); process.WaitForExit(); // 종료시까지 대기 string result = process.StandardOutput.ReadToEnd(); // 실행한 프로그램의 출력을 읽는다. Console.WriteLine(\"result =&gt; \" + result); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"콘솔","slug":"콘솔","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%EC%86%94/"},{"name":"백그라운드","slug":"백그라운드","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C/"},{"name":"백그라운드 실행","slug":"백그라운드-실행","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89/"}]},{"title":"[Eclipse] 프로젝트에 jar 파일 추가하는 방법","slug":"eclipse-1","date":"2023-07-29T04:48:04.000Z","updated":"2024-01-12T08:12:40.542Z","comments":true,"path":"2023/07/29/eclipse-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/29/eclipse-1/","excerpt":"","text":"이클립스에서 라이브러리(jar 파일)를 추가하는 방법입니다. 일반적인 자바 프로젝트와 웹 프로젝트일 경우 두 가지로 방법으로 나눠집니다. 자바 프로젝트 1. 프로젝트 우클릭 &gt; properties 2. Java Build Path &gt; Libraries &gt; Add External JARs 3. 폴더에서 jar 파일 선택 4. 라이브러리 추가 후 [Apply and Close] 클릭 웹 프로젝트(Maven) 1. 아래와 같이 src/main/web/WEB-INF/lib 폴더를 생성하고 lib 폴더에 라이브러리 파일을 넣어준다. 2. 프로젝트 우클릭 &gt; properties 3. Java Build Path &gt; Libraries &gt; Add Library 4. Web App Libraries 선택 후 [Next] 클릭 5. 프로젝트 선택 후 [Finish] 클릭 6. Web App Libraries 추가 확인 후 [Apply and Close] 클릭 결론 라이브러리(jar 파일) 추가 후 코드에서 import 해서 사용하시면 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"jar 파일","slug":"jar-파일","permalink":"http://hgko1207.github.io/tags/jar-%ED%8C%8C%EC%9D%BC/"}]},{"title":"자동가입 방지문자(SimpleCaptcha) 사용 방법","slug":"web-1","date":"2023-07-29T04:25:33.000Z","updated":"2024-01-12T08:13:10.946Z","comments":true,"path":"2023/07/29/web-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/29/web-1/","excerpt":"","text":"로그인 또는 회원가입 시 자동 등록 방지가 필요할 경우가 있다. 이를 구현하기 위해 여러 가지가 있는데 CATPCHA를 사용하는 방법을 사용하였다. CAPTCHA는 HIP 기술의 일종으로, 어떠한 사용자가 실제 사람인지 컴퓨터 프로그램인지를 구별하기 위해 사용되는 방법이다. 사람은 구별할 수 있지만 컴퓨터는 구별하기 힘들게 의도적으로 비틀거나 덧칠한 그림을 주고 그 그림에 쓰여 있는 내용을 물어보는 방법이 자주 사용된다. 위키백과 다운로드 CATPCHA를 사용하기 위해선 https://sourceforge.net/projects/simplecaptcha/ 사이트로 이동해서 jar 파일을 다운로드 받는다. jar 파일 추가 사용하는 툴이 이클립스 일 경우 jar 파일을 프로젝트에 포함시켜야 한다. [Eclipse] 프로젝트에 jar 파일 추가하는 방법 사이트를 참고해서 추가합니다. 사용 HTML 먼저 자동입력 방지 기능을 넣기 위한 화면 코드다. CATPCHA 이미지를 보여주고 이미지 안의 숫자들을 새로고침 할 수 있는 버튼을 만들었다. 12345678910&lt;div class=\"mt-3\"&gt; &lt;label class=\"form-label fw-bold\"&gt;자동입력 방지문자&lt;/label&gt; &lt;div class=\"d-flex\"&gt; &lt;img id=\"captchaImg\" src=\"captchaImg\" title=\"캡차 이미지\" alt=\"캡차 이미지\" /&gt; &lt;button type=\"button\" id=\"refresh_btn\" class=\"btn btn-sm btn-gray w-50 ms-2\"&gt;새로고침&lt;/button&gt; &lt;/div&gt; &lt;div class=\"d-flex mt-1\"&gt; &lt;input id=\"captcha\" type=\"text\" class=\"form-control input-control\" /&gt; &lt;/div&gt;&lt;/div&gt; Controller 부분 html에서 /captchaImg 경로를 호출하면 아래 컨트롤러가 호출된다. Captcha 이미지 설정을 한 후 세션에 값을 저장하고 이미지를 그려준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * captchaImg * @param request * @param response * @throws IOException */@GetMapping(\"captchaImg\")public void captchaImg(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; try &#123; // 폰트 설정 ========================================================= List&lt;Font&gt; fontList = new ArrayList&lt;Font&gt;(); fontList.add(new Font(\"\", Font.HANGING_BASELINE, 28)); fontList.add(new Font(\"Courier\", Font.ITALIC, 28)); fontList.add(new Font(\"\", Font.PLAIN, 28)); List&lt;Color&gt; colorList = new ArrayList&lt;Color&gt;(); colorList.add(Color.black); Captcha captcha = new Captcha.Builder(200, 36) // 이미지 크기 설정 .addText(new NumbersAnswerProducer(6), new DefaultWordRenderer(colorList, fontList)) //.gimp(new DropShadowGimpyRenderer()).gimp() // 그림자 효과 추가 .addNoise().addNoise() // 한번 호출할 떄마다 하나의 라인이 추가된다 .addBackground(new GradiatedBackgroundProducer()) // Gradiated백그라운드 효과 추가 .addBorder() // 검정 테두리 선 생성 .build(); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setHeader(\"Pragma\", \"no-cache\"); // 캐쉬를 지우기 위해 헤더값을 설정 response.setDateHeader(\"Expires\", 0); response.setDateHeader(\"Max-Age\", 0); // 리턴값을 image형태로 설정 response.setContentType(\"image/png\"); // 세션에 자동가입방지 문자를 저장한다. request.getSession().setAttribute(Captcha.NAME, captcha); // Image를 write 한다 CaptchaServletUtil.writeImage(response, captcha.getImage()); &#125; catch (Exception e) &#123; response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; &#125;&#125; 다음은 현재 보이는 자동입력 방지문자와 입력한 문자가 일치하는 하는지 확인하는 코드다. 1234567891011121314/** * 자동입력 방지문자 확인 */@GetMapping(\"isCorrect\")public ResponseEntity&lt;?&gt; isCorrect(HttpServletRequest request, String answer) &#123; boolean result = false; Captcha captcha = (Captcha) request.getSession().getAttribute(Captcha.NAME); if (captcha.isCorrect(answer)) &#123; result = true; &#125; return new ResponseEntity&lt;&gt;(result, HttpStatus.OK);&#125; JavaScript 화면단에서 자등입력 방지문자를 잘 입력했는지 확인하는 코드다. 12345678910111213141516171819202122232425262728293031// 자동입력 방지문자가 일치하는지 확인const isCaptCha = () =&gt; &#123; const answer = $('#captcha').val(); if (answer == '') &#123; alert('자동입력 방지문자를 입력해주세요.'); return; &#125; let result = false; $.ajax(&#123; url: `$&#123;contextPath&#125;/signup/isCorrect`, type: 'GET', data: &#123; answer: answer &#125;, async: false, success: function (response) &#123; result = response; &#125;, &#125;); return result;&#125;;if (!isCaptCha()) &#123; alert('자동입력 방지문자가 일치하지 않습니다.', function () &#123; $('#captcha').focus(); &#125;); return;&#125; else &#123; alert('자동입력 방지문자가 일치합니다.');&#125; 새로고침 버튼을 누를 경우 자동입력 방지문자 이미지 안의 숫자가 바뀐다. 123456/** * 자동입력 방지문자 새로고침 */$('#refresh_btn').click(function () &#123; $('#captchaImg').attr('src', 'captchaImg');&#125;); 화면 성공적으로 자동입력 방지문자 이미지를 가져왔다! 위의 방법처럼 쉽게 구현할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Captcha","slug":"Captcha","permalink":"http://hgko1207.github.io/tags/Captcha/"},{"name":"SimpleCptcha","slug":"SimpleCptcha","permalink":"http://hgko1207.github.io/tags/SimpleCptcha/"},{"name":"자동가입방지문자","slug":"자동가입방지문자","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%8F%99%EA%B0%80%EC%9E%85%EB%B0%A9%EC%A7%80%EB%AC%B8%EC%9E%90/"}]},{"title":"[Angular] DI 수명(lifetime)","slug":"angular-13","date":"2023-07-21T12:07:55.000Z","updated":"2024-01-12T08:12:16.869Z","comments":true,"path":"2023/07/21/angular-13/","link":"","permalink":"http://hgko1207.github.io/2023/07/21/angular-13/","excerpt":"","text":"Transient Transient 서비스는 주입될 때마다 생성됩니다. 즉, 컴포넌트(component)가 서비스를 주입할 때마다 서비스의 새 인스턴스가 생성됩니다. Transient 서비스의 예는 다음과 같습니다. 1234567891011121314import &#123; Injectable &#125; from '@angular/core';@Injectable()export class TransientService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 컴포넌트가 TransientService를 주입하면 매번 서비스의 새 인스턴스가 생성됩니다. Scoped Scoped 서비스는 Angular 모듈당 한 번 생성됩니다. 이는 동일한 모듈 내의 컴포넌트(component)가 서비스를 주입할 때마다 동일한 서비스 인스턴스가 사용됨을 의미합니다. Scoped 서비스의 예는 다음과 같습니다. 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'my-module',&#125;)export class ScopedService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 동일한 모듈 내의 컴포넌트가 ScopedService를 주입하면 동일한 서비스 인스턴스가 사용됩니다. Singleton Singleton 서비스는 한 번 생성되고 동일한 인스턴스가 애플리케이션 전체에서 사용됩니다. 다음은 Singleton 서비스의 예입니다. 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class SingletonService &#123; private data: number; constructor() &#123; this.data = Math.random(); &#125; getData() &#123; return this.data; &#125;&#125; 컴포넌트가 SingletonService를 주입하면 애플리케이션 전체에서 동일한 서비스 인스턴스가 사용됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"DI","slug":"DI","permalink":"http://hgko1207.github.io/tags/DI/"},{"name":"의존성","slug":"의존성","permalink":"http://hgko1207.github.io/tags/%EC%9D%98%EC%A1%B4%EC%84%B1/"},{"name":"수명","slug":"수명","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EB%AA%85/"},{"name":"lifetime","slug":"lifetime","permalink":"http://hgko1207.github.io/tags/lifetime/"}]},{"title":"[Angular] OpenLayers로 지도 생성","slug":"angular-12","date":"2023-07-18T05:05:29.000Z","updated":"2024-01-12T08:09:48.669Z","comments":true,"path":"2023/07/18/angular-12/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/angular-12/","excerpt":"","text":"OpenLayers는 개인 또는 상업 프로젝트에 지도를 추가해야 하는 경우 광범위한 사용 사례에 적합한 오픈 소스 라이브러리입니다. 아래 단계를 따라 하면 몇 분 안에 빠르게 실행할 수 있습니다. Angular 프로젝트를 한 번도 해본 적이 없는 경우 새 프로젝트를 만드는 방법을 보여 드리겠습니다. 하지만 해당 부분을 건너뛰고 OpenLayers를 기존 프로젝트에 추가할 수 있습니다. 새 Angular 프로젝트 만들기 이 시점에서 첫 번째 Angular 프로젝트를 설정하는 방법을 보여 드리겠습니다. 모든 컴퓨터 운영 체제를 사용할 수 있으며 Angular는 macOS, Linux 및 Windows에서 작동합니다. 이것은 지금 사용하는 설정입니다. 1234Angular CLI: 16.1.0Node: 18.15.0Package Manager: npm 9.5.0OS: win32 x64 먼저 Angular를 처음 사용하는 경우 로컬 환경을 설정해야 합니다. Node.js 와 npm이 필요합니다. 설치된 버전을 확인하려면 다음 명령을 실행하십시오. 12node -vnpm -v 자, 새 프로젝트를 만들어 봅시다. command line interface(터미널, 명령 프롬프트)를 열고 새 Angular 프로젝트에 사용하려는 디렉토리로 이동합니다. Angular CLI를 설치하려면 다음을 실행합니다. 1npm install -g @angular/cli 이제 작업 공간을 만듭니다. 1ng new openlayers-demo 그리고 앱을 실행할 수 있는지 확인하십시오. 12cd openlayers-demong serve — open 잘하셨습니다. 이제 OpenLayers 설정을 시작할 준비가 되었습니다. Angular 프로젝트에 OpenLayers 추가 최신 버전의 OpenLayers를 설치합니다. 1npm install --save ol 이 시점에서 앱을 제공하려고 하면 앱이 컴파일되지 않는 것을 알 수 있습니다. 이 문제는 Openlayers 6.6 이상 버전에 존재하므로 위의 명령에 @6.5를 추가하여 Openlayers 6.5 버전을 사용하도록 결정할 수도 있습니다. 그러나 이후 버전에 존재하는 문제를 해결하는 방법을 살펴보겠습니다. 아래와 같이 ol 라이브러리와 관련된 오류가 표시됩니다. 1234Error: node_modules/ol/source/Cluster.d.ts:136:31 - error TS2314: Generic type 'Feature&lt;Geometry&gt;' requires 1 type argument(s).136 protected features: Array&lt;Feature&gt;;Error: node_modules/ol/source/Cluster.d.ts:152:23 - error TS2314: Generic type 'VectorSource&lt;Geometry&gt;' requires 1 type argument(s).152 protected source: VectorSource; 오류를 해결하려면 tsconfig.json 파일을 열고 compilerOptions 안에 &quot;skipLibCheck&quot;:true 옵션을 추가합니다. 123456789101112131415161718192021222324252627&#123; \"compileOnSave\": false, \"compilerOptions\": &#123; \"baseUrl\": \"./src\", \"outDir\": \"./dist/out-tsc\", \"sourceMap\": true, \"declaration\": false, \"module\": \"es2020\", \"moduleResolution\": \"node\", \"experimentalDecorators\": true, \"allowSyntheticDefaultImports\": true, \"importHelpers\": true, \"target\": \"es2020\", \"typeRoots\": [\"node_modules/@types\"], \"lib\": [\"es2018\", \"dom\"], \"paths\": &#123; \"@core\": [\"@core/\"], \"environments\": [\"environments/\"] &#125;, \"resolveJsonModule\": true, \"skipLibCheck\": true &#125;, \"angularCompilerOptions\": &#123; \"fullTemplateTypeCheck\": false, \"strictInjectionParameters\": false &#125;&#125; 이제 OpenLayers CSS Style을 프로젝트에 추가하십시오. angular.json 파일을 열고 기존 CSS Style 옆에 &quot;node_modules/ol/ol.css&quot; 를 추가합니다. 123456789101112131415161718192021222324252627282930&#123; \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", \"version\": 1, \"newProjectRoot\": \"projects\", \"projects\": &#123; \"openlayers-demo\": &#123; \"projectType\": \"application\", \"schematics\": &#123; \"@schematics/angular:component\": &#123; \"style\": \"scss\" &#125; &#125;, \"root\": \"\", \"sourceRoot\": \"src\", \"prefix\": \"app\", \"architect\": &#123; \"build\": &#123; \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": &#123; ... \"styles\": [ \"src/styles.scss\", \"node_modules/ol/ol.css\" ], &#125; &#125; &#125; &#125; &#125;&#125; 이제 지도를 넣을 수 있는 컴포넌트를 만들 차례입니다. 1ng generate component map 컴포넌트의 콘텐츠를 추가합니다. map.component.html 1&lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; map.component.scss 1234.map &#123; width: 100%; height: 500px;&#125; map.component.ts 12345678910111213141516171819202122232425262728293031import &#123; Component, OnInit &#125; from '@angular/core';import 'ol/ol.css';import Map from 'ol/Map';import View from 'ol/View';import &#123; OSM &#125; from 'ol/source';import TileLayer from 'ol/layer/Tile';@Component(&#123; selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'],&#125;)export class MapComponent implements OnInit &#123; public map!: Map; ngOnInit(): void &#123; this.map = new Map(&#123; layers: [ new TileLayer(&#123; source: new OSM(), &#125;), ], target: 'map', view: new View(&#123; center: [0, 0], zoom: 2, maxZoom: 18, &#125;), &#125;); &#125;&#125; OSM 은 OpenStreetMaps를 의미하며 여기서는 표준 지도를 사용하지만 OpenLayers는 다양한 지도 Tile Servers, 이미지 등과 함께 작동하며 사용자 고유의 레이어를 만들고 사용자 지정할 수도 있습니다. 마지막 단계는 지도 컴포넌트의 내용을 포함하도록 루트 html 파일 app.component.html의 내용을 바꾸는 것입니다. 1&lt;app-map&gt;&lt;/app-map&gt; 이제 작동하는 웹사이트를 확인할 시간입니다! 이 글에서는 OpenLayers 라이브러리로 Angular 프로젝트를 설정하여 웹사이트에서 지도를 사용하는 방법을 배웠습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"지도","slug":"지도","permalink":"http://hgko1207.github.io/tags/%EC%A7%80%EB%8F%84/"}]},{"title":"[C#] FileSystemWatcher 파일 감시 모니터링","slug":"csharp-1","date":"2023-07-18T04:49:39.000Z","updated":"2024-01-12T08:10:51.529Z","comments":true,"path":"2023/07/18/csharp-1/","link":"","permalink":"http://hgko1207.github.io/2023/07/18/csharp-1/","excerpt":"","text":"FileSystemWatcher는 특정 폴더 경로(디렉터리)의 모든 파일이 생성되거나 변경되면 함수 호출을 해줍니다. 사용 방법 사용 방법 순서입니다. FileSystemWatcher 생성자 호출 감시할 폴더 설정(디렉토리) 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) 감시할 이벤트 설정 (생성, 변경, 삭제 등) FIleSystemWatcher 감시 모니터링 활성화 감시할 폴더 내부 변경 시 event 호출 구현 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;namespace Test.Utils&#123; public class FileWatcher &#123; public void initWatcher() &#123; string filePath = $\"D:\\\\files\\\\\"; // 1. FileSystemWatcher 생성자 호출 FileSystemWatcher watcher = new FileSystemWatcher(); // 2. 감시할 폴더 설정(디렉토리) watcher.Path = filePath; // 3. 감시할 항목들 설정 (파일 생성, 크기, 이름, 마지막 접근 변경 등) watcher.NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size | NotifyFilters.LastAccess | NotifyFilters.CreationTime | NotifyFilters.LastWrite; //감시할 파일 유형 선택 예) *.* 모든 파일 watcher.Filter = \"*.*\"; watcher.IncludeSubdirectories = true; // 4. 감시할 이벤트 설정 (생성, 변경..) watcher.Created += new FileSystemEventHandler(Changed); watcher.Changed += new FileSystemEventHandler(Changed); watcher.Renamed += new RenamedEventHandler(Renamed); // 5. FIleSystemWatcher 감시 모니터링 활성화 watcher.EnableRaisingEvents = true; &#125; // 6. 감시할 폴더 내부 변경 시 event 호출 private void Changed(object source, FileSystemEventArgs e) &#123; Console.Write(e.FullPath); &#125; // 이름 변경 시 event 호출 private void Renamed(object source, RenamedEventArgs e) &#123; MessageBox.Show(e.FullPath); &#125; &#125;&#125; FileSystemWatcher은 using System.IO를 선언해 주어야 합니다. initWatcher() 함수를 실행시키면 D:\\files\\ 해당 경로에 파일이 생기면 바로 Changed() 이벤트가 호출됩니다. 호출될 때 담기는 파라미터 FileSystemEventArgs e에서 e.Fullpath를 통해 생성된 파일의 전체 경로를 가져옵니다. 12# 예)D:\\files\\새 텍스트 문서.txt 이렇게 FileSystemWatcher를 사용해서 해당 폴더를 실시간으로 감지 모니터링하는 기능을 구현했습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"}]},{"title":"[Angular] cross-fetch 사용 방법","slug":"angular-11","date":"2023-07-11T02:48:34.000Z","updated":"2024-01-12T08:09:00.973Z","comments":true,"path":"2023/07/11/angular-11/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-11/","excerpt":"","text":"Angular 개발 시 api 통신을 하기 위한 Fetch API에 대해 알아보겠습니다. Fetch API 란 Fetch API는 HTTP 파이프라인을 구성하는 요청과 응답 등의 요소를 JavaScript에서 접근하고 조작할 수 있는 인터페이스를 제공합니다. Fetch API가 제공하는 전역 fetch() 메서드로 네트워크의 리소스를 쉽게 비동기적으로 취득할 수도 있습니다. 설치 Fetch API를 사용하기 위해 cross-fetch 패키지를 설치한다. 12345# npm 을 사용하여 설치하는 경우npm install --save cross-fetch# yarn 을 사용하여 설치하는 경우yarn add cross-fetch ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; http 메서드 설정 HTTP 요청 메소드에서 자주 사용하는 GET, POST, PUT, DELETE 를 사용하는 함수를 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable &#125; from '@angular/core';import fetch from 'cross-fetch';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125; public get(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'GET', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public post(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'POST', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public put(url: string, payload: BodyInit): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'PUT', body: payload, headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125; public delete(url: string): Promise&lt;Response&gt; &#123; return this.fetch(url, &#123; method: 'DELETE', headers: &#123; 'Content-type': 'application/json', &#125;, &#125;); &#125;&#125; fetch의 return 타입은 Promise 이기 때문에 then 함수를 사용하거나 async await 를 사용한다. 12345678910111213141516171819202122// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; ApiService &#125; from 'app/services/api.service';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; private BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private api: ApiService) &#123; this.api.get(`$&#123;BASE_URL&#125;/today`).then((response: any) =&gt; &#123; if (response.ok) &#123; console.log(response.json()); &#125; &#125;); &#125; ngOnInit(): void &#123;&#125;&#125; 참고 Fetch API 사용하기 https://github.com/lquixada/cross-fetch","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"}]},{"title":"[Angular] HttpClient 사용 방법","slug":"angular-10","date":"2023-07-11T02:13:24.000Z","updated":"2024-01-12T08:07:32.234Z","comments":true,"path":"2023/07/11/angular-10/","link":"","permalink":"http://hgko1207.github.io/2023/07/11/angular-10/","excerpt":"","text":"Angular 개발 시 프로젝트 초기에 api 통신에 대해 설정 파일을 생성하고 설정해 두면 작업하기가 편합니다. Angluar는 @angular/common 안에 존재하는 http 패키지를 사용하면 됩니다. import http 작업을 하기 위해 src/app.module.ts 파일에 HttpClientModule을 import 해야 합니다. 12345678910111213141516// src/app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpClientModule &#125; from '@angular/common/http';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], // BrowserModule 다음에 HttpClientModule를 작성해야 한다 imports: [BrowserModule, HttpClientModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; ApiService 구축 api는 전역에서 사용하는 것이기 때문에 service로 만든다. src/app/services 폴더 아래에 api.service.ts 파일을 만들었다. 123456789// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class ApiService &#123; constructor() &#123;&#125;&#125; Injectable 이기 때문에 다른 module 에서 import 하지 않아도 바로 사용할 수 있다. baseUrl 설정 이제 불러 올 api의 baseUrl을 설정해준다. 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125;&#125; 보통 BASE_URL은 각 프로젝트의 환경 별로 다르게 설정 가능하다. 12345// src/environments/environments.tsexport const environment = &#123; production: false, baseUrl: 'https://test.api.example.com',&#125;; 12345// src/environments/environment.prod.tsexport const environment = &#123; production: true, baseUrl: 'https://api.example.com',&#125;; 위의 처럼 설정한 후 src/api/api.service.ts에 다음과 같이 불러와 사용하면 된다. 12345import &#123; environment &#125; from 'environments/environment';// ...생략export class ApiService &#123; public BASE_URL = environment.baseUrl;&#125; http 메서드 설정 HTTP 요청 메서드에서 자주 사용하는 GET, POST, PUT, DELETE를 사용하는 함수를 생성한다. 123456789101112131415161718192021222324252627// src/api/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';import &#123; Observable &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; public BASE_URL = 'https://webtoon-crawler.nomadcoders.workers.dev'; constructor(private http: HttpClient) &#123;&#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125; post&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.post&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; put&lt;T&gt;(endPoint: string, body: any): Observable&lt;T&gt; &#123; return this.http.put&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`, body); &#125; delete&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.delete&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`); &#125;&#125; Angular의 http의 return 타입은 모두 Observable 이기 때문에, 할당할 변수의 타입도 Observable로 지정해야 한다. 1234567891011121314151617181920212223242526// src/app/app.components.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs';import &#123; ApiService &#125; from 'app/services/api.service';interface WebToonInfo &#123; id: string; title: string; thumb: number;&#125;@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; webToons$: Observable&lt;WebToonInfo[]&gt;; constructor(private api: ApiService) &#123; this.webToons$ = this.api.get('/today'); this.webToons$.subscribe(console.log); // console 확인 &#125; ngOnInit(): void &#123;&#125;&#125; Error 처리 만약 에러를 처리하고 싶다면, 각 api 요청마다 설정할 수도 있지만 api.service.ts 에서 설정 해줘도 된다. 1234567891011121314151617181920212223// src/app/services/api.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpErrorResponse &#125; from '@angular/common/http';import &#123; Observable, throwError &#125; from 'rxjs';import &#123; catchError &#125; from 'rxjs/operators';@Injectable(&#123; providedIn: 'root' &#125;)export class ApiService &#123; // ... 생략 private handleError(error: HttpErrorResponse) &#123; if (error.status === 0) &#123; console.error('Error:', error.error); &#125; else &#123; console.error(`Backend error $&#123;error.status&#125;, $&#123;error.error&#125;`); &#125; return throwError('예기치 못한 에러가 발생했습니다. 다시 시도해주세요.'); &#125; get&lt;T&gt;(endPoint: string): Observable&lt;T&gt; &#123; return this.http.get&lt;T&gt;(`$&#123;this.BASE_URL&#125;$&#123;endPoint&#125;`).pipe(catchError(this.handleError)); &#125;&#125; 참고 Understanding communicating with backend services using HTTP","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"}]},{"title":"Flutter 업그레이드 방법","slug":"flutter-2","date":"2023-05-30T05:14:11.000Z","updated":"2024-01-12T08:02:43.807Z","comments":true,"path":"2023/05/30/flutter-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/30/flutter-2/","excerpt":"","text":"Flutter 버전 오류 Flutter 프로젝트를 진행하면서 http 패키지를 설치하려고 flutter pub get 명령어를 실행했을 때 다음과 같은 오류가 발생했습니다. 123456[flutter\\example] flutter pub getResolving dependencies...The current Dart SDK version is 3.0.0-431.0.devBecause example depends on http &gt;=1.0.0 which requires SDK version ^3.0.0, version solving failed.exit code 1 http 패키지의 1.0.0 버전을 설치하는데 현재 Dart SDK 버전이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되지 않아 발생한 오류였습니다. 현재 Dart SDK 버전 3.0.0-431.0.dev 이 &gt;=3.0.0 &lt;4.0.0 범위에 포함되는 것 같지만 실제로는 조건에 충족하지 않습니다. 오류 해결 Dart SDK 버전을 올려주면 해결됩니다. 버전을 올리기 위해 Dart를 새로 설치를 해도 되지만 번거롭습니다. flutter 명령어로 Flutter와 Dart의 버전을 올릴 수 있기 때문에 flutter CLI 명령어로 버전을 변경합니다. 1flutter upgrade 위의 명령어를 실행하면 다음와 같이 업그레이드를 진행합니다. 12345678910111213141516171819202122232425Upgrading engine...Downloading android-arm-profile/windows-x64 tools... 387msDownloading android-arm-release/windows-x64 tools... 101msDownloading android-arm64-profile/windows-x64 tools... 132msDownloading android-arm64-release/windows-x64 tools... 97msDownloading android-x64-profile/windows-x64 tools... 101msDownloading android-x64-release/windows-x64 tools... 103msDownloading android-x86 tools... 639msDownloading android-x64 tools... 628msDownloading android-arm tools... 521msDownloading android-arm-profile tools... 216msDownloading android-arm-release tools... 142msDownloading android-arm64 tools... 526msDownloading android-arm64-profile tools... 261msDownloading android-arm64-release tools... 201msDownloading android-x64-profile tools... 258msDownloading android-x64-release tools... 214msDownloading android-x86-jit-release tools... 337msDownloading Web SDK... 1,662ms...Flutter 3.11.0-15.0.pre.48 • channel master • https://github.com/flutter/flutter.gitFramework • revision c5f45d7121 (54 minutes ago) • 2023-05-30 00:15:34 -0400Engine • revision b5f60d2b33Tools • Dart 3.1.0 (build 3.1.0-155.0.dev) • DevTools 2.23.1 flutter 업그레이드가 끝나고 다시 flutter pub get 명령어를 실행하면 정상적으로 dependency를 가지고 오는 것을 확인할 수 있습니다. 1234567891011[flutter\\example] flutter pub getResolving dependencies...&gt; collection 1.17.2 (was 1.17.1)+ http 1.0.0+ http_parser 4.0.2 matcher 0.12.15 (0.12.16 available)&gt; material_color_utilities 0.5.0 (was 0.3.0)&gt; test_api 0.5.2 (was 0.5.1) (0.6.0 available)+ typed_data 1.3.2Changed 6 dependencies!exit code 0","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"}]},{"title":"[NestJS] End-to-end 테스트","slug":"nest-7","date":"2023-05-15T07:11:20.000Z","updated":"2024-01-12T08:01:02.809Z","comments":true,"path":"2023/05/15/nest-7/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-7/","excerpt":"","text":"End-to-end 테스트 개별 모듈과 클래스에 중점을 두는 Unit 테스트와 달리 end-to-end(e2e) 테스트는 보다 종합적인 수준에서 클래스와 모듈의 상호 작용을 다룹니다. 애플리케이션이 성장함에 따라 각 API endpoint의 E2E 동작을 수동으로 테스트하기가 어려워집니다. 자동화된 E2E 테스트는 시스템의 전반적인 동작이 정확하고 프로젝트 요구 사항을 충족하는지 확인하는 데 도움이 됩니다. Nest를 사용하면 SuperTest 라이브러리를 사용하여 HTTP request를 쉽게 시뮬레이션할 수 있습니다. SuperTest는 superagent를 기반으로 하는 HTTP 검증 라이브러리입니다. request() SuperTest 의 request(app.getHttpServer()) 함수를 사용하여 HTTP 테스트를 시뮬레이션합니다. 1234// localhost:3000/ 으로 라우팅될 때 Hello World!가 출력되는지 확인it('/ (GET)', () =&gt; &#123; return request(app.getHttpServer()).get('/').expect(200).expect('Hello World!');&#125;); 이러한 HTTP request 가 실행 중인 Nest 앱으로 라우팅 되기를 원하므로 request() 함수에 Nest 의 기반이 되는 HTTP 리스너에 대한 참조를 전달합니다. 사용 예시 기본적인 CRUD (Create/Read/Update/Delete) 에 대한 테스트를 하기 위해 다음과 같이 작성할 수 있습니다. 1234567891011121314151617181920212223242526272829describe('/users', () =&gt; &#123; it('GET', () =&gt; &#123; return request(app.getHttpServer()).get('/users').expect(200).expect([]); &#125;); it('POST', () =&gt; &#123; return request(app.getHttpServer()) .post('/users') .send(&#123; name: 'hgko', age: 30, hobbies: ['soccer'], &#125;) .expect(201); &#125;); it('PATCH', () =&gt; &#123; return request(app.getHttpServer()) .patch('/users/1') .send(&#123; age: 35, &#125;) .expect(200); &#125;); it('DELETE', () =&gt; &#123; return request(app.getHttpServer()).delete('/users/1').expect(200); &#125;);&#125;); 참고 https://docs.nestjs.com/fundamentals/testing#end-to-end-testing https://github.com/visionmedia/supertest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"}]},{"title":"[NestJS] Jest 사용 방법","slug":"nest-6","date":"2023-05-15T01:55:57.000Z","updated":"2024-01-12T07:22:39.918Z","comments":true,"path":"2023/05/15/nest-6/","link":"","permalink":"http://hgko1207.github.io/2023/05/15/nest-6/","excerpt":"","text":"NestJS에서 Jest를 사용하는 방법에 대해 간략하게 알아보겠습니다. Jest Jest는 단순함에 초점을 맞춘 유쾌한 JavaScript 테스팅 프레임워크입니다. Babel, TypeScript, Node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동합니다. 시작하기 describe() describe() 함수를 사용하면 작은 단위의 테스트 코드를 그룹화할 수 있습니다. 작성하는 테스트 코드가 특정 component 에 속하는 테스트 코드라면 다음과 같이 describe() 함수를 사용해서 해당 테스트 코드들을 그룹화하는 것이 좋습니다. 테스트 결과를 확인할 때 가시적으로 보기 편하게 테스트 케이스들을 확인할 수 있습니다. 12345678910111213describe('StudentService', () =&gt; &#123; test('getAll', () =&gt; &#123; ... &#125;); test('getOne', () =&gt; &#123; ... &#125;); test('create', () =&gt; &#123; ... &#125;);&#125;); it(), test() 테스트 케이스를 생성합니다. it() 함수 대신 test()도 사용 가능합니다. 123it('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 123test('should be 4', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); expect() 값을 테스트할 때마다 expect() 함수가 사용됩니다. 테스트할 때 expect() 함수를 여러개 사용할 수 있습니다. 1234567function bestJuiceFlavor() &#123; return 'apple';&#125;test('the best flavor is apple', () =&gt; &#123; expect(bestJuiceFlavor()).toBe('apple');&#125;); Using Matchers Common Matchers toBe() 함수는 Object.is를 사용하여 정확한 동등성을 테스트합니다. 객체의 값을 확인하려면 대신 toEqual() 함수를 사용하세요. 123it('two plus two is four', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;); 12345it('object assignment', () =&gt; &#123; const data = &#123; one: 1 &#125;; data['two'] = 2; expect(data).toEqual(&#123; one: 1, two: 2 &#125;);&#125;); Strings toMatch() 함수를 사용하여 정규 표현식에 대해 문자열을 확인할 수 있습니다. 123it('but there is a \"ko\" in hgko', () =&gt; &#123; expect('hgko').toMatch(/ko/);&#125;); Arrays and iterables toContain() 함수를 사용하여 배열 또는 iterable에 특정 항목이 포함되어 있는지 확인할 수 있습니다. 123456789const shoppingList = ['egg', 'coffee', 'tissue', 'milk'];it('the shopping list has milk on it', () =&gt; &#123; // array expect(shoppingList).toContain('milk'); // iterable expect(new Set(shoppingList)).toContain('milk');&#125;); Exceptions 특정 함수가 호출될 때 오류가 발생하는지 테스트하려면 toThrow() 함수를 사용합니다. 예외를 발생시키는 함수는 래핑 함수 내에서 호출해야 합니다. 그렇지 않으면 toThrow assertion 이 실패합니다. 123456789101112131415describe('getOne', () =&gt; &#123; it('shoule find a student', () =&gt; &#123; const student = service.getOne(1); expect(student).toBeDefined(); &#125;); it('should throw 404 error', () =&gt; &#123; try &#123; service.getOne(999); &#125; catch (e) &#123; expect(e).toBeInstanceOf(NotFoundException); expect(e.message).toEqual(`Student with ID: 999 not found.`); &#125; &#125;);&#125;); toBeInstanceOf(Class) 함수를 사용하여 객체가 클래스의 인스턴스인지 확인할 수 있습니다. 테스트 전/후 처리 beforeEach 각각의 테스트가 실행되기 전에 매번 함수를 실행합니다. 각각의 테스트 전에 각 테스트에서 사용할 전역 상태를 재설정하려는 경우에 유용합니다. 함수가 promise을 반환하거나 generator 인 경우 Jest는 테스트를 실행하기 전에 해당 promise가 해결될 때까지 기다립니다. 밀리초로 대기할 시간을 지정할 수 있습니다. (기본 시간 5초) 1234567891011121314let users: User[];// test() 함수들이 실행될때마다 beforeEach()에서 설정한, users 데이터를 사용하게 된다.beforeEach(async () =&gt; &#123; users.push(&#123; id: 1, name: 'hgko' &#125;, &#123; id: 2, name: 'eden' &#125;);&#125;);test('find all users', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;);test('create a user', () =&gt; &#123; // ... 테스트하면서 users의 데이터들을 가져와 사용한다.&#125;); afterEach 각각의 테스트가 완료된 후 함수를 실행합니다. beforeAll 모든 테스트가 실행되기 전에 딱 한 번 함수를 실행합니다. 123456let connection;beforeAll(() =&gt; &#123; // 테스트 실행하기전에 데이터베이스에 접속할 연결(Connection) 개체를 만든다. conection = openConnection(&#123; host: '...', port: '...' &#125;);&#125;); afterAll 모든 테스트가 완료된 후 함수를 실행합니다. 1234afterAll(() =&gt; &#123; // 데이터베이스 Connection을 종료한다. conection.close();&#125;); 실행 NestJS 개발환경에서 package.json 파일에 Testing 하는 명령어가 정의되어 있습니다. 123456789101112// package.json&#123; ... \"scripts\": &#123; ... \"test\": \"jest\", \"test:watch\": \"jest --watch\", \"test:cov\": \"jest --coverage\", \"test:debug\": \"node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand\", \"test:e2e\": \"jest --config ./test/jest-e2e.json\" &#125;,&#125; 다음과 같이 테스트 하려는 방식에 따라 명령어를 실행해서 테스트합니다. 1234567# Unit 테스트npm run testnpm run test:watchnpm run test:cov# E2E 테스트npm rum test:e2e 참고 https://jestjs.io/ https://jestjs.io/docs/getting-started https://jestjs.io/docs/expect","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"}]},{"title":"[NestJS] Mapped types의 Partial 사용 방법","slug":"nest-5","date":"2023-05-13T12:46:39.000Z","updated":"2024-01-12T07:21:40.161Z","comments":true,"path":"2023/05/13/nest-5/","link":"","permalink":"http://hgko1207.github.io/2023/05/13/nest-5/","excerpt":"","text":"Mapped types CRUD(Create/Read/Update/Delete)와 같은 기능을 구축할 때 기본 엔터티 클래스를 기능에 맞게 변형하는 것이 필요한 경우가 많습니다. Nest는 이 작업을 보다 편리하게 만들기 위해 클래스 변환을 수행하는 여러 유틸리티 기능을 제공합니다. Partial input validation types(DTO라고도 함)을 빌드할 때 동일한 클래스에 대한 create 및 update 클래스로 변형하는 것이 필요한 경우가 많습니다. 예를 들어, create 에는 모든 필드가 필요할 수 있지만 update는 모든 필드를 선택 사항으로 만들 수 있습니다. Nest는 이 작업을 더 쉽게 만들고 보일러플레이트(Boilerplate) 코드를 최소화하기 위해 PartialType() 유틸리티 함수를 제공합니다. PartialType() 함수는 입력 클래스의 모든 속성이 선택 사항으로 설정된 클래스를 반환합니다. 설치 Mapped types 설치를 통해 PartialType을 가져올 수 있습니다. 1npm i @nestjs/mapped-types 사용 예시 이전 글 [NestJS] ValidationPipe 사용 방법 에서 생성한 사용자 등록 DTO 클래스를 이용합니다. 사용자 등록 DTO 클래스의 필드들은 모두 필수 항목입니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 DTO 클래스와 동일한 필드를 가지지만 각 필드가 선택 사항인 사용자 수정 DTO 클래스를 생성하려면 PartialType() 함수를 상속받고 사용자 등록 DTO 클래스인 CreateUserDto를 인수로 전달합니다. 12345// update-user.dto.tsimport &#123; PartialType &#125; from '@nestjs/mapped-types';import &#123; CreateUserDto &#125; from './create-user.dto';export class UpdateUserDto extends PartialType(CreateUserDto) &#123;&#125; 사용자 수정 요청을 받기 위해 컨트롤러 클래스를 생성합니다. update 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Patch &#125; from '@nestjs/common';import &#123; UpdateUserDto &#125; from './dto/update-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 수정 * @param userData * @returns */ @Patch() update(@Body() userData: UpdateUserDto) &#123; return '사용자 수정 성공'; &#125;&#125; 사용자 수정 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 PATCH 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12// 서버에서 응답사용자 수정 성공 사용자 등록과 달리 모든 필드가 선택 사항으로 설정되어 있어 요청할 때 속성들을 입력하지 않아도 잘 동작하는 것을 확인할 수 있습니다. 참고 https://docs.nestjs.com/openapi/mapped-types#partial https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"}]},{"title":"[NestJS] ValidationPipe 사용 방법","slug":"nest-4","date":"2023-05-11T03:10:18.000Z","updated":"2024-01-12T07:20:45.231Z","comments":true,"path":"2023/05/11/nest-4/","link":"","permalink":"http://hgko1207.github.io/2023/05/11/nest-4/","excerpt":"","text":"Validation 웹 애플리케이션으로 전송되는 데이터의 검증을 도와줍니다. 들어오는 요청을 자동으로 검증하기 위해 Nest는 즉시 사용할 수 있는 여러 파이프를 제공합니다. ValidationPipe ValidationPipe는 강력한 클래스 유효성 검사기 패키지와 선언적 유효성 검사 데코레이터를 사용합니다. ValidationPipe는 들어오는 모든 클라이언트 페이로드에 대해 유효성 검사 규칙을 적용하는 편리한 접근 방식을 제공합니다. ValidationPipe 사용을 위한 class-validator, class-transformer 패키지를 설치합니다. 1npm i --save class-validator class-transformer 사용 예시 ValidationPipe 를 사용하기 위해 main.ts 파일에 다음과 같이 추가합니다. 123456789101112// main.tsimport &#123; NestFactory &#125; from '@nestjs/core';import &#123; AppModule &#125; from './app.module';import &#123; ValidationPipe &#125; from '@nestjs/common';async function bootstrap() &#123; const app = await NestFactory.create(AppModule); // ValidationPipe 추가 app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);&#125;bootstrap(); 유효성 검사를 위해 사용자 등록을 예시로 작성했습니다. 먼저 사용자 등록을 위한 DTO(Data Transfer Object) 클래스를 생성합니다. 그리고 validation decorator(IsString, IsNumber 등)를 유효성 검사하기 위한 필드에 추가합니다. 12345678910111213// create-user.dto.tsimport &#123; IsString, IsNumber &#125; from 'class-validator';export class CreateUserDto &#123; @IsString() readonly name: string; @IsNumber() readonly age: number; @IsString(&#123; each: true &#125;) readonly hobbies: string[];&#125; 사용자 등록 요청을 받기 위해 컨트롤러 클래스를 생성합니다. create 함수의 파라미터에 생성한 DTO 클래스를 타입으로 지정합니다. 1234567891011121314151617import &#123; Body, Controller, Post &#125; from '@nestjs/common';import &#123; CreateUserDto &#125; from './dto/create-user.dto';@Controller('users')export class UserController &#123; constructor() &#123;&#125; /** * 사용자 등록 * @param userData * @returns */ @Post() create(@Body() userData: CreateUserDto) &#123; return '사용자 등록 성공!!'; &#125;&#125; 사용자 등록 요청을 해보겠습니다. Postman 또는 Insomnia 툴을 이용합니다. http://localhost:3000/student/ 주소를 POST 방식으로 요청합니다. 1234// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"height\": 180&#125; 12345678910// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [ \"name must be a string\", \"age must be a number conforming to the specified constraints\", \"each value in hobbies must be a string\" ], \"error\": \"Bad Request\"&#125; 요청하는 데이터가 “name”, “age”, “hobbies” 필드가 존재하지 않으므로 예외를 응답합니다. 즉, ValidationPipe를 사용하면 모든 엔드포인트가 잘못된 데이터를 수신하지 못하도록 보호됩니다. 간단한 설정만으로 유효성 체크를 할 수 있습니다. 옵션 whitelist whitelist: true로 설정하면 유효성 검사기는 class-validator의 유효성 검사 데코레이터를 적어도 하나라도 사용하지 않은 모든 속성 객체를 제거합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, &#125;)); forbidNonWhitelisted forbidNonWhitelisted: true로 설정하면 화이트리스트에 없는 속성을 제거하는 대신 유효성 검사기가 예외를 발생합니다. 123456app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, forbidNonWhitelisted: true, &#125;)); whitelist 와 forbidNonWhitelisted 옵션을 true로 설정하면 &quot;height&quot;이라는 속성은 화이트리스트에 존재하지 않으므로 HttpException을 응답합니다. 1234567// 클라이언트 측에서 전송한 데이터가 다음과 같을 경우&#123; \"name\": \"hgko\", \"age\": 35, \"hobbies\": [\"soccer\"], \"height\": 180&#125; 123456// 서버에서 응답&#123; \"statusCode\": 400, \"message\": [\"property height should not exist\"], \"error\": \"Bad Request\"&#125; transform (자동 형변환) 네트워크를 통해 들어오는 payload는 일반 JavaScript 객체입니다. ValidationPipe는 payload를 DTO 클래스에 따라 유형이 지정된 객체로 자동 변환할 수 있습니다. 자동 변환을 활성화하려면 transform을 true로 설정하십시오. 이 동작을 전역적으로 활성화하려면 전역 파이프에서 옵션을 설정합니다. 12345app.useGlobalPipes( new ValidationPipe(&#123; transform: true, &#125;)); 참고 https://docs.nestjs.com/techniques/validation https://www.npmjs.com/package/class-validator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"}]},{"title":"[NestJS] Param decorators","slug":"nest-3","date":"2023-05-10T03:05:36.000Z","updated":"2024-01-12T07:19:33.891Z","comments":true,"path":"2023/05/10/nest-3/","link":"","permalink":"http://hgko1207.github.io/2023/05/10/nest-3/","excerpt":"","text":"Param decorators Nest는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 매개변수 데코레이터 세트를 제공합니다. 다음은 제공된 데코레이터와 이들이 나타내는 일반 Express(또는 Fastify) 객체의 목록과 사용 예시입니다. @Param Param은 Path Variable 을 받아올 때 사용합니다. (예, /users/123) 12345// NestJS@Param(param?: string)// ExpressJSreq.params / req.params[param] 123456789import &#123; Controller, Get, Param &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('/:id') getOne(@Param('id') userId: string) &#123; return `This will return one user with the id: $&#123;userId&#125;`; &#125;&#125; @Body Body는 JSON 형식으로 받아올 때 사용합니다. 12345// NestJS@Body(param?: string)// ExpressJSreq.body / req.body[param] 1234567891011121314151617import &#123; Body, Controller, Param, Patch, Post &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Post() create(@Body() userData) &#123; return userData; &#125; @Patch('/:id') update(@Param('id') userId: string, @Body() updateData) &#123; return &#123; updateData: userId, ...updateData, &#125;; &#125;&#125; @Query Query는 Query Parameter를 받아올 때 사용합니다. (예, /users?id=123) 12345// NestJS@Query(param?: string)// ExpressJSreq.query / req.query[param] 123456789import &#123; Controller, Get, Query &#125; from '@nestjs/common';@Controller('users')export class UserController &#123; @Get('search') search(@Query('id') userId: string) &#123; return `We are searching for a user made after: $&#123;userId&#125;`; &#125;&#125; 참고 https://docs.nestjs.com/custom-decorators#param-decorators","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"}]},{"title":"[NestJS] Controller, Provider, Module 이란?","slug":"nest-2","date":"2023-05-08T02:40:07.000Z","updated":"2024-01-12T07:18:58.542Z","comments":true,"path":"2023/05/08/nest-2/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-2/","excerpt":"","text":"NestJS에서 사용하는 Controller, Provider, Module에 대한 간략한 내용을 정리하였습니다. Controllers 컨트롤러는 들어오는 요청을 처리하고 클라이언트에 응답을 반환하는 역할을 합니다. express의 라우터 같은 역할을 합니다. 1234567891011121314151617import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125; @Get('/hello') sayHello(): string &#123; return 'Hello everyone'; &#125;&#125; @Controller(): express의 app.use('/', router) 에서 '/'와 같은 역할을 합니다. @Controller('req') 이렇게 인자로 string을 넘겨주면 express에서 app.use('/req', router) 처럼 코드를 작성한 것과 같습니다. @Get(): Route 핸들러(메서드) 데코레이터입니다. HTTP GET 요청을 지정된 경로로 라우팅 합니다. @Get('hello') 이렇게 인자로 string을 넘겨주면 express 에서 router.get('/hello', sayHello) 처럼 코드를 작성한 것과 같습니다. Providers Provider는 Nest의 기본 개념입니다. 대부분의 기본 Nest Class 인 services, repositories, factories, helpers 등은 provider로 취급될 수 있습니다. provider는 단순히 @Injectable() 데코레이터가 달린 클래스입니다. 12345678import &#123; Injectable &#125; from '@nestjs/common';@Injectable()export class AppService &#123; getHello(): string &#123; return 'Hello World!'; &#125;&#125; provider 의 주요 아이디어는 의존성을 주입할 수 있다는 것입니다. 즉, 개체가 서로 다양한 관계를 만들 수 있으며 개체 인스턴스를 &quot;연결&quot;하는 기능은 대부분 Nest 런타임 시스템에 위임할 수 있습니다. 123456789101112import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getHello(): string &#123; return this.appService.getHello(); &#125;&#125; 위의 AppController 생성자에 변수의 타입을 AppService 로 지정해 줌으로써 Nest Injector 가 appService 변수를 AppService의 인스턴스로 만들어줍니다(인스턴스화한다). Modules NestJS 에는 모듈이 있습니다. @Module() 데코레이터로 모듈을 만들 수 있습니다. Nest 어플리케이션을 만들면 최소 하나의 모듈, 루트 모듈(AppModule)이 있습니다. 이 루트 모듈은 Nest가 Module 및 Provider 관계와 의존성을 해결하는 데 사용하는 내부 데이터 구조를 구축하는 시작점입니다. 모듈을 만들면 루트 모듈과 연결되어야 합니다. 12345678910import &#123; Module &#125; from '@nestjs/common';import &#123; AppController &#125; from './app.controller';import &#123; AppService &#125; from './app.service';@Module(&#123; imports: [], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; @Module() 데코레이터는 하나의 객체를 인자로 가지며, 객체가 가질 수 있는 프로퍼티는 다음과 같습니다. providers: Nest injector에 의해 인스턴스화되고, 인스턴스들은 모듈 안에서 최소한으로 공유됩니다. controllers: 해당 모듈에서 정의된, 인스턴스화되어야 하는 Controller의 집합입니다. imports: 임포트 된 모듈들의 리스트입니다. 이 리스트의 모듈들은 데코레이터에 사용 중인 모듈에서 필요한 providers를 export 하고 있어야 합니다. exports: providers의 하위 집합으로, 데코레이터를 사용 중인 모듈이 제공받은 Provider의 일부를 내보낼 수 있습니다. 이는 다른 모듈에서 import 할 때 사용됩니다. 파일 생성 Module 생성 1nest g mo module-name Controller 생성 1nest g co controller-name Service 생성 1nest g s service-name Provider 생성 1nest g pr provider-name 참고 https://docs.nestjs.com/controllers#controllers https://docs.nestjs.com/controllers#routing https://docs.nestjs.com/providers#providers https://docs.nestjs.com/modules#modules","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"}]},{"title":"[NestJS] 설치 및 프로젝트 생성","slug":"nest-1","date":"2023-05-08T02:22:59.000Z","updated":"2024-01-12T07:17:27.853Z","comments":true,"path":"2023/05/08/nest-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/08/nest-1/","excerpt":"","text":"설치 Nest CLI를 사용하면 새 프로젝트를 설정하는 것이 매우 간단합니다. npm이 설치된 상태에서 터미널에서 다음 명령을 사용하여 Nest CLI를 설치합니다. 1npm i -g @nestjs/cli 프로젝트 생성 nest new 명령어로 새 Nest 프로젝트를 만들 수 있습니다. 1nest new project-name nest new로 프로젝트 생성이 안된다면 npx nest new로 진행합니다. 예시로 프로젝트를 생성해 보겠습니다. 1234567D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? (Use arrow keys)&gt; npm yarn pnpm 기본적으로 npm을 선택합니다. 123456789101112131415161718192021222324252627282930313233D:\\project\\Study\\nestjs&gt; nest new test-nestjs⚡ We will scaffold your app in a few seconds..? Which package manager would you ❤️ to use? npmCREATE test-nestjs/.eslintrc.js (663 bytes)CREATE test-nestjs/.prettierrc (51 bytes)CREATE test-nestjs/nest-cli.json (171 bytes)CREATE test-nestjs/package.json (1942 bytes)CREATE test-nestjs/README.md (3340 bytes)CREATE test-nestjs/tsconfig.build.json (97 bytes)CREATE test-nestjs/tsconfig.json (546 bytes)CREATE test-nestjs/src/app.controller.spec.ts (617 bytes)CREATE test-nestjs/src/app.controller.ts (274 bytes)CREATE test-nestjs/src/app.module.ts (249 bytes)CREATE test-nestjs/src/app.service.ts (142 bytes)CREATE test-nestjs/src/main.ts (208 bytes)CREATE test-nestjs/test/app.e2e-spec.ts (630 bytes)CREATE test-nestjs/test/jest-e2e.json (183 bytes)✔ Installation in progress... ☕🚀 Successfully created project test-nestjs👉 Get started with the following commands:$ cd test-nestjs$ npm run start Thanks for installing Nest 🙏 Please consider donating to our open collective to help us maintain this package. 🍷 Donate: https://opencollective.com/nest 프로젝트에 필요한 파일과 폴더를 생성하고, 패키지들을 설치합니다. Nest CLI를 사용하면 직접 파일을 만들 필요 없어 편리합니다. 프로젝트 시작 파일의 변경 사항을 감시하려면 다음 명령를 실행하여 프로젝트를 시작할 수 있습니다. 이 명령은 파일을 감시하여 자동으로 서버를 다시 컴파일하고 다시 로드합니다. 1npm run start:dev http://localhost:3000/ 주소로 접속해서 정상적으로 시작됐는지 확인합니다. 참고 https://docs.nestjs.com/first-steps","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"}]},{"title":"[Git] detached HEAD 문제 해결 방법","slug":"git-1","date":"2023-05-04T06:22:00.000Z","updated":"2024-01-12T07:16:53.877Z","comments":true,"path":"2023/05/04/git-1/","link":"","permalink":"http://hgko1207.github.io/2023/05/04/git-1/","excerpt":"","text":"git을 사용할 때 add와 commit 까진 실행이 잘 되는데 다음과 같이 detached HEAD 문제로 push 가 안 될 때 해결 방법을 정리하였습니다. 123456D:\\project\\Study\\react&gt; git pushfatal: You are not currently on a branch.To push the history leading to the current (detached HEAD)state now, use git push origin HEAD:&lt;name-of-remote-branch&gt; Detached Head 란, 말 그대로 head가 (branch로부터) 떨어져 있는 상태를 뜻한다. 즉, branch 를 통해서가 아니라 직접 다이렉트로 commit을 참조하고 있는 상태를 뜻한다. git branch 명령어를 사용하여 살펴보니 지금 현재 브랜치는 HEAD detached from bdcfe3d8 로 설정되어 있습니다. 123D:\\project\\Study\\react&gt; git branch -a* (HEAD detached from 537d4a3) master 해결 방법 임시로 새로운 브랜치를 만들어 main 브랜치와 병합하여 해결하는 방법입니다. 브랜치 생성 현재 Head 분기를 참조하게끔 임시 브랜치를 생성합니다. 12git branch tempgit checkout temp 또는 12# -b 명령어 사용git checkout -b temp 이렇게 하면 temp 라는 브랜치가 만들어지고, temp로 checkout을 하게 됩니다. master 브랜치로 이동 1git checkout master 병합 새로운 브랜치와 master 브랜치를 병합합니다. 1git merge temp 새로운 브랜치 삭제 임시로 만든 temp 라는 브랜치를 삭제합니다. 1git branch -d temp push 마지막으로 push 를 실행하면 됩니다. 1git push push를 실행했을 때 다음과 같이 내용이 보이면 git push --set-upstream origin master 명령어를 사용해서 기본 브랜치를 설정합니다. 12345678D:\\project\\Study\\react&gt; git pushfatal: The current branch master has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin masterTo have this happen automatically for branches without a trackingupstream, see 'push.autoSetupRemote' in 'git help config'.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"}]},{"title":"Chocolatey를 이용한 Flutter 설치 방법","slug":"flutter-1","date":"2023-04-25T01:58:13.000Z","updated":"2024-01-12T07:15:39.242Z","comments":true,"path":"2023/04/25/flutter-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/25/flutter-1/","excerpt":"","text":"윈도우 환경에서 Chocolatey를 이용해서 Flutter를 설치하고 안드로이드 기기와 연결하는 방법에 대해 알아보겠습니다. 1. Chocolatey 설치 이전 글 **Chocolatey 설치**를 참고해서 Chocolatey를 먼저 설치를 합니다. 2. Flutter 설치 관리자 권한으로 PowerShell 을 열고 다음 명령어를 실행하여 설치를 합니다. 1choco install flutter 설치가 완료되면 flutter 명령어를 실행하였을 때 다음과 같이 메시지가 나옵니다. 12345678910111213C:\\Windows\\system32&gt; flutterCommon commands: flutter create &lt;output directory&gt; Create a new Flutter project in the specified directory. flutter run [options] Run your Flutter application on an attached device or in an emulator....Run \"flutter help &lt;command&gt;\" for more information about a command.Run \"flutter help -v\" for verbose help output, including less commonly used options. 3. 안드로이드 연결 안드로이드 앱을 개발하려고 한다면 Android setup 사이트에 접속해서 가이드대로 Android 에뮬레이터를 설치하고 연결하면 됩니다. 설치 방법은 아래 기술하였습니다. 1) Android Studio 설치 https://developer.android.com/studio 사이트에 접속해서 Android Studio 를 다운로드합니다. 다운로드가 완료되면 설치를 진행합니다. 2) Android SDK 빌드 도구 설치 Android Studio 를 시작하고 **‘Android Studio Setup Wizard’**를 진행합니다. 이렇게 하면 Android 용으로 개발할 때 Flutter에 필요한 최신 Android SDK, Android SDK Command-line Tools 및 Android SDK Build-Tools 가 설치됩니다. PowerShell에서 flutter doctor 명령어를 실행해서 Flutter 가 설치된 Android Studio를 찾았는지 확인합니다. 1234567891011121314151617C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[!] Android toolchain - develop for Android devices (Android SDK version 33.0.2) X cmdline-tools component is missing Run `path/to/sdkmanager --install \"cmdline-tools;latest\"` See https://developer.android.com/studio/command-line for more details. X Android license status unknown. Run `flutter doctor --android-licenses` to accept the SDK licenses. See https://flutter.dev/docs/get-started/install/windows#android-setup for more details.[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (3 available)[√] Network resources 3) Android 에뮬레이터 설정 Android 에뮬레이터에서 Flutter 앱을 실행하고 테스트할 준비를 하려면 다음 단계를 진행합니다. Machine에서 VM acceleration를 활성화합니다. Android Studio를 실행하고 Tools &gt; Device Manager 메뉴를 클릭하거나 Device Manager 아이콘을 클릭한 다음 Virtual 탭 에서 Create Device를 선택합니다. 이전 버전의 Android Studio에서는 대신 Android Studio &gt; Tools &gt; Android &gt; AVD Manager를 실행하고 Create Virtual Device를 선택해야 합니다. (Android 하위 메뉴는 Android 프로젝트 내부에만 있습니다.) 열려 있는 프로젝트가 없으면 점 3개 Menu / More Actions &gt; Virtual Device Manager 메뉴를 클릭한 다음 Create Device 를 선택할 수 있습니다. Visual Device Configuration 창에서 장치를 선택하고 Next 버튼을 클릭합니다. (저는 Pixel 3 XL 모델을 선택했습니다.) 에뮬레이션 하려는 Android 버전의 시스템 이미지를 하나 이상 선택하고 Next 버튼을 클릭합니다. x86 또는 x86_64 이미지를 권장합니다. Verify Configuration에서 하단에 Emulated Performance에서 Graphics 를 Hardware-GLES 2.0으로 선택 후 Finish 버튼을 클릭하여 하드웨어 가속을 활성화합니다. Android Virtual Device Manager의 도구 모음에서 실행(▶)을 클릭합니다. 에뮬레이터가 시작되고 선택한 OS 버전 및 장치에 대한 기본 캔버스를 표시합니다. 4) Android 라이선스에 동의 Flutter를 사용하려면 먼저 Android SDK 플랫폼의 라이선스에 동의해야 합니다. 이 단계는 위에 나열된 도구를 설치한 후에 수행해야 합니다. 자바 8 버전 이상이 설치되어 있고 JDK의 폴더가 환경 변수 설정되어 있는지 확인합니다. PowerShell 또는 명령 프롬프트에서 다음 명령어를 실행하여 라이언스 서명을 시작합니다. 1flutter doctor --android-licenses 에러 발생 해결 방법 123C:\\WINDOWS\\system32&gt; flutter doctor --android-licensesAndroid sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed toresolve this. 만약 cmdline-tools 가 없으므로 설치하라는 빨간 메시지가 출력된다면 다음의 절차를 진행합니다. Android Studio에서 SDK Manager를 실행합니다. 좌측의 System Settings 에서 Android SDK 를 선택하고 우측 화면에서 SDK Tools 탭을 선택합니다. Android SDK Command-line Tools(latest) 를 체크한 후 OK 버튼을 클릭해 설치를 진행합니다. 설치가 완료되었다면 Finish 를 클릭하고 flutter doctor --android-licenses 명령어를 다시 입력합니다. 이때 동의에 대해 묻는데 y 입력해주시면 됩니다. All SDK package licenses accepted 메시지가 출력 되면 라이센스 동의가 끝났습니다. 1234C:\\WINDOWS\\system32&gt; flutter doctor --android-licenses...Accept? (y/N): yAll SDK package licenses accepted 5) 확인 라이선스 동의가 완료되면 flutter doctor 명령어를 다시 입력하여 Flutter 를 사용할 준비가 되었는지 확인합니다. 1234567891011C:\\WINDOWS\\system32&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel master, 3.10.0-4.0.pre, on Microsoft Windows [Version 10.0.22621.1555], locale ko-KR)[√] Windows Version (Installed version of Windows is version 10 or higher)[√] Android toolchain - develop for Android devices (Android SDK version 33.0.2)[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Professional 2019 16.11.25)[√] Android Studio (version 2022.2)[√] VS Code (version 1.77.1)[√] Connected device (4 available)[√] Network resources 에러 발생 해결 방법 flutter doctor 명령어를 실행하였을 때 Windows 10 SDK 이 없다고 하는 메시지가 출력될 경우 해결 방법입니다. https://visualstudio.microsoft.com/ko/downloads/ 사이트에서 Visual Studio 2022 버전의 무료 다운로드를 클릭하여 다운로드하고 설치해줍니다. Visual Studio Installer 창이 열리면 데스크톱 및 모바일에서 C++를 이용한 데스크톱 개발을 선택 후 설치합니다. 결론 Chocolatey를 사용해서 Flutter를 설치하면 zip 파일을 다운로드하고, 열어서 설치하고, path 설정하고, 여러 가지 설정하는 것보다 훨씬 쉬운 방법입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"}]},{"title":"[Dart] 클래스(Class) 사용 방법","slug":"dart-6","date":"2023-04-18T04:55:52.000Z","updated":"2024-01-12T07:12:44.322Z","comments":true,"path":"2023/04/18/dart-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/18/dart-6/","excerpt":"","text":"Dart에서 클래스(Class) 사용 방법에 대해 알아보겠습니다. Class 클래스 안에서 property를 선언할 때는 타입을 사용해서 정의합니다. 1234567891011121314class Player &#123; final String name = 'eden'; final int age = 3; void sayName() &#123; print(\"Hi my name is $name\"); &#125;&#125;void main() &#123; // new 를 꼭 붙이지 않아도 됩니다. var player = Player(); player.sayName();&#125; 클래스 메서드 안에서는 this 를 붙이지 않는 것을 Dart에서는 권장하나, 어쩔 수 없이 같은 변수명이 있을 때는 this를 붙여서 사용해야 합니다. Constructor 생성자(constructor) 함수는 클래스 이름과 같아야 합니다. 123456789101112131415class Player &#123; // late 사용 late final String name; late final int age; Player(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;void main() &#123; // Player 클래스의 인스턴스 생성 var player = Player(\"eden\", 3);&#125; 위의 생성자 함수는 다음과 같이 줄일 수 있습니다. 1234567class Player &#123; // late 사용 안함 final String name; final int age; Player(this.name, this.age);&#125; 위의 코드는 late 를 사용하였지만 아래 코드에서 사용하지 않은 이유는 생성자 함수를 만들 때 변수에 값을 할당하지 않았기 때문입니다. 이전 생성자 함수를 만들 때에는 this.name = name; 식으로 값을 할당했기 때문에 먼저 선언한 변수에 late 를 붙여야 오류가 발생하지 않습니다. Named Constructor Parameters 클래스가 거대해질 경우 다음과 같이 생성자 함수를 만드는 것은 비효율적일 것입니다. 많은 파라미터를 받아야 하고 각 파라미터의 의미를 알 수가 없습니다. 123456789101112class Team &#123; final String name; int members; int ranking; String description; Team(this.name, this.members, this.ranking, this.description);&#125;void main() &#123; var team = Team(\"Tottenham\", 25, 5, \"Tottenham Hotspur Football Club\");&#125; 문제를 해결하려면 너무 간단합니다. 생성자 함수 생성할 때 중괄호({})를 사용하는 것입니다. 그리고 클래스를 정의할 때 Named Paramaters를 사용합니다. 12345678910111213141516class Team &#123; final String name; int members; int ranking; String description; Team(&#123;this.name, this.members, this.ranking, this.description&#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; 하지만 여기에는 큰 문제가 있습니다. 변수가 null 일 수도 있기 때문에 기본 값(default value)을 주거나 required 파라미터 앞에 붙여 사용합니다. 다음의 코드는 required를 사용하였습니다. 123456789101112131415161718192021class Team &#123; final String name; int members; int ranking; String description; Team(&#123; required this.name, required this.members, required this.ranking, required this.description &#125;);&#125;void main() &#123; var team = Team( name: \"Tottenham\", members: 25, ranking: 5, description: \"Tottenham Hotspur Football Club\");&#125; Named Constructor 콜론(:)을 사용하면 특별한 생성자 함수를 만들 수 있습니다. 콜론을 넣음으로써 dart에게 객체를 초기화하라고 명령할 수 있습니다. 12345678910111213141516171819class Team &#123; String name; int members; String description; Team(&#123;required this.name, required this.members, required this.description&#125;); Team.createTeam(&#123;required String name, required int members&#125;) : this.name = name, this.members = members, this.description = \"$name team is good.\";&#125;void main() &#123; var team = Team.createTeam( name: \"Tottenham\", members: 25, );&#125; Enum Enum 은 우리가 코드를 작성할 때 실수를 하지 않게 도와줍니다. enum type 의 변수들은 해당 enum type에 생성된 값들 중에서만 값이 할당될 수 있습니다. 123456789101112enum Team &#123; red, blue &#125;class Player &#123; String name; Team team; Player(&#123;required this.name, required this.team&#125;);&#125;void main() &#123; var player = Player(name: 'eden', team: Team.red);&#125; Abstract Class 추상 클래스는 다른 클래스들이 직접 구현해야 하는 필드와 메서드들을 모아놓은 클래스입니다. 추상 클래스는 아직 메소드와 내용이 추상적이므로 객체를 생성할 수 없습니다. 추상 클래스를 상속받는 클래스들은 추상 클래스의 메서드들을 구현해야 합니다. 12345678910111213141516171819abstract class Person &#123; void walk();&#125;class Player extends Person &#123; String name; String team; Player(&#123;required this.name, required this.team&#125;); void walk() &#123; print(\"Player is walking\"); &#125;&#125;void main() &#123; var player = Player(name: 'eden', team: 'red'); player.walk();&#125; Mixin Mixin은 생성자가 없는 클래스를 의미합니다. Mixin은 클래스에 코드를 재사용하기 위해 사용되며, 다중 상속의 일부 단점을 보완합니다. Mixin은 extends가 아닌 with 키워드를 사용하여 클래스에 적용합니다. 1234567891011121314151617181920212223242526mixin Strong &#123; final double strengthLevel = 100.5;&#125;mixin Tall &#123; final double height = 180;&#125;mixin QuickRunner &#123; void run() &#123; print(\"run!!\"); &#125;&#125;class Player with Strong, Tall, QuickRunner &#123; final String name; Player(&#123;required this.name&#125;);&#125;void main() &#123; var player = Player( name: \"eden\", ); player.run(); // run!! 출력&#125; 상속과 Mixin 의 차이점 extends를 사용하여 상속받은 클래스는 자식 클래스, 상속한 클래스는 부모클래스가 되는 것이고, 자식 클래스는 부모 클래스를 super 를 통해서 접근할 수 있습니다. Mixin with 라는 키워드를 통해서 단순히 Mixin 내부의 프로퍼티와 메서드들을 가져오는 것뿐입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"}]},{"title":"[Dart] 함수(Function) 사용 방법","slug":"dart-5","date":"2023-04-17T05:57:34.000Z","updated":"2024-01-12T07:11:12.996Z","comments":true,"path":"2023/04/17/dart-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-5/","excerpt":"","text":"Dart에서 함수(Function) 사용 방법에 대해 알아보겠습니다. Functions Dart는 진정한 객체 지향 언어이므로 함수도 객체이며 타입이 Function입니다. 이는 함수를 변수에 할당하거나 다른 함수에 인수로 전달할 수 있음을 의미합니다. 12345678// 하나의 표현식만 포함하는 함수의 경우 아래와 같이 단축 구문을 사용할 수 있습니다.String sayHello(String name) =&gt; \"Hello $&#123;name&#125; nice to meet you!\";num plus(num a, num b) =&gt; a + b;void main() &#123; print(sayHello(\"eden\")); // Hello eden nice to meet you!&#125; Positional Paramaters 함수을 호출할 때 필요한 매개변수와 매개변수의 위치를 정확하게 알아야 합니다. 함수의 매개변수가 많아질수록 함수 호출할 때 다 기억해야 하므로 사용하기 어렵습니다. 1234567String sayHello(String name, int age, String country) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello('eden', 30, 'Korea'));&#125; Named Paramaters 위의 Positional Paramaters 방식은 함수를 호출할 때 사용자가 요소들의 순서를 잊어버릴 수도 있고, 코드를 봤을 때 인자가 뜻하는 것이 무엇인지 바로 이해를 못 할 수도 있습니다. 이 문제를 해결하기 위해 Dart 에서는 Named Paramaters를 지원합니다. 다음과 같이 매개변수 앞뒤로 중괄호를 붙여주면 함수를 호출할 때 매개변수의 이름과 값을 함께 입력할 수 있어 사용자에게 훨씬 편리합니다. 이때 매개변수들의 순서는 지키지 않아도 됩니다. 1234567String sayHello(&#123;String name, int age, String country&#125;) &#123; return \"$&#123;name&#125; / $&#123;age&#125; / $&#123;country&#125;\";&#125;void main() &#123; print(sayHello(name: \"eden\", age: 30, country: \"Korea\"));&#125; 하지만 여기서 또 문제가 발생합니다. Dart는 null safety가 적용되는데, 매개변수 중 하나가 null 일 수도 있기 때문입니다. 다시 말해, 사용자가 name과 age, country 3개의 매개변수 중 하나라도 빼고 보낼 수 있습니다. 이때는 두 가지 옵션이 있습니다. default value 1234567891011String sayHello(&#123; String name = 'ko', int age = 99, String country = 'Italy',&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(sayHello());&#125; 함수를 호출할 때 아무것도 전달하지 않아도 default value가 이미 있으므로 null safety에 걸릴 일이 없습니다. required 다음과 같이 매개변수 앞에 required를 적어주면, 함수가 호출될 때 반드시 required가 적힌 매개변수가 포함되어야 한다는 것입니다. 123456789101112String sayHello(&#123; required String name, required int age, required String country&#125;) &#123; return \"Hello $name, you are $age, and you come from $country\";&#125;void main() &#123; print(🚫sayHello()); // name, country, age가 모두 포함되어야 하기 때문에 dart에서 컴파일하지 않음&#125; Optional Positional Paramaters Dart에서 []은 optional, positional parameter를 명시할 때 사용됩니다. name, age 는 필수값이고 []를 통해 country를 optional 값으로 지정해 줄 수 있습니다. 12345678String sayHello(String name, int age, [String? country = \"Korea\"]) &#123; return 'Hello $&#123;name&#125;, You are $&#123;age&#125; from the $&#123;country&#125;';&#125;void main() &#123; var result = sayHello(\"eden\", 3); print(result); // Hello eden, You are 3 from the Korea&#125; QQ Operator ?? 연산자를 이용하면 왼쪽 값이 null 인지 체크해서 null 이 아니면 왼쪽 값을 리턴하고 null 이면 오른쪽 값을 리턴합니다. 12345678String capitalizeName(String? name) &#123; return name?.toUpperCase() ?? \"NONE\";&#125;void main() &#123; print(capitalizeName(\"eden\")); // EDEN; print(capitalizeName(null)); // NONE&#125; 위의 코드를 더욱 간략하게 만들 수 있습니다. 1String capitalizeName(String? name) =&gt; name?.toUpperCase() ?? \"NONE\"; ??= 연산자를 이용하면 변수 안에 값이 null 일 때를 체크해서 값을 할당해줄 수 있습니다. 1234567void main() &#123; String? name; name ??= \"eden\"; name = null; name ??= \"ko\"; print(name); // ko&#125; TypeDef 자료형에 사용자가 원하는 alias 를 붙일 수 있게 해 줍니다. (자료형 이름의 별명을 만들 때 사용) 12345// 사용 전List reverseListOfNumbers(List list) &#123; var reversed = list.reversed; return reversed.toList();&#125; 1234567891011// 사용 후typedef ListOfInts = List;ListOfInts reverseListOfNumbers(ListOfInts list) &#123; var reversedList = list.reversed.toList(); return reversedList;&#125;void main() &#123; print(reverseListOfNumbers([1, 2, 3])); // [3, 2, 1]&#125; 참고 https://dart.dev/guides/language/language-tour#functions https://dart.dev/guides/language/language-tour#parameters https://dart.dev/guides/language/language-tour#typedefs","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"}]},{"title":"[Dart] Data Types","slug":"dart-4","date":"2023-04-17T05:07:53.000Z","updated":"2024-01-12T07:09:13.930Z","comments":true,"path":"2023/04/17/dart-4/","link":"","permalink":"http://hgko1207.github.io/2023/04/17/dart-4/","excerpt":"","text":"Dart에서 데이터 타입 사용 방법에 대해 알아보겠습니다. 기본 데이터 타입 Dart에는 대표적으로 String, bool, int, double, num 타입이 있습니다. 중요한 점은 이 모든 게 객체(object)라는 것입니다. Dart가 진정한 객체 지향 언어로 불리는 이유입니다. 12345678void main() &#123; String name = \"eden\"; bool isPlay = true; int age = 3; double money = 59.99; num x = 12; num y = 1.2;&#125; String Interpoldation String Interpoldation은 텍스트에 변수를 추가하는 방법입니다. 단순히 변수의 값을 넣고 싶다면 $달러 기호 뒤에 사용할 변수를 적어주면 됩니다. 변수의 값을 계산하고 싶다면 $와 함께 중괄호(`${ })내에 계산할 내용을 적어주면 됩니다. 123456void main() &#123; var name = \"eden\"; var age = 3; var greeting = \"hello $name, I'm $&#123;age + 5&#125; years old.\"; print(greeting);&#125; Lists Dart에서 List를 선언하는 것은 두 가지 방법이 있습니다. 123456void main() &#123; List&lt;int&gt; numbers = [1, 2, 3]; numbers.add(4); var number2 = [4, 5, 6];&#125; Dart에서 List의 유용한 점은 collection if와 collection for를 지원합니다. collection if collection if는 List를 만들 때, if를 통해 존재할 수도 안 할 수도 있는 요소를 가지고 만들 수 있습니다. 1234567891011void main() &#123; var giveMeFive = true; var item = [ 1, 2, 3, 4, if (giveMeFive) 5, // giveMeFive가 true이면 5가 추가됨 ]; print(item);&#125; Collection For Dart에서는 반복(for)을 사용하여 컬렉션을 구축하는 데 사용할 수 있는 Collection for를 제공합니다. 12345678910void main() &#123; var oldFriends = [\"ko\", \"lee\"]; var newFriends = [ \"eden\", \"woorim\", for (var friend in oldFriends) \"🥰 $friend\" ]; print(newFriends); // [eden, woorim, 🥰 ko, 🥰 lee]&#125; Maps 일반적으로 Map은 key와 value를 연결하는 객체입니다. 키와 값 모두 모든 유형의 객체가 될 수 있습니다. 각 키는 한 번만 발생하지만 동일한 값을 여러 번 사용할 수 있습니다. Map을 정의하는 방법은 두 가지가 있습니다. 첫 번째는 var 를 이용한 방법입니다. 두 번째는 var 대신 Map 을 사용하고, 자료형을 명시하는 것입니다. 1234567891011121314// 첫 번째var gifts = &#123; // Key: Value 'first': 'smartphone', 'second': 'laptop', 'third': 'bicycle'&#125;;// 두 번째Map players = &#123; 1 : true, 2 : false, 3 : true,&#125;; 12345// Map 생성자를 사용하여 동일한 객체를 만들 수 있습니다.var gifts = Map();gifts['first'] = 'smartphone';gifts['second'] = 'laptop';gifts['third'] = 'bicycle'; Sets Set에 속한 모든 아이템들이 유니크해야 될 때 사용합니다. 유니크할 필요가 없다면 List를 사용하면 됩니다. Set도 두 가지 방법으로 정의할 수 있습니다. 12345678910void main() &#123; var numbers1 = &#123;1, 2, 3&#125;; Set numbers2 = &#123;1, 2, 3&#125;; Set&lt;int&gt; numbers3 = &#123;1, 2, 3&#125;; numbers3.add(1); numbers3.add(2); numbers3.add(4); print(numbers3) // &#123;1, 2, 3, 4&#125;&#125; List는 대괄호를 쓰며 Set은 중괄호를 쓴다는 점이 다릅니다. List는 같은 요소가 여러 개 반복될 수 있지만, Set은 중복이 허용되지 않습니다. 참고 https://dart.dev/guides/language/language-tour#collection-operators https://dart.dev/guides/language/language-tour#maps https://dart.dev/guides/language/language-tour#sets","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"}]},{"title":"[Dart] Null Safety","slug":"dart-3","date":"2023-04-14T05:10:05.000Z","updated":"2024-01-12T07:07:10.075Z","comments":true,"path":"2023/04/14/dart-3/","link":"","permalink":"http://hgko1207.github.io/2023/04/14/dart-3/","excerpt":"","text":"Null Safety는 개발자가 null 값을 참조할 수 없게 하는 것입니다. 다음 코드를 봅시다. 123456bool isEmpty(String string) =&gt; string.length == 0;main()&#123; // [오류] isEmpty(🚫null);&#125; 다음과 같은 코드는 어떻게 실행될까요? 정답은 NoSuchMethodError를 실행합니다. 왜 이렇게 실행될까요? 바로 String을 보내야 할 곳에 null을 보냈기 때문입니다. null 에는 length 라는 속성이 없기 때문이기도 합니다. 이와 같은 에러는 컴파일러에서 잡을 수 있는 에러가 아닙니다. 이런 상황이 발생하지 않도록 null 를 삭제하기에는 null 값은 유용합니다. 그럼 어떻게 null 값을 참조하는 것을 dart 는 어떻게 보호할까요? dart에서는 변수가 null이 될 수 있음을 명확히 표시해야 합니다. 다음 코드를 봅시다. 1234void main() &#123; String name = \"eden\"; 🚫name = null;&#125; 이 코드는 에러가 납니다. name 이 null 값을 참조할 수 있다고 알려주지 않고 null 값을 참조하기 때문입니다. 그러면 다음 코드를 봅시다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; 이 코드는 에러가 나지 않습니다. 차이점이 뭘까요? 바로 변수 뒤에 ?를 사용해 이 변수에는 null 이 참조될 수 있음을 알려주는 것입니다. 만약 ?를 붙인 변수는 이 변수가 null 인지 아닌지 확인해야 합니다. 12345678void main() &#123; String? name = \"eden\"; name = null; if (name != null) &#123; print(name.length); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"}]},{"title":"[Dart] 변수(Variable) 사용 방법","slug":"dart-2","date":"2023-04-13T02:09:29.000Z","updated":"2024-01-12T07:06:15.658Z","comments":true,"path":"2023/04/13/dart-2/","link":"","permalink":"http://hgko1207.github.io/2023/04/13/dart-2/","excerpt":"","text":"Dart에서 변수 사용 방법에 대해 알아보겠습니다. 변수를 만드는 2가지 방법 dart에서는 변수를 var 키워드 또는 명시적으로 변수의 타입을 지정해서 사용합니다. 다른 타입의 변수는 서로 대입할 수 없습니다. 1234567// 방법 1void main() &#123; var name = \"car\"; name = \"bus\"; // [오류] 🚫 name = 1;&#125; 12345// 방법 2void main() &#123; String name = \"car\"; name = \"bus\";&#125; var를 사용하는 게 dart 스타일가이드의 권장 방식입니다. 함수나 메소드 내부에 지역변수를 선언할 때는 var를 사용하고 class에서 변수나 property를 선언할 때는 타입을 지정해 줍니다. Dynamic 타입 여러 가지 타입을 가질 수 있는 변수에 쓰는 키워드입니다. 변수를 선언할 때 dynamic을 쓰거나 값을 지정하지 않으면 dynamic 타입을 가집니다. 1234void main() &#123; dynamic name; var name2;&#125; 123456void main() &#123; var name; name = 'car'; name = 1; name = true;&#125; dynamic 타입은 언제 사용될까? 해당 변수의 타입을 알 수 없을 때 주로 사용합니다. 예를 들어 json을 작업할 경우입니다. 하지만 dynamic 타입은 다양한 타입을 가질 수 있기 때문에 정말 필요할 때만 사용해야 합니다. (위험 방지) Null Safety null safety는 개발자가 null 값을 참조할 수 없도록 하는 것입니다. String 뒤에 ?를 붙여줌으로써 name 이 String 또는 null 이 될 수 있다고 명시해 준 것입니다. 기본적으로 모든 변수는 non-nullable(null이 될 수 없음)입니다. 1234void main() &#123; String? name = \"eden\"; name = null;&#125; final 변수 var 대신 final로 변수를 만들게 되면 이 변수는 수정할 수 없게 됩니다. (딱 한 번만 설정될 수 있음) 자바스크립트의 const 랑 비슷합니다. 1234567void main() &#123; final name = \"pizza\"; 🚫name = \"ham\"; // 수정 불가 final String username = \"eden\"; 🚫name = \"eden2\"; // 수정 불가&#125; late 변수 초기 데이터 없이 먼저 변수를 생성하고 추후에 데이터를 넣을 때 주로 사용합니다. flutter로 data fecthing을 할 때 유용합니다. late 변수를 만들고, API에 요청을 보낸 뒤에 API에서 값을 보내주면 그 응답 값을 late 변수에 넣어 사용할 수 있습니다. 123456789void main() &#123; late final String name; 🚫print(name); // 값을 넣기 전에는 name 변수에 접근 불가 // do something, go to api name = 'api'; // 한번만 할당해 줄 수 있음 🚫name = 'test';&#125; const 변수 dart에서 const는 compile-time constant를 만들어줍니다. const는 컴파일할 때 알고 있는 값을 사용해야 합니다. 만약 어떤 값인지 모르고, 그 값이 API로부터 오거나 사용자가 화면에서 입력해야 하는 값이라면 그건 const가 아닌 final이나 var가 되어야 합니다. 1234567void main() &#123; // 컴파일 시점에 바뀌지 않는 값 const API_KEY = \"********\"; // 컴파일 시점에 바뀌는 값 final API = fetchAPI();&#125; const: 컴파일 시점에 바뀌지 않는 값 (상수) final: 컴파일 시점에 바뀌는 값 (API에서 받아온 값, 사용자 입력값)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"}]},{"title":"[Dart] 시작하기","slug":"dart-1","date":"2023-04-12T01:35:46.000Z","updated":"2024-01-12T07:04:33.093Z","comments":true,"path":"2023/04/12/dart-1/","link":"","permalink":"http://hgko1207.github.io/2023/04/12/dart-1/","excerpt":"","text":"Dart 란 Dart는 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다. UI 최적화용 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발합니다. 생산적인 개발 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인 가능합니다. 모든 플랫폼에서 빠름 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript 로 컴파일합니다. Why Dart Dart 의 컴파일러 기술을 사용하면 다양한 방식으로 코드를 실행할 수 있습니다. 기본 플랫폼(Dart Native): 모바일 및 데스크톱 장치를 대상으로 하는 앱의 경우 Dart에는 JIT(Just-In-Time) 컴파일 기능이 있는 Dart VM과 기계 코드 생성을 위한 AOT(Ahead-of-Time) 컴파일러가 모두 포함되어 있습니다. 웹 플랫폼(Dart Web): 웹을 대상으로 하는 앱의 경우 Dart 는 개발 또는 프로덕션 목적으로 컴파일할 수 있습니다. 웹 컴파일러는 Dart를 JavaScript로 변환합니다. 또 다른 특징 null safety 특성을 가집니다. c 또는 java 에서 null 참조하면 오류가 발생합니다. flutter, dart 둘 다 구글에서 개발한 것입니다. 즉 flutter의 성능 향상을 위해 dart를 최적화할 수 있습니다. flutter가 dart에 대해 뭔가 필요한 게 있으면, flutter를 위해 dart를 수정할 수 있습니다. react-native, django, flask 등 다른 프레임워크들은 사용하는 언어를 수정할 수 없다는 점이 다릅니다. main 함수 main 함수는 모든 Dart 프로그램의 Entry point 입니다. main 함수에서 쓴 코드가 호출됩니다. (만약 main 함수가 없다면 실행이 되지 않음) dart는 자동으로 세미콜론을 붙여주지 않기 때문에 직접 붙여야 합니다. (일부러 세미콜론을 안 쓸 때가 있기 때문입니다.) 123void main() &#123; print(\"hello world\");&#125; Flutter Flutter 프레임워크는 인기 있는 다중 플랫폼 UI 툴킷으로 Dart 플랫폼으로 구동되며 iOS, Android, macOS, Windows, Linux 및 웹에서 실행되는 UI 경험을 빌드하기 위한 도구 및 UI 라이브러리를 제공합니다. 참고 https://dart.dev/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"}]},{"title":"[TypeScript] JSDoc Reference 사용 방법","slug":"typescript-7","date":"2023-04-11T05:53:58.000Z","updated":"2024-01-12T07:03:21.079Z","comments":true,"path":"2023/04/11/typescript-7/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-7/","excerpt":"","text":"JavaScript 파일에서 TypeScript처럼 코드를 보호받을 수 있도록 하는 방법에 대해 알아보겠습니다. @ts-check JavaScript 파일에서 오류를 활성화하려면 // @ts-check를 .js 파일의 첫 번째 줄에 추가하여 TypeScript가 오류를 발생시키도록 합니다. TypeScript는 여러 오류를 제공할 수 있습니다. 아래 코드는 TypeScript와 같이 함수 파라미터에 정의가 되어 있지 않아 오류가 발생합니다. 1234567891011// @ts-check// [오류]export function init(🚫 config) &#123; return true;&#125;// [오류]export function exit(🚫 code) &#123; return code + 1;&#125; 이러한 오류를 무시하고 싶다면 // @ts-ignore 또는 // @ts-expect-error를 추가하여 특정 줄의 오류를 무시할 수 있습니다. JSDoc Reference JSDoc 주석을 사용하여 JavaScript 파일에 type 정보를 제공할 수 있습니다. (자바스크립트 파일에서 타입 정보를 제공할 수 있습니다.) 123456789101112131415161718192021// @ts-check/** * Initializes the project * @param &#123;object&#125; config * @param &#123;boolean&#125; config.debug * @param &#123;string&#125; config.url * @returns &#123;boolean&#125; */export function init(config) &#123; return true;&#125;/** * Exits the program * @param &#123;number&#125; code * @returns &#123;number&#125; */export function exit(code) &#123; return code + 1;&#125; JSDoc 주석을 통해 타입을 정의하고 TypeScript 파일에서 다음과 같이 함수를 사용할 수 있습니다. 123456init(&#123; debug: false, url: 'true',&#125;);exit(1); 주의 사항 @ts-check를 사용하면 JavaScript 파일 내에서 타입 검사를 허용합니다. @ts-check를 사용하지 않고 JSDoc 만 사용하면 TypeScript 파일에서는 JavaScript의 타입을 검사 하지만, JavaScript 내에서는 단순 주석이나 타입을 명시하는 정도로만 사용할 수 있는 것 같습니다 참고 https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"}]},{"title":"[TypeScript] 설치 및 설정 방법","slug":"typescript-6","date":"2023-04-11T02:10:23.000Z","updated":"2024-01-12T07:02:38.035Z","comments":true,"path":"2023/04/11/typescript-6/","link":"","permalink":"http://hgko1207.github.io/2023/04/11/typescript-6/","excerpt":"","text":"NextJS, Create React App(CRA)를 사용하지 않고 초기 프로젝트에 TypeScript를 설치하고 설정하는 방법에 대해 알아보겠습니다. 프로젝트 시작 프로젝트 디렉터리를 생성합니다. 12$ mkdir typescripttest$ cd typescripttest 다음 명령어를 실행하여 package.json을 초기화합니다. 1$ npm init -y TypeScript 설치 다음 명령어를 실행하여 TypeScript 설치합니다. 1$ npm i -D typescript tsconfig.json 설정 TypeScript 설정은 tsconfig.json 파일에서 합니다. 디렉터리에 tsconfig.json 파일이 있으면 해당 디렉터리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일과 컴파일러 옵션을 지정합니다. tsconfig.json 파일을 생성합니다. 다음과 같이 기본적인 설정을 작성합니다. 1234567// tsconfig.json&#123; \"include\": [\"src\"], // 자바스크립트로 컴파일 하고 싶은 모든 디렉터리 \"compilerOptions\": &#123; \"outDir\": \"build\" // 자바스크립트 파일로 생성될 디렉터리(빌드 디렉터리) &#125;&#125; 다음 명령어로도 기본적인 tsconfig.json 파일 생성이 가능합니다. 12$ npm i -g typescript$ tsc --init Target (기본값: ES3) 최신 브라우저는 모든 ES6 기능을 지원하므로 ES6는 좋은 선택입니다. 코드가 이전 환경에 배포된 경우 더 낮은 target을 설정하거나 최신 환경에서 코드 실행이 보장되는 경우 더 높은 target을 설정하도록 선택할 수 있습니다. 12345678// tsconfig.json&#123; \"include\": [\"src\"], \"compilerOptions\": &#123; \"outDir\": \"build\", \"target\": \"ES6\" &#125;&#125; Lib(라이브러리) 타입스크립트에게 어떤 API를 사용하고 어떤 환경에서 코드를 실행하는 지를 지정할 수 있습니다. (target 런타임 환경이 무엇인지를 지정합니다.) 프로그램이 브라우저에서 실행되면 lib에 “DOM” 유형 정의를 할 수 있습니다. DOM: window, document 등 123456// ex)&#123; \"compilerOptions\": &#123; \"lib\": [\"ES6\", \"DOM\"] &#125;&#125; strict 모든 엄격한 타입 검사 옵션을 활성화합니다. strict 플래그는 프로그램 정확성을 더 강력하게 보장하는 광범위한 타입 검사 동작을 가능하게 합니다. tsconfig.json 에서 &quot;strict&quot;: true를 통해 strict mode로 해주면, Declaration Files 가 없는 경우에 대해서도 에러를 띄워줍니다. 12345&#123; \"compilerOptions\": &#123; \"strict\": true &#125;&#125; 참고 https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content https://www.typescriptlang.org/tsconfig#target https://www.typescriptlang.org/tsconfig#lib https://www.typescriptlang.org/tsconfig#strict","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"}]},{"title":"[TypeScript] 인터페이스(Interface) 사용 방법","slug":"typescript-5","date":"2023-04-06T14:20:26.000Z","updated":"2024-01-12T07:01:14.780Z","comments":true,"path":"2023/04/06/typescript-5/","link":"","permalink":"http://hgko1207.github.io/2023/04/06/typescript-5/","excerpt":"","text":"TypeScript에서 인터페이스(Interface)를 생성하고 사용하는 방법에 대해 알아보겠습니다. Interfaces 객체의 모양을 특정해 주기 위해 사용합니다. 여기서는 firstName 및 lastName 필드가 있는 객체를 설명하는 인터페이스를 사용합니다. 1234interface Person &#123; firstName: string; lastName: string;&#125; 다른 인터페이스를 상속 받아 사용할 수 있습니다. 123456789interface User &#123; name: string;&#125;interface Player extends User &#123;&#125;const eden: Player = &#123; name: 'eden',&#125;; 인터페이스 이름이 같도록 3번 각각 만들어도 타입스크립트는 알아서 하나로 합쳐줍니다. Type과 차이점입니다. 1234567891011121314151617interface User &#123; name: string;&#125;interface User &#123; nickname: string;&#125;interface User &#123; age: number;&#125;const eden: User = &#123; name: 'eden', nickname: 'ko', age: 30,&#125;; implements implements 을 사용하여 클래스가 특정 인터페이스를 충족하는지 확인할 수 있습니다. 클래스를 올바르게 구현하지 못하면 오류가 발생합니다. implements 절은 클래스가 인터페이스 유형으로 처리될 수 있는지 확인하는 것입니다. 클래스의 유형이나 메서드는 전혀 변경하지 않습니다. 또한 클래스는 여러 인터페이스를 구현할 수도 있습니다. 12// ex) 클래스 C 는 A, B 를 구현합니다.class C implements A, B &#123;&#125; 1234567891011interface Pingable &#123; ping(): void;&#125;// Sonar 클래스는 Pingable 인터페이스를 implement 했기 때문에// Pingable 가 가진 ping 메서드를 구현해줘야 합니다.class Sonar implements Pingable &#123; ping() &#123; console.log('ping!'); &#125;&#125; 여러 개의 인터페이스를 상속받아 사용할 수 있습니다. 123456789101112interface User &#123; firstName: string; lastName: string;&#125;interface Human &#123; health: number;&#125;class Player implements User, Human &#123; constructor(public firstName: string, public lastName: string, public health: number) &#123;&#125;&#125; Type Aliases 과 Interfaces의 차이점 Type Aliases 과 인터페이스는 매우 유사하며 많은 경우 자유롭게 선택할 수 있습니다. 인터페이스의 거의 모든 기능은 type에서 사용할 수 있으며, 주요 차이점은 type을 다시 열어 새 속성을 추가할 수 없는 것입니다. 반면 인터페이스는 항상 확장 가능합니다. 참고 https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[TypeScript] 클래스(Class) 사용 방법","slug":"typescript-4","date":"2023-03-29T05:20:34.000Z","updated":"2024-01-12T07:00:38.265Z","comments":true,"path":"2023/03/29/typescript-4/","link":"","permalink":"http://hgko1207.github.io/2023/03/29/typescript-4/","excerpt":"","text":"TypeScript에서 클래스(Class)를 생성하고 사용하는 방법에 대해 알아보겠습니다. 클래스(Class) 가장 기본적인 클래스입니다. 1class Player &#123;&#125; 필드를 선언해서 사용 가능합니다. 12345678class Player &#123; firstname: string; lastname: string;&#125;const eden = new Player();eden.firstname = 'ko';eden.lastname = 'eden'; 생성자에 매개변수를 추가해서 선언할 수 있습니다. 1234567891011121314class Player &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123;&#125;&#125;const eden = new Player(\"ko\", \"eden\", \"고수\");// [오류]// firstname는 private 이기 때문에 접근 불가// javascript 에서는 아무 문제없이 작동함🚫 eden.firstname; public: 모든 클래스에서 접근 가능 private: 해당 클래스 내에서만 접근 가능 (자식 클래스에서도 접근 불가) protected: 해당 클래스와 자식 클래스에서 접근 가능 추상 클래스(Abstract Class) TypeScript와 객체지향 프로그램이 가지고 있는 엄청 훌륭한 것은 추상 클래스(Abstract Class)라고 생각됩니다. 추상클래스는 다른 클래스가 상속받을 수 있는 클래스입니다. 하지만 이 클래스는 직접 새로운 인스턴스를 만들 수는 없습니다. 1234567891011121314151617abstract class User &#123; constructor( private firstname: string, private lastname: string, public nickname: string ) &#123; abstract getNickname(): void getFullName() &#123; return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;`; &#125; &#125;&#125;// [오류]// TypeScript 가 추상 클래스의 인스턴스를 만들 수 없다고 경고함🚫 const eden = new User(\"ko\", \"eden\", \"고수\"); 12345678910class Player extends User &#123; // 추상 메서드는 추상 클래스를 상속받는 클래스들이 반드시 구현(implement)해야하는 메서드입니다. getNickname() &#123; console.log(this.nickname); &#125;&#125;const eden = new Player('ko', 'eden', '고수');eden.getNickname();eden.getFullName(); 추상 클래스를 사용하기 위해서는 상속을 받아 사용합니다. Static Members 클래스에는 static 멤버가 있을 수 있습니다. 이 멤버는 클래스의 특정 인스턴스와 연결되지 않습니다. 클래스 생성자 객체 자체를 통해 액세스 할 수 있습니다. static 멤버는 동일한 public, protected 및 private과 함께 사용할 수도 있습니다. 12345678910class MyClass &#123; static x = 0; static printX() &#123; console.log(MyClass.x); &#125;&#125;console.log(MyClass.x);MyClass.printX(); 참고 https://www.typescriptlang.org/docs/handbook/2/classes.html https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"}]},{"title":"[TypeScript] 다형성(Polymorphism)","slug":"typescript-3","date":"2023-03-16T05:59:01.000Z","updated":"2024-01-12T06:59:18.061Z","comments":true,"path":"2023/03/16/typescript-3/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-3/","excerpt":"","text":"다형성(Polymorphism) 다형성이란, 여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미합니다. poly: many, serveral, much, multi 등과 같은 뜻 morphos: form, structure 등과 같은 뜻 polymorphos = poly + morphos: 여러 다른 구조 예시 123456789101112type SuperPrint = &#123; (arr: T[]): T;&#125;;const superPrint: SuperPrint = (arr) =&gt; &#123; return arr[0];&#125;;const a = superPrint([1, 2, 3]);const b = superPrint([true, false, true]);const c = superPrint(['a', 'b']);const d = superPrint([1, 2, 'a', 'b', true]); any, generics 차이점 any를 사용하는 것은 어떤 타입이든 받을 수 있다는 점에서 generics과 같지만 함수를 반환하는 데 있어 any는 받았던 인수들의 타입을 활용하지 못합니다. 즉, generics 은 어떤 타입이든 받을 수 있다는 점에서 any와 같지만 해당 정보를 잃지 않고 타입에 대한 정보를 다른 쪽으로 전달할 수 있다는 점이 다릅니다. Generics 제네릭은 C#이나 Java와 같은 언어에서 재사용 가능한 컴포넌트를 만들기 위해 사용하는 기법입니다. 단일 타입이 아닌 다양한 타입에서 작동할 수 있는 컴포넌트를 생성할 수 있습니다. (구체적인 타입을 지정하지 않고 다양한 인수와 리턴 값에 대한 타입을 처리할 수 있습니다.) 타입스크립트에서 제네릭을 통해 인터페이스, 함수 등의 재사용성을 높일 수 있습니다. 1234567891011function identity&lt;Type&gt;(arg: Type): Type &#123; return arg;&#125;// 제네릭 화살표 함수 (tsx기준)const identity = &lt;Type extends &#123;&#125;&gt;(arg: Type): Type =&gt; &#123; return arg;&#125;;let output = identity&lt;string&gt;('myString'); // 첫 번째 방법let output = identity('myString'); // 두 번째 방법 위에서 두 번째 방법은 type argument inference(타입 인수 유추)를 사용합니다. 즉, 컴파일러가 전달하는 인수 유형에 따라 자동으로 Type 값을 설정하기를 원합니다. 참고 https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"}]},{"title":"[TypeScript] Function Overloads","slug":"typescript-2","date":"2023-03-16T05:47:52.000Z","updated":"2024-01-12T06:54:18.471Z","comments":true,"path":"2023/03/16/typescript-2/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/typescript-2/","excerpt":"","text":"Function Overloads 동일한 이름에 매개 변수와 매개 변수 타입 또는 리턴 타입이 다른 여러 버전의 함수를 만드는 것을 말합니다. TypeScript에서는 오버로드 signatures을 작성하여 **“다양한 방식으로 호출할 수 있는 함수”**를 지정할 수 있습니다. 사용 예제 매개변수의 데이터 타입이 다른 경우 매개변수의 데이터 타입이 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: string): number;&#125;;const add: Add = (a, b) =&gt; &#123; if (typeof b === 'string') return a; return a + b;&#125;;add(1, '2');add(1, 2); 매개변수의 수가 다른 경우 매개변수의 수가 다른 경우 예외 처리를 합니다. 123456789101112type Add = &#123; (a: number, b: number): number; (a: number, b: number, c: number): number;&#125;;const add2: Add = (a, b, c?: number) =&gt; &#123; if (c) return a + b + c; return a + b;&#125;;add(1, 2);add(1, 2, 3); 참고 https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"}]},{"title":"[WPF] 문자열(string)의 가로 세로 길이 계산","slug":"wpf-10","date":"2023-03-16T01:53:23.000Z","updated":"2024-01-12T06:59:58.582Z","comments":true,"path":"2023/03/16/wpf-10/","link":"","permalink":"http://hgko1207.github.io/2023/03/16/wpf-10/","excerpt":"","text":"WPF에서 글꼴 크기(FontSize)와 폰트(FontFamily)를 통해 문자열의 크기를 계산하는 방법에 대해 알아보겠습니다. FormattedText를 사용하여 텍스트의 서식을 지정한 후 크기를 계산할 수 있습니다. 소스코드 TextBlock 컨트롤을 사용할 경우 다음과 같이 작성하여 문자열의 크기를 구합니다. 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"textBlock\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(TextBlock textBlock)&#123; FormattedText formattedText = new FormattedText ( textBlock.Text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( textBlock.FontFamily, textBlock.FontStyle, textBlock.FontWeight, textBlock.FontStretch ), textBlock.FontSize, textBlock.Foreground, VisualTreeHelper.GetDpi(textBlock).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; TextBlock 컨트롤을 사용하지 않고 string 문자열과 글꼴 크기, 폰트를 입력하여 길이를 구할 수 있습니다. 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 글자 가로 세로 길이 계산/// &lt;/summary&gt;/// &lt;param name=\"text\"&gt;&lt;/param&gt;/// &lt;param name=\"fontSize\"&gt;&lt;/param&gt;/// &lt;param name=\"fontFamily\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Size MeasureString(string text, int fontSize, FontFamily fontFamily)&#123; FormattedText formattedText = new FormattedText ( text, CultureInfo.CurrentUICulture, FlowDirection.LeftToRight, new Typeface ( fontFamily, FontStyles.Normal, FontWeights.Bold, FontStretches.Normal ), fontSize, Brushes.Black, VisualTreeHelper.GetDpi(this).PixelsPerDip ); return new Size(formattedText.Width, formattedText.Height);&#125; 사용 방법 TextBlock 컨트롤을 사용할 경우 사용 방법입니다. 123456789101112TextBlock textBlock = new TextBlock&#123; Text = \"test\", FontFamily = new FontFamily(\"Arial\"), FontSize = 16, Foreground = Brushes.Red&#125;;Size textSize = MeasureString(textBlock);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); TextBlock 컨트롤을 사용하지 않을 경우 사용 방법입니다. 12345678string text = \"hello eden\";int fontSize = 32;FontFamily fontFamily = new FontFamily(\"Arial\");Size textSize = MeasureString(text, fontSize, fontFamily);Console.Write(\"Width =&gt; \" + textSize.Width);Console.Write(\"Height =&gt; \" + textSize.Height); 참고 https://learn.microsoft.com/ko-kr/dotnet/api/system.windows.media.formattedtext?view=netframework-4.7.2","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"}]},{"title":"[TypeScript] Types","slug":"typescript-1","date":"2023-03-13T04:56:29.000Z","updated":"2024-01-12T06:50:13.257Z","comments":true,"path":"2023/03/13/typescript-1/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/typescript-1/","excerpt":"","text":"타입스크립트란? TypeScript는 JavaScript에 추가적인 구문을 추가하여 editor 와의 단단한 통합을 지원합니다. editor에서 초기에 오류를 잡을 수 있습니다. TypeScript 코드는 JavaScript가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript로 변환될 수 있습니다. TypeScript는 JavaScript를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다. Types(기본) ✅ 배열: 자료형[] ✅ 숫자: number ✅ 문자열: string ✅ 논리: boolean 123456type Player = &#123; name: string; age: number; weapons: string[]; attack: bool;&#125;; optional 사용 ?를 :앞에 붙이면 optional 사용 가능합니다. 123456const player: &#123; name: string; age?: number;&#125; = &#123; name: 'eden',&#125;; 위와 같이 player.age를 optional로 설정할 경우 Typescript는 player.age가 undefined 일수도 있다고 오류를 알려줍니다. 123// ❌ player.age 가 undefined 일 가능성 알림if (player.age &lt; 10) &#123;&#125; player.age가 존재하는지 확인을 거쳐야 오류 알림이 사라집니다. 123// ⭕ player.age 가 undefined 일 가능성 체크if (player.age &amp;&amp; player.age &lt; 10) &#123;&#125; Alias(별칭) 타입 12345678type Player = &#123; name: string; age?: number;&#125;;const player: Player = &#123; name: 'eden',&#125;; readonly 사용 변수 또는 별칭 앞에 readonly를 붙이면 readonly 사용 가능합니다. 1234type Player = &#123; readonly name: string; age?: number;&#125;; readonly가 있으면 최초 선언 후 수정 불가합니다. 불변성(immutability)이 부여됩니다. 하지만 javascript에서는 그냥 배열로 인식하여 수정이 됩니다. 123456789const playerMaker = (name: string): Player =&gt; (&#123; name &#125;);const player = playerMaker('eden');// [오류]🚫 player.name = \"khk\"const numbers: readonly number[] = [1, 2, 3, 4];// [오류]🚫 numbers.push(5) Tuple 타입 정해진 개수와 순서에 따라 배열 선언이 가능합니다. 123const player: [string, number, boolean] = ['eden', 1, true];// [오류]🚫 player[0] = 1 // 바꿀 수 없습니다. string으로 지정됨 readonly도 사용 가능 합니다. 1const player: readonly [string, number, boolean] = ['eden', 1, true]; any / undefined / null 타입 ✅ any: 어떠한 타입도 허용 12const a: any[] = [1, 2, 3, 4];const b: any = true; ✅ undefined: undefined 값만 가질 수 있음 ✅ null: null 값만 가질 수 있음 123456let nullable: null = null;let undefinedable: undefined = undefined;// [오류]// 'undefined' 형식은 'null' 형식에 할당할 수 없습니다.🚫 nullable = undefined; void 타입 void는 값을 반환하지 않는 함수의 반환 값을 나타냅니다. 함수에 return 문이 없거나 해당 return 문에서 명시적 값을 반환하지 않을 때 항상 유추되는 타입입니다. 1234// The inferred return type is voidfunction noop() &#123; return;&#125; 1234567function test() &#123; console.log('x')&#125;const a = test()// [오류]🚫 a.toUpperCase() unknown 타입 unknown 타입은 모든 값을 나타냅니다. 이것은 any 타입과 비슷하지만 any 보다 unknown 이 더 안전합니다. 이유는 unknown 값으로 작업을 수행하는 것은 합법적이지 않기 때문입니다. 1234567function test(a: any) &#123; a.b(); // OK&#125;function test2(a: unknown) &#123; 🚫 a.b(); // 에러: Object is of type 'unknown'.&#125; never 타입 never 타입은 모든 타입에 할당 가능한 하위 타입이나, never 타입에는 본인 외에 다른 타입이 할당될 수는 없습니다. never 타입은 절대 발생할 수 없는 타입을 나타냅니다. 가장 흔한 예제로는 에러를 발생시킬 때 사용됩니다. 123function fail(msg: string): never &#123; throw new Error(msg);&#125; 사용법에 대해 좀 더 찾아봐야겠지만 그 외에도 특정 타입 값을 할당받지 않도록 하거나, 매개변수의 제한을 건다거나 뭐 그런 곳들에 사용된다는데, 사실 많이 사용하는 타입은 아니라고 봐도 무방합니다. 참고 타입스크립트 코드 테스트 타입스크립트 핸드북","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"}]},{"title":"[WPF] Grid를 Bitmap 이미지로 변환 후 저장하기","slug":"wpf-9","date":"2023-03-13T01:49:24.000Z","updated":"2024-01-12T06:53:56.071Z","comments":true,"path":"2023/03/13/wpf-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/13/wpf-9/","excerpt":"","text":"WPF의 Grid를 사용하여 사용자의 입력을 받는 문서를 작성하거나 여러 이미지를 가시화할 시, 이를 이미지로 저장하는 기능이 필요할 경우가 있습니다. 따라서 Grid 컨트롤을 하위 요소들과 함께 Bitmap으로 변환하고 이미지를 저장하는 방법에 대해 알아보겠습니다. 소스코드 먼저 Grid 컨트롤 내용들을 Bitmap으로 변환합니다. 1234567891011121314151617181920212223/// &lt;summary&gt;/// Grid를 Bitmap이미지로 변환/// &lt;/summary&gt;/// &lt;param name=\"element\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static RenderTargetBitmap GetBitmapFromControl(FrameworkElement element)&#123; Size size = new Size(element.ActualWidth, element.ActualHeight); if (size.IsEmpty) return null; DrawingVisual drawingVisual = new DrawingVisual(); using (DrawingContext context = drawingVisual.RenderOpen()) &#123; context.DrawRectangle(new VisualBrush(element), null, new Rect(new Point(), size)); context.Close(); &#125; RenderTargetBitmap result = new RenderTargetBitmap((int)size.Width, (int)size.Height, 96, 96, PixelFormats.Pbgra32); result.Render(drawingVisual); return result;&#125; 변환된 Bitmap을 PNG 또는 TIF 이미지 파일로 저장하는 코드입니다. 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// Bitmap을 이미지로 저장/// &lt;/summary&gt;/// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;/// &lt;param name=\"filePath\"&gt;파일 경로&lt;/param&gt;public static void SaveImage(RenderTargetBitmap bitmap, string filePath)&#123; string ext = System.IO.Path.GetExtension(filePath); using (FileStream stream = new FileStream(filePath, FileMode.Create)) &#123; if (ext == \".png\") &#123; PngBitmapEncoder encoder = new PngBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; else if (ext == \".tif\") &#123; TiffBitmapEncoder encoder = new TiffBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create(bitmap)); encoder.Save(stream); &#125; stream.Close(); &#125;&#125; 사용 방법 123456789101112131415&lt;Window x:Class=\"TestProject.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Width=\"800\" Height=\"600\" Title=\"이미지 저장하기\"&gt; &lt;Grid Name=\"grid\"&gt; &lt;Canvas&gt; ... &lt;/Canvas&gt; &lt;StackPanel&gt; ... &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; GetBitmapFromControl 함수를 사용하여 이미지로 저장하려는 Grid를 Bitmap으로 변환합니다. 그리고 SaveImage 함수의 파라미터에 bitmap, 파일경로를 넣어 이미지를 저장합니다. 123456789/// &lt;summary&gt;/// 이미지 저장/// &lt;/summary&gt;private void Capture()&#123; RenderTargetBitmap bitmap = GetBitmapFromControl(this.grid); string filePath = \"d:\\\\test.png\"; SaveImage(bitmap, filePath);&#125; Grid 컨트롤 뿐만 아니라 FrameworkElement을 상속받는 모든 컨트롤들을 위의 함수를 사용하여 이미지를 저장할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"}]},{"title":"[Angular] FormGroup 관련 에러","slug":"angular-9","date":"2023-03-08T14:12:56.000Z","updated":"2024-01-12T06:48:54.999Z","comments":true,"path":"2023/03/08/angular-9/","link":"","permalink":"http://hgko1207.github.io/2023/03/08/angular-9/","excerpt":"","text":"Angular에서 FormGroup 사용 시 다음과 같이 에러가 발생할 경우 해결 방법에 대해 알아보겠습니다. Error 1234567891011121314151617181920212223ERROR Error: NG01350: ngModel cannot be used to register form controls with a parent formGroup directive. Try using formGroup's partner directive \"formControlName\" instead. Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;/div&gt; In your class: this.myGroup = new FormGroup(&#123; firstName: new FormControl() &#125;); Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions: Example: &lt;div [formGroup]=\"myGroup\"&gt; &lt;input formControlName=\"firstName\"&gt; &lt;input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt; &lt;/div&gt; 해결 방법 에러 메시지 내용은 formGroup을 사용하려면 formControlName을 사용하거나 [(ngModel)] 사용 시 [ngModelOptions]=&quot;{standalone: true}를 추가하라고 합니다. 다음과 같이 formGroup 속성이 있는 태그의 자식 중에 ngModel 속성을 사용하는 모든 태그에 formControlName 또는 [ngModelOptions]=&quot;{standalone: true}이 있어야 에러를 해결할 수 있습니다. 12345this.myForm = new FormGroup(&#123; id: new FormControl(''), name: new FormControl(''), title: new FormControl(''),&#125;); 12345&lt;form [formGroup]=\"myForm\"&gt; &lt;input type=\"text\" formControlName=\"id\"&gt; &lt;input type=\"text\" formControlName=\"name\"&gt; &lt;input type=\"text\" [(ngModel)]=\"myForm.value.title\" [ngModelOptions]=\"&#123;standalone: true&#125;\"&gt;&lt;/fom&gt; 그리고 추가적으로 Typescript에서 FormBuilder를 통해 Group을 생성할 때 formControlName에 있는 값들을 전부 넣어줘야 됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"}]},{"title":"[Next.js] Dynamic Routes 사용 방법","slug":"nextjs-6","date":"2023-02-23T07:28:30.000Z","updated":"2024-01-12T06:48:05.521Z","comments":true,"path":"2023/02/23/nextjs-6/","link":"","permalink":"http://hgko1207.github.io/2023/02/23/nextjs-6/","excerpt":"","text":"Next.js에서 Dynamic Routes 사용 방법에 대해 알아보겠습니다. Dynamic Routes Next.js에서는 page에 대괄호([param])를 추가하여 Dynamic Route를 생성할 수 있습니다. pages/movies 경로에 [id].js 파일을 생성하면 /movies/1, /movies/abc 등과 같은 경로로 접속할 수 있습니다. 다음 예제처럼 useRouter()의 query를 통해 /movies 다음의 하위 경로를 확인할 수 있습니다. 123456789// pages/movies/[id].jsimport &#123; useRouter &#125; from 'next/router';export default function Detail() &#123; const router = useRouter(); const &#123; id &#125; = router.query; return 'detail';&#125; 생성한 경로로 이동을 원한다면 다음과 같이 next/link를 사용하여 작성합니다. 12345678910111213141516import Link from 'next/link';function Home() &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link href=\"/movies/abc\"&gt;Go to movies/movies/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=\"/movies/abc?foo=bar\"&gt;Also goes to movies/post/[id].js&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;export default Home; Catch all routes 대괄호 안에 세 개의 점(…)을 추가하여 모든 경로를 포착하도록 Dynamic Routes를 확장할 수 있습니다. pages/movies/[…id].js는 /movies/1와 일치하지만 /movies/1/2, /movies/1/ab/cd 등과도 일치합니다. 일치하는 매개변수는 페이지에 쿼리 매개변수로 전송되며 항상 배열이므로 /movies/a 또는 /movies/a/b 경로일 경우 다음과 같이 조회가 됩니다. 12345// /movies/a&#123; \"id\": [\"a\"] &#125;// /movies/a/b&#123; \"id\": [\"a\", \"b\"] &#125; 참고 https://nextjs.org/docs/routing/dynamic-routes","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"}]},{"title":"엘라스틱 스택 개발부터 운영까지","slug":"book-3","date":"2023-02-22T01:12:03.000Z","updated":"2024-01-12T06:47:24.925Z","comments":true,"path":"2023/02/22/book-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/22/book-3/","excerpt":"","text":"책 정보 책 소개 데이터를 처리하는 데 서로 잘 맞지도 않는 오픈소스 기술들을 굳이 동원해야 할까? 제각각인 오픈소스들을 통합하고 운영하느라 지친 개발자와 운영자들을 위한 솔루션! 이제 엘라스틱 스택 기술 하나면 OK! 어느덧 엘라스틱 스택은 검색 엔진을 넘어서 데이터 처리 시스템의 최강자로 자리 잡았다. 이 책에서는 빠르게 변화하는 세상에서 엘라스틱 스택을 지렛대로 삼아 기업의 생존 능력을 극대화하는 방법을 체계적으로 정리한다. 엔터프라이즈 빅데이터 파이프라인을 만들어 기업의 데이터를 처리하고 싶다면? 기업 내에 검색 엔진을 구축해서 빠르게 자료를 검색하고 싶다면? 방대한 데이터를 잘 가공해서 저장한 후에 멋진 시각화로 인사이트를 얻고 싶다면? 여러 서버에서 데이터들을 가져와 하나로 통합한 다음에 추이를 보거나 통계를 내고 싶다면? 바로 이럴 때 엘라스틱 스택이 정답이다. 실습을 위한 물리적인 컴퓨터나 가상 머신만 준비한다면 나머지는 모두 이 책이 책임져줄 것이다. 이 책에서는 엘라스틱 스택을 사용해 데이터 중심 애플리케이션을 설계하고, 개발하며, 운영하는 과정에서 꼭 알아야 할 필수 지식을 구체적인 사례와 함께 설명한다. 리뷰 데이터 검색과 분석을 위해서 엘라스틱 서치를 공부하려고 찾던 중 엘라스틱 스택을 알게 되었고 궁금함을 못 참고 바로 구입하게 되었습니다. 엘라스틱 스택 개념과 구성요소(엘라스틱 서치, 로그스태시, 비트, 키바나 등)들이 잘 정리되어 있어 이해가 쉬웠고 참고가 많이 되었습니다. 엘라스틱 스택의 구성요소를 통해 데이터 수집부터 변환, 분석, 검색, 시각화까지 하는 내용들이 구성되어 있어 응용 학습에 많은 도움이 될 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"}]},{"title":"[Next.js] Redirect and Rewrite","slug":"nextjs-5","date":"2023-02-21T02:25:34.000Z","updated":"2024-01-12T06:46:56.386Z","comments":true,"path":"2023/02/21/nextjs-5/","link":"","permalink":"http://hgko1207.github.io/2023/02/21/nextjs-5/","excerpt":"","text":"Next.js에서 Redirect와 Rewrite 설정 방법에 대해 알아보겠습니다. Redirect와 Rewrite 설정은 next.config.js 파일에서 설정하게 됩니다. next.config.js Next.js에서 커스텀 설정을 하기 위해서는 프로젝트 디렉터리의 루트에 next.config.js 또는 next.config.mjs 파일을 만들 수 있습니다. next.config.js는 JSON 파일이 아닌 일반 Node.js 모듈입니다. 123456/** @type &#123;import('next').NextConfig&#125; */const nextConfig = &#123; reactStrictMode: true,&#125;;module.exports = nextConfig; Next.js 서버 및 빌드 단계에서 사용되며 브라우저 빌드에는 포함되지 않습니다. Redirects (URL변경됨) Redirect 을 사용하면 들어오는 request 경로를 다른 destination 경로로 Redirect 할 수 있습니다. Redirect 을 사용하려면 next.config.js 에서 redirects 키를 설정합니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/contact', destination: '/form', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; redirects은 source, destination 및 permanent 속성이 있는 객체를 포함하는 배열을 반환하는 비동기 함수입니다. source: 들어오는 request 경로 (request 경로) destination: 라우팅 하려는 경로 (redirect 할 경로) permanent: true 인 경우 클라이언트와 search 엔진에 redirect를 영구적으로 cache 하도록 지시하는 308 status code를 사용하고, false 인 경우 일시적이고 cache 되지 않은 307 status code를 사용합니다. request 경로에 요청되는 모든 쿼리 값도 destination 으로 전달됩니다. 12345678910111213const nextConfig = &#123; reactStrictMode: true, async redirects() &#123; return [ &#123; source: '/old-blog/:path*', destination: '/blog/:path*', permanent: false, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 예를 들어 /old-blog/post-1?hello=world 요청이 들어오면 /blog/post-1?hello=world 경로로 Redirect 됩니다. Rewrites (URL변경되지 않음) Rewrites를 사용하면 들어오는 request 경로를 다른 destination 경로에 매핑할 수 있습니다. Rewrites은 URL 프록시 역할을 하고 destination 경로를 mask 하여 사용자가 사이트에서 위치를 변경하지 않은 것처럼 보이게 합니다. 반대로 redirects은 새 페이지로 reroute 되고 URL 변경 사항을 표시합니다. 1234567891011121314const API_KEY = process.env.API_KEY;const nextConfig = &#123; reactStrictMode: true, async rewrites() &#123; return [ &#123; source: '/api/movies', destination: `https://api.themoviedb.org/3/movie/popular?api_key=$&#123;API_KEY&#125;`, &#125;, ]; &#125;,&#125;;module.exports = nextConfig; 12// 사용const &#123; results &#125; = await (await fetch(`/api/movies`)).json(); API를 통해 데이터를 조회할 때 API Key가 필요한 경우가 있습니다. 그럴 경우 API Key가 노출되어 위험할 수 있습니다. 위의 내용처럼 Rewrites를 사용하여 API 주소로 매핑을 하여 노출되지 않도록 해결하였습니다. 참고 https://nextjs.org/docs/api-reference/next.config.js/introduction https://nextjs.org/docs/api-reference/next.config.js/redirects https://nextjs.org/docs/api-reference/next.config.js/rewrites","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"}]},{"title":"[Next.js] Head 사용 방법","slug":"nextjs-4","date":"2023-02-07T07:19:38.000Z","updated":"2024-01-12T06:45:16.177Z","comments":true,"path":"2023/02/07/nextjs-4/","link":"","permalink":"http://hgko1207.github.io/2023/02/07/nextjs-4/","excerpt":"","text":"Next.js에서 Head 사용 방법에 대해 알아보겠습니다. Title 설정 Next.js에는 페이지 헤더의 제목을 변경하고 meta를 추가할 수 있는 내장 컴포넌트를 가지고 있습니다. 123456789101112import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 태그 중복 방지 head에 태그가 중복되는 것을 방지하려면 다음 예제와 같이 태그가 한 번만 렌더링 되도록 하는 key 속성을 사용할 수 있습니다. 12345678910111213141516import Head from 'next/head';export default function Home() &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Home | Title&lt;/title&gt; &lt;meta property=\"og:title\" content=\"My page title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;Head&gt; &lt;meta property=\"og:title\" content=\"My new title\" key=\"title\" /&gt; &lt;/Head&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 이 경우 두 번째 meta property=&quot;og:title&quot;만 렌더링 됩니다. 중복 키 속성이 있는 meta 태그는 자동으로 처리됩니다. key를 지정해주지 않으면 meta property=&quot;og:title&quot;가 중복해서 2번 랜더링 됩니다. Title 은 지정하지 않아도 2번 랜더링 되지 않습니다. 공통 컴포넌트 공통으로 사용할 컴포넌트 파일(예: Seo.js)을 생성합니다. title prop을 받아서 화면마다 제목을 설정할 수 있습니다. 123456789import Head from 'next/head';export default function Seo(&#123; title &#125;) &#123; return ( &lt;Head&gt; &lt;title&gt;&#123;`$&#123;title&#125; | Title`&#125;&lt;/title&gt; &lt;/Head&gt; );&#125; 12345678910import Seo from '@/components/Seo';export default function Home() &#123; return ( &lt;div&gt; &lt;Seo title=\"Home\" /&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 참고 https://nextjs.org/docs/api-reference/next/head","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"}]},{"title":"[Next.js] Styles 사용 방법","slug":"nextjs-3","date":"2023-02-06T06:22:16.000Z","updated":"2024-01-12T06:44:18.215Z","comments":true,"path":"2023/02/06/nextjs-3/","link":"","permalink":"http://hgko1207.github.io/2023/02/06/nextjs-3/","excerpt":"","text":"Next.js에서 스타일 적용하는 방법에 대해 알아보겠습니다. 1. CSS-in-JS 가장 간단한 방법은 인라인 스타일입니다. 1234567export default function Home() &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123; color: 'red' &#125;&#125;&gt;Hello&lt;/div&gt; &lt;/div&gt; );&#125; 2. CSS Modules Next.js는 [name].module.css 파일 명명 규칙을 사용하여 CSS Module을 지원합니다. Common.module.css파일을 생성하고 스타일을 다음과 같이 작성합니다. 중요한 것은 .module.css 패턴을 사용하는 것입니다. 123456789.nav &#123; display: flex; justify-content: space-between; background-color: red;&#125;.text &#123; color: blue;&#125; 생성된 module을 import 해서 사용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;styles.nav&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 여러 개의 스타일을 적용할 수 있습니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;`$&#123;styles.nav&#125; $&#123;styles.text&#125;`&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 또는 join() 함수를 사용해 적용합니다. 12345678910import styles from './Common.module.css';export default function Home() &#123; return ( &lt;div&gt; &lt;nav className=&#123;[styles.nav, styles.text].join(' ')&#125;&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; );&#125; 3. Styled JSX 격리된 범위 CSS 에 대한 지원을 제공하기 위해 styled-jsx를 번들로 제공합니다. styled-jsx를 사용하는 컴포넌트는 다음과 같습니다. style에 jsx prop 을 넣고 중괄호({})와 백틱(`)을 사용하여 작성합니다. 123&lt;style jsx&gt;&#123;` CSS 스타일..`&#125;&lt;/style&gt; 12345678910111213141516export default function Home() &#123; return ( &lt;div&gt; &lt;nav&gt;&lt;/nav&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;style jsx&gt;&#123;` nav &#123; background-color: red; &#125; h1 &#123; color: blud; &#125; `&#125;&lt;/style&gt; &lt;/div&gt; );&#125; Global Styles 설정하는 방법은 global Prop 을 추가하면 됩니다. 12345&lt;style jsx global&gt;&#123;` body &#123; background: black; &#125;`&#125;&lt;/style&gt; VSCode 익스텐션 Styled JSX 사용 시 추천 VSCode 익스텐션입니다. styled-jsx : 하이라이팅, 코드 가독성에 도움이 됨 styled-jsx Language Server : 자동완성 참고 https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js https://github.com/vercel/styled-jsx","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"}]},{"title":"[Next.js] Routing 사용 방법","slug":"nextjs-2","date":"2023-02-03T07:36:02.000Z","updated":"2024-01-12T06:43:38.567Z","comments":true,"path":"2023/02/03/nextjs-2/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-2/","excerpt":"","text":"Next.js에서 Rouing 하는 방법에 대해 알아보겠습니다. &lt;a&gt; 사용 &lt;a&gt; 태그를 사용해서 페이지 이동을 할 수 있습니다. 하지만 페이지 이동 시 전체 페이지 새고로침이 되는 문제가 발생했습니다. 12345678export default function NavBar() &#123; return ( &lt;nav&gt; &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;a href=\"/about\"&gt;About Us&lt;/a&gt; &lt;/nav&gt; );&#125; Link 사용 single-page app 환경의 페이지 전환을 하려면 Link 컴포넌트를 사용해야 합니다. 12345678910import Link from 'next/link';export default function NavBar() &#123; return ( &lt;nav&gt; &lt;Link href=\"/\"&gt;Home&lt;/Link&gt; &lt;Link href=\"/about\"&gt;About Us&lt;/Link&gt; &lt;/nav&gt; );&#125; useRouter() 컴포넌트에서 router 객체 내부에 접근하려면 userRouter() hook 을 사용할 수 있습니다. useRouter는 React Hook입니다. 즉, 클래스와 함께 사용할 수 없습니다. withRouter를 사용하거나 클래스를 함수 컴포넌트로 래핑 할 수 있습니다. 다음 내용은 useRouter() hook을 사용해서 메뉴의 색상을 변경하는 예제입니다. 1234567891011121314151617import Link from 'next/link';import &#123; useRouter &#125; from 'next/router';export default function NavBar() &#123; const router = useRouter(); return ( &lt;nav&gt; &lt;Link href=\"/\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/' ? 'red' : 'blue' &#125;&#125;&gt;Home&lt;/span&gt; &lt;/Link&gt; &lt;Link href=\"/about\"&gt; &lt;span style=&#123;&#123; color: router.pathname === '/about' ? 'red' : 'blue' &#125;&#125;&gt;About Us&lt;/span&gt; &lt;/Link&gt; &lt;/nav&gt; );&#125; 참고 https://nextjs.org/docs/messages/no-html-link-for-pages https://nextjs.org/docs/api-reference/next/router#userouter","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"}]},{"title":"라이브러리와 프레임워크 차이점","slug":"info-1","date":"2023-02-03T06:50:35.000Z","updated":"2024-01-12T06:42:28.266Z","comments":true,"path":"2023/02/03/info-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/info-1/","excerpt":"","text":"라이브러리와 프레임워크의 주요 차이점에 대해 알아보겠습니다. 라이브러리 사용자가 파일 이름이나 구조 등을 정하고, 모든 결정을 내립니다. 우리 프로젝트에 가져와서 쓰는 방식 예) React: 렌더링 할 때 ReactDOM.render()를 불러와서 사용합니다. 프레임워크 파일 이름이나 구조 등을 정해진 규칙에 따라 만들고 따릅니다. 정해진 틀 안에서 커스터마이징 방식 예) NextJS: 정해진 규칙에 따라 코드를 작성하면 렌더링됩니다. 차이점 라이브러리와 프레임워크의 주요 차이점은 “Inversion of Control”(통제의 역전) 입니다. 라이브러리에서 메서드를 호출하면 사용자가 제어할 수 있습니다. 그러나 프레임워크에서는 제어가 역전되어 프레임워크가 사용자를 호출합니다. 참고 https://www.youtube.com/watch?v=t9ccIykXTCM","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"}]},{"title":"[Next.js] 프로젝트 생성 및 시작 방법","slug":"nextjs-1","date":"2023-02-03T00:48:16.000Z","updated":"2024-01-12T06:42:51.230Z","comments":true,"path":"2023/02/03/nextjs-1/","link":"","permalink":"http://hgko1207.github.io/2023/02/03/nextjs-1/","excerpt":"","text":"Next.js를 사용하는 프로젝트 생성 하는 방법에 대해 알아보겠습니다. 시스템 요구 사항 Node.js 14.6.0 이상 MacOS, Windows(WSL 포함) 및 Linux 가 지원됩니다. 프로젝트 생성 리액트 프로젝트를 생성하는 방법과 비슷하게 create-next-app 명령어를 사용합니다. @latest 를 추가하면 최신 버전으로 프로젝트를 생성합니다. 123npx create-next-app@latest# oryarn create next-app TypeScript 프로젝트로 시작하려면 --typescript 옵션을 추가합니다. 123npx create-next-app@latest --typescript# oryarn create next-app --typescript 위의 방법으로 프로젝트를 생성해 보겠습니다. 123456789101112131415161718192021222324252627282930D:\\project\\Study&gt;npx create-next-app@latest√ What is your project named? ... nextjs-intro√ Would you like to use TypeScript with this project? ... No / Yes√ Would you like to use ESLint with this project? ... No / Yes√ Would you like to use `src/` directory with this project? ... No / Yes√ Would you like to use experimental `app/` directory with this project? ... No / Yes√ What import alias would you like configured? ... @/*Creating a new Next.js app in D:\\project\\Study\\nomadcoders\\nextjs-intro.Using npm.Installing dependencies:- react- react-dom- next- @next/font- eslint- eslint-config-nextadded 264 packages, and audited 265 packages in 25s102 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesInitializing project with template: defaultSuccess! Created nextjs-intro at D:\\project\\Study\\nextjs-intro 프로젝트 이름을 입력하고 TypeScript와 ESLint 사용 여부를 선택하면 프로젝트가 성공적으로 생성됩니다. 시작 프로젝트 기본 구조입니다. 다음 명령어를 실행하여 개발 서버를 시작합니다. 123npm run dev# oryarn dev 개발 서버가 구동되면 http://localhost:3000에 접속하여 확인합니다. 참고 https://nextjs.org/docs/getting-started","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"}]},{"title":"WPF에서 Windows Forms(WinForm) Control 사용하기","slug":"wpf-8","date":"2023-02-01T07:33:44.000Z","updated":"2023-03-14T02:27:21.817Z","comments":true,"path":"2023/02/01/wpf-8/","link":"","permalink":"http://hgko1207.github.io/2023/02/01/wpf-8/","excerpt":"","text":"WPF에서 Windows Forms(WinForm) Control 사용하는 방법에 대해 알아보겠습니다. 참조 추가 프로젝트에 다음 어셈블리에 대한 참조를 추가합니다. WindowsFormsIntegration System.Windows.Forms XAML에 추가 WinForm 컨트롤을 사용하려는 XAML 파일을 열고 아래 네임스페이스 매핑을 추가합니다. wf 네임스페이스 매핑은 Windows Forms 컨트롤이 포함된 어셈블리에 대한 참조를 설정합니다. 1xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" 123456&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt;... 사용 WindowsFormsHost 컨트롤을 사용하고 자식으로는 WinForm 컨트롤을 사용합니다. 123&lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\"/&gt;&lt;/WindowsFormsHost&gt; 전체 소스 123456789101112&lt;Window x:Class=\"WPF.Text.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:wf=\"clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms\" Title=\"MainWindow\" Height=\"350\" Width=\"500\"&gt; &lt;Grid&gt; &lt;WindowsFormsHost&gt; &lt;wf:PictureBox x:Name=\"DisplayImage\" /&gt; &lt;/WindowsFormsHost&gt; &lt;/Grid&gt;&lt;/Window&gt; 참고 WindowsFormsHost 클래스 연습: XAML을 사용하여 WPF에서 Windows Forms 컨트롤 호스팅","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"}]},{"title":"[Kibana] 사용 방법","slug":"elasticsearch-4","date":"2023-01-06T07:41:51.000Z","updated":"2024-01-12T06:42:01.405Z","comments":true,"path":"2023/01/06/elasticsearch-4/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-4/","excerpt":"","text":"키바나(Kibana) 사용 방법에 대해 알아보겠습니다. 운영환경 Windows Kibana Version: 7.17.8 키바나를 실행합니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 서버 상태 확인 키바나의 서버 상태는 http://localhost:5601/status 에서 확인할 수 있습니다. 키바나 콘솔 사용법 키바나 Dev Tools에 있는 콘솔을 이용해 엘라스틱서치 REST API를 호출합니다. 키바나 왼쪽 상단의 토글 메뉴를 클릭하면 키바나 메뉴를 확인할 수 있는데 Management -&gt; Dev Tools를 선택하면 됩니다. 왼쪽 입력창에서 엘라스틱서치에서 제공하는 REST API를 입력하고 실행 버튼을 누르면 오른쪽 출력창에서 HTTP의 응답을 확인할 수 있습니다. 또한 키바나 콘솔은 엘라스틱서치 API 자동 완성 기능이 지원됩니다. 샘플 데이터 불러오기 엘라스틱 스택은 세 가지 샘플 데이터를 기본으로 제공합니다. 키바나에서 아주 쉽게 가능합니다. 샘플 데이터를 불러와서 검색 테스트를 할 수 있습니다. 키바나의 홈 화면에서 Try sample data 링크를 클릭합니다. 샘플 데이터를 추가할 수 있는 화면입니다. 총 3개의 심플 데이터(Sample eCommerce orders, Sample flight data, Sample web logs)가 있고, 각 샘플 데이터마다 Add data 버튼을 클릭해서 샘플을 추가할 수 있습니다. 샘플 데이터를 추가하면 키바나의 Visualize(시각화)와 Daashboard(대시보드) 등에도 샘플들이 함께 추가됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Kibana] 윈도우에 설치 및 실행 방법","slug":"elasticsearch-3","date":"2023-01-06T05:18:22.000Z","updated":"2024-01-12T06:41:22.805Z","comments":true,"path":"2023/01/06/elasticsearch-3/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-3/","excerpt":"","text":"Kibana(키바나): 시각화와 엘라스틱서치 관리 도구 키바나는 오픈서치의 자유-오픈 소스 후계자가 오픈서치 대시보드인 일래스틱서치용의 소스 이용이 가능한 데이터 시각화 대시보드 소프트웨어이다. 일래스틱서치 클러스터에 색인된 내용 기반의 시각화 기능을 제공한다. 사용자는 막대, 선, 산점도 플롯, 원 그래프, 지도를 다량의 데이터에 맞추어 만들 수 있다. 위키백과 엘라스틱서치는 REST API가 잘 설계된 제품이긴 하지만 복잡한 요청을 일일이 작성하기 에는 다소 불편할 수 있습니다. 키바나는 이런 불편함을 해소해 줍니다. 엘라스틱서치에 대한 대부분의 관리 기능, API를 실행할 수 있는 콘솔, 솔루션 페이지들, 모니터링 페이지 등이 모두 카바나에 포함되어 있습니다. 개요 윈도우 환경에서 Kibana 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 엘라스틱서치와 동일하게 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/kibana 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치할 것이므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드 받습니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 kibana-7.17.8-windows-x86_64 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치 같은 실행 관련 파일들이 있습니다. config 폴더에는 설정 파일(kibana.yml)과 기타 설정 관련 파일들이 있습니다. 실행하기 키바나를 실행해 봅니다. 키바나를 실행하기 전에 반드시 엘라스틱서치를 먼저 실행하고 나서 실행해야 합니다. bin 폴더에 있는 kibana.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\kibana-7.17.8-windows-x86_64&gt; .\\bin\\kibana.bat 기본적으로 포그라운드로 실행됩니다. 확인하기 키바나가 정상적으로 실행되면 동작 여부를 웹 브라우저에서 확인할 수 있습니다. 키바나는 기본적으로 5601 포트를 사용하는데, 웹 브라우저를 열고 http://localhost:5601 주소를 입력합니다. 다음과 같이 키바나 웹 페이지가 나왔다면 정상 동작하는 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(8.X 버전)","slug":"elasticsearch-2","date":"2023-01-06T01:08:14.000Z","updated":"2024-01-12T06:40:48.579Z","comments":true,"path":"2023/01/06/elasticsearch-2/","link":"","permalink":"http://hgko1207.github.io/2023/01/06/elasticsearch-2/","excerpt":"","text":"윈도우 환경에서 Elasticsearch 8.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 8.X 대 버전을 설치하므로 Windows 버튼을 클릭하여 다운로드합니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-8.5.3 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. 실행하기 엘라스틱서치를 실행해 봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch.bat 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 12C:\\elasticsearch-8.5.3&gt; curl -X GET \"localhost:9200/?pretty\"curl: (52) Empty reply from server 명령을 실행했지만 Elasticsearch 7.X 대 버전과는 다르게 연결이 되지 않습니다. Elasticsearch 8.X 대 버전으로 업데이트되면서 https를 사용하는 방식으로 변경되었습니다. 해결하기 엘라스틱서치를 실행하면 명령 프롬프트 마지막에 다음과 같이 출력된 것을 확인할 수 있습니다. curl을 사용하여 확인하기 위해서는 user와 password를 추가로 입력하면 됩니다. 1curl -u [user]:[password] https://localhost:9200 -k user는 기본적으로 elastic이고, password는 위에서 나온 정보를 입력하여 실행합니다. 123456789101112131415161718C:\\elasticsearch-8.5.3&gt; curl -u elastic:yJ454NS-=mdaBI9bBVM= https://localhost:9200 -k&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Ne40oBP9Td2u-XLohcOFxQ\", \"version\" : &#123; \"number\" : \"8.5.3\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"4ed5ee9afac63de92ec98f404ccbed7d3ba9584e\", \"build_date\" : \"2022-12-05T18:22:22.226119656Z\", \"build_snapshot\" : false, \"lucene_version\" : \"9.4.2\", \"minimum_wire_compatibility_version\" : \"7.17.0\", \"minimum_index_compatibility_version\" : \"7.0.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치가 잘 실행된 것을 확인할 수 있습니다. 브라우저에서 http가 아닌 https로 변경된 https://localhost:9200 로 접속해서 확인할 수 있습니다. “고급” 버튼을 눌러 안전하지 않은 사이트로 이동하여 접속합니다. elatic 계정과 비밀번호를 입력하면 아래 그림과 같이 정보를 확인할 수 있습니다. 비밀번호 변경 elastic 계정의 비밀번호를 변경하려면 다음의 명령을 실행합니다. 12345678C:\\elasticsearch-8.5.3&gt; .\\bin\\elasticsearch-reset-password -u elasticThis tool will reset the password of the [elastic] user to an autogenerated value.The password will be printed in the console.Please confirm that you would like to continue [y/N]yPassword for the [elastic] user successfully reset.New value: ubj9aU+XNNsqV0VKkWLx 명령을 실행하고 y를 입력하면 새로운 비밀번호가 생성됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Elasticsearch] 윈도우에 설치 및 실행 방법(7.X 버전)","slug":"elasticsearch-1","date":"2023-01-05T06:50:51.000Z","updated":"2024-01-12T06:39:32.952Z","comments":true,"path":"2023/01/05/elasticsearch-1/","link":"","permalink":"http://hgko1207.github.io/2023/01/05/elasticsearch-1/","excerpt":"","text":"Elasticsearch(엘라스틱서치): 분산 검색 엔진 루씬 기반의 검색 엔진이다. HTTP 웹 인터페이스와 스키마에서 자유로운 JSON 문서와 함께 분산 멀티테넌트 지원 전문 검색 엔진을 제공한다. 일래스틱서치는 자바로 개발되어 있으며 아파치 라이선스 조항에 의거하여 오픈 소스로 출시되어 있다. 위키백과 엘라스틱서치는 모든 레코드를 JSON 도큐먼트 형태로 입력하고 관리하고 있으며, 일반적인 데이터베이스와 마찬가지로, 쿼리 한 결과에 대해 일치하는 원본 도큐먼트를 반환합니다. 또한 엘라스틱서치는 텍스트 외에도 숫자, 날짜, IP 주소, 지리 정보 등 다양한 데이터 타입에 대해 최적화되어 있습니다. 또한 엘라스틱서치는 사용자의 모든 입력을 REST API 형태로 받아들이기 때문에 별도의 드라이버 라이브러리가 없더라도 웹 브라우저나 curl 명령어를 이용해 기능을 활용할 수 있습니다. 개요 윈도우 환경에서 Elasticsearch 7.X 버전을 설치 및 실행하는 방법에 대해 알아보겠습니다. 윈도우에서는 파일을 다운로드하고 압축을 푼 다음 실행 파일을 실행하면 엘라스틱서치가 설치되는 구조입니다. 다운로드 먼저 설치를 위해 공식홈페이지로 이동합니다. https://www.elastic.co/kr/downloads/elasticsearch 현재 기준으로 8.5.3 버전이 최신입니다. 7.X 버전을 설치하므로 오른쪽의 View pas releases를 클릭합니다. 7.X 버전 중 원하는 버전을 선택하고 Download 버튼을 클릭합니다. 버전을 확인하고 WINDOWS 링크를 클릭하여 다운로드합니다. 설치하기 다운로드가 완료되면 zip 파일이 나오는데 압축을 해제합니다. 이 글에서는 윈도우 C 드라이브 밑에 elasticsearch-7.17.8 이라는 폴더에 압축을 해제했습니다. 압축을 해제하면 다음과 같은 폴더 구조가 나옵니다. bin 폴더에는 실행 파일과 플러그인 설치나 키 생성 등의 실행 작업을 위한 파일들이 있습니다. config 폴더에는 설정 파일(elasticsearch.yml)을 포함하여 설정에 관한 파일들이 있습니다. 실행하기 엘라스틱서치를 실행해 봅니다. bin 폴더에 있는 elasticsearch.bat 파일을 실행하면 됩니다. 윈도우에서 기본으로 제공하는 명령 프롬프트(CMD)을 실행하고 다음 명령어를 실행합니다. 1C:\\elasticsearch-7.17.8&gt; .\\bin\\elasticsearch.bat 기본적으로 포그라운드로 실행되고 로그를 출력합니다. 백그라운드로 실행을 원할 경우 실행 명령문 뒤에 -d를 추가하면 됩니다. 확인하기 엘라스틱서치를 실행하고 동작 여부를 확인하기 위해 curl이라는 툴을 이용합니다. 윈도우를 설치하면 기본으로 설치되어 있습니다. 윈도우 bat 파일의 경우 기본적으로 백그라운드 실행이 안 되기 때문에 명령 프롬프트를 하나 더 실행하고 다음 명령을 실행합니다. 123456789101112131415161718C:\\elasticsearch-7.17.8&gt; curl -X GET \"localhost:9200/?pretty\"&#123; \"name\" : \"DESKTOP-08OF09U\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"Qd8gx2FzSnyFb4zCvx9C6Q\", \"version\" : &#123; \"number\" : \"7.17.8\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"120eabe1c8a0cb2ae87cffc109a5b65d213e9df1\", \"build_date\" : \"2022-12-02T17:33:09.727072865Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.11.1\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 엘라스틱서치는 기본적으로 9200 포트를 사용하는데, localhost:9200 주소에 GET 메서드 요청을 해서 응답이 있다면 엘라스틱서치가 정상적으로 실행된 것입니다. 응답 결과를 JSON 형태로 보여주는데, URL 뒤에 ?pretty를 추가하면 가독성 좋은 형태로 결과를 보여줍니다. 브라우저에서 http://localhost:9200 로 접속해서 확인 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"}]},{"title":"[Gatsby] Page Query","slug":"react-17","date":"2023-01-04T14:45:56.000Z","updated":"2024-01-12T06:37:13.039Z","comments":true,"path":"2023/01/04/react-17/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-17/","excerpt":"","text":"gatsby-source-filesystem 로컬 파일 시스템에서 Gatsby 애플리케이션으로 데이터를 sourcing 하기 위한 Gatsby 소스 플러그인입니다. 플러그인은 파일에서 파일 노드를 생성합니다. 다양한 “transformer” 플러그인은 파일 노드를 다양한 다른 유형의 데이터로 변환할 수 있습니다. Markdown, JSON, 이미지, YAML, CSV 및 기타 수집 가지 데이터 유형이 지원됩니다. 설치 1npm install gatsby-source-filesystem 사용 방법 예시로 blog-posts 디렉토리를 생성하고 디렉터리 안에 post1.md, post2.md 파일을 생성합니다. gatsby-config.ts 파일의 plugin 부분을 다음과 같이 수정합니다. path 속성 값에는 생성한 blog-posts 디렉토리를 입력합니다. 12345678910111213141516// gatsby-config.jsimport type &#123; GatsbyConfig &#125; from 'gatsby';const config: GatsbyConfig = &#123; ... plugins: [ &#123; resolve: `gatsby-source-filesystem`, options: &#123; path: `$&#123;__dirname&#125;/blog-posts`, &#125;, &#125;, ],&#125;;export default config; GraphQL 쿼리를 해보면 nodes에 생성한 파일명들이 조회됩니다. 1234567query MyQuery &#123; allFile &#123; nodes &#123; name &#125; &#125;&#125; 12345678910111213141516// 결과&#123; \"data\": &#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125; &#125;, \"extensions\": &#123;&#125;&#125; index.tsx 파일에서 쿼리를 추가하고 별다른 작성 없이 props에 data를 선언하기만 하면 Gatsby 가 자동으로 쿼리 결과를 가져올 수 있도록 도와줍니다. TypeScript를 사용한다면 PageProps&lt;Queries.BlogTitlesQuery&gt; 타입을 지정합니다. 1234567891011121314151617181920212223import &#123; graphql, PageProps &#125; from 'gatsby';import React from 'react';export default function IndexPage(&#123; data &#125;: PageProps&lt;Queries.BlogTitlesQuery&gt;) &#123; console.log(data); return ( &lt;ul&gt; &#123;data.allFile.nodes.map((file, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;file.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export const query = graphql` query BlogTitles &#123; allFile &#123; nodes &#123; name &#125; &#125; &#125;`; 12345678910111213// data object&#123; \"allFile\": &#123; \"nodes\": [ &#123; \"name\": \"post1\" &#125;, &#123; \"name\": \"post2\" &#125; ] &#125;&#125; 결론 위와 같이 gatsby-source-filesystem 플러그인을 사용하여 Gatsby 가 생성한 파일들을 관찰할 수 있게 허용해 주고 쿼리를 통해 더 많은 정보를 조회할 수 있도록 도와줍니다. 참고 https://www.gatsbyjs.com/plugins/gatsby-source-filesystem","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"}]},{"title":"[Gatsby] useStaticQuery(정적 쿼리 사용)","slug":"react-16","date":"2023-01-04T14:09:13.000Z","updated":"2024-01-12T06:36:24.020Z","comments":true,"path":"2023/01/04/react-16/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/react-16/","excerpt":"","text":"useStaticQuery useStaticQuery는 빌드 시 리액트 훅을 사용하여 Gatsby의 GraphQL 데이터 계층을 쿼리 하는 기능을 제공합니다. 이를 통해 React 컴포넌트는 구문 분석, 평가 및 컴포넌트에 삽입될 GraphQL 쿼리를 통해 데이터를 검색할 수 있습니다. useStaticQuery 훅은 모든 컴포넌트 또는 페이지에서 사용할 수 있습니다. 123456789const data = useStaticQuery(graphql` query HeaderQuery &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 사용 방법 TypeScript를 사용하고 gatsby-config.ts 파일에서 GraphQL 타입 생성에 관한 항목인 graphqlTypegen 값이 true로 설정되어 있다면 Gatsby가 쿼리를 읽고서 자동적으로 맞는 타입을 생성합니다. gatsby-types.d.ts 파일을 열어서 보면 정의한 쿼리를 읽고 자동 타입 생성을 해버렸음을 확인 할 수 있습니다. 12345678910// useStaticQuery 정의const data = useStaticQuery(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125;`); 12// gatsby-types.d.tstype SeoDataQuery = &#123; readonly site: &#123; readonly siteMetadata: &#123; readonly title: string | null &#125; | null &#125; | null &#125;; 이렇게 자동 타입이 생성되었다면 Queries를 사용하여 SeoDataQuery를 찾아 타입을 부여합니다. TypeScript 자동완성이 제공됩니다. 123456789101112const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;( graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `);console.log(data.site?.siteMetadata?.title); 전체 코드 GraphQL 쿼리를 통해 조회해서 Title를 설정하는 코드입니다. 1234567891011121314151617181920212223import &#123; graphql, useStaticQuery &#125; from 'gatsby';import React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; const data = useStaticQuery&lt;Queries.SeoDataQuery&gt;(graphql` query SeoData &#123; site &#123; siteMetadata &#123; title &#125; &#125; &#125; `); return ( &lt;title&gt; &#123;title&#125; | &#123;data.site?.siteMetadata?.title&#125; &lt;/title&gt; );&#125; 참고 https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/ https://www.gatsbyjs.com/docs/reference/graphql-data-layer/graphql-api/#usestaticquery GraphQL Typegen","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"}]},{"title":"SHACL(Shapes Constraint Language) 란","slug":"shacl","date":"2023-01-04T06:47:24.000Z","updated":"2024-01-12T06:38:05.336Z","comments":true,"path":"2023/01/04/shacl/","link":"","permalink":"http://hgko1207.github.io/2023/01/04/shacl/","excerpt":"","text":"데이터를 검증하는 데 사용되는 SHACL(Shapes Constraint Language)에 대해 공부하고 정리한 내용입니다. SHACL(Shapes Constraint Language) 란 Shapes Constraint Language(SHACL)는 RDF(Resource Description Framework) 그래프를 설명하기 위한 W3C(World Wide Web Consortium) 표준 언어입니다 . SHACL은 RDF 그래프로 표현되는 온톨로지의 의미 체계 및 기술 상호 운용성 계층을 향상하도록 설계되었습니다. SHACL 모델은 그래프의 내용, 구조 및 의미에 대한 제약 조건으로 정의됩니다. SHACL은 표현력이 뛰어난 언어입니다. 무엇보다도 속성이 가질 수 있는 값의 수, 이러한 값의 유형, 숫자 범위, 문자열 일치 패턴 및 이러한 제약 조건의 논리적 조합을 제한하는 조건을 표현하는 기능이 포함되어 있습니다. SHACL에는 SPARQL 및 JavaScript 와 같은 언어로 보다 복잡한 조건을 표현하는 확장 메커니즘도 포함되어 있습니다 . SHACL 규칙은 SHACL에 추론 기능을 추가하여 사용자가 기존(어설션된) 문에서 추론할 수 있는 새 문을 정의할 수 있도록 합니다. 위키백과 2017년 7월 20일 이후 W3C 권장 사항(https://www.w3.org/TR/shacl/) RDF 언어 사용 RDF의 검증을 허용하도록 생성되었습니다. SHACL은 데이터를 검증하는 데 사용되는 &quot;Shapes Graph&quot;를 정의합니다. RDF(Resource Description Framework) 란 RDF는 자원의 정보를 표현하고 상호 연결 및 교환하기 위하여 월드 와이드 웹 컨소시움(W3C)에 의해 개발되고 있는 언어 규격이다. 여기서 말하는 자원이란 웹상에 존재하는 대부분의 객체를 의미하는 것으로, 사람이나 웹페이지, 저작물과 같은 특정 지을 수 있는 개체들이 해당된다. RDF는 이러한 자원들의 메타데이터를 표현하기 위하여 개발된 규격으로, 예를 들어 웹페이지라면 제목, 저자, 수정날짜와 같은 정보가 RDF로 서술하는 대상이 된다. 나무위키 SHACL Validation SHACL Processor 두 개의 입력 데이터를 넣고 검증합니다. shapes graph(확인하는 방법), data graph(검증 대상) SHACL Processor는 graph를 변경해서는 안됩니다. 즉, 유효성 검사 종료 시 data 및 shapes graph는 유효성 검사 시작 시 graph와 동일해야 합니다. 결과 graph를 생성합니다. Shape 이란 targets(대상) 및 contraints(제약 조건) 모음입니다. Targets: data graph에서 어떤 노드가 shape을 준수해야 하는지 정의합니다. Constraint: 노드를 검증하는 방법을 정의합니다. Shapes and Constraints Targets (of a shape) Data Graph에서 어떤 노드가 형태를 따라야 하는지 정의합니다. Target 선언은 어떤 리소스(RDF 그래프 노드)가 Shape의 &quot;Focus Node&quot;가 될 것인지를 정의합니다. Property Description sh:targetClass 지정된 클래스의 인스턴스인 모든 리소스를 대상으로 합니다. 예) sh:targetClass schema:Person; sh:targetNode 특정 리소스(예: 주어진 인스턴스)를 대상으로 합니다. 예) sh:targetNode ex:John; Node Shapes 노드(클래스)에 대한 제약 조건을 지정합니다. Property Shapes을 그룹화하는데 사용됩니다. sh:NodeShape의 SHACL 인스턴스로 선언하는 것이 권장되지만 필수는 아닙니다. sh:NodeShape의 SHACL 인스턴스는 sh:path 속성 값을 가질 수 없습니다. 12345schema:ExampleNodeShape e a sh:NodeShape sh:targetClass schema:Example ; sh:property [ ... ] Property Shapes 속성 및 해당 값에 대한 제약 조건을 지정합니다. 1234567sh:property [ sh:path schema:name ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string ; sh:maxLength 20 ;] ; Core Constraint Components SHACL 프로세서에서 지원해야 하는 기본 제공 SHACL Core 제약 조건 구성 요소를 정의합니다. Type Constraints Types of values class, datatype, nodeKind Cardinality minCount, maxCount Values node, in, hasValue Range of values minInclusive, maxInclusive, minExclusive, maxExclusive String based minLength, maxLength, pattern, languageIn, uniqueLang Logical constraints not, and, or, xone Closed shapes closed, ignoredProperties Property pair constraints equals, disjoint, lessThan, lessThanOrEquals Non-validating constraints name, description, group, order, defaultValue Qualified shapes qualifiedValueShape, qualifiedMinCount, qualifiedMaxCount Value Type Constraint Components Value 노드의 유형을 제한하는 데 사용합니다. Property Description sh:class 주어진 클래스의 인스턴스인 노드로 제한합니다. sh:datatype 노드의 데이터 유형을 주어진 값으로 제한합니다. (예: xsd:integer) sh:nodeKind 각 값 노드의 RDF 노드 종류가 만족할 조건을 지정합니다. 가능한 값: BlankNode, IRI, Literal, BlankNodeOrIRI, BlankNodeOrLiteral, IRIOrLiteral 123456&lt;!-- sh:class --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:class :Person; ] . 123456&lt;!-- sh:datatype --&gt;schema:Person a sh:NodeShape ; sh:property [ sh:path schema:birthDate ; sh:datatype xsd:date; ] . sh:datatype 에 대한 데이터 유형은 XMLSchema를 참고하여 지정합니다. The XML Schema Built-in Datatypes 1234567891011&lt;!-- sh:nodeKind --&gt;schema:Person a sh:NodeShape ; sh:nodeKind sh:IRI ; sh:property [ sh:path schema:knows ; sh:nodeKind sh:BlankNodeOrIRI; ]; sh:property [ sh:path schema:name ; sh:nodeKind sh:BlankNodeOrLiteral; ] . Cardinality Constraint Components Value 노드 수에 대한 제한을 나타냅니다. Property Description minCount 지정된 속성의 최소 발생 횟수를 제한합니다. 기본값: 0 maxCount 지정된 속성의 최대 발생 횟수를 제한합니다. 기본값: 0 123456schema:Person a sh:NodeShape ; sh:property [ sh:path schema:knows ; sh:minCount 1; sh:maxCount 2; ] . Value Range Constraint Components &lt;, &lt;=, &gt; 및 &gt;= 와 같은 연산자를 통해 비교할 수 있는 값 노드가 충족할 값 범위 조건을 지정합니다. Property Description minInclusive 최소 포함(Inclusive) 값, &lt;= maxInclusive 최대 포함(Inclusive) 값, &gt;= minExclusive 최소 독점(Exclusive) 값, &lt; maxExclusive 최대 독점(Exclusive) 값, &gt; 1234567schema:Rating a sh:NodeShape; sh:property [ sh:path schema:ratingValue ; sh:minInclusive 1; sh:maxExclusive 6; sh:datatype xsd:integer; ] ;. String-based Constraint Components Value 노드의 문자열 표현에 대한 조건을 지정한다는 공통점이 있습니다. Property Description minLength 최소 문자열 길이를 제한합니다. maxLength 최대 문자열 길이를 제한합니다. pattern 문자열 값이 정규 표현식과 일치하는지 확인합니다. uniqueLang 동일한 언어 태그를 사용하는 노드 쌍이 없는지 확인합니다. languageIn 속성 값이 주어진 언어 목록으로 표현되는지 확인합니다. 1234567&lt;!-- sh:minLength, sh:maxLength --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:name ; sh:minLength 4; sh:maxLength 15; ] . 123456&lt;!-- sh:pattern --&gt;schema:Product a sh:NodeShape; sh:property [ sh:path schema:productID ; sh:pattern \"^P\" ; &lt;!-- P or p로 시작하는지 확인 --&gt; ] . 1234567&lt;!-- sh:uniqueLang, sh:languageIn --&gt;schema:Country a sh:NodeShape; sh:property [ sh:path schema:name ; sh:languageIn (\"en\" \"ex\") ; sh:uniqueLang true ; ] . Property Pair Constraint Components 다른 속성과 관련하여 값 노드 집합에 대한 조건을 지정합니다. Property Description equals 지정된 Focus 노드에서 두 속성의 값 집합은 동일해야 합니다. disjoint 지정된 Focus 노드에서 두 속성의 값 집합은 달라야 합니다. lessThan 값은 다른 속성 값보다 작아야 합니다. lessThanOrEquals 값은 다른 속성의 값보다 작거나 같아야 합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:givenName ; sh:equals foaf:firstName ; ] ; sh:property [ sh:path schema:givenName ; sh:disjoint schema:lastName ; ] . Logical Constraint Components 공통 논리 연산자 and, or 및 not과 xor(Exclusive-OR)을 구현합니다. Property Description not 각 노드가 주어진 Shape을 따를 수 없다는 조건을 준수하는지 확인합니다. and 각 노드가 제공된 모든 Shape을 준수하는 조건을 준수하는지 확인합니다. or 각 노드가 제공된 Shape 중 하나 이상 또는 둘 다를 준수하는지 확인합니다. xone 각 노드가 제공된 Shape 중 정확히 하나를 준수한다는 조건을 준수하는지 확인합니다 1234567&lt;!-- sh:not --&gt;schema:Person a sh:NodeShape; sh:not [ sh:path foaf:name ; sh:minCount 1; ] . 12345678910111213141516&lt;!-- sh:and --&gt;schema:Person a sh:NodeShape; sh:and ( [ sh:property [ sh:path schema:name ; sh:minCount 1; ] ] [ sh:property [ sh:path schema:affiliation ; sh:MinCount 1; ] ] ) . 123456789101112&lt;!-- sh:or --&gt;schema:Person a sh:NodeShape; sh:or ( [ sh:path foaf:name ; sh:minCount 1 ; ] [ sh:path schema:name ; sh:minCount 1 ; ] ) . 1234567891011121314151617181920&lt;!-- sh:xone --&gt;schema:Person a sh:NodeShape; sh:xone ( [ sh:property [ sh:path ex:fullName ; sh:minCount 1; ] ] [ sh:property [ sh:path ex:firstName ; sh:minCount 1 ; ] ; sh:property [ sh:path ex:lastName ; sh:minCount 1 ; ] ] ). Shape-based Constraint Components 특정 Shape에 대해 Value 노드의 유효성을 검사하여 복잡한 조건을 지정하는 데 사용할 수 있습니다. Property Description node 주어진 속성의 모든 값은 주어진 Shape을 준수해야 합니다. qualifiedValueShape 지정된 노드 수가 준수해야 하는 Shape을 정의합니다. qualifiedMinCount Shape에 맞는 최소 노드 수 qualifiedMaxCount Shape에 맞는 최대 노드 수 123456789101112&lt;!-- sh:node --&gt;schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:node schema:Company; ].schema:Company a sh:Shape ; sh:property [ sh:path schema:name ; sh:datatype xsd:string ; ] . 12345678910111213&lt;!-- sh:qualifiedValueShape, sh:qualifiedMinCount --&gt;schema:QualifiedExampleShape a sh:NodeShape; sh:targetNode :Offspring ; sh:property [ sh:path :parent; sh:minCount 2; sh:maxCount 2; sh:qualifiedValueShape [ sh:path :gender ; sh:hasValue :Female ; ] ; sh:qualifiedMinCount 1 ; ] . Closed Constraint Components Shape에 명시적으로 열거된 속성에 대한 값만 갖는 조건을 지정합니다. Property Description closed true로 설정하면 Shape에 명시적으로 설명되지 않은 속성은 허용되지 않습니다. ignoredProperties Shape에 명시적으로 열거된 속성 외에 허용되는 속성의 Optional 목록입니다. 123456789schema:Person a sh:NodeShape; sh:closed true ; sh:ignoredProperties (rdf:type) ; sh:property [ sh:path ex:firstName ; ] ; sh:property [ sh:path ex:lastName ; ] . Non-Validating Constraint 유효성 검사 조건에서 무시되는 속성입니다. Property Description name 속성 라벨명을 정의합니다. description 속성에 대한 설명을 정의합니다. order 속성의 상대적 순서를 정의합니다. group 그룹을 정의합니다. 12345678910111213schema:Person a sh:NodeShape; sh:property [ sh:path schema:url; sh:name \"URL\"; sh:description \"User URL\"; sh:order 1; ] ; sh:property [ sh:path schema:name; sh:name \"Name\"; sh:description \"Person name\"; sh:order 2; ] . Other Constraint Components Property Description hasValue Focus 노드에 주어진 값이 있는지 확인합니다. in 속성이 가질 수 있는 값 옵션을 열거합니다. 123456789schema:Person a sh:NodeShape; sh:property [ sh:path schema:affiliation ; sh:hasValue :OurCompany; ]; sh:property [ sh:path schema:gender ; sh:in (schema:Male schema:Female); ] . 참고 Shapes Constraint Language (SHACL) Informatiemodellering met SHACL SHAPES CONSTRAINT LANGUAGE – SHACL SHACL validation with pySHACL","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"}]},{"title":"[Gatsby] Head API","slug":"react-15","date":"2023-01-03T14:26:44.000Z","updated":"2024-01-12T06:36:01.705Z","comments":true,"path":"2023/01/03/react-15/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-15/","excerpt":"","text":"Gatsby Head API Gatsby 에는 페이지의 문서 헤드에 요소를 추가할 수 있는 내장 head가 포함되어 있습니다. react-helmet 또는 기타 유사한 솔루션과 비교할 때 Gatsby Head는 사용하기 쉽고 성능이 우수하며 번들 크기가 더 작고 최신 React 기능을 지원합니다. 12// ex)export const Head = () =&gt; &lt;title&gt;Home Page&lt;/title&gt;; SEO Component 를 사용하여 Head 함수를 정의할 수 있습니다. 12345678910// src/components/Seo.tsximport React from 'react';interface ISeoProps &#123; title: string;&#125;export default function Seo(&#123; title &#125;: ISeoProps) &#123; return &lt;title&gt;&#123;title&#125; | Hello!&lt;/title&gt;;&#125; 123456789// index.tsximport * as React from 'react';import Seo from '../components/Seo';export default function IndexPage() &#123; return &lt;div&gt;Welcome&lt;/div&gt;;&#125;export const Head = () =&gt; &lt;Seo title=\"Home Page\" /&gt;; Usage notes Gatsby Head를 사용할 때 다음 사항에 유의해야 합니다. 컴포넌트가 아닌 페이지 내부에서만 Head export 를 정의할 수 있습니다. Gatsby Head 의 내용은 페이지 마운트 해제 시 지워지므로 각 페이지가 &lt;head&gt;에 필요한 내용을 정의하는지 확인해야 합니다. Head 함수는 유효한 JSX를 반환해야 합니다. Head 함수 내부의 유효한 태그는 link, meta, style, title, base, script 및 noscript 입니다. 참고 https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/ https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-seo-component","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"}]},{"title":"[Gatsby] Layout Components","slug":"react-14","date":"2023-01-03T14:08:22.000Z","updated":"2024-01-12T06:35:43.154Z","comments":true,"path":"2023/01/03/react-14/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-14/","excerpt":"","text":"Layout Components Gatsby는 기본적으로 레이아웃을 페이지에 자동으로 적용하지 않습니다. 대신 Layout Component를 사용하면 Header 및 Footer, 그리고 일부 페이지에서 사용하는 사이드바와 같은 여러 가지 레이아웃을 만들 수 있습니다. 또한 레이아웃과 페이지 컴포넌트 간에 데이터를 전달할 수 있습니다. 즉, Layout Component를 사용하여 여러 페이지에서 일반적으로 사용하는 Header 및 Footer의 레이아웃을 공유하도록 구성할 수 있습니다. 예제 src/components/ 디렉터리를 생성하고 Layout.tsx 파일을 생성합니다. 다음과 같이 Gatsby 의 Link를 사용하여 페이지를 이동하는 Layout Component를 구성합니다. 12345678910111213141516171819202122232425// src/components/Layout.tsximport &#123; Link &#125; from 'gatsby';import React from 'react';interface ILayoutProps &#123; children: any;&#125;export default function Layout(&#123; children &#125;: ILayoutProps) &#123; return ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/blog\"&gt;Blog&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;/div&gt; );&#125; 페이지에 레이아웃을 적용하려면 Layout Component 를 포함하고 그 안에 페이지 내용을 넣어야 합니다. 레이아웃을 페이지에 적용하는 방법은 다음과 같습니다. 12345678910111213// src/pages/index.tsximport * as React from 'react';import Layout from '../components/Layout';export default IndexPage = () =&gt; &#123; return ( &lt;Layout&gt; &lt;div&gt; &lt;h1&gt;Welcome to Home&lt;/h1&gt; &lt;/div&gt; &lt;/Layout&gt; );&#125;; 이 레이아웃이 필요한 모든 페이지와 템플릿에 대해 반복을 합니다. 참고 https://www.gatsbyjs.com/docs/how-to/routing/layout-components/ https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-link/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"}]},{"title":"[Gatsby] Routing","slug":"react-13","date":"2023-01-03T13:56:08.000Z","updated":"2024-01-12T06:34:51.144Z","comments":true,"path":"2023/01/03/react-13/","link":"","permalink":"http://hgko1207.github.io/2023/01/03/react-13/","excerpt":"","text":"Routing 리액트 라우터를 사용하여 페이지를 생성하는 것과 달리 Gatsby는 src/pages 안에 각 .tsx 파일에 대한 페이지를 생성합니다. 예를 들어 src/pages/contact.tsx는 yoursite.com/contact 페이지를 생성하고 src/pages/home.tsx는 yoursite.com/home 페이지를 생성합니다. Gatsby로 Routing 하는 것은 간단하고 리액트 라우터도, 스크린도 만들 필요 없고 그 경로와 요소들을 일일이 설명할 필요도 없다는 장점이 있습니다. 123456// src/pages/index.tsximport React from 'react';export default function Index() &#123; return &lt;div&gt;Hello world&lt;/div&gt;;&#125; 참고 https://www.gatsbyjs.com/docs/reference/routing/creating-routes/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"}]},{"title":"[MySQL] 5분 단위로 그룹핑하여 평균값 계산","slug":"mysql-8","date":"2023-01-02T01:14:53.000Z","updated":"2024-01-12T06:34:32.563Z","comments":true,"path":"2023/01/02/mysql-8/","link":"","permalink":"http://hgko1207.github.io/2023/01/02/mysql-8/","excerpt":"","text":"MYSQL을 사용하여 5분 단위로 그룹핑하여 평균값 계산하는 방법에 대해 알아보겠습니다. 테이블 생성 먼저 분 단위로 그룹핑과 평균값 계산을 위해 DATETIME, FLOAT 타입이 포함된 테이블을 생성합니다. 123456CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, sensor_value FLOAT, log_time DATETIME, PRIMARY KEY(id),) ENGINE=MYISAM CHARSET=utf8; 테이블이 생성되면 값을 입력합니다. 첫 번째 방법 시간 단위로 먼저 그룹핑한 후 분단위를 5로 나누어 그룹핑합니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 1, 10), FLOOR(SUBSTR(date_format(log_time, '%Y%m%d%H%i%S'), 11, 2) / 5)ORDER BY log_time; 또는 다음과 같이 SUBSTR 함수를 빼고 format을 다르게 해서 할 수 있습니다. 12345SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY date_format(log_time, '%Y%m%d%H'), FLOOR(date_format(log_time, '%i') / 5);ORDER BY log_time; FLOOR 함수는 가장 가까운 정수로 버림하여 반환합니다. 두 번째 방법 시간 및 분 단위로 분리하는 함수를 사용합니다. 1234SELECT date_format(log_time, '%Y%m%d%H%i%S'), AVG(sensor_value)FROM testGROUP BY DATE(log_time), HOUR(log_time), FLOOR(MINUTE(log_time) / 5)ORDER BY log_time; DATE, HOUR, MINUTE 함수는 날짜, 시간, 분의 값을 반환합니다. 5분 단위 데이터 출력 123SELECT *FROM testWHERE MOD(date_format(log_time, '%i'), 5) = 0 또는 123SELECT *FROM testWHERE date_format(log_time, '%i') % 5 = 0 MOD 함수는 첫 번째 값을 두 번째 값으로 나눈 나머지를 반환합니다. 참고 date_format 함수의 두 번째 항목인 format 내용은 아래 사이트에서 자세하게 확인해 볼 수 있습니다. https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_date-format","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Gatsby] 설치 및 사용 방법","slug":"react-12","date":"2022-12-29T07:03:34.000Z","updated":"2024-01-12T06:33:25.879Z","comments":true,"path":"2022/12/29/react-12/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/react-12/","excerpt":"","text":"Gatsby 설치 및 사용 방법에 대해 알아보겠습니다. Gatsby(개츠비) 란 개츠비는 리액트 기반의 프레임워크입니다. 리액트를 이용하면서도 리액트에 새로운 규칙 몇 가지를 추가해 주면서 아주 약간의 복잡함을 더해주고 있습니다. 주로 서버사이드 렌더링을 위해 사용하는 Next.js 와는 달리 개츠비는 서버 없이, 오로지 정적 웹사이트 생성을 위해 사용하는 오픈소스 프레임워크입니다. 정적 웹 페이지, 플랫 페이지는 저장된 그대로 사용자에게 전달되는 웹 페이지로서, 이는 웹 애플리케이션에 의해 생성되는 동적 웹 페이지와 반대되는 용어이다. 즉, 정적 웹 페이지는 모든 상황에서 모든 사용자에게 동일한 정보를 표시하며, 콘텐츠 타입이나 문서 언어의 협상(negotiate)을 위해 웹 서버의 현대적 기능에 종속된다. 위키백과 서비스 및 블로그, 포트폴리오 등에서 많이 사용됩니다. 설치 Gatsby를 사용하기 위해 gatsby-cli를 설치합니다. 1$ npm install -g gatsby-cli 12Gatsby requires Node.js 18.0.0 or higher (you have v14.17.5).Upgrade Node to the latest stable release: https:&#x2F;&#x2F;gatsby.dev&#x2F;upgrading-node-js 개츠비를 사용하려면 Node.js 18 이상 버전이 필요합니다. 버전이 낮다면 위와 같은 에러가 발생합니다. 프로젝트 생성 Gatsby CLI를 사용하여 프로젝트를 만듭니다. 1$ npm init gatsby 또는 1$ gatsby new 위의 명령어를 실행하면 프로젝트 생성을 위한 여러 가지 입력하는 부분이 있습니다. 순서대로 입력하면 프로젝트가 생성됩니다. 프로젝트 명을 입력합니다. 디렉터리를 확인합니다. JavaScript 쓸 건지 TypeScript 쓸 건지 선택합니다. 사용할 CMS를 선택합니다. 사용하지 않을 경우 No를 선택합니다. 사용할 styling system(Sass, Emotion, styled-components 등…)을 선택합니다. 구글 애널리틱스, 반응형 이미지나 사이트맵 등을 추가할 것인지 묻습니다. 없다면 Done을 선택합니다. CMS 는 비개발자인 사람들이 콘텐츠를 계속 올리는 웹사이트 혹은 앱입니다. 실행 다음 명령어를 실행합니다. 12$ cd my-gatsby-site/$ npm run develop 완료가 되면 사이트를 접속해서 확인합니다. 1234...You can now view dev-stickers in the browser. http://localhost:8000/ 빌드 빌드를 진행하면 축소된 파일, 변환된 이미지, 페이지별 정보와 데이터가 있는 JSON 파일, 페이지별 정적 HTML 등이 모두 포함됩니다. 최적화가 잘되어 있어 빠르게 로드되는 정적 웹사이트를 배포할 수 있습니다. 1$ npm run build 결론 개츠비 설치와 기본적인 사용 방법에 대해서 정리하였습니다. 나만의 블로그를 만들고 싶을 때 사용하면 좋을 것 같습니다. Gatsby Plugin Library Gatsby 사이트나 앱을 커스텀할 수 있는 기능을 제공하는 라이브러리들입니다. https://www.gatsbyjs.com/plugins 참고 Documentation Tutorials Guides","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"}]},{"title":"[Spring Boot] MultipartFile transferTo() 사용 파일 저장시 주의사항","slug":"spring-4","date":"2022-12-29T04:50:03.000Z","updated":"2024-01-12T06:33:57.644Z","comments":true,"path":"2022/12/29/spring-4/","link":"","permalink":"http://hgko1207.github.io/2022/12/29/spring-4/","excerpt":"","text":"multipart 기본 경로 Spring Boot 설정에서 spring.servlet.multipart.location를 특정 경로로 설정하지 않을 경우 기본적으로 tmp 폴더로 지정됩니다. 각 운영체제 tmp 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp Linux: \\tmp 각 운영체제 basedir 경로 Windows: C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT Linux: \\tmp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT 위와 같이 눈으로 보기에도 많이 지저분한 경로에 저장이 되므로 작업과 관리가 용이하도록 경로를 직접 설정해 주는 것이 좋습니다. 주의사항 경로 설정시 주의사항은 파일 저장 경로를 /upload로 할 경우 리눅스는 절대경로로 인식하여 /upload로 인식하지만 윈도우는 상대경로로 인식하여 basedir을 포함한 경로를 만듭니다. 결과는 C:\\User\\사용자\\AppData\\Local\\Temp\\tomcat.xxxxxx.8080\\work\\Tomcat\\localhost\\ROOT\\upload 입니다. 만약 C:/upload에 저장하고 싶다면 /upload가 아닌 C:/upload로 상세하게 입력해야 합니다. 1spring.servlet.multipart.location=C:/upload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"}]},{"title":"[Spring Boot] MultipartFile + Modal 사용 파일 업로드","slug":"spring-3","date":"2022-12-26T14:01:16.000Z","updated":"2023-03-14T02:26:44.705Z","comments":true,"path":"2022/12/26/spring-3/","link":"","permalink":"http://hgko1207.github.io/2022/12/26/spring-3/","excerpt":"","text":"Spring Boot에서 MultipartFile와 Bootstrap의 Modal을 사용하여 이미지 파일을 업로드하는 방법에 대해 알아보겠습니다. Spring Boot 2.6.11 버전과 Bootstrap 5를 사용하였습니다. MultipartFile MultipartFile이란 스프링에서 업로드한 파일을 표현할 때 사용되는 인터페이스입니다. 파일 내용은 메모리에 저장되거나 임시로 디스크에 저장됩니다. 요청 처리가 끝나면 임시 저장소는 지워집니다. 설정 Spring Boot application.properties 설정 파일에 파일 업로드 경로와 파일 사이즈를 설정합니다. 윈도우 기준으로 d:/upload/ 경로로 파일을 업로드합니다. 12345# 지도 파일 업로드 경로spring.servlet.multipart.location=d:/upload/spring.servlet.multipart.max-file-size=512MBspring.servlet.multipart.max-request-size=512MB spring.servlet.multipart.location: 업로드된 파일의 임시 저장 공간 spring.servlet.multipart.max-file-size: 파일의 최대 사이즈 (default: 1MB) spring.servlet.multipart.max-request-size: 요청의 최대 사이즈 (default: 10MB) html CDN을 통해 Bootstrap CSS와 JS를 포함합니다. 파일 업로드하는 모달 팝업 코드를 작성합니다. 파일 업로드 시 form 태그에 enctype=&quot;multipart/form-data&quot;를 추가하고 input 태그 타입을 file로 작성해야 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;파일 업로드 예제&lt;/title&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD\" crossorigin=\"anonymous\" /&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN\" crossorigin=\"anonymous\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#uploadModal\"&gt; 파일 업로드 &lt;/button&gt; &lt;!-- Modal --&gt; &lt;div id=\"uploadModal\" class=\"modal fade\" tabindex=\"-1\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header bg-primary text-white border-0\"&gt; &lt;h5 class=\"modal-title\"&gt;지도 등록&lt;/h5&gt; &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;form id=\"uploadForm\" method=\"POST\" action=\"/file/upload\" class=\"form-horizontal\" enctype=\"multipart/form-data\" &gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"form-group row mb-2\"&gt; &lt;label class=\"col-form-label col-md-3\"&gt;파일 &lt;/label&gt; &lt;div class=\"col-md-8\"&gt; &lt;input type=\"file\" class=\"form-control\" name=\"file\" accept=\"image/*\" required /&gt; &lt;span class=\"text-muted\"&gt; ※ 이미지 파일만 업로드 가능합니다. &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary me-2\"&gt;등록&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-light\" data-bs-dismiss=\"modal\"&gt;닫기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /Modal --&gt; &lt;/body&gt;&lt;/html&gt; JavaScript Modal와 Form을 제어하는 JavaScript 코드를 추가합니다. 12345678910111213141516171819202122232425262728// modal 닫기const modalHide = (modalId) =&gt; &#123; const modalEl = document.getElementById(modalId); const modal = bootstrap.Modal.getInstance(modalEl); modal.hide();&#125;;$('#uploadForm').submit(function (e) &#123; e.preventDefault(); const form = $(this); const url = form.attr('action'); const formData = new FormData($('#uploadForm')[0]); $.ajax(&#123; url: url, type: 'POST', data: formData, processData: false, contentType: false, success: function (response) &#123; modalHide('uploadModal'); alert('파일 업로드 성공'); &#125;, error: function (response) &#123; alert('파일 업로드 실패'); &#125;, &#125;);&#125;); Java Controller 파일을 생성합니다. 파일을 입력받고 저장하는 코드를 작성합니다. MultipartFile의 transferTo() 함수를 사용하여 파일을 저장합니다. 123456789101112131415161718192021public class FileController &#123; @PostMapping(\"file/upload\") @ResponseBody public ResponseEntity&lt;?&gt; upload(MultipartFile file) &#123; if (file != null) &#123; writeFile(file); return new ResponseEntity&lt;&gt;(HttpStatus.OK); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); &#125; /** * 파일 저장 */ private void writeFile(MultipartFile multipartFile) throws IOException &#123; File file = new File(filePath); multipartFile.transferTo(file); &#125;&#125; 파일을 업로드하는 코드를 작성해봤습니다. 파일 업로드에 대한 간략한 코드이므로 응용해서 사용할 수 있을 것 같습니다. 참고 https://getbootstrap.com/docs/5.0/components/modal/ https://www.baeldung.com/spring-multipartfile-to-file","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"}]},{"title":"[리눅스] mount --bind 사용 방법","slug":"linux-28","date":"2022-12-16T01:00:04.000Z","updated":"2024-01-12T06:32:22.563Z","comments":true,"path":"2022/12/16/linux-28/","link":"","permalink":"http://hgko1207.github.io/2022/12/16/linux-28/","excerpt":"","text":"mount 명령어는 디스크 드라이브와 같은 블록 디바이스(Block Device)만 마운트가 가능합니다. --bind 옵션을 추가하면 특정 디렉터리를 다른 디렉터리에 마운트(mount)해서 양쪽 디렉터리가 같은 곳으로 연결되도록 할 수 있습니다. 1$ mount --bind [원본 디렉토리] [붙일 디렉토리] 사용 예시 먼저 두 개의 디렉토리를 생성합니다. 12$ mkdir src$ mkdir dest --bind 또는 -B 옵션을 사용해서 src 디렉토리를 dest 디렉토리에 연결합니다. 1$ mount --bind src dest dest 디렉토리 하위에 파일을 생성을 하면 src 디렉토리에도 반영이 됩니다. 1$ touch dest/test 변경된 내용을 양쪽 모두 확인이 가능합니다. 1234$ ls desttest$ ls srctest","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"}]},{"title":"[리눅스] 네트워크 설정","slug":"linux-27","date":"2022-12-14T02:41:21.000Z","updated":"2024-01-12T06:31:46.975Z","comments":true,"path":"2022/12/14/linux-27/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-27/","excerpt":"","text":"리눅스 환경에서 ifconfig를 이용하여 네트워크 설정하는 방법을 알아보겠습니다. ifconfig 란 TCP/IP를 사용하여 네트워크의 네트워크 인터페이스 매개변수를 구성 또는 표시합니다. ifconfig 명령을 사용하여 네트워크 인터페이스에 주소를 지정하고 현재 네트워크 인터페이스 구성 정보를 구성 또는 표시할 수 있습니다. IP 주소 확인 옵션 없이 ifconfig 명령어만 실행하면 서버에 할당된 IP 주소를 확인합니다. 12345678910$ ifconfigenp5s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.0.19 netmask 255.255.255.0 broadcast 192.168.0.255 inet6 fe80::d487:3f17:d845:654b prefixlen 64 scopeid 0x20&lt;link&gt; ether 1c:1b:0d:7d:36:6f txqueuelen 1000 (Ethernet) RX packets 11943615 bytes 5682003196 (5.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8140188 bytes 2132065829 (1.9 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0... IPv4주소(inet), 서브넷마스트(netmask), 브로드캐스트주소(broadcast)가 표기되고 있고, MAC주소(ether)도 표시됩니다. 네트워크 설정 IP 주소, 서브넷마스크 주소, 브로드캐스트 주소를 모두 할당하려면 다음과 같이 모든 인수와 함께 ifconfig 명령을 사용하면 됩니다. 1$ ifconfig [이더넷명] [주소] netmask [주소] broadcast [주소] 추가로 up 옵션을 추가하여 이더넷을 활성화합니다. 1$ ifconfig [이더넷명] up 다음 예제는 eth0 에 IP 주소를 192.168.0.250, 서브넷마스크 주소를 255.255.255.0, 브로드캐스트 주소를 192.168.0.255 설정하고 활성화하는 명령어입니다. 1$ ifconfig eth0 192.168.0.250 netmask 255.255.255.0 broadcast 192.168.0.255 up 위의 방법으로 설정을 하면 물리적으로 변경된 것이 아니라 시스템 메모리상에서 로딩된 리눅스 커널이 사용하고 있는 랜카드 드라이브의 네트워크 설정이 바뀌는 것입니다. 따라서 시스템을 재부팅하고 나면 설정이 사라집니다. 고정 네트워크 설정 IP 주소를 고정하기 위해 설정을 해야 합니다. /etc/sysconfig/network 시스템 전체에 대한 Global 한 기본 게이트웨이 주소 설정과 호스트네임, 네트워킹 연결 허용 여부를 설정합니다. 123456$ vi /etc/sysconfig/networkNETWORKING=yesNETWORKING_IPV6=noHOSTNAME=hgko.comGATEWAY=192.168.0.1 /etc/resolv.conf 네임서버 설정과 기본적으로 사용할 도메인명을 설정합니다. 호스트명만 지정하였을 경우에 호스트명을 search 항목에 지정하여 도메인명으로 사용합니다. 1$ vi /etc/resolv.conf 1234# Generated by NetworkManagersearch hgko.comnameserver 168.126.63.1nameserver 168.126.63.2 /etc/sysconfig/network-script/ 시스템에서 사용하는 모든 이더넷 설정파일은 /etc/sysconfig/network-script/ 디렉토리에 존재합니다. 시스템에 설치되어 있는 기본 이더넷카드의 파일을 열고 고정 IP 부여를 위해 수정합니다. 1$ vi /etc/sysconfig/network-script/ifcfg-eth0 123456789101112131415161718192021222324# 장치명, 첫번째 이더넷카드DEVICE=eth0# IP 부여 방식 결정, static 은 고정IPBOOTPROTO=static# 이더넷카드의 MAC 주소HWADDR=XX:XX:XX:XX:XX:XX# 고유ID를 부여하는 것으로 자동으로 부여됨UUID=XXXXXXX-XXX-XXX-XXX-XXXXXXX# Ethernet 에 대한 설정TYPE=Ethernet# IP 주소 지정IPADDR=192.168.0.250# 서브넷마스크 지정NETMASK=255.255.255.0# 브로드캐스트 지정BROADCAST=192.168.0.255# 네트워크 지정NETWORK=192.168.0.0# 일반사용자의 eth0 제어 가능여부USERCTL=no# IPV6 사용여부IPV6INIT=no# 시스템 시작시 자동으로 활성화ONBOOT=yes 설정 적용 시스템을 재부팅하거나 재부팅하지 않고 변경사항을 적용하는 명령어를 실행합니다. 1$ /etc/rc.d/init.d/network restart 또는 1$ service network restart 참고 https://www.ibm.com/docs/ko/aix/7.2?topic=i-ifconfig-command","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"}]},{"title":"[CentOS] netstat 사용 포트 확인","slug":"linux-26","date":"2022-12-14T01:35:12.000Z","updated":"2024-01-12T06:30:58.009Z","comments":true,"path":"2022/12/14/linux-26/","link":"","permalink":"http://hgko1207.github.io/2022/12/14/linux-26/","excerpt":"","text":"리눅스 환경에서 netstat 명령어를 사용하여 네트워크 정보를 확인하는 방법에 대해 알아보겠습니다. netstat 란 netstat는 전송 제어 프로토콜, 라우팅 테이블, 수많은 네트워크 인터페이스, 네트워크 프로토콜 통계를 위한 네트워크 연결을 보여주는 명령 줄 도구이다. 위키백과 netstat는 네트워크 관련한 정보를 보는 유틸리티로 오래전부터 Unix 계열의 운영체제에서 사용되어 왔으며 현재 LISTEN 중인 포트, 모든 내외부/연결 정보 등을 확인할 수 있습니다. 자주 사용하는 netstat 옵션 -a : 모든 소켓보기, 이 옵션이 없으면 상태가 ESTABLISHED 인 것만 나옵니다. --all 옵션과 동일합니다. -n : 도메인 주소를 읽어들이지 않고 숫자로 출력합니다. -p : PID(프로세스 ID) 와 사용 중인 프로그램명이 출력됩니다. netstat 옵션 -c : 현재 실행 명령을 매 초마다 실행 -l : listen 하고 있는 포트만 보여줌 -i : 내트워크 트래픽정보 모니터링 -t : tcp 로 연결된 내용 출력 -u : udp 로 연결된 내용 출력 -r : 라우팅 테이블을 출력 -s : 프로토콜별 통계 정보 netstat State LISTEN : 서버에 프로세스가 실행되어 있으며 클라이언트의 접속 요청을 기다리는 상태 ESTABLISED : 서버와 클라이언트간에 세션 연결이 성립되어 통신이 이루어지는 상태 CLOSE_WAIT : TCP 연결이 상위 레벨로부터 연결 종료를 기다리는 상태 TIME_WAIT : 연결은 종료 되었지만 특정시간 동안 소켓을 열어놓은 상태 CLOSE : 연결이 종료된 상태 모든 소켓 확인 12345678910111213141516$ netstat -aActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:sunrpc 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:wap-wsp 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:vrace 0.0.0.0:* LISTENtcp 0 0 localhost.locald:domain 0.0.0.0:* LISTEN...Active UNIX domain sockets (servers and established)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ] DGRAM 41808 @000f7unix 2 [ ACC ] STREAM LISTENING 46336 @/tmp/.ICE-unix/2446unix 2 [ ACC ] STREAM LISTENING 40451 /var/run/docker/metrics.sockunix 2 [ ACC ] STREAM LISTENING 42868 @/tmp/dbus-i51dyYJlx0... TCP 포트 목록 특정 문자열이 포함된 포트를 확인할 수 있습니다. 다음의 예시는 0 0.0.0.0 또는 0 ::: 문자열이 포함된 TCP 포트 목록을 출력하는 명령어입니다. 12345678910$ netstat -nlpt | egrep \"0 (0.0.0.0|:::)\"or$ netstat -anp | grep ^tcp | egrep \"0 (0.0.0.0|:::)\"tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 951/sshdtcp 0 0 :::22 :::* LISTEN 951/sshdtcp6 0 0 :::8080 :::* LISTEN 6959/javatcp6 0 0 :::8009 :::* LISTEN 6959/javatcp6 0 0 :::3306 :::* LISTEN 2025/mariadbd... 포트 &amp; 프로세스 목록 LISTEN 중인 포트 및 프로세스명만 확인하려면 다음과 같은 명령을 사용합니다. 1234567$ netstat -anp | grep \"LISTEN \" | grep -v 127.0.0.1 | sed 's/:::/0 /g' | sed 's/[:\\/]/ /g' | awk '&#123;print $5\"\\t\"$10&#125;' | sort -ug22 sshd8009 java8080 java3306 mysqld...","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"}]},{"title":"[CentOS] PM2 서비스 등록","slug":"linux-25","date":"2022-12-09T08:23:14.000Z","updated":"2024-01-12T06:29:03.302Z","comments":true,"path":"2022/12/09/linux-25/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/linux-25/","excerpt":"","text":"리눅스 환경에서 PM2 서비스 등록하는 방법에 대해 알아보겠습니다. PM2에서는 시스템이 부팅되고 나서 자동으로 실행되도록 하는 서비스를 등록해 주는 startup 명령어가 있습니다. pm2 등록 12$ pm2 start [파일명] --name test$ pm2 list 서비스 등록 pm2 startup 명령어를 사용하여 PM2 서비스를 등록합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142$ pm2 startup[PM2] Init System found: systemdPlatform systemdTemplate[Unit]Description=PM2 process managerDocumentation=https://pm2.keymetrics.io/After=network.target[Service]Type=forkingUser=rootLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityEnvironment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/binEnvironment=PM2_HOME=/root/.pm2PIDFile=/root/.pm2/pm2.pidRestart=on-failureExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrectExecReload=/usr/lib/node_modules/pm2/bin/pm2 reload allExecStop=/usr/lib/node_modules/pm2/bin/pm2 kill[Install]WantedBy=multi-user.targetTarget path/etc/systemd/system/pm2-root.serviceCommand list[ 'systemctl enable pm2-root' ][PM2] Writing init configuration in /etc/systemd/system/pm2-root.service[PM2] Making script booting at startup...[PM2] [-] Executing: systemctl enable pm2-root...Created symlink from /etc/systemd/system/multi-user.target.wants/pm2-root.service to /etc/systemd/system/pm2-root.service.[PM2] [v] Command successfully executed.+---------------------------------------+[PM2] Freeze a process list on reboot via:$ pm2 save[PM2] Remove init script via:$ pm2 unstartup systemd pm2 save 명령어를 통해 재부팅 시 프로세스 목록을 고정시킵니다. 123$ pm2 save[PM2] Saving current process list...[PM2] Successfully saved in /root/.pm2/dump.pm2 PM2 서비스를 시작합니다. 12345678910111213$ sudo systemctl start pm2-root.service$ systemctl status pm2-root.service● pm2-root.service - PM2 process manager Loaded: loaded (/etc/systemd/system/pm2-root.service; enabled; vendor preset: disabled) Active: active (running) since 금 2022-12-09 17:14:27 KST; 5min ago Docs: https://pm2.keymetrics.io/ Process: 18456 ExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrect (code=exited, status=0/SUCCESS) Main PID: 13515 (PM2 v5.2.0: God) Tasks: 0 Memory: 0B CGroup: /system.slice/pm2-root.service ‣ 13515 PM2 v5.2.0: God Daemon (/root/.pm2)... 시스템 재부팅 후 서비스를 확인합니다. 1$ sudo reboot 1$ pm2 list","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"메타마스크(MetaMask) 설치 및 사용 방법","slug":"blockchain-2","date":"2022-12-09T03:59:18.000Z","updated":"2024-01-12T06:28:43.382Z","comments":true,"path":"2022/12/09/blockchain-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/blockchain-2/","excerpt":"","text":"메타마스크 설치 및 사용 방법에 대해 알아보겠습니다. 메타마스크(MetaMask) 란 Ethereum 블록체인과 상호 작용하는 데 사용되는 소프트웨어 암호 화폐 지갑입니다. 이를 통해 사용자는 브라우저 확장 프로그램이나 모바일 앱을 통해 이더리움 지갑에 액세스 할 수 있으며, 이를 통해 분산 애플리케이션과 상호 작용할 수 있습니다. 위키백과 이더리움 지갑 중 메타마스크는 커뮤니티에서 사용죄는 가장 인기 있는 지갑 중 하나입니다. 설치 및 사용 방법 설치 메타마스크 웹사이트에서 크롬 플러그인으로 설치 할 수 있습니다. 사이트로 접속하여 Download 버튼을 클릭합니다. 크롬 웹 스토어 창이 열리게 되고 “Chrome에 추가” 버튼을 클릭합니다. 크롬 확장프로그램에 MetaMask가 추가됩니다. Mnemonic 복구 크롬 확장프로그램에서 MetaMask를 선택하고 “시작하기” 버튼을 클릭합니다. 처음 사용하는 사용자라면 비밀 복구 구문을 사용하여 기존 지갑 가져오기와 새 지갑과 비밀 복구 구문 생성을 선택하는 화면이 보입니다. 지갑 생성을 해서 MetaMask를 사용할 수 있지만 이전 글 [Ethereum] ganache-cli 설치 및 실행에서 생성된 Mnemonic을 사용하여 지갑을 가져오도록 하겠습니다. &quot;지갑 가져오기&quot;를 클릭하면 비밀 복구 구문으로 계정 가져오기 화면이 보입니다. 생성된 Mnemonic과 비밀번호를 입력하고 “가져오기” 버튼을 클릭합니다. 메타마스크 접속 시 화면입니다. 네트워크 추가 ganache로 실행한 네트워크를 연결하기 위해 메타마스크에서 네트워크 추가를 합니다. 메타마스크 화면에서 우측 네트워크를 클릭하고 “네트워크 추가” 버튼을 클릭합니다. 설정화면에서 &quot;네트워크 수동 추가&quot;를 클릭합니다. 네트워크 이름, 새 RPC URL(ip 주소와 포트), 체인 ID(url을 입력하면 자동으로 찾아줌), 통화 기호를 입력하고 “저장” 버튼을 클릭합니다. 추가된 네트워크가 보이며 선택 시 계정 정보가 보입니다. 결론 메타마스크 설치와 사용 방법에 대해 알아보았습니다. 이더리움 지갑에 쉽게 액세스 할 수 있어 블록체인 기반 웹이나 앱개발 시 도움이 많이 됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"}]},{"title":"[Spring Boot] WebSocket & STOMP 사용 방법","slug":"spring-2","date":"2022-12-09T00:58:32.000Z","updated":"2024-01-12T06:30:10.129Z","comments":true,"path":"2022/12/09/spring-2/","link":"","permalink":"http://hgko1207.github.io/2022/12/09/spring-2/","excerpt":"","text":"WebSocket 이란 웹소켓(WebSocket)은 하나의 TCP 접속에 전이중 통신 채널을 제공하는 컴퓨터 통신 프로토콜이다. 웹소켓 프로토콜은 2011년 IETF에 의해 RFC 6455로 표준화되었으며 웹 IDL의 웹소켓 API는 W3C에 의해 표준화되고 있다. 위키백과 HTTP 프로토콜과 호환되며, 실시간 양방향 통신을 제공하기 위한 프로토콜이며 Spring 4.0에서 등장한 네트워크 서비스입니다. (접속까지는 HTTP 프로토콜을 사용하지만 이후 WebSocket 프로토콜로 변경) Spring Boot로 구현하기 Spring Boot에서 WebSocket과 자바스크립트에서 STOMP을 사용하여 메시지를 주고받는 예제를 구현해 보려고 합니다. 의존성 추가 pom.xml에 spring-boot-starter-websocket를 추가합니다. 12345&lt;!-- 웹소켓 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; WebSocketConfig 설정 웹 소켓을 사용하기 위한 설정 파일이 필요합니다. @Configuration을 통해 해당 파일이 Bean 설정을 할 것을 나타냅니다. @EnableWebSocketMessageBroker 을 통해 WebSocket 사용을 나타냅니다. 1234567891011121314151617181920212223242526@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; /** * 클라이언트가 웹 소켓 서버에 연결하는데 사용할 웹 소켓 엔드포인트 등록 * withSockJS 를 통해 웹 소켓을 지원하지 않는 브라우저에 대해 웹 소켓을 대체한다. * +)메소드명에 STOMP가 들어가는 경우 통신 프로토콜인 STOMP구현에서 작동된다. */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(\"/websocket\").setAllowedOriginPatterns(\"*\").withSockJS(); &#125; /** * 한 클라이언트에서 다른 클라이언트로 메시지를 라우팅하는데 사용될 메시지 브로커 */ @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; // topic으로 시작되는 요청을 구독한 모든 사용자들에게 메시지를 전달한다. registry.enableSimpleBroker(\"/topic\"); // 클라이언트에서 보낸 메세지를 받을 prefix registry.setApplicationDestinationPrefixes(\"/app\"); &#125;&#125; MessageDTO 생성 메시지 내용을 담아줄 MessageDTO를 생성합니다. 1234567@Datapublic class MessageDTO &#123; private String content; private String sender;&#125; MessageController 생성 /app/sendMessage 경로를 통해 전송되면 @MessageMapping과 매핑되어 메서드를 호출합니다. 그리고 @SendTo를 통해 /topic/message를 구독하고 있는 사용자에게 MessageDTO를 JSON 형식으로 전달합니다. 123456789101112131415@Controllerpublic class MessageController &#123; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message * @return */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public MessageDTO message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); return message; &#125;&#125; @SendTo Annotation이 아닌 SimpMessagingTemplate을 사용해서 메세지를 전달할 수 있습니다. 1234567891011121314151617@Controller@RequiredArgsConstructorpublic class MessageController &#123; private final SimpMessagingTemplate simpMessagingTemplate; /** * /message/sendMessage로 요청이 들어오면 해당 메소드로 처리된다. * @param message */ @MessageMapping(\"/sendMessage\") @SendTo(\"/topic/message\") public void message(MessageDTO message) &#123; System.out.println(\"메세지 도착 :\" + message); simpMessagingTemplate.convertAndSend(\"/topic/message\", message); &#125;&#125; STOMP 사용 STOMP는 Simple Text Oriented Messaging Protocol의 약자입니다. 클라이언트와 서버가 서로 통신하는 데 있어 메시지의 형식, 유형, 내용 등을 정의해 주는 프로토콜이라고 할 수 있습니다. STOMP를 사용하게 되면 단순한 Binary, Text가 아닌 규격을 갖춘 메시지를 보낼 수 있습니다. 라이브러리 추가 sockjs와 stomp 라이브러리를 추가합니다. 1234&lt;!-- sock js --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.2/sockjs.min.js\"&gt;&lt;/script&gt;&lt;!-- STOMP --&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js\"&gt;&lt;/script&gt; 메시지 받기 클라이언트에서는 다음과 같이 연결하고 구독을 합니다. 12345678910function subscribeMessage() &#123; let socket = new SockJS('/websocket'); let stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; stompClient.subscribe('/topic/message', function (message) &#123; console.log(message.body); &#125;); &#125;);&#125; 메시지 전송 메세지 전송 시 실행되는 함수입니다. 12345678910111213function sendMessage() &#123; const socket = new SockJS('/websocket'); const stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function () &#123; const message = &#123; content: 'test', sender: 'hgko', &#125;; stompClient.send('/app/sendMessage', &#123;&#125;, JSON.stringify(message)); stompClient.disconnect(); &#125;);&#125; 결론 Spring Boot 환경에서 WebSocket과 STOMP를 활용한 메시지 전송 기능 구현에 대해 알아보았습니다. 쉽게 구현할 수 있어 적용이 빠를 것 같습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"}]},{"title":"[OpenLayers] Feature Drag and Drop","slug":"js-dev-8","date":"2022-12-07T15:29:35.000Z","updated":"2024-01-12T06:27:46.376Z","comments":true,"path":"2022/12/08/js-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-8/","excerpt":"","text":"이전 글 [OpenLayers] Custom Icon Feature 추가 에서 추가된 Icon Feature를 Drag and Drop 하는 예제입니다. Script ol.interaction.Modify 을 이용해서 Drag and Drop 기능을 구현합니다. modifystart, modifyend 이벤트를 등록하여 Icon을 선택하거나 이동 시 커서가 변경되도록 하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;;// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// var dragInteraction = new ol.interaction.Modify(&#123; features: new ol.Collection([iconFeature]), &#125;); const target = document.getElementById('map'); dragInteraction.on('modifystart', function (event) &#123; target.style.cursor = 'grabbing'; &#125;); dragInteraction.on('modifyend', function (event) &#123; target.style.cursor = 'pointer'; event.features.forEach(function (feature) &#123; const name = feature.get('name'); console.log(name); // Drop 완료 시 프로세스 진행 &#125;); &#125;, iconFeature); const overlaySource = dragInteraction.getOverlay().getSource(); overlaySource.on(['addfeature', 'removefeature'], function (evt) &#123; target.style.cursor = evt.type === 'addfeature' ? 'pointer' : ''; &#125;); this.addInteraction(dragInteraction); /////////////////////////////////////////////////////// &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); Drop 이 되었을 때 feature.get() 함수를 이용해서 설정한 값을 가져와 다음 프로세스를 처리합니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Custom Icon Feature 추가","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"}]},{"title":"[OpenLayers] Custom Icon Feature 추가","slug":"js-dev-7","date":"2022-12-07T15:19:40.000Z","updated":"2024-01-12T06:27:12.315Z","comments":true,"path":"2022/12/08/js-dev-7/","link":"","permalink":"http://hgko1207.github.io/2022/12/08/js-dev-7/","excerpt":"","text":"이전 글 [OpenLayers] Static Image에서 설정한 Static Image 위에 주어진 위치의 아이콘을 표시하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. Script 기존 코드에서 addVectorLayer 함수와 styles 객체가 추가되었습니다. 먼저 ol.style.Icon 을 이용해서 아이콘 경로를 설정합니다. 12345678const styles = &#123; icon: new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 1, src: 'images/icon.png', &#125;), &#125;),&#125;; ol.Feature, ol.layer.Vector 이용해서 Vector Layer를 생성하고 지도에 레이어를 추가합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;, /////////////////////////////////////////////////////// // 추가된 부분 /////////////////////////////////////////////////////// addVectorLayer: function (x, y) &#123; const iconFeature = new ol.Feature(&#123; geometry: new ol.geom.Point([x, y]), type: 'icon', name: 'icon', &#125;); const vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: [iconFeature], wrapX: false, &#125;), style: function (feature) &#123; return styles[feature.get('type')]; &#125;, &#125;); this.map.addLayer(vectorLayer); &#125;, ///////////////////////////////////////////////////////&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName); mapInfo.addVectorLayer(100, 100);&#125;); 결과 [100, 100] 위치에 아이콘이 표시됩니다. 참고 https://openlayers.org/en/latest/examples/ [OpenLayers] Static Image","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"}]},{"title":"[OpenLayers] Static Image 사용 방법","slug":"js-dev-6","date":"2022-12-07T12:10:10.000Z","updated":"2024-01-12T06:26:23.353Z","comments":true,"path":"2022/12/07/js-dev-6/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/js-dev-6/","excerpt":"","text":"OpenLayers 사용하여 OSM(OpenStreetMap)으로 지도를 가시화하는 것이 아닌 Static Image를 Layer Source로 사용하여 이미지를 가시화하는 예제입니다. OpenLayers 3 버전을 사용하였습니다. HTML 12345678910111213141516171819202122232425&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Static Map Example&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.css\" /&gt; &lt;style&gt; .map &#123; width: 100%; height: 600px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/ol3/4.6.5/ol.js\"&gt;&lt;/script&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Script 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// main.js// 지도 정보const mapInfo = &#123; map: null, extent: null, projection: null, setProjection: function (w, h) &#123; this.extent = [0, 0, w, h]; this.projection = new ol.proj.Projection(&#123; code: 'pixel', units: 'pixels', extent: this.extent, &#125;); &#125;, init: function (imageName) &#123; const view = new ol.View(&#123; projection: this.projection, center: ol.extent.getCenter(this.extent), zoom: 2, maxZoom: 8, &#125;); const imageLayer = new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: 'images/' + imageName, imageSize: [this.extent[2], this.extent[3]], projection: this.projection, imageExtent: this.extent, &#125;), &#125;); this.map = new ol.Map(&#123; target: 'map', layers: [imageLayer], view: view, &#125;); this.zoomFit(); &#125;, zoomFit: function () &#123; this.map.getView().fit(this.extent, &#123; duration: 200 &#125;); &#125;,&#125;;// Initialize module// ------------------------------document.addEventListener('DOMContentLoaded', function () &#123; const width = 500; const height = 500; const imageName = 'image.png'; mapInfo.setProjection(width, height); mapInfo.init(imageName);&#125;); OpenLayers 활용 라이브러리입니다. ol.proj.Projection ol.View ol.layer.Image ol.source.ImageStatic ol.Map 결과 Static Image 가 지정한 크기의 지도 중앙에 가시화됩니다. 참고 https://openlayers.org/en/latest/examples/static-image.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"}]},{"title":"[CentOS] Node.js 및 NPM 설치","slug":"linux-24","date":"2022-12-07T03:47:28.000Z","updated":"2024-01-12T06:26:52.978Z","comments":true,"path":"2022/12/07/linux-24/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/linux-24/","excerpt":"","text":"리눅스 환경에서 Node.js 와 NPM 설치하는 방법에 대해 알아보겠습니다. 운영환경 Centor 7.6 저장소 추가 설치하려는 Node.js 버전을 확인하여 NodeSource yum 저장소를 추가합니다. NodeSource Node.js Binary Distributions 사이트에 다음과 같은 내용이 정리되어 있습니다. Node.js v19.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_19.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_19.x | sudo bash - Node.js v18.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash - Node.js v16.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_16.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash - Node.js v14.x 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_14.x | sudo bash - Node.js LTS (18.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo bash - Node.js Current (19.x) 12345# As root$ curl -fsSL https://rpm.nodesource.com/setup_current.x | bash -# No root privileges$ curl -fsSL https://rpm.nodesource.com/setup_current.x | sudo bash - 설치 yum을 사용하여 Node.js 및 npm을 설치합니다. Node.js 14 버전을 설치해 보도록 하겠습니다. 12$ curl -fsSL https://rpm.nodesource.com/setup_14.x | bash -$ yum install -y nodejs 설치 확인 다음 명령어를 통해 설치된 버전을 확인할 수 있습니다. 12$ node --versionv14.20.0 12$ npm --version6.14.17 참고 https://github.com/nodesource/distributions","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[Ethereum] ganache-cli 설치 및 실행 방법","slug":"blockchain-1","date":"2022-12-07T01:20:28.000Z","updated":"2024-01-12T06:25:45.807Z","comments":true,"path":"2022/12/07/blockchain-1/","link":"","permalink":"http://hgko1207.github.io/2022/12/07/blockchain-1/","excerpt":"","text":"ganache-cli를 설치하고 실행하는 방법에 대해 알아보겠습니다. Ganache &quot;가나슈&quot;라고 읽으면 되고, 가상의 이더리움 네트워크를 생성해서 Smart Contract를 실행할 수 있도록 해주는 프로그램입니다. 이런 가상 환경을 TestRPC라고 합니다. Ganache CLI Ganache CLI는 빠르고 커스터마이징 가능한 블록체인 에뮬레이터인 TestRPC의 최신 버전입니다. 실제 이더리움 노드를 실행하는 오버헤드 없이 블록체인을 호출할 수 있습니다. Transactions are “mined” instantly. No transaction cost. Accounts can be re-cycled, reset and instantiated with a fixed amount of Ether (no need for faucets or mining). Gas price and mining speed can be modified. A convenient GUI gives you an overview of your testchain events. NPM 설치 Ganache는 NPM을 통해 설치할 수 있습니다. 먼저 NPM이 설치되어 있어야 합니다. 이전 글 Node.js 및 NPM 설치 을 참고해서 설치를 합니다. Ganache 설치 1$ npm install -g ganache-cli 실행 1$ ganache-cli &lt;options&gt; ganache-cli 명령어를 통해 실행합니다. 옵션 없이 실행 시 다음과 같은 결과를 볼 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ ganache-cliGanache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x3F82D42b4b946aA53fF069cF931d940872C3f675 (100 ETH)(1) 0x0912b4EdD5279FEE8362257adD75715424C51a39 (100 ETH)(2) 0x668fF7BD1fe9ffe6758B9d1f71fcdA22c56f68ce (100 ETH)(3) 0xD74Dd2D769763B78009a67b6b87c7810a7eb7E6d (100 ETH)(4) 0x6Ec7b0A1f88f482711f4C8b378c8B4c6dCB863EB (100 ETH)(5) 0xa7eed29620A49ca13F780b740d597Cc79092E2D9 (100 ETH)(6) 0xfE7f9A8E6c147A07bd1b0601431dc74468456174 (100 ETH)(7) 0x0b3a29F6174631a97fe9B9289c66456ddD27D069 (100 ETH)(8) 0x89b626bAF633fAb58986499195b4F98d15D09252 (100 ETH)(9) 0xA42521a288fD576f59E1F7A7461Dfe88A52cAF99 (100 ETH)Private Keys==================(0) 0xe7c964a0050a9c8c79008eab74502ea7c105a425b5e6b8ffe57d72eef4165c20(1) 0x098196b42d262985b0f0b43edc4a51919d8dd9925e0feee485859c5987b4af9c(2) 0x23738d8fc442fd26c7a802423868bbfc0c0d930f15baef50531483a1e9f7cecd(3) 0xa67eaa626df00109e219b5f94d33535d536b19d362fbf0eff08e7143383fd95e(4) 0xede8027c26a03ec63d6b9c404216fe6328936cc6584f93b3389901bfe34efef0(5) 0x30541fc3cac5dbe9e96a482dcd4100930270f9759d1e15494bbf26932fd6e873(6) 0xa8ed660d43f2c775efff16732088e34ab23775fa56375f491c8bec3123bde75c(7) 0x5cf88b19ce7be57320c2a89bf03a9ea5a512a5dc07f9e14f4a752fb1a021deac(8) 0x557ae7917ca63f17fbb947933c3ad13cc699f42293aafbebe24729f91708eabe(9) 0xbe44643a2507aa8fc13893f4052edd154e6753d74bec3f8a8ec6a88fda645c19HD Wallet==================Mnemonic: convince have junior clean bomb fluid gossip surprise build twenty urban swordBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;Gas Price==================20000000000Gas Limit==================6721975Call Gas Limit==================9007199254740991Listening on 127.0.0.1:8545 기존 Mnemonic 을 가지고 있다면 -m 옵션을 추가하여 설정할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435$ ganache-cli -d -m \"taxi\"Ganache CLI v6.12.2 (ganache-core: 2.13.2)Available Accounts==================(0) 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1 (100 ETH)(1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0 (100 ETH)(2) 0x22d491Bde2303f2f43325b2108D26f1eAbA1e32b (100 ETH)(3) 0xE11BA2b4D45Eaed5996Cd0823791E0C93114882d (100 ETH)(4) 0xd03ea8624C8C5987235048901fB614fDcA89b117 (100 ETH)(5) 0x95cED938F7991cd0dFcb48F0a06a40FA1aF46EBC (100 ETH)(6) 0x3E5e9111Ae8eB78Fe1CC3bb8915d5D461F3Ef9A9 (100 ETH)(7) 0x28a8746e75304c0780E011BEd21C72cD78cd535E (100 ETH)(8) 0xACa94ef8bD5ffEE41947b4585a84BdA5a3d3DA6E (100 ETH)(9) 0x1dF62f291b2E969fB0849d99D9Ce41e2F137006e (100 ETH)Private Keys==================(0) 0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d(1) 0x6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1(2) 0x6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c(3) 0x646f1ce2fdad0e6deeeb5c7e8e5543bdde65e86029e2fd9fc169899c440a7913(4) 0xadd53f9a7e588d003326d1cbf9e4a43c061aadd9bc938c843a79e7b4fd2ad743(5) 0x395df67f0c2d2d9fe1ad08d1bc8b6627011959b79c53d7dd6a3536a33ab8a4fd(6) 0xe485d098507f54e7733a205420dfddbe58db035fa577fc294ebd14db90767a52(7) 0xa453611d9419d0e56f499079478fd72c37b251a94bfde4d19872c44cf65386e3(8) 0x829e924fdf021ba3dbbc4225edfece9aca04b929d6e75613329ca6f1d31c0bb4(9) 0xb0057716d5917badaf911b193b12b910811c1497b5bada8d7711f758981c3773HD Wallet==================Mnemonic: taxiBase HD Path: m/44'/60'/0'/0/&#123;account_index&#125;... 실행 옵션 옵션들을 확인하여 환경에 맞게 실행합니다. -a or --accounts: 시작 시 생성할 계정 수를 지정합니다. -b or --blocktime: 자동 마이닝을 위한 블록 타임을 초 단위로 지정합니다. 기본값은 0이며 자동 마이닝이 없습니다. -d or --deterministic: 미리 정의된 니모닉을 기반으로 결정적 주소를 생성합니다. -n or --secure: 기본적으로 사용 가능한 계정 잠금(제3자 트랜잭션 서명에 적합) -m or --mnemonic: 특정 HD 지갑 니모닉을 사용하여 초기 주소를 생성합니다. -p or --port: 포트 번호 설정. 기본값은 8545 입니다. -h or --hostname: 호스트 이름. 기본값은 노드의 server.listen() 입니다. -s or --seed: 임의의 데이터를 사용하여 사용할 HD 지갑 니모닉을 생성합니다. -g or --gasPrice: 사용자 지정 가스 가격 설정(기본값은 20000000000) -l or --gasLimit: 사용자 지정 가스 한도 설정(기본값은 90000) -f or --fork: 주어진 블록에서 현재 실행 중인 다른 이더리움 클라이언트에서 분기합니다. 입력은 다른 클라이언트의 HTTP 주소 및 포트여야 합니다.(예: http://localhost:8545) -i or --networkId: ganache-cli가 자신을 식별하는 데 사용할 네트워크 ID를 지정합니다. --db: 체인 데이터베이스를 저장할 디렉터리 경로를 지정합니다. 데이터베이스가 이미 존재하는 경우 ganache-cli는 새 체인을 생성하는 대신 해당 체인을 초기화합니다. --debug: Output VM opcodes for debugging --mem: ganache-cli 메모리 사용량 통계를 출력합니다. --e: 사용자 계정별 가스를 설정합니다.(기본값은 100) 참고 https://www.npmjs.com/package/ganache-cli https://docs.nethereum.com/en/latest/ethereum-and-clients/ganache-cli/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"}]},{"title":"[CentOS] 사용자 계정 관리","slug":"linux-23","date":"2022-12-05T01:15:46.000Z","updated":"2024-01-12T06:24:36.794Z","comments":true,"path":"2022/12/05/linux-23/","link":"","permalink":"http://hgko1207.github.io/2022/12/05/linux-23/","excerpt":"","text":"리눅스 환경에서 사용자 계정 조회, 추가, 수정, 삭제하는 방법에 대해 알아보겠습니다. 사용자 조회 모든 사용자를 출력합니다. 123456$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin... 사용자 계정 확인 root와 useradd 또는 adduser 명령어를 통해 생성한 사용자 계정을 출력합니다. 123$ grep /bin/bash /etc/passwdroot:x:0:0:root:/root:/bin/bashhgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 사용자 계정 확인 입력한 특정 사용자 계정을 출력합니다. 1$ cat /etc/passwd | grep [사용자계정] 12$ cat /etc/passwd | grep hgkohgko:x:1000:1000:hgko:/home/hgko:/bin/bash 특정 조건(ID 500 이상)을 통해 사용자 목록을 조회합니다. 123456$ awk -F':' '&#123;if($3 &gt;= 500)print $1&#125;' /etc/passwdpolkitdunboundlibstoragemgmtcolord... 사용자 추가 useradd 1$ useradd [사용자계정] test 사용자를 생성합니다. 1$ useradd test 사용자 홈 디렉터리도 같이 만들고 싶다면 -m 또느 -d 옵션을 사용합니다. 12345# 홈 디렉토리를 지정할 때 사용하고 디렉토리가 없으면 생성$ useradd test -m# 홈 디렉토리 지정$ useradd test -d /home/test test 사용자의 비밀번호를 생성합니다. passwd는 리눅스 사용자 계정의 비밀번호를 변경하는 명령어입니다. 12345$ passwd testChanging password for user test.New password: ****Retype new password: ****passwd: all authentication tokens updated successfully. adduser adduser 명령어는 useradd 명령어와 달리 사용자 홈 디렉터리를 자동으로 만들고, 비밀번호 설정 등로 한 번에 할 수 있습니다. 1234567891011121314151617$ adduser testAdding user `test' ...Adding new group `test' (1000) ...Adding new user `test' (1000) with group `test' ...Creating home directory `/home/test' ...Copying files from `/etc/skel' ...New password: ****Retype new password: ****passwd: password updated successfullyChanging the user information for testEnter the new value, or press ENTER for the default Full Name []: test Room Number []: Work Phone []: Home Phone []: Other []:Is the information correct? [Y/n] 사용자 수정 1$ usermod [option] [사용자계정] test 사용자의 홈 디렉터리를 변경합니다. 1$ usermod -d /home/test1 test 사용자 삭제 1$ userdel [사용자계정] test 사용자를 삭제합니다. 1$ userdel test test 사용자를 강제로 삭제합니다. 1$ userdel -f test test 사용자와 함께 사용자 디렉터리도 같이 삭제합니다. 1$ userdel -r test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"}]},{"title":"리눅스 명령어","slug":"linux-22","date":"2022-11-30T02:05:43.000Z","updated":"2023-03-14T02:26:09.998Z","comments":true,"path":"2022/11/30/linux-22/","link":"","permalink":"http://hgko1207.github.io/2022/11/30/linux-22/","excerpt":"","text":"자주 사용하는 리눅스 명령어에 대해 알아보겠습니다. 명령어 설명 cdcd …cd -cd ~cd /cd [path] 디렉토리 이동 cp [path] [target] -R 파일 복사 tar cvfz backup.tar.gz [target] tar 로 압축 tar cvfz backup.tar.gz /test --exclude “/test/backup” 특정 디렉토리 제외하고 tar 로 압축 tar xvfz backup.tar.gz 압축 풀기 which [command]예) which find 특정 명령어의 위치 source /etc/profile 환경 설정 적용 find / -name [파일명]예) find / -name ‘test’ 파일 찾기 ls -al 디렉토리 조회 du -skh 디렉토리 용량 확인 df -h 디스크 용량 확인 ps -ef | grep [실행프로세스]예) ps -ef | grep tomcat 실행 프로세스 확인 kill -9 [pid] 프로세스 강제 종료 grep -nR [단어] * 예) grep -nR ‘/test/’ * 특정 단어 존재 여부 검사 mkdir [디렉토리명] 디렉토리 생성 rmdir [디렉토리명] 디렉토리 삭제 rm [파일명] 파일 삭제 pwd 현재 디렉토리 위치 catcat [파일명] 파일 내용 출력 id 사용자 로그인명 useradd [id] 계정 추가 userdel [id] 계정 삭제 usermod [id] 계정 수정 passwod [id] 비밀번호 변경 chmod 실행 권한 clear 화면 내용 지우기 free 메모리 확인 w 사용자 로그인 정보 top 시스템 운용상황 점검","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[JPA] CascadeType 정리","slug":"spring-jpa-6","date":"2022-11-29T04:51:38.000Z","updated":"2024-01-12T06:23:37.757Z","comments":true,"path":"2022/11/29/spring-jpa-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/29/spring-jpa-6/","excerpt":"","text":"동일 트랜잭션 내부 연관 엔티티가 수정되었을 경우 CascadeType과 상관없이 자동으로 수정됩니다. 같은 트랜젝션이라 하더라도 해당 엔티티가 CasecadeType.PERSIST 로 설정 되어 있지 않으면 연관 엔티티를 추가하더라도 반영되지 않습니다. (CascadeType.MERGE로 설정 되어도 추가는 되지 않음) CascadeType 별 동작 CascadeType.ALL 상위 엔티티에서 하위 엔티티로 모든 작업을 전파합니다. 모든 Cascade 설정을 적용합니다. CascadeType.PERSIST 상위 엔티티를 생성하고, 하위 엔티티를 추가하였을 때 persist()를 수행하면 하위 엔티티도 같이 persist()가 수행됩니다. 만약, 하위 엔티티가 DB에 등록된 키값을 가졌다면 detached entity passed to persist 예외가 발생합니다. CascadeType.MERGE 트랜젝션이 종료되고 detach 상태에서 하위 엔티티를 추가하거나 변경된 이후에 상위 엔티티가 merge()를 수행하게 되면 변경 사항이 적용됩니다. 하위 엔티티의 추가 및 수정 모두 반영됩니다. CascadeType.REMOVE 삭제 시 연관된 하위 엔티티들도 같이 삭제됩니다. CascadeType.DETACH 상위 엔티티가 detech()를 수행하게 되면 연관된 하위 엔티티도 detach() 상태가 되어 변경 사항이 반영되지 않습니다. 고려사항 부모/자식 간의 관계를 설정하는 과정에서 부모가 데이터베이스에 존재하지 않는 경우 데이터 무결성의 문제가 발생합니다. 자식 레코드를 삭제하지 않은 상태에서 부모 레코드를 먼저 삭제하려 시도하는 경우 참조 무결성 위반이 발생합니다. 참고 https://www.baeldung.com/jpa-cascade-types","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"}]},{"title":"[Spring] QuerydslRepositorySupport 사용","slug":"spring-querydsl-2","date":"2022-11-28T02:45:08.000Z","updated":"2024-01-12T06:22:34.853Z","comments":true,"path":"2022/11/28/spring-querydsl-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-2/","excerpt":"","text":"QueryDslPredicateExecutor를 이용하는 findAll, findOne 등은 where, Sort, Limit 등의 조건만 넣을 수 있습니다. 하지만 Join이나 Group by 등의 기능을 사용하려면 인터페이스 선언만으로는 기능을 구현하기 힘듭니다. 이를 해결하기 위해서 Spring Data JPA에서 제공하는 QuerydslRepositorySupport 추상 클래스가 있습니다. QuerydslRepositorySupport는 개발자에게 querydsl 객체를 직접 제공합니다. 예를 들어 권한별 사용자 수에 대한 데이터가 필요하다면, 다음과 같이 할 수 있습니다. 사용자 클래스와 DTO 클래스를 생성합니다. 1234567891011121314151617@Data@Entity@Tablepublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column(nullable = false, length = 50) private String username; @Column(nullable = false, length = 50) private String password; private int role;&#125; 123456789101112@Datapublic class UserRoleCountDTO &#123; private int role; private long count; public UserRoleCountDTO(int role, long count) &#123; this.role = role; this.count = count; &#125;&#125; 권한별 사용자 수를 얻어오는 인터페이스를 생성하고 메소드를 선언합니다. 123public interface UserRepositoryCustom &#123; List&lt;UserRoleCountDTO&gt; getUserRoleCount();&#125; UserRepository에 상속 시킵니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt;, UserRepositoryCustom &#123;&#125; QuerydslRepositorySupport를 이용해서 UserRepositoryCustom를 구현하는 클래스를 작성합니다. UserRepository 이름 뒤에 Impl이라는 Postfix 가 붙으면 자동으로 Spring Data JPA의 AOP 주입 대상이 됩니다. 12345678910111213public class UserRepositoryImpl extends QuerydslRepositorySupport implements UserRepositoryCustom &#123; public UserRepositoryImpl() &#123; super(User.class); &#125; @Override public List&lt;UserRoleCountDTO&gt; getUserRoleCount() &#123; QUser user = QUser.user; return from(user).groupBy(user.role) .list(Projections.constructor(UserRoleCountDTO.class, user.role, user.role.sum)); &#125;&#125; 위의 예제를 통해 JpaRepository의 기능과 추가로 구현한 UserRepositoryCustom의 추가 기능까지 사용할 수 있습니다. 1234567891011@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public void testQuery() &#123; List&lt;UserRoleCountDTO&gt; userRoleCountDTOs = userRepository.getUserRoleCount(); System.out.println(\"result =&gt;\" + userRoleCountDTOs); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"}]},{"title":"[Spring] JPA with Querydsl","slug":"spring-querydsl-1","date":"2022-11-28T01:57:14.000Z","updated":"2024-01-12T06:21:05.213Z","comments":true,"path":"2022/11/28/spring-querydsl-1/","link":"","permalink":"http://hgko1207.github.io/2022/11/28/spring-querydsl-1/","excerpt":"","text":"Query DSL JPA, JDO, SQL 같은 백엔드를 위해 type-safe SQL을 만드는 프레임워크 Domain Specific Language 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어 특징 type-safe 조회에 특화된 프로그래밍 언어 단순, 간결 다양한 저장소 조회 기능 통합 (데이터 조회 기능 추상화) 동작 방식 Member java or Member table의 메타 데이터를 참조하여 코드 생성기를 통해 QMember.java를 생성합니다. APT: Annotation Processing Tool Table Meta: Querydsl-maven-plugin 기능 Query: from, where, join Path: QMember, Qmember.name Expression: name.eq, name.qt 세부기능 from innerJoin, join, leftJoin, fetchJoin, fullJoin, on where (and, or, allOf, anyOf) groupBy having order By (desc, asc) limit, offset, restrict(limit + offset) (Paging) list listResults (list + Paging Info(totalCount)) iterate count singleResult, uniqueResult 사용 방법 설정 Spring Boot 프로젝트의 pom.xml 에 의존성과 플러그인을 추가합니다. QueryDSL을 사용하기 위해서는 com.querydsl에서 제공하는 querydsl-jpa와 querydsl-apt에 대한 의존성이 필요합니다. 123456789101112131415&lt;!-- dependencies 에 추가 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jdo&lt;/artifactId&gt;&lt;/dependency&gt; com.mysema.maven에서 제공하는 apt-maven-plugin을 설치합니다. 123456789101112131415161718&lt;!-- build - plugins 에 추가 --&gt;&lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;sourceEncoding&gt;UTF-8&lt;/sourceEncoding&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 이제 프로젝트 우클릭 후 maven -&gt; Update Project… 수행하면 Entity에 대한 Q 클래스들이 target/generated-sources/java 경로에 생성된 것을 확인할 수 있습니다. 도메인 클래스 생성 테이블 도메인 클래스를 생성합니다. 1234567891011@Entity@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 인터페이스를 작성합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123;&#125; Querydsl 사용 예 Repository 인터페이스에 QuerydslPredicateExecutor 를 확장합니다. 12public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt;, QuerydslPredicateExecutor&lt;Team&gt; &#123;&#125; 1234567891011@Service@RequiredArgsConstructorpublic class TeamService &#123; private final TeamRepository teamRepository; public void testQuerydsel &#123; teamRepository.findAll(QTeam.team.name.eq(\"test\"1)); teamRepository.findOne(QTeam.team.rating.loe(100)); &#125;&#125; JPAQuery 사용 예 JPAQuery을 Bean 등록 후 사용 가능합니다. 1234567891011@SpringBootApplicationpublic class TestWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestWebApplication.class, args); &#125; @Bean public JPAQueryFactory jpaQueryFactory(EntityManager em) &#123; return new JPAQueryFactory(em); &#125;&#125; 123456789101112131415@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl() &#123; QTeam team = QTeam.team; List&lt;Team&gt; teams = query.from(team) .where(team.name.eq(\"test1\").or(team.name.like(\"hgko%\"))) .list(team); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125; BooleanBuilder 사용 예 상황에 따라 동적으로 변경되는 쿼리를 작성할 경우 BooleanBuilder 를 사용하면 간편하게 쿼리를 작성할 수 있습니다. 12345678910111213141516171819@Service@RequiredArgsConstructorpublic class TeamService &#123; private final JPAQueryFactory factory; public void testQuerydsl(String name) &#123; QTeam team = QTeam.team; // 검색 조건에 따른 동적 쿼리 작성 BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(name)) &#123; builder.and(team.name.contains(name)); &#125; List&lt;Team&gt; teams = factory.selectFrom(team).where(builder).fetch(); System.out.println(\"querydsl =&gt;\" + teams); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"}]},{"title":"[JPA] NamedQuery","slug":"spring-jpa-5","date":"2022-11-25T01:10:56.000Z","updated":"2024-01-12T06:19:56.059Z","comments":true,"path":"2022/11/25/spring-jpa-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/25/spring-jpa-5/","excerpt":"","text":"NamedQuery 란 Entity에 @NamedQuery 어노테이션을 통해 쿼리를 지정해 줍니다. 쉽게 말하면 미리 이름을 부여해서 재활용할 수 있는 JPQL입니다. 사용 방법 도메인 클래스에 @NamedQuery 또는 @NamedNativeQuery를 정의합니다. 2개 이상의 Query를 정의하려면 @NamedQueries 또는 @NamedNativeQueries를 사용하면 됩니다. Primary Key 가 되는 칼럼은 @Id를 사용하여 지정합니다. 테이블의 칼럼명과 도메인 클래스의 필드명이 다를 경우 @Column을 이용하여 지정할 수 있습니다. 클래스 생성 위의 설명의 어노테이션을 사용하여 도메인 클래스를 생성합니다. 12345678910111213141516171819@Entity@NamedQueries(&#123; @NamedQuery(name = \"Team.query1\", query = \"select t.id from Team t where t.name = 'test1'\"), @NamedQuery(name = \"Team.query2\", query = \"select t.name from Team t where t.name = ?1\"),&#125;)@NamedNativeQueries(&#123; @NamedNativeQuery(name = \"Team.nativeQuery1\", query = \"select t.id from tb_team t where t.name = 'test1'\"), @NamedNativeQuery(name = \"Team.nativeQuery2\", resultClass = Team.class, query = \"select * from tb_team t where t.name = '?1\")&#125;)@Table(name = \"tb_team\")public class Team &#123; @Id private int id; @Column(name = \"name\", nullable = false) private String name; private int rating;&#125; Repository 생성 Repository 인터페이스에 직접 @Query를 이용하여 SQL문을 사용할 수 있습니다. nativeQuery를 사용하려면 해당 필드를 true로 설정하면 됩니다. @Param을 사용하여 Query문의 파라미터와 연결할 수 있습니다. entityName을 사용하면 도메인 타입이 자동으로 설정됩니다. 12345678910111213141516public interface TeamRepository extends JpaRepository&lt;Team, Integer&gt; &#123; @Query(value = \"select * from tb_team t where t.name = 'test1'\", nativeQuery = true) List&lt;Team&gt; testNativeQuery(); @Query(value = \"select t.id from #&#123;#entityName&#125; t where t.name like :name%\", nativeQuery = true) List&lt;String&gt; testNativeQuery(@Param(\"name\") String name); List&lt;Integer&gt; query1(); List&lt;String&gt; query2(String name); List&lt;Integer&gt; nativeQuery1(); List&lt;Team&gt; nativeQuery2(String name);&#125; 위와 같이 클래스에 Native 쿼리문을 작성하고 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"}]},{"title":"[JPA] 쿼리 메서드","slug":"spring-jpa-4","date":"2022-11-24T06:24:06.000Z","updated":"2024-01-12T06:18:42.077Z","comments":true,"path":"2022/11/24/spring-jpa-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-4/","excerpt":"","text":"Spring Data JPA 쿼리 메서드는 가장 강력한 메서드이며, SQL 쿼리를 작성하지 않고도 데이터베이스에서 레코드를 선택하는 쿼리 메서드를 만들 수 있습니다. 백그라운드에서 Spring Data JPA는 쿼리 메서드를 기반으로 SQL 쿼리를 생성하고 쿼리를 실행합니다. Entity 필드를 사용하여 Repository에 대한 쿼리 메서드를 생성할 수 있으며 쿼리 메서드 생성을 finder methods(findBy, findAll …)라고도 합니다. 예 findByEmailAddressAndName() 이 쿼리 메서드인 UserRepository 가 있다고 가정합니다. 123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndName(String emailAddress, String name);&#125; 백그라운드에서 Spring Data JPA 는 위의 메서드(findByEmailAddressAndName)에서 JPA 기준 API를 사용하여 쿼리를 생성하지만 기본적으로 다음과 같은 JPQL 쿼리로 변환됩니다. 1select u from User u where u.emailAddress = ?1 and u.name = ?2 키워드들 JPA에 대해 지원되는 키워드와 해당 키워드를 포함하는 메서드가 무엇을 의미하는지 설명합니다. Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname, findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstname) = UPPER(?1) 참고 https://www.javaguides.net/2018/11/spring-data-jpa-query-creation-from-method-names.html https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"}]},{"title":"[JPA] @ElementCollection 사용 예","slug":"spring-jpa-3","date":"2022-11-24T06:05:52.000Z","updated":"2024-01-12T06:18:23.611Z","comments":true,"path":"2022/11/24/spring-jpa-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/24/spring-jpa-3/","excerpt":"","text":"RDB(Relational DataBase) 에는 Collection 형태의 데이터를 칼럼에 저장할 수 있는 방법이 없습니다. 그래서 별도의 테이블을 생성하고 Collection을 관리해야 합니다. JPA의 @ElementCollection 사용하여 별도의 테이블을 생성하고 Collection 을 관리할 수 있습니다. ElementCollection 특징은 부모 Entity에 의해 관리되고, 항상 부모와 함께 저장되고 삭제됩니다. casecade 옵션이 default입니다. 예 Collection 대상이 되는 객체는 @Entity 가 아닌 Embeddable Class로 생성하여 One-To-Many 관계를 맺습니다. 12345678910@Embeddable@Datapublic class Address &#123; @Column(length = 50) public String address; @Column(length = 50) public String detailAddress;&#125; @ElementCollection 생성하여 Collection 테이블을 생성합니다. 1234567891011121314@Entity@Datapublic class User &#123; @ElementCollection(fetch = FetchType.LAZY) @CollectionTable( name = \"user_address\", joinColumns = @JoinColumn(name = \"userId\") ) @ForeignKey(name = \"fk_user_address\") private List&lt;Address&gt; addresses; ...&#125; 결과 다음과 같은 DDL 스크립트가 만들어집니다. 1234567CREATE TABLE `user_address` ( `user_id` int(11) NOT NULL, `address` varchar(50) DEFAULT NULL, `detail_address` varchar(50) DEFAULT NULL, KEY `fk_user_address` (`user_id`), CONSTRAINT `fk_user_address` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 참고 https://prohannah.tistory.com/133","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"}]},{"title":"[MySQL] 스토리지 엔진(Storage Engine)","slug":"mysql-7","date":"2022-11-23T04:49:27.000Z","updated":"2024-01-12T06:17:50.644Z","comments":true,"path":"2022/11/23/mysql-7/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-7/","excerpt":"","text":"MySQL 스토리지 엔진 종류 및 간단 비교 내용입니다. MyISAM 정적인 테이블, 로그 테이블 쓰기 작업이 별로 없는 select 위주의 테이블 다수의 세션이 동시 작업을 하는 경우 성능이 저하됨 InnoDB 민감한 정보를 갖는 테이블 (회원 등) 갱신 (읽기 / 쓰기) 위주의 트랜잭션이 요구되는 테이블 인덱스가 많이 걸린 대량의 테이블 Archive 로그 수집에 적합 데이터가 메모리상에서 압축된 후 압축된 상태로 디스크에 저장 Memory 일시적으로만 사용되는 임시 테이블","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"}]},{"title":"[MySQL] 유용 명령어","slug":"mysql-6","date":"2022-11-23T04:32:58.000Z","updated":"2024-01-12T06:17:35.238Z","comments":true,"path":"2022/11/23/mysql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-6/","excerpt":"","text":"Help 1234HELP SHOW;HELP &#123;SELECT | DELETE | UPDATE&#125;;HELP ALTER;HELP ALTER &#123;DATABASE | TABLE&#125;; Show 123SHOW PRIVILEGES;SHOW OPEN TABLES;SHOW TABLE STATUS; 테이블 칼럼 조회 명령어입니다. (코멘트 포함) 1SHOW FULL COLUMNS FROM 테이블명; Select 12345-- 왜래키 규약SELECT * FROM information_schema.REFERENTIAL_CONSTRAINTS;-- PRIMARY KEY, UNIQUE 규악 등SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_schema = 데이터베이스명; 백업 1$ mysqldump &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &gt; 백업파일명.sql 복구 1$ mysql &#123; -h 호스트 &#125; -u 사용자 -p 데이터베이스명 &lt; 백업파일명.sql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[MySQL] ALTER TABLE 구문 정리","slug":"mysql-5","date":"2022-11-23T02:06:21.000Z","updated":"2024-01-12T05:52:59.560Z","comments":true,"path":"2022/11/23/mysql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/23/mysql-5/","excerpt":"","text":"MySQL에서 사용하는 ALTER TABLE 구문에 대해 알아보겠습니다. 테이블 관련 테이블 생성 테이블 2개를 생성합니다. 1234567891011CREATE TABLE test ( id INT NOT NULL AUTO_INCREMENT, age INT, name VARCHAR(50), jumin VARCAHR(15), PRIMARY KEY(id), UNIQUE(age), INDEX(name), KEY(jumin), INDEX(name, jumin)); 12345CREATE TABLE test2 ( id INT, parent_id INT, FOREIGN KEY (parent_id) REFERENCES test(id) ON DELETE CASCADE ON UIPDATE CASCADE); INDEX를 KEY로 바꿔도 됩니다. INDEX(name, jumin) 과 INDEX(name), INDEX(jumin) 은 다릅니다. 테이블 속성 변경 [] 에 들어가 있는 내용은 생략 가능합니다. 1. 필드 추가 12ALTER TABLE 테이블명 ADD [COLUMN] 추가할필드명 필드타입 [FIRST | AFTER 필드명];ALTER TABLE 테이블명 ADD [COLUMN] (추가할필드명 필드타입, ...); 2. 필드명 및 타입 변경 1ALTER TABLE 테이블명 CHANGE [COLUMN] 기존필드명 변경할필드명 변경할필드타입 [FIRST | AFTER 필드명]; 3. 필드 타입 변경 1ALTER TABLE 테이블명 MODIFY [COLUMN] 기존필드명 변경할필드명 [FIRST | AFTER 필드명]; 4. 필드 삭제 1ALTER TABLE 테이블명 DROP [COLUMN] 제거할필드명; 5. 필드 디폴트 정의 1ALTER TABLE 테이블명 ALTER [COLUMN] 필드명 &#123;SET DEFAULT 'XXX' | DROP DEFAULT&#125;; 6. 테이블명 변경 1ALTER TABLE 테이블명 RENAME 변경할테이블명; 7. COMMENT 추가 12ALTER TABLE 테이블명 COMMENT '내용';ALTER TABLE 테이블명 MODIFY 필드명 필드타입 [DEFAULT 'XXX'] COMMENT '내용'; 인덱스 관련 인덱스 생성 INDEX 123CREATE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD INDEX [인덱스명] [인덱스타입] (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD KEY [인덱스명 ] [인덱스타입] (필드1, 필드2, ...); UNIQUE 12CREATE UNIQUE INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] UNIQUE [인덱스명] [인덱스타입] (필드1, 필드2, ...); PRIMARY KEY 1ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] PRIMARY KEY [인덱스타입] (필드1, 필드2, ...); FOREIGN KEY 외래키 생성 시 제약 조건과 INDEX 가 같이 생성되며, 외래키를 삭제하더라도 INDEX는 남게 됩니다. 만약 인덱스도 삭제가 필요하다면 같이 삭제해야 합니다. 123ALTER TABLE 테이블명 ADD [CONSTRAINT [심볼]] FOREIGN KEY [인덱스명] (필드1, 필드2, ...) [레퍼런스조건] ON UPDATE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT] ON DELETE [RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT]; FULLTEXT 12CREATE FULLTEXT INDEX 인덱스명 ON 테이블명 (필드1, 필드2, ...);ALTER TABLE 테이블명 ADD FULLTEXT [인덱스명 ] (필드1, 필드2, ...); 인덱스 보기 1SHOW INDEX FROM 테이블명 인덱스 삭제 1234DROP INDEX 인덱스명 ON 테이블명;ALTER TABLE 테이블명 DROP INDEX 인덱스명;ALTER TABLE 테이블명 DROP INDEX PRIMARY KEY;ALTER TABLE 테이블명 DROP INDEX FOREIGN KEY [fk_symbol]; 기타 키 활성화 12ALTER TABLE 테이블명 ENABLE KEYS;ALTER TABLE 테이블명 DISABLE KEYS; 정렬 1ALTER TABLE 테이블명 ORDER BY 필드명; 캐릭터 셋 12ALTER TABLE 테이블명 CONVER TO CHARACTER SET 캐릭터셋ALTER TABLE 테이블명 CHARACTER SET 캐릭터셋 데이터베이스 엔진 변경 1ALTER TABLE 테이블명 ENGINE=&#123;InnoDB | MyISAM&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"}]},{"title":"[MySQL] 인덱스(INDEX) 정리","slug":"mysql-4","date":"2022-11-17T06:57:35.000Z","updated":"2024-01-12T05:52:21.269Z","comments":true,"path":"2022/11/17/mysql-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-4/","excerpt":"","text":"인덱스(index)란? 인덱스(index)는 테이블에서 원하는 데이터를 쉽고 빠르게 찾기 위해 사용합니다. 이러한 인덱스는 자주 사용되는 필드 값으로 만들어진 원본 테이블의 사본이라고 생각할 수 있습니다. MySQL은 데이터를 검색할 때 첫 번째 필드부터 차례대로 테이블 전체를 검색합니다. 따라서 테이블이 크면 클수록 데이터를 탐색하는 시간도 많이 늘어나게 됩니다. 장점 MIN(), MAX() 등의 함수를 사용하는 쿼리에 대해 해당 필드에 인덱스가 있는 경우 빠르게 찾을 수 있습니다. ORDER BY와 GROUP BY를 빠르게 수행할 수 있습니다. 단점 ISAM, MyISAM 테이블 인덱스를 무겁게 만들면 인덱스 파일이 데이터 파일보다 더 빠르게 최대 크기에 도달됩니다. BDB(Berkeley DB) 테이블은 동일한 파일 내에 데이터와 인덱스 값을 함께 저장하며, 인덱스를 추가하게 되면 해당 테이블의 최대 파일 크기에 빠르게 도달하게 됩니다. InnoDB 테이블은 테이블 스페이스 안에 모든 공간을 공유하는 구조이며, 인덱스를 추가하면 테이블 스페이스 내의 공산을 빠르게 소모합니다. 검색속도는 향상되지만 삽입, 삭제, 갱신 속도는 느려집니다. 고려사항 인덱스를 위한 칼럼을 선택하는 가장 좋은 기준은 WHERE 절 안에 나오는 칼럼, 조인 절에 명명된 칼럼, ORDER BY, GROUP BY 절에 나오는 칼럼 등이 된다는 것입니다. SELECT 키워드 뒤에 나오는 출력 칼럼, 목록에만 나오는 칼럼은 좋은 선택이 아닙니다. 유일한 인덱스 사용: 유일한 값을 가지고 있는 칼럼들에 대해 효과가 좋고, 중복된 값들이 많은 칼럼들에 대해 효과가 나쁩니다. 짧은 값으로 인덱스를 만듭니다. 가장 왼쪽의 접두어를 활용합니다. 인덱스 생성 CREATE 문을 사용하여 인덱스를 생성할 수 있습니다. 1CREATE INDEX 인덱스명 ON 테이블명 (필드명1, 필드명2, ...) 이때 쉼표(,)를 사용하여 여러 필드를 가지는 인덱스를 생성할 수도 있습니다. 12-- 예CREATE INDEX NameIdx On Test (Name); 인덱스 추가 기본 인덱스에서 필드의 값은 같은 값이 여러 번 저장될 수 있으며, NULL 값을 가질 수도 있습니다. 1ALTER TABLE 테이블명 ADD INDEX 인덱스명 (필드명) 12-- 예ALTER TABLE Test ADD INDEX NameIdx (Name); 인덱스 삭제 ALTER 문으로 삭제 ALTER 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1ALTER TABLE 테이블명 DROP INDEX 인덱스명 12-- 예ALTER TABLE Test DROP INDEX NameIdx; DROP 문으로 삭제 DROP 문을 사용하면 해당 테이블에서 명시된 인덱스를 삭제할 수 있습니다. 1DROP INDEX 인덱스명 ON 테이블명 12-- 예DROP INDEX NameIdx ON Test; 인덱스 정보 보기 생성한 인덱스를 확인할 수 있습니다. 1SHOW INDEX FROM 테이블명 이때 반환되는 인덱스 정보의 필드 값은 다음과 같습니다. Table : 테이블의 이름을 표시함. Non_unique : 인덱스가 중복된 값을 저장할 수 있으면 1, 저장할 수 없으면 0을 표시함. Key_name : 인덱스의 이름을 표시하며, 인덱스가 해당 테이블의 기본 키라면 PRIMARY로 표시함. Seq_in_index : 인덱스에서의 해당 필드의 순서를 표시함. Column_name : 해당 필드의 이름을 표시함. Collation : 인덱스에서 해당 필드가 정렬되는 방법을 표시함. Cardinality : 인덱스에 저장된 유일한 값들의 수를 표시함. Sub_part : 인덱스 접두어를 표시함. Packed : 키가 압축되는(packed) 방법을 표시함. Null : 해당 필드가 NULL을 저장할 수 있으면 YES를 표시하고, 저장할 수 없으면 ''를 표시함. Index_type : 인덱스에 사용되는 메서드(method)를 표시함. Comment : 해당 필드를 설명하는 것이 아닌 인덱스에 관한 기타 정보를 표시함. Index_comment : 인덱스에 관한 모든 기타 정보를 표시함. 참고 http://www.tcpschool.com/mysql/mysql_index_create","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"}]},{"title":"[MySQL] 계정 관리","slug":"mysql-3","date":"2022-11-17T04:34:33.000Z","updated":"2024-01-12T05:50:39.361Z","comments":true,"path":"2022/11/17/mysql-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/17/mysql-3/","excerpt":"","text":"MySQL에서 계정 생성 및 권한 부여와 계정 정보 수정하는 방법에 대해 알아보겠습니다. 로그인 root의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MySQL [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MySQL [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 123456789MySQL [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+ 계정 생성 사용자 계정을 생성하는 방법입니다. CREATE 문으로 생성 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; INSERT 문으로 생성 1INSERT INTO user (host, user, password) VALUES ('localhost', '계정명', password('비밀번호')); **‘localhost’**를 **’%’**로 변경하면 원격에서 접속 가능합니다. 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. GRANT 문으로 권한 부여 1grant all privileges on *.* to 'USERNAME'@'%' identified by 'PASSWORD'; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; INSERT 문으로 권한 부여 12INSERT INTO db (Host, Db, USer, select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv)VALUES ('localhost', 'DB명', '계정명', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'); DB명에 ‘%’ 를 넣으면 모든 DB를 나타냅니다. 계정 정보 변경 계정의 비밀번호 변경 하는 방법입니다. UPDATE 문으로 변경 1UPDATE user SET password=password('비밀번호') where user='계정명'; SET 문으로 변경 1SET PASSWORD FOR '계정명'@'localhost' = PASSWORD('비밀번호'); 계정 삭제 DELETE 문으로 삭제 12DELETE FROM user WHERE user = '계정명';DELETE FROM db WHERE user = '계정명'; DROP 문으로 삭제 1DROP USER '계정명'@'localhost'; 권한 삭제 1REVOKE ALL ON *.* FROM '계정명'; 권한 확인 1234567MySQL [mysql]&gt; SHOW GRANTS FOR root;+--------------------------------------------------------------------------------------------------------------+| Grants for root@% |+--------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO `root`@`%` IDENTIFIED BY PASSWORD '*D08D94B3E46A8CCDA5F1682F57F8BE24F5FD1C79' |+--------------------------------------------------------------------------------------------------------------+1 row in set (0.002 sec) 설정 적용 위의 설정 명령어들을 실행 후 다음 명령어를 실행해야 적용이 됩니다. 1flush privileges;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[MySQL] 접속 에러 해결 방법","slug":"mysql-2","date":"2022-11-15T06:35:01.000Z","updated":"2024-01-12T05:49:56.746Z","comments":true,"path":"2022/11/15/mysql-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/mysql-2/","excerpt":"","text":"MySQL 서버에 접속 시도 시 다음과 같은 에러가 발생할 경우 해결 방법입니다. 123$ sudo mysql -u rootERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (111) MySQL 사용자로 접속 시도 시 /var/lib/mysql/ 경로에서 mysql.sock 파일을 찾을 수 없어서 나오는 오류입니다. 먼저 mysql.sock 파일을 찾습니다. 12$ find / -name \"mysql.sock\"/db/mysql_data/mysql.sock 해결 1 my.cnf 파일을 열고 다음 항목을 추가합니다. 12345$ vi /etc/my.cnf[client]socket=/db/mysql_data/mysql.sock[mysqld]socket=/db/mysql_data/mysql.sock 해결 2 심볼릭 링크를 사용합니다. 1$ ln -s /db/mysql_data/mysql.sock /var/lib/mysql/mysql.sock","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[Java] Iteration 예","slug":"java-dev-11","date":"2022-11-15T06:20:43.000Z","updated":"2023-03-14T02:25:28.271Z","comments":true,"path":"2022/11/15/java-dev-11/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-11/","excerpt":"","text":"Iteration 람다(Lambda)의 forEach 함수를 사용하는 예제입니다. 사용 예 1List&lt;String&gt; friends = Arrays.asList(\"Brian\", \"Nate\", \"Neal\", \"Raju\", \"Sara\", \"Scott\"); 기존 for 문 1234567for (int i = 0; i &lt; friends.size(); i++) &#123; System.out.println(friends.get(i));&#125;for (String name : friends) &#123; System.out.println(name);&#125; 1234567# 결과BrianNateNealRajuSaraScott forEach 사용 forEach 함수를 사용한 예제입니다. 첫 번째부터 마지막까지 점점 코드가 간략해지는 것을 볼 수 있습니다. 12345678910111213141516// 1)friends.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String name) &#123; System.out.println(name); &#125;&#125;);// 2)friends.forEach((final String name) -&gt; System.out.println(name));// 3)friends.forEach(name -&gt; System.out.println(name));// 4)friends.forEach(System.out::println); 결과는 모두 같습니다. 1234567# 결과BrianNateNealRajuSaraScott","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"}]},{"title":"[Java] 스트림(Stream) 사용 방법","slug":"java-dev-10","date":"2022-11-15T05:08:03.000Z","updated":"2024-01-12T05:48:48.859Z","comments":true,"path":"2022/11/15/java-dev-10/","link":"","permalink":"http://hgko1207.github.io/2022/11/15/java-dev-10/","excerpt":"","text":"스트림(stream) Java 8 버전부터 추가되었고 특정 요소 형식으로 이루어진 연속된 값에 대한 집합 인터페이스를 제공합니다. filter, map, reduce, sort, find 등의 함수들을 제공합니다. 사용 예 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String name; private String age;&#125; 123456List&lt;Person&gt; people = Arrays.asList( new Person(\"Eden\", 20), new Person(\"Ko\", 21), new Person(\"Lee\", 21), new Person(\"Kang\", 25)); Mutable 21살 이상의 사람을 찾는 코드입니다. filter를 사용하여 20살 초과인 사람만 찾고 List에 값을 넣는 예제입니다. 123456List&lt;Person&gt; olderThan20 = new ArrayList&lt;&gt;();people.stream() .filter(person -&gt; person.getAge() &gt; 20) .forEach(person -&gt; olderThan20.add(person));System.out.println(\"People older than 20: \" + olderThan20); 12# 결과People older than 20: [Person(name=Ko, age=21), Person(name=Lee, age=21), Person(name=Kang, age=25)] Collect collect를 사용하여 ArrayList 형식의 List를 반환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);System.out.println(\"People older than 20: \" + olderThan20); Collect To List Collectors.toList()를 사용하여 Collect 형식을 List로 변환합니다. 12345List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(Collectors.toList());System.out.println(\"People older than 20: \" + olderThan20); Group By(1) 나이를 Key로 해서 Map을 생성하는 예제입니다. 1234Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge));System.out.println(\"Grouped by age: \" + peopleByAge); 12# 결과Grouped by age: &#123;20=[Person(name=Eden, age=20)], 21=[Person(name=Ko, age=21), Person(name=Lee, age=21)], 25=[Person(name=Kang, age=25)]&#125; Group By(2) 값을 Person 객체가 아닌 이름으로 구성하는 예제입니다. 12345Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge, Collectors.mapping(Person::getName, Collectors.toList())));System.out.println(\"People grouped by age: \" + nameOfPeopleByAge); 12# 결과People grouped by age: &#123;20=[Eden], 21=[Ko, Lee], 25=[Kang]&#125; reducing 이름의 첫글자가 같은 사람 중 나이가 많은 사람만 찾는 예제입니다. 12345678// 나이 비교Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge);Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = people.stream() .collect(Collectors.groupingBy(person -&gt; person.getName().charAt(0), Collectors.reducing(BinaryOperator.maxBy(byAge))));System.out.println(\"Oldest person of each letter: \" + oldestPersonOfEachLetter); 12# 결과Oldest person of each letter: &#123;E=Optional[Person(name=Eden, age=20)], K=Optional[Person(name=Kang, age=25)], L=Optional[Person(name=Lee, age=21)]&#125; 예제들을 통해 스트림(Stream) 사용하는 방법을 알아봤습니다. 제공하는 함수들을 잘 사용하면 좋은 결과 값을 얻을 수 있습니다. 참고 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"}]},{"title":"Java 8 람다(Lambda) 적용 예","slug":"java-dev-9","date":"2022-11-09T01:17:47.000Z","updated":"2024-01-12T05:48:04.114Z","comments":true,"path":"2022/11/09/java-dev-9/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-9/","excerpt":"","text":"람다(Lamdba) 란 람다식, 또는 람다 함수라 부른다. 프로그래밍 언어에서 사용되는 개념으로, 익명 함수(Anonymous functions)를 지칭하는 용어이다. 나무위키 예제 Map에서 특정한 값을 가지는 entry에 대해서 삭제하는 코드입니다. 1234567891011121314Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"XXX\", \"111\");map.put(\"YYY\", \"222\");map.put(\"ZZZ\", \"333\");map.put(\"AAA\", \"444\");map.put(\"BBB\", \"555\");map.entrySet().stream() .filter(entry -&gt; entry.getValue().equals(\"111\")) .map(entry -&gt; entry.getKey()) .collect(Collectors.toList()) .forEach(map::remove);System.out.println(map); 실행 결과입니다. 1&#123;YYY=222, ZZZ=333, AAA=444, BBB=555&#125; 만약, collect 함수를 삭제할 경우 컴파일 에러는 없지만 다음과 같은 예외를 발생합니다. 12Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:20) 삭제하는 코드를 간략하게 구현할 수 있지만 위의 예제는 람다식의 다양한 함수를 보여주기 위해 사용하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"}]},{"title":"Java 8 스트림 적용시 성능 변화","slug":"java-dev-8","date":"2022-11-09T01:02:33.000Z","updated":"2024-01-12T05:47:45.390Z","comments":true,"path":"2022/11/09/java-dev-8/","link":"","permalink":"http://hgko1207.github.io/2022/11/09/java-dev-8/","excerpt":"","text":"for 문 1234567891011121314int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = 0;for (long i = startIndex; i &lt; endIndex; i++) &#123; sum += i;&#125;long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 11919ms Stream 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 33446ms parallel 사용 12345678910int startIndex = 0;long endIndex = 2000000000L;long startTime = System.currentTimeMillis();long sum = LongStream.range(startIndex, endIndex).parallel().sum();long processTime = System.currentTimeMillis() - startTime;System.out.println(\"sum : \" + sum);System.out.println(\"process time : \" + processTime + \"ms\"); 실행 결과입니다. 12sum : 1999999999000000000process time : 9407ms 결과 기존 for 문으로 구현한 방식을 자바의 stream 형태로 변경했을 때 성능은 저하되나 병렬 처리를 사용하면 성능 향상을 할 수 있습니다. for 문은 병렬 처리를 하려면 여러 스레드에 공유 자원에 대한 접근을 고려하여 구현해야 하기 때문에 쉽지 않은데 자바의 stream을 사용할 경우 병렬 처리로 변경하는 과장이 parallel() 메소드만 호출하면 가능합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"}]},{"title":"[PostgreSQL] 사용자, 그룹 관리","slug":"postgresql-6","date":"2022-11-08T05:03:30.000Z","updated":"2024-01-12T05:47:11.425Z","comments":true,"path":"2022/11/08/postgresql-6/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-6/","excerpt":"","text":"실행 파일을 통합 방법 사용자 생성 1$ createuser hgko --createdb --no-superuser --no-createrole 사용자 삭제 1$ dropuser hgko DB 접속을 통한 방법 GROUP 생성, 수정, 삭제 SYSID: 내부의 GROUP ID 구분용 숫자 코드이며, 설정하지 않으면 자동으로 100부터 1씩 증가합니다. (1~99는 핵심적인 그룹을 위함) 자동으로 설정되게 하면 됩니다. GROUP 생성 1234CREATE GROUP [그룹명];CREATE GROUP [그룹명] WITH USER user1, user2, user3;CREATE GROUP [그룹명] WITH SYSID 100 USER user1;CREATE GROUP [그룹명] WITH SYSID 100; GROUP 수정 123ALTER GROUP [그룹명] ADD USER user4, user5;ALTER GROUP [그룹명] DROP USER user3;ALTER GROUP [그룹명] RENAME TO [새로운 그룹명]; GROUP 삭제 1DROP GROUP [그룹명]; GROUP 조회 123456-- 1)postgres=# \\dgpostgres=# \\du-- 2)select * from pg_group; 사용자 생성, 수정, 삭제 사용자 생성 1CREATE USER test_user CREATEDB CREATEUSER IN GROUP test_group UNENCRYPTED PASSWORD '1234'; 사용자 생성에 사용되는 옵션들입니다. [ SUPERUSER | NOSUPERUSER ] [ CREATEDB | NOCREATEDB ] [ CREATEROLE | NOCREATEROLE ] [ CREATEUSER | NOCREATEUSER ] [ LOGIN | NOLOGIN ] [ ENCRYPTED | UNENCRYPTED ] PASSOWRD ‘password’ VALID UNTIL ‘timestamp’ IN ROLE role_name [,…] IN GROUP group_name [,…] ROLE role_name [,…] ADMIN role_name [,…] USER role_name [,…] SYSID uid 사용자 수정 1ALTER USER [사용자명] RENAME TO [새로운 사용자명]; 사용자 삭제 1DROP USER [사용자명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"}]},{"title":"[PostgreSQL] 사용자 인증","slug":"postgresql-5","date":"2022-11-08T04:39:56.000Z","updated":"2024-01-12T05:46:13.533Z","comments":true,"path":"2022/11/08/postgresql-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/08/postgresql-5/","excerpt":"","text":"사용자 인증 Postgresql을 처음 설치하게 되면 비밀번호를 묻지 않고 로그인을 할 수 있습니다. 인증과정을 포함하려면 pg_hba.conf 에서 설정해야 합니다. pg_hba.conf 파일은 initdb 에서 생성된 클러스터 폴더에 위치합니다. Authentication Method 필드의 값에 따라서 인증처리가 됩니다. trust: 패스워드 없이 접근 가능 (local 이외에는 비추천) reject: 거부 md5: 패스워드를 md5 로 암호화해서 전송 password: text 로 패스워드를 사용 (스니핑에 바로 보임) 사용 예제 TCP/IP로 127.0.0.1에 접근 시 모든 DB, 사용자로의 접근에 패스워드가 필요 없는 예제입니다. 1host all all 127.0.0.1/32 trust TCP/IP로 192.168.0.1에 접근 시 hgko 계정으로 모든 DB에 대한 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host all hgko 192.168.0.1/32 md5 TCP/IP로 192.168.0.1에 접근 시 hgko 계정으로 mydb, test DB에 대한 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host mydb,test hgko 192.168.0.1/32 md5 원격 어디서든지 remotegroup의 SYSID로 설정된 계정들로 remotedb의 접근이 허용되며, md5로 패스워드를 암호화해야 하는 예제입니다. 1host remotedb +remotegroup 0.0.0.0/0 md5 모든 호스트로 부터 접속 허용 postgresql.conf 파일을 수정합니다. 1listen_addresses = '*' pg_hba.conf 파일을 수정합니다. 12# TYPE DATABASE USER CIDR-ADDRESS METHODhost all all 0.0.0.0/0 md5 참고 https://www.postgresql.kr/docs/9.5/auth-methods.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"}]},{"title":"[Oracle] 사용자 및 테이블 조회","slug":"oracle-5","date":"2022-11-04T07:57:39.000Z","updated":"2024-01-12T05:44:56.309Z","comments":true,"path":"2022/11/04/oracle-5/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-5/","excerpt":"","text":"테이블 스페이스 남은 공간 조회 현재 접속한 사용자의 DEFAULT_TABLESPACE 남은 공간을 조회합니다. 123456789101112SELECT ts.tablespace_name, TO_CHAR(SUM(NVL(fs.bytes, 0)) / 1024 / 1024, '99,999,990.99') AS MB_FREEFROM user_free_space fs, user_tablespace ts, user_users usWHERE fs.tablespace_name(+) = ts.tablespace_name AND ts.tablespace_name(+) = us.default_tablespaceGROUP BY ts.tablespace_name; ‘user_’ prefix가 붙게 되면 로그인한 계정에 관련된 내용이 출력됩니다. 사용자 조회 123SQL&gt; SELECT * FROM user_users;SQL&gt; SELECT username, user_id, default_tablespace FROM dba_users;SQL&gt; SELECT * FROM all_users; 테이블 조회 1234SQL&gt; SELECT * FROM tab;SQL&gt; SELECT table_name, tablespace_name FROM user_tables;SQL&gt; SELECT owner, table_name, tablespace_nsme, cluster_name FROM dba_tables;SQL&gt; SELECT * FROM all_tables;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"}]},{"title":"[Oracle] 테이블 스페이스 사용 방법","slug":"oracle-3","date":"2022-11-04T06:44:12.000Z","updated":"2024-01-12T05:19:36.343Z","comments":true,"path":"2022/11/04/oracle-3/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-3/","excerpt":"","text":"테이블 스페이스(Table Space)란 테이블스페이스(Tablespace)는 데이터베이스 오브젝트 내 실제 데이터를 저장하는 공간이다. 이것은 데이터베이스의 물리적인 부분이며, 세그먼트로 관리되는 모든 DBMS에 대해 저장소(세그먼트)를 할당한다. 테이블스페이스는 단지 데이터베이스 저장소 위치를 지정할 뿐이며, 논리적 데이터베이스 구조나 스키마를 지정하지 않는다. 예를 들면, 동일한 스키마 내의 다른 오브젝트는 서로 다른 테이블스페이스에 놓일 수 있다. 마찬가지로, 하나의 테이블스페이스는 여러 세그먼트들을 서비스할 수 있다. 위키백과 테이블 스페이스 조회 12SQL&gt; SELECT * FROM dba_tablespaces;SQL&gt; SELECT * FROM dba_data_files; 테이블 스페이스 생성 오라클 DBMS는 테이블스페이스 생성을 위해 CREATE TABLESPACE 명령어를 사용합니다. 123SQL&gt; CREATE TABLESPACE [테이블스페이스명] DATAFILE '/db/oracle_data/ts.dbf' SIZE 200M autoextent on next 100M; DATAFILE: 파일 경로 SIZE: 초기 데이터 파일 크기 설정 autoextent on next: 초기 크기 공간을 모두 사용하는 경우 자동으로 파일의 크기가 커지는 기능 테이블 스페이스 삭제 123SQL&gt; DROP TABLESPACE [테이블스페이스명] INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS; INCLUDING CONTENTS: 테이블 스페이스의 모든 세그먼트 삭제 INCLUDING CONTENTS AND DATAFILES: 테이블 스페이스의 물리적파일까지 삭제 CASCADE CONSTRAINTS: 제약 조건 삭제 테이블 스페이스 이동 12SQL&gt; ALTER TABLE [테이블명] MOVE TABLESPACE [테이블스페이스명];SQL&gt; ALTER INDEX [인덱스명] REBUILD TABLESPACE [테이블스페이스명];","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"}]},{"title":"[Oracle] 계정 관리","slug":"oracle-4","date":"2022-11-04T06:44:12.000Z","updated":"2024-01-12T05:19:57.328Z","comments":true,"path":"2022/11/04/oracle-4/","link":"","permalink":"http://hgko1207.github.io/2022/11/04/oracle-4/","excerpt":"","text":"Oracle에서 계정 생성, 삭제 및 권한을 부여하는 방법입니다. 계정 생성 및 권한 부여 12345SQL&gt; CREATE USER [계정] IDENTIFIED BY [비밀번호] DEFAULT TABLESPACE [테이블스페이스명] QUOTA unlimited ON [테이블스페이스명] -- 테이블 스페이스의 내용을 모두 쓸 수 있다. TEMPORARY TABLESPACE [임시테이블스페이스명]; 123456-- 예SQL&gt; CREATE USER test IDENTIFIED BY 123!@#QWE DEFAULT TABLESPACE users QUOTA unlimited ON users TEMPORARY TABLESPACE temp; 계정 기본 테이블 스페이스 변경 12SQL&gt; ALTER USER [계정] DEFAULT TABLESPACE [테이블스페이스명];SQL&gt; ALTER USER [계정] TEMPORARY TABLESPACE [임시테이블스페이스명]; 계정 삭제 CASCADE를 명시하면 계정과 관련된 모든 데이터베이스 스키마가 삭제되고 모든 스키마 객체도 물리적으로 삭제됩니다. 1SQL&gt; DROP USER [계정] CASCADE; 계정별 Lock 상태 조회 12SQL&gt; SELECT username, account_status, to_char(lock_date, 'YYYY-MM-DD HH24:MI') lock_date FROM dba_users; Lock 해제 1SQL&gt; ALTER USER [계정] IDENTIFIED BY [비밀번호] ACCOUNT UNLOCK;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"}]},{"title":"[CentOS] Service 등록 및 실행 방법","slug":"linux-21","date":"2022-11-03T08:07:08.000Z","updated":"2024-01-12T05:18:34.961Z","comments":true,"path":"2022/11/03/linux-21/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/linux-21/","excerpt":"","text":"리눅스 환경에서 Tomcat을 구동하는 서비스를 등록하고 실행하는 방법에 대해 알아보겠습니다. Service 파일 생성 /etc/systemd/system/ 위치에 service 파일을 생성합니다. 1$ sudo vi /etc/systemd/system/tomcat-server.service 1234567891011121314[Unit]Description=TOMCAT SERVER ServiceAfter=network.target syslog.target[Service]Type=forkingUser=rootGroup=rootExecStart=/usr/local/tomcat-server/bin/startup.shExecStop=/usr/local/tomcat-server/bin/shutdown.sh[Install]WantedBy=multi-user.target Description: 서비스 설명 ExecStart: 실행할 서버 및 프로그램이 위치한 전체 경로 ExecStop: 종료할 서버 및 프로그램이 위치한 전체 경로 WantedBy: systemctl enable 명령어로 유닛을 등록할 때 등록에 필요한 유닛 지정 Service 등록 생성한 서비스를 등록합니다. 1$ sudo systemctl enable tomcat-server.service Service 비활성화 1$ sudo systemctl disable tomcat-server.service Service 시작 1$ sudo systemctl start tomcat-server.service Service 재시작 1$ sudo systemctl restart tomcat-server.service Service 종료 1$ sudo systemctl stop tomcat-server.service Service 실행 확인 1$ sudo systemctl status tomcat-server.service Service 목록 확인 1$ sudo systemctl list-unit-files","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"WGS84 - 도분초 변환","slug":"satellite-wgs84","date":"2022-11-03T07:58:10.000Z","updated":"2024-01-12T05:18:54.908Z","comments":true,"path":"2022/11/03/satellite-wgs84/","link":"","permalink":"http://hgko1207.github.io/2022/11/03/satellite-wgs84/","excerpt":"","text":"세계 지구 좌표 시스템(World Geodetic System, WGS) 1984년에 제정된 범 지구적 측위 시스템으로 지도학, 측지학, 항법에 많이 사용된다. GPS측량 시 WGS84 타원체를 사용한다. 통칭 및 약칭은 WGS 84 (aka WGS 1984, EPSG:4326, WGS84)라고 부르며, 2004년에 마지막으로 개정되었다. 이전에 쓰던 초안으로 WGS 72, WGS 66, 그리고 WGS 60이 있다. 위키백과 3735.0079는 위도로서 37도 35.0079분을 뜻합니다. 도(degree) 단위로 환산 시, 대략 37.5도가 됩니다. 12701.6446은 경도로서 127도 1.6446분을 뜻합니다. 도(degree) 단위로 환산 시, 대략 127.0도가 됩니다. DDMM.MMMM , DDDMM.MMMM 형식입니다. 일반적으로 WGS84 좌표라고 하면서 37.494961 , 127.030380 이런식으로 이용하면 그냥 37점494961도 라고 읽으면 됩니다. 도분초 변환 도를 도 분 초로 변환하는 자바 소스 코드입니다. 12345678910float lat = 37.494961;float lon = 127.030380;lat_do = (int)lat;lat_min = (lat - (int)lat) * 60;lat_sec = ((lat - (int)lat) * 60 - lat_min) * 60;lon_do = (int)lon;lon_min = (lon - (int)lon) * 60;lon_sec = ((lon - (int)lon) * 60 - lon_min) * 60;","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"}]},{"title":"Angular Development with TypeScript","slug":"book-2","date":"2022-11-02T03:40:45.000Z","updated":"2024-01-12T05:18:09.868Z","comments":true,"path":"2022/11/02/book-2/","link":"","permalink":"http://hgko1207.github.io/2022/11/02/book-2/","excerpt":"","text":"책 정보 책 소개 Angular는 Google이 주관하는 웹 애플리케이션 프레임워크다. 개발자들에게 큰 인기를 끌었던 이전 버전의 AngularJS는 이제 새로운 구조와 철학을 도입해서 완전히 새로운 프레임워크가 되어 돌아왔다. 새로운 버전의 Angular에서 제공하는 훌륭한 기능과 웹 컴포넌트 기반 철학을 깊이 있게 알아보고, 데이터를 뷰에 표시하는 방법, 사용자가 입력한 폼 데이터 처리, 서버와 통신, 테스트와 배포까지 애플리케이션의 모든 개발 단계를 다룬다. 더불어 현업에 바로 적용할 수 있도록 다양한 예제와 함께 설명하며, 중대형 규모의 애플리케이션 개발에 적합한 TypeScript와 ES6에 대해서도 알아본다. 이 책을 마지막까지 읽고 나면, 실무에 바로 도입할 수준이 될 것이다. 리뷰 최근 Angular로 프로젝트를 진행할 일이 생겨서 읽게 되었습니다. 예전에 나온 책이라 최근 Angular 버전과는 차이가 있지만 각 핵심 내용이 잘 정리가 되어 있고 번역서임에도 불구하고 번역이 굉장히 깔끔하였습니다. 분량이 많아 필요한 부분을 정독했는데 좋은 예제들로 쉽게 이해시켜 줘서 프로젝트를 진행하는데 도움이 많이 된 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[MariaDB] 계정 생성 및 권한 부여","slug":"mariadb-1","date":"2022-10-28T08:19:20.000Z","updated":"2024-01-12T05:17:00.520Z","comments":true,"path":"2022/10/28/mariadb-1/","link":"","permalink":"http://hgko1207.github.io/2022/10/28/mariadb-1/","excerpt":"","text":"MariaDB에서 계정을 생성하고 권한을 부여하는 방법입니다. 로그인 root의 패스워드를 입력하여 로그인합니다. 1$ sudo mysql -u root -p 계정 확인 123456789101112131415MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test || triplet_db |+--------------------+6 rows in set (0.435 sec)MariaDB [(none)]&gt; use mysql;Database changed 다음 명령어를 실행하여 사용자 계정들을 확인합니다. 12345678910MariaDB [mysql]&gt; SELECT user, host FROM user;+-------------+-----------+| User | Host |+-------------+-----------+| | localhost || mariadb.sys | localhost || mysql | localhost || root | localhost |+-------------+-----------+4 rows in set (0.002 sec) 계정 생성 로컬에서만 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'localhost' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'localhost' IDENTIFIED BY 'test!@'; 로컬 및 원격에서 접속이 가능하도록 계정을 생성하는 방법입니다. 1CREATE USER '계정명'@'%' IDENTIFIED BY '비밀번호'; 12-- 예)MariaDB [mysql]&gt; CREATE USER 'test'@'%' IDENTIFIED BY 'test!@'; 권한 부여 생성된 계정에 대해 모든 권한을 부여하도록 설정합니다. 1grant all privileges on *.* to '계정명'@'%' identified by '비밀번호'; 1234-- 예MariaDB [mysql]&gt; grant all privileges on *.* to 'test'@'%' identified by 'test!@';-- 변경된 권한 적용MariaDB [mysql]&gt; flush privileges; 해당 데이터베이스에 대해서만 권한을 부여하도록 설정합니다. 1grant all privileges on DB명.* to '계정명'@'%' identified by '비밀번호'; 123-- 예)MariaDB [mysql]&gt; grant all privileges on test_db.* to 'test'@'%' identified by 'test!@';MariaDB [mysql]&gt; flush privileges; 확인 계정 생성이 완료되면 생성된 계정으로 로그인합니다. 1$ sudo mysql -u test -p","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"}]},{"title":"[CentOS] MariaDB 설치","slug":"linux-20","date":"2022-10-26T04:32:16.000Z","updated":"2024-01-12T05:14:16.404Z","comments":true,"path":"2022/10/26/linux-20/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/linux-20/","excerpt":"","text":"리눅스 환경에서 MariaDB 설치 방법에 대해 알아보겠습니다. MariaDB 란 MariaDB는 오픈 소스의 관계형 데이터베이스 관리 시스템이다. MySQL과 동일한 소스 코드를 기반으로 하며, GPL v2 라이선스를 따른다. 오라클 소유의 현재 불확실한 MySQL의 라이선스 상태에 반발하여 만들어졌으며, 배포자는 몬티 프로그램 AB와 저작권을 공유해야 한다. 위키백과 MariaDB 저장소 추가 yum 저장소에는 MariaDB 라이브러리가 없기 때문에 저장소를 추가합니다. MariaDB Server 다운로드 사이트에 연결한 후에 MariaDB Repositories 탭을 클릭합니다. 사용하는 배포판을 선택합니다. 설치할 버전을 선택합니다. 미러 사이트를 선택합니다. 4번에 있는 내용을 아래 명령어를 실행한 후에 복사합니다. 1[root@localhost ~]$ vi /etc/yum.repos.d/MariaDB.repo 1234567891011# MariaDB 10.4 CentOS repository list - created 2023-06-02 08:54 UTC# https://mariadb.org/download/[mariadb]name = MariaDB# rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details.# baseurl = https://rpm.mariadb.org/10.4/centos/$releasever/$basearchbaseurl = https://tw1.mirror.blendbyte.net/mariadb/yum/10.4/centos/$releasever/$basearchmodule_hotfixes = 1# gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDBgpgkey = https://tw1.mirror.blendbyte.net/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck = 1 설치 저장소를 추가하였다면 설치를 합니다. 1[root@localhost ~]$ sudo yum install MariaDB-server MariaDB-client 설치 확인 잘 설치가 되었는지 확인합니다. 12345[root@localhost ~]$ rpm -qa | grep MariaDBMariaDB-common-10.4.26-1.el7.centos.x86_64MariaDB-client-10.4.26-1.el7.centos.x86_64MariaDB-server-10.4.26-1.el7.centos.x86_64MariaDB-compat-10.4.26-1.el7.centos.x86_64 서비스 시작 부팅 시 자동시작되도록 서비스를 등록하고 시작합니다. 12[root@localhost ~]$ systemctl enable mariadb[root@localhost ~]$ systemctl start mariadb 패스워드 변경 패스워드를 변경합니다. 1[root@localhost ~]$ /usr/bin/mysqladmin -u root password '패스워드' 접속 확인 다음 명령어를 실행한 후 패스워드를 입력하면 접속이 됩니다. 1234567891011[root@localhost ~]$ mysql -u root -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.4.26-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; 모든 IP 허용 외부에서 접속을 하기 위해 모든 IP가 허용가능하도록 설정합니다. 12MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '패스워드';MariaDB [(none)]&gt; FLUSH PRIVILEGES; 방화벽 포트 개방 12[root@localhost ~]$ netstat -anp | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 12596/mysqld Mariadb 포트는 3306입니다. 외부에서 접속하기 위해 3306 포트를 개방합니다. 123456# 포트 개방[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3306/tcp# 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload# 개방된 포트 목록 확인[root@localhost ~]$ firewall-cmd --list-ports 참고 https://zetawiki.com/wiki/CentOS7_MariaDB_%EC%84%A4%EC%B9%98","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"}]},{"title":"NVM 설치 및 사용 방법","slug":"nodejs-4","date":"2022-10-26T01:44:59.000Z","updated":"2024-01-12T05:14:48.256Z","comments":true,"path":"2022/10/26/nodejs-4/","link":"","permalink":"http://hgko1207.github.io/2022/10/26/nodejs-4/","excerpt":"","text":"Windows 환경에서 NVM를 설치하고 Node 버전을 관리하는 방법에 대해 알아보겠습니다. NVM(Node Version Manager) NVM 은 Node.js의 버전을 관리하는 도구입니다. 여러 개의 Node.js 버전을 설치할 수 있고 설치된 모든 버전을 확인할 수 있습니다. 그리고 필요에 따라 버전 변경도 할 수 있습니다. 설치 NVM Github Repository 사이트에 접속합니다. nvm-setup.zip 또는 nvm-setup.exe 을 선택하여 다운로드하고 설치를 합니다. 사용 NPM 버전 조회 현재 최신의 사용가능한 Node.js 버전이 조회됩니다. 1$ nvm list available NPM 설치 원하는 버전을 입력하여 설치합니다. 1$ nvm install [node version] 예시입니다. 12$ nvm install 19.0.0$ nvm install 18.11.0 설치 확인 설치되어 있는 Node.js 버전들이 조회됩니다. 1$ nvm list 버전 변경 설치된 Node.js 버전들 중에서 사용하려는 버전으로 변경할 수 있습니다. 1$ nvm use [node version] 예시입니다. 1$ nvm use 18.11.0 Node.js 버전 확인 Node.js 버전이 설치 또는 변경되었는지 확인합니다. 1$ node -v 여기까지 NVM 설치 및 사용 포스팅을 마치겠습니다. 참고 https://github.com/nvm-sh/nvm","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"}]},{"title":"[JavaScript] 주민등록번호 유효성 검사","slug":"js-dev-5","date":"2022-10-23T08:26:18.000Z","updated":"2024-01-12T05:13:56.237Z","comments":true,"path":"2022/10/23/js-dev-5/","link":"","permalink":"http://hgko1207.github.io/2022/10/23/js-dev-5/","excerpt":"","text":"JavaScript에서 주민등록번호 유효성 검사 방법에 대해 알아보겠습니다. 주민등록번호란 주민등록번호는 “주민의 거주관계를 파악하고 상시로 인구의 동태를 명확히 하여 행정사무의 적정하고 간이 한 처리를 도모함”(1962년 주민등록법) 등을 목적으로 만든 일련번호로서, 개개인의 신원을 명확하게 구분하는 역할을 한다. 나무위키 내국인과 외국인 주민등록번호 유효성을 검사하는 소스코드입니다. 내국인 주민등록번호와 달리 외국인 등록번호는 뒤 7자리 숫자의 첫 숫자가 2000년 이전 출생 외국인에게는 남자는 5, 여자는 6, 2000년 이후 출생 외국인에게는 남자는 7, 여자는 8로 부여하고 있습니다. 내국인 주민등록번호 숫자는 1, 2, 3, 4 로 시작됩니다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;label class=\"font-weight-bold\"&gt;주민등록번호 입력 :&lt;/label&gt; &lt;div class=\"d-flex align-items-center\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"jumin1\" required /&gt; &lt;span class=\"font-weight-bold mx-2\"&gt;-&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" id=\"jumin2\" required /&gt; &lt;/div&gt; &lt;button type=\"button\" onclick=\"validate()\"&gt;검증&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const CommonUtil = (function () &#123; // 내국인/외국인 주민등록번호 유효성 검사 const validRegistrationNumber = function (rn, type) &#123; rn = rn.split('-').join(''); if (rn.length !== 13) return false; let checkSum = 0; for (let i = 0; i &lt; 12; i++) &#123; checkSum += (rn.substr(i, 1) &gt;&gt; 0) * ((i % 8) + 2); &#125; const korMatch = (11 - (checkSum % 11)) % 10 == rn.substr(12, 1); const frnMatch = (13 - (checkSum % 11)) % 10 == rn.substr(12, 1); if (type === 'local') return korMatch; else if (type === 'foreigner') return frnMatch; else return korMatch || frnMatch; &#125;; return &#123; // 주민등록번호가 내국민인지 외국인인지 분류 // 뒤 7자리의 첫번째 숫자가 1,2,3,4 일경우 내국인 / 5,6,7,8 일경우 외국인 validateJumin: function (ssn1, ssn2) &#123; const ssnType = ssn2.substr(0, 1); const rn = ssn1 + ssn2; if (ssnType == '5' || ssnType == '6' || ssnType == '7' || ssnType == '8') &#123; const type = 'foreigner'; &#125; else &#123; const type = 'local'; &#125; return validRegistrationNumber(rn, type); &#125;, &#125;;&#125;)();document.addEventListener('DOMContentLoaded', function () &#123; // 주민등록번호 검증 확인 function validate() &#123; const jumin1 = document.getElementById('jumin1'); const jumin2 = document.getElementById('jumin2'); const ssn1 = jumin1.value; const ssn2 = jumin2.value; return CommonUtil.validateJumin(ssn1, ssn2); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"}]},{"title":"[Python] OpenCV Sharpening","slug":"python-3","date":"2022-10-22T14:41:19.000Z","updated":"2024-01-12T05:13:33.036Z","comments":true,"path":"2022/10/22/python-3/","link":"","permalink":"http://hgko1207.github.io/2022/10/22/python-3/","excerpt":"","text":"Python에서 OpenCV를 사용하여 Sharpening 하는 방법에 대해 알아보겠습니다. Sharpening Sharpening 기법은 Bluring과 반대되는 개념으로, 초점이 잘 맞은 사진처럼 사물의 윤곽이 뚜렷하고 선명한 느낌이 나도록 하는 것이다. 설치 Python 에서 OpenCV 를 사용하기 위해 패키지를 설치합니다. 1$ pip install opencv-python 예제 원본 이미지에 여러가지의 커널을 적용하여 선명하게 표현하였습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import cv2import numpy as npimport matplotlib.pyplot as pltimage = cv2.imread('images/lenna.png', cv2.IMREAD_GRAYSCALE)# 커널 생성(대상이 있는 픽셀을 강조)kernel_sharpen_1 = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])kernel_sharpen_2 = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])kernel_sharpen_3 = np.array([[1, 1, 1], [1, -7, 1], [1, 1, 1]])kernel_sharpen_4 = np.array([[-1, -1, -1, -1, -1], [-1, 2, 2, 2, -1], [-1, 2, 8, 2, -1], [-1, 2, 2, 2, -1], [-1, -1, -1, -1, -1]]) / 8.0smoothed = cv2.GaussianBlur(image, (5, 5), 1)unsharped = cv2.addWeighted(image, 1.5, smoothed, -0.5, 0)# 커널 적용image_sharp1 = cv2.filter2D(image, 0, kernel_sharpen_1)image_sharp2 = cv2.filter2D(image, 0, kernel_sharpen_2)image_sharp3 = cv2.filter2D(image, 0, kernel_sharpen_3)image_sharp4 = cv2.filter2D(image, 0, kernel_sharpen_4)fig, ax = plt.subplots(2, 3, figsize=(10, 5))ax[0][0].imshow(image, cmap='gray')ax[0][0].set_title('Original Image')ax[0][1].imshow(unsharped, cmap='gray')ax[0][1].set_title('addWeighted')ax[0][2].imshow(image_sharp1, cmap='gray')ax[0][2].set_title('image_sharp1')ax[1][0].imshow(image_sharp2, cmap='gray')ax[1][0].set_title('image_sharp2')ax[1][1].imshow(image_sharp3, cmap='gray')ax[1][1].set_title('image_sharp3')ax[1][2].imshow(image_sharp4, cmap='gray')ax[1][2].set_title('image_sharp4')plt.show(); 결과 필터에 따라 Sharpening 적용된 이미지를 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"}]},{"title":"[Angular] Cytoscape 사용 방법","slug":"angular-8","date":"2022-10-12T06:53:50.000Z","updated":"2024-01-12T05:12:39.088Z","comments":true,"path":"2022/10/12/angular-8/","link":"","permalink":"http://hgko1207.github.io/2022/10/12/angular-8/","excerpt":"","text":"Cytoscape 소개 Cytoscape은 점 (node)과 선 (edge)으로 이루어진 네트워크의 가시화, 통합, 분석을 가능하게 하는 프리 오픈소스 소프트웨어입니다. 자바로 구현되어 있어 윈도우, 맥, 리눅스등에서 자유롭게 구동합니다. Cytoscape 라이브러리를 사용하여 노드 간의 절차를 시각화하는 그래프를 구현하는 방법에 대해 알아보겠습니다. 설치 cytoscape 패키지를 설치합니다. 1$ npm install --save cytoscape cytoscape-klay TypeScript 사용 시 추가로 설치합니다. 1$ npm install --save-dev @types/cytoscape 설정 angular.json 파일에서 다음의 내용을 추가합니다. 1\"scripts\": [\"./node_modules/cytoscape/dist/cytoscape.min.js\"], 예제 app.component.html 1&lt;div id=\"cy\"&gt;&lt;/div&gt; 그래프의 스타일을 정의합니다. app.component.scss 12345#cy &#123; height: 300px; width: 100%; display: block;&#125; cytoscape 패키지를 import 합니다. 기본적으로 container, elements, style 및 layout 옵션을 설정합니다. 노드 간의 연결을 시각화 하기 위해 layout 에 klay를 정의합니다. app.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import &#123; Component, OnInit &#125; from '@angular/core';import cytoscape from 'cytoscape';import klay from 'cytoscape-klay';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; /** * constructor */ constructor() &#123;&#125; /** * ngOnInit */ ngOnInit(): void &#123; cytoscape.use(klay); const cy = cytoscape(&#123; container: document.getElementById('cy'), // container to render in elements: [ // node &#123; data: &#123; id: 'step1', name: 'step1' &#125; &#125;, &#123; data: &#123; id: 'step2', name: 'step2' &#125; &#125;, &#123; data: &#123; id: 'step3', name: 'step3' &#125; &#125;, &#123; data: &#123; id: 'step4', name: 'step4' &#125; &#125;, // edge &#123; data: &#123; id: '1', source: 'step1', target: 'step2' &#125; &#125;, &#123; data: &#123; id: '2', source: 'step1', target: 'step3' &#125; &#125;, &#123; data: &#123; id: '3', source: 'step2', target: 'step4' &#125; &#125;, &#123; data: &#123; id: '4', source: 'step3', target: 'step4' &#125; &#125;, ], style: [ // the stylesheet for the graph &#123; selector: 'node', style: &#123; content: 'data(name)', shape: 'rectangle', 'text-wrap': 'wrap', 'text-halign': 'center', 'text-valign': 'center', 'background-color': '#6FB1FC', width: '40px', height: '40px', color: 'black', 'font-size': '10px', &#125;, &#125;, &#123; selector: 'edge', style: &#123; 'curve-style': 'bezier', 'line-color': '#000000', 'target-arrow-shape': 'triangle', 'target-arrow-fill': 'filled', 'target-arrow-color': '#000000', width: '1px', 'line-style': 'solid', opacity: 0.666, &#125;, &#125;, ], layout: &#123; name: 'klay', &#125;, &#125;); const options = &#123; name: 'klay', nodeDimensionsIncludeLabels: true, klay: &#123; borderSpacing: 100, fixedAlignment: 'BALANCED', edgeRouting: 'POLYLINE', edgeSpacingFactor: 10, inLayerSpacingFactor: 2.0, layoutHierarchy: true, linearSegmentsDeflectionDampening: 3.0, spacing: 30, mergeEdges: false, &#125;, &#125;; cy.layout(options).run(); &#125;&#125; 아래 참고 사이트에서 예제 및 옵션 설정에 대해 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://js.cytoscape.org/ https://github.com/cytoscape/cytoscape.js","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"}]},{"title":"[Angular] Markdown 사용 방법","slug":"angular-7","date":"2022-09-29T04:30:09.000Z","updated":"2024-01-12T05:12:00.606Z","comments":true,"path":"2022/09/29/angular-7/","link":"","permalink":"http://hgko1207.github.io/2022/09/29/angular-7/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular에서 ngx-markdown 패키지를 사용하여 Markdown 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown 패키지를 설치합니다. 1$ npm install ngx-markdown --save 설정 angular.json 파일에서 다음의 내용을 추가합니다. 123456789101112131415&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"scripts\": [ \"node_modules/marked/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; 예제 MarkdownModule을 import 합니다. 1234567891011121314// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; MarkdownModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, MarkdownModule.forRoot()], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; markdown 태그를 사용하여 작성합니다. 1234567&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;markdown [data]=\"markdownText\"&gt;&lt;/markdown&gt; &lt;/div&gt;&lt;/div&gt; markdownText에 임시로 데이터를 입력합니다. 123456789101112131415161718// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; constructor() &#123; this.markdownText = `# Test`; &#125; ngOnInit(): void &#123;&#125;&#125; 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://www.npmjs.com/package/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"}]},{"title":"[Angular] Markdown Editor 사용 방법","slug":"angular-6","date":"2022-09-28T01:07:39.000Z","updated":"2024-01-12T05:08:34.220Z","comments":true,"path":"2022/09/28/angular-6/","link":"","permalink":"http://hgko1207.github.io/2022/09/28/angular-6/","excerpt":"","text":"Markdown 이란 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. 위키백과 Angular에서 ngx-markdown-editor 패키지를 사용하여 Markdown Editor 기능을 구현하는 방법에 대해 알아보겠습니다. 설치 ngx-markdown-editor와 ace-builds, bootstrap, font-awesome 패키지도 필수로 설치합니다. 12$ npm install ngx-markdown-editor --save$ npm install ace-builds bootstrap font-awesome --save 설정 angular.json 파일에서 다음 내용을 추가합니다. 12345678910111213141516171819202122232425262728&#123; ... \"architect\": &#123; \"build\": &#123; \"options\": &#123; ... \"assets\": [ &#123; \"glob\": \"**/*\", \"input\": \"node_modules/ace-builds/src-min\", \"output\": \"./assets/ace-builds/\" &#125; ], \"styles\": [ \"node_modules/bootstrap/dist/css/bootstrap.min.css\", \"node_modules/font-awesome/css/font-awesome.min.css\", \"node_modules/ngx-markdown-editor/assets/highlight.js/agate.min.css\" ], \"scripts\": [ \"node_modules/ngx-markdown-editor/assets/highlight.js/highlight.min.js\", \"node_modules/ngx-markdown-editor/assets/marked.min.js\" ] ... &#125; &#125; &#125; ...&#125; index.html 파일에서 아래 내용을 추가합니다. 123456&lt;html&gt; &lt;head&gt; &lt;script src=\"/assets/ace-builds/ace.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 예제 LMarkdownEditorModule을 import 합니다. 12345678910111213141516// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; AppRoutingModule &#125; from 'app/app-routing.module';import &#123; LMarkdownEditorModule &#125; from 'ngx-markdown-editor';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, FormsModule, AppRoutingModule, LMarkdownEditorModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; md-editor 태그를 사용하여 작성합니다. 123456789101112131415161718&lt;!-- app.component.html --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;md-editor id=\"description\" name=\"description\" [upload]=\"doUpload\" [(ngModel)]=\"markdownText\" [mode]=\"mode\" [options]=\"options\" required height=\"400px\" &gt;&lt;/md-editor&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Option, Text, Mode, Upload 설정을 합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; UploadResult, MdEditorOption &#125; from 'ngx-markdown-editor';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; public markdownText: string; public mode: string = 'editor'; public options: MdEditorOption; constructor() &#123;&#125; /** * 이미지 파일 Upload * @param files * @returns */ doUpload(files: Array&lt;File&gt;): Promise&lt;Array&lt;UploadResult&gt;&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result: Array&lt;UploadResult&gt; = []; for (let file of files) &#123; result.push(&#123; name: file.name, url: `https://avatars3.githubusercontent.com/$&#123;file.name&#125;`, isImg: file.type.indexOf('image') !== -1, &#125;); &#125; resolve(result); &#125;, 3000); &#125;); &#125; ngOnInit(): void &#123; // markdown editor option 설정 this.options = &#123; showPreviewPanel: false, enablePreviewContentClick: false, resizable: true, customRender: &#123; image: function (href: string, title: string, text: string) &#123; let out = `&lt;img style=\"max-width: 100%; border: 20px solid red;\" src=\"$&#123;href&#125;\" alt=\"$&#123;text&#125;\"`; if (title) &#123; out += ` title=\"$&#123;title&#125;\"`; &#125; out += (&lt;any&gt;this.options).xhtml ? '/&gt;' : '&gt;'; return out; &#125;, &#125;, &#125;; &#125;&#125; Markdown Editor 구현된 이미지입니다. 아래 참고 사이트에서 자세하게 설명이 되어있습니다. 참고하여 구현하시면 됩니다. 참고 https://openbase.com/js/ngx-markdown-editor https://openbase.com/js/ngx-markdown","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"}]},{"title":"[Angular] Can't resolve crypto 오류 해결 방법","slug":"angular-5","date":"2022-09-21T06:42:48.000Z","updated":"2024-01-12T05:07:54.201Z","comments":true,"path":"2022/09/21/angular-5/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-5/","excerpt":"","text":"Angular에서 Web3를 사용할 경우 다음과 같은 오류가 발생할 경우가 있습니다. 1234Module not found: Error: Can't resolve 'crypto' in ...Module not found: Error: Can't resolve 'stream' in ...Module not found: Error: Can't resolve 'fs' in ...Module not found: Error: Can't resolve 'os' in ... 12345678[NG_SERVE] BREAKING CHANGE: webpack &lt; 5 used to include polyfills for node.js core modules by default.[NG_SERVE] This is no longer the case. Verify if you need this module and configure a polyfill for it.[NG_SERVE][NG_SERVE] If you want to include a polyfill, you need to:[NG_SERVE] - add a fallback 'resolve.fallback: &#123; \"stream\": require.resolve(\"stream-browserify\") &#125;'[NG_SERVE] - install 'stream-browserify'[NG_SERVE] If you don't want to include a polyfill, you can use an empty module like this:[NG_SERVE] resolve.fallback: &#123; \"stream\": false &#125; polyfill.ts 파일에 내용을 추가하는 방법도 있지만 Webpack을 구성하여 해결하였습니다. 해결 방법 설치 사용자 지정 웹팩 구성을 하여 빌드 및 실행할 수 있도록 custom-webpack 패키지를 설치합니다. 1$ npm install --save-dev @angular-builders/custom-webpack 오류가 발생하는 모듈의 패키지를 설치합니다. 1$ npm install --save-dev stream-http https-browserify 생성 custom-webpack.config.js 파일을 생성하고 다음 내용을 추가합니다. 123456789101112131415const webpack = require('webpack');module.exports = &#123; resolve: &#123; fallback: &#123; http: require.resolve('stream-http'), https: require.resolve('https-browserify'), fs: false, crypto: false, os: false, stream: false, assert: false, &#125;, &#125;,&#125;; 적용 angular.json 파일의 내용을 수정합니다. builder 와 options 부분을 custom-webpack으로 수정합니다. 1234567891011121314151617181920\"architect\": &#123; ... \"build\": &#123; \"builder\": \"@angular-builders/custom-webpack:browser\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"customWebpackConfig\": &#123; \"path\": \"./custom-webpack.config.js\", // 생성한 파일 적용 \"replaceDuplicatePlugins\": true &#125;, ... &#125;, ... &#125;, \"serve\": &#123; \"builder\": \"@angular-builders/custom-webpack:dev-server\", // @angular-builders/custom-webpack 으로 변경 \"options\": &#123; \"browserTarget\": \"test-project:build\" &#125; &#125;&#125; Angular를 재실행하면 오류들이 없어진 것을 확인할 수 있습니다. 참고 https://www.npmjs.com/package/@angular-builders/custom-webpack","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Angular] process is not defined 해결 방법","slug":"angular-4","date":"2022-09-21T00:34:20.000Z","updated":"2023-07-20T14:30:35.135Z","comments":true,"path":"2022/09/21/angular-4/","link":"","permalink":"http://hgko1207.github.io/2022/09/21/angular-4/","excerpt":"","text":"Angular 14 버전을 사용하면서 ERROR ReferenceError: process is not defined 오류가 발생할 경우 해결 방법입니다. 설치 process 패키지를 설치합니다. 1$ npm install --save-dev process 내용 추가 src/polyfill.ts 파일을 열고 다음 내용을 추가합니다. 123(window as any).global = window;global.Buffer = global.Buffer || require('buffer').Buffer;global.process = require('process');","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"node-gyp 설치 오류 해결 방법","slug":"nodejs-3","date":"2022-09-16T00:30:27.000Z","updated":"2024-01-12T05:07:04.698Z","comments":true,"path":"2022/09/16/nodejs-3/","link":"","permalink":"http://hgko1207.github.io/2022/09/16/nodejs-3/","excerpt":"","text":"node-gyp 설치 과정 중 오류가 발생하였을 때 해결 방법입니다. npm 버전 확인 npm 버전을 확인하고 버전에 맞게 수행합니다. 1$ npm --version Windows PowerShell 또는 명령 프롬프트(cmd.exe)를 &quot;관리자 권한으로 실행&quot;으로 실행합니다. 먼저 node 가 설치된 디렉토리로 이동합니다. 1$ cd \"C:\\Program Files\\nodejs\" npm 버전이 7 미만인 경우 12$ cd node_modules\\npm\\node_modules\\npm-lifecycle$ npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 12$ cd node_modules\\npm\\node_modules\\@npmcli\\run-script$ npm install node-gyp@latest Linux, MacOS 다음 명령어를 실행하면 됩니다. 권한 오류가 나서 실패하면 앞에 sudo 명령어를 추가합니다. npm 버전이 7 미만인 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/npm-lifecycle -g -- npm install node-gyp@latest npm 버전이 7 또는 8 일 경우 다음을 수행합니다. 1$ npm explore npm/node_modules/@npmcli/run-script -g -- npm_config_global=false npm install node-gyp@latest 참고 https://github.com/nodejs/node-gyp/blob/main/docs/Updating-npm-bundled-node-gyp.md","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"node-gyp","slug":"node-gyp","permalink":"http://hgko1207.github.io/tags/node-gyp/"}]},{"title":"npm install 시 gyp ERR! 해결 방법","slug":"nodejs-2","date":"2022-09-05T04:39:40.000Z","updated":"2024-01-12T01:40:07.197Z","comments":true,"path":"2022/09/05/nodejs-2/","link":"","permalink":"http://hgko1207.github.io/2022/09/05/nodejs-2/","excerpt":"","text":"npm install 시 **gyp ERR!**로 시작하는 설치 에러가 발생할 경우 해결 방법을 정리하였습니다. 첫 번째 방법 Microsoft 의 windows-build-tools 설치합니다. 관리자 권한으로 PowerShell 또는 터미널을 열고 다음 명령어를 실행하여 설치합니다. npm 버전이 8 이상 설치가 되어 있어야 합니다. 1$ npm install --global windows-build-tools 두 번째 방법 1) Visual Studio Download https://visualstudio.microsoft.com/ko/downloads/ 사이트를 접속해서 Visual Studio를 다운로드합니다. 2) C++ 설치 Visual Studio Installer에서 Desktop development with C++ 선택 후 설치 3) msvs_version, msbuild_path 설정 12$ npm config set msvs_version 2022$ npm config set msbuild_path \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\Msbuild\\Current\\Bin\\MSBuild.exe\" msvs_version, msbuild_path를 설정할 때 다른 버전이 설치되어 있으면 변경합니다. 설치 1$ npm install -g node-gyp 프로젝트에서 설치합니다. 1$ npm install 참고 https://exerror.com/errerr-find-vsfind-vs-msvs_version-not-set-from-command-line-or-npm-config-vcinstalldir-not-set/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"}]},{"title":"[React] Animations 사용 방법","slug":"react-11","date":"2022-08-28T13:50:48.000Z","updated":"2024-01-12T01:37:52.737Z","comments":true,"path":"2022/08/28/react-11/","link":"","permalink":"http://hgko1207.github.io/2022/08/28/react-11/","excerpt":"","text":"Framer Motion을 사용하여 애니메이션을 간편하고 쉽게 만드는 방법을 알아보겠습니다. Framer Motion Framer는 디자이너들을 위해 프로토타입 등을 만들어 주는 회사입니다. Framer Motion은 React 용 production-ready 모션 라이브러리입니다. 설치 1$ npm install framer-motion 사용 Animation Framer Motion의 애니메이션은 모션 컴포넌트의 유연한 animate 속성을 통해 제어됩니다. 간단한 애니메이션의 경우 animate props에서 직접 값을 설정할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 360 &#125;&#125; transition=&#123;&#123; duration: 2 &#125;&#125; initial initial: boolean | Target | VariantLabels (애니메이션의 초기값 지정) 속성, 변형 레이블 또는 시작할 변형 레이블의 배열입니다. animate의 값으로 초기화하려면 false로 설정합니다(마운트 애니메이션 비활성화).https://www.framer.com/docs/component/###initial Transition Transition은 값이 한 상태에서 다른 상태로 움직이는 방식을 정의합니다. 또한 Tween, Spring 또는 Inertia를 사용할 애니메이션 유형을 정의하는 소품을 허용할 수 있습니다. 1motion.div animate=&#123;&#123; rotate: 180 &#125;&#125; transition=&#123;&#123; type: 'spring' &#125;&#125; 예제 initial, animate, transition을 사용하여 사각형이 회전하고 튕기는 애니메이션을 구현하였습니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';import &#123; motion &#125; from 'framer-motion';const Wrapper = styled.div` display: flex; max-width: 680px; width: 100vw; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Box = styled(motion.div)` width: 200px; height: 200px; background-color: white; border-radius: 15px; box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.06);`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box transition=&#123;&#123; type: 'spring', delay: 0.5 &#125;&#125; initial=&#123;&#123; scale: 0 &#125;&#125; animate=&#123;&#123; scale: 1, rotate: 360 &#125;&#125; /&gt; &lt;/Wrapper&gt; );&#125;export default App; 참고 https://www.framer.com/motion https://www.framer.com/docs/animation https://www.framer.com/docs/transition","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"Framer Motion","slug":"Framer-Motion","permalink":"http://hgko1207.github.io/tags/Framer-Motion/"}]},{"title":"[CentOS] alias 등록 방법","slug":"linux-19","date":"2022-08-23T04:40:33.000Z","updated":"2024-01-12T01:36:36.643Z","comments":true,"path":"2022/08/23/linux-19/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-19/","excerpt":"","text":"alias 란 alias는 별칭이라는 뜻으로 리눅스에서 alias는 사용자가 명령어를 다른 이름으로 바꿔서 사용할 수 있는 쉘 내부 명령어를 말합니다. 이 alias를 통해서 일일이 입력하기 번거로운. 길이가 긴 명령어를 간단한 이름으로 바꿔서 등록하여 업무 효율을 높일 수 있습니다. alias 확인 현재 등록된 alias 리스트를 확인할 수 있습니다. 1234567891011$ aliasalias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l.='ls -d .* --color=auto'alias ll='ls -l --color=auto'alias ls='ls --color=auto'alias mv='mv -i'alias rm='rm -i'... alias 등록 명령어 별칭은 alias 명령어별칭='명령어'의 형식으로 등록합니다. 다음의 예제처럼 등록하면 run_tomcat 라는 명령어를 실행할 경우 tomcat 이 실행됩니다. 12# alias 명령어별칭 = '명령어'$ alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start' alias 해제 unalias 명령어를 사용하여 등록된 alias를 삭제할 수 있습니다. 1$ unalias run_tomcat alias 영구 등록 위에서 등록된 alias 들은 시스템을 재부팅하고 나면 다시 초기화가 되어 매번 재 설정해줘야 한다는 불편함이 있습니다. 이러한 문제를 방지하려면 alias 를 ./bashrc이나 .bash_aliases 파일에 등록해서 사용해야 합니다. 재부팅이 되더라도 등록해 둔 alias가 영구 지속됩니다. 1$ vi ~/.bashrc ./bashrc 파일을 열고 alias를 추가합니다. 123alias run_tomcat='/usr/local/tomcat8/bin/catalina.sh start'alias stop_tomcat='/usr/local/tomcat8/bin/catalina.sh stop'alias tomcat_logs='tail -n 150 -f /usr/local/tomcat8/logs/catalina.out' bashrc 파일을 수정하면 바로 적용되지 않고 source 명령어를 사용하여 동기화를 해야 합니다. 1$ source ~/.bashrc 위의 방법으로 alias 별칭을 편리하게 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"}]},{"title":"[CentOS] Tomcat 다중 설치 및 운영 방법","slug":"linux-18","date":"2022-08-23T04:13:31.000Z","updated":"2024-01-12T01:35:37.710Z","comments":true,"path":"2022/08/23/linux-18/","link":"","permalink":"http://hgko1207.github.io/2022/08/23/linux-18/","excerpt":"","text":"리눅스 환경에서 Tomcat을 다중 설치하고 운영하는 방법에 대해 알아보겠습니다. 1. Tomcat 설치 이전 글 [CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법 을 보면서 Tomcat 을 설치합니다. 설치된 Tomcat 폴더를 서로 다른 이름의 폴더로 복사합니다. 12- tomcat1 : /usr/local/tomcat_1- tomcat2 : /usr/local/tomcat_2 2. catalina.sh 파일 수정 /bin/catalina.sh 파일을 열고 다음 내용을 추가합니다. 1234export CATALINA_HOME=[Tomcat Path]export TOMCAT_HOME=[Tomcat Path]export CATALINA_BASE=[Tomcat Path]CATALINA_PID=[Tomcat Path]/bin/tomcat.pid tomcat1 1234export CATALINA_HOME=/usr/local/tomcat_1export TOMCAT_HOME=/usr/local/tomcat_1export CATALINA_BASE=/usr/local/tomcat_1CATALINA_PID=/usr/local/tomcat_1/bin/tomcat.pid tomcat2 1234export CATALINA_HOME=/usr/local/tomcat_2export TOMCAT_HOME=/usr/local/tomcat_2export CATALINA_BASE=/usr/local/tomcat_2CATALINA_PID=/usr/local/tomcat_2/bin/tomcat.pid 3. 포트 변경 /conf/server.xml 파일에서 포트를 수정합니다. Tomcat 마다 포트 3개를 다르게 입력해야 합니다. 다음과 같이 tomcat1 은 80XX, tomcat2 은 81XX 포트로 변경합니다. 123Server Port 는 8005, 8105Connector Port 는 8080, 8180AJP/1.3 Port 는 8009, 8109 tomcat1 12345678910...&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... tomcat2 12345678910...&lt;Server port=\"8105\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;... &lt;Connector port=\"8180\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;... &lt;Connector port=\"8109\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;... 4. 방화벽 해제 설정된 HTTP 포트의 방화벽을 해제합니다. 123$ sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent$ sudo firewall-cmd --zone=public --add-port=8180/tcp --permanent$ sudo firewall-cmd --reload 서비스를 시작 시킨 후 각각의 서비스 포트로 접속해서 제대로 동작하는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"}]},{"title":"[React] reference 사용 방법","slug":"react-10","date":"2022-08-21T13:58:27.000Z","updated":"2024-01-12T01:35:13.373Z","comments":true,"path":"2022/08/21/react-10/","link":"","permalink":"http://hgko1207.github.io/2022/08/21/react-10/","excerpt":"","text":"reference는 react 코드를 이용해 HTML 요소를 지정하고 가져올 수 있는 방법입니다. 다시 말해서 자바스크립트로부터 HTML 요소를 가져오고 수정할 수 있도록 해줍니다. 사용 useRef를 사용하여 HTML 요소를 가져옵니다. 다음 코드는 button 클릭 시 input을 포커싱하고 해제하는 예제입니다. 1234567891011121314151617181920import &#123; useRef &#125; from 'react';function RefEx() &#123; const inputRef = useRef&lt;HTMLInputElement&gt;(null); const onClick = () =&gt; &#123; inputRef.current?.focus(); // 5초 뒤에 focus 사라짐 setTimeout(() =&gt; &#123; inputRef.current?.blur; &#125;, 5000); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputRef&#125; type=\"text\" placeholder=\"input\" /&gt; &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;export default RefEx; typescript 사용하므로 HTMLInputElement를 지정하였습니다. useRef를 사용하여 HTML 요소를 가져왔지만 수정할 경우에는 HTMLInputElement 지정한 것 처럼 일반 자바스크립트를 이용합니다. useRef() useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 반환된 객체는 컴포넌트의 전 life cycle을 통해 유지될 것입니다. 일반적인 사용 사례는 자식에게 접근하는 경우입니다. 본질적으로 useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 &quot;상자&quot;와 같습니다. 참고 https://ko.reactjs.org/docs/hooks-reference.html#useref HTMLInputElement methods","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"}]},{"title":"[Spring] Swagger Header 설정 방법","slug":"spring-1","date":"2022-08-19T07:48:58.000Z","updated":"2024-01-12T01:33:57.342Z","comments":true,"path":"2022/08/19/spring-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/spring-1/","excerpt":"","text":"Spring에서 Swagger Header 설정 방법에 대해 알아보겠습니다. API 마다 설정 각 API 마다 @ApiImplicitParam을 통해 인증 정보(토큰)를 입력하도록 설정합니다. 1234567@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"Authorization\", value = \"JWT Token\", required = true, dataType = \"string\", paramType = \"header\") &#125;)@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 이 방법은 API 개수가 많아질 경우 코드 양이 늘어나고 가독성이 나빠집니다. 그리고 Swagger를 통해 테스트 진행 시 각 API 마다 인증 정보를 입력해야 한다는 번거로움이 생기게 됩니다. Authroize 버튼 활성화 SWagger Version 2.9.2부터는 번거로움을 없애주는 기능이 생겼습니다. Swagger 화면 상단 부분에 Autorize 버튼이 생겼습니다. Autorize 버튼을 클릭하면 모든 API에 일괄 인증 할 수 있도록 해주는 인증 정보를 입력받는 창이 뜹니다. 설정 먼저 maven 또는 gradle 설정을 합니다. 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 1234dependencies &#123; compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' implementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2'&#125; SwaggerConfig 클래스를 생성하고 코드들을 추가합니다. 중요한 것은 ApiKey 를 유의해야 합니다. 프로젝트마다 사용하는 인증 key가 다르므로 확인해서 입력합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Arrays;import java.util.List;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.ApiKey;import springfox.documentation.service.AuthorizationScope;import springfox.documentation.service.SecurityReference;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger.web.DocExpansion;import springfox.documentation.swagger.web.ModelRendering;import springfox.documentation.swagger.web.OperationsSorter;import springfox.documentation.swagger.web.TagsSorter;import springfox.documentation.swagger.web.UiConfiguration;import springfox.documentation.swagger.web.UiConfigurationBuilder;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger 자동 문서화 웹 생성을 위한 Spring MVC 설정 * @author hgko * */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .useDefaultResponseMessages(false) // 웹 페이지에서 디폴트 설정되는 ResponseMessages 부분 표시하지 않음 .select() .apis(RequestHandlerSelectors.basePackage(\"com.hgko.controller\")) // Controller에서 api 추출 .paths(PathSelectors.any()) .build() .apiInfo(swaggerInfo()) .securityContexts(Arrays.asList(securityContext())) .securitySchemes(Arrays.asList(apiKey())); &#125; public ApiInfo swaggerInfo() &#123; return new ApiInfoBuilder() .title(\"Server API Documentation\") .description(\"서버 API에 대한 연동 문서입니다\") .version(\"0.0.1\") .build(); &#125; private ApiKey apiKey() &#123; return new ApiKey(\"Authorization\", \"Authorization\", \"header\"); &#125; private SecurityContext securityContext() &#123; return SecurityContext.builder() .securityReferences(defaultAuth()) .build(); &#125; private List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Arrays.asList(new SecurityReference(\"Authorization\", authorizationScopes)); &#125;&#125; 기존 API 코드에서 @ApiImplicitParams 부분을 제거합니다. 12345@PostMapping(\"/auth/test\")public ResponseEntity&lt;?&gt; authTest() &#123; System.err.println(\"authTest\"); return ResponseEntity.ok(\"test ok\");&#125; 설정은 다 끝났습니다. Swagger 화면에서 정상적으로 동작하는지 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"}]},{"title":"[Angular] 기능 구현 방식","slug":"angular-3","date":"2022-08-19T00:59:13.000Z","updated":"2024-01-12T01:32:44.240Z","comments":true,"path":"2022/08/19/angular-3/","link":"","permalink":"http://hgko1207.github.io/2022/08/19/angular-3/","excerpt":"","text":"Angular 프레임워크로 특정 기능을 구현할 때 어떤 방식으로 사용하는지에 대해 알아보겠습니다. UI Component 구현 클래스에 @Component Annotation을 붙여서 생성합니다. HTML 템플릿 정의 인라인 HTML 코드를 사용할 때는 @Component 어노테이션 template 항목을 사용하고, 외부 파일에서 불러올 때는 templateUrl 항목을 사용합니다. 컴포넌트 Property 를 UI에 표시 템플릿의 이중 중괄호 안에 Property를 사용합니다. 1&lt;span&gt;&#123;&#123; customValue &#125;&#125;)&lt;/span&gt; 컴포넌트 Property 바인딩 대괄호를 사용해서 Property를 바인딩합니다. 1&lt;input [value]=\"inputValue\" /&gt; 이벤트 처리 이벤트 이름을 괄호로 감싸고 핸들러를 지정합니다. 1&lt;button (click)=\"onClickEvent\"&gt;Click&lt;/button&gt; 양방향 바인딩 [()] 표기를 사용합니다. 1&lt;input [(ngModel)]=\"componentProperty\" /&gt; HTML 일부를 자식 컴포넌트에 전달하기 자식 컴포넌트의 템플릿에 &lt;ng-content&gt; 태그를 사용합니다. 내비게이션 구현 라우터를 사용해서 컴포넌트와 URL을 연결하고 컴포넌트의 템플릿이 렌더링될 위치를 &lt;router-outlet&gt; 태그로 지정합니다. 컴포넌트에서 데이터 받기 컴포넌트 프로퍼티를 선언할 때 @Input 어노테이션을 사용해서 외부 값과 연결합니다. 컴포넌트에 데이터 전달하기 컴포넌트 프로퍼티를 선언할 때 @Output 어노테이션을 사용하고 EventEmitter를 이용해서 이벤트를 발생시킵니다. HTTP 요청 컴포넌트에 Http 객체를 주입하고 HTTP 함수를 사용합니다. 1this.http.get('/users'); HTTP 응답 처리 subscribe() 함수를 사용해서 옵저버블 스트림을 처리합니다. 123this.http.get('/users').subscribe(() =&gt; &#123; ...&#125;); 컴포넌트 상태가 변경되는 것을 가로채기 컴포넌트 생성주기 함수를 사용합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[React] memo 사용 방법","slug":"react-9","date":"2022-08-12T13:50:38.000Z","updated":"2024-01-12T01:31:45.775Z","comments":true,"path":"2022/08/12/react-9/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-9/","excerpt":"","text":"React에서 memo 사용 방법에 대해 알아보겠습니다. 컴포넌트가 동일한 props로 동일한 결과를 렌더링 해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑 하여 경우에 따라 성능 향상을 누릴 수 있습니다. 즉, React는 컴포넌트를 렌더링 하지 않고 마지막으로 렌더링 된 결과를 재사용합니다. 1234567import React from 'react';function MyComponent(props) &#123; /* props를 사용하여 렌더링 */&#125;export default React.memo(MyComponent, areEqual); 사용 이전 포스트 [React] Drag and Drop에서 드래그, 드롭 시 바뀐 부분이 아닌 전체가 리랜더링이 되어 텍스트의 흔들림이 가끔씩 발생하는 문제가 있었습니다. Card 부분을 DraggableCard Component로 새로 만들었습니다. DraggableCard에게 동일한 index와 todo prop을 주고 불필요한 리랜더링을 하지 않도록 하기 위해 memo를 사용하였습니다. 123456789101112131415161718192021222324252627282930// DraggableCard.tsximport React from 'react';import &#123; Draggable &#125; from 'react-beautiful-dnd';import styled from 'styled-components';const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;interface IDraggableCardProps &#123; toDo: string; index: number;&#125;function DraggableCard(&#123; toDo, index &#125;: IDraggableCardProps) &#123; return ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; );&#125;export default React.memo(DraggableCard); 실제로 바뀐 것들만 리렌더링 되어 텍스트가 흔들리는 문제를 해결함으로써 최적화 할 수 있었습니다. 주의 React.memo는 props 변화에만 영향을 줍니다. React.memo로 감싸진 함수 컴포넌트 구현에 useState, useReducer 또는 useContext 훅을 사용한다면, 여전히 state나 context가 변할 때 다시 렌더링 됩니다. 이 메서드는 오직 성능 최적화를 위하여 사용됩니다. 렌더링을 방지하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다. 참고 https://ko.reactjs.org/docs/react-api.html#reactmemo","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"}]},{"title":"[React] Drag and Drop 사용 방법","slug":"react-8","date":"2022-08-12T13:21:15.000Z","updated":"2024-01-12T01:30:23.092Z","comments":true,"path":"2022/08/12/react-8/","link":"","permalink":"http://hgko1207.github.io/2022/08/12/react-8/","excerpt":"","text":"react-beautiful-dnd을 사용하여 React에서 깔끔하고 사용하기 쉬운 드래그, 드롭, 애니메이션을 적용하는 방법에 대해 알아보겠습니다. 설치 1$ npm i react-beautiful-dnd TypeScript 사용 시 추가로 설치합니다. 1$ npm i --save-dev @types/react-beautiful-dnd 사용 임시 데이터 **[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]**를 사용하여 카드 형태의 드래그, 드롭을 구현해 봤습니다. 1234567// atoms.tsximport &#123; atom &#125; from 'recoil';export const toDoState = atom(&#123; key: 'toDo', default: ['a', 'b', 'c', 'd', 'e', 'f'],&#125;); DragDropContext, Draggable, Droppable 를 사용하여 구성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// App.tsximport &#123; DragDropContext, Draggable, Droppable, DropResult &#125; from 'react-beautiful-dnd';import &#123; useRecoilState &#125; from 'recoil';import styled from 'styled-components';import &#123; toDoState &#125; from './atoms';const Wrapper = styled.div` display: flex; max-width: 480px; width: 100%; margin: 0 auto; justify-content: center; align-items: center; height: 100vh;`;const Boards = styled.div` display: grid; width: 100%; grid-template-columns: repeat(3, 1fr);`;const Board = styled.div` padding: 20px 10px; padding-top: 30px; background-color: gray; border-radius: 5px; min-height: 200px;`;const Card = styled.div` border-radius: 5px; margin-bottom: 5px; padding: 10px 10px; background-color: white;`;function App() &#123; const [toDos, setToDos] = useRecoilState(toDoState); const onDragEnd = (&#123; draggableId, destination, source &#125;: DropResult) =&gt; &#123; if (!destination) return; setToDos((oldToDos) =&gt; &#123; const copyToDos = [...oldToDos]; // 1) Delete item on source.index copyToDos.splice(source.index, 1); // 2) Put back the item on the destination.index copyToDos.splice(destination?.index, 0, draggableId); return copyToDos; &#125;); &#125;; return ( &lt;DragDropContext onDragEnd=&#123;onDragEnd&#125;&gt; &lt;Wrapper&gt; &lt;Boards&gt; &lt;Droppable droppableId=\"one\"&gt; &#123;(provided) =&gt; ( &lt;Board ref=&#123;provided.innerRef&#125; &#123;...provided.droppableProps&#125;&gt; &#123;toDos.map((toDo, index) =&gt; ( &lt;Draggable key=&#123;toDo&#125; draggableId=&#123;toDo&#125; index=&#123;index&#125;&gt; &#123;(provided) =&gt; ( &lt;Card ref=&#123;provided.innerRef&#125; &#123;...provided.dragHandleProps&#125; &#123;...provided.draggableProps&#125;&gt; &#123;toDo&#125; &lt;/Card&gt; )&#125; &lt;/Draggable&gt; ))&#125; &#123;provided.placeholder&#125; &lt;/Board&gt; )&#125; &lt;/Droppable&gt; &lt;/Boards&gt; &lt;/Wrapper&gt; &lt;/DragDropContext&gt; );&#125;export default App; Draggable의 draggableProps는 모든 영역을 dragHandleProps는 특정 영역을 통해서만 드래그할 수 있도록 설정할 수 있습니다. Draggable list를 렌더링 하는 경우 각 Draggable에 key prop을 추가하는 것이 중요합니다. key는 list 내에서 고유해야 합니다. key에 item의 index가 포함되어서는 안 되기 때문에 일반적으로 draggableId를 key로 사용합니다. 참고 react-beautiful-dnd 테스트해 보기 react-beautiful-dnd 예시 코드 react-beautiful-dnd-kr","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"},{"name":"Drag","slug":"Drag","permalink":"http://hgko1207.github.io/tags/Drag/"},{"name":"Drop","slug":"Drop","permalink":"http://hgko1207.github.io/tags/Drop/"}]},{"title":"[React] React Hook Form","slug":"react-7","date":"2022-08-08T14:40:32.000Z","updated":"2024-01-12T01:28:14.233Z","comments":true,"path":"2022/08/08/react-7/","link":"","permalink":"http://hgko1207.github.io/2022/08/08/react-7/","excerpt":"","text":"React에서 React Hook Form 사용 방법에 대해 알아보겠습니다. 기본적으로 Form을 사용할 때 작성하는 코드입니다. 하나의 input 이지만 여러 개의 input 을 사용할 경우 useState 와 onChange 이벤트가 많이 생성됩니다. 그리고 Validation Check 하는 코드도 복잡해집니다. 123456789101112131415161718192021222324252627282930313233// InputForm.tsximport React, &#123; useState &#125; from 'react';function InputForm() &#123; const [toDo, setTodo] = useState(''); const [toDoError, setTodoError] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setTodoError(''); setTodo(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); if (toDo.length &lt; 10) &#123; return setTodoError('To do should be longer'); &#125; console.log(toDo); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input onChange=&#123;onChange&#125; value=&#123;toDo&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &#123;toDoError !== '' ? toDoError : null&#125; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; react-hook-form 라이브러리를 사용하면 위의 코드들을 간략하게 줄일 수 있습니다. 그리고 Validation(검증)도 쉽게 관리할 수 있습니다. 설치 1$ npm install react-hook-form 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add react-hook-form 사용 먼저 useForm 을 import 합니다. 1import &#123; useForm &#125; from 'react-hook-form'; register useForm, register을 사용한 단 한줄의 코드가 onChange 이벤트와 value, useState 를 모두 대체했습니다. 사용법은 {...register(name)}를 input 태그 안에 작성합니다. register 함수는 Validation을 보다 쉽게 관리할 수 있도록 해줍니다. required: true처럼 조건을 작성할 수 있습니다. 123456789101112131415// InputForm.tsxfunction InputForm() &#123; const &#123; register &#125; = useForm(); return ( &lt;div&gt; &lt;form&gt; &lt;input &#123;...register('toDo', &#123; required: true &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; watch watch는 form의 입력 값들의 변화를 관찰할 수 있게 해줍니다. 12const &#123; register, watch &#125; = useForm();console.log(watch); handleSubmit handleSubmit는 form 데이터의 Validation Check를 해결해 줍니다. 파라미터는 Validation을 통과했을 때 호출되는 함수입니다. handleSubmit를 사용하면 키보드랑 마우스를 조건이 유효하지 않은 항목으로 바로 focus 시켜줍니다. 123456789101112131415161718192021222324252627// InputForm.tsxfunction InputForm() &#123; const &#123; register, handleSubmit &#125; = useForm(); const onValid = (data: any) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('toDo', &#123; required: true, minLength: &#123; value: 5, message: 'Your todo is too short.', &#125;, &#125;)&#125; placeholder=\"Write a to do\" /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; formState formState 을 통해 에러메시지를 출력해 보겠습니다. 먼저 email 은 정규식을 통해 검증하도록 pattern을 작성하였습니다. 조건을 입력할 때 메시지도 작성하여 에러메시지가 출력되도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344type IForm = &#123; errors: &#123; email: &#123; message: string; &#125;; &#125;; email: string;&#125;;function InputForm() &#123; const &#123; register, handleSubmit, formState: &#123; errors &#125;, &#125; = useForm&lt;IForm&gt;(&#123; defaultValues: &#123; email: '@gmail.com', &#125;, &#125;); const onValid = (data: IForm) =&gt; &#123; console.log(data); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;handleSubmit(onValid)&#125;&gt; &lt;input &#123;...register('email', &#123; required: '이메일을 입력하세요.', pattern: &#123; value: /^[A-Za-z0-9._%+-]+@gmail.com$/, message: '이메일 형식이 맞지 않습니다.', &#125;, &#125;)&#125; placeholder=\"Email\" /&gt; &lt;span&gt;&#123;errors?.email?.message&#125;&lt;/span&gt; &lt;button&gt;등록&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default InputForm; email을 입력하지 않았을 경우 이메일을 입력하세요. 에러메시지가 출력되고 email 형식이 맞지 않을 경우 이메일 형식이 맞지 않습니다. 에러메시지가 출력됩니다. SetValue submit 하고 난 후 값을 초기화할 수 있습니다. Custom Validation setError 를 통해 직접 에러를 발생시키도록 할 수 있습니다. shouldFocus 옵션을 사용하면 form의 커서가 자동으로 옮겨집니다. 12// 예setError('password1', &#123; message: '비밀번호가 다릅니다.' &#125;, &#123; shouldFocus: true &#125;); 참고 https://react-hook-form.com/ https://react-hook-form.com/kr/get-started/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"}]},{"title":"[Angular] Angular 시작","slug":"angular-2","date":"2022-08-07T12:51:25.000Z","updated":"2024-01-12T01:26:04.818Z","comments":true,"path":"2022/08/07/angular-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/07/angular-2/","excerpt":"","text":"Angular는 구글이 만든 단일 페이지 웹 애플리케이션 개발을 위한 자바스크립트 프레임워크입니다. 다양한 플랫폼에서 동작할 수 있게 하는 개발 툴과 기능들을 제공합니다. Module 컴포넌트, 파이프, 서비스 등과 같은 앵귤러 애플리케이션의 주요 부분을 기능단위로 그룹핑하게 해 줍니다. 모든 앵귤러 애플리케이션은 하나의 Root Module을 가집니다. 여러 Feature Module을 가질 수 있습니다. 재사용할 수 있는 기능을 외부에 배포하기 위해 사용되기도 합니다. Component 빌딩 블록 형식 HTML 요소들의 그룹 뷰와 로직으로 구성 1$ ng g component todo/todos --module todo/todo.module.ts --export 컴포넌트 내부에서 html, css 코드를 작성하도록 생성할 수 있습니다. 1$ ng g component todos/todo --inline-template --inline-style Template HTML 코드로서 템플릿을 표현합니다. Template 표현식(Expression)과 Template 문장(Statement)을 가집니다. 바인딩 바인딩의 대상: 속성, 이벤트, ngModel, class, style 123456789101112&lt;!-- &#123;&#123; 템플릿 표현식 &#125;&#125; --&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;!-- [속성]=\"템플릿 표현식\" --&gt;&lt;todo [todo]=\"work\"&gt;&lt;/todo&gt;&lt;!-- (이벤트)=\"템플릿 문장(함수)\" --&gt;&lt;button (click)=\"handle()\"&gt;&lt;/button&gt;&lt;!-- [(ngModel)]=\"템플릿 문장\" --&gt;&lt;!-- 양방향 바인딩을 사용할 수 있음 --&gt;&lt;input type=\"text\" [(ngModel)]=\"name\" /&gt; 컴포넌트 간 커뮤니케이션 부모 컴포넌트 -&gt; 자식 컴포넌트 @input() 사용 ES6 setter 사용 가능 @ViewChild() 사용 자식 컴포넌트 -&gt; 부모 컴포넌트 @Output() 사용 EventEmitter 사용하여 부모에게 이벤트 전달 부모 컴포넌트는 $event로 이벤트의 데이터를 전달받음 자식이 부모 컴포넌트를 직접 주입받을 수 있음 파이프(Pipe) 템플릿(HTML)에서 보이는 데이터를 변환해 줍니다. AngularJs 1.x에서는 필터로 제공되었습니다. 실제 값을 변경하는 것이 아니라 보여주는 값만 바꿔 보여주기 위해 사용합니다. 123456789// 사용법&#123;&#123; express | pipeName: paramValue &#125;&#125;// 예today: Date = new Date();&#123;&#123; today | date &#125;&#125;&#123;&#123; today | date:\"yy/mm/dd\" &#125;&#125; // 날짜 포맷 변환&#123;&#123; today | date | uppercase &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"}]},{"title":"[Python] 기초(2)","slug":"python-2","date":"2022-08-02T14:47:28.000Z","updated":"2024-01-12T01:24:54.287Z","comments":true,"path":"2022/08/02/python-2/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-2/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본편)을 보면서 작성하였습니다. 기본 시작 함수 123456789101112131415161718192021222324def open_account(): print(\"새로운 계좌가 생성되었습니다.\")def deposit(balance, money): # 입금 print(\"입금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance + money)) return balance + moneydef withdraw(balance, money): # 출금 if balance &gt;= money: # 잔액이 출금보다 많으면 print(\"출금이 완료되었습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance - money)) return balance - money else: print(\"출금이 완료되지 않았습니다. 잔액은 &#123;0&#125; 원입니다.\".format(balance)) return balancedef withdraw_night(balance, money): # 저녁에 출금 commission = 100 # 수수료 100원 return commission, balance - money - commissionbalance = 0balance = deposit(balance, 1000)# balance = withdraw(balance, 500)commission, balance = withdraw_night(balance, 500)print(\"수수료 &#123;0&#125; 원이며, 잔액은 &#123;1&#125; 원입니다.\".format(commission, balance)) 함수 기본값 12345678910def profile(name, age, main_lang): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\", 35, \"파이썬\")# 같은 학교 같은 학년 같은 반 같은 수업def profile(name, age=17, main_lang=\"파이썬\"): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t주 사용언어 : &#123;2&#125;\".format(name, age, main_lang))profile(\"고형균\") 가변인자 123456789101112# def profile(name, age, lang1, lang2, lang3, lang4, lang5):# print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \")# print(lang1, lang2, lang3, lang4, lang5)def profile(name, age, *language): print(\"이름 : &#123;0&#125;\\t나이 : &#123;1&#125;\\t\".format(name, age), end=\" \") for lang in language: print(lang, end=\" \") print()profile(\"고형균\", 35, \"Python\", \"Java\", \"C\", \"C++\", \"C#\", \"JavaScript\")profile(\"김태호\", 40, \"Kotlin\", \"Swift\", \"\", \"\", \"\") 지역변수와 전역변수 12345678910111213141516gun = 10def checkpoint(soldiers): # 경계근무 global gun # 전역 공간에 있는 gun 사용 gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun))def checkpoint_ret(gun, soldiers): gun = gun - soldiers print(\"[함수 내] 남은 총 : &#123;0&#125;\".format(gun)) return gunprint(\"전체 총 : &#123;0&#125;\".format(gun))#checkpoint(2) # 2명이 경계 근무 나감gun = checkpoint_ret(gun, 2)print(\"남은 총 : &#123;0&#125;\".format(gun)) 표준 입출력 1234567891011121314import sysprint(\"Python\", \"Java\", file=sys.stdout)print(\"Python\", \"Java\", file=sys.stderr)# 시험 성적scores = &#123;\"수학\":0, \"영어\":50, \"코딩\":100&#125;for subject, score in scores.items(): #print(subject, score) print(subject.ljust(8), str(score).rjust(4), sep=\":\")# 은행 대기순번표# 001, 002, 003, ...for num in range(1, 21): print(\"대기번호 : \" + str(num).zfill(3)) 다양한 출력포맷 123456789101112131415161718# 빈 자리는 빈공간으로 두고, 오른쪽 정렬을 하되, 총 10자리 공간을 확보print(\"&#123;0: &gt;10&#125;\".format(500))# 양수일 땐 +로 표시, 음수일 땐 -로 표시print(\"&#123;0: &gt;+10&#125;\".format(500))print(\"&#123;0: &gt;+10&#125;\".format(-500))# 왼쪽 정렬하고, 빈칸으로 _로 채움print(\"&#123;0:_&lt;+10&#125;\".format(500))# 3자리 마다 콤마를 찍어주기print(\"&#123;0:,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이기print(\"&#123;0:+,&#125;\".format(1000000000))# 3자리 마다 콤마를 찍어주기, +- 부호도 붙이고, 자릿수 확보하기# 돈이 많으면 행복해지니까 빈 자리는 ^ 로 채워주기print(\"&#123;0:^&lt;+30,&#125;\".format(1000000000))# 소수점 출력print(\"&#123;0:f&#125;\".format(5/3))# 소수점 특정 자리수 까지만 표시 (소수점 3째 자리에서 반올림)print(\"&#123;0:.2f&#125;\".format(5/3)) 파일 입출력 12345678910111213141516171819202122232425262728293031323334score_file = open(\"score.txt\", \"w\", encoding=\"utf8\") # writeprint(\"수학 : 0\", file=score_file)print(\"영어 : 50\", file=score_file)score_file.close()score_file = open(\"score.txt\", \"a\", encoding=\"utf8\") # updatescore_file.write(\"과학 : 80\")score_file.write(\"\\n코딩 : 100\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\") # readprint(score_file.read())score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")print(score_file.readline(), end=\"\") # 줄별로 읽기, 한 줄 읽고 커서는 다음 줄로 이동print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")print(score_file.readline(), end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")while True: line = score_file.readline() if not line: break print(line, end=\"\")score_file.close()score_file = open(\"score.txt\", \"r\", encoding=\"utf8\")lines = score_file.readlines() # list 형태로 저장for line in lines: print(line, end=\"\")score_file.close() pickle 1234567891011import pickleprofile_file = open(\"profile.pickle\", \"wb\") # b: 바이너리profile = &#123;\"이름\":\"고형균\", \"나이\":36, \"취미\":[\"축구\", \"볼링\", \"코딩\"]&#125;print(profile)pickle.dump(profile, profile_file) # profile 에 있는 정보를 file 에 저장profile_file.close()profile_file = open(\"profile.pickle\", \"rb\")profile = pickle.load(profile_file) # file 에 있는 정보를 profile 에 불러오기print(profile)profile_file.close() with 12345with open(\"study.txt\", \"w\", encoding=\"utf8\") as study_file: study_file.write(\"파이썬을 열심히 공부하고 있어요\")with open(\"study.txt\", \"r\", encoding=\"utf8\") as study_file: print(study_file.read()) 클래스 1234567891011class Unit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage print(\"&#123;0&#125; 유닛이 생성되었습니다.\".format(self.name)) print(\"체력 &#123;0&#125;, 공격력 &#123;1&#125;\\n\".format(self.hp, self.damage))marine1 = Unit(\"마린\", 40, 5)marine2 = Unit(\"마린\", 40, 5)tank = Unit(\"탱크\", 150, 35) 메서드 12345678910111213141516171819202122class AttackUnit: def __init__(self, name, hp, damage): self.name = name self.hp = hp self.damage = damage def attack(self, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 적군을 공격합니다. [공격력 &#123;2&#125;]\".format(self.name, location, self.damage)) def damaged(self, damage): print(\"&#123;0&#125; : &#123;1&#125; 데미지를 입었습니다.\".format(self.name, damage)) self.hp -= damage print(\"&#123;0&#125; : 현재 체력은 &#123;1&#125; 입니다.\".format(self.name, self.hp)) if self.hp &lt;= 0: print(\"&#123;0&#125; : 파괴되었습니다.\".format(self.name))firebat1 = AttackUnit(\"파이어뱃\", 50, 16)firebat1.attack(\"5시\")# 공격 2번 받는다고 가정firebat1.damaged(25)firebat1.damaged(25) 상속 123456789class Unit: def __init__(self, name, hp): self.name = name self.hp = hpclass AttackUnit(Unit): def __init__(self, name, hp, damage): Unit.__init__(self, name, hp) self.damage = damage 다중 상속 1234567891011121314151617# 날 수 있는 기능을 가진 클래스class Flyable: def __init__(self, flying_speed): self.flying_speed = flying_speed def fly(self, name, location): print(\"&#123;0&#125; : &#123;1&#125; 방향으로 날아갑니다. [속도 &#123;2&#125;]\".format(name, location, self.flying_speed))# 공중 공격 유닛 클래스class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, damage) Flyable.__init__(self, flying_speed)# 발키리 : 공중 공격 유닛, 한번에 14발 미사일 발사.valkrie = FlyableAttackUnit(\"발키리\", 200, 6, 5)valkrie.fly(valkrie.name, \"3시\"); 메서드 오버라이딩 1234567class FlyableAttackUnit(AttackUnit, Flyable): def __init__(self, name, hp, damage, flying_speed): AttackUnit.__init__(self, name, hp, 0, damage) Flyable.__init__(self, flying_speed) def move(self, location): self.fly(self.name, location) # &lt;= 메서드 오버라이딩 pass 12345678def game_start(): print(\"[알림] 새로운 게임을 시작합니다.\")def game_over(): passgame_start()game_over() super 12345class BuildingUnit(Unit): def __init__(self, name, hp, location): #Unit.__init__(self, name, hp, 0) super().__init__(name, hp, 0) self.location = location 예외처리 1234567891011121314try: print(\"나누기 전용 계산기입니다.\") nums = [] nums.append(int(input(\"첫 번째 숫자를 입력하세요 : \"))) nums.append(int(input(\"두 번째 숫자를 입력하세요 : \"))) nums.append(int(nums[0] / nums[1])) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(nums[0], nums[1], nums[2]))except ValueError: print(\"에러! 잘못된 값을 입력하였습니다.\")except ZeroDivisionError as err: print(err)except Exception as err: print(\"알 수 없는 에러가 발생하였습니다.\") print(err) 예외 발생시키기 12345678910111213141516171819class BigNumberError(Exception): def __init__(self, msg): self.msg = msg def __str__(self): return self.msgtry: print(\"한 자리 숫자 나누기 전용 계산기입니다.\") num1 = int(input(\"첫 번째 숫자를 입력하세요 : \")) num2 = int(input(\"두 번째 숫자를 입력하세요 : \")) if num1 &gt;= 10 or num2 &gt;= 10: raise BigNumberError(\"입력값 : &#123;0&#125;, &#123;1&#125;\".format(num1, num2)) print(\"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;\".format(num1, num2, int(num1 / num2)))except ValueError: print(\"잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.\")except BigNumberError as err: print(\"에러가 발생하였습니다. 한 자리 숫자만 입력하세요.\") print(err) 모듈 모듈을 사용하기 위해 theater_module.py 파일을 생성합니다. 1234567891011# 일반 가격def price(people): print(\"&#123;0&#125;명 가격은 &#123;1&#125;원 입니다.\".format(people, people * 10000))# 조조 할인 가격def price_morning(people): print(\"&#123;0&#125;명 조조 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 6000))# 군인 할인 가격def price_soldier(people): print(\"&#123;0&#125;명 군인 할인 가격은 &#123;1&#125;원 입니다.\".format(people, people * 4000)) 생성한 모듈을 사용하기 위한 5가지 방법입니다. 1234567891011121314151617181920212223242526# 1) 기본import theater_moduletheater_module.price(3) # 3명이서 영화 보러 갔을 때 가격theater_module.price_morning(4) # 4명이서 조조 할인 영화 보러 갔을 때theater_module.price_soldier(5) # 5명의 군인이 영화 보러 갔을 때# 2) 별칭 사용import theater_module as mvmv.price(3)mv.price_morning(4)mv.price_soldier(5)# 3) 전체 사용from theater_module import *price(3)price_morning(4)price_soldier(5)# 4) 특정한 함수 사용from theater_module import price, price_morningprice(5)price_morning(6)# 5) 함수에 별칭 사용from theater_module import price_soldier as priceprice(5) all 1__all__ = [\"vietnam\"] 모듈 직접 실행 1234567891011class ThailandPackage: def detail(self): print(\"[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원\")if __name__ == \"__main__\": print(\"Thailand 모듈을 직접 실행\") print(\"이 문장은 모듈을 직접 실행할 때만 실행돼요\") trip_to = ThailandPackage() trip_to.detail()else: print(\"Thailand 외부에서 모듈 호출\") 패키지, 모듈 위치 123import inspectimport randomprint(inspect.getfile(random)) pip install https://pypi.org/search/ pip install beautifulsoup4 pip list pip show beautifulsoup4 pip install --upgrade beautifulsoup4 pip uninstall beautifulsoup4 내장 함수 Built-in Functions 사이트는 파이썬의 내장 함수 목록을 확인할 수 있습니다. 12345678910111213# input : 사용자 입력을 받는 함수language = input(\"무슨 언어를 좋아하세요?\")print(\"&#123;0&#125;은 아주 좋은 언어입니다!\".format(language))# dir : 어떤 객체를 넘겨줬을 때 그 객체가 어떤 변수와 함수를 가지고 있는지 표시import random # 외장 함수print(dir(random))lst = [1, 2, 3]print(dir(lst))name = \"Ko\"print(dir(name)) 외장 함수 Python Module Index 사이트는 파이썬의 외장 함수 목록을 확인할 수 있습니다. 123456789101112131415161718192021# glob : 경로 내의 폴더 / 파일 목록 조회 (윈도우 dir)import globprint(glob.glob(\"*.py\")) # 확장자가 py 인 모든 파일# os : 운영체제에서 제공하는 기본 기능import osprint(os.getcwd()) # 현재 디렉토리print(os.listdir())# time : 시간 관련 함수import timeprint(time.localtime())print(time.strftime(\"%Y-%m-%d %H:%M:%S\"))import datetimeprint(\"오늘 날짜는 \", datetime.date.today())# timedelta : 두 날짜 사이의 간격today = datetime.date.today() # 오늘 날짜 저장td = datetime.timedelta(days=100) # 100일 저장print(\"우리가 만난지 100일은\", today + td) # 오늘부터 100일 후","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Python] 기초(1)","slug":"python-1","date":"2022-08-02T14:40:29.000Z","updated":"2024-01-12T01:24:09.754Z","comments":true,"path":"2022/08/02/python-1/","link":"","permalink":"http://hgko1207.github.io/2022/08/02/python-1/","excerpt":"","text":"나도코딩 님의 파이썬 코딩 무료 강의 (기본 편)을 보면서 작성하였습니다. 환경설정 Python 설치 https://www.python.org/downloads/ 홈페이지 접속 후 다운로드 탭을 선택하고, 현재 버전(3.10.2) 다운로드를 합니다. 다운로드 완료 후 설치를 시작한다. Customize installation 클릭하고, install location 란에 c:\\Python310 입력 후 설치 버튼을 클릭합니다. Visual Studio Code 설치 https://code.visualstudio.com/ 홈페이지 접속 후 다운로드 후 설치합니다. python 익스텐션 설치 기본 시작 주석 1234567print(\"주석\")#print(\"주석\")'''여러문장주석입니다.''' 숫자처리함수 12345678910print(abs(-5)) #5print(pow(4, 2)) # 4^2 = 4*4 = 16print(max(5, 12)) # 12print(min(5, 12)) # 5print(round(3.14)) # 3from math import *print(floor(4.99)) # 내림. 4print(ceil(3.14)) # 올림. 4print(sqrt(16)) # 제곱근. 4 랜덤함수 123456789from random import *print(random()) # 0.0 ~ 1.0 미만의 임의의 값 생성print(random(10)) # 0.0 ~ 10.0 미만의 임의의 값 생성print(int(random() * 10)) # 0 ~ 10 미만의 임의의 값 생성print(int(random() * 10) + 1) # 1 ~ 10 이하의 임의의 값 생성print(int(random() * 45) + 1) # 1 ~ 45 이하의 임의의 값 생성print(randrange(1, 46)) # 1 ~ 46 미만의 임의의 값 생성print(randint(1, 45)) # 1 ~ 45 이하의 임의의 값 생성 문자열 123456789sentence = '나는 소년입니다'print(sentence)sentence2 = \"파이썬은 쉬워요\"print(sentence2)sentence3 = \"\"\"나는 소년이고,파이썬은 쉬워요\"\"\"print(sentence3) 슬라이싱 1234567891011jumin = \"990101-1234567\"print(\"성별 : \" + jumin[7])print(\"연 : \" + jumin[0:2]) # 0 부터 2 직전까지 (0, 1)print(\"월 : \" + jumin[2:4])print(\"일 : \" + jumin[4:6])print(\"생년월일 : \" + jumin[:6]) # 처음부터 6 직전까지print(\"뒤 7자리 : \" + jumin[7:]) # 7 부터 끝까지print(\"뒤 7자리 (뒤에부터) : \" + jumin[-7:])# 맨 뒤에서 7번째부터 끝까지 문자열 처리 함수 1234567891011121314python = \"Python is Amazing\"print(python.lower()) # 소문자로print(python.upper()) # 대문자로print(python[0].isupper())print(len(python)) # 길이print(python.replace(\"Python\", \"Java\")) # 문자열 바꿈index = python.index(\"n\") # 문자열 위치 찾기index = python.index(\"n\", index + 1) # 두번째 n의 위치 찾기print(python.find(\"Java\")) # 문자를 찾지 못할 경우 -1 출력print(python.index(\"Java\")) # 문자를 찾지 못할 경우 오류남print(python.count(\"n\")) # 문자열 n이 나오는 개수 문자열 포맷 123456789101112131415161718192021# 방법 1print(\"나는 %d살입니다.\" % 35) # 정수만print(\"나는 %s을 좋아해요\" % \"파이썬\") # 문자열만print(\"Apple 은 %c로 시작해요.\" % \"A\") # 한글자만 받겠다는 의미# %sprint(\"나는 %s살입니다.\" % 35)print(\"나는 %s색과 %s색을 좋아해요.\" % (\"파란\", \"빨간\"))# 방법 2print(\"나는 &#123;&#125;살입니다.\".format(35))print(\"나는 &#123;&#125;색과 &#123;&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;0&#125;색과 &#123;1&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))print(\"나는 &#123;1&#125;색과 &#123;0&#125;색을 좋아해요.\".format(\"파란\", \"빨간\"))# 방법 3print(\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\".format(age=35, color=\"빨간\"))# 방법 4 (v3.6 이상~)age = 35color = \"빨간\"print(f\"나는 &#123;age&#125;살이며, &#123;color&#125;색을 좋아해요.\") 탈출 문자 1234567891011121314151617181920# \\n : 줄바꿈print(\"백문이 불여일견\\n백견이 불여일타\")# \\\" \\' : 문장 내에서 따옴표# 저는 \"고고고\" 입니다.print(\"저는 '고고고' 입니다.\")print('저는 \"고고고\" 입니다.')print(\"저는 \\\"고고고\\\" 입니다.\")# \\\\ : 문장 내에서 \\print(\"C:\\\\Users\\\\hgko\\\\Desktop\\\\project\\\\Python\\\\PythonStudy\")# \\r : 커서를 맨 앞으로 이동print(\"Red Apple\\rPine\")# \\b : 백스페이스 (한 글자 삭제)print(\"Redd\\bApple\")# \\t : 탭print(\"Red\\tApple\") 리스트 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 리스트 []# 지하철 칸별로 10명, 20명, 30명subway1 = 10subway2 = 20subway3 = 30subway = [10, 20, 30]print(subway)subway = [\"유재석\", \"조세호\", \"박명수\"]# 조세호 씨가 몇 번째 칸에 타고 있는지?print(subway.index(\"조세호\"))# 하하 씨가 다음 정류장에서 다음 칸에 탐subway.append(\"하하\")# 정형돈 씨를 유재석 / 조세호 사이에 태워봄subway.insert(1, \"정형돈\")# 지하철에 있는 사람을 한 명 씩 뒤에서 꺼냄print(subway.pop())# 같은 이름의 사람이 몇 명 있는지 확인subway.append(\"유재석\")print(subway.count(\"유재석\"))# 정렬num_list = [5,2,4,3,1]num_list.sort()# 순서 뒤집기num_list.reverse()# 모두 지우기num_list.clear()# 다양한 자료형 함께 사용num_list = [5,2,4,3,1]mix_list = [\"유재석\", 20, True]# 리스트 확장num_list.extend(mix_list) 사전 1234567891011121314151617181920212223242526272829303132cabinet = &#123;3:\"유재석\", 100:\"김태호\"&#125;print(cabinet[3])print(cabinet[100])print(cabinet.get(3))print(cabinet.get(5, \"사용 가능\"))print(3 in cabinet) # Trueprint(5 in cabinet) # Falsecabinet = &#123;\"A-3\":\"유재석\", \"B-100\":\"김태호\"&#125;print(cabinet[\"A-3\"])print(cabinet[\"B-100\"])# 새 손님cabinet[\"A-3\"] = \"김종국\" # 업데이트cabinet[\"C-20\"] = \"조세호\" # 추가# 간 손님del cabinet[\"A-3\"]# key 들만 출력print(cabinet.keys())# value 들만 출력print(cabinet.values())# key, value 쌍으로 출력print(cabinet.items())# 전체 삭제cabinet.clear() 튜플 1234menu = (\"돈까스\", \"치즈까스\")(name, age, hobby) = (\"김종국\", 20, \"코딩\")print(name, age, hobby) 세트 12345678910111213141516171819202122232425# 집합 (set)# 중복 안됨, 순서 없음my_set = &#123;1,2,3,3,3&#125;print(my_set)java = &#123;\"유재석\", \"김태호\", \"양세형\"&#125;python = set([\"유재석\", \"박명수\"])# 교집합 (java 와 python 을 모두 할 수 있는 개발자)print(java &amp; python)print(java.intersection(python))# 합집합 (java 할 수 있거나 python 도 할 수 있는 개발자)print(java | python)print(java.union(python))# 차집합 (java 할 수 있지만 python 은 할 줄 모르는 개발자)print(java - python)print(java.difference(python))# python 할 줄 아는 사람이 늘어남python.add(\"김태호\")# java 를 잊어버림java.remove(\"김태호\") 자료구조의 변경 123456789101112# 커피숍menu = &#123;\"커피\", \"우유\", \"주소\"&#125;print(menu, type(menu)) # &#123;'커피', '주소', '우유'&#125; &lt;class 'set'&gt;menu = list(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'list'&gt;menu = tuple(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'tuple'&gt;menu = set(menu)print(menu, type(menu)) # ['커피', '주소', '우유'] &lt;class 'set'&gt; if 1234567891011121314151617weather = input(\"오늘 날씨는 어때요?\")if weather == \"비\" or weather == \"눈\": print(\"우산을 챙기세요\")elif weather == \"미세먼지\": print(\"마스크를 챙기세요\")else: print(\"준비물 필요 없어요\")temp = int(input(\"기운은 어때요?\"))if 30 &lt;= temp: print(\"너무 더워요. 나가지 마세요\")elif 10 &lt;= temp and temp &lt; 30: print(\"괜찮은 날씨에요\")elif 0 &lt;= temp &lt; 10: print(\"외투를 챙기세요\")else: print(\"너무 추워요. 나가지 마세요\") for 123# randrange()for waiting_no in range(1, 6): # 1, 2, 3, 4, 5 print(\"대기번호 : &#123;0&#125;\".format(waiting_no)) while 12345customer = \"토르\"person = \"Unknown\"while person != customer: print(\"&#123;0&#125;, 커피가 준비 되었습니다.\".format(customer)) person = input(\"이름이 어떻게 되세요?\") 한 줄 for 123456students = [1,2,3,4,5]students = [i+100 for i in students]# 학생 이름을 길이도 반환students = [\"Iron man\", \"Thor\", \"I am groot\"]students = [len(i) for i in students]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"}]},{"title":"[Angular] Angular Cli 설치 및 사용 방법","slug":"angular-1","date":"2022-07-28T11:31:14.000Z","updated":"2024-01-12T01:23:28.767Z","comments":true,"path":"2022/07/28/angular-1/","link":"","permalink":"http://hgko1207.github.io/2022/07/28/angular-1/","excerpt":"","text":"Angular는 Angular CLI를 이용해 프로젝트 관리의 복잡도를 낮추고 Angular 개발에만 집중할 수 있게 합니다. 설치 Angular CLI를 설치하려면 다음과 같은 npm 명령어를 실행합니다. 1$ npm install -g @angular/cli 설치가 완료되면 ng 명령어를 사용할 수 있습니다. ng 명령어는 Angular CLI에서 제공하는 기능들을 실행하는 역할을 담당합니다. Angular CLI 도움말 옵션을 사용해 확인해 봅니다. 1234567891011121314151617181920212223242526272829303132$ ng --helpng &lt;command&gt;Commands: ng add &lt;collection&gt; Adds support for an external library to your project. ng analytics Configures the gathering of Angular CLI usage metrics. ng build [project] Compiles an Angular application or library into an output directory named dist/ at the given output path. [aliases: b] ng cache Configure persistent disk cache and retrieve cache statistics. ng completion Set up Angular CLI autocompletion for your terminal. ng config [json-path] [value] Retrieves or sets Angular configuration values in the angular.json file for the workspace. ng deploy [project] Invokes the deploy builder for a specified project or for the default project in the workspace. ng doc &lt;keyword&gt; Opens the official Angular documentation (angular.io) in a browser, and searches for a given keyword. [aliases: d] ng e2e [project] Builds and serves an Angular application, then runs end-to-end tests. [aliases: e] ng extract-i18n [project] Extracts i18n messages from source code. ng generate Generates and/or modifies files based on a schematic. [aliases: g] ng lint [project] Runs linting tools on Angular application code in a given project folder. ng new [name] Creates a new Angular workspace. [aliases: n] ng run &lt;target&gt; Runs an Architect target with an optional custom builder configuration defined in your project. ng serve [project] Builds and serves your application, rebuilding on file changes. [aliases: s] ng test [project] Runs unit tests in a project. [aliases: t] ng update [packages..] Updates your workspace and its dependencies. See https://update.angular.io/. ng version Outputs Angular CLI version. [aliases: v]Options: --help Shows a help message for this command in the console. [boolean]For more information, see https://angular.io/cli/. 프로젝트 생성 Angular 프로젝트를 생성하려면 ng new 명령어를 사용합니다. 1$ ng new [프로젝트명] ng new 명령어 다음에 프로젝트 이름을 지정하면 프로젝트 이름과 일치하는 새로운 프로젝트 폴더가 생성되고 스캐폴딩(프로젝트 기본 골격)이 작성됩니다. 프로젝트 이름을 my-app로 지정하여 프로젝트를 생성합니다. 1$ $ ng new my-app 프로젝트가 생성되면 아래와 같은 파일 구조의 스캐폴딩이 생성됩니다. 12345678910111213my-app&#x2F;├── .git&#x2F;├── node_modules&#x2F;├── src&#x2F;├── .editorconfig├── .gitignore├── angular.json├── package-lock.json├── package.json├── README.md├── tsconfig.app.json├── tsconfig.json└── tsconfig.spec.json 시작 프로젝트 폴더로 이동한 후 실행합니다. 1$ npm start 또는 ng serve 명령어를 사용합니다. 1$ ng serve 이미 포트 4200번을 사용하고 있다면 Angular CLI 내장 서버를 실행할 수 없습니다. 포트번호를 변경해 실행하려면 다음과 같이 --port(축약형 -p) 옵션을 추가한다. 1$ ng serve --port 4201 Build 빌드 결과는 기본적으로 dist/ 폴더에 저장됩니다. 1$ ng build 컴포넌트 생성 1$ ng generate component [component-name] 간략하게 명령어를 사용할 수 있습니다. 1$ ng g c [component-name] 사용 예시입니다. 123$ ng g c section$ ng g m section$ ng g c section/card ng generate directive|pipe|service|class|guard|interface|enum|module 명령어를 통해 컴포넌트 외에 다른 파일들을 생성할 수 있습니다. Running unit tests Karma를 통해 단위 테스트를 할 수 있습니다. 1$ ng test Running end-to-end tests 선택한 플랫폼을 통해 end-to-end 테스트를 실행합니다. 이 명령을 사용하려면 먼저 end-to-end 테스트 기능을 구현하는 패키지를 추가해야 합니다. 1$ ng e2e 참고 Angular CLI https://angular.io/cli https://angular.io/tutorial https://material.angular.io/ https://angular.io/guide/devtools https://blog.angular.io/ vscode 플러그인 Angular Files Angular Language Service TypeScript Hero: 소스 코드 관리에 필요한 TypeScript 코드 정렬을 도와주는 Plugin","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"}]},{"title":"[React] Recoil 사용 방법","slug":"react-6","date":"2022-07-25T13:54:57.000Z","updated":"2024-01-12T01:22:15.595Z","comments":true,"path":"2022/07/25/react-6/","link":"","permalink":"http://hgko1207.github.io/2022/07/25/react-6/","excerpt":"","text":"Recoil 사용 방법에 대해 알아보겠습니다. Recoil Recoil는 페이스북에서 만든 React를 위한 상태 관리 라이브러리입니다. Recoil을 사용하면 atoms (공유 상태)에서 selectors (순수 함수)를 거쳐 React 컴포넌트로 내려가는 data-flow graph를 만들 수 있습니다. 설치 Recoil 패키지는 npm에 존재합니다. 안정한 최신 버전을 설치하기 위해서는 다음의 명령어를 실행하면 됩니다. 1$ npm install recoil 또는 yarn을 사용한다면 이 명령어를 사용하면 됩니다. 1$ yarn add recoil RecoilRoot 루트에 RecoilRoot를 감싸줍니다. 12345678910111213// index.tsximport &#123; RecoilRoot &#125; from 'recoil';import ToggleOutput from './ToggleOutput';import ToggleButton from './ToggleButton';function App() &#123; return ( &lt;RecoilRoot&gt; &lt;ToggleOutput /&gt; &lt;ToggleButton /&gt; &lt;/RecoilRoot&gt; );&#125; 사용 Atoms Atoms는 상태(state)의 일부를 나타냅니다. Atoms는 어떤 컴포넌트에서나 읽고 쓸 수 있습니다. atoms.ts 파일을 생성하고 Recoil의 atom function 을 사용하여 필요한 데이터를 설정합니다. atom 은 두 가지를 요구하는데 첫 번째는 key 로 unique ID 이고 두 번째는 default value입니다. 1234567// atoms.tsimport &#123; atom &#125; from 'recoil';export const isToggleAtom = atom(&#123; key: 'isToggle', default: false,&#125;); 컴포넌트가 atom을 읽게 하기 위해서는 useRecoilValue()를 다음과 같이 사용하면 됩니다. 123456789// ToggleOutput.tsximport &#123; useRecoilValue &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleOutput() &#123; const isToggle = useRecoilValue(isToggleAtom); return &lt;div&gt;Toggle state: &#123;isToggle&#125;&lt;/div&gt;;&#125; 컴포넌트가 atom을 쓰게 하기 위해서는 useSetRecoilState()를 다음과 같이 사용하면 됩니다. atom을 읽고 쓰게 하기 위해서는 useRecoilState()를 사용하면 됩니다. 12345678910111213141516// ToggleButton.tsximport &#123; useSetRecoilState &#125; from 'recoil';import &#123; isToggleAtom &#125; from './atoms';function ToggleButton() &#123; const setToggleAtom = useSetRecoilState(isToggleAtom); const toggle = () =&gt; setToggleAtom((prev) =&gt; !prev); return ( &lt;div&gt; &lt;br /&gt; &lt;button onClick=&#123;toggle&#125;&gt;Toggle Mode&lt;/button&gt; &lt;/div&gt; );&#125; Selectors Selectors는 devived state를 나타냅니다. devived state 란 state 를 입력받아서 그걸 변형해 반환하는 순수 함수를 거쳐 반환된 값을 말합니다. atom의 output은 한 가지 형태이므로 조금 더 잘 써먹을 수 있는 형태로 변형해 줍니다. 12345678910111213141516171819202122export interface IToDo &#123; text: string; id: number; category: 'TO_DO' | 'DOING' | 'DONE';&#125;export const toDoState = atom&lt;IToDo[]&gt;(&#123; key: 'toDo', default: [],&#125;);export const toDoSelector = selector(&#123; key: 'toDoSelector', get: (&#123; get &#125;) =&gt; &#123; const toDos = get(toDoState); return [ toDos.filter((toDo) =&gt; toDo.category === 'TO_DO'), toDos.filter((toDo) =&gt; toDo.category === 'DOING'), toDos.filter((toDo) =&gt; toDo.category === 'DONE'), ]; &#125;,&#125;); category 값을 3개의 타입 형태로 사용할 경우 타입 별로 값을 반환하고 싶을 때 selector를 사용하여 atom에서 각각의 타입 별로 값을 분류하고 합쳐서 하나의 값으로 반환합니다. 참고 https://recoiljs.org/ko/docs/introduction/getting-started https://recoiljs.org/docs/basic-tutorial/selectors/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"}]},{"title":"[React] ApexCharts 사용 방법","slug":"react-5","date":"2022-07-24T13:16:30.000Z","updated":"2024-01-12T01:20:31.691Z","comments":true,"path":"2022/07/24/react-5/","link":"","permalink":"http://hgko1207.github.io/2022/07/24/react-5/","excerpt":"","text":"ApexCharts는 데이터를 시각화해주는 차트 라이브러리입니다. 무료로 사용할 수 있고, Js, Angular, React, Vue를 지원합니다. ApexCharts를 사용하여 React.js 에서 간단하게 차트 만드는 방법에 대해 알아보겠습니다. 설치 apexcharts 와 react-apexcharts 라이브러리를 같이 설치합니다. 1$ npm install --save react-apexcharts apexcharts 사용 코인 정보를 조회하여 차트를 구성하였습니다. Line Chart를 예제로 사용하였습니다. 1234567891011// api.tsconst BASE_URL = `https://api.coinpaprika.com/v1`;// 코인 정보 조회export function fetchCoinHistory(coinId: string) &#123; const endDate = Math.floor(Date.now() / 1000); const startDate = endDate - 60 * 60 * 23; // 하루치 조회 return fetch(`$&#123;BASE_URL&#125;/coins/$&#123;coinId&#125;/ohlcv/historical?start=$&#123;startDate&#125;&amp;end=$&#123;endDate&#125;`).then((reponse) =&gt; reponse.json() );&#125; https://apexcharts.com/docs/options/# 페이지를 참고하여 옵션을 커스텀합니다. 테마, x축, y축, 색상, 툴바 감추기, 크기, 툴팁 설정 등 세세한 부분까지 커스텀할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Chart.tsximport &#123; useQuery &#125; from 'react-query';import &#123; useOutletContext &#125; from 'react-router';import &#123; fetchCoinHistory &#125; from '../api';import ApexChart from 'react-apexcharts';interface IHistorical &#123; time_open: string; time_close: string; open: number; high: number; low: number; close: number; volume: number; market_cap: number;&#125;function Chart() &#123; const coinId = useOutletContext() as string; const &#123; isLoading, data &#125; = useQuery&lt;IHistorical[]&gt;(['ohlcv', coinId], () =&gt; fetchCoinHistory(coinId)); return ( &lt;div&gt; &#123;isLoading ? ( 'Loading chart...' ) : ( &lt;ApexChart type=\"line\" series=&#123;[ &#123; name: 'Price', data: data?.map((price) =&gt; price.close) as number[], &#125;, ]&#125; options=&#123;&#123; theme: &#123; mode: 'dark', &#125;, chart: &#123; height: 300, width: 500, toolbar: &#123; show: false, &#125;, background: 'transparent', &#125;, grid: &#123; show: false, &#125;, stroke: &#123; curve: 'smooth', width: 4, &#125;, yaxis: &#123; show: false, &#125;, xaxis: &#123; type: 'datetime', categories: data?.map((price) =&gt; price.time_close), labels: &#123; style: &#123; colors: '#9c88ff', &#125;, &#125;, &#125;, fill: &#123; type: 'gradient', gradient: &#123; gradientToColors: ['blue'], stops: [0, 100], &#125;, &#125;, colors: ['red'], tooltip: &#123; y: &#123; formatter: (value) =&gt; `$$&#123;value.toFixed(2)&#125;`, &#125;, &#125;, &#125;&#125; /&gt; )&#125; &lt;/div&gt; );&#125;export default Chart; 참고 https://apexcharts.com/docs/react-charts/ https://apexcharts.com/docs/options/# https://api.coinpaprika.com/#tag/Coins/paths/1coins1{coin_id}1ohlcv1historical/get","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"}]},{"title":"[React] React Query","slug":"react-4","date":"2022-07-22T15:07:58.000Z","updated":"2024-01-12T01:19:53.638Z","comments":true,"path":"2022/07/23/react-4/","link":"","permalink":"http://hgko1207.github.io/2022/07/23/react-4/","excerpt":"","text":"React Query는 데이터 Fetching, 캐싱, 동기화, 업데이트, 에러핸들링 등 비동기 과정을 쉽게 만들어 주는 React 라이브러리입니다. React Query를 사용하면 기존의 서버 데이터를 가져오거나 업데이트하는 코드를 축약할 수 있고 캐싱 처리가 간단해졌습니다. 간단하게 useQuery를 사용하여 코인들의 정보를 조회하는 코드를 통해 React Query 사용 전 후를 비교하였었습니다. 설치 123$ npm i react-queryor$ yarn add react-query useQuery 서버에서 데이터를 가져오기 위해 모든 Promise 기반 메서드(GET 및 POST 포함)와 함께 사용할 수 있습니다. 첫 번째 파라미터는 unique Key이고, 두 번째는 비동기 함수(api호출 함수)입니다. return 개체에는 api의 로딩상태, 성공, 실패여부, 결과 데이터를 포함한 객체입니다. React Query 사용 전 코인들의 정보를 조회하는 코드입니다. useState를 사용하여 코인 데이터와 조회 상태를 따로 관리하였었습니다. 12345678910111213141516171819202122232425262728293031// Coins.tsximport &#123; useEffect, useState &#125; from 'react';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;function Coins() &#123; const [coins, setCoins] = useState&lt;ICoin[]&gt;([]); const [loading, setLoading] = useState(true); useEffect(() =&gt; &#123; (async () =&gt; &#123; const response = await fetch('https://api.coinpaprika.com/v1/coins'); const json = await response.json(); setCoins(json.slice(0, 100)); setLoading(false); &#125;)(); &#125;, []); return ( ... );&#125;export default Coins; React Query 사용 후 먼저 React Query를 사용하도록 세팅합니다. 12345678910111213141516// index.tsximport React from 'react';import ReactDOM from 'react-dom';import App from './App';import &#123; QueryClient, QueryClientProvider &#125; from 'react-query';const queryClient = new QueryClient();ReactDOM.render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 코인들의 정보를 조회하는 코드를 별도 파일을 생성하여 관리합니다. 1234// api.tsexport function fetchCoins() &#123; return fetch('https://api.coinpaprika.com/v1/coins').then((reponse) =&gt; reponse.json());&#125; React Query를 사용하기 전과 비교하면 많은 코드가 제거된 것을 확인할 수 있습니다. 12345678910111213141516171819202122import &#123; useQuery &#125; from 'react-query';import &#123; fetchCoins &#125; from '../api';interface ICoin &#123; id: string; name: string; symbol: string; rank: number; is_new: boolean; is_active: boolean; type: string;&#125;// coins.tsxfunction Coins() &#123; const &#123; isLoading, isError, data &#125; = useQuery&lt;ICoin[]&gt;('allCoins', fetchCoins); return ( ... );&#125;export default Coins; useQuery 파라미터와 결과 값을 다음과 같이 변형해서 사용할 수 있습니다. 123const &#123; isLoading: infoLoding, data: infoData &#125; = useQuery&lt;InfoData&gt;(['info', coinId], () =&gt; fetchCoinInfo(coinId as string)); Devtools React Query는 query 데이터를 시각화 하기 위해서 Devtools(Developer Tools, 개발자도구)를 기능을 가지고 있습니다. 1234567891011// App.tsximport &#123; ReactQueryDevtools &#125; from 'react-query/devtools';function App() &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &#123;/* The rest of your application */&#125; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; /&gt; &lt;/QueryClientProvider&gt; );&#125; initialIsOpen: 개발자도구가 기본적으로 열려 있도록 하려면 true로 설정 참고 https://react-query-v3.tanstack.com/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"}]},{"title":"[React] Nested Routes","slug":"react-3","date":"2022-07-21T15:59:11.000Z","updated":"2024-01-12T01:18:32.004Z","comments":true,"path":"2022/07/22/react-3/","link":"","permalink":"http://hgko1207.github.io/2022/07/22/react-3/","excerpt":"","text":"Nested Routes는 route 안에 있는 또 다른 route입니다. React Router 가 v6로 바뀌면서 Nested Routes 만 아니라 Route 사용하는 방법이 바뀌었습니다. 전 5 버전과 현재 6 버전 사용법을 비교하였습니다. React Router v5 nested routes 구현하는 방법은 자식 route를 부모 route의 element 내부에 작성하는 것입니다. 1234567891011121314151617181920// Router.tsximport &#123; BrowserRouter, Switch, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/:coinId\"&gt; &lt;Coin /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Coins /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 12345678910111213141516171819202122// Coin.tsximport &#123; Switch, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Switch&gt; &lt;Route path=\"price\"&gt; &lt;Price /&gt; &lt;/Route&gt; &lt;Route path=\"chart\"&gt; &lt;Chart /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Container&gt; );&#125;export default Coin; React Router v6 nested routes를 구현하는 방법은 두 가지가 있습니다. 6 버전에서는 Switch 가 Routes로 변경됐습니다. 첫 번째 부모 route의 path 마지막에 /*를 적어 명시적으로 이 route의 내부에서 nested route 가 render 될 수 있음을 표시하고 자식 route를 부모 route의 element 내부에 작성하는 방법입니다. 1234567891011121314151617// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Coin from './routes/Coin';import Coins from './routes/Coins';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId/*\" element=&#123;&lt;Coin /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415161718// Coin.tsximport &#123; Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Routes&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/Container&gt; );&#125;export default Coin; 두 번째 자식 route 를 부모 element의 내부가 아닌 Router 내부에 작성하는 방법입니다. 그리고 이 자식 Route들이 어디에 render 될지 부모의 element 안에 Outlet을 이용해 표시해 주면 됩니다. 12345678910111213141516171819202122// Router.tsximport &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom';import Chart from './routes/Chart';import Coin from './routes/Coin';import Coins from './routes/Coins';import Price from './routes/Price';function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=\"/:coinId\" element=&#123;&lt;Coin /&gt;&#125;&gt; &lt;Route path=\"price\" element=&#123;&lt;Price /&gt;&#125; /&gt; &lt;Route path=\"chart\" element=&#123;&lt;Chart /&gt;&#125; /&gt; &lt;/Route&gt; &lt;Route path=\"/\" element=&#123;&lt;Coins /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );&#125;export default Router; 123456789101112131415// Coin.tsximport &#123; Outlet, Routes, Route &#125; from 'react-router-dom';function Coin() &#123; return ( &lt;Container&gt; &lt;Header&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/Header&gt; &lt;Outlet /&gt; &lt;/Container&gt; );&#125;export default Coin; 참고 https://ui.dev/react-router-nested-routes https://reactrouter.com/docs/en/v6/getting-started/overview","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"}]},{"title":"[JPA] 복합키 사용","slug":"spring-jpa-2","date":"2022-07-13T10:21:50.000Z","updated":"2024-01-12T01:17:15.844Z","comments":true,"path":"2022/07/13/spring-jpa-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/13/spring-jpa-2/","excerpt":"","text":"서론 복합키는 기본키가 되지 못하는 칼럼들을 서로 묶어서 기본키처럼 사용하는 것입니다. Entity 예를 들어 사용자명과 이메일을 복합키로 사용한다고 가정합니다. 복합키로 묶는 CompositePK 클래스를 생성하고, @IdClass 어노테이션을 사용하여 설정합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = \"tb_user\")@IdClass(CompositePK.class) //이름과 이메일을 primary key로 사용@Datapublic class User &#123; @Data @AllArgsConstructor @NoArgsConstructor public static class CompositePK implements Domain &#123; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 이메일 */ @Column(length = 45) private String email; &#125; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Repository 인터페이스를 생성하고 JpaRepository 를 상속받습니다. 12public interface UserRepository extends JpaRepository&lt;User, CompositePK&gt; &#123;&#125; 사용 Service 클래스를 생성하고 Repository 인터페이스를 불러와서 사용합니다. 1234567891011@Service@Transactionalpublic class UserService &#123; @Autowired private UserRepository userRepository; public User get(CompositePK id) &#123; return userRepository.findById(id).orElse(null); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"}]},{"title":"[React] TypeScript 사용 방법","slug":"react-2","date":"2022-07-03T14:52:45.000Z","updated":"2024-01-12T01:16:06.112Z","comments":true,"path":"2022/07/03/react-2/","link":"","permalink":"http://hgko1207.github.io/2022/07/03/react-2/","excerpt":"","text":"React에서 TypeScript를 적용하고 사용 방법에 대해 알아보겠습니다. 설치 create-react-app 명령어에 typescript 옵션을 추가합니다. 1$ npx create-react-app typescript --template typescript Typescript를 추가하지 않은 기존 프로젝트가 있다면 다음 명령어를 실행하여 설치합니다. 1$ npm install --save typescript @types/node @types/react @types/react-dom @types/jest Typescript 사용 시 styled-components 부분에서 에러가 날 경우 다음 명령어를 실행하여 설치합니다. 1$ npm i --save-dev @types/styled-components Typing the Props Prop Types는 코드를 실행한 후 에만 브라우저의 콘솔에 경고 표시로 확인이 가능합니다. TypeScript를 사용하는 이유는 코드가 실행되기 전에 오류를 확인하기 위해서입니다. interface는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있습니다. 123456789101112import Circle from './Circle';function App() &#123; return ( &lt;div&gt; &lt;Circle bgColor=\"teal\" /&gt; &lt;Circle bgColor=\"tomato\" /&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718import styled from 'styled-components';interface CircleProps &#123; bgColor: string;&#125;const Container = styled.div&lt;CircleProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;;`;function Circle(&#123; bgColor &#125;: CircleProps) &#123; return &lt;Container bgColor=&#123;bgColor&#125; /&gt;;&#125;export default Circle; Optional Props props는 기본으로 required 이지만 interface의 object 뒤에 ?를 추가하여 optional 될 수 있도록 변경 가능합니다. 123456789101112131415161718192021222324252627282930import styled from 'styled-components';interface ContainerProps &#123; bgColor: string; borderColor: string;&#125;const Container = styled.div&lt;ContainerProps&gt;` width: 200px; height: 200px; border-radius: 100px; background-color: $&#123;(props) =&gt; props.bgColor&#125;; border: 1px solid $&#123;(props) =&gt; props.borderColor&#125;;`;interface CircleProps &#123; bgColor: string; borderColor?: string; // object뒤에 ?를 추가 =&gt; Option props text?: string;&#125;function Circle(&#123; bgColor, borderColor, text = 'default text' &#125;: CircleProps) &#123; return ( &lt;Container bgColor=&#123;bgColor&#125; borderColor=&#123;borderColor ?? 'white'&#125;&gt; &#123;text&#125; &lt;/Container&gt; );&#125;export default Circle; State State 사용 시 number, string 타입을 같이 쓰고 싶다면 다음과 같이 정의합니다. 1234const [value, setValue] = useState&lt;number | string&gt;(0);setValue(1);setValue('hello');setValue(true); // error Event https://reactjs.org/docs/events.html SyntheticEvent는 기본적으로 ReactJS 버전의 이벤트입니다. 이벤트들의 정보를 확인하는 사이트입니다. Form React.FormEvent&lt;HTMLInputElement&gt; 또는 React.FormEvent&lt;HTMLFormElement&gt;와 같은 Element를 사용함으로써 event를 보호하고 어떤 event 를 받는지 알 수 있습니다. 12345678910111213141516171819202122232425import React, &#123; useState &#125; from 'react';function App() &#123; const [value, setValue] = useState(''); const onChange = (event: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; currentTarget: &#123; value &#125;, &#125; = event; setValue(value); &#125;; const onSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault(); console.log(value); &#125;; return ( &lt;div&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; type=\"text\" placeholder=\"username\" /&gt; &lt;button&gt;Log in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;export default App; Theme https://styled-components.com/docs/api#typescript styled.d.ts 파일을 생성합니다. 12345678910// styled.d.tsimport 'styled-components';declare module 'styled-components' &#123; export interface DefaultTheme &#123; textColor: string; bgColor: string; btnColor: string; &#125;&#125; thmem.ts 파일을 생성하고 테마를 정의합니다. 1234567891011121314// thmem.tsimport &#123; DefaultTheme &#125; from 'styled-components';export const lightTheme: DefaultTheme = &#123; bgColor: 'white', textColor: 'black', btnColor: 'tomato',&#125;;export const darkTheme: DefaultTheme = &#123; bgColor: 'black', textColor: 'white', btnColor: 'teal',&#125;; React에서 테마 사용하는 것과 똑같은 방식입니다. 123456789101112131415// index.tsximport React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';import &#123; lightTheme &#125; from './theme';ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;lightTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 참고 https://create-react-app.dev/docs/adding-typescript/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"}]},{"title":"[React] Styled Components 사용 방법","slug":"react-1","date":"2022-06-28T14:36:34.000Z","updated":"2024-01-12T01:15:07.134Z","comments":true,"path":"2022/06/28/react-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/28/react-1/","excerpt":"","text":"React에서 Styled Components를 사용하는 방법에 대해 알아보겠습니다. 설치 Visual Studio Code를 사용 시 Styled-Component 자동 완성을 위해 vscode-styled-components 플러그인을 설치합니다. 1$ npm i styled-components https://styled-components.com/ 사용 예 123456789101112131415161718192021222324252627282930import styled from 'styled-components';const Father = styled.div` display: flex;`;const BoxOne = styled.div` background-color: teal; width: 100px; height: 100px;`;const BoxTwo = styled.div` background-color: tomato; width: 100px; height: 100px;`;const Text = styled.span` color: white;`;function App() &#123; return ( &lt;Father&gt; &lt;BoxOne&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/BoxOne&gt; &lt;BoxTwo /&gt; &lt;/Father&gt; );&#125;export default App; 확장 컴포넌트를 확장하는 방법입니다. 12345678const Box = styled.div` background-color: $&#123;(props) =&gt; props.bgColor&#125;; width: 100px; height: 100px;`;const Circle = styled(Box)` border-radius: 50px;`; ‘As’ and Attrs 다음과 같이 as 속성을 사용하여 값을 a로 지정하면 button 태그가 a 태그로 변경됩니다. 12345678const Btn = styled.button` color: white; background-color: tomato; border: 0; border-radius: 15px;`;&lt;Btn as=\"a\"&gt;Log in&lt;/Btn&gt;; 속성 값 설정 attrs을 사용하여 HTML 태그에 속성 값을 설정할 수 있습니다. 123const Input = styled.input.attrs(&#123; require: true, minLength: 10 &#125;)` background-color: tomato;`; Animation keyframes를 추가하고, Animation 을 설정합니다. 그리고 styled components에 ${}를 통해 설정된 변수를 지정합니다. 123456789101112131415161718192021222324252627282930313233343536import styled, &#123; keyframes &#125; from 'styled-components';const rotationAnimation = keyframes` 0% &#123; transform: rotate(0deg); border-radius: 0px; &#125; 50% &#123; border-radius: 100px; &#125; 100% &#123; transform: rotate(360deg); border-radius: 0px; &#125;`;const Wrapper = styled.div` display: flex;`;const Box = styled.div` height: 200px; width: 200px; background-color: tomato; animation: $&#123;rotationAnimation&#125; 1s linear infinite;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Box /&gt; &lt;/Wrapper&gt; );&#125;export default App; Theme index.js 파일에서 ThemeProvider를 styled-components로 부터 Import 한 후 App 태그를 감쌉니다. Theme에 어떤 색을 사용할 건지 설정합니다. 1234567891011121314151617181920212223import React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'styled-components';import App from './App';const darkTheme = &#123; textColor: 'whitesmoke', backgroundColor: '#111',&#125;;const lightTheme = &#123; textColor: '#111', backgroundColor: 'whitesmoke',&#125;;ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme=&#123;darkTheme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 위에서 설정한 Theme 변수를 사용합니다. Theme가 변경되면 Title이나 Wrapper 안의 글자 색상과 배경색이 변화되는 것을 확인할 수 있습니다. 123456789101112131415161718192021222324import styled from 'styled-components';const Title = styled.h1` color: $&#123;(props) =&gt; props.theme.textColor&#125;;`;const Wrapper = styled.div` display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; background-color: $&#123;(props) =&gt; props.theme.backgroundColor&#125;;`;function App() &#123; return ( &lt;Wrapper&gt; &lt;Title&gt;Hello&lt;/Title&gt; &lt;/Wrapper&gt; );&#125;export default App;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"}]},{"title":"[WPF] ffmpeg을 활용한 동영상 만들기","slug":"wpf-7","date":"2022-06-24T14:06:59.000Z","updated":"2024-01-12T01:13:51.939Z","comments":true,"path":"2022/06/24/wpf-7/","link":"","permalink":"http://hgko1207.github.io/2022/06/24/wpf-7/","excerpt":"","text":"FFmpeg Build 다운로드하기 https://ffmpeg.org/download.html#build-windows 사이트에서 Windows EXE Files 항목의 원하는 형식으로 다운로드를 합니다. 다운로드한 후 압축해제 합니다. 프로젝트의 ffmpeg 폴더를 생성 후 실행에 사용되는 exe, dll 파일들을 복사합니다. Bitmap들을 동영상으로 만들기 FFmpegLoader ffmpeg를 사용하기 위해 FFMediaToolkit 패키지를 Nuget을 이용하여 설치합니다. FFmpegLoader를 사용하여 Path를 지정합니다. 12// 예FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; 동영상에 프레임 추가 아래는 예제코드입니다. StartRecordVideo 함수에 저장될 경로를 지정하여 mediaFile을 생성합니다. 그리고 AddRecordFrame 함수를 통해 Bitmap 이미지를 설정한 30fps로 동영상에 추가합니다. 이렇게 생성된 동영상은 MPEG2 형식이므로 MPEG4 형식으로 변경합니다. MPEG2 형식의 동영상은 가끔 윈도우 환경에서 오류가 발생하는 경우가 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using FFMediaToolkit;using FFMediaToolkit.Encoding;using FFMediaToolkit.Graphics;namespace Hgko.Utils&#123; public class ImageService &#123; private bool ffmpegInit = false; private MediaOutput mediaFile = null; /// &lt;summary&gt; /// Start Record video /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public void StartRecordVideo(string path) &#123; if (mediaFile == null) &#123; if (!ffmpegInit) &#123; FFmpegLoader.FFmpegPath = @\".\\ffmpeg\"; ffmpegInit = true; &#125; int width = 1024; int heigth = 1024; VideoEncoderSettings settings = new VideoEncoderSettings(width, heigth, 30, VideoCodec.MPEG2); settings.EncoderPreset = EncoderPreset.Medium; mediaFile = MediaBuilder.CreateContainer(path).WithVideo(settings).Create(); &#125; &#125; /// &lt;summary&gt; /// Add RecordFrame /// &lt;/summary&gt; /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt; public void AddRecordFrame(Bitmap bitmap) &#123; if (bitmap == null) return; if (mediaFile == null) return; System.Drawing.Imaging.BitmapData bdata = bitmap.LockBits(new Rectangle(System.Drawing.Point.Empty, bitmap.Size), System.Drawing.Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat); ImageData imgdata = ImageData.FromPointer(bdata.Scan0, ImagePixelFormat.Bgra32, bitmap.Size); mediaFile.Video.AddFrame(imgdata); bitmap.UnlockBits(bdata); &#125; /// &lt;summary&gt; /// Stop Record Video /// &lt;/summary&gt; public void StopRecordVideo() &#123; if (mediaFile != null) &#123; mediaFile.Video.Dispose(); mediaFile.Dispose(); mediaFile = null; &#125; &#125; &#125;&#125; 동영상 포맷 변환 임시로 빌드되는 경로에 display/video 경로의 폴더를 생성합니다. 포맷 변환하는 방법은 많습니다. 다음 코드는 여러 이미지 또는 동영상을 합쳐서 새로운 동영상으로 만드는 형식의 방법을 활용하여 포맷 변환을 진행합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.IO;/// &lt;summary&gt;/// End Record Video/// &lt;/summary&gt;/// &lt;param name=\"mp2Path\"&gt;mp2 형식으로 저장된 파일경로&lt;/param&gt;public void EndRecordVideo(string mp2Path)&#123; string videoWorkingPath = @\".\\display\\video\\\"; string vedeoWorkingFolder = Directory.GetCurrentDirectory() + videoWorkingPath.Replace(\".\", \"\"); string outputVeideoPath = vedeoWorkingFolder + Path.GetFileNameWithoutExtension(mp2Path) + \".mp4\" // if exist video working directory, clean up. if (Directory.Exists(videoWorkingPath)) ClearFolder(videoWorkingPath); // remake working dir. Directory.CreateDirectory(videoWorkingPath); Task.Run(() =&gt; &#123; string lstPath = vedeoWorkingFolder + \"lst.txt\"; // 텍스트 파일에 앞에서 생성된 mp2 동영상 파일 경로 추가 using (StreamWriter writer = File.CreateText(lstPath)) &#123; writer.WriteLine(\"file '&#123;0&#125;'\", mp2Path); &#125; // h264 or mpeg4 string codec = \"h264\"; // 동영상 포맷 변환(mp2 -&gt; mp4) string arg = $@\"-safe 0 -f concat -i \"\"&#123;lstPath&#125;\"\" -c copy -vcodec \"\"&#123;codec&#125;\"\" \"\"&#123;outputVeideoPath&#125;\"\"\"; using (Process process = Process.Start(@\".\\ffmpeg\\ffmpeg.exe\", arg)) &#123; process.WaitForExit(); &#125; &#125;);&#125;/// &lt;summary&gt;/// Clear Folder/// &lt;/summary&gt;/// &lt;param name=\"path\"&gt;삭제할 경로&lt;/param&gt;public static void ClearFolder(string path)&#123; DirectoryInfo dir = new DirectoryInfo(path); // remove all files foreach (FileInfo fi in dir.GetFiles()) fi.Delete(); // remove dir recursive foreach (DirectoryInfo di in dir.GetDirectories()) &#123; ClearFolder(di.FullName); di.Delete(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"}]},{"title":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"book-1","date":"2022-06-22T07:05:37.000Z","updated":"2024-01-12T01:13:06.706Z","comments":true,"path":"2022/06/22/book-1/","link":"","permalink":"http://hgko1207.github.io/2022/06/22/book-1/","excerpt":"","text":"책 정보 책 소개 이 책은 제목 그대로 스프링 부트와 AWS로 웹 서비스를 구현합니다. JPA와 JUnit 테스트, 그레이들, 머스테치, 스프링 시큐리티를 활용한 소셜 로그인 등으로 애플리케이션을 개발하고, 뒤이어 AWS 인프라의 기본 사용법과 AWS EC2와 RDS를 사용해 서비스가 가능하도록 합니다. 이렇게 점진적으로 스프링 부트 프로젝트를 개선해서 배포 자동화하고 무중단 배포까지 경험합니다. 실무 현장에서의 노하우와 테스트 방법, 객체지향 프로그래밍 등을 소개하고 다룹니다. 리뷰 스프링 부트와 AWS로 웹 서비스 구현에 대한 설명이 잘 정리 되어있고, 코드만 따라 해도 완성품을 만들 수 있어 도움이 되었습니다. 다만 스프링 부트와 자바에 대한 경험이 필요합니다. 책의 예제 중에서 시간이 지나면서 안 되는 기능, 부분들은 GitHub에 오류 수정으로 설명되어 있어 찾으면서 진행하면 좋습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"}]},{"title":"[WPF] 이미지 자르기","slug":"wpf-6","date":"2022-06-20T02:02:13.000Z","updated":"2023-06-05T00:38:17.382Z","comments":true,"path":"2022/06/20/wpf-6/","link":"","permalink":"http://hgko1207.github.io/2022/06/20/wpf-6/","excerpt":"","text":"사각형, 타원, 삼각형으로 이미지를 자르기 위해 다음처럼 정의합니다. 123456public enum ShapeType&#123; Rectangle, Ellipse, Triangle,&#125; 이미지 자르기 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 자릅니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public Bitmap CreateCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; RectangleF srcRect = new Rectangle((int)left, (int)top, (int)width, (int)height); switch (shapeType) &#123; case ShapeType.Rectangle: g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); break; case ShapeType.Ellipse: &#123; int x = (int)width / 2; int y = (int)height / 2; g.SmoothingMode = SmoothingMode.AntiAlias; g.TranslateTransform(result.Width / 2, result.Height / 2); GraphicsPath gp = new GraphicsPath(); gp.AddEllipse(0 - x, 0 - y, result.Width, result.Height); Region rg = new Region(gp); g.SetClip(rg, CombineMode.Replace); g.DrawImage(image, new Rectangle(-x, -y, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Replace); g.DrawImage(image, new Rectangle(0, 0, result.Width, result.Height), srcRect, GraphicsUnit.Pixel); &#125; break; &#125; &#125; return result;&#125; 이미지 제외 나머지 부분 제거 기존 비트맵 이미지에서 주어진 위치과 크기, 도형을 통해 이미지를 제외한 나머지 부분을 제거합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Bitmap CreateInvertCroppedImage(Bitmap image, double left, double top, double width, double height, ShapeType shapeType)&#123; Bitmap result = new Bitmap(image.Width, image.Height); using (Graphics g = Graphics.FromImage(result)) &#123; switch (shapeType) &#123; case ShapeType.Rectangle: Rectangle rect = new Rectangle((int)left, (int)top, (int)width, (int)height); g.SetClip(rect, CombineMode.Exclude); break; case ShapeType.Ellipse: &#123; GraphicsPath gp = new GraphicsPath(); gp.AddEllipse((int)left, (int)top, (float)width, (float)height); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; case ShapeType.Triangle: &#123; float x1 = 0; float y1 = 0; float x2 = (float)(x1 + width); float y2 = (float)(y1 + height); PointF[] destPoints = &#123; new PointF(x1 + (x2 - x1) / 2, y1), new PointF(x2, y2), new PointF(x1, y2), &#125;; GraphicsPath gp = new GraphicsPath(); gp.AddPolygon(destPoints); Region region = new Region(gp); g.SetClip(region, CombineMode.Exclude); &#125; break; &#125; Rectangle destRect = new Rectangle(0, 0, result.Width, result.Height); Rectangle srcRect = new Rectangle(0, 0, result.Width, result.Height); g.DrawImage(image, destRect, srcRect, GraphicsUnit.Pixel); &#125; return result;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"}]},{"title":"[WPF] 이미지 불러오기","slug":"wpf-5","date":"2022-06-18T13:03:19.000Z","updated":"2023-03-14T02:23:28.017Z","comments":true,"path":"2022/06/18/wpf-5/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-5/","excerpt":"","text":"이미지 로드 이미지 파일 경로를 통해 이미지를 로드합니다. 123456789using System.Drawing.Imaging;public Bitmap LoadImage(string path)&#123; using (Bitmap bitmap = new Bitmap(path)) &#123; return bitmap.Clone(new Rectangle(0, 0, bitmap.Width, bitmap.Height), PixelFormat.Format32bppArgb); &#125;&#125; BitmapSource 변환 주어진 비트맵을 WPF 이미징 프레임워크에서 사용 가능한 BitmapSource 형식으로 변환합니다. 1234567891011121314151617181920212223242526using System.Drawing.Imaging;using System.Windows;using System.Windows.Media.Imaging;public BitmapSource ConvertGDIBitmapToWPF(Bitmap image)&#123; if (image == null) return null; Rectangle rect = new Rectangle(0, 0, image.Width, image.Height); BitmapData bitmapData = image.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb); try &#123; int size = rect.Width * rect.Height * 4; BitmapSource result = BitmapSource.Create(image.Width, image.Height, image.HorizontalResolution, image.VerticalResolution, PixelFormats.Bgra32, null, bitmapData.Scan0, size, bitmapData.Stride); result.Freeze(); return result; &#125; finally &#123; image.UnlockBits(bitmapData); &#125;&#125; 빈 비트맵 생성 주어진 크기를 갖는 빈 비트맵을 생성합니다. 123456using System.Drawing.Imaging;public Bitmap MakeEmptyImage(int width, int height)&#123; return new Bitmap(width, height, PixelFormat.Format32bppArgb);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[Devexpress] GridControl 자동 번호 매기기","slug":"wpf-4","date":"2022-06-18T02:33:14.000Z","updated":"2024-01-12T01:12:27.487Z","comments":true,"path":"2022/06/18/wpf-4/","link":"","permalink":"http://hgko1207.github.io/2022/06/18/wpf-4/","excerpt":"","text":"Devexpress GridControl의 TableView에서 행이 추가될 때마다 컬럼의 숫자가 자동 증가하도록 구현한 코드입니다. Converter 생성 IValueConverter 인터페이스를 상속받아 IndexFromOneConverter 클래스를 생성합니다. 12345678910111213141516171819202122232425using System;using System.Globalization;using System.Windows.Data;/// &lt;summary&gt;/// GridControl의 자동 생성 인덱스를 1 부터로 변환하는 컨버터/// &lt;/summary&gt;namespace IVM.Studio.Utils&#123; public class IndexFromOneConverter : IValueConverter &#123; /// &lt;summary&gt; /// 자동 증가되도록 1을 더해준다. /// &lt;/summary&gt; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; return (int)value + 1; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; return value; &#125; &#125;&#125; 적용 위에서 만든 Converter를 불러와서 GridControl에 적용합니다. 123456789101112131415161718192021222324252627282930313233343536&lt;Window x:Class=\"Test.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"d\" xmlns:util=\"clr-namespace:Test.Utils\" xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\" Title=\"Test\" Height=\"600\" Width=\"560\"&gt; &lt;Window.Resources&gt; &lt;utils:IndexFromOneConverter x:Key=\"IndexFromOneConverter\"/&gt; &lt;/Window.Resources&gt; &lt;Grid Margin=\"10\"&gt; &lt;dxg:GridControl ItemsSource=\"&#123;Binding TestInfos&#125;\" SelectedItem=\"&#123;Binding SelectedTestInfo&#125;\" SelectionMode=\"Row\" ShowBorder=\"True\" RenderOptions.EdgeMode=\"Aliased\"&gt; &lt;dxg:GridControl.View&gt; &lt;dxg:TableView AutoWidth=\"True\"/&gt; &lt;/dxg:GridControl.View&gt; &lt;dxg:GridControl.Columns&gt; &lt;dxg:GridColumn Header=\"#\" Width=\"40\"&gt; &lt;dxg:GridColumn.CellTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=\"&#123;Binding RowData.RowHandle.Value, Converter=&#123;StaticResource IndexFromOneConverter&#125;&#125;\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; &lt;/DataTemplate&gt; &lt;/dxg:GridColumn.CellTemplate&gt; &lt;/dxg:GridColumn&gt; &lt;dxg:GridColumn Header=\"Note\" Width=\"100\" FieldName=\"Note\"/&gt; &lt;dxg:GridColumn Header=\"Content\" Width=\"200\" FieldName=\"Content\"/&gt; &lt;dxg:GridColumn Header=\"Area\" Width=\"200\" FieldName=\"Area\"/&gt; &lt;/dxg:GridControl.Columns&gt; &lt;/dxg:GridControl&gt; &lt;/Grid&gt;&lt;/Window&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"}]},{"title":"CE, LE 계산","slug":"satellite-ce-le","date":"2022-06-17T12:56:43.000Z","updated":"2024-01-12T01:10:36.612Z","comments":true,"path":"2022/06/17/satellite-ce-le/","link":"","permalink":"http://hgko1207.github.io/2022/06/17/satellite-ce-le/","excerpt":"","text":"관측값 즉, 지상기준점과 측정점의 차이에 대해 CE 및 LE 결과를 내기 위해 구현을 하게 되었고 참고자료를 바탕으로 정리하였습니다. 소스 코드는 CE, LE 계산 사이트에 있습니다. CE(Circular Error) X, Y 축의 값에 대한 2차원 오차를 측정합니다. 원형오차라고 부르며, CE 50, CE 90, CE 95 등의 형식으로 표현합니다. 예) CE90 5m는 오차들이 실제 값에서 5m 반경 안에 90% 있음을 나타냄. CE 90 계산 1) 관측값 평균이 0일 경우 CE_XX = R * 𝜎𝑚𝑎𝑥 2x2 공분산 행렬을 계산하고, 공분산 행렬에 대해 고유값(Eigenvalue) 계산 최소, 최대 고유값에 대해 제곱근으로 𝜎𝑚𝑖𝑛, 𝜎𝑚𝑎𝑥 값을 구함 예) MATLAB은 eig(A) 함수를 사용 r = 𝜎𝑚𝑖𝑛/𝜎𝑚𝑎𝑥, p=90/100 두 개의 값과 아래 표의 값을 통해 선형 보간하여 확률 계수 R을 구함 예) r = 0.509, p = 0.9 일 때, R = 0.041/0.05 * 1.7371 + 0.009/0.05 * 1.7621 = 1.7416 확률 계수와 𝜎𝑚𝑎𝑥를 곱함 2) 관측값 평균이 0이 아닐 경우 X, Y 축에 대해 각각 공분산 값을 구하고 2x2 공분산 행렬을 계산 i 수만큼 위의 수식으로 2x1(X, Y)의 Si를 계산 Si의 크기를 가장 작은 것부터 가장 큰 것 순으로 정렬(크기는 아래 수식과 같음) RExx는 xx% 가장 큰 크기, RE*xx는 다음으로 큰 크기를 지정. CE_XX 계산은 아래 수식으로 계산. LE(Linear Error) Z 축(고도)에 대한 오차를 측정합니다. 지형의 수직 정확도를 측정합니다.(TIN, DEM, DSM 등) 선형오차라고 부르며, LE 50, LE 90, LE 95 등의 형식으로 표현합니다. LE 90 계산 1) 관측값 평균이 0일 경우 LE_XX = P(확률계수) * 𝜎𝑧 (표준편차) 관측값에 대한 표준편차를 구함 다음의 표에서 p=90/100(0.90)에 대한 확률 계수인 1.6449를 구함 표준편차와 확률 계수를 곱함 LE_90 = 1.6449 * (표준편차) 2) 관측값 평균이 0이 아닐 경우 기준점과 측정점을 통해 표준편차와 평균을 구함 위의 식(누적분포함수)에서 p 값을 계산 p 값에 대해 오차 역함수(Inverse Error Function)를 구함 다음의 식을 통해 LE를 계산 참고내용 1) 분산(Variance) 관측값에 대한 분산 2) 공분산(Covariance) 관측값에 대한 공분산 3) 공분산 행렬 두 개의 확률 변수의 공분산 행렬은 각 변수 쌍에 대해 계산된 공분산 값으로 구성된 행렬 4) 표준편차(Standard Deviation) 관측값에 대한 표준편차 참고자료 Computation of scalar accuracy metrics LE, CE, and SE as both predictive and samplebased statistics (NGA) Geopositional Statistical Methods (NASA)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"}]},{"title":"DEM","slug":"satellite-dem","date":"2022-06-14T15:39:52.000Z","updated":"2024-01-12T01:11:57.819Z","comments":true,"path":"2022/06/15/satellite-dem/","link":"","permalink":"http://hgko1207.github.io/2022/06/15/satellite-dem/","excerpt":"","text":"Digital Elevation Models 수치표고모형(DEM)은 수치지형 또는 수심측량 데이터에 관한 일반적인 용어로써, 일반적으로 식생과 인공지물을 포함하지 않는 지형만의 높이를 의미하며, 강, 호수의 DEM 높이 값은 수표면을 나타냅니다. DEM은 일반적으로 **DTM(Digital Terrain Model)**과 비슷한 의미로 사용됩니다. **USGS(U.S. Geological Survey)**의 정의 : DEM은 보통 높이의 기준면으로부터 측정한 z값을 사용하여 x, y 방향으로 일정한 간격의 지형에 대한 높이 값을 수치지도 형식으로 표현한 것입니다. 이 정의는 **NIMA(National Imagery and Mapping Agency)**에서 작성한 **DTED(Digital Terrain Elevation Data)**의 정의와 유사합니다. DEM의 기하학적 구조는 규칙격자망(Regular Grid, Elevation Matrix)과 불규칙삼각망(Triangular Irregular Network, TIN)이 있으며 각각 장단점을 가지고 있습니다. DTM(Digital Terrain Model) DEM과 유사한 뜻으로 사용되며, 동일한 간격의 z값을 가집니다. DTM은 DEM과 비슷하지만 지형을 좀 더 정확하게 묘사하기 위해 불규칙적으로 간격을 갖는 불연속성(breakline)이 존재한다는 것이 다릅니다. DTM의 최종적인 결과는 특정 지형을 명확히 묘사하는 것이며, 등고선은 지형의 실제 형태에 가깝도록 DTM으로부터 생성하곤 합니다. DSM(Digital Surface Mode) DEM에 식생, 건물, 도로 등 자연 및 인공 지형지물의 표고 값이 포함된 것을 나타냅니다. 원거리통신관리, 산림관리, 3D 시뮬레이션 등에 이용됩니다. 규칙격자망 일정 크기 사각형 격자지점의 표고행렬로 지형기복 변화를 표현하는 방법입니다. 규칙적인 격자의 교차점에서의 고도를 저장하며, 보통 불규칙한 기준점 집합으로부터 정교한 보간 기법을 거쳐 계산됩니다. 일반적으로 격자의 크기는 기준점 사이의 거리보다 더 작으며, 불연속선이나 높이를 나타내는 점에 의해 표현된 지질학적 정보도 규칙적인 격자로 형성됩니다. 장점 고도만 저장되므로 자료의 구조가 간단함 등고선, 경사각, 경사 방향 계산, 음영이나 분지를 표현 하는데 유용 행렬 처리를 적용함에 있어서 계산 시간이 빠름 단점 복잡한 지형의 표현 시 격자 간격을 좁게 해야 함 표면을 표현하기 위해 높은 밀도의 점들을 저장해야 함 규칙적인 격자에서 불연속선을 표현하는 데 따르는 문제점 불규칙삼각망(TIN) 불규칙삼각망은 원래의 자료 점들을 Delaunay 삼각망을 활용하여 불규칙한 형태의 연속적인 삼각형을 연결시켜 지형의 기복을 표현합니다. 장점 기복이 심한 지역에서 효과적으로 사용될 수 있음 자료의 중복을 줄일 수 있으므로 지형을 효과적으로 표현 최소한의 표고점을 이용하여 능선이나 곡선과 같은 지형 구조 특성을 반영한 보간을 할 수 있다는 점 단점 점들의 불규칙한 구조로 인해 각각의 점들을 저장하려면 대상에 대한 더 많은 정보가 필요함 등고선, 능선, 합수선, 인공구조물 등을 가로질러 TIN이 구성되면 실제 지형 특성을 반영하기 못함 수치등고선으로 TIN을 구성할 때 동일 등고선 상의 꼭짓점들 안으로 TIN이 구성되면 그 TIN 내부는 평지로 표현이 됨 원천 자료에 따른 DEM 구축 방법 별 특성 구분 소요 장비 경제성 정확성 현시성 지상 측량 Total Station, GPS 시간경비과다 우수 우수 종이 지도 Digitizer 수동, 시간 과다 지도에 달림 지도에 달림 Scanner GEOVEC 자동, 기술적 애로 지도에 달림 지도에 달림 수치 지도 MAP 지도 S/W 우수 지도에 달림 지도에 달림 기존 사진(사진 측량) 해석도화기 양호 우수 사진에 달림 신규 촬영(사진 측량) 수치도화기 촬영비 추가 우수 우수 원격 탐사 Image Processor 우수 개선 중 우수 레이저 측량 레이저 고도계 우수 우수 우수 DEM 추출 방법 – 수치 지도 활용 이미 제작된 수치지도를 이용하여 DEM을 구축하는 방법으로 수치지도의 등고선 및 고도점의 좌표를 추출하여 DEM을 생성합니다. DEM 생성 시 고려해야 할 사항 수치지도 제작 시기가 오래되었을 경우 현재의 지표 및 지물의 정보가 부족 인공지물 밀집 지역일 경우 고도 추출점이 표기되어 있지 않을 수 있음 따라서, 수치지도로 DEM을 작성할 때에는 항공사진 혹은 보다 대축척의 수치지도, 지상측량 등의 보조 자료를 이용하여 등고선 및 고도점을 보완해야 합니다. 등고선 데이터는 제한된 범위의 정확도를 가진 DEM을 구축합니다. 기대할 수 있는 최대의 정확도는 등고선 간격의 1/2 정보 등고선으로부터 DEM을 생성하는 것은 대부분의 상용 소프트웨어(PCI, Erdas Imagine) 등에서 지원합니다. DEM 추출 방법 – 항공사진 측량 항공사진(또는 항공영상)을 이용한 DEM 구축 방법은 현재 실용화된 방법 중 가장 정확하고 최신의 수치 고도 자료를 얻을 수 있습니다. 항공사진측량용 카메라로 촬영된 입체 항공사진을 이용하여 해석도화기와 도화사의 작업을 통해 수동으로 DEM을 추출하는 방법 항공사진을 스캐닝하거나 항공사진 측량용 디지털카메라로 획득한 항공 영상을 이용하여 수치도화기에서 자동으로 DEM을 추출하는 방법 항공사진(또는 항공영상)을 이용하면 지형은 물론이고 지물에 대한 DEM 구축이 가능합니다. DEM 추출 방법 – 위성 영상 위성영상의 해상력이 높아지고 이동한 위치에서 반복 촬영한 동일 지점의 영상을 획득할 수 있게 됨으로써 위성영상으로부터 DEM 구축이 가능해집니다. 위성영상은 항공사진에 비하여 포함면적이 넓고, 주기적으로 영상을 얻을 수 있으므로 최신의 정보를 획득하는데 소요되는 시간과 비용을 절감할 수 있습니다. 위성영상에 항공사진의 수치사진측량기법을 적용하여 자동으로 DEM을 생성할 수 있습니다. DEM의 정확도 수치표고모델의 정확도는 선형적으로 보간 된 DEM과 지도나 GPS 자료와 같은 참조자료와의 비교를 통한 RMSE(root-mean square error) 값을 이용합니다. DEM의 정확도는 데이터의 스케일과 공간 해상도, 격자 간격에 영향을 많이 받습니다. DEM의 수평정확도는 표고행렬의 수평간격에 영향을 많이 받음 DEM의 수직정확도는 원시 데이터의 질과 공간 해상도, 자료의 수집과 처리과정에 많은 영향을 받음 등고선으로부터 구축된 DEM의 평가 기준(Carrara, 1997) 수치 지도의 등고선 근처에 배치된 격자점의 표고는 그 등고선의 표고와 일치하거나 큰 차이가 없어야 함 두 등고선으로 포위된 영역 내에 있는 격자점의 표고는 두 등고선 표고 사이의 표고이며, 두 등고선 사이에서 선형 변화함 경사 변화가 완만한 지역에서도 DEM은 지형을 현실적으로 묘사하여야 함 일정 규모이상의 인공 지물에 대한 정보를 DEM으로부터 추출할 수 있어야 함 DEM 자동 제작 방법","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"}]},{"title":"DPPDB","slug":"satellite-dppdb","date":"2022-06-14T12:36:15.000Z","updated":"2022-09-02T14:49:52.097Z","comments":true,"path":"2022/06/14/satellite-dppdb/","link":"","permalink":"http://hgko1207.github.io/2022/06/14/satellite-dppdb/","excerpt":"","text":"Digital Point Positioning Database 네이버 백과사전 정밀영상위치제공 지형정보로서 미(美) 국가영상지도국(NIMA)이 1970년대 베트남전 중 미 공군의 B-52와 F-111에서 정밀항법 유도무기를 사용하기 위해 개발했다가 1995년 IT 발달에 따라 디지털로 전환시켰습니다. 3차원 지형데이터에 각종 건물 등 지상 구조물 데이터를 통합해 매우 정밀한 위치정보를 제공합니다. 이 데이터와 미군용 GPS를 결합하면 수십km 밖에서도 미사일 등 유도 무기를 1m의 오차로 공격할 수 있습니다. DPPDB는 스테레오 이미지 쌍 및 관련 보조 데이터의 모음으로, 이미지에서 식별할 수 있는 모든 점 또는 특징에 대한 정확한 위치 데이터를 신속하게 확인할 수 있는 기능을 제공합니다. 이 데이터는 스테레오 이미지를 분할, 방사 보정, 합리적인 다항식 구성 및 압축 등의 추가 처리를 함으로써 얻을 수 있습니다. 일반적으로 1도 면적(60 x 60 NM)을 커버하며 NITF 파일로 제공됩니다. 참고로 DPPDB는 NITF(National Imagery Transmission Format ) 2.0 사양의 제품입니다. DPPDB 제품은 세 가지 주요 구성 요소로 구성된 디지털 제품입니다. 1. imagery support data : Master Product File(MPF) 2. a map graphic for reference(참고 용 지도) : CADRG 프레임 파일 3. stereo imagery(입체 영상) : 전체 해상도 및 Overview 이미지 파일 NITF 란 National Imagery Transmission Format Standard (국가 영상정보 전송 포맷 표준) NITF는 공중에서 영상을 획득하는 플랫폼들로부터 얻어진 원본 영상을 기반으로 영상, 서브-영상(sub-images), 그래픽, 심볼, 텍스트 뿐 아니라 영상과 관련된 정보를 담을 수 있는 하나의 패키지(package)로서 2차 디지털 영상(secondary digital imagery)의 배포 또는 유통을 지원하기 위한 포맷입니다. 따라서 단순히 영상 자체만을 저장하는 일반 영상 포맷과 차별화됩니다. NITF에 대한 개발은 1987년 미국 정부에 의하여 시작되었으며, 1991년 미국 국방부(DoD) 내에서 영상 파일에 대한 표준인 MIL-STD-2500B로 지정되었으며, 현재 MIL-STD-2500C로 발전되었습니다. NITF는 영상유통포맷의 최초 개발로 1989년 NITF 1.1 발표 이후, 1991년 국방부 표준으로 지정되면서 이름을 NITFS(National Imagery Transmission Format Standard)로 개명하게 되었습니다. DPPDB 구조 DPPDB 제품 파일은 아래 그림과 같이 순차적으로 배열됩니다. 첫 번째 파일은 MPF(Master Product File)이며 DPPDB 및 참조 그래픽에 대한 정보를 제공하는 수많은 서브 헤더 파일이 있습니다. MPF 다음에는 참조 그래픽 프레임을 구성하는 파일이 있습니다. DPPDB에 포함 된 나머지 파일은 이미지 파일입니다. 1) MPF (Master Product File) 정확도, 세그먼트간 이격점 데이터, 진단점, 불량 지역 정보, 풋 프린트 및 이미지 파일과 참조 그래픽에 대한 정보와 같은 보조 데이터를 포함하고 있습니다. 그림은 기본 구성 요소만 보여주는 MPF의 파일 구조입니다. 2) Reference Graphic files MPF 다음으로 구성된 그래픽 파일은 사용자가 지정한 영역에 대한 디지털 맵을 제공합니다. 다양한 벡터 오버레이를 표시하고 대상의 대략적인 위치를 식별하기 위해 사용됩니다. DPPDB 제품의 사각형보다 약간 큰 영역을 포함하는 8 비트 컬러 래스터 이미지입니다. 그래픽의 소스는 CADRG(Compressed ARC Digitized Raster Graphics) 데이터입니다. 3) Image Files 이미지 파일은 전체 해상도 및 overview(전체 해상도 이미지의 1/8x 또는 1/4x 축소 된 이미지) 세그먼트 이미지 세트로 구성되어 있습니다. 각 전체 해상도 및 overview 이미지 파일에는 해당 이미지에 대한 정보 및 함수 계수도 포함되어 있습니다. 이미지 파일은 4 개의 그룹 (왼쪽과 오른쪽의 전체 해상도 및 overview 이미지)으로 구성되며 각 그룹은 단일 DPPDB 모델에 포함됩니다. 아래 그림은 전체 해상도 및 overview 이미지 세그먼트의 파일 구조를 보여줍니다. DPPDB 생성 NITF 영상 및 위치결정자료 생성 절차를 설명합니다. 세그먼트 분할 입체시 영상에 대한 세그먼트 이미지를 분할합니다. 불량지역 생성 불량지역 생성 기능을 통해 영상에서 유효하지 않는 영역을 식별 또는 추가합니다. 불량지역은 구름으로 관측이 어려운 지역이나, 바다, 호수와 같이 수계지역을 의미합니다. 정확도 평가 각 세그먼트간 측정오차, 절대정확도, 상대정확도를 계산합니다. 세그먼트간 이격점 생성 각 세그먼트 간 중복지역에서 특징점을 추출하고, 매칭을 통해 자동으로 점을 생성합니다. 참고문헌 미국 군사규격서 MIL-PRF-89034 : Digital Point Positioning Data Base(DPPDB) MIL-STD-2500A: National Imagery Transmission Format(NITF) for NITFS MIL-STD-2301A : Computer Graphics Metafile(CGM) Implementation Standard for the National Imagery Transmission Format Standard(NITFS) MIL-PRF-89038 : Compressed ARC Digitized Raster Graphics(CARRG) MIL-PRF-89041: Controlled Image Base(CIB) NITF NITFS : https://terms.naver.com/entry.nhn?docId=3480012&amp;cid=58439&amp;categoryId=58439 NITF/NSIF Background : https://www.harrisgeospatial.com/docs/BackgroundNITFNSIFFormat.html#Main","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"}]},{"title":"CSM","slug":"satellite-csm","date":"2022-06-13T11:01:13.000Z","updated":"2024-01-12T01:09:45.521Z","comments":true,"path":"2022/06/13/satellite-csm/","link":"","permalink":"http://hgko1207.github.io/2022/06/13/satellite-csm/","excerpt":"","text":"Community Sensor Model(CSM) NGA(국가지리정보국, National Geospatial Intelligence Agency)에서는 센서 모델을 동일한 방법으로 접근할 필요성에 따라 CSM(Community Sensor Model)을 개발하여 통일된 인터페이스를 제공합니다. CSM은 현재 운용되고 있거나 추후 운용이 예상되는 위성 센서의 모델, 알고리즘, 소프트웨어에 대한 개발, 시험, 평가를 지원하는 플러그인 소프트웨어 라이브러리입니다. CSM은 WGS84 타원체의 ECEF(Earth Centered Earth Fixed) 좌표계를 사용하고 있습니다. 따라서 모든 함수에서 지상 좌표의 입력과 출력 값은 ECEF 좌표로 구성해야 합니다. CSM 사용 소프트웨어 ENVI, ERDAS, SOCET GXP 등 CSM 장단점 장점 센서모델링을 수행하기 위한 소프트웨어 개발 시 모델링에 사용되는 행렬과 반복 알고리즘만 구현하면 되므로 소프트웨어의 개발비용 절감효과가 큽니다. 새로운 센서나 모델들이 개발되면, 센서모델에 대한 플러그인만 개발하여 배포하고 응용 소프트웨어에서 호출하여 모델링을 수행하므로 센서모델의 확장성이 뛰어납니다. 단점 ECEF 좌표계 사용을 위해 경우에 따라 중복된 좌표 변환 작업을 수행하게 되어 효율성이 다소 저하됩니다. CSM Context Diagram CSM API CSM은 CSMPlugin 클래스와 CSMSensorModel 클래스로 구분됩니다. CSMPlugin 클래스 플러그인 제조사, 배포 일자와 같은 기본적인 정보를 제공합니다. 센서 모델 선택, Image Support Data(ISD) 처리, 센서 모델 생성과 같은 기능을 하는 함수들로 구성됩니다. SMSensorModel 클래스 영상좌표에서 지상좌표의 상호 간 변환, 편미분, 공분산, 파라미터 설정 등 사진 측량에 필요한 함수들로 구성됩니다. Sensor Model Download Github Page - Community Sensor Model API Build 다운로드가 완료되면 압축을 풀어줍니다. 빌드에 필요한 CMake를 설치합니다. 설치가 완료되면 CMake gui를 실행합니다. 빌드를 하기 전 CSM 폴더 안에 build 폴더를 생성합니다. CMake gui에서 Source 및 Build(생성한 build 폴더 경로) 경로를 입력하고 Configure 버튼을 클릭합니다. 오류 없이 설정이 완료되면 Generate 버튼을 클릭합니다. CMake Build가 완료되면 다음과 같이 프로젝트가 생성됩니다. 프로젝트를 실행하여 빌드를 실행하면 csmapi.dll, csmapi.lib 파일이 생성됩니다. CSM 은 공통 인터페이스를 제공하기 때문에 csmapi.dll, csmapi.lib, 헤더 파일을 참조 및 로드하여 위성에 대한 센서 모델을 구현합니다. 기본적으로 Plugin, RasterGM을 상속받아 구현합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"}]},{"title":"개발 시 도움이 될 도구들","slug":"util-2","date":"2022-06-11T13:31:16.000Z","updated":"2024-01-11T15:28:47.284Z","comments":true,"path":"2022/06/11/util-2/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/util-2/","excerpt":"","text":"1. 댓글 게시판, 커뮤니티, 블로그 등 콘텐츠 위주의 서비스면 댓글은 필수입니다. 댓글 기능이 메인은 아니지만 필요한 기능 중 하나이며, 구현하기에는 시간도 많이 듭니다. 그래서 다음 서비스들로 대체해서 사용합니다. Disqus Disqus(https://disqus.com/)는 소셜 댓글 서비스입니다. 자바스크립트 코드만 사이트에 등록하면 위젯 형태로 서비스에서 바로 사용이 가능한 댓글 전문 서비스입니다. LiveRe LiveRe(https://www.livere.com/)는 국내에서 만든 소셜 댓글 서비스입니다. 별도의 가입이 필요하지 않고, SNS(카카오톡, 네이버, 페이스북 등) 계정이 있으면 언제든 댓글을 남길 수 있는 편의성이 있습니다. Utterances Utterances(https://rtterances.es/)는 깃허브 댓글입니다. 깃허브의 이슈 기능을 이용했기 때문에 무료로 사용 가능합니다. 깃허브의 마크다운 에디터를 그래도 사용하고 있어 댓글을 마크다운으로 작성할 수 있다는 장점이 있습니다. 2. 외부 서비스 연동 SNS 연동 서비스들입니다. Zapier Zapier(https://zapier.com/)는 수많은 클라우드와 SNS 서비스들의 오픈 API를 이용하여 서로 간의 연동을 지원하는 서비스입니다. IFTTT IFTTT(https://ifttt.com/)는 IF This Then That의 약자로, 만약 A를 하면 B를 하라는 의미로 클라우드와 SNS 연동을 지원하는 서비스입니다. 3. 방문자 분석 사이트 운영에 필요한 여러 정보들을 분석하는 기능을 무료로 지원하는 도구들입니다. 구글 애널리틱스 구글 애널리틱스는 구글에서 지원하는 사이트 분석 도구입니다. 국내에도 많은 자료가 공유되어 있어 사용하기 편하고 다른 구글 서비스들과의 연동도 잘 되어 있습니다. 4. CDN CDN은 Content Delivery Network의 약자로 전 세계에 분산되어 있는 서버 네트워크입니다. 정적 콘텐츠라고 불리는 JS, CSS, 이미지 등을 전 세계에 퍼진 서버에 전달하여 사용자가 서비스에 접속할 때 가장 가까운 서버에서 가져가도록 지원하는 서비스입니다. CDN의 목적은 트래픽 분산을 위함입니다. 클라우드플레어 클라우드플레어(https://www.cloudflare.com/)는 해외뿐만 아니라 국내에서도 가장 많이 사용되는 CDN 서비스입니다. 정적 파일들을 캐싱하여 제공하는 CDN의 기능은 무료로 사용할 수 있습니다. 5. 이메일 마케팅 뉴스레터와 같은 이메일 마케팅 기능을 지원하는 서비스입니다. Mailchimp Mailchimp(https://mailchimp.com/)는 해외에서 서비스 중인 이메일 마케팅 서비스입니다. 회원 2000명에게 월 12000개의 메일을 무료로 보낼 수 있어 초기에 사용하기 좋습니다. 반응형을 고려한 뉴스레터나 구독자 관리, 통계 등의 기능을 지원합니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"}]},{"title":"지리공간자료 정확도","slug":"satellite-accuracy","date":"2022-06-11T13:29:25.000Z","updated":"2024-01-11T15:28:26.089Z","comments":true,"path":"2022/06/11/satellite-accuracy/","link":"","permalink":"http://hgko1207.github.io/2022/06/11/satellite-accuracy/","excerpt":"","text":"지리공간자료 정확도의 형태 Spatial (position, geometry, topology) Attributional (correctness of attributes) Spectral (band depth) Temporal (appropriate date) Radiometric (capture piece of electromagnetic spectrum) 지리공간자료 기하보정된 위성영상 정사영상(Orthoimagery) DTM(Digital Terrain Model) DEM(Digital Elevation Model) DSM(Digital Surface Model) TIN(Triangulated Irregular Network) 정확도(Accuracy) 과학, 산업, 공업, 통계학 분야에서 재거나 계산된 양이 실제 값과 얼마큼 가까운지를 나타내는 기준이며, 관측의 정교성이나 균질성과는 무관합니다. 측정에 의해 얻은 최고 추정 값과 측정 된 수량의 &quot;참&quot;값에 대한 근접성입니다. 위치 정확도(Position Accuracy) 두 지리 공간 레이어 사이 또는 지리 공간 레이어와 현실 사이의 위치 차이를 나타내는 정량화 가능한 값입니다. Root Mean Square Error(RMSE) 평균 제곱근 편차(Root Mean Square Deviation; RMSD) 또는 평균 제곱근 오차(Root Mean Square Error; RMSE)는 추정 값 또는 모델이 예측한 값과 실제 환경에서 관찰되는 값의 차이를 다룰 때 흔히 사용하는 측도이다. 정밀도를 표현하는데 적합합니다. 각각의 차이 값은 잔차(residual)라고도 하며, 평균 제곱근 편차는 잔차들을 하나의 측도로 종합할 때 사용됩니다. 잔차 값 간의 분산을 통계적으로 측정한 것입니다. Standard Deviation(StDev) : 표준 편차 자료의 산포도를 나타내는 수치로, 분산의 양의 제곱근으로 정의됩니다. Circular Error(CE) : 원형 오차 CE는 X, Y 모두에 대한 2차원 오차를 측정합니다. CE90, CE95, CE99 형식으로 표현합니다. 원형 분포에서 모든 오차가 n%를 초과하지 않는 반경 오차 예) CE 90 = 2미터인 경우 : 오차들이 반지름 2미터인 원 안에 있을 확률이 90%라는 것을 나타낸다. Linear Error(LE) : 선형 오차 Z축(고도)에 대한 오차 측정을 합니다. 측정된 값과 실제 또는 알려진 값과의 차이를 계산합니다. 지형의 수직 정확도 측정(예: DEM 또는 TIN) LE90, LE95, LE99 형식으로 표현합니다. 예) LE 95 = 10m인 경우: 오차들이 10 미터 내에 있을 확률이 90%라는 것을 나타낸다. Circular Error Probable(CEP) Circular Error Probability 또는 Circular Error Probable, 원형 공산 오차 라고 하며 탄도학에서 무장의 정밀도를 측정하는 단위. CEP는 폭탄 등이 투하되었을 경우, 그중의 반수가 명중하는 원의 반경을 가리킵니다. 즉 10발 공격했을 때 5발이 들어가는 원을 그렸을 때 그 반경이 5m이라고 하면 CEP는 5m라고 합니다. 2차원의 수평방향 성분에 대해 50%의 원형 확률 오차(CEP)의 수치는 원의 반경과 같으며, 측점들의 각각의 계산 값에 포함되는 잔차들 중 50%는 이 원안에 들어오고 나머지는 원 밖에 존재합니다. 항해 시의 위치정밀도 측정치로, 실제 수평자표에서 오차 타원에서 그 반경을 나타냅니다. 이 값은 현재 위치가 실제 위치에 있을 확률이 50% 임을 나타냅니다. 실제위치를 중심으로 한 위치추정값의 50%를 함유하는 원의 반경 수치입니다. CE50 형식과 같습니다. 참고자료 GPS 기초 GCP 용어정리 Introduction to GPS","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"}]},{"title":"[CentOS] nohup 사용 방법","slug":"linux-17","date":"2022-05-29T13:11:12.000Z","updated":"2024-01-11T15:26:46.689Z","comments":true,"path":"2022/05/29/linux-17/","link":"","permalink":"http://hgko1207.github.io/2022/05/29/linux-17/","excerpt":"","text":"리눅스 환경에서 nohup 사용 방법에 대해 알아보겠습니다. nohup nohup 은 No Hang Ups의 약자로 백그라운드로 지속적으로 실행하는 프로세스를 의미합니다. nohup 은 실행을 현재 사용자 세션이 아닌 운영체제가 제공하는 백그라운드 공간에서 실행을 한다. &amp; 는 사용자 세션에서 실행되며, 화면 출력만 백그라운드로 전환한 상태입니다. 즉 &amp; 로 실행된 프로세스는 사용자 세션이 로그아웃되는 시점에 같이 종료되는 것입니다. 애플리케이션 실행할 때 터미널을 종료해도 애플리케이션은 계속 구동될 수 있도록 nohup 명령어를 사용합니다. 실행 기본 실행 nohup 명령어를 사용하여 실행합니다. nohup 으로 실행시킬 파일은 반드시 755 퍼미션을 가지고 있어야 합니다. 1$ nohup [실행파일명] 예시입니다. 1$ nohup ./run.sh 실행을 하면 “nohup: ignoring input and appending output to ‘nohup.out’” 메세지와 함께 해당 프로그램의 nohup 을 실행시킨 경로에 nohup.out 파일이 생성되고 표준출력 내용이 출력됩니다. 백그라운드 실행 &amp; 명령어를 맨 끝에 불여서 사용하면 백그라운드로 실행됩니다. 1$ nohup [실행파일명] &amp; 예시입니다. 1$ nohup ./run.sh &amp; 파일 저장 표준출력과 표준에러 같은 파일 저장 2&gt;&amp;1을 추가하면 표준 출력(1)과 표준 에러(2)를 한 파일에 저장됩니다. 1$ nohup [실행파일명] 2&gt;&amp;1 예시입니다. 1$ nohup ./run.sh 2&gt;&amp;1 표준출력과 표준에러 다른 파일 저장 표준 출력(1)은 run_output.out 파일로 저장하고, 표준 에러(2)는 run_output.err 파일로 저장됩니다. 1$ nohup ./run.sh 1 &gt; run_output.out 2 &gt; run_output.err 표준출력 다른 위치에 저장 표준 출력을 nohup.out이 아닌 다른 이름의 파일이나 다른 위치에 저장하려면 다음 명령어를 사용합니다. 1$ nohup [실행파일명] &gt; [파일위치] 예시입니다. 1$ nohup ./run.sh &gt; /data/run_output.out 표준출력 남지기 않도록 표준 출력을 별도로 남기고 싶지 않다면 /dev/null를 추가합니다. 1$ nohup [실행파일명] &gt; /dev/null 예시입니다. 1$ nohup ./run.sh &gt; /dev/null 실행 프로세스 확인 백그라운드 실행의 경우 다음 명령어를 통해 실행 중인 프로세스 상태를 확인할 수 있습니다. 1$ ps -ef | grep run.sh 프로세스 종료 백그라운드로 실행 중인 프로세스를 종료하는 방법입니다. 먼저 프로세스 아이디를 찾고 종료를 합니다. 1$ ps -ef | grep run.sh 프로세스 아이디를 입력하여 종료합니다. 1$ kill -9 [프로세스 아이디] 여기까지 nohup 사용 방법에 대해 알아보았습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"}]},{"title":"[CentOS] Hostname 변경 방법","slug":"linux-16","date":"2022-05-28T01:32:02.000Z","updated":"2024-01-11T15:25:41.575Z","comments":true,"path":"2022/05/28/linux-16/","link":"","permalink":"http://hgko1207.github.io/2022/05/28/linux-16/","excerpt":"","text":"HOSTNAME 등록 각 서버가 어느 서비스 인지 표현하기 위해 HOSTNAME을 변경합니다. 다음 명령어로 편집 파일을 엽니다. 1$ sudo vim /etc/sysconfig/network 편집 화면에서 HOSTNAME 항목을 본인이 원하는 서비스명으로 추가합니다. 123NETWORKING=yesHOSTNAME=hgko-webserviceNOZEROCONF=yes 변경한 후 서버를 재부팅합니다. 1$ sudo reboot 재부팅이 끝나고 나서 ssh 명령어를 사용하여 다시 접속해 보면 HOSTNAME이 잘 변경됐는지 확인할 수 있습니다. 1$ ssh hgko-webservice 다른 HOSTNAME 등록 리눅스 버전에 따라 명령어가 다르기 때문에 위의 내용으로 등록이 안될 시 다음 명령어를 통해 HOSTNAME을 등록합니다. 1$ sudo hostnamectl set-hostname [변경할 호스트명] 1234567$ sudo hostnamectl set-hostname hgko-webservice# 확인hostname# 결과 출력hgko-webservice hosts 추가 호스트 주소를 찾을 때 먼저 검색해 보는 /etc/hosts 에 추가한 hostname을 등록합니다. 다음 명령어로 /etc/hosts 파일을 엽니다. 1$ sudo vim /etc/hosts 편집 화면에서 등록한 HOSTNAME을 추가합니다. 1127.0.0.1 hgko-webservice 저장하고 종료한 뒤 정상적으로 등록되었는지 다음 명령어로 확인합니다. 1$ curl hgko-webservice 잘 등록하였다면 다음과 같이 80 포트로 접근이 안 된다는 에러가 발생합니다. 1curl: (7) Failed to connect to hgko-webservice port 80 after 0 ms: Connection refused 아직 80 포트로 실행된 서비스가 없음을 의미입니다. curl 호스트 이름 명령어로 실행이 잘 되었음을 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"}]},{"title":"[CentOS] 타임존 변경","slug":"linux-15","date":"2022-05-26T23:14:00.000Z","updated":"2024-01-11T15:24:40.642Z","comments":true,"path":"2022/05/27/linux-15/","link":"","permalink":"http://hgko1207.github.io/2022/05/27/linux-15/","excerpt":"","text":"타임존 변경 리눅스 서버 타임존이 UTC인 경우가 있습니다. 이는 세계 표준 시간으로 한국의 시간대가 아닙니다. 한국의 시간과는 9시간 차이가 발생하므로 서버에서 수행되는 애플리케이션에서 생성되는 시간도 모두 9시간씩 차이가 나기 때문에 수정이 필요합니다. 서버의 타임존을 한국 시간(KST)으로 변경하겠습니다. 12$ sudo rm /etc/localtime$ sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime 타임존 확인 date 명령어로 타임존이 KST로 변경된 것을 확인 할 수 있습니다. 1$ date 결과입니다. 1Fri May 27 08:18:19 KST 2022","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"}]},{"title":"[CentOS] Java 8 설치 및 환경변수 설정 방법","slug":"linux-14","date":"2022-05-26T13:06:50.000Z","updated":"2024-01-11T15:23:14.891Z","comments":true,"path":"2022/05/26/linux-14/","link":"","permalink":"http://hgko1207.github.io/2022/05/26/linux-14/","excerpt":"","text":"리눅스 환경에서 Java 8 버전 설치 및 환경변수 설정 방법에 대해 알아보겠습니다. JAVA 설치 yum을 이용해서 설치를 합니다. 1[root@localhost ~]# sudo yum install -y java-1.8.0-openjdk-devel.x86_64 버전 변경 설치가 완료되었으면 Java 버전을 8로 변경합니다. 다음 명령어를 실행하면 선택 화면이 나옵니다. 선택 화면에서 Java8을 선택합니다(1 입력). 1[root@localhost ~]# sudo /usr/sbin/alternatives --config java 확인 현재 버전이 Java8로 되었는지 확인합니다. 12[root@localhost ~]# java -versionopenjdk version \"1.8.0_312\" 12[root@localhost ~]# rpm -qa java*jdk-develjava-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 제거 만약 사용하지 않는 Java 가 설치되었으면 삭제를 합니다. 1[root@localhost ~]# sudo yum remove java-1.7.0-openjdk 환경변수 설정 환경변수 확인 일단 현재 JAVA_HOME 환경변수가 설정 되어 있는지 확인합니다. 123[root@localhost ~]# echo $JAVA_HOME[root@localhost ~]# JAVA_HOME 환경변수가 설정이 안되어 있는 것을 확인했습니다. 설치위치 확인 1234[root@localhost ~]# which javac/usr/bin/javac[root@localhost ~]# readlink -f /usr/bin/javac/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64/bin/javac which javac 명령어는 javac 명령어의 위치를 알려줍니다. /usr/bin/javac 는 심볼릭 링크이므로 원본 파일의 위치를 찾기 위해 readlink -f /usr/bin/javac 명령어를 사용하였습니다. readlink -f 는 심볼릭 링크에서 원본파일을 추출하는 명령어입니다. 설정 환경변수를 설정할 수 있는 profile 파일을 엽니다. 1[root@localhost ~]# vi /etc/profile 해당 파일 하단에 다음의 내용을 추가한 후 저장합니다. 1export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64 다음 명령어를 이용하여 수정한 파일을 적용합니다. 1[root@localhost ~]# source /etc/profile 설정 확인 JAVA_HOME 환경변수가 제대로 설정되었는지 확인합니다. 1234[root@localhost ~]# echo $JAVA_HOME/usr/lib/jvm/java-1.8.0-openjdk-devel-1.8.0.342.b07-1.el7_9.x86_64[root@localhost ~]# $JAVA_HOME/bin/javac -versionjavac 1.8.0_312","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[MyBatis] 동적 쿼리","slug":"mybatis-2","date":"2021-09-17T12:49:15.000Z","updated":"2024-01-11T15:22:35.739Z","comments":true,"path":"2021/09/17/mybatis-2/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-2/","excerpt":"","text":"검색 조건에 따라 비교하면서 동적 쿼리를 사용하는 방법에 대해 알아보겠습니다. MyBatis와 데이터베이스는 Oracle을 사용하였습니다. 조건문 조건문에는 단일(if), 다중(choose, when, otherwise) 조건문이 있습니다. 1. 단일 조건문 123456789&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 LIKE %'||#&#123;parameter2&#125;||'%' &lt;/if&gt;&lt;/select&gt; 2. 다중 조건문 1234567891011121314&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE column1 = #&#123;parameter1&#125; &lt;choose&gt; &lt;when test=\"parameter2 != null and parameter2 == ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/when&gt; &lt;otherwise&gt; AND column3 = #&#123;parameter3&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 비교 형식 123456789&lt;!-- 문자열 비교 --&gt;&lt;if test=\"parameter != null and (parameter eq 'all'.toString())\"&gt;&lt;/if&gt;&lt;if test=\"!parameter.equals('all')\"&gt;&lt;/if&gt;&lt;!-- 공백 비교 --&gt;&lt;if test=\"parameter == ' '\"&gt;&lt;/if&gt;&lt;!-- 값 비교 --&gt;&lt;if test=\"uesYn == 'Y'\"&gt;&lt;/if&gt; for 문 foreach를 사용하여 조건을 만들 수 있습니다. 12345678&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE WHERE &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; column1 IN $&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; where 절 123456789101112&lt;select id=\"findBySearch\" resultType=\"Sample\" parameterType=\"SearchParam\"&gt; SELECT * FROM TB_SAMPLE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"parameter1 != null and parameter1 != ''\"&gt; AND column1 = #&#123;parameter1&#125; &lt;/if&gt; &lt;if test=\"parameter2 != null and parameter2 != ''\"&gt; AND column2 = #&#123;parameter2&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"}]},{"title":"[MyBatis] 페이징 처리","slug":"mybatis-1","date":"2021-09-17T12:44:53.000Z","updated":"2024-01-11T15:21:44.933Z","comments":true,"path":"2021/09/17/mybatis-1/","link":"","permalink":"http://hgko1207.github.io/2021/09/17/mybatis-1/","excerpt":"","text":"웹 개발 시 페이징 처리는 필수입니다. MyBatis를 사용하여 페이징 처리하는 방법에 대해 알아보겠습니다. 데이터베이스는 Oracle을 사용하였습니다. 1. 기본 페이징 공지사항 조회 시 페이징을 예제로 만들었습니다. Class 생성 공지사항 관련 Class와 페이징을 위한 Class를 생성하였습니다. 12345678910111213141516171819// Notice.java@Datapublic class Notice &#123; /** 작성사용자ID */ private String userId; /** 작성사용자명 */ private String userName; /** 제목 */ private String title; /** 내용 */ private String content; /** 조회수 */ private int hit;&#125; 12345678910// Pagination.java@Datapublic class Pagination &#123; /** 페이지 번호 */ private int pageNo; /** 한 페이지당 데이터 수 */ private int amount;&#125; Mapper 생성 123456// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination);&#125; 쿼리 작성 CDATA 태크는 XML에서 부등호를 사용하기 위함입니다. 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.hgko.test.repository.NoticeMapper\"&gt; &lt;select id=\"getListWithPaging\" resultType=\"Notice\" parameterType=\"Pagination\"&gt; &lt;![CDATA[ SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM TB_NOTICE WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ) WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt; &lt;/select&gt;&lt;/mapper&gt; 테스트 123456789101112131415161718@RunWith(SpringRunner.class)@MybatisTestpublic class NoticeMapperTest &#123; @Autowired private NoticeMapper noticeMapper; @Test public void getListTest() &#123; Pagination pagination = new Pagination(); pagination.setPageNo(1); pagination.SetAmount(10); List&lt;Notice&gt; notices = noticeMapper.getListWithPaging(pagination); System.out.println(notices); &#125;&#125; 2. 조회 조건 추가 위의 기본 페이징 형식에서 조회 조건을 추가하였습니다. 조회 조건 Class 생성 조회 조건 Class 를 생성하고, Pagination Class 를 상속받았습니다. 12345678910// SearchParam.java@Datapublic class SearchParam extends Pagination &#123; /** 작성사용자명 */ private String userName; /** 제목 */ private String title;&#125; Mapper 수정 Mapper Class에 조회 조건으로 조회하는 함수를 추가하였습니다. 123456789// NoticeMapper.java@Mapperpublic interface NoticeMapper &#123; public List&lt;Notice&gt; getListWithPaging(Pagination pagination); /** 조회조건을 통해 조회 */ public List&lt;Notice&gt; getListWithCondition(SearchParam searchParam);&#125; 조회 쿼리 추가 123456789101112131415161718192021222324252627&lt;!-- NoticeMapper.xml --&gt;&lt;select id=\"getListWithCondition\" resultType=\"Notice\" parameterType=\"SearchParam\"&gt; SELECT USER_NAME, TITLE, CONTENT FROM ( SELECT *, ROWNUM RN FROM ( SELECT * FROM TB_NOTICE &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"userName != null and userName != ''\"&gt; AND USER_NAME LIKE %'||#&#123;userName&#125;||'%' &lt;/if&gt; &lt;if test=\"title != null and title != ''\"&gt; AND TITLE LIKE %'||#&#123;title&#125;||'%' &lt;/if&gt; &lt;/trim&gt; ) &lt;![CDATA[ WHERE ROWNUM &lt;= #&#123;pageNo&#125; * #&#123;amount&#125; ]]&gt; ) &lt;![CDATA[ WHERE RN &gt; (#&#123;pageNo&#125; - 1) * #&#123;amount&#125; ]]&gt;&lt;/select&gt; MyBatis 와 Oracle DB를 이용하여 페이징 처리를 해봤습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"}]},{"title":"[Vue] 설치와 세팅","slug":"vue-1","date":"2021-08-22T09:46:02.000Z","updated":"2024-01-11T15:17:00.273Z","comments":true,"path":"2021/08/22/vue-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/22/vue-1/","excerpt":"","text":"Vue 쓰는 이유 Web app(Single Page Application) 만들 때 사용합니다. 코드 작성할 때 방법이 정해져 있습니다. React는 방법이 다양한 방면 Vue는 v-for, v-if, v-else 등 방법이 하나로 정해져 있어 개발 초보에게도 쉽습니다. 물론 Vue 도 React처럼 자유도 높은 개발도 가능합니다. HTML 렌더링이 React 보다 빠르다고 합니다.(크게 영향을 주지 않음) 업데이트가 잘 됩니다. 결론은 React 보다 학습 곡선이 낮아 쉽고, 가볍고 빠르며, 누구나 빨리 배울 수 있어 접근성이 뛰어나 많이 쓰이고 있습니다. 설치하기 1. Nodejs 설치 Node.js 공식 다운로드 페이지에서 운영체제에 맞게 다운로드하고 설치합니다. 현재 최신 버전은 14.17.5 입니다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인합니다. 12$ node -vv14.17.5 2. 에디터 설치 VS Code 공식 다운로드 페이지에서 운영체제에 맞는 버전을 설치합니다. 여기서는 Windows 버전을 설치합니다. 이 에디터는 macOS, Window, 리눅스를 모두 지원합니다. VS Code 설치가 완료되었으면 Vue 개발을 효율적으로 하기 위해 Extension을 설치합니다. Vetur html css support Vue 3 Snippets Vue-cli 설치 Vue 개발환경 세팅을 도와주는 프로그램을 설치합니다. 명령어를 실행하고 vue 버전 선택을 하면 설치가 완료됩니다. 1$ npm install -g @vue/cli 프로젝트 생성 프로젝트를 생성할 때는 vue create &lt;프로젝트명&gt; 명령어를 사용합니다. 1$ vue create exapmle-vue 실행 터미널에 npm run serve 명령어를 실행합니다. 실행하여 완료했다면 http://localhost:8080/ 로 접속하여 웹 페이지를 확인합니다. 12$ cd example-vue$ npm run serve 정리 Vue에 대한 설명부터 설치, 프로젝트 실행까지 진행했습니다. 프로젝트를 진행하면서 중요한 부분을 정리할 예정입니다. 참고 https://kr.vuejs.org/v2/guide/index.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"}],"tags":[{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"}]},{"title":"[CentOS] 압축 및 해제","slug":"linux-13","date":"2021-08-20T05:17:29.000Z","updated":"2024-01-11T14:50:14.393Z","comments":true,"path":"2021/08/20/linux-13/","link":"","permalink":"http://hgko1207.github.io/2021/08/20/linux-13/","excerpt":"","text":"압축 tar 파일 압축 123tar -cvf [파일명.tar] [압축할 파일 또는 폴더명]예) tar -cvf test.tar test/ tar.gz 파일 압축 123tar -zcvf [파일명.tar.gz] [압축할 파일 또는 폴더명]예) tar -zcvf test.tar.gz test/ 압축 해제 zip 파일 압축 풀기 1234unzip [파일명]unzip [파일명] -d [폴더경로]예) unzip test.zip tar 파일 압축 풀기 123tar -xvf [파일명.tar]예) tar -xvf test.tar tar.gz 파일 압축 풀기 123tar -zxvf [파일명.tar.gz]예) tar -zxvf test.tar.gz tar 압축 옵션 옵션 설명 -c tar로 묶기 -v 묶거나 파일을 풀 때 과정을 화면으로 출력 -f 파일을 묶도록 지정 (반드시 추가되어야 함) -x tar를 풀기 -z gzip(gz)으로 압축 또는 해제 -p 심볼릭 링크 설정 -C 경로를 지정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"}]},{"title":"[Go] 설치 및 기본 사용 방법","slug":"go-1","date":"2021-08-19T00:38:09.000Z","updated":"2024-01-11T14:49:41.917Z","comments":true,"path":"2021/08/19/go-1/","link":"","permalink":"http://hgko1207.github.io/2021/08/19/go-1/","excerpt":"","text":"서론 노마드 코더에서 무료인 쉽고 빠른 Go 시작하기 강의 내용을 코딩하며 정리하였습니다. 시작 https://go.dev/ 페이지에서 Go를 다운로드 합니다. 다운로드 완료 시 설치파일을 실행하여 설치합니다. 그리고 폴더를 다음과 같이 생성합니다. mkdir github.com/hgko1207 cd github.com/hgko1207 mkdir learngo cd learngo go mod init github.com/hgko1207/learngo 코딩 main.go 는 컴파일을 위한 파일 export 함수를 만들 경우 함수명 맨 앞에 대문자로 작성 function -&gt; func null -&gt; nil 상수와 변수 12// Constantsconst name string = \"eden\" 12345678// Variablesfunc main() &#123; var name string = \"eden\" // 변수를 아래와 같이 축약형으로 사용 가능 // 축약형은 함수 안에서만 동작 name := \"eden\"&#125; For 문 1234people := [2]string&#123;\"eden\", \"haeun\"&#125;for _, person := range people &#123; fmt.Println(person);&#125; 함수 1234567891011121314// naked returnfunc lenAndUpper(name string) (length int, uppercase string) &#123; // 'derfer' function이 끝난 후에 실행되는 코드 defer fmt.Println(\"I'm done\") length = len(name) uppercase = strings.ToUpper(name) return&#125;// Go가 내부적으로 호출하는 method를 사용하는 방법func (a Account) String() string &#123; return fmt.Sprint(a.Owner(), \"'s account.\\nHas: \", a.Balance())&#125; 배열 선언 123func main() &#123; data := [2]string&#123;\"test1\", \"test2\"&#125;&#125; Map 사용 12345678// empty map을 초기화하고 싶을때// map 끝에 중괄호(&#123;&#125;)를 작성하여 초기화 해야 함var results = map[string]string&#123;&#125;// 또는 make 사용var results = make(map[string]string)results[\"hello\"] = \"Hello\" Goroutines Goroutines 이란 기본적으로 다른 함수와 동시에 실행시키는 함수입니다. Goroutines는 프로그램이 작동하는 동안(메인함수가 실행하는 동안)만 유효합니다. 123456789101112131415161718// 함수 앞에 go를 붙입니다.func main() &#123; go count() count()&#125;func count() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) time.Sleep(time.Second) &#125;&#125;// 이 경우는 main함수가 바로 종료되기 때문에 동작하지 않습니다.func main() &#123; go count() go count()&#125; Channels Channel 은 Goroutines 이랑 메인함수 사이에 정보를 전달하기 위한 방법입니다. 채널로부터 뭔가를 받을 때 메인 함수가 어떤 결과가 올 때까지 기다립니다. 채널의 타입은 chan 입니다. 채널은 데이터를 받을 순 없고 보낼 수만 있도록 작성할 수 있습니다.(send-only) 12345678910111213141516func main() &#123; c := make(chan bool) go channelTest(c) result := &lt;- c fmt.Println(result)&#125;func channelTest(c chan bool) &#123; time.Sleep(time.Second * 5) c &lt;- true&#125;// send-onlyfunc sendOnlyTest(c chan&lt;- bool) &#123; c &lt;- true&#125; Error errors.New()를 사용하여 에러를 정의하고 호출합니다. 123456789var err = errors.New(\"error content\")func main() &#123; fmt.PrintLn(errTest())&#125;func errTest() error &#123; return err&#125; goquery HTML을 navigate하고 필요한 걸 HTML에서 찾아내기 위해서 사용 JQuery와 유사한 go를 위한 라이브러리입니다. https://github.com/PuerkitoBio/goquery 1$ go get github.com/PuerkitoBio/goquery 참고 go lang std library https://golang.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"}]},{"title":"[CentOS] yum을 이용한 rpm 패키지 다운로드","slug":"linux-12","date":"2021-07-23T08:50:03.000Z","updated":"2023-03-14T02:22:58.983Z","comments":true,"path":"2021/07/23/linux-12/","link":"","permalink":"http://hgko1207.github.io/2021/07/23/linux-12/","excerpt":"","text":"yum-downloadonly 패키지 이용 yum-downloadonly 패키지를 설치합니다. 1$ yum install yum-downloadonly 1$ yum install [패키지명] -y --downloadonly --downloaddir=[다운로드 경로] 사용 예제입니다. 1$ yum install dotnet-sdk-5.0 -y --downloadonly --downloaddir=/home/rpm/download yumdownloader 이용 yumdownloader 명령어가 있는 yum-utils 패키지를 설치합니다. 1$ yum install yum-utils 1$ yumdownloader --downloadonly --resolve --destdir=[다운로드 경로] [패키지명] 사용 예제입니다. 1$ yumdownloader --downloadonly --resolve --destdir=/home/rpm/download dotnet-sdk-5.0 패키지 의존성 정보 확인 12$ yum deplist [패키지명]$ yum deplist dotnet-sdk-5.0 패키지 설치 1$ rpm -ivh [패키지 파일명] 패키지 삭제 설치된 패키지를 삭제합니다. 패키지명만 입력합니다. 1$ rpm -e [패키지명] 패키지 설치 여부 1$ rpm -q [패키지명]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"}]},{"title":"Chocolatey 설치","slug":"chocolatey","date":"2021-07-21T10:21:51.000Z","updated":"2024-01-11T14:47:33.391Z","comments":true,"path":"2021/07/21/chocolatey/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/chocolatey/","excerpt":"","text":"윈도우(Windows)를 사용하면서 개발 환경을 쉽게 꾸릴 수 있는 Chocolatey(윈도우용 패키지 매니저) 설치와 사용 방법에 대해 알아보겠습니다. 설치 공식 Install 홈페이지를 따라 설치를 진행합니다. 윈도우 7 이상, 윈도우 서버 2003 이상에서 설치가 가능하고, PowerShell에서 명령어로 설치할 수 있습니다. PowerShell 사용 관리자 권한으로 실행해야 합니다. 그렇지 않으면 에러 메세지를 보여줍니다. 다음 설치 명령어를 복사하여 실행하면 설치가 진행됩니다. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 설치가 완료되었다면 choco 명령어를 실행하였을 때 다음과 같이 버전 정보가 나옵니다. 1234C:\\Windows\\system32&gt; chocoChocolatey v0.10.15Please run 'choco -?' or 'choco &lt;command&gt; -?' for help menu.C:\\Windows\\system32&gt; 패키지 설치 패키지 리스트 에서 설치 가능한 패키지들을 확인할 수 있습니다. 구글 크롬을 예제로 설치해보겠습니다. 검색 창에 google chrome 을 검색하면 결과가 나오고 오른쪽에 설치 명령어가 보입니다. 명령어를 복사하고 PowerShell에 입력하면 설치가 진행됩니다. 1&gt; choco install googlechrome 설치가 완료되었으면 다음 명령어를 실행하여 설치된 패키지들을 확인합니다. 1&gt; choco search googlechrome Ubuntu 의 apt-get와 CentOS rpm 명령어처럼 윈도우에서도 설치 명령어를 통해 필요한 프로그램을 쉽게 설치할 수 있습니다. 추천 패키지들 Windows Terminal vscode python3 git postman jdk8 Adobe Acrobat Reader Notepad++ Node JS PowerToys WSL(Windows Subsystem for Linux)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"}]},{"title":"알아두면 손해 안보는 사이트","slug":"util-1","date":"2021-07-21T02:59:01.000Z","updated":"2022-09-26T12:04:47.996Z","comments":true,"path":"2021/07/21/util-1/","link":"","permalink":"http://hgko1207.github.io/2021/07/21/util-1/","excerpt":"","text":"개발 자바스크립트 https://beautifier.io/ 온라인 JSON Parser http://json.parser.online.fr/ 변수명 짓기 https://www.curioustore.com/#!/ 웹 템플릿 https://semantic-ui.com/ https://themeforest.net/ 마크다운 툴 https://stackedit.io/app# CSS Gradient Generator https://www.colorzilla.com/gradient-editor/ 디자인 컬러 팔레트 https://flatuicolors.com/ 무료 아이콘 모음 https://icons8.com/ https://www.flaticon.com/ 아이콘 변환 https://flat-icon.surge.sh/# 사진 모음 https://unsplash.com/ ETC. 파일 포맷 정보 https://eknote.tistory.com/89 좌표계 변환 http://www.synnatschke.de/geo-tools/coordinate-converter.php Convert Lat Long to UTM https://www.latlong.net/lat-long-utm.html 사진 용량 줄이기 https://tinypng.com/","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"}]},{"title":"[JPA] Select Query 사용 방법","slug":"spring-jpa-1","date":"2021-06-19T13:27:35.000Z","updated":"2024-01-11T14:45:34.026Z","comments":true,"path":"2021/06/19/spring-jpa-1/","link":"","permalink":"http://hgko1207.github.io/2021/06/19/spring-jpa-1/","excerpt":"","text":"SpringData JPA를 사용하여 웹 프로젝트를 진행하면서 Select Query를 작성 시 잊어버리게 되어 검색을 하게 되는데 자주 사용하는 내용들을 정리하였습니다. JpaRepository를 상속받아 사용하는 기본 Query와 @Query 주석을 사용하여 JPQL 및 네이티브 SQL 쿼리를 실행하는 방법에 대해 알아보겠습니다. Entity 먼저 데이터베이스에 저장하기 위해 tb_user 테이블 이름의 Entity 클래스를 작성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) protected long id; /** 사용자ID */ @Column(nullable = false, length = 45) private String userId; /** 사용자명 */ @Column(nullable = false, length = 100) private String name; /** 사용자비밀번호 */ @Column(nullable = false, length = 100) private String password; /** 이메일 */ @Column(length = 45) private String email; /** 연락처 */ @Column(length = 20) private String tel; /** 생성일시 */ @CreationTimestamp private LocalDateTime createDate; /** 수정일시 */ @UpdateTimestamp private LocalDateTime updateDate; /** 권한 */ @Enumerated(EnumType.STRING) @Column(nullable = false) private UserRole role; public enum UserRole &#123; ADMIN, GUEST &#125;&#125; Repository Entity 클래스를 작성했다면 이번엔 Repository 인터페이스를 만들어야 합니다. Entity의 기본적인 CRUD가 가능하도록 JpaRepository 인터페이스를 제공합니다. 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 기본 Query Spring Data JPA에서 기본적으로 제공하는 Query는 규칙에 맞게 작성해야 합니다. Method 설명 findBy… 쿼리를 요청 countBy… 쿼리 결과 행 수를 요청 orderBy… 쿼리 결과를 정렬 existsBy… 해당 조건의 항목이 존재하는지 확인 그리고 Query 메소드에 포함할 수 있는 키워드가 있습니다. 아래 참고 사이트에 자세하게 더 다양하게 정리가 되어있습니다. Keyword 설명 And 여러 컬럼을 and 로 쿼리 Or 여러 컬럼을 or 로 쿼리 Containing like 쿼리 Like like 쿼리 Between 컬럼의 두 값 사이에 있는 항목 쿼리 OrderBy 쿼리 결과를 정렬 In 여러 값 중에 하나인 항목 쿼리 Exists 해당 조건의 항목이 존재하는지 확인 아래는 예제 코드입니다. 12345678910111213User findByUserId(String userId);User findByUserIdAndPassword(String userId, String password);List&lt;User&gt; OrderByName();List&lt;User&gt; OrderByCreateDateDesc();List&lt;User&gt; findByRoleOrderByCreateDateDesc(Role role);List&lt;User&gt; findByNameContaining(String name);List&lt;User&gt; findByCreateDateBetween(LocalDateTime startDate, LocalDateTime endDate);boolean existsByUserId(String userId);int countByRole(Role role); JPQL(Java Persistence Query Language) JPQL은 SQL과 비슷한 문법을 가진 객체 지향 쿼리입니다. JPQL과 Native SQL 동일하게 @Query 어노테이션을 사용하여 쿼리를 작성하고, 또한 두 가지 방법으로 쿼리에 메소드의 매개변수 값을 전달할 수 있습니다. @Param 어노테이션을 사용하여 이름으로 정의 된 매개변수를 쿼리에 전달합니다. 메소드의 매개변수 순서로 쿼리에 전달합니다.(1부터 시작) 1234567891011121314@Query(value = \"SELECT u FROM User u WHERE u.role = 'GUEST'\")List&lt;User&gt; findByRole();@Query(\"SELECT u FROM User u WHERE u.userId = :userId\")User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT u FROM User u WHERE u.userId = :userId and u.password = :password\")User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT u FROM User u WHERE u.userId = ?1\")User findByUserId(String userId);@Query(\"SELECT u FROM User u WHERE u.userId = ?1 and u.password = ?2\")User findByUserIdAndPassword(String userId, String password); Native SQL 네이티브 SQL을 사용하여 쿼리를 정의할 수 있습니다. 네이티브 SQL을 사용하려면 nativeQuery 속성의 값을 true 로 설정합니다. 1234567891011121314@Query(value = \"SELECT * FROM tb_user u WHERE u.role = 'GUEST'\", nativeQuery = true)List&lt;User&gt; findByRole();@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId\", nativeQuery = true)User findByUserId(@Param(\"userId\") String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = :userId and u.password = :password\", nativeQuery = true)User findByUserIdAndPassword(@Param(\"userId\") String userId, @Param(\"password\") String password);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1\", nativeQuery = true)User findByUserId(String userId);@Query(\"SELECT * FROM tb_user u WHERE u.userId = ?1 and u.password = ?2\", nativeQuery = true)User findByUserIdAndPassword(String userId, String password); 참고 Spring Data JPA @Query https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"}]},{"title":"[JavaScript] 모달에서 이미지 및 동영상 출력","slug":"js-dev-4","date":"2021-06-16T13:25:20.000Z","updated":"2024-01-11T14:44:22.810Z","comments":true,"path":"2021/06/16/js-dev-4/","link":"","permalink":"http://hgko1207.github.io/2021/06/16/js-dev-4/","excerpt":"","text":"서론 [사진 보기], [동영상 보기] 버튼을 클릭 시 모달창이 띄워지면서 사진 또는 동영상이 출력되도록 하는 예제입니다. 사진과 동영상 파일을 images 경로에 저장하여 출력하였고, 실제 구동되는 프로젝트에서는 웹 서버가 실행되는 곳의 특정 경로에 저장하여 URL을 불러와서 출력합니다. html 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openImageModal()\"&gt;사진 보기&lt;/button&gt; &lt;button type=\"button\" class=\"btn\" onClick=\"openVideoModal()\"&gt;동영상 보기&lt;/button&gt; &lt;!-- 모달창 --&gt; &lt;div id=\"fileModal\" class=\"modal fade\" role=\"dialog\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header modal-header-sm\"&gt; &lt;h6 class=\"modal-title\"&gt;사진/동영상 보기&lt;/h6&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&amp;times;&lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body text-center\"&gt; &lt;div id=\"file-viewer\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; javascript JQuery를 이용하여 모달창을 생성합니다. 1234567891011121314151617181920212223242526272829// 이미지 출력 모달창 오픈function openImageModal() &#123; $('#file-viewer').empty(); let img = document.createElement('img'); img.setAttribute('src', 'images/image.jpg'); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); $('#fileModal').modal();&#125;// 동영상 출력 모달창 오픈function openVideoModal() &#123; $('#file-viewer').empty(); var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); // video 태그 사용 var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); ideo.setAttribute('src', 'images/video.mp4'); div.append(video); $('#file-viewer').append(div); $('#fileModal').modal();&#125; 응용 서버에서 파일를 조회하여 출력하도록 하는 예제입니다. 12345678910111213141516171819202122232425262728const contextPath = '$&#123;pageContext.request.contextPath&#125;';$.ajax(&#123; url: contextPath + '/file/get', type: 'GET', success: function (file) &#123; if (file.fileType == 'IMAGE') &#123; var img = document.createElement('img'); img.setAttribute('src', contextPath + '/uploads/' + file.fileName); img.setAttribute('class', 'img-fluid'); $('#file-viewer').append(img); &#125; else if (file.fileType == 'VIDEO') &#123; var div = document.createElement('div'); div.setAttribute('class', 'embed-responsive embed-responsive-16by9'); var video = document.createElement('video'); video.setAttribute('class', 'embed-responsive-item'); video.setAttribute('controls', 'controls'); video.setAttribute('src', contextPath + '/uploads/' + file.fileName); div.append(video); $('#file-viewer').append(div); &#125; $('#fileModal').modal(); &#125;,&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"}]},{"title":"[WPF] Slider Custom Style","slug":"wpf-3","date":"2021-06-04T13:50:55.000Z","updated":"2024-01-11T14:44:03.696Z","comments":true,"path":"2021/06/04/wpf-3/","link":"","permalink":"http://hgko1207.github.io/2021/06/04/wpf-3/","excerpt":"","text":"WPF 기본 Slider Stlye에서 Thumb을 드래그할 때마다 박스 안에 숫자가 표시되도록 Style 을 하였습니다. Slider 모양 Style 추가 App.xaml 에 추가하거나 Resource.xaml 파일을 생성하여 Style 을 추가합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;SolidColorBrush x:Key=\"CustomSliderBackgroundSolidColorBrush\" Color=\"#1E211B\" /&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderForegroundBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#9B5B2B\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#65351F\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;LinearGradientBrush x:Key=\"CustomSliderThumBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.2\" /&gt; &lt;GradientStop Color=\"#454543\" Offset=\"0.5\" /&gt; &lt;GradientStop Color=\"#3B3C39\" Offset=\"0.8\" /&gt;&lt;/LinearGradientBrush&gt;&lt;Style x:Key=\"CustomSliderThumbStyle\" TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Setter Property=\"Focusable\" Value=\"false\"/&gt; &lt;Setter Property=\"SnapsToDevicePixels\" Value=\"true\"/&gt; &lt;Setter Property=\"OverridesDefaultStyle\" Value=\"true\"/&gt; &lt;Setter Property=\"Height\" Value=\"20\"/&gt; &lt;Setter Property=\"Width\" Value=\"30\"/&gt; &lt;Setter Property=\"Cursor\" Value=\"Hand\"/&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type Thumb&#125;\"&gt; &lt;Canvas SnapsToDevicePixels=\"true\"&gt; &lt;Grid Height=\"20\" Width=\"30\"&gt; &lt;Rectangle x:Name=\"Background\" Fill=\"&#123;StaticResource CustomSliderThumBrush&#125;\" Stroke=\"#FFDADADA\" Height=\"20\" Width=\"30\" RadiusX=\"3\" RadiusY=\"3\"/&gt; &lt;TextBlock HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"White\" FontSize=\"10\" Text=\"&#123;Binding Value, RelativeSource=&#123;RelativeSource AncestorType=&#123;x:Type Slider&#125;&#125;&#125;\"/&gt; &lt;/Grid&gt; &lt;/Canvas&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property=\"IsMouseOver\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Orange\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsDragging\" Value=\"true\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"&#123;StaticResource CustomSliderThumBrush&#125;\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsEnabled\" Value=\"false\"&gt; &lt;Setter Property=\"Fill\" TargetName=\"Background\" Value=\"Gray\"/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt;&lt;/Style&gt;&lt;ControlTemplate x:Key=\"CustomSliderControlTemplate\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Border Background=\"Transparent\" SnapsToDevicePixels=\"True\"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=\"&#123;TemplateBinding MinHeight&#125;\" /&gt; &lt;/Grid.RowDefinitions&gt; &lt;DockPanel LastChildFill=\"True\"&gt; &lt;Border x:Name=\"PART_SelectionRange\" Height=\"5\" ClipToBounds=\"True\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 -10 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderForegroundBrush&#125;\" /&gt; &lt;/Border&gt; &lt;Border ClipToBounds=\"True\" Height=\"5\" Visibility=\"Visible\"&gt; &lt;Rectangle Margin=\"0 0 0 0\" RadiusX=\"2\" RadiusY=\"2\" Fill=\"&#123;StaticResource CustomSliderBackgroundSolidColorBrush&#125;\" /&gt; &lt;/Border&gt; &lt;/DockPanel&gt; &lt;Track x:Name=\"PART_Track\"&gt; &lt;Track.Thumb&gt; &lt;Thumb Style=\"&#123;StaticResource CustomSliderThumbStyle&#125;\" VerticalAlignment=\"Center\" Width=\"&#123;TemplateBinding MinWidth&#125;\" Height=\"&#123;TemplateBinding MinHeight&#125;\" OverridesDefaultStyle=\"True\" Focusable=\"False\" /&gt; &lt;/Track.Thumb&gt; &lt;/Track&gt; &lt;/Grid&gt; &lt;/Border&gt;&lt;/ControlTemplate&gt;&lt;Style x:Key=\"CustomSliderStyle\" TargetType=\"&#123;x:Type Slider&#125;\"&gt; &lt;Setter Property=\"Template\" Value=\"&#123;StaticResource CustomSliderControlTemplate&#125;\" /&gt; &lt;Setter Property=\"VerticalAlignment\" Value=\"Center\" /&gt; &lt;Setter Property=\"MinWidth\" Value=\"30\" /&gt; &lt;Setter Property=\"MinHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"Height\" Value=\"20\" /&gt; &lt;Setter Property=\"MaxHeight\" Value=\"20\" /&gt; &lt;Setter Property=\"BorderBrush\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\" /&gt; &lt;Setter Property=\"AutoToolTipPlacement\" Value=\"None\" /&gt; &lt;Setter Property=\"IsMoveToPointEnabled\" Value=\"True\" /&gt; &lt;Setter Property=\"SelectionStart\" Value=\"0\" /&gt; &lt;Setter Property=\"SelectionEnd\" Value=\"&#123;Binding Path=Value, RelativeSource=&#123;RelativeSource Self&#125;&#125;\" /&gt; &lt;Setter Property=\"Stylus.IsPressAndHoldEnabled\" Value=\"false\" /&gt;&lt;/Style&gt; Slider Style 적용 다음과 같이 Slider 에 Style을 지정합니다. 1&lt;Slider Minimum=\"1\" Maximum=\"255\" IsSnapToTickEnabled=\"True\" Style=\"&#123;StaticResource CustomSliderStyle&#125;\"/&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"}]},{"title":"[WPF] Prism ViewModelBase 정의","slug":"wpf-2","date":"2021-05-27T05:50:42.000Z","updated":"2024-01-11T14:43:41.706Z","comments":true,"path":"2021/05/27/wpf-2/","link":"","permalink":"http://hgko1207.github.io/2021/05/27/wpf-2/","excerpt":"","text":"WPF에서 Prism을 사용하여 ViewModel을 구현할 때 필요에 따라 Container, EventAggregator, RegionManager, Logger 등의 서비스를 사용합니다. 서비스를 각각 ViewModel 에 정의해서 사용하는 것이 아닌 공통으로 작성하여 편리하게 사용할 수 있는 추상 클래스를 작성하였습니다. ViewModelBase Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using Prism.Events;using Prism.Logging;using Prism.Ioc;using Prism.Mvvm;using Unity;namespace Prism.Project.Common.Mvvm&#123; public abstract class ViewModelBase : BindableBase &#123; private string title; public string Title &#123; get =&gt; title; set =&gt; SetProperty(ref title, value); &#125; protected IUnityContainer Container &#123; get; &#125; private IEventAggregator eventAggregator; /// &lt;summary&gt; /// The EventAggregator /// &lt;/summary&gt; public IEventAggregator EventAggregator &#123; get &#123; return eventAggregator; &#125; private set &#123; this.SetProperty&lt;IEventAggregator&gt;(ref this.eventAggregator, value); &#125; &#125; private IRegionManager regionManager; /// &lt;summary&gt; /// The region manager /// &lt;/summary&gt; public IRegionManager RegionManager &#123; get &#123; return regionManager; &#125; private set &#123; this.SetProperty&lt;IRegionManager&gt;(ref this.regionManager, value); &#125; &#125; protected ILoggerFacade Logger &#123; get; &#125; protected ViewModelBase(IUnityContainer container) &#123; Container = container; RegionManager = container.Resolve&lt;IRegionManager&gt;(); EventAggregator = container.Resolve&lt;IEventAggregator&gt;(); Logger = container.Resolve&lt;ILoggerFacade&gt;(); &#125; &#125;&#125; 사용 코드 ViewModelBase 클래스를 상속받고 생성자에 container 를 정의합니다. 1234567891011121314151617181920212223242526using Prism.Project.Common.Mvvm;using Unity;using Prism.Events;namespace Prism.Project.ViewModels&#123; public class MainWindowViewModel : ViewModelBase &#123; public MainWindowViewModel(IUnityContainer container) : base(container) &#123; Title = \"Prism 테스트\"; Logger.Log(\"[MainWindowViewModel Created]\", Category.Debug, Priority.None); // Event 예제 코드 EventAggregator.GetEvent&lt;MainWindowClosedEvent&gt;().Subscribe(MainWindowClosed); &#125; /// &lt;summary&gt; /// MainWindow 화면 종료 시 /// &lt;/summary&gt; private void MainWindowClosed() &#123; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"[JQuery] Select Box 제어","slug":"js-dev-3","date":"2021-05-21T02:47:06.000Z","updated":"2024-01-11T14:42:25.760Z","comments":true,"path":"2021/05/21/js-dev-3/","link":"","permalink":"http://hgko1207.github.io/2021/05/21/js-dev-3/","excerpt":"","text":"JQuery를 이용해서 select를 제어하는 방법에 대해 알아보겠습니다. 1&lt;select class=\"form-control\" name=\"name\" id=\"nameSelect\"&gt;&lt;/select&gt; 선택된 옵션 값 읽기 12$('#nameSelect option:selected').val();$('select[name=name]').val(); 선택된 옵션 이름 읽기 1$('#nameSelect option:selected').text(); 옵션 추가하기 123456$('#nameSelect').append( $('&lt;option&gt;', &#123; value: 1, text: '테스트', &#125;)); 값이 변경되었을 때 1234$('#nameSelect').change(function () &#123; const name = $(this).val(); console.log(name);&#125;); 특정한 값 선택하기 1$('#nameSelect').val(1).trigger('change'); 옵션 삭제 12345678// 지정한 인덱스의 옵션 삭제$('#nameSelect option:eq(0)').remove();// 첫 번째 옵션 삭제$('#nameSelect option:first').remove();// 마지막 옵션 삭제$('#nameSelect option:first').remove(); Select Box 비우기 1$('#nameSelect').empty();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"}]},{"title":"[Android] Yahoo Weather API를 이용하여 날씨정보 조회","slug":"android-dev-1","date":"2021-05-12T07:58:49.000Z","updated":"2024-01-11T14:42:02.757Z","comments":true,"path":"2021/05/12/android-dev-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/12/android-dev-1/","excerpt":"","text":"Yahoo Weather API를 이용하여 현재 위치의 날씨 정보를 조회하는 방법에 대해 알아보겠습니다. 개발 환경 Android Studio Java 설정 build.gradle -&gt; dependencies 추가 1implementation 'zh.wang.android:yweathergetter4a:1.3.0' manifest -&gt; permission 추가 1234567&lt;!-- 인터넷 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;!-- GPS 사용 권한 --&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 코드 작성 Activity 또는 Fragment에 YahooWeatherInfoListener 인터페이스를 implements 하면 gotWeatherInfo 함수를 오버라이딩(Override)을 하게 됩니다. 123456789101112public class WeatherActivity extends Activity implements YahooWeatherInfoListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; &#125;&#125; 이제 날씨 정보를 불러오기 위해 다음의 함수 중 상황에 맞게 호출합니다. 12345678// 장소 이름으로 쿼리public void queryYahooWeatherByPlaceName(final Context context, final String cityAreaOrLocation, final YahooWeatherInfoListener result)// 위도와 경도로 쿼리public void queryYahooWeatherByLatLon(final Context context, final String lat, final String lon, final YahooWeatherInfoListener result)// GPS를 사용하여 현재 위치로 쿼리public void queryYahooWeatherByGPS(final Context context, final YahooWeatherInfoListener result) 이번 프로젝트에는 GPS를 사용하여 현재 위치의 날씨 정보를 얻었습니다. 쿼리 함수를 호출하면 오버라이딩한 gotWeatherInfo 함수를 통해 날씨 정보를 얻을 수 있습니다. 123456YahooWeather yahooWeather = YahooWeather.getInstance();yahooWeather.setNeedDownloadIcons(true);yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS);yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS);yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); 날씨 정보를 한 번만 불러오는 것이 아니라 1분마다 얻기 위해 Timer를 사용하였습니다. Timer를 사용하기 위해 위의 코드를 함수로 만들었습니다. 12345678910111213141516171819Timer timer = new Timer();timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125;&#125;, 0, 1000 * 60);public void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this);&#125; 이제 1분 마다 날씨 정보를 불러올 수 있게 되었습니다. 현재 위치, 시간, 온도, 습도, 대기압, 풍향, 풍속 등의 다양한 날씨 정보를 화면에 표출하여 완성하였습니다. 1234567891011121314151617@Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; 전체 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// WeatherActivity.javaimport android.os.Handler;import android.os.Looper;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import butterknife.BindView;import butterknife.ButterKnife;import me.hgko.networkinfo.R;import zh.wang.android.yweathergetter4a.WeatherInfo;import zh.wang.android.yweathergetter4a.YahooWeather;import zh.wang.android.yweathergetter4a.YahooWeatherInfoListener;public class WeatherActivity extends AppCompatActivity implements YahooWeatherInfoListener &#123; private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss\"); @BindView(R.id.logitudeText) TextView logitudeText; @BindView(R.id.latitudeText) TextView latitudeText; @BindView(R.id.datetimeText) TextView datetimeText; @BindView(R.id.addressText) TextView addressText; @BindView(R.id.weatherText) TextView weatherText; @BindView(R.id.temperatureText) TextView temperatureText; @BindView(R.id.humidityText) TextView humidityText; @BindView(R.id.pressureText) TextView pressureText; @BindView(R.id.windDirectionText) TextView windDirectionText; @BindView(R.id.windSpeedText) TextView windSpeedText; @BindView(R.id.windChillText) TextView windChillText; @BindView(R.id.visibilityText) TextView visibilityText; private YahooWeather yahooWeather; private Timer timer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); ButterKnife.bind(this); yahooWeather = YahooWeather.getInstance(); timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; searchByGPS(); &#125; &#125;); &#125; &#125;, 0, 1000 * 60 * 10); &#125; @Override public void gotWeatherInfo(WeatherInfo weatherInfo, YahooWeather.ErrorType errorType) &#123; if (weatherInfo != null) &#123; datetimeText.setText(dateFormat.format(new Date())); logitudeText.setText(weatherInfo.getAddress().getLongitude() + \"\"); latitudeText.setText(weatherInfo.getAddress().getLatitude() + \"\"); addressText.setText(weatherInfo.getAddress().getAddressLine(0)); weatherText.setText(weatherInfo.getCurrentText()); temperatureText.setText(weatherInfo.getCurrentTemp() + \" ºC\"); humidityText.setText(weatherInfo.getAtmosphereHumidity() + \" %\"); pressureText.setText(weatherInfo.getAtmospherePressure()); windDirectionText.setText(weatherInfo.getWindDirection() + \"˚\"); windSpeedText.setText(weatherInfo.getWindSpeed() + \" m/s\"); windChillText.setText(weatherInfo.getWindChill() + \" °F\"); visibilityText.setText(weatherInfo.getAtmosphereVisibility()); &#125; &#125; private void searchByGPS() &#123; yahooWeather.setNeedDownloadIcons(true); yahooWeather.setUnit(YahooWeather.UNIT.CELSIUS); yahooWeather.setSearchMode(YahooWeather.SEARCH_MODE.GPS); yahooWeather.queryYahooWeatherByGPS(getApplicationContext(), this); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!-- activity_weather.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"20dp\" android:paddingLeft=\"20dp\" android:paddingRight=\"20dp\" android:paddingTop=\"20dp\" tools:context=\".activity.WeatherActivity\"&gt; &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Datetime :\" /&gt; &lt;TextView android:id=\"@+id/datetimeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Logitude :\" /&gt; &lt;TextView android:id=\"@+id/logitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Latitude :\" /&gt; &lt;TextView android:id=\"@+id/latitudeText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Address :\" /&gt; &lt;TextView android:id=\"@+id/addressText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Weather :\" /&gt; &lt;TextView android:id=\"@+id/weatherText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Temperature :\" /&gt; &lt;TextView android:id=\"@+id/temperatureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Chill :\" /&gt; &lt;TextView android:id=\"@+id/windChillText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Direction :\" /&gt; &lt;TextView android:id=\"@+id/windDirectionText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Wind Speed :\" /&gt; &lt;TextView android:id=\"@+id/windSpeedText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Humidity :\" /&gt; &lt;TextView android:id=\"@+id/humidityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Pressure :\" /&gt; &lt;TextView android:id=\"@+id/pressureText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:orientation=\"horizontal\"&gt; &lt;TextView style=\"@style/TextStyle1\" android:text=\"Visibility :\" /&gt; &lt;TextView android:id=\"@+id/visibilityText\" style=\"@style/TextStyle2\" android:textColor=\"@color/colorBlue\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; TextView 에 공통으로 스타일을 지정하기 위해 styles.xml 에 추가합니다. 123456789101112131415&lt;style name=\"TextStyle1\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;1&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt;&lt;style name=\"TextStyle2\"&gt; &lt;item name=\"android:layout_width\"&gt;0dp&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_weight\"&gt;2&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt;&lt;/style&gt; 실행 결과 앱을 실행하면 아래 이미지와 같이 현재 위치의 날씨 정보를 확인할 수 있습니다. 참고 https://github.com/zh-wang/YWeatherGetter4a","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"}]},{"title":"[MATLAB] MinGW-W64 수동 설치","slug":"matlab-1","date":"2021-05-06T07:41:52.000Z","updated":"2024-01-11T14:41:22.480Z","comments":true,"path":"2021/05/06/matlab-1/","link":"","permalink":"http://hgko1207.github.io/2021/05/06/matlab-1/","excerpt":"","text":"MATLAB에서 개발하고 MATLAB Coder를 사용하여 C 또는 C++ 코드로 변환하려고 하였다. 그런데 MEX 컴파일러를 확인할 수 없다는 에러가 났습니다. MATLAB 에서 mex -setup 명령어를 실행했더니 다음과 같이 MinGW-w64 C/C++ 컴파일러를 설치해야 한다는 내용이 나왔습니다. 1234&gt;&gt; mex -setup다음 사용 중 오류가 발생함: mex사용할 수 있는 컴파일러 또는 SDK를 찾을 수 없습니다. 무료로 제공되는 MinGW-w64 C/C++ 컴파일러를 설치할 수 있습니다. MinGW-w64 컴파일러 설치를 참조하십시오. 더 많은 옵션을보려면 http://www.mathworks.com/support/compilers/R2016a/win64.html을 참조하십시오. 구글 검색했을 때 홈 탭 &gt; 환경 섹션 &gt; 애드온 을 이용하여 설치할 수 있다고 하였는데 지금 사용하고 있는 MATLAB 2016a 버전 같은 경우에는 설치를 지원하지 않는 것인지 자동으로 설치를 할 수가 없었습니다. 그래서 직접 설치 파일을 다운로드하여 설치를 진행하였습니다. 수동 설치 https://jmeubank.github.io/tdm-gcc/download/ 페이지에서 현재 최신 버전인 tdm64-gcc-9.2.0.exe 설치 파일 다운로드(윈도우 운영체제에 맞게 다운로드) 위 그림처럼 체크를 해제한 후 Create 버튼을 클릭 설치 경로는 공백이 없는 C:\\TDM-GCC-64 경로로 지정하여 설치 환경 변수가 자동으로 등록되며 설치 완료 환경 설정 및 setup MATLAB 으로 돌아와서 setenv 명령어를 통해 설치된 경로에 대해 환경 설정을 하고 mex -setup 명령어를 실행하면 이제 MinGW64 Compiler를 사용할 수 있습니다. 123456789101112&gt;&gt; setenv ( 'MW_MINGW64_LOC', 'C:\\TDM-GCC-64' )&gt;&gt; mex -setupMEX이(가) C 언어 컴파일에 'MinGW64 Compiler (C)'을(를) 사용하도록 구성되었습니다.경고: 2^32-1개의 요소를 초과하는 MATLAB 변수를 지원하기 위해 MATLAB C와 Fortran API가 변경되었습니다. 새 API를 활용하기 위해서는 가까운 시일 내에 코드를 업데이트해야 할 수 있습니다. 자세한 내용은 http://www.mathworks.com/help/matlab/matlab_external/upgrading-mex-files-to-use-64-bit-api.html에서 확인할 수 있습니다.다른 언어를 선택하려면 다음 중 하나를 선택하십시오. mex -setup C++ mex -setup FORTRAN MinGW64 Compiler (C++) 을 사용하도록 구성할 시 다음 명령어를 실행합니다. 1&gt;&gt; mex -setup C++ 결과 MATLAB Coder를 이용한 Code 변환도 성공적으로 완료되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"}]},{"title":"[C++] 평균, 표준편차 구하기","slug":"cpp-coding-4","date":"2021-04-28T00:49:09.000Z","updated":"2023-03-14T02:22:32.765Z","comments":true,"path":"2021/04/28/cpp-coding-4/","link":"","permalink":"http://hgko1207.github.io/2021/04/28/cpp-coding-4/","excerpt":"","text":"평균 및 표준편차 계산 함수 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;// 평균 계산 함수template&lt;class T&gt;double Mean(std::vector&lt;T&gt; array)&#123; double sum = 0.0; for (int i = 0; i &lt; array.size(); i++) sum += array[i]; return sum / array.size();&#125;// 표준 편차 계산 함수template&lt;class T&gt;double StandardDeviation(std::vector&lt;T&gt; array)&#123; double meanValue = Mean&lt;T&gt;(array); // 배열 요소가 1개밖에 없을 때는 // NaN(숫자가 아님)이라는 의미로 // sqrt(-1.0) 을 반환 int size = array.size(); if (size &lt; 2) &#123; return sqrt(-1.0); &#125; double sum = 0.0; for (int i = 0; i &lt; size; i++) &#123; double diff = array[i] - meanValue; sum += diff * diff; &#125; return sqrt(sum / (size - 1));&#125; 테스트 123456789101112131415161718int main()&#123; std::vector&lt;int&gt; array; array.push_back(5); array.push_back(2); array.push_back(7); array.push_back(8); array.push_back(4); array.push_back(1); array.push_back(10); array.push_back(9); double meanValue = Mean&lt;int&gt;(array); double stddevValue = StandardDeviation&lt;int&gt;(array); std::cout &lt;&lt; \"meanValue : \" &lt;&lt; meanValue &lt;&lt; std::endl; std::cout &lt;&lt; \"stddevValue : \" &lt;&lt; stddevValue &lt;&lt; std::endl;&#125; 결과 12meanValue : 5.75stddevValue : 3.28416","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"}]},{"title":"[JAVA] 날짜 비교","slug":"java-dev-7","date":"2021-04-26T01:18:29.000Z","updated":"2024-01-11T14:40:35.864Z","comments":true,"path":"2021/04/26/java-dev-7/","link":"","permalink":"http://hgko1207.github.io/2021/04/26/java-dev-7/","excerpt":"","text":"SimpleDateFormat을 이용한 날짜 비교하는 방법에 대해 알아보겠습니다. 소스코드 12345678910111213141516171819202122232425262728293031import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatExample &#123; public static long getDayCount( String start, String end ) &#123; SimpleDateFormat format = new SimpleDateFormat( \"yyyy-M-d\" ); long diff = -1; try &#123; Date dateStart = format.parse( start ); Date dateEnd = format.parse( end ); // time is always 00:00:00 so rounding should help to ignore the // missing hour when going from winter to summer time as well as the // extra hour in the other direction diff = Math.round( ( dateEnd.getTime() - dateStart.getTime() ) / (double)( 60 * 60 * 24 * 1000 ) ); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; return diff; &#125; public static void main( String[] args ) &#123; long diff = getDayCount( \"2021-1-1\", \"2021-4-26\" ); System.out.println( \"결과 : \" + diff + \" 일\" ); &#125;&#125; 결과 1결과 : 115 일","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"}]},{"title":"[C++] Is the Point Inside the Polygon?","slug":"cpp-coding-3","date":"2021-04-13T04:58:06.000Z","updated":"2023-03-14T02:22:27.678Z","comments":true,"path":"2021/04/13/cpp-coding-3/","link":"","permalink":"http://hgko1207.github.io/2021/04/13/cpp-coding-3/","excerpt":"","text":"point-in-polygon (PIP) “In computational geometry, the point-in-polygon (PIP) problem asks whether a given point in the plane lies inside, outside, or on the boundary of a polygon.” Wikipedia. 점이 다각형(Polygon) 내부에 있는지 확인하는 코드입니다. 123456789101112131415161718192021struct Point&#123; int x; int y;&#125;;bool InsidePolygon(int nvert, Point polygon[], int pointx, int pointy)&#123; int i, j = 0; bool inside = false; for (i = 0, j = nvert - 1; i &lt; nvert; j = i++) &#123; if (((polygon[i].y &gt; pointy) != (polygon[j].y &gt; pointy)) &amp;&amp; (pointx &lt; (polygon[j].x - polygon[i].x) * (pointy - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) &#123; inside = !inside; &#125; &#125; return inside;&#125; 인수 nvert : 다각형의 정점 수 polygon[] : 다각형을 형성하는 점의 배열 pointx : 점의 X 좌표 pointy : 점의 Y 좌표 테스트 12345678910111213int main()&#123; Point polygon[] = &#123;&#123;0, 0&#125;, &#123;50, 0&#125;, &#123;50, 50&#125;, &#123;0, 50&#125;&#125;; int n = sizeof(polygon) / sizeof(polygon[0]); bool result = InsidePolygon(n, polygon, 0, 5); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; result = InsidePolygon(n, polygon, 60, 20); result ? std::cout &lt;&lt; \"YES \\n\" : std::cout &lt;&lt; \"NO \\n\"; return 0;&#125; 결과 12YESNO","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[Oracle] Spatial Data Query","slug":"oracle-2","date":"2021-03-18T00:39:31.000Z","updated":"2023-03-14T02:22:25.175Z","comments":true,"path":"2021/03/18/oracle-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/18/oracle-2/","excerpt":"","text":"Table 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); INSERT SDO_GEOMETRY 컬럼에 넣을 데이터는 타입마다 형식이 다릅니다. Point(점) 타입 1234567SDO_GEOMETRY( 2001, 4326, SDO_POINT_TYPE(126.64,36.86, NULL), NULL, NULL ) Rectangle(직사각형) 타입 12345678SDO_GEOMETRY( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), -- 1개의 사각형 SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88) -- 사각형을 정의하기 위해 오직 2개의 포인트 필요(lower left and upper right)) Polygon 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1), -- 1개의 폴리곤 SDO_ORDINATE_ARRAY(126.63,36.88, 126.64,36.88, 126.64,36.84, 126.63,36.84, 126.63,36.88) ) Circle(원) 타입 1234567SDO_GEOMETRY( 2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,4), -- 1개의 원 SDO_ORDINATE_ARRAY(8,7, 10,9, 8,11) -- 1개의 원은 최소 3개의 점으로 정의됨 ) 두 개의 폴리곤 1234567SDO_GEOMETRY ( 2003, -- 2차원의 폴리곤 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1, 19,2003,1), SDO_ORDINATE_ARRAY(0,0, 10,0, 10,10, 0,10, 0,0, 4,4, 6,4, 6,6, 4,6, 4,4) ) Insert 예제 12345INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.63,36.84, 126.65,36.88)) ); SELECT 입력된 직사각형 영역 안의 데이터 조회 1234567891011# SDO_INTERSECTION(geometry1, geometry2, tolerance);SELECT id, nameFROM sample_tableWHERE SDO_GEOM.SDO_INTERSECTION( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 0.005 ) is not null 1234567891011# SDO_RELATE(geometry1, geometry2, param);SELECT id, nameFROM sample_tableWHERE SDO_RELATE( shape, SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(126.61,36.82, 126.66,36.90)), 'mask=INSIDE+OVERLAPBDYINTERSECT+EQUAL+COVERS' ) = 'TRUE' 위의 쿼리에서 SDO_RELATE 의 param에 대한 내용은 참고 사이트에 자세하게 설명되어 있습니다. X, Y 좌표 조회 12SELECT name, t.x, t.y, t.idFROM sample_table s, TABLE(SDO_UTIL.GETVERTICES(s.shape)) t Polygon Center 좌표 조회 12345SELECT SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.X x, SDO_GEOM.SDO_CENTROID(s.shape, m.diminfo).SDO_POINT.Y yFROM sample_table s, user_sdo_geom_metadata mWHERE name = 'Polygon' Geometry 형식이 맞는가? 12SELECT s.name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(s.shape, 0.005)FROM sample_table s 참고 Oracle Help Center - Spatial Relationships and Filtering","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"}]},{"title":"[Oracle] SDO_GEOMETRY 사용 방법","slug":"oracle-1","date":"2021-03-16T01:22:54.000Z","updated":"2024-01-11T14:38:12.419Z","comments":true,"path":"2021/03/16/oracle-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/16/oracle-1/","excerpt":"","text":"SDO_GEOMETRY Oracle Spatial을 사용하여 공간 데이터를 생성하고 관리합니다. Oracle 에는 SDO_GEOMETRY 타입을 통하여 공간 데이터를 구성할 수 있습니다. SDO_GEOMETRY 은 다음과 같이 정의됩니다. 1234567CREATE TYPE sdo_geometry AS OBJECT ( SDO_GTYPE NUMBER, SDO_SRID NUMBER, SDO_POINT SDO_POINT_TYPE, SDO_ELEM_INFO SDO_ELEM_INFO_ARRAY, SDO_ORDINATES SDO_ORDINATE_ARRAY); SDO_GTYPE 00 - UNKNOWN_GEOMETRY 01 - POINT 02 - LINE or CURVE 03 - POLYGON or SURFACE 04 - COLLECTION 05 - MULTIPOINT 06 - MULTILINE or MULTICURVE 07 - MULTIPOLYGON or MULTISURFACE 08 - SOLID 09 - MULTISOLID 예) 2003 일 경우 2차원의 POLYGON 형식 SDO_SRID Geometry와 연관된 Coordinate System(Spatial Reference System)입니다. 값이 NULL 이면 관련된 Coordinate System 이 없는 것입니다. SDO_POINT POINT 형식일 때 사용합니다. SDO_POINT_TYPE(x, y, z) 을 통해 포인트를 입력합니다. SDO_ELEM_INFO SDO_ORDINATES 에 저장될 값의 형식을 정의합니다. 예) SDO_ELEM_INFO_ARRAY(1,1003,3) 첫 번째 1 은 SDO_ORDINATES 에 입력된 도형 ARRAY 의 시작 위치 1003과 3은 도형 형식을 정의 1003 은 외부도형, 2003 일 경우 내부도형 (1,1003,1) or (1,2003,1) : 폴리곤 형식으로 4면 다각형의 경우 5개의 점을 지정하고 점 5와 점 1은 동일 (1,1003,3) or (1,2003,3) : 직사각형 유형. 왼쪽 하단과 오른쪽 상단의 두 점을 지정 (1,1003,4) or (1,2003,4) : 원형 유형. 최소 3개의 점을 지정해야 함 자세한 내용은 참고 사이트에서 확인 SDO_ORDINATES SDO_ELEM_INFO 에서 정의된 형식으로 값을 입력합니다. Spatial Table 생성 1. 테이블 생성 shape 필드에 SDO_GEOMETRY 타입을 지정하여 Spatial 테이블을 생성하였습니다. 123456CREATE TABLE sample_table( id NUMBER PRIMARY KEY, name VARCHAR2(20), shape SDO_GEOMETRY); 2. 메타데이터 생성 SDO_GEOMETRY 를 사용하기 전에 꼭 메타데이터를 생성해줘야 합니다. 1234567891011121314151617insert into user_sdo_geom_metadata ( table_name, column_name, diminfo, srid )values ( 'sample_table', 'shape', SDO_DIM_ARRAY( SDO_DIM_ELEMENT('Longitude', -180, 180, 0.5), =&gt; 10 미터 허용오차 SDO_DIM_ELEMENT('Latitude', -90, 90, 0.5) ), 4326 ====&gt; Longitude/Latitude(WGS 84) : 4326 ); 3. 인덱스 생성 메타데이터 생성 후 Spatial 테이블의 인덱스를 생성합니다. 12345# 인덱스 생성 형식CREATE INDEX index_name ON table_name(column_name) INDEXTYPE IS MDSYS.SPATIAL_INDEX;# 사용 예제CREATE INDEX sample_index ON sample_table(shape) indextype IS MDSYS.SPATIAL_INDEX; 4. 데이터 입력 테이블을 생성하고 메타데이터와 인덱스까지 생성하였으면 데이터를 넣어봅니다. 123456# Rectangle 데이터INSERT INTO sample_table (id, name, shape)VALUES ( 1, 'Rectangle', SDO_GEOMETRY(2003, 4326, NULL, SDO_ELEM_INFO_ARRAY(1,1003,3), SDO_ORDINATE_ARRAY(5,5, 10,10)) ); 5. 확인 입력된 데이터가 SDO_GEOMETRY 형식인지 확인합니다. 결과가 TRUE 가 아니면 잘못된 입력입니다. 1234SELECT id, name, SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(shape, 0.5) FROM sample_table;# 결과1, Rectangle, TRUE SDO_GEOMETRY 타입을 사용하여 공간 데이터 생성을 진행하였습니다. 다음에는 생성된 공간 데이터에 대한 쿼리를 알아보겠습니다. 참고 Oracle Help Center - SDO_GEOMETRY Object Type Oracle Help Center - Polygon with a Hole Oracle Spatial Geometry Type 및 Spatial Table 생성","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"}]},{"title":"[Spring Boot] 환경에 따른 설정 방법","slug":"springboot-2","date":"2021-03-11T00:38:25.000Z","updated":"2024-01-11T14:37:10.341Z","comments":true,"path":"2021/03/11/springboot-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/11/springboot-2/","excerpt":"","text":"Spring Boot를 사용하여 웹 프로젝트를 할 때에 환경(개발 또는 배포)에 따라 설정 값들을 달리 할 필요가 있습니다. Spring Boot 에서는 application.properties 파일을 profile 로 구분하여 사용할 수 있습니다. profile을 작성하지 않을 경우 default로 application.properties를 사용합니다. application.properties 작성 규칙 profile을 포함한 파일명을 작성합니다. 1234567891011121314# defaultapplication.properties# 배포 환경(prod)application-prod.properties# 개발 환경(dev)application-dev.properties# 테스트 환경(test)application-test.properties# customapplication-custom.properties 예제 개발과 배포할 때의 설정을 나눈 예제입니다. 파일 생성 12345# 배포용(기본)application.properties# 개발용(dev)application-dev.properties application.properties 설정 application-dev.properties 파일에 spring.profiles.active=dev 을 추가합니다. application.properties 12345678# Server 설정server.port=8080# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://[외부 IP]:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=root!23 application-dev.properties 1234567891011# Profile 설정 - 이 값을 꼭 넣어야 합니다.spring.profiles.active=dev# Server 설정server.port=8081# Database 설정spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=test!23 Application 실행 설정 STS(Spring Tool Suite) - Spring Boot Run 다음의 이미지와 같이 Profile에 적용하고자 하는 환경 값(예: dev)을 선택하면 application-dev.properties의 설정을 읽어옵니다. 실행 테스트 dev 환경을 주입 후 실행 테스트를 하였습니다. dev 환경일 때 서버 포트를 8081으로 설정을 하였었는데 다음의 실행 로그를 보면 Tomcat started on port(s): 8081 처럼 8081 포트로 서버가 실행된 것을 확인할 수 있습니다. 123452021-03-11 13:52:28.738 INFO 13588 --- [ restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'2021-03-11 13:52:28.772 INFO 13588 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292021-03-11 13:52:29.903 INFO 13588 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2021-03-11 13:52:30.836 INFO 13588 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path '/admin'2021-03-11 13:52:30.839 INFO 13588 --- [ restartedMain] c.y.a.a.EAfterschoolAdminApplication : Started EAfterschoolAdminApplication in 6.985 seconds (JVM running for 7.822)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"}]},{"title":"[JavaScript] String형 Bytes length 구하기","slug":"js-dev-2","date":"2021-03-10T00:52:06.000Z","updated":"2023-06-12T13:57:01.518Z","comments":true,"path":"2021/03/10/js-dev-2/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/js-dev-2/","excerpt":"","text":"UTF-8 인코딩 방식 바이트 길이 구하기 한글 한글자당 3 바이트씩 계산됩니다. 12345678910// Functionconst getByteLengthOfString = function (s, b, i, c) &#123; for (b = i = 0; (c = s.charCodeAt(i++)); b += c &gt;&gt; 11 ? 3 : c &gt;&gt; 7 ? 2 : 1); return b;&#125;;// Testconst test = '테스트';console.log('length : ', getByteLengthOfString(test), 'Bytes'); 12// 결과length : 9 Bytes 한글의 경우 2바이트 계산되도록 다음의 함수를 통해 한글 문자열의 바이트 수를 2 바이트로 나오게 할 수 있습니다. 1234567891011121314151617181920// FunctionString.prototype.getBytes = function () &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; &#125; return int_char_count;&#125;;// Testconst test = '테스트';console.log('length : ', test.getBytes(), 'Bytes'); 12// 결과length : 6 Bytes 입력된 길이 만큼의 문자열을 리턴 1234567891011121314151617181920212223242526// FunctionString.prototype.getStringFromByteLength = function (length) &#123; const contents = this; let str_character; let int_char_count = 0; let int_contents_length = contents.length; let returnValue = ''; for (k = 0; k &lt; int_contents_length; k++) &#123; str_character = contents.charAt(k); if (escape(str_character).length &gt; 4) int_char_count += 2; else int_char_count++; if (int_char_count &gt; length) &#123; break; &#125; returnValue += str_character; &#125; return returnValue;&#125;;// Testconst test = '테스트';console.log('result : ', test.getStringFromByteLength(4)); 12// 결과result: 테스;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"[JAVA] String형 Bytes length 구하기","slug":"java-dev-6","date":"2021-03-10T00:32:48.000Z","updated":"2024-01-18T01:36:11.174Z","comments":true,"path":"2021/03/10/java-dev-6/","link":"","permalink":"http://hgko1207.github.io/2021/03/10/java-dev-6/","excerpt":"","text":"String 길이 구하기 12String test = \"테스트\";System.out.println(\"length : \" + test.length()); 12# 결과length : 3 바이트 길이 구하기 1234String test = \"테스트\";int length = test.getBytes().length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 9 Bytes 기본 인코딩이 UTF-8 설정되어있을 경우 한글은 한글자당 3바이트씩 계산됩니다. 한글 한글자당 2바이트씩 나오게 하려면 다음과 같이 인코딩을 설정하면 됩니다. 12345String charset = \"euc-kr\";String test = \"테스트\";int length = test.getBytes(charset).length;System.out.println(\"length : \" + length + \" Bytes\"); 12# 결과length : 6 Bytes 인코딩 문자셋에 따라 바이트 길이 구하기 12345678910111213141516/** * 문자열의 바이크 길이 구하기 * 인코딩 문자셋에 따라 바이크 길이 달라짐. * * @param str 문자열 * @param charset 인코딩 문자셋 * @return */private int getByteLength(String str, String charset) &#123; try &#123; return str.getBytes(charset).length; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"}]},{"title":"[Spring Boot] Maven 빌드 방법","slug":"springboot-1","date":"2021-03-09T04:52:07.000Z","updated":"2024-01-11T14:35:24.116Z","comments":true,"path":"2021/03/09/springboot-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/09/springboot-1/","excerpt":"","text":"STS(Spring Tool Suite)에서 빌드 방법 메뉴 -&gt; Run -&gt; Run Configurations -&gt; Maven Build(우클릭) -&gt; New Configuration 클릭 [Name] 입력 란에 작성 [Base directory] 에서 Workspace 버튼 클릭 빌드하려는 프로젝트 선택 [Goals] 입력 란에 clean install 작성 저장 후 빌드 실행 아래 이미지는 설정 한 내용입니다. Maven 빌드 중에 데이터베이스 연결을 제외하는 방법 Maven Build -&gt; [Goals] 입력 란에 clean install -DskipTests 작성합니다. 또는 pom.xml에 아래 코드를 추가합니다. 1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"}]},{"title":"[Kubernetes] 명령어들","slug":"kubernetes-1","date":"2021-03-04T02:17:05.000Z","updated":"2023-03-14T02:22:11.262Z","comments":true,"path":"2021/03/04/kubernetes-1/","link":"","permalink":"http://hgko1207.github.io/2021/03/04/kubernetes-1/","excerpt":"","text":"명령어들 123456789101112131415161718192021222324# 생성kubectl create -f test.pod.yaml# 중지 및 삭제kubectl delete pod test --grace-period=0 --forcekubectl delete service test# node 정보 확인kubectl get nodes# pod 확인kubectl get pods --all-namespaces# 서비스 확인kubectl get svc# 배포 확인kubectl get deployments# 상세 정보 확인kubectl describe pods# 개별 상세 정보 확인kubectl describe pod &lt;name&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"}]},{"title":"[Docker] 명령어들","slug":"docker-2","date":"2021-01-26T06:18:26.000Z","updated":"2023-03-14T02:22:08.827Z","comments":true,"path":"2021/01/26/docker-2/","link":"","permalink":"http://hgko1207.github.io/2021/01/26/docker-2/","excerpt":"","text":"컨테이너 관련 명령어들 명령어 설명 docker ps 실행되고 있는 컨테이너 목록 docker ps -a 전체 컨테이너 목록 docker ps --no-trunc 컨테이너 정보 전체 표시 docker logs [컨테이너명 or ID] 로그 확인 docker exec -i -t [컨테이너명 or ID] /bin/bash 컨테이너 내부 셸 접속 docker rm [컨테이너명 or ID] 컨테이너 삭제 docker rm -f [컨테이너명 or ID] 컨테이너 강제 삭제 docker commit [옵션] [컨테이너명] [이미지명]:[태그] 컨테이너 커밋 12345678# 컨테이너 압축# export의 경우 컨테이너를 동작하는데 필요한 모든 파일이 압축됨docker export [컨테이너명 or ID] &gt; [파일명]docker export test &gt; test.tar# 컨테이너 importdocker import [파일명]docker import test.tar 이미지 관련 명령어들 명령어 설명 docker images 이미지 목록 확인 docker build [옵션] [이미지명] [Dockerfile 경로] 이미지 생성 docker rmi [이미지명 or ID] 이미지 삭제 docker tag [기존 이미지명] [새로운 이미지명] 이미지 태그명 변경 docker tag [기존 이미지명]:[기존 태그명] [새로운 이미지명]:[새로운 태그명] 이미지 태그명 변경 docker pull [저장소 주소]/[이미지명] 도커 허브에서 다운로드 docker push [저장소 주소]/[이미지명] 도커 허브 저장소에 이미지 올리기 1234567891011121314# 이미지 압축docker save [옵션] [파일명] &lt;이미지명 또는 이미지ID&gt;docker save -o baseimage.tar baseimage# 모든 이미지 압축docker save -o images.tar $(docker image ls -q)# gzip을 이용한 이미지 압축docker save [이미지명] | gzip &gt; [파일명]docker save baseimage | gzip &gt; baseimage.tar.gz# 이미지 로드docker load [옵션] [파일명]docker load -i baseimage.tar 기타 명령어 12# 컨테이너 정보 일부 표시docker ps --format \"table &#123;&#123;.image&#125;&#125;\\t&#123;&#123;.command&#125;&#125;\"","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[CentOS] Cmake 설치 및 사용 방법","slug":"linux-11","date":"2021-01-25T07:36:18.000Z","updated":"2024-01-11T14:34:58.640Z","comments":true,"path":"2021/01/25/linux-11/","link":"","permalink":"http://hgko1207.github.io/2021/01/25/linux-11/","excerpt":"","text":"리눅스 환경에서 Cmake 설치 및 사용 방법에 대해 알아보겠습니다. 다운로드 https://cmake.org/download/ 페이지를 가서 최신 버전을 다운로드합니다.현재 날짜 기준으로 3.19.3 버전입니다. 123[hgko@localhost ~]$ sudo su[root@localhost ~]$ cd /usr/local/src[root@localhost src]$ wget http://www.cmake.org/files/v3.19/cmake-3.19.3.tar.gz 다운로드가 완료되면 압축해제를 합니다. 1[root@localhost src]$ tar -zxvf cmake-3.19.3.tar.gz 설치 /usr/local 경로의 bin 폴더에 설치가 됩니다. 1234[root@localhost src]$ cd cmake-3.19.3[root@localhost cmake-3.19.3]$ ./bootstrap --prefix=/usr/local[root@localhost cmake-3.19.3]$ make[root@localhost cmake-3.19.3]$ make install 설치 확인 다음과 같이 버전 정보가 출력되면 성공적으로 설치가 완료되었습니다. 1234[root@localhost ~]$ cmake --versioncmake version 3.19.3CMake suite maintained and supported by Kitware (kitware.com/cmake). 사용 방법 다음 명령어는 사용 방법입니다. CMakeLists.txt 파일을 생성하고 내용을 작성 cmake 명령어로 실행 123$ cmake CMakeLists.txt$ make$ make install make 파일 정리 1$ make clean","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"}]},{"title":"[CentOS] 유용하게 쓰는 명령어들","slug":"linux-10","date":"2021-01-20T01:53:23.000Z","updated":"2023-03-14T02:22:03.502Z","comments":true,"path":"2021/01/20/linux-10/","link":"","permalink":"http://hgko1207.github.io/2021/01/20/linux-10/","excerpt":"","text":"유용하게 쓰는 명령어들 명령어 설명 source /etc/profile profile 적용 free -h 메모리 용량 확인 dh -h 디스크 용량 확인 nproc CPU 코어 수 확인 pwd 현재 경로 확인 chmod -R 755 [폴더 or 파일] 사용 권한 변경 chown -R root:root [폴더 or 파일] 소유자와 그룹 변경 ps -ef | grep [프로세스명] 프로세스 확인 rpm -qa | grep [패키지명] 설치된 패키지 확인 kill -9 [프로세스ID] 프로세스 삭제 mv [파일명] [변경할파일명] 파일명 바꾸기 mv [폴더명] [변경할폴더명] 폴더명 바꾸기 pgrep -f [파일명] 프로세스 id만 추출 1234567891011121314151617# 특정 파일 제외하고 삭제find ./ ! -name '*.h' -exec rm -rf &#123;&#125; \\;# 두 개의 파일 형식 빼고 다 삭제# 예) .h, .inl 파일 빼고 삭제find ./ \\( ! -name '*.inl' ! -name '*.h' \\) -exec rm -rf &#123;&#125; \\;# 별칭 설정alias rm='rm -i'alias cp='cp -i'alias mv='mv -i'# 환경변수 설정export LD_LIBRARY_PATH=/usr/bin:$LD_LIBRARY_PATH# 폴더와 하위 폴더에 있는 파일명 텍스트로 추출dir [폴더경로] &gt; list.txt 12# tail -n 로 가장 나중의 jar 파일 찾기ls -tr | grep jar | tail -n 1 가끔 쓰인 명령어들 명령어 설명 uname -r 커널 버전 확인 ln -s [원본파일] [링크파일] 심볼릭 링크 설정","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[CentOS] Nginx 설치 및 사용 방법","slug":"linux-9","date":"2020-11-16T02:35:35.000Z","updated":"2024-01-11T14:34:25.936Z","comments":true,"path":"2020/11/16/linux-9/","link":"","permalink":"http://hgko1207.github.io/2020/11/16/linux-9/","excerpt":"","text":"리눅스 환경에서 Nginx 설치 및 사용 방법에 대해 알아보겠습니다. 1. Nginx 저장소 추가 yum 저장소에는 nginx 라이브러리가 없기 때문에 저장소를 추가합니다. 1[hgko@localhost ~]$ sudo vi /etc/yum.repos.d/nginx.repo /etc/yum.repos.d 경로에 nginx.repo 파일을 추가하고 다음과 같이 작성합니다. 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1 2. 설치 저장소를 추가하였다면 설치를 합니다. 1[hgko@localhost ~]$ sudo yum install -y nginx 3. 방화벽 포트 개방 웹서버의 8080 포트를 사용할 계획이므로, 8080 포트를 개방합니다. 123456# 포트 개방[hgko@localhost ~]$ sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp# 방화벽 재시작[hgko@localhost ~]$ sudo firewall-cmd --reload# 개방된 포트 목록 확인[hgko@localhost ~]$ sudo firewall-cmd --list-ports 4. 서비스 시작 서비스를 등록하고 시작합니다. 12[hgko@localhost ~]$ sudo systemctl enable nginx[hgko@localhost ~]$ sudo systemctl start nginx 5. 웹 서버 배포 서비스가 시작되었으면 개발된 웹 서버 배포 작업을 진행합니다. 빌드된 프로젝트를 /usr/share/nginx/ 경로로 이동시킵니다. 기존의 설정파일인 default.conf 파일을 엽니다. 기존 설정파일을 지우고 새로 생성해도 됩니다. 포트를 변경하고, 프로젝트 경로를 입력하고, 필요한 proxy 정보를 입력합니다. proxy_pass에는 backend server url을 입력합니다. 12[hgko@localhost ~]$ sudo su[root@localhost ~]$ vi /etc/nginx/conf.d/default.conf 12345678910111213141516171819202122232425262728293031server &#123; listen 8080; listen [::]:8080; server_name localhost; # 도메인 주소 root /usr/share/nginx/frontend; # 배포된 프로젝트 경로 index index.html index.htm; client_max_body_size 100M; location ^~ /api &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; location ^~ /stream &#123; proxy_pass http://127.0.0.1:3100; # backend url proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_cache_bypass $http_upgrade; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 6. 서비스 재시작 설정이 완료되면 서비스를 재시작합니다. 1[hgko@localhost ~]$ sudo systemctl restart nginx 7. 확인 http://localhost:8080을 접속하여 웹 서버가 잘 실행되고 있는지 확인합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"}]},{"title":"[CentOS] PM2 설치 및 사용 방법","slug":"linux-8","date":"2020-10-26T06:57:59.000Z","updated":"2024-01-11T14:33:51.482Z","comments":true,"path":"2020/10/26/linux-8/","link":"","permalink":"http://hgko1207.github.io/2020/10/26/linux-8/","excerpt":"","text":"리눅스 환경에서 PM2 설치 및 사용 방법에 대해서 알아보겠습니다. Node.js 는 단일 CPU 코어에서 실행되기 때문에 CPU 개수만큼 멀티코어 시스템을 사용하기 위해 PM2(Process Manager 2) 를 설치하고 사용하였습니다. 설치 npm이 설치되어 있어야 합니다. 1[root@localhost ~]$ npm install pm2 -g 설치 확인 pm2 프로세스의 상태를 확인합니다. 처음에는 시작한 애플리케이션이 없기 때문에 아무것도 없습니다. 1[root@localhost ~]$ pm2 list 기본 사용 방법 pm2를 사용해 보기 위해 간단한 애플리케이션을 작성하겠습니다. app.js 파일을 생성하고 아래 코드를 복사합니다. 123456789101112// app.jsconst express = require('express');const app = express();const port = 3000;app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);app.listen(port, function () &#123; console.log(`application is listening on port $&#123;port&#125;...`);&#125;); pm2를 통해 실행합니다. 1[root@localhost test]$ pm2 start app.js 또는 이름을 지정하여 실행할 수 있습니다. 1[root@localhost test]$ pm2 start app.js --name app 아무런 옵션없이 PM2를 사용하여 실행하면 위의 그림처럼 포크(fork) 모드로 애플리케이션을 실행합니다. 클러스터 모드 사용 설정파일을 활용해 클러스터 모드로 실행할 수 있습니다. 123# 설정파일 생성[root@localhost test]$ touch ecosystem.config.js[root@localhost test]$ vi ecosystem.config.js 1234567891011// ecosystem.config.jsmodule.exports = &#123; apps: [ &#123; name: 'app', script: './app.js', instances: 0, exec_mode: 'cluster', &#125;, ],&#125;; 1[root@localhost test]$ pm2 start ecosystem.config.js 위의 코드를 복사하고 pm2 명령어로 실행하면 클러스터 모드로 실행됩니다. exec_mode 값을 'cluster’로 설정하면 클러스터 모드로 실행한다는 의미이고, instances 값을 '0’으로 설정하면 CPU 코어 수 만큼 프로세스를 실행한다는 의미입니다. instances 값을 0이 아닌 고정으로 설정할 수도 있습니다. 다수의 어플리케이션 설정 123456789101112131415161718module.exports = &#123; apps: [ &#123; name: 'collect', cwd: './workspace/pipeline-service-collector', script: 'npm', args: 'run serve', instances: 5, exec_mode: 'cluster', &#125;, &#123; name: 'collect-manager', cwd: './workspace/pipeline-service-collector-manager', script: 'npm', args: 'run serve', &#125;, ],&#125;; 위의 코드는 두 개의 애플리케이션을 실행하는 예제입니다. 첫 번째는 클러스터 모드로 5개의 프로세스를 실행하도록 설정하였고, 두 번째는 포크(fork) 모드로 하나의 프로세스를 실행하도록 하였습니다. 이렇게 여러 개의 애플리케이션을 한 번에 실행하도록 설정을 할 수도 있습니다. 실제로 동작하는 상태는 아래 그림과 같습니다. 프로세스 줄이기 프로세스의 수가 많다면 프로세스를 2개로 줄일 수 있습니다. 1[root@localhost test]$ pm2 scale app 2 재시작 1[root@localhost test]$ pm2 reload 중지 1[root@localhost test]$ pm2 stop app 삭제 1[root@localhost test]$ pm2 delete app 추가 설정 nodejs 권한이 잘못 되어있는 경우 1234[hgko@localhost test]$ sudo su[root@localhost test]$ cd /usr/local/lib[root@localhost lib]$ chown -R hgko:hgko nodejs[root@localhost lib]$ exit","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"}]},{"title":"[CentOS] 아파치 톰캣(Tomcat) 설치 및 사용 방법","slug":"linux-7","date":"2020-10-12T01:30:46.000Z","updated":"2024-01-11T14:31:29.414Z","comments":true,"path":"2020/10/12/linux-7/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-7/","excerpt":"","text":"리눅스 환경에서 아파치 톰캣 설치 및 사용 방법에 대해 알아보겠습니다. 아파치 톰캣(Tomcat) 이란 아파치 톰캣(Apache Tomcat)은 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너(또는 웹 컨테이너)만 있는 웹 애플리케이션 서버이다. 톰캣은 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 자바서버 페이지(JSP)와 자바 서블릿이 실행할 수 있는 환경을 제공하고 있다. 톰캣은 관리툴을 통해 설정을 변경할 수 있지만, XML 파일을 편집하여 설정할 수도 있다. 그리고, 톰캣은 HTTP 서버도 자체 내장하기도 한다. 출처 : 위키백과 1. 다운로드 http://archive.apache.org/dist/tomcat/tomcat-8/ 사이트에서 최신 버전을 확인하고 다운로드합니다. 12[hgko@localhost ~]$ cd /home/download[hgko@localhost download]$ wget http://archive.apache.org/dist/tomcat/tomcat-8/v8.5.59/bin/apache-tomcat-8.5.59.tar.gz 오프라인 환경에서는 Tomcat 8 Download 사이트 접속해서 tar.gz 파일을 직접 다운로드 후 서버에 전송합니다. 2. 설치 먼저 tar 명령어를 사용하여 압축을 풀어 줍니다. 압축이 풀리면 모든 사용자가 사용하고 관리가 편리하도록 Root 계정으로 접속 후 해당 폴더로 이동시켜줍니다. 123456# 압축 해제[hgko@localhost download]$ tar zxvf apache-tomcat-8.5.59.tar.gz# 폴더 이동[hgko@localhost download]$ sudo su[root@localhost download]$ mv /home/download/apache-tomcat-8.5.59 /usr/local/lib 3. 환경 설정 1[root@localhost ~]$ vi /etc/profile 123456JAVA_HOME=/usr/local/javaJRE_HOME=/usr/local/javaCATALINA_HOME=/usr/local/lib/apache-tomcat-8.5.59CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$CATALINA_HOME/lib/jsp-api.jar:$CATALINA_HOME/lib/servlet-api.jarPATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/binexport JAVA_HOME JRE_HOME CLASSPATH PATH CATALINA_HOME Tomcat 설정 부분(CATALINA)만 수정하면 됩니다. 설정이 완료되면 반영합니다. 12345# 설정 반영[root@localhost ~]$ source /etc/profile# 설정 확인[root@localhost ~]$ echo $CATALINA_HOME 4. 방화벽 설정 현재 톰캣 포트가 8080이기 때문에 8080 포트에 대한 방화벽을 설정합니다. 12[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=8080/tcp[root@localhost ~]$ firewall-cmd --reload 5. 실행 12[root@localhost ~]$ cd /usr/local/lib/apache-tomcat-8.5.59/bin[root@localhost bin]$ ./startup.sh 6. 중지 1[root@localhost bin]$ ./shutdown.sh 7. 실행 확인 http://localhost(ip 주소):8080 에 접속해서 확인합니다. 1[root@localhost bin]$ tail -f /usr/local/lib/apache-tomcat-8.5.59/logs/catalina.out tail 명령어를 사용하여 로그 내용을 출력해서 진행 상태를 파악할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"}]},{"title":"[CentOS] NFS 설치 및 설정 방법","slug":"linux-6","date":"2020-10-12T00:42:48.000Z","updated":"2024-01-11T14:29:35.392Z","comments":true,"path":"2020/10/12/linux-6/","link":"","permalink":"http://hgko1207.github.io/2020/10/12/linux-6/","excerpt":"","text":"리눅스 환경에서 NFS 설치 및 설정 방법에 대해 알아보겠습니다. NFS 란 네트워크 파일 시스템(Network File System, NFS)은 1984년에 썬 마이크로시스템즈가 개발한 프로토콜이다. 클라이언트 컴퓨터의 사용자가 네트워크 상의 파일을 직접 연결된 스토리지에 접근하는 방식과 비슷한 방식으로 접근하도록 도와준다. 다른 수많은 프로토콜과 마찬가지로 ONC RPC 시스템을 기반으로 한다. 네트워크 파일 시스템은 RFC에 정의된 오픈 표준이므로 누구나 구현할 수 있다. 출처 : 위키백과 운영환경 CentOS 7.6 NFS 서버 설정 1. 설치 nfs-utils 패키지가 설치되어있는지 확인하고 없을 시 yum을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 부팅 시 자동 시작되도록 서비스 등록을 하고 실행을 합니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트 할 디렉토리 생성 마운트 할 임의의 디렉토리 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 마운트 설정을 위해 /etc/export 파일을 수정합니다. 1$ vi /etc/export 아래 내용을 추가합니다. 1/nfstest 192.168.0.*(rw,sync) /nfstest: 공유할 디렉토리 192.168.0.*: 허가할 호스트 대역 rw : 읽기, 쓰기 가능 ro : 읽기만 가능 secure : 클라이언트 마운트 요청 시 포트를 1024 이하로 설정 noaccess : 액세스 거부 root_squach : 클라이언트의 root가 서버의 root 권한을 획득하는 것을 차단 no_root_squash : 클라이언트의 계정을 root로 매핑 sync : 파일 시스템이 변경되면 즉시 동기화 all_squach : root를 제외하고 서버와 클라이언트의 사용자를 동일한 권한으로 설정 no_all_squach : root를 제외하고 서버와 클라이언트의 사용자들을 하나의 권한을 가지도록 설정 참고로 /etc/exports 에서 IP 입력 후 띄어쓰기 없이 (rw) 설정을 해야하고, 만약 띄어쓰기를 사용하면 설정이 제대로 되지 않아 Read-only 설정으로 되어 에러가 발생할 수 있습니다. 5. 수정내용 적용 수정한 export 내용을 적용합니다. 1$ exportfs -r 서비스를 재시작 합니다. 1$ systemctl restart nfs-server 6. 수정내용 확인 NFS 설정이 정상적으로 되었는지 확인합니다. 12$ showmount -e$ exportfs -v 클라이언트 마운트 설정 1. 설치 nfs-utils 패키지가 설치되어 있는지 확인하고 없을 시 yum을 사용하여 설치합니다. 12345# 설치 패키지 확인$ rpm -qa | grep nfs-utils# nfs 설치$ yum install nfs-utils 2. 서비스 시작 서비스 등록 및 시작 명령어입니다. 12$ systemctl enable nfs-server$ systemctl start nfs-server 3. 마운트할 디렉토리 생성 마운트 할 임의의 디렉토리를 생성합니다. 12$ mkdir /nfstest$ chmod 700 /nfstest 4. 마운트 생성된 디렉토리에 NFS 디렉토리를 마운트 합니다. 1$ mount -t nfs 192.168.0.100:/nfstest /nfstest 192.168.0.100: nfs 서버 주소 5. 마운트 영구 적용 마운트 영구 적용을 위해 /etc/fstab 파일을 수정합니다. 12$ vi /etc/fstab192.168.0.100:/nfstest /nfstest nfs defaults 0 0 192.168.0.100: nfs 서버 주소 6. 마운트 확인 정상적으로 마운트 되었는지 확인을 합니다. 12$ df -h | grep nfs192.168.0.100:/nfstest 24G 6.4G 16G 30% /nfstest 7. 설정 확인 설정이 완료되었다면 /nfstest 경로에서 파일을 생성해 보고 클라이언트와 서버에 제대로 공유가 되는지 확인합니다. 12[root@localhost ~]$ cd /nfstest[root@localhost nfstest]$ touch test","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"}]},{"title":"[PostgreSQL] TimescaleDB 설치 방법","slug":"postgresql-4","date":"2020-10-08T04:12:58.000Z","updated":"2024-01-11T08:27:52.346Z","comments":true,"path":"2020/10/08/postgresql-4/","link":"","permalink":"http://hgko1207.github.io/2020/10/08/postgresql-4/","excerpt":"","text":"TimescaleDB 란 TimescaleDB는 빠른 수집, 복잡한 쿼리를 편리하게 사용하기 위해 설계된 오픈 소스 시계열 데이터베이스입니다. PostgreSQL을 기반으로 하며 자동 파티셔닝과 SQL 지원을 제공합니다. PostgreSQL 보다 10 ~ 100배 빠른 쿼리를 수행하고 시계열에 대해 최적화가 되어 있습니다. 5 ~ 10분 단위로 수집되는 많은 양의 데이터를 데이터베이스에 추가하고 시계열로 관리하며 빠르게 조회하기 위해 TimescaleDB를 사용하였습니다. 운영환경 CentOS 7.6 PostgreSQL 11 설치 PostgreSQL이 설치되어있어야 합니다. 미설치 시 [PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작을 참고해서 설치합니다. 1. PostgreSQL 설치 확인 1$ rpm -qa | grep postgresql 2. 계정 확인 1$ cat /etc/passwd | grep postgres postgres 계정이 없으면 생성합니다. 12$ sudo useradd postgres$ sudo passwd postgres 3. 설정 변경 1234$ vi /var/lib/pgsql/11/data/postgresql.conf#listen_addresses = 'localhost' -&gt; listen_addresses = '*'#password_encryption = md5 -&gt; password_encryption = md5 4. TimescaleDB 다운로드 다음 명령어를 복사해서 붙여 넣습니다. 123456789101112$ sudo cat &gt; /etc/yum.repos.d/timescale_timescaledb.repo &lt;&lt;EOL[timescale_timescaledb]name=timescale_timescaledbbaseurl=https://packagecloud.io/timescale/timescaledb/el/7/\\$basearchrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/timescale/timescaledb/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300EOL 12$ sudo yum update -y$ yum install -y timescaledb-postgresql-11 5. 데이터베이스 설정 계속 y를 눌러줍니다. 1$ sudo timescaledb-tune --pg-config=/usr/pgsql-11/bin/pg_config 6. PostgreSQL 재시작 1$ systemctl restart postgresql-11 7. 접속 123$ sudo su$ su - postgres$ psql","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"}]},{"title":"[CentOS] Apache Kafka 설치 및 사용 방법","slug":"linux-5","date":"2020-10-01T13:16:06.000Z","updated":"2023-06-04T14:51:05.343Z","comments":true,"path":"2020/10/01/linux-5/","link":"","permalink":"http://hgko1207.github.io/2020/10/01/linux-5/","excerpt":"","text":"아파치 카프카(Apache Kafka)는 아파치 소프트웨어 재단이 스칼라로 개발한 오픈 소스 메시지 브로커 프로젝트이다. 출처 : 위키백과 메시지 큐를 사용하여 동기화 서비스 및 대용량 분산 시스템을 구축하기 위해 Zookeeper와 함께 Apache Kafka를 사용하게 되었습니다. 운영환경 CentOS 7.6 1. 다운로드 및 설치 123[root@localhost ~]$ cd /home/test[root@localhost test]$ wget http://apache.mirror.cdnetworks.com/kafka/2.1.0/kafka_2.11-2.3.0.tgz[root@localhost test]$ ln -s kafka_2.11-2.3.0 kafka 2. server.properties 수정 123456789101112[root@localhost test]$ vim kafka/config/server.properties# zookeeper 서버의 myid 값으로 설정broker.id=1#Broker가 받은 데이터를 관리위한 저장공간log.dirs=/home/test/kafka-logs#Broker가 사용하는 호스트와 포트를 지정listeners=PLAINTEXT://0.0.0.0:9002#Producer와 Consumer가 접근할 호스트와 포트를 지정, 기본값은 listeners를 사용advertised.listeners=PLAINTEXT://192.168.24.10:9092# zookeeper의 접속 정보zookeeper.connect=192.168.24.7:2181 3. 실행 12[root@localhost test]$ cd kafka/bin[root@localhost bin]$ ./kafka-server.start.sh ../config/server.properties 정상적으로 실행이 되면 다음과 같은 메시지가 뜹니다. 12....중략....[KafkaServer id=1] started (kafka.server.KafkaServer) 4. 서비스 등록 마지막으로 kafka-server.service라는 스크립트를 만들고 서비스에 등록합니다. 123# 종료 후 서비스 등록[root@localhost bin]$ ./kafka-server-stop.sh[root@localhost bin]$ vi /etc/systemd/system/kafka.service 1234567891011121314151617[Unit]Description=kafkaAfter=network.target[Service]Type=simpleUser=testGroup=testSyslogIdentifier=kafkaWorkingDirectory=/home/test/kafkaRestart=alwaysRestartSec=0sExecStart=/home/test/kafka/bin/kafka-server-start.sh /home/test/kafka/config/server.propertiesExecStop=/home/test/kafka/bin/kafka-server-stop.sh[Install]WantedBy=multi-user.target 저장하고 나서 서비스를 재시작하고 카프카를 실행합니다. 정상적으로 실행되면 시스템 부팅 시 자동실행 설정을 지정합니다. 12345678# 서비스 데몬 재시작[root@localhost ~]$ systemctl daemon-reload# 카프카 실행 (종료는 stop, 재시작은 restart)[root@localhost ~]$ systemctl start kafka-server.service# 실행상태 확인[root@localhost ~]$ systemctl status kafka-server.service# 시스템 부팅할때 자동실행 설정[root@localhost ~]$ systemctl enable kafka-server.service 방화벽 설정 1234[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=9092/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload kafka topic 관리 topic 리스트 123# 192.168.24.7는 zookeeper 접속 주소[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --list --zookeeper 192.168.24.7:2181 topic 생성 topic 명은 manager-out 로 설정하였습니다. 123[root@localhost ~]$ cd /home/test/kafka/bin[root@localhost bin]$ ./kafka-topics.sh --create --zookeeper 192.168.24.7:2181 --replication-factor 1 --partitions 5 --topic manager-out[root@localhost bin]$ ./kafka-topics.sh --zookeeper 192.168.24.7:2181 --alter --topic manager-out --config retention.ms=600000 topic 삭제 1[root@localhost bin]$ ./kafka-topics.sh --delete --zookeeper 192.168.24.7:2181 --topic manager-out topic 상세정보 1[root@localhost bin]$ ./kafka-topics.sh --describe --zookeeper 192.168.24.7:2181","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"}]},{"title":"[CentOS] Apache Zookeeper 설치 및 사용 방법","slug":"linux-4","date":"2020-09-28T01:36:53.000Z","updated":"2024-01-11T08:26:08.304Z","comments":true,"path":"2020/09/28/linux-4/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-4/","excerpt":"","text":"아파치 주키퍼(Apache ZooKeeper)는 아파치 소프트웨어 재단 프로젝트 중의 한 소프트웨어 프로젝트로서 공개 분산형 구성 서비스, 동기 서비스 및 대용량 분산 시스템을 위한 네이밍 레지스트리를 제공한다. 주키퍼는 하둡의 한 하위 프로젝트이었으나 지금은 독립적인 상위 프로젝트이다. 출처 : 위키백과 위의 설명처럼 메시키 큐를 관리하고 동기 서비스 및 대용량 분산 시스템을 구축하기 위해 Apache ZooKeeper 를 사용할 경우가 있습니다. Apache ZooKeeper 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Java jdk 설치 먼저 java jdk를 필수로 설치를 합니다. 1[root@localhost ~]$ yum install java-1.8.0-openjdk.x86_64 profile 정보를 변경합니다. 1234[root@localhost ~]$ vim /etc/profile# profile 파일 안에 아래의 내용을 추가export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk source 명령어를 이용해서 변경된 내용 적용합니다. 1[root@localhost ~]$ source /etc/profile Zookeeper 설치 Zookeeper 서버 패키지를 다운로드하고 환경 설정을 합니다. 1. 계정 생성 먼저 계정을 생성합니다. 계정을 생성하는 이유는 Zookeeper를 별도로 관리하기 위함입니다. 12[root@localhost ~]$ useradd zookeeper[root@localhost ~]$ passwd zookeeper 생성된 계정으로 변경합니다. 1[root@localhost ~]$ su - zookeeper 2. 다운로드 및 설치 다음의 명령어 순서대로 실행해서 다운로드 한 후 압축을 해제합니다. 1234[zookeeper@localhost ~]$ cd /home/test[zookeeper@localhost zookeeper]$ wget http://apache.mirror.cdnetworks.com/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ tar xvfzp zookeeper-3.4.14.tar.gz[zookeeper@localhost zookeeper]$ ln -s zookeeper-3.4.14 zookeeper 3. 설정 파일 변경 데이터 디렉터리 경로와 서버 설정을 합니다. 12345678[zookeeper@localhost test]$ cd zookeeper/conf[zookeeper@localhost conf]$ cp zoo_sample.cfg zoo.cfg[zookeeper@localhost conf]$ vim zoo.cfgdataDir=/home/test/zookeeper/data #zookeeper 데이터 위치, 원하는 경로에 저장입력server.1=zoo-1:2888:3888 #멀티 서버 설정 (주키퍼 서버가 한곳이 아닐때)# server.2=server_host_1:2888:3888# server.3=server_host_2:2888:3888 4. myid 생성 반드시 myid 파일을 dataDir 속성에 넣었던 경로에 만들어야 합니다. 호스트마다 아이디를 부여해야 합니다. 위의 설정에서 server.1에만 설정하였기 때문에 {dataDir}/myid 내부에 1이라는 값이 있어야 합니다. 그리고 이 값은 유일해야 하고 1~255 사이로 설정해야 합니다. 123[zookeeper@localhost ~]$ cd /home/test/zookeeper/data[zookeeper@localhost data]$ touch myid[zookeeper@localhost data]$ echo 1 &gt; myid 5. Zookeeper 서버 실행 다음 명령어를 실행하면 이상없이 서버가 실행됩니다. 12[zookeeper@localhost ~]$ cd /home/test/zookeeper/bin[zookeeper@localhost bin]$ ./zkServer.sh start 실행 확인 12[zookeeper@localhost bin]$ ./zkCli.sh -server zoo-1:2181[zookeeper@localhost bin]$ ls / Zookeeper 서버 중지 1[zookeeper@localhost bin]$ ./zkServer.sh stop 추가 설정 추가적으로 프로세스 저장 경로와 로그 저장 경로 변경 및 환경변수 등록을 위한 절차입니다. 변경하지 않아도 됩니다. 폴더 권한 변경 Zookeeper 프로세스 아이디 저장 폴더와 로그 저장 폴더를 생성하고 권한을 변경합니다. 1234567891011# root 계정으로 전환[zookeeper@localhost ~]$ su -[root@localhost ~]$ cd /var/run[root@localhost run]$ mkdir zookeeper[root@localhost run]$ chown zookeeper:zookeeper /var/run/zookeeper[root@localhost run]$ cd ../log[root@localhost log]$ mkdir zookeeper[root@localhost log]$ chown zookeeper:zookeeper /var/log/zookeeper# zookeeper 계정으로 다시 돌아가기[root@localhost log]$ exit 추가로 위 두개의 폴더에 링크를 생성합니다. 123[zookeeper@localhost log]$ cd /home/test/zookeeper[zookeeper@localhost zookeeper]$ ln -s /var/run/zookeeper/ pids[zookeeper@localhost zookeeper]$ ln -s /var/log/zookeeper/ logs 환경변수 변경 12345678910export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdkexport ZOOKEEPER_HOME=/home/test/zookeeperexport ZOOKEEPER_CONF_DIR=$ZOOKEEPER_HOME/confexport ZOOKEEPER_LOG_DIR=/var/log/zookeeperexport ZOO_LOG_DIR=$ZOOKEEPER_LOG_DIRexport ZOOKEEPER_PID_DIR=/var/run/zookeeperexport ZOOPIDFILE=$ZOOKEEPER_PID_DIR/zookeeper_server.pidexport SERVER_JVMFLAGS=-Xmx1024mexport JAVA=$JAVA_HOME/bin/javaexport CLASSPATH=$ZOOKEEPER_CONF_DIR:/usr/share/java/jline.jar:/usr/share/java/log4j-1.2.jar:/usr/share/java/xercesImpl.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/netty.jar:/usr/share/java/slf4j-api.jar:/usr/share/java/slf4j-log4j12.jar:/usr/share/java/zookeeper.jar 서버 재시작 12[zookeeper@localhost bin]$ ./zkServer.sh stop[zookeeper@localhost bin]$ ./zkServer.sh start 방화벽 설정 123456[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2181/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=2888/tcp[root@localhost ~]$ firewall-cmd --permanent --zone=public --add-port=3888/tcp## 방화벽 재시작[root@localhost ~]$ firewall-cmd --reload","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"}]},{"title":"[CentOS] Proxy 서버를 사용한 내부망 yum 사용 방법","slug":"linux-3","date":"2020-09-28T00:49:32.000Z","updated":"2024-01-11T08:25:32.267Z","comments":true,"path":"2020/09/28/linux-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/28/linux-3/","excerpt":"","text":"서버가 운영되는 시스템은 인터넷이 안 되는 시스템이 많습니다. 이런 상황에서 yum 을 통한 Package 를 설치할 수 없게 되어 관리가 쉽지 않습니다. Proxy 서버를 이용하여 인터넷이 가능한 하나의 서버 시스템을 통해 모든 서버가 인터넷이 가능하도록 구성할 수 있습니다. 운영환경 CentOS 7.6 설치 인터넷이 되는 서버에 squid Package를 설치합니다. 1$ yum -y install squid 설정 다음과 같이 Proxy 정책을 설정합니다. 1$ vi /etc/squid/squid.conf 12345678910111213141516... 생략 ...# Only allow cachemgr access from localhost#http_access allow localhost manager#http_access deny managerhttp_access allow all # 모든 IP 에 대해 Allow 정책 추가# And finally deny all other access to this proxy#http_access deny all # deny 정책 해제... 생략 ...# Squid normally listens to port 3128http_port 8080 # Proxy 로 사용하길 원하는 Port 지정#http_port 3128 서비스 시작 12$ systemctl start squid$ systemctl status squid 정상적으로 Proxy 서비스가 안될경우 다음과 같이 커널 파라미터를 추가합니다. 12net.ipv6.conf.all.disable_ipv6 = 1net.ipv4.ip_forward = 1 Proxy 서비스 테스트 인터넷이 안되는 내부 시스템에서 다음 명령어를 실행합니다. 1234567891011121314[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorDetermining fastest mirrorsCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - \"Could not resolve host: mirrorlist.centos.org; Unknown error\"Loading mirror speeds from cached hostfileLoading mirror speeds from cached hostfileLoading mirror speeds from cached hostfilerepo id repo name statusbase/7/x86_64 CentOS-7 - Base 0extras/7/x86_64 CentOS-7 - Extras 0updates/7/x86_64 CentOS-7 - Updates 0repolist: 0[root@localhost ~]# 아직 yum 을 사용 할 수 없습니다. yum.conf 수정 /etc/yum.conf 파일에 다음과 같이 proxy 옵션을 추가합니다. 인터넷이 되는 시스템의 IP와 Port 정보를 입력합니다. 12345678910111213141516[root@localhost ~]# vi /etc/yum.conf[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-releaseproxy=http://192.168.100.200:8080 # Proxy 서버 정보 추가 테스트 yum 사용이 가능한지 다시 확인합니다. 12345678910111213141516[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorLoaded plugins: fastestmirror, langpacksRepository nodesource is listed more than once in the configurationRepository nodesource-source is listed more than once in the configurationLoading mirror speeds from cached hostfile * base: mirror.kakao.com * epel: ftp.riken.jp * extras: mirror.kakao.com * updates: mirror.kakao.comrepo id repo name statusbase/7/x86_64 CentOS-7 - Base 10,070extras/7/x86_64 CentOS-7 - Extras 413updates/7/x86_64 CentOS-7 - Updates 1,134repolist: 11,617[root@localhost ~]# 위와 같은 결과가 나타나면 yum 을 사용할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"}]},{"title":"[CentOS] VNC 설치 및 사용 방법(오프라인 환경)","slug":"linux-2","date":"2020-09-19T12:18:14.000Z","updated":"2024-01-11T08:25:07.112Z","comments":true,"path":"2020/09/19/linux-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/19/linux-2/","excerpt":"","text":"오프라인 환경에서 VNC 설치 및 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 Server 설치 다운로드 http://mirror.centos.org/centos/7/os/x86_64/Packages/ 사이트에 접속 후 tigervnc-server-1.8.0-19.el7.x86_64.rpm 파일을 선택하여 다운로드합니다. 다운로드가 완료되면 파일을 리눅스 환경으로 이동시킵니다. 설치 및 설정 12345# 실행$ sudo rpm -ivh tigervnc-server-1.8.0-19.el7.x86_64.rpm# 1 입력 시 5901 포트번호로 생성됩니다.cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 12345$ vi /etc/systemd/system/vncserver@:1.service# 변경ExecStart=/usr/bin/vncserver_wrapper &lt;USER&gt; %i- &lt;USER&gt;를 서버 계정으로 변경 서비스 등록 12$ systemctl daemon-reload$ systemctl enable vncserver@:1.service 방화벽 설정 123456# 포트 열기$ firewall-cmd --zone=public --permanent --add-port=5901/tcp# 포트 갱신$ firewall-cmd --reload# 포트 확인$ firewall-cmd --zone=public --list-all Client 설치 및 접속 https://www.realvnc.com/en/connect/download/viewer/ 사이트 접속 후 Download VNC Viewer를 클릭하여 다운로드합니다. 다운로드가 완료되면 설치를 합니다. VNC Viewer 실행 후 상단 search 란에 host:5901 입력 후 Enter 키를 누릅니다. 서버 계정명과 패스워드를 입력하면 리눅스 환경의 화면이 나오는 것을 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"}]},{"title":"[Node.js] 시작 및 구성 방법","slug":"nodejs-1","date":"2020-09-15T09:11:31.000Z","updated":"2024-01-11T08:24:36.670Z","comments":true,"path":"2020/09/15/nodejs-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/15/nodejs-1/","excerpt":"","text":"다운로드 및 설치 위의 페이지에 접속한 후 플랫폼에 맞게 선택을 하여 다운로드합니다. Windows 환경에서 개발하기 위해 Windows Installer (.msi) 64-bit를 다운로드 합니다. 현재 최신 LTS 버전은 v16.17.0 버전입니다. 다운 받은 인스톨러 파일을 실행해서 설치를 진행합니다. 설치가 완료되면 다음 명령어를 실행해서 확인을 합니다. 12345D\\&gt; node -vv16.17.0D\\&gt; npm -v8.15.0 Node.js를 설치하면 자동으로 NPM 이 설치가 됩니다. npm (노드 패키지 매니저/Node Package Manager)은 자바스크립트 프로그래밍 언어를 위한 패키지 관리자이다. 자바스크립트 런타임 환경 Node.js의 기본 패키지 관리자이다. 출처 : 위키백과 시작 1. 작업 디렉터리 생성 12D:\\&gt; mkdir node_testD:\\&gt; cd node_test 2. 프로젝트 초기화 npm init 명령어를 실행하면 각 항목들을 설정할 수 있는데 아무것도 입력하지 않고 엔터만 치면 괄호안의 기본값 또는 빈값으로 설정이 됩니다. 최종적으로 모든 설정이 끝나면 package.json 파일의 경로와 내용이 출력되고 yes를 입력하게 되면 저장과 동시에 종료됩니다. 1234567891011121314151617181920212223242526272829303132333435D:\\node_test&gt; npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\\node_test\\package.json:&#123; \"name\": \"node_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125;Is this OK? (yes) yesD:\\node_test&gt; 3. 패키지 설치 npm install 명령어를 실행합니다. 1D:\\node_test&gt; npm install 설치된 패키지들은 node_modules 디렉터리에 저장됩니다. 4. 웹 사이트 구축 app.js 파일을 생성합니다. 1D:\\node_test&gt; copy /Y /b NUL app.js 간단하게 Node.js 시작 가이드에 있는 코드를 복사해서 붙여넣습니다. 123456789101112131415// app.jsconst http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 5. 실행 node app.js 명령어를 실행합니다. 12D:\\node_test&gt; node app.jsServer running at http://127.0.0.1:3000/ 실행이 완료되면 서버가 구동이 됩니다. 사이트에 접속하면 Hello World 문자가 출력됩니다. 이로써 Node.js 설치와 초기 설정 및 실행을 완료하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[CentOS] 기본 명령어","slug":"linux-1","date":"2020-09-14T02:21:19.000Z","updated":"2023-03-14T02:19:57.438Z","comments":true,"path":"2020/09/14/linux-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/linux-1/","excerpt":"","text":"기본 명령어 명령어 설명 ll 해당 디렉토리 파일 목록 보기 ls -al 숨김 파일까지 보기 ls -lt 시간순으로 보기 hostname 호스트명 보기 cat [파일명]예) cat /etc/hosts 파일 내용 출력 vi [파일명]예) vi /etc/hosts 파일 내용 편집 mkdir [폴더명] 폴더 생성 touch [파일명] 파일 생성 rm [파일명] 파일 삭제 rm -f [파일명] 묻지 않고 삭제 rm -rf [폴더명] 폴더 삭제 cp [복사대상] [붙여넣을파일명] 파일 복사 cp -r [복사대상] [붙여넣을폴더명] 폴더 복사 mv [파일] [변경할파일] 파일 또는 폴더 이동 pwd 현재 경로 보기 서비스 명령어 설명 systemctl enable [서비스명] 서비스 등록 systemctl start [서비스명] 서비스 시작 systemctl stop [서비스명] 서비스 중지 systemctl restart [서비스명] 서비스 재시작 systemctl status [서비스명] 서비스 상태확인 systemctl list-unit-files | grep [서비스명] 서비스 검색 계정 명령어 설명 su [계정명] 접속 계정 변경 su - 예) su - root 다시 로그인 whoami 접속 사용자 확인 주요 명령어 명령어 설명 ssh 계정@IP주소예) ssh root@192.168.20.25 SSH 접속 scp 파일명 계정@IP주소:폴더위치 예) scp mydb.sql root@192.168.20.24:/home/sql 파일 이동 실시간 명령어 명령어 설명 watch [-d] [-n seconds] ‘command’ 기본 사용 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"}],"tags":[{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"}]},{"title":"[PostgreSQL] Command 명령어","slug":"postgresql-3","date":"2020-09-14T01:40:09.000Z","updated":"2024-01-18T01:40:36.971Z","comments":true,"path":"2020/09/14/postgresql-3/","link":"","permalink":"http://hgko1207.github.io/2020/09/14/postgresql-3/","excerpt":"","text":"명령어 PostgreSQL에 접속합니다. 1$ psql -U postgres 다음은 데이터베이스와 테이블 관련 명령어입니다. 명령어 설명 \\list or \\l 데이터베이스 목록 조회 \\list+ or \\l+ 데이터베이스 목록 상세조회 \\c [DB Name] 다른 DB에 접속 \\d 테이블 목록 보기 \\dt [Table Name] 지정된 테이블 컬럼 목록 보기 \\dS 시스템 테이블 목록 보기 \\dv 뷰 목록 보기 \\ds 시퀀스 목록 보기 \\du 롤 목록 보기 \\dn 스키마 목록 보기 \\q psql 종료(Ctrl + d) 백업 및 복원 명령어 설명 pg_dump &gt; [백업파일명] 전체 백업 pg_dump [DB명] &gt; [백업파일명]예) pg_dump mydb &gt; db.sql 데이터베이스만 백업 psql -U postgres [DB명] &gt; [백업파일명] 데이터베이스만 백업 psql -f [백업파일명] [복원할 DB명]예) psql -f db.sql mydb DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다. psql [복원할 DB명] &lt; [백업파일명]예) psql mydb &lt; db.sql DB 만 복원단, DB가 없는 경우에는 생성을 먼저 해줘야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[PostgreSQL] 외부 접속 허용 설정","slug":"postgresql-2","date":"2020-09-11T01:20:47.000Z","updated":"2024-01-11T08:23:27.189Z","comments":true,"path":"2020/09/11/postgresql-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/11/postgresql-2/","excerpt":"","text":"외부 접속 허용 설정 1. 사용자 비밀번호 설정 외부에서 접속하기 위해선 우선 postgres 비밀번호를 설정해야 합니다. postgres 계정으로 접속합니다. 1$ su - postgres psql 12345# 비밀번호 설정\\password postgres# 종료\\q 2. 방화벽 개방 방화벽에서 5432 포트를 개방합니다. 12$ firewall-cmd --permanent --zone=public --add-port=5432/tcp$ firewall-cmd --reload 3. 설정 파일 변경 postgresql 접속 후 Data 디렉터리 확인을 할 수 있습니다. 12$ show data_directory;-&gt; /var/lib/pgsql/11/data postgresql.conf 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/postgresql.conf 설정 파일에서 다음과 같이 변경합니다. 12# listen_addresses = 'localhost' -&gt; 주석으로 되어있음listen_addresses = '*' 4. 보안 설정 변경 외부 접속을 위해 보안 설정을 변경합니다. root 계정으로 복귀합니다. 1$ su - root 설정 파일을 엽니다. 1$ vi /var/lib/pgsql/11/data/pg_hba.conf 설정 정보를 다음과 같이 변경합니다. 123local all all peer =&gt; local all all md5host all all 127.0.0.1/32 ident =&gt; host all all 0.0.0.0/0 md5host all all ::1/128 ident =&gt; host all all ::1/128 md5 md5 : 패스워드를 md5로 암호화해서 전송 5. 서비스 재시작 1$ sudo systemctl restart postgresql-11 참고 아래 링크에서는 pg_hba.conf를 수정하지 않고 접근제어를 할 수 있도록 하는 방법이 설명되어 있는데 테스트해보진 않았습니다. CentOS 7 에서 방화벽에 PostgreSQL 리스너 포트 등록하기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"외부접속허용","slug":"외부접속허용","permalink":"http://hgko1207.github.io/tags/%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D%ED%97%88%EC%9A%A9/"}]},{"title":"[PostgreSQL] CentOS 7에서 PostgreSQL 설치 및 시작 방법","slug":"postgresql-1","date":"2020-09-10T09:22:53.000Z","updated":"2024-01-11T08:20:15.500Z","comments":true,"path":"2020/09/10/postgresql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/10/postgresql-1/","excerpt":"","text":"리눅스 환경에서 PostgreSQL 설치 및 시작 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 PostgreSQL 11.9 인터넷이 되는 환경 12345# Install the repository RPM:$ sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm# PostgreSQL을 설치합니다.$ sudo yum install -y postgresql11-server postgresql11-contrib 인터넷이 안 되는 환경 1. RPM 다운로드 외부 환경에서 PostgreSQL Database Server 11 PGDG 페이지에 접속해서 RPM 파일들을 다운로드하고 리눅스 환경으로 이동시킨다. postgresql11-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-contrib-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-libs-11.9-1PGDG.rhel7.x86_64.rpm postgresql11-server-11.9-1PGDG.rhel7.x86_64.rpm 2. 설치 postgresql11-libs -&gt; postgresql11 -&gt; (postgresql11-server, postgresql11-contrib) 순으로 설치합니다. 1234sudo rpm -ivh postgresql11-libs-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-server-11.5-1PGDG.rhel7.x86_64.rpmsudo rpm -ivh postgresql11-contrib-11.5-1PGDG.rhel7.x86_64.rpm 설치된 패키지 확인 1$ rpm -qa | grep postgresql 기본 Database 생성 initdb 명령어를 통해 기본 데이터베이스를 설치합니다. 기본 데이터베이스는 postgres라는 이름으로 생성됩니다. 1$ sudo /usr/pgsql-11/bin/postgresql-11-setup initdb 서비스 등록 및 실행 12$ sudo systemctl enable postgresql-11$ sudo systemctl start postgresql-11 postgresql 접속 1$ sudo -u postgres psql 데이터베이스 생성 1postgres=# create database &lt;name&gt; encoding 'utf-8';","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"}]},{"title":"[WPF] Event Notifier 사용 방법","slug":"wpf-1","date":"2020-09-07T01:40:55.000Z","updated":"2024-01-11T08:19:34.038Z","comments":true,"path":"2020/09/07/wpf-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/07/wpf-1/","excerpt":"","text":"컴포넌트 간의 데이터를 주고받을 경우 Prism의 EventAggregator를 사용하면 편리하지만 WPF 만을 사용할 경우 아래 코드와 같이 구성하여 사용하였습니다. Event Manager EventManager.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace Tool.Event&#123; public class EventManager &#123; public delegate void EventHandler(); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish() &#123; event?.Invoke(); &#125; &#125; public class EventManager&lt;T&gt; &#123; public delegate void EventHandler(T item); event EventHandler event; public void Subscribe(EventHandler handler) &#123; event += handler; &#125; public void UnSubscribe(EventHandler handler) &#123; event -= handler; &#125; public void Publish(T item) &#123; event?.Invoke(item); &#125; &#125;&#125; Event Notifier EventNotifier.cs 1234567891011namespace Tool.Event&#123; public class EventNotifier &#123; public static EventManager&lt;string&gt; InputDataEvent = new EventManager&lt;string&gt;(); public static EventManager OpenEvent = new EventManager(); public static EventManager CloseEvent = new EventManager(); &#125;&#125; 사용 예 이벤트 등록 12345678910111213141516namespace Tool.Views&#123; public partial class TestWindow : Window &#123; public TestWindow() &#123; InitializeComponent(); &#125; private void CloseClick(object sender, RoutedEventArgs e) &#123; this.Close(); EventNotifier.CloseEvent.Publish(); &#125; &#125;&#125; 이벤트 받기 123456789101112131415namespace Tool.ViewModwl&#123; public class MainWindowViewModwl &#123; public MainWindow() &#123; EventNotifier.CloseEvent.Subscribe(CloseEvent); &#125; private void CloseEvent() &#123; Console.WriteLine(\"CloseEvent\"); &#125; &#125;&#125; 위의 코드는 다른 Window 에서 창을 종료 시 메인 Window 의 기능을 수행하기 위한 예제입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":"Event","slug":"Event","permalink":"http://hgko1207.github.io/tags/Event/"}]},{"title":"[Docker] 주요 명령어 및 기본 사용법","slug":"docker-1","date":"2020-09-06T12:57:13.000Z","updated":"2024-01-11T08:18:54.021Z","comments":true,"path":"2020/09/06/docker-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/06/docker-1/","excerpt":"","text":"리눅스 환경에서 Docker 명령어와 기본 사용 방법에 대해 알아보겠습니다. 운영환경 CentOS 7.6 설치 1$ yum install docker 설치가 완료되면 버전을 조회하여 설치 확인을 합니다. 1$ docker -v 컨테이너 생성 및 실행 docker run 명령어는 컨테이너를 생성 및 실행과 동시에 컨테이너 내부로 들어갑니다. 기본 포맷입니다. 1$ docker run (&lt;옵션&gt;) &lt;이미지 식별자&gt; (&lt;명령어&gt;) (&lt;인자&gt;) 예시입니다. 가독성을 위해 (역슬래시)를 이용해 각 설정 옵션을 구분합니다. 1234567$ docker run -d \\ --name hgko.default.local \\ --privileged \\ -h hgko --network insnet \\ -v /data:/data \\ -p 5914:5901 \\ hgko 간략한 예시입니다. 1$ docker run -d -i -t test /bin/bash Run 옵션 목록 -d : 컨테이너를 백그라운드로 실행해야 할 때 사용 -name : 컨테이너를 식별할 수 있도록 이름을 부여 -h : 컨테이너 호스트 이름 설정 -v : 볼륨 마운트 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 디렉토리 마운트) -p : 포트 연결 (컨테이너 외부 &lt;-&gt; 컨테이너 내부 포트간의 연결) --link : 내부 IP를 알 필요 없이 항상 컨테이너에 별명으로 접근하도록 설정 --privileged : 시스템 내 장치 등 주요 자원에 접근하며 커널의 기능을 대부분 사용할 수 있도록 설정 컨테이너 생성 docker create 명령어는 컨테이너를 생성만 할 뿐 컨테이너 내부로 들어가지 않습니다. 1$ docker create -i -t --name mycentos centos:7 컨테이너 실행 다음 명령어를 실행하여 컨테이너를 시작합니다. 1$ docker start mycentos 컨테이너 내부로 들어갑니다.(단, -i -t 옵션을 사용 했을 때) 1$ docker attach mycentos 컨테이너 내부 셸 사용 mycentos 컨테이너 내부에 bash 프로세스를 실행하고, -i -t 옵션을 사용해서 bash 셸을 쓸 수 있게 유지합니다. 12$ docker exec -i -t mycentos \\bin\\bash$ docker exec -i -t mycentos bash 컨테이너 내부에서 빠져나오기 컨테이너 내부에서 빠져나오는 방법은 두 가지가 있습니다. 첫 번째는 컨테이너 셸에서 exit를 입력하거나 Ctrl + D를 동시에 입력하는 것 입니다. 이 방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지시킵니다. 두 번째는 Ctrl + P, Q를 입력하는 것 입니다. 이 방법은 컨테이너를 정지하지 않고 빠져나옵니다. 컨테이너 확인 정지되지 않은 컨테이너만 출력합니다. 1$ docker ps 정지된 컨테이너를 포함한 모든 컨테이너를 출력합니다. 1$ docker ps -a 출력 결과가 줄바꿈되어 알아보기 힘들 때 --format 옵션을 사용합니다/ 1$ docker ps --format \"table &#123;&#123;.ID&#125;&#125;\\&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\" 특정 컨테이너를 출력합니다. 1$ docker ps | grep mycentos 컨테이너 이름 변경 1$ docker rename mycentos my_centos 컨테이너 삭제 정지된 컨테이너만 삭제 가능합니다. 1$ docker rm mycentos 실행 중인 컨테이너도 삭제 가능합니다. (-f : 강제 삭제) 1$ docker rm -f mycentos 모든 컨테이너 삭제 가능합니다. 1$ docker container prune 이미지 목록 1$ docker images 이미지 삭제 1$ docker rmi &lt;이미지 식별자&gt; 이미지 빌드 1$ docker build -t hgko ./image/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"}]},{"title":"[딥러닝] Preprocess 준비","slug":"ai-preprocess-1","date":"2020-09-01T14:10:35.000Z","updated":"2023-07-18T04:14:09.880Z","comments":true,"path":"2020/09/01/ai-preprocess-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/ai-preprocess-1/","excerpt":"","text":"로컬 데이터를 불러와 전처리시 필요한 내용이다. Load Packages 12345678910import osfrom glob import globimport numpy as npimport tensorflow as tffrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 12345678910# 현재 경로를 알려준다.os.getcwd()# 경로를 넣으면 경로의 파일명만 목록 형식으로 보여준다.os.listdir()os.listdir('dataset/mnist_png/training/')# 경로가 포함된 모든 파일들을 목록 형식으로 보여준다.# 원하는 포맷의 파일만을 가져올 수 있습니다.(png, txt 등)glob('dataset/mnist_png/training/*.png') 데이터 분석 123456label_nums = os.listdir('dataset/mnist_png/training/')&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']# Label 데이터 갯수 확인len(label_nums)&gt; 10 데이터 별 갯수 비교 1234567nums_dataset = []for lbl_n in label_nums: data_per_class = os.listdir('../dataset/mnist_png/training/' + lbl_n) nums_dataset.append(len(data_per_class))&gt; [5923, 6742, 5958, 6131, 5842, 5421, 5918, 6265, 5851, 5949] TensorFlow로 열기 12gfile = tf.io.read_file(path)image = tf.io.decode_image(gfile) 데이터 이미지 사이즈 알기 123456789101112from tqdm import tqdm_notebookheights = []widths = []for path in tqdm_notebook(data_paths): image_pil = Image.open(path) image = np.array(image_pil) h, w = image.shape heights.append(h) widths.append(w)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[C++] DLL 동적 로딩","slug":"cpp-coding-2","date":"2020-09-01T09:46:17.000Z","updated":"2023-07-18T04:14:41.812Z","comments":true,"path":"2020/09/01/cpp-coding-2/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/cpp-coding-2/","excerpt":"","text":"DLL 동적 로딩 특정 폴더 내에 다수의 DLL 라이브러리 파일들을 로딩하기 위한 코드다. Header 파일 1234567891011121314151617181920// dllload.h#include &lt;iostream&gt;class DLLLoad&#123;public: DLLLoad() &#123;&#125; ~DLLLoad() &#123;&#125; bool LoadLibrary(); bool FreeLibrary();private: // DLL 폴더 경로를 설정한다. const std::string DLL_DIR; // 로딩된 DLL 파일 경로들을 저장하고 관리한다. std::list&lt;std::string&gt; fileList;&#125; C++ 파일 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// dllload.cpp#include \"dllload.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;const std::string DLLLoad::DLL_DIR = \"C:\\\\dll\\\\\";DLLLoad::DLLLoad() &#123;&#125;DLLLoad::~DLLLoad() &#123;&#125;// DLL 라이브러리들을 동적 로딩한다.bool DLLLoad::LoadLibrary()&#123; // 처음 DLL 로드 이후에는 다시 로드하지 않는다. if (fileList.size() == 0) &#123; std::string input = DLL_DIR + \"*.dll\"; WIN32_FIND_DATA FindData; HANDLE hFind = FindFirstFile(input.c_str(), &amp;FindData); if (hFind == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; \"Error - Can't find a file : \" &lt;&lt; FindData.cFileName &lt;&lt; std::endl; return false; &#125; do &#123; if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_ARCHIVE) // 파일만 검색 &#123; std::string dir = CSM_DLL_DIR + FindData.cFileName; HINSTANCE hmodule = LoadLibrary(dir.c_str()); if (hmodule != NULL) &#123; fileList.push_back(dir); &#125; &#125; &#125; while (FindNextFile(hFind, &amp;FindData) != 0); FindClose(hFind); &#125; return true;&#125;// 로딩된 DLL 라이브러리들을 해제한다.bool DLLLoad::FreeLibrary()&#123; for (std::string file : fileList) &#123; HINSTANCE hmodule = GetModuleHandle(file.c_str()); if (hmodule != NULL) &#123; FreeLibrary(hmodule); &#125; &#125; return true;&#125; Main 함수 123456int main()&#123; DLLLoad dllLoad = new DLLLoad(); dllLoad-&gt;LoadLibrary(); dllLoad-&gt;FreeLibrary();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[MSSQL] Geometry Query","slug":"mssql-1","date":"2020-09-01T08:38:30.000Z","updated":"2023-03-14T02:19:43.856Z","comments":true,"path":"2020/09/01/mssql-1/","link":"","permalink":"http://hgko1207.github.io/2020/09/01/mssql-1/","excerpt":"","text":"Geometry 데이터 형식 쿼리 STContains STContains(geometry 데이터 형식) geometry 인스턴스에 다른 geometry 인스턴스가 완전히 포함되어 있으면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STContains(@h); POINT 좌표가 POLYGON 좌표에 완전히 포함되어 있지 않기 때문에 결과는 0을 반환합니다. STIntersects STIntersects(geometry 데이터 형식) geometry 인스턴스가 다른 geometry 인스턴스와 교차하면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. 123456DECLARE @g geometry;DECLARE @h geometry;SET @g = geometry::STGeomFromText('POLYGON((-122.358 47.653, -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326);SET @h = geometry::STGeomFromText('POINT(-122.358 47.656)', 4326);SELECT @g.STIntersects(@h); POINT 좌표가 POLYGON 좌표와 교차하기 때문에 결과는 1을 반환합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"}]},{"title":"[딥러닝] 교육자료","slug":"ai-deep-1","date":"2020-08-21T08:24:38.000Z","updated":"2023-07-18T04:13:41.727Z","comments":true,"path":"2020/08/21/ai-deep-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/ai-deep-1/","excerpt":"","text":"딥러닝 교육자료 딥러닝을 배우기 위한 강의 사이트와 책을 정리하였다. 교육 사이트 프로그래머스 - https://programmers.co.kr/ 에드윗 - https://www.edwith.org/ 입문 강의 파이썬 입문 - https://programmers.co.kr/learn/courses/2 딥러닝 입문(Tensorflow) - https://www.edwith.org/others26 입문 블로그 딥러닝 입문(Keras) - https://tykimos.github.io/lecture/ 딥러닝 책 밑바닥부터 시작하는 딥러닝(기초) DeepLearningBook(심화) 머신러닝 책 핸즈온 머신러닝(심화) PRML(심화)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"}]},{"title":"[Web Design] Canvas","slug":"web-design-1","date":"2020-08-21T07:59:04.000Z","updated":"2023-07-18T04:13:52.343Z","comments":true,"path":"2020/08/21/web-design-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/21/web-design-1/","excerpt":"","text":"HTML 템플릿 회사 홈페이지 및 블로그 형태의 사이트 제작 요청이 있어 디자인 템플릿을 찾아보던 중 심플하기도 하고 이쁜 HTML 템플릿을 찾게 되었다. Canvas The Multi-Purpose HTML5 Template Canvas는 Mulit-Page 및 One-Page 사이트를 제공하고 반응형을 지원하는 다목적 HTML5 템플릿이다. 비즈니스, 의료, SEO, 여행, 건설, 부동산, 요가, 뷰티, 기사, 사진, 뉴스, 대여, 이력서, 블로그, 웨딩, 음악, 앱 쇼케이스, 애완 동물, 스토어 등 120개 이상의 즉시 사용 가능한 홈페이지 템플릿을 제공합니다. 유료 이지만 가격도 저렴해서 가성비가 좋다. 빠르게 개발을 해야 하거나 디자인 비용을 절감해야 할 때 사용하면 좋은 사이트를 제작할 수 있을 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"}]},{"title":"TensorFlow 2.0과 PyTorch 비교","slug":"ai-dev-8","date":"2020-08-13T07:36:58.000Z","updated":"2023-03-14T02:19:19.731Z","comments":true,"path":"2020/08/13/ai-dev-8/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-dev-8/","excerpt":"","text":"TensorFlow 2.0 123import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Hyperparameter 1234567batch_size = 64learning_rate = 0.001dropout_rate = 0.7input_shape = (28, 28, 1)num_classes = 10 Preprocess 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Build Model 1234567891011121314151617181920212223inputs = layers.Input(input_shape)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(dropout_rate)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(dropout_rate)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), # Optimization loss='sparse_categorical_crossentropy', # Loss Function metrics=['accuracy']) # Metrics / Accuracy Training 1234567model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# OutTrain on 60000 samples60000/60000 [==============================] - 6s 103us/sample - loss: 0.3794 - accuracy: 0.8767 12model.evaluate(test_x, test_y, batch_size=batch_size)=&gt; [0.06760077927671373, 0.9776] PyTorch 12345678import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optim# 이미지 데이터를 관리하기 위한 라이브러리from torchvision import datasets, transforms Hyperparameter 12345678910111213# 랜덤 값을 고정시키기 위해seed = 1lr = 0.001momentum = 0.5batch_size = 64test_batch_size = 64epochs = 5no_cuda = Falselog_interval = 100 Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Preprocess 12345678910111213141516171819202122torch.manual_seed(seed)use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")kwargs = &#123;'num_workers': 1, 'pin_memory': True&#125; if use_cuda else &#123;&#125;train_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True, **kwargs)test_loader = torch.utils.data.DataLoader( datasets.MNIST('../data', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True, **kwargs) Optimization 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=lr, momentum=momentum) Training 12345678910111213141516171819202122232425262728293031323334for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() # backpropagation 계산하기 전에 0으로 기울기 계산 output = model(data) loss = F.nll_loss(output, target) # https://pytorch.org/docs/stable/nn.html#nll-loss loss.backward() # 계산한 기울기를 optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) # Test mode model.eval() # batch norm이나 dropout 등을 train mode 변환 test_loss = 0 correct = 0 with torch.no_grad(): # autograd engine, 즉 backpropagatin이나 gradient 계산 등을 꺼서 memory usage를 줄이고 속도를 높임 for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() # sum up batch loss pred = output.argmax(dim=1, keepdim=True) # get the index of the max log-probability correct += pred.eq(target.view_as(pred)).sum().item() # pred와 target과 같은지 확인 test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) 결과 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Train Epoch: 1 [0/60000 (0%)] Loss: 2.300039Train Epoch: 1 [6400/60000 (11%)] Loss: 2.239658Train Epoch: 1 [12800/60000 (21%)] Loss: 2.133953Train Epoch: 1 [19200/60000 (32%)] Loss: 2.007281Train Epoch: 1 [25600/60000 (43%)] Loss: 1.656340Train Epoch: 1 [32000/60000 (53%)] Loss: 1.400340Train Epoch: 1 [38400/60000 (64%)] Loss: 0.864186Train Epoch: 1 [44800/60000 (75%)] Loss: 0.613089Train Epoch: 1 [51200/60000 (85%)] Loss: 0.615066Train Epoch: 1 [57600/60000 (96%)] Loss: 0.427881Test set: Average loss: 0.4822, Accuracy: 8651/10000 (87%)Train Epoch: 2 [0/60000 (0%)] Loss: 0.635855Train Epoch: 2 [6400/60000 (11%)] Loss: 0.361398Train Epoch: 2 [12800/60000 (21%)] Loss: 0.457372Train Epoch: 2 [19200/60000 (32%)] Loss: 0.393982Train Epoch: 2 [25600/60000 (43%)] Loss: 0.536390Train Epoch: 2 [32000/60000 (53%)] Loss: 0.258121Train Epoch: 2 [38400/60000 (64%)] Loss: 0.413061Train Epoch: 2 [44800/60000 (75%)] Loss: 0.174248Train Epoch: 2 [51200/60000 (85%)] Loss: 0.222638Train Epoch: 2 [57600/60000 (96%)] Loss: 0.401988Test set: Average loss: 0.2956, Accuracy: 9128/10000 (91%)Train Epoch: 3 [0/60000 (0%)] Loss: 0.425370Train Epoch: 3 [6400/60000 (11%)] Loss: 0.242881Train Epoch: 3 [12800/60000 (21%)] Loss: 0.266271Train Epoch: 3 [19200/60000 (32%)] Loss: 0.344442Train Epoch: 3 [25600/60000 (43%)] Loss: 0.271553Train Epoch: 3 [32000/60000 (53%)] Loss: 0.233463Train Epoch: 3 [38400/60000 (64%)] Loss: 0.206387Train Epoch: 3 [44800/60000 (75%)] Loss: 0.289864Train Epoch: 3 [51200/60000 (85%)] Loss: 0.227708Train Epoch: 3 [57600/60000 (96%)] Loss: 0.266247Test set: Average loss: 0.2279, Accuracy: 9320/10000 (93%)Train Epoch: 4 [0/60000 (0%)] Loss: 0.197864Train Epoch: 4 [6400/60000 (11%)] Loss: 0.334545Train Epoch: 4 [12800/60000 (21%)] Loss: 0.171417Train Epoch: 4 [19200/60000 (32%)] Loss: 0.261458Train Epoch: 4 [25600/60000 (43%)] Loss: 0.129152Train Epoch: 4 [32000/60000 (53%)] Loss: 0.129057Train Epoch: 4 [38400/60000 (64%)] Loss: 0.203361Train Epoch: 4 [44800/60000 (75%)] Loss: 0.304724Train Epoch: 4 [51200/60000 (85%)] Loss: 0.136878Train Epoch: 4 [57600/60000 (96%)] Loss: 0.171525Test set: Average loss: 0.1808, Accuracy: 9482/10000 (95%)Train Epoch: 5 [0/60000 (0%)] Loss: 0.199721Train Epoch: 5 [6400/60000 (11%)] Loss: 0.246554Train Epoch: 5 [12800/60000 (21%)] Loss: 0.217517Train Epoch: 5 [19200/60000 (32%)] Loss: 0.255912Train Epoch: 5 [25600/60000 (43%)] Loss: 0.182075Train Epoch: 5 [32000/60000 (53%)] Loss: 0.296272Train Epoch: 5 [38400/60000 (64%)] Loss: 0.283726Train Epoch: 5 [44800/60000 (75%)] Loss: 0.239351Train Epoch: 5 [51200/60000 (85%)] Loss: 0.293096Train Epoch: 5 [57600/60000 (96%)] Loss: 0.157650Test set: Average loss: 0.1533, Accuracy: 9581/10000 (96%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Evaluating 및 Predicting","slug":"ai-pytorch-5","date":"2020-08-13T07:11:54.000Z","updated":"2023-07-18T04:13:35.982Z","comments":true,"path":"2020/08/13/ai-pytorch-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-5/","excerpt":"","text":"이전 블로그를 이어서 진행해본다. Evaluation model.train() 모드로 변한 것 처럼 평가할 때는 model.eval() 으로 설정한다. 1234567891011# Test mode# batch norm이나 dropout 등을 train mode 변환model.eval()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) torch.no_grad() 함수는 autograd engine, 즉 backpropagatin 이나 기울기 계산 등을 꺼서 memory usage 를 줄이고 속도를 높인다. 12345678910111213141516171819test_loss = 0correct = 0with torch.no_grad(): data, target = next(iter(test_loader)) data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct = pred.eq(target.view_as(pred)).sum().item()# Outtest_loss : 29.74889373779297correct : 54test_loss /= len(test_loader.dataset)=&gt; 0.0029748893737792967 정리 1234567891011121314151617181920model.eval()test_loss = 0correct = 0with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item()test0_loss /= len(test_loader.dataset)print('\\nTest set: Average Loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset)))# OutTest set: Average Loss: 0.4799, Accuracy: 8660/10000 (87%)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] Optimizer 및 Training","slug":"ai-pytorch-4","date":"2020-08-13T04:48:37.000Z","updated":"2023-07-18T04:13:15.068Z","comments":true,"path":"2020/08/13/ai-pytorch-4/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-4/","excerpt":"","text":"Optimization &amp; Training https://github.com/pytorch/examples/tree/master/mnist Load Packages 1234567import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsimport numpy as np 1234567no_cuda = False# cuda를 사용할지 안할지use_cuda = not no_cuda and torch.cuda.is_available()device = torch.device(\"cuda\" if use_cuda else \"cpu\")=&gt; device(type='cuda') Preprocess 12345678910111213141516171819202122seed = 1batch_size = 64test_batch_size = 64torch.manual_seed(seed)train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=test_batch_size, shuffle=True) Model 1234567891011121314151617class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) Optimization Model과 Optimization를 설정한다. SGD 사용 확률적 경사 하강법(Stochastic Gradient Descent, SGD) 옵티마이저 Lr(learning Rate) : 0 보다 크거나 같은 float 값. 학습률 momentum: 0 보다 크거나 같은 float 값. SGD를 적절한 방향으로 가속화하며, 흔들림(진동)을 줄여주는 매개변수 12model = Net().to(device)optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.5) parameters를 확인합니다. 12345678910111213params = list(model.parameters())for i in range(8): print(params[i].size())# Weight, Bais를 순서대로 보여준다.torch.Size([20, 1, 5, 5])torch.Size([20])torch.Size([50, 20, 5, 5])torch.Size([50])torch.Size([500, 800])torch.Size([500])torch.Size([10, 500])torch.Size([10]) Before Training 학습하기 전에 Model이 Train할 수 있도록 Train Mode로 변환한다. Convolution 또는 Linear 뿐만 아니라, DropOut과 Batch Normalization과 같이 parameter를 가진 Layer들도 학습하기 위해 준비한다. 12345678910# train modemodel.train()# OutNet( (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(20, 50, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=800, out_features=500, bias=True) (fc2): Linear(in_features=500, out_features=10, bias=True)) 모델에 넣기 위한 첫 Batch 데이터를 추출하고 cpu 또는 gpu device에 컴파일한다. 12345data, target = next(iter(train_loader))data, target = data.to(device), target.to(device)data.shape, target.shape=&gt; (torch.Size([64, 1, 28, 28]), torch.Size([64])) 기울기(gradients)를 clear해서 새로운 최적화 값을 찾기 위해 준비한다. 그리고 준비한 데이터를 model에 넣어 output을 얻습니다. Model에서 예측한 결과를 Loss Function에 넣는다. 12345optimizer.zero_grad()output = model(data)# Negative Log-Likelihood Loss 사용loss = F.nll_loss(output, target) Back Propagation을 통해 기울기를 계산한다. 계산된 기울기는 Parameter에 업데이트를 한다. 1234# 기울기 계산loss.backward()# Updateoptimizer.step() Start Training 위의 최적화 과정을 반복하여 학습을 시작한다. 12345678910111213141516171819202122232425262728293031epochs = 1log_interval = 100for epoch in range(1, epochs + 1): # Train Mode model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % log_interval == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100 * batch_idx / len(train_loader), loss.item() ))# OutTrain Epoch: 1 [0/60000 (0%)] Loss: 2.290735Train Epoch: 1 [6400/60000 (11%)] Loss: 2.228956Train Epoch: 1 [12800/60000 (21%)] Loss: 2.121080Train Epoch: 1 [19200/60000 (32%)] Loss: 1.893549Train Epoch: 1 [25600/60000 (43%)] Loss: 1.570034Train Epoch: 1 [32000/60000 (53%)] Loss: 1.213198Train Epoch: 1 [38400/60000 (64%)] Loss: 0.993993Train Epoch: 1 [44800/60000 (75%)] Loss: 0.778737Train Epoch: 1 [51200/60000 (85%)] Loss: 0.732925Train Epoch: 1 [57600/60000 (96%)] Loss: 0.624502","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 각 Layer별 역할 및 파라미터","slug":"ai-pytorch-3","date":"2020-08-13T02:31:56.000Z","updated":"2023-07-18T04:12:30.053Z","comments":true,"path":"2020/08/13/ai-pytorch-3/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-3/","excerpt":"","text":"PyTorch Layer 이해하기 Load Packages 123456import torchfrom torchvision import datasets, transformsimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline 예제 불러오기 1234567891011train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor() ])), batch_size=1)image, label = next(iter(train_loader))image.shape, label.shape=&gt; (torch.Size([1, 1, 28, 28]), torch.Size([1])) 12plt.imshow(image[0, 0, :, :], 'gray')plt.show() 각 Layer별 설명 Network 쌓기 위한 준비를 합니다. 123import torchimport torch.nn as nnimport torch.nn.functional as F Convolution in_channels : 받게 될 channel의 갯수 out_channels : 보내고 싶은 channel의 갯수 kernel_size : 만들고 싶은 kernel(weights)의 사이즈 1234# Device type : cpu, cuda, mkldnn, opengl, opencl, ideep, hip, msnpulayer = nn.Conv2d(in_channels=1, out_channels=20, kernel_size=5, stride=1).to(torch.device('cpu'))=&gt; Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) weight 시각화를 위해 slice하고 numpy화 합니다. 1234weight = layer.weightweight.shape=&gt; torch.Size([20, 1, 5, 5]) 여기서 weight는 학습 가능한 상태이기 때문에 바로 numpy로 뽑아낼 수 없다. detach() method는 그래프에서 잠깐 꺼내서 gradient에 영향을 받지 않게 한다. 1234weight = weight.detach().numpy()weight.shape=&gt; (20, 1, 5, 5) 123plt.imshow(weight[0, 0, :, :], 'jet')plt.colorbar()plt.show() output 시각화 준비를 위해 numpy화 합니다. 123456output_data = layer(image)output_data = output_data.dataoutput = output_data.cpu().numpy()output.shape=&gt; (1, 20, 24, 24) input으로 들어간 이미지 numpy화 한다. 1234image_arr = image.numpy()image_arr.shape=&gt; (1, 1, 28, 28) 1234567891011plt.figure(figsize=(15, 30))plt.subplot(131)plt.title('Input')plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(132)plt.title('Weight')plt.imshow(weight[0, 0, :, :], 'jet')plt.subplot(133)plt.title('Output')plt.imshow(output[0, 0, :, :], 'gray')plt.show() Pooling input을 먼저 앞에 넣고, 뒤어 kernel 사이즈와 stride를 순서대로 넣는다. 1234pool = F.max_pool2d(image, 2, 2)pool.shape=&gt; torch.Size([1, 1, 14, 14]) MaxPool Layer는 weight가 없기 때문에 바로 numpy() 사용 가능하다. 1234pool_arr = pool.numpy()pool_arr.shape, image_arr.shape=&gt; ((1, 1, 14, 14), (1, 1, 28, 28)) 12345678plt.figure(figsize=(10, 15))plt.subplot(121)plt.title(\"Input\")plt.imshow(np.squeeze(image_arr), 'gray')plt.subplot(122)plt.title('Output')plt.imshow(np.squeeze(pool_arr), 'gray')plt.show() Linear nn.Linear는 2D가 아닌 1D만 들어가기 때문에 view() 함수를 사용하여 1D로 펼쳐줘야 한다. 12345# image size가 28 이기 때문에 28 * 28을 넣는다.flatten = image.view(1, 28 * 28)flatten.shape=&gt; torch.Size([1, 784]) 123456789lin = nn.Linear(784, 10)(flatten)lin.shape=&gt; torch.Size([1, 10])lin=&gt; tensor([[-0.1198, 0.2404, -0.0522, -0.3474, -0.3997, -0.0318, -0.0630, 0.2680, 0.1849, 0.1000]], grad_fn=&lt;AddmmBackward&gt;) 12plt.imshow(lin.detach().numpy(), 'jet')plt.show() Softmax 결과를 numpy로 꺼재기 위해선 weight가 담긴 Linear에 weight를 꺼줘야 한다. 123456789with torch.no_grad(): flatten = image.view(1, 28 * 28) lin = nn.Linear(784, 10)(flatten) softmax = F.softmax(lin, dim=1)softmax=&gt; tensor([[0.0846, 0.1084, 0.0792, 0.1265, 0.1004, 0.0897, 0.0990, 0.1113, 0.1239, 0.0769]]) 12np.sum(softmax.numpy())=&gt; 0.99999994 Layer 쌓기 예제 출처 : https://pytorch.org/tutorials/beginner/pytorch_with_examples.html#id23 nn 과 nn.functional의 차이점 nn은 학습 파라미터가 담긴 것 nn.functional은 학습 파라미터가 없는 것 123456789101112131415161718192021class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): # Feature Extraction x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) # Fully Connected (Classficiation) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) image를 Model에 넣어서 결과를 확인한다. 12345model = Net()result = model.forward(image)=&gt; tensor([[-2.3262, -2.2901, -2.2722, -2.2262, -2.3148, -2.3693, -2.2773, -2.2977, -2.3222, -2.3371]], grad_fn=&lt;LogSoftmaxBackward&gt;)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[PyTorch] 데이터 불러오기","slug":"ai-pytorch-2","date":"2020-08-13T01:14:45.000Z","updated":"2023-07-18T04:11:52.897Z","comments":true,"path":"2020/08/13/ai-pytorch-2/","link":"","permalink":"http://hgko1207.github.io/2020/08/13/ai-pytorch-2/","excerpt":"","text":"PyTorch Data Preprocess 12import torchfrom torchvision import datasets, transforms Import Error 1ImportError: cannot import name 'PILLOW_VERSION' from 'PIL' pillow 버전이 7.0.0 이상 일경우 Import 에러 나는 경우가 있다. 아래 처럼 pillow 버전을 내려주면 해결이 된다. 1$ pip install pillow==6.2.2 Data Loader 부르기 Pytorch는 DataLoader를 불러 model에 넣는다. 12345678910batch_size = 32train_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset/', train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize(mean=(0.5,), std=(0.5,)) ])), batch_size=batch_size, shuffle=True) 12345678910test_batch_size = 32test_loader = torch.utils.data.DataLoader( datasets.MNIST('dataset', train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5)) ])), batch_size=test_batch_size, shuffle=True) 첫번째 iteration에서 나오는 데이터 확인 1234images, labels = next(iter(train_loader))image.shape, label.shape=&gt; torch.Size([32, 1, 28, 28]), torch.Size([32]) 데이터 시각화 123import numpy as npimport matplotlib.pyplot as plt%matplotlib inline 12345# squeeze() 함수는 차원의 원소가 1인 차원을 없애준다.torch_image = torch.squeeze(images[0])torch_image.shape=&gt; torch.Size([28, 28]) 1234image = torch_image.numpy()image.shape=&gt; (28, 28) 123plt.title(label)plt.imshow(image, 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[JavaScript] DataTables 사용 방법","slug":"js-dev-1","date":"2020-08-12T04:24:43.000Z","updated":"2024-01-11T08:16:36.394Z","comments":true,"path":"2020/08/12/js-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/12/js-dev-1/","excerpt":"","text":"JQuery 용 테이블 라이브러리인 DataTables 플러그인을 사용하여 개발했을 경우 편리하게 사용하기 위해 구조를 설계하였습니다. DataTables는 데이터를 테이블로 쉽게 구현할 수 있도록 도와주는 라이브러리입니다. 설치와 사용법은 DataTables 공식 사이트에 잘 설명되어 있기 때문에 생략하겠습니다. 초기 설정 여러 곳에서 DataTables로 작업할 때 유용하도록 초기 기본값으로 설정하였습니다. 12345678910111213141516171819202122232425// table.js$.extend($.fn.dataTable.defaults, &#123; autoWidth: false, dom: `&lt;'row'&lt;'col-sm-12'tr&gt;&gt;&lt;'row'&lt;'col-sm-12 col-md-5'i&gt;` + `&lt;'col-sm-12 col-md-7 dataTables_pager'lp&gt;&gt;`, language: &#123; emptyTable: '데이터가 없습니다.', infoEmpty: '', info: ' _TOTAL_ 개의 데이터가 있습니다.', search: '&lt;span&gt;검색 :&lt;/span&gt; _INPUT_', searchPlaceholder: '내용 입력...', lengthMenu: 'Display _MENU_', paginate: &#123; first: 'First', last: 'Last', next: $('html').attr('dir') == 'rtl' ? '&amp;larr;' : '&amp;rarr;', previous: $('html').attr('dir') == 'rtl' ? '&amp;rarr;' : '&amp;larr;', &#125;, &#125;, // 검색 기능 숨기기 searching: false, // 표시 건수기능 숨기기 lengthChange: false, // 한 페이지에 표시되는 Row 수 pageLength: 10,&#125;); 기본 구조 기본 구조를 설계하여 다른 파일에서 공통으로 사용할 수 있도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// table.jsconst Datatables = &#123; // 기본 테이블 구조 basic: function (id, tableOption, info) &#123; let table = $(id).DataTable(&#123; // 반응형 테이블 설정 responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, order: [[0, 'asc']], &#125;); return table; &#125;, // 정렬하는 컬럼을 설정하도록 order: function (id, tableOption, num, info) &#123; let table = $(id).DataTable(&#123; responsive: true, language: &#123; info: info ? info : ' _TOTAL_ 개의 데이터가 있습니다.', &#125;, columns: tableOption ? tableOption.columns : null, columnDefs: [ &#123; orderable: true, className: 'reorder', targets: 0 &#125;, &#123; orderable: true, className: 'reorder', targets: num &#125;, &#123; orderable: false, targets: '_all' &#125;, ], order: [[num, 'desc']], &#125;); return table; &#125;, // 데이터 추가 rowsAdd: function (table, url, param) &#123; table.clear(); $.ajax(&#123; url: url, type: 'POST', data: JSON.stringify(param), contentType: 'application/json', success: function (data) &#123; table.rows.add(data).draw(); // 반응형 테이블 사용 table.responsive.recalc(); &#125;, &#125;); &#125;, // 새로고침 refresh: function (table, data) &#123; table.clear(); table.rows.add(data).draw(); &#125;,&#125;; 사용 예제 예를 들어 공지사항 테이블을 만들어 보겠습니다. 1234567891011121314151617&lt;!-- notice.html --&gt;&lt;table class=\"table\" id=\"noticeTable\"&gt; &lt;thead class=\"text-center\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;작성시간&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=\"text-center\"&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;!-- thymeleaf 사용 --&gt;&lt;script th:src=\"@&#123;/js/table.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/notice.js&#125;\"&gt;&lt;/script&gt; table 태그의 id를 설정하고 위에서 설정한 Datatables.order 함수를 통해 DataTables을 생성하였습니다. 123456789101112131415161718192021222324252627282930313233// notice.jsconst dataTable = &#123; ele: '#noticeTable', table: null, option: &#123; columns: [ &#123; data: null, render: function (data, type, row, meta) &#123; return meta.row + 1; &#125;, &#125;, &#123; data: 'title' &#125;, &#123; data: 'userId' &#125;, &#123; data: 'createDate' &#125;, &#123; data: 'hit' &#125;, ], &#125;, init: function () &#123; // DataTables 생성 this.table = Datatables.order(this.ele, this.option, 3); this.search(); &#125;, search: function () &#123; const param = new Object(); // 조회 조건에 따라 데이터를 조회해서 DataTables에 넣는다. Datatables.rowsAdd(this.table, contextPath + '/notice/search', param); &#125;,&#125;;$(document).ready(function () &#123; dataTable.init();&#125;); 결과 DataTables 라이브러리를 사용하여 구현해 봤습니다. 여러 프로젝트에서 공통으로 사용하기 위해 정리를 하였는데 개선사항이 있으면 추가할 예정입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"}]},{"title":"[MySQL] Packet for query is too large 에러 발생시","slug":"mysql-1","date":"2020-08-10T06:14:27.000Z","updated":"2024-01-11T08:15:37.599Z","comments":true,"path":"2020/08/10/mysql-1/","link":"","permalink":"http://hgko1207.github.io/2020/08/10/mysql-1/","excerpt":"","text":"MySQL을 사용하여 개발 중 4MB가 넘는 파일을 업로드 시 다음과 같은 패킷 에러가 발생하였다. 1com.mysql.jdbc.PacketTooBigException: Packet for query is too large (9,523,277 &gt; 4,194,304). You can change this value on the server by setting the 'max_allowed_packet' variable 기본적으로 할당된 패킷 사이즈 값이 너무 작기 때문에 에러가 발생했기 때문에 수정이 필요하다. MySQL 설정에서 max_allowed_packet 값을 변경하여 해결하였다. max_allowed_packet은 서버로 질의하거나 받게 되는 패킷의 최대 길이를 나타내는 시스템 변수 다음은 해결방법에 대해 알아보겠다. 1) MySQL 커맨드 라인에서 변경 먼저 MySQL 에 접속한다. 1$ mysql -u root -p **** 12345678910111213141516mysql&gt; show variables;## 1024 * 1024 * 32 -&gt; 32MBmysql&gt; SET GLOBAL max_allowed_packet = 33554432;Query OK, 0 rows affected (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables where Variable_name = 'max_allowed_packet';+--------------------+----------+| Variable_name | Value |+--------------------+----------+| max_allowed_packet | 33554432 |+--------------------+----------+1 row in set (0.01 sec) 2) 설정파일 변경 /etc/my.cnf 설정파일 내의 값을 변경한다. 1$ vi /etc/my.cnf 12# 없을 시 추가한다.max_allowed_packet=32M 3) MySQL 재시작 다음 명령어를 사용여 MySQL를 재시작한다. 12345678# 우분투$ service mysql restart# CentOS6$ service mysqld restart# CentOS7$ systemctl restart mysqld","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"[JAVA] 동네예보 조회서비스 API 사용 방법","slug":"java-dev-5","date":"2020-08-06T06:13:50.000Z","updated":"2024-01-11T08:15:09.635Z","comments":true,"path":"2020/08/06/java-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/08/06/java-dev-5/","excerpt":"","text":"동네예보 조회서비스 동네예보 정보를 조회하기 위해 공공데이터 포털 사이트의 동네예보 조회서비스 API 사용 방법에 대해 알아보겠습니다. Open API 활용 방법 동네예보 조회서비스 사이트에서 활용신청을 하고 Service Key를 발급받는다. 오픈 API 활용 가이드를 다운로드하여 조회 조건 및 결과 데이터를 이해한다. 동네예보 데이터 조회 1http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst?ServiceKey=&#123;발급받은 Service Key&#125;&amp;pageNo=1&amp;numOfRows=10&amp;dataType=JSON&amp;base_date=&#123;현재날짜&#125;&amp;base_time=&#123;현재시간&#125;&amp;nx=&#123;지점 X 좌표값&#125;&amp;ny=&#123;지점 Y 좌표값&#125; 결과 데이터(JSON 형식) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#123; \"response\": &#123; \"header\": &#123; \"resultCode\": \"00\", \"resultMsg\": \"NORMAL_SERVICE\" &#125;, \"body\": &#123; \"dataType\": \"JSON\", \"items\": &#123; \"item\": [ &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"POP\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"80\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"PTY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"R06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"9\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"REH\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"85\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"S06\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"SKY\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"4\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"T3H\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"24\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"UUU\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"-1.1\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VEC\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"127\", \"nx\": 76, \"ny\": 122 &#125;, &#123; \"baseDate\": \"20200807\", \"baseTime\": \"0800\", \"category\": \"VVV\", \"fcstDate\": \"20200807\", \"fcstTime\": \"1200\", \"fcstValue\": \"0.9\", \"nx\": 76, \"ny\": 122 &#125; ] &#125;, \"pageNo\": 1, \"numOfRows\": 10, \"totalCount\": 216 &#125; &#125;&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 조회 서비스 마다 결과 데이터의 items 부분이 다르므로 기본 구조 도메인과 Item 도메인을 분리해서 생성하였다. 12345678import lombok.Data;@Datapublic class ApiData &#123; private Response response;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.List;import lombok.Data;@Datapublic class Response &#123; private Header header; private Body body; @Data public static class Header &#123; private int resultCode; private String resultMsg; &#125; @Data public static class Body &#123; /** 데이터 타입 */ private String dataType; /** 한 페이지 결과 수 */ private int numOfRows; /** 페이지 번호 */ private int pageNo; /** 전체 결과 수 */ private int totalCount; private Items items; &#125; @Data public static class Items &#123; private List&lt;VilageFcst&gt; item; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import lombok.Data;/** * 동네예보 서비스 도메인 * * @author hgko * */@Datapublic class VilageFcst &#123; /** 발표일자 */ private String baseDate; /** 발표시각 */ private String baseTime; /** 예보일자 */ private String fcstDate; /** 예보시각 */ private String fcstTime; /** 자료구분문자 */ private CategoryType category; /** 예보 값 */ private float fcstValue; /** 예보지점 X 좌표 */ private float nx; /** 예보지점 Y 좌표 */ private float ny; /** * 코드값 정보 */ @Getter public enum CategoryType &#123; POP(\"강수확률\", \"강수확률\"), R06(\"6시간 강수량\", \"범주 (1 mm)\"), S06(\"6시간 신적설\", \"범주 (1 cm)\"), SKY(\"하늘상태\", \"코드값\"), T3H(\"3시간 기온\", \"℃\"), TMN(\"아침 최저기온\", \"℃\"), TMX(\"낮 최저기온\", \"℃\"), WAV(\"파고\", \"M\"), T1H(\"기온\", \"℃\"), RN1(\"1시간 강수량\", \"mm\"), UUU(\"동서바람성분\", \"m/s\"), VVV(\"남북바람성분\", \"m/s\"), REH(\"습도\", \"%\"), PTY(\"강수형태\", \"코드값\"), VEC(\"풍향\", \"m/s\"), WSD(\"풍속\", \"1\"); private String name; private String unit; private CategoryType(String name, String unit) &#123; this.name = name; this.unit = unit; &#125; &#125;&#125; 2) 데이터 조회 데이터 조회 시 주의해야 할 점은 시간을 3시간 단위로 설정해야 한다. 오전 02시부터 3시간 단위로 증가해서 시간을 설정한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final String BASE_URL = \"http://apis.data.go.kr/1360000/VilageFcstInfoService/getVilageFcst\";private final String serviceKey = \"\"; /*공공데이터포털에서 받은 인증키*/public void getVilageFcst() &#123; try &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); urlBuilder.append(\"?\" + URLEncoder.encode(\"ServiceKey\", \"UTF-8\") + \"=\" + serviceKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"pageNo\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"numOfRows\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"10\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"dataType\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"JSON\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_date\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"20200807\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"base_time\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1100\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"nx\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"76\", \"UTF-8\")); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"ny\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"122\", \"UTF-8\")); URL url = new URL(urlBuilder.toString()); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Content-type\", \"application/json\"); System.out.println(\"Response code: \" + conn.getResponseCode()); if (conn.getResponseCode() &gt;= 200 &amp;&amp; conn.getResponseCode() &lt;= 300) &#123; StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); in.lines().forEach(line -&gt; &#123; sb.append(line); &#125;); in.close(); conn.disconnect(); System.out.println(sb.toString()); setWeatherInfo(sb.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 동네예보 데이터 파싱 * @param json */private void setWeatherInfo(String json) &#123; try &#123; ObjectMapper objectMapper = new ObjectMapper(); ApiData data = objectMapper.readValue(json, ApiData.class); Items items = data.getResponse().getBody().getItems(); for (VilageFcst item : items.getItem()) &#123; if (item.getCategory() == CategoryType.T3H) &#123; &#125; else if (item.getCategory() == CategoryType.REH) &#123; &#125; else if (item.getCategory() == CategoryType.SKY) &#123; &#125; else if (item.getCategory() == CategoryType.PTY) &#123; &#125; &#125; &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 동네예보 데이터들이 조회되면 데이터들을 가공해서 사용하도록 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"}]},{"title":"[JAVA] 농업기상정보 서비스 API 사용 방법","slug":"java-dev-4","date":"2020-07-31T06:07:15.000Z","updated":"2024-01-11T08:11:35.832Z","comments":true,"path":"2020/07/31/java-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-4/","excerpt":"","text":"농업기상정보 서비스 농업 관련 기상 데이터가 필요하게 되어 공공데이터 포털 사이트의 농업기상정보 API를 사용하여 조회하였다. Open API 활용 방법 농업기상정보서비스 사이트에 접속한다. 이용방법에 따라 회원가입 후 Open API 신청을 하고 Service Key를 발급받는다. 활용 가이드를 다운로드하여 조회 조건 및 결과 데이터를 이해한다. 농업 기상 데이터 조회 1http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp?mberid=&#123;id&#125;&amp;regist_ky=&#123;발급받은 Service Key&#125; 결과 데이터(XML 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;Root&gt; &lt;Info&gt; &lt;stncode&gt;380959A001&lt;/stncode&gt; &lt;stnname&gt;충주시 달천동&lt;/stnname&gt; &lt;date&gt;2020/07/31 14:50&lt;/date&gt; &lt;temp_150&gt;28.3℃&lt;/temp_150&gt; &lt;tmprt_150Top&gt;29.7℃&lt;/tmprt_150Top&gt; &lt;tmprt_150Lwet&gt;22.5℃&lt;/tmprt_150Lwet&gt; &lt;tmprt_50&gt;-℃&lt;/tmprt_50&gt; &lt;tmprt_50Top&gt;-℃&lt;/tmprt_50Top&gt; &lt;tmprt_50Lwet&gt;-℃&lt;/tmprt_50Lwet&gt; &lt;tmprt_400&gt;-℃&lt;/tmprt_400&gt; &lt;tmprt_400Top&gt;-℃&lt;/tmprt_400Top&gt; &lt;tmprt_400Lwet&gt;-℃&lt;/tmprt_400Lwet&gt; &lt;hd_150&gt;86.2%&lt;/hd_150&gt; &lt;hd_150Top&gt;100.0%&lt;/hd_150Top&gt; &lt;hd_150Lwet&gt;75.6%&lt;/hd_150Lwet&gt; &lt;hd_50&gt;-%&lt;/hd_50&gt; &lt;hd_50Top&gt;-%&lt;/hd_50Top&gt; &lt;hd_50Lwet&gt;-%&lt;/hd_50Lwet&gt; &lt;hd_400&gt;-%&lt;/hd_400&gt; &lt;hd_400Top&gt;-%&lt;/hd_400Top&gt; &lt;hd_400Lwet&gt;-%&lt;/hd_400Lwet&gt; &lt;wd_300&gt;남동&lt;/wd_300&gt; &lt;wd_300Top&gt;남&lt;/wd_300Top&gt; &lt;wd_300Lwet&gt;정온&lt;/wd_300Lwet&gt; &lt;wd_150&gt;-&lt;/wd_150&gt; &lt;wd_150Top&gt;-&lt;/wd_150Top&gt; &lt;wd_150Lwet&gt;-&lt;/wd_150Lwet&gt; &lt;wd_1000&gt;-&lt;/wd_1000&gt; &lt;wd_1000Top&gt;-&lt;/wd_1000Top&gt; &lt;wd_1000Lwet&gt;-&lt;/wd_1000Lwet&gt; &lt;arvlty_300&gt;1.9&lt;/arvlty_300&gt; &lt;arvlty_300Top&gt;4.0&lt;/arvlty_300Top&gt; &lt;arvlty_300Lwet&gt;0.0&lt;/arvlty_300Lwet&gt; &lt;arvlty_150&gt;-&lt;/arvlty_150&gt; &lt;arvlty_150Top&gt;-&lt;/arvlty_150Top&gt; &lt;arvlty_150Lwet&gt;-&lt;/arvlty_150Lwet&gt; &lt;arvlty_1000&gt;-&lt;/arvlty_1000&gt; &lt;arvlty_1000Top&gt;-&lt;/arvlty_1000Top&gt; &lt;arvlty_1000Lwet&gt;-&lt;/arvlty_1000Lwet&gt; &lt;afp&gt;0.0mm&lt;/afp&gt; &lt;afv&gt;-mm&lt;/afv&gt; &lt;sunshnTime&gt;202.0hr&lt;/sunshnTime&gt; &lt;solradQy&gt;10.4MJ/㎡&lt;/solradQy&gt; &lt;dwcnTime&gt;0.0hr&lt;/dwcnTime&gt; &lt;pnwgTp&gt;-hr&lt;/pnwgTp&gt; &lt;pnwgTpTop&gt;-hr&lt;/pnwgTpTop&gt; &lt;pnwgTpLwet&gt;-hr&lt;/pnwgTpLwet&gt; &lt;frfrTp&gt;-℃&lt;/frfrTp&gt; &lt;frfrTpTop&gt;-℃&lt;/frfrTpTop&gt; &lt;frfrTpLwet&gt;-℃&lt;/frfrTpLwet&gt; &lt;udgrHeattCndctvt&gt;-100.0℃&lt;/udgrHeattCndctvt&gt; &lt;udgrHeattCndctvtTop&gt;-100.0℃&lt;/udgrHeattCndctvtTop&gt; &lt;udgrHeattCndctvtLwet&gt;-100.0℃&lt;/udgrHeattCndctvtLwet&gt; &lt;udgrTp_10&gt;-℃&lt;/udgrTp_10&gt; &lt;udgrTp_10Top&gt;26.1℃&lt;/udgrTp_10Top&gt; &lt;udgrTp_10Lwet&gt;24.4℃&lt;/udgrTp_10Lwet&gt; &lt;udgrTp_5&gt;-℃&lt;/udgrTp_5&gt; &lt;udgrTp_5Top&gt;-℃&lt;/udgrTp_5Top&gt; &lt;udgrTp_5Lwet&gt;-℃&lt;/udgrTp_5Lwet&gt; &lt;udgrTp_20&gt;-℃&lt;/udgrTp_20&gt; &lt;udgrTp_20Top&gt;-℃&lt;/udgrTp_20Top&gt; &lt;udgrTp_20Lwet&gt;-℃&lt;/udgrTp_20Lwet&gt; &lt;soilMitr_10&gt;32.5&lt;/soilMitr_10&gt; &lt;soilMitr_10Top&gt;36.3&lt;/soilMitr_10Top&gt; &lt;soilMitr_10Lwet&gt;27.3&lt;/soilMitr_10Lwet&gt; &lt;soilMitr_10Cmst&gt;23.4&lt;/soilMitr_10Cmst&gt; &lt;soilMitr_10CmstTop&gt;27.2&lt;/soilMitr_10CmstTop&gt; &lt;soilMitr_10CmstLwet&gt;18.2&lt;/soilMitr_10CmstLwet&gt; &lt;soilMitr_20&gt;-&lt;/soilMitr_20&gt; &lt;soilMitr_20Top&gt;-&lt;/soilMitr_20Top&gt; &lt;soilMitr_20Lwet&gt;-&lt;/soilMitr_20Lwet&gt; &lt;soilMitr_20Cmst&gt;-&lt;/soilMitr_20Cmst&gt; &lt;soilMitr_20CmstTop&gt;-&lt;/soilMitr_20CmstTop&gt; &lt;soilMitr_20CmstLwet&gt;-&lt;/soilMitr_20CmstLwet&gt; &lt;soilMitr_30&gt;-&lt;/soilMitr_30&gt; &lt;soilMitr_30Top&gt;-&lt;/soilMitr_30Top&gt; &lt;soilMitr_30Lwet&gt;-&lt;/soilMitr_30Lwet&gt; &lt;soilMitr_30Cmst&gt;-&lt;/soilMitr_30Cmst&gt; &lt;soilMitr_30CmstTop&gt;-&lt;/soilMitr_30CmstTop&gt; &lt;soilMitr_30CmstLwet&gt;-&lt;/soilMitr_30CmstLwet&gt; &lt;/Info&gt;&lt;/Root&gt; 1) Respone Domain 생성 기본적으로 결과가 XML 형식이므로 javax.xml를 사용하여 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import lombok.Data;/** * 기상청 API로 기상정보 조회할 때 쓰이는 도메인 * * @author hgko * */@Data@XmlRootElement(name = \"Root\")@XmlAccessorType(value = XmlAccessType.FIELD)public class ResponseXml &#123; @XmlElement(name = \"Info\") private Info info; @Data public static class Info &#123; /** 지역 코드 */ private String stncode; /** 지역 이름 */ private String stnname; /** 일시 */ private String date; /** 온도(150CM) */ private String temp_150; /** 습도(150CM) */ private String hd_150; /** 풍향(300CM) */ private String wd_300; /** 풍속(300CM) */ private float arvlty_300; /** 강수량 */ private String afp; /** 증발량 */ private String afv; /** 일사량 */ private String solradQy; /** 일조시간 */ private String sunshnTime; /** 토양수분(10CM) */ private float soilMitr_10; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회한다. 123456789101112131415161718private final String BASE_URL = \"http://weather.rda.go.kr/openapi/realtime_openapi_xml.jsp\";private final String userId = \"\"; // Login Idprivate final String serviceKey = \"\"; // 발급받은 Service Keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"mberid\", \"UTF-8\") + \"=\" + userId); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"regist_ky\", \"UTF-8\") + \"=\" + serviceKey); RestTemplate restTemplate = new RestTemplate(); ResponseXml response = restTemplate.getForObject(urlBuilder.toString(), ResponseXml.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"}]},{"title":"[JAVA] OpenWeather API 사용 방법","slug":"java-dev-3","date":"2020-07-31T05:12:22.000Z","updated":"2024-01-11T08:11:18.411Z","comments":true,"path":"2020/07/31/java-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-3/","excerpt":"","text":"OpenWeather API 200,000 개가 넘는 도시를 포함하여 지구상의 모든 위치에 대한 현재 날씨 데이터에 액세스 할 수 있습니다. 현재 날씨는 글로벌 모델과 4만 개가 넘는 기상 관측소의 데이터를 기반으로 자주 업데이트됩니다. 데이터는 JSON, XML 또는 HTML 형식으로 제공됩니다. 출처 : OpenWeather OpenWeather API를 사용하여 현재 날씨 데이터를 조회하였다. 현재 날씨 데이터 조회 OpenWeather 사이트에 접속해서 API Key를 발급받는다. 메인에서 Current Weather Data를 선택받는다. 조회 조건 및 결과 정보와 다른 기능들에 대해 잘 설명되어 있다. 우리나라 전체에 대한 날씨 데이터를 조회할 것이기 때문에 조회 조건은 다음과 같다. 1http://api.openweathermap.org/data/2.5/weather?q=Koesan&amp;appid=&#123;발급받은 API Key&#125;&amp;lang=kr&amp;units=metric 결과 데이터(JSON 형식) 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"coord\": &#123; \"lon\": 127.79, \"lat\": 36.81 &#125;, \"weather\": [ &#123; \"id\": 803, \"main\": \"Clouds\", \"description\": \"튼구름\", \"icon\": \"04d\" &#125; ], \"base\": \"stations\", \"main\": &#123; \"temp\": 28, \"feels_like\": 32.65, \"temp_min\": 28, \"temp_max\": 28, \"pressure\": 1014, \"humidity\": 78 &#125;, \"visibility\": 10000, \"wind\": &#123; \"speed\": 1.5, \"deg\": 270 &#125;, \"clouds\": &#123; \"all\": 75 &#125;, \"dt\": 1596171614, \"sys\": &#123; \"type\": 1, \"id\": 8131, \"country\": \"KR\", \"sunrise\": 1596141211, \"sunset\": 1596191806 &#125;, \"timezone\": 32400, \"id\": 1842800, \"name\": \"Koesan\", \"cod\": 200&#125; 1) Respone Domain 생성 기본적으로 결과가 JSON 형식이므로 그에 맞게 도메인을 생성하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;import lombok.Data;/** * OpenWeath API - 현재 날씨 데이터 * @author hgko */@Datapublic class OpenWeather &#123; private List&lt;Weather&gt; weather; /** 내부 매개 변수 */ private String base; private Main main; private Wind wind; private Clouds clouds; private Rain rain; private Snow snow; /** 가시성 */ private int visibility; /** 데이터 계산 시간, 유닉스, UTC */ private long dt; /** UTC에서 초 단위로 이동 */ private int timezone; /** 도시 ID */ private long id; /** 도시 이름 */ private String name; /** 내부 매개 변수 */ private int cod; @Data public static class Weather &#123; /** 기상 조건 ID */ private int id; /** 날씨 매개 변수 그룹 (비, 눈, 극한 등) */ private String main; /** 그룹 내 날씨 조건 */ private String description; /** 날씨 아이콘 ID */ private String icon; &#125; @Data public static class Main &#123; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float temp; /** 온도. 단위 기본값 : 켈빈, 미터법 : 섭씨, 임페리얼 : 화씨 */ private float feels_like; /** 현재 최저 온도.(대규모 대도시 및 도시 지역 내) */ private float temp_min; /** 현재 최대 온도.(대규모 대도시 및 도시 지역 내)*/ private float temp_max; /** 대기압 (해수면, 해수면 또는 grnd_level 데이터가 없는 경우), hPa */ private int pressure; /** 습도, % */ private float humidity; /** 해수면의 대기압, hPa */ private float sea_level; /** 지면에서의 대기압, hPa */ private float grnd_level; &#125; @Data public static class Wind &#123; /** 바람의 속도. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float speed; /** 풍향,도 (기상) */ private int deg; /** 바람 돌풍. 단위 기본값 : meter/sec, 미터법 : meter/sec, 임페리얼 : miles/hour */ private float gust; &#125; @Data public static class Clouds &#123; /** 흐림, % */ private int all; &#125; @Data public static class Rain &#123; /** 지난 1 시간 동안의 강우량, mm */ @JsonProperty(\"1h\") private float rain1h; /** 지난 3 시간 동안의 강우량, mm */ @JsonProperty(\"3h\") private float rain3h; &#125; @Data public static class Snow &#123; /** 지난 1 시간 동안의 눈량, mm */ @JsonProperty(\"1h\") private float snow1h; /** 지난 3 시간 동안의 눈량, mm */ @JsonProperty(\"3h\") private float snow3h; &#125; @Data public static class Sys &#123; private int type; private int id; /** 국가 코드 (GB, JP 등) */ private String country; /** 일출 시간, 유닉스, UTC */ private long sunrise; /** 일몰 시간, 유닉스, UTC */ private long sunset; &#125;&#125; 2) 데이터 조회 SpringFramework에서 지원하는 RestTemplate를 사용하여 조회하였다. 12345678910111213141516171819private final String BASE_URL = \"http://api.openweathermap.org/data/2.5/weather\";private final String apiKey = \"\"; // 발급받은 API keypublic void getWeatherData() &#123; StringBuilder urlBuilder = new StringBuilder(BASE_URL); try &#123; urlBuilder.append(\"?\" + URLEncoder.encode(\"q\", \"UTF-8\") + \"=Koesan\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"appid\", \"UTF-8\") + \"=\" + apiKey); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"lang\", \"UTF-8\") + \"=kr\"); urlBuilder.append(\"&amp;\" + URLEncoder.encode(\"units\", \"UTF-8\") + \"=metric\"); RestTemplate restTemplate = new RestTemplate(); OpenWeather response = restTemplate.getForObject(urlBuilder.toString(), OpenWeather.class); System.out.println(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3) 결과 확인 정상적으로 결과가 출력되었는지 확인하고 정상이면 날씨 데이터들을 가공해서 사용하도록 한다. 추가 내용 풍향 데이터 변환 날씨 API에서 풍향 데이터는 대부분이 degree(integer) 형식으로 되어 있기 때문에 방향을 나타내는 String 형식으로 나타낼 필요가 있다. 123456789101112131415161718192021222324252627282930313233343536373839# Enum 정의@Getterpublic enum WindType &#123; N0(0, \"북\"), NNE(1, \"북북동\"), NE(2, \"북동\"), ENE(3, \"동북동\"), E(4, \"동\"), ESE(5, \"동남동\"), SE(6, \"남동\"), SSE(7, \"남남동\"), S(8, \"남\"), SSW(9, \"남남서\"), SW(10, \"남서\"), WSW(11, \"서남서\"), W(12, \"서\"), WNW(13, \"서북서\"), NW(14, \"북서\"), NNW(15, \"북북서\"), N16(16, \"북\"); private int code; private String name; private WindType(int code, String name) &#123; this.code = code; this.name = name; &#125; public static WindType value(int value) &#123; for (WindType type : WindType.values()) &#123; if (type.getCode() == value) &#123; return type; &#125; &#125; return null; &#125;&#125; Enum을 사용하여 편리하게 변환한다. 12345private String getWindDirection(int degree) &#123; int result = (int)((degree + 22.5 * 0.5) / 22.5); WindType windType = WindType.value(result); return windType.getName();&#125; 1234public static void main(String[] args) &#123; String wd = getWindDirection(270); System.out.println(\"풍향 : \" : wd);&#125; 결과 1풍향 : 서 날씨 정보 변환 OpenWeatherMap API의 다국어에 한국어 지원을 위한 협업용 정보 openweathermap_api_translation_ko","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"}]},{"title":"[CSS] 그라데이션 효과","slug":"css-dev-1","date":"2020-07-31T01:20:38.000Z","updated":"2023-07-17T12:56:40.270Z","comments":true,"path":"2020/07/31/css-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/css-dev-1/","excerpt":"","text":"linear-gradient : CSS3에서 추가된 것으로, 선형 그라데이션 효과를 만들 수 있다. 1linear-gradient( direction, color1, color2, …, color3 ); direction에는 그라데이션 방향을 입력한다. to bottom : 위에서 아래로 그라데이션을 만든다. (기본값) to top : 아래에서 위로 그라데이션을 만든다. to left : 오른쪽에서 왼쪽으로 그라데이션을 만든다. to right : 왼쪽에서 오른쪽으로 그라데이션을 만든다. ndeg : n 도의 방향으로 그라데이션을 만든다. 예시 1234.gradation_bar &#123; width: 100%; background: linear-gradient(to right, #ff0000, orange, yellow, #00ff00, #0000ff, indigo, violet);&#125; 결과 참고 Ultimate CSS Gradient Generator","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"}]},{"title":"[JAVA] proj4 투형 변환","slug":"java-dev-2","date":"2020-07-31T01:04:39.000Z","updated":"2024-01-11T08:10:27.253Z","comments":true,"path":"2020/07/31/java-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-2/","excerpt":"","text":"투형 변환 TM(미국좌표) 좌표와 WGS84(한국좌표) 좌표를 서로 변환한다. 다운로드 Java Map Projection Library 사이트에 접속하여 다음의 Download에서 소스 및 jar 파일을 다운로드한다. 다운로드한 jar 파일은 프로젝트의 classpath 경로에 추가한다. 샘플 1234567891011121314151617181920212223// 투형 정보 입력(중부원점 직각좌표 투형정보)String[] proj4 = new String[] &#123; \"+proj=tmerc\", \"+lat_0=38N\", \"+lon_0=127.00289027777777777776E\", \"+ellps=bessel\", \"+units=m\", \"+x_0=200000\", \"+y_0=500000\", \"+k=1.0\"&#125;Projection proj = ProjectionFactory.fromPROJ4Specification(proj4);Point2D.Double srcProject = new Point2D.Double(132, 37);Point2D.Double dstProject = proj.transform(srcProject, new Point2D.Double());System.out.println(\"TM : \" + dstProject);srcProject = new Point2D.Double(644904.399587292, 400717.8948938238);dstProject = proj.inverseTransForm(srcProject, new Point2D.Double());System.out.println(\"WGS84 : \" + dstProjec); 결과 12TM : Point2D.Double[644904.399587292, 400717.8948938238]WGS84 : Point2D.Double[132.00000000065793, 36.999999999128526]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"}]},{"title":"[JAVA] Julian Date Conversion","slug":"java-dev-1","date":"2020-07-31T00:59:38.000Z","updated":"2023-03-14T02:18:51.709Z","comments":true,"path":"2020/07/31/java-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/java-dev-1/","excerpt":"","text":"율리우스력 변환하기 율리우스력은 고대 로마의 정치가 율리우스 카이사르가 기원전 46년에 제정해 기원전 45년부터 시행한 양력(陽曆) 역법이다. 율리우스력의 1년은 365일 또는 366일(4년에 한번)이다. 기원전 46년 이전까지 고대 로마에서는 태음력을 사용하였으며, 점차 계절의 변화(즉, 태양의 일주)를 고려해 태음력과 태양력을 섞어서 년(年)과 월(月)을 계산하였다. 이에 따라 특히 달을 계산하는 데 적지 않은 혼란과 계산의 착오가 생겼으며, 이러한 착오는 제사장이 임의로 수정하였다. 율리우스 카이사르가 채택한 달력은 태양력을 기준으로 2월을 제외한 달은 모두 30일 또는 31일로 정함으로써 이전에 있던 번거로움을 한꺼번에 해소하였다. 출처 : 위키백과 1. Joda-Time Library 사용 12345String dateStr = \"2009218\";MutableDateTime mdt = new MutableDateTime();mdt.setYear(Integer.parseInt(dateStr.subString(0, 3)));mdt.setDayOfYear(Integer.parseInt(dateStr.subString(4)));Date parsedDate = mdt.toDate(); 2. Java Api 사용 12345String dateStr = \"2009218\";Calendar cal = new GregorianCalendar();cal.set(Calendar.YEAR,Integer.parseInt(dateStr.subString(0, 3)));cal.set(Calendar.DAY_OF_YEAR,Integer.parseInt(dateStr.subString(4)));Date parsedDate = cal.getTime();","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"}]},{"title":"[Eclipse RCP] 폴더안의 파일 리스트 읽기","slug":"rcp-dev-4","date":"2020-07-31T00:53:37.000Z","updated":"2023-07-17T13:04:41.398Z","comments":true,"path":"2020/07/31/rcp-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-4/","excerpt":"","text":"SWT 의 DirectoryDialog 를 이용하여 폴더를 읽고 폴더의 파일들을 읽어서 원하는 List 의 형식으로 만든다. 123456789101112131415161718192021Shell shell = GUIUtil.getShell();shell.getDisplay().asyncExec(() -&gt; &#123; DirectoryDialog dialog = new DirectoryDialog(shell); dialog.setMessage(\"Please select a directory and click OK\"); String dir = dialog.open(); if (dir != null) &#123; List&lt;MapImage&gt; mapImages = null; try &#123; mapImages = Files.list(new File(dir).toPath()) .filter(file -&gt; file.toFile().isFile()) .filter(file -&gt; !file.toFile().getName().endsWith(\".txt\")) .map(file -&gt; &#123; return new MapImage(shell, file.toFile()); &#125;).collect(Collectors.toList()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.err.println(mapImages); &#125;&#125;);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[Eclipse RCP] SWT에서의 GC, Drawable, Canvas 사용","slug":"rcp-dev-3","date":"2020-07-31T00:38:00.000Z","updated":"2024-01-11T08:13:05.766Z","comments":true,"path":"2020/07/31/rcp-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/31/rcp-dev-3/","excerpt":"","text":"addPaintListener() Control 객체가 그 객체의 paintEvent를 통하여 그림을 그릴 수 있지만, 이보다는 Control 클래스를 상속받아 그래픽 작업을 위해 설계된 특별한 클래스인 Canvas 클래스를 사용하여 그림을 그리는 것이 더욱 좋습니다. Canvas 클래스를 생성한 후 addPaintListener()를 통하여 paintListener를 추가하거나, 사용자가 직접 정의한 Control을 상속받음으로써 그림을 그릴 수 있습니다. Canvas 클래스는 그림을 그릴 때 사용할 수 있는 다양한 종류의 스타일 비트를 가지고 있습니다. SWT.NO_BACKGROUND Canvas의 기본적인 동작은 다음과 같습니다. 객체의 할당영역을 그리기 앞서, 객체에 할당된 전체 영역을 현재 배경색으로 칠합니다. 이때 화면이 깜박이는 현상을 볼 수 있는데 이는 paintEvent가 배경색을 칠하고, 그 위에 Canvas의 요소들을 덧칠하는 순간을 우리가 보는 것입니다. 이 현상을 방지하기 위한 방법 중 하나는, Canvas를 생성할 때 SWT.NO_BACKGROUND 스타일 비트를 사용하여 배경이 그려지지 않게 하는것입니다. 단, 이 비트를 사용할 경우, 프로그램은 영역 전체에 대하여 모든 픽셀을 직접 그려야 합니다. SWT.NO_REDRAW_RESIZE 위젯의 사이즈가 변경될 때에도 paintEvent가 발생합니다. 이 역시 화면을 깜박거리게 할 수 있는데, 왜냐하면 사이즈가 변경될 때마다 해당 영역에 대해 모든 요소들을 다시 그려야 하기 때문입니다. 이는 SWT.NO_REDRAW_RESIZE 스타일 비트를 사용하여 완화시킬 수 있으며, 이는 컨트롤의 사이즈가 변경되더라도 paintEvent가 발생하지 않는다는 것을 의미합니다. 이는 컨트롤이 불필요하게 다시 그려지는 것을 방지한다는 의미를 갖으며, 만약 크기가 증가된다고 한다면, paintEvent의 GC는 이 영역을 제외한 부분만을 다시 그리게 됩니다. 단 사각형 모양이 Canvas가 존재할 경우 사각형의 오른쪽 하단에 L이 거꾸로 된 형태로 그려질 수 있습니다. SWT.NO_REDRAW_RESIZE 스타일 비트는 새로 그려지는 부분에 대해서 적절히 처리해줄 경우, 고정사이즈의 그림이 GC에 그려질 때 나타나는 깜박임을 감소시킬 수 있습니다. 하지만 잘못 쓰였을 경우, SWT.NO_REDRAW_RESIZE는 치즈(cheese)라는 효과를 불러올 수 있습니다. 치즈는 다시 그려야 할 상황에 제대로 다시 그려지지 않는 부분이 있는 경우를 지칭합니다. paintEvent가 클라이언트 전 영역을 다시 그려야 하는 다음의 예시를 확인해 보세요. 화면이 작아질 때에는 paintEvent가 발생하지 않기 때문에 그림이 다시 그려지지 않습니다. SWT.NO_REDRAW_RESIZE 상태에서 화면이 커질 경우, paintEvent는 새로 그려야 하는 부분에 대해서만 영역을 다시 그립니다. 그래서 기존에 그려졌던 부분이 지워지지 않았기 때문에 치즈 현상이 발생하게 됩니다. 또한 Canvas 사이즈가 증가할 때 GC는 필요한 부분만 다시 그리기 때문에 치즈 현상이 발생하게 됩니다. 12345678910shell.setLayout(new FillLayout());final Canvas canvas = new Canvas(shell,SWT.NO_REDRAW_RESIZE);canvas.addPaintListener(new PaintListener() &#123; public void paintControl(PaintEvent e) &#123; Rectangle clientArea = canvas.getClientArea(); e.gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN)); e.gc.fillOval(0,0,clientArea.width,clientArea.height); &#125;&#125;); SWT.NONE 이 문제를 해결하는 방법은 SWT.NONE 스타일 비트를 사용하여 GC가 크기가 커질 때 커진 부분만 새로 그리는것이 아닌, 모든 부분을 새로 그리도록 하고, 동시에 paintEvent가 셸 사이즈가 작아졌을 때에도 발생하게 하여, Canvas의 전체 부분이 다시 그려지게 하는 것입니다. 1final Canvas canvas = new Canvas(shell,SWT.NONE); SWT.NO_MERGE_PAINTS 각각의 SWT 위젯에 대해, 만약 하나이상의 영역이 다시 그려져야 할 경우, 운영체제는 다시 그려야 할 영역을 하나의 영역으로 묶어서 paintEvent를 발생하여 효율적인 처리를 가능하게 합니다. Canvas의 SWT.NO_MERGE_PAINTS 스타일 비트는 각각의 위젯에서 다시 그릴 영역을 하나로 묶지 않고, 각각의 영역에 대해 일일이 paintEvent를 호출하는 방식으로 변경합니다. 정리 NO_BACKGROUND, NO_REDRAW_RESIZE, NO_MERGE_PAINTS 스타일 비트는 Composite와 이 하부 클래스인 Canvas, Shell, Group등에서 사용할 수 있습니다, SWT에서 허용하긴 하지만, Composite 클래스의 Javadoc에서는 스타일 비트에 대해서 다음과 같이 기술합니다. Canvas 이외의 Composite의 하위클래스에서의 사용은 정의되지 않았다. 그러므로 Canvas 클래스가 그림 그리는데에 가장 적합한 컨트롤이라 할 수 있습니다. 깜박임을 방지하는 또 다른 방법은 더블 버퍼링을 사용하여 그림 그리기를 한 번에 처리하는 것입니다. 더블 버퍼링은 paintEvent에서 제공하는 GC기 아닌 GC에 그림을 미리 그린 후, 이것을 제공되는 GC에 복사하는 기술입니다. 이를 위하여, Canvas의 영역과 동일한 사이즈의 Image 객체를 만들고, GC(Image)를 통하여 이 객체에 그림을 그립니다. 그려진 그림(Image)은 drawImage(Image, int, int) 메서드를 호출함으로써 paintEvent의 GC로 그려지게 됩니다. 이 기술을 사용할 때 주의할 점은 몇몇 운영체제는 이미 더블 버퍼링을 자체적으로 구현하고 있으므로, 결국 트리플 버퍼링이 이루어질 수 있다는 점입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"[PyTorch] 기초 사용법","slug":"ai-pytorch-1","date":"2020-07-30T06:04:07.000Z","updated":"2023-03-14T02:18:45.739Z","comments":true,"path":"2020/07/30/ai-pytorch-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/30/ai-pytorch-1/","excerpt":"","text":"Load Packages 12import numpy as npimport torch Basic PyTorch 기초 사용법 1234nums = torch.arange(9)nums.shapenums.numpy()nums.reshape(3, 3) 1234randoms = torch.rand((3, 3))zeros = torch.zeros((3, 3))ones = torch.ones((3, 3))torch.zeros_like(ones) Operations PyTorch로 수학연산 하기 1234567891011nums * 3nums = nums.reshape((3, 3))nums + numsresult = torch.add(nums, 10)result.numpy()# Outarray([[10, 11, 12], [13, 14, 15], [16, 17, 18]], dtype=int64) View reshape와 같다. 123456range_nums = torch.arange(9).reshape(3, 3)range_nums.view(-1)range_nums.view(1, 9)# Outtensor([[0, 1, 2, 3, 4, 5, 6, 7, 8]]) Compile numpy를 torch tensor로 불러오기 12345arr = np.array([1, 1, 1])arr_torch = torch.from_numpy(arr)arr_torch.float()# tensor([1., 1., 1.]) Device 설정 12345device = 'cuda' if torch.cuda.is_available() else 'cpu'arr_torch.to(device)# Out - GPU 사용 가능tensor([1, 1, 1], device='cuda:0', dtype=torch.int32) AutoGrad 기울기 구하기 123456x = torch.ones(2, 2, requires_grad=True)y = x + 2print(x.grad_fn)# Out&lt;AddBackward0 object at 0x000001FFE2A04148&gt; 1234567z = y * y * 3out = z.mean()print(z, out)# Outtensor([[27., 27.], [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;) 123456out.backward()print(x.grad)# Outtensor([[4.5000, 4.5000], [4.5000, 4.5000]])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[TensorFlow 2.0] Evaluating & Prediction","slug":"ai-dev-7","date":"2020-07-29T02:29:29.000Z","updated":"2023-07-17T12:56:15.225Z","comments":true,"path":"2020/07/29/ai-dev-7/","link":"","permalink":"http://hgko1207.github.io/2020/07/29/ai-dev-7/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets Build Model 123456789101112131415161718192021222324252627input_shape = (28, 28, 1)num_classes = 10learning_rate = 0.001inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') 1234# Model is the full model w/o custom layersmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate), loss='sparse_categorical_crossentropy', metrics=['accuracy']) Preprocess 데이터셋 불러오기 1234567(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis]train_x = train_x / 255.test_x = test_x / 255. Training 12345678910num_epochs = 1batch_size = 64hist = model.fit(train_x, train_y, batch_size=batch_size, shuffle=True)# 결과Train on 60000 samples60000/60000 [==============================] - 6s 94us/sample - loss: 0.0798 - accuracy: 0.9755 1234hist.history# 결과&#123;'loss': [0.07980264157739779], 'accuracy': [0.9755]&#125; Evaluating 학습한 모델을 확인합니다. 1234model.evaluate(test_x, test_y, batch_size=batch_size)# 결과[0.03286817007374484, 0.9888] 결과 확인 Input으로 들어갈 이미지 데이터를 확인한다. 123456789import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinetest_image = text_x[0, :, :, 0]test_image.shape# 결과(28, 28) 123plt.title(test_y[0])plt.imshow(test_image, 'gray')plt.show() 모델에 Input Data로 확인 할 이미지 데이터를 넣는다. 1234567# 이미지를 보기위해 shape를 바꿨었는데 다시 reshape로 차원을 변경합니다.pred = model.predict(test_image.reshape(1, 28, 28, 1))# 결과array([[2.4227038e-09, 2.3278629e-08, 5.8909092e-07, 1.0298673e-07, 9.4029007e-10, 6.1998517e-11, 1.4364351e-12, 9.9999928e-01, 4.7319365e-10, 4.7449920e-08]], dtype=float32) 12345# 배열에서 가장 높은 값의 인덱스를 찾을 때 np.argmax를 사용한다.np.argmax(pred)# 결과7 Test Batch Batch Test Dataset 모델에 넣는다. 12345test_batch = test_x[:32]test_batch.shape# 결과(32, 28, 28, 1) 12345preds = model.predict(test_batch)preds.shape# 결과(32, 10) 123456789# -1을 넣으면 하나의 값이 아니라 앞의 32개의 결과를 보여줍니다.np.argmax(preds, -1)# 결과array([7, 2, 1, 0, 4, 1, 4, 9, 5, 9, 0, 6, 9, 0, 1, 5, 9, 7, 5, 4, 9, 6, 6, 5, 4, 0, 7, 4, 0, 1, 3, 1], dtype=int64)plt.imshow(test_batch[5, :, :, 0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Expert)","slug":"ai-dev-6","date":"2020-07-28T08:38:22.000Z","updated":"2023-07-17T12:55:57.031Z","comments":true,"path":"2020/07/28/ai-dev-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/28/ai-dev-6/","excerpt":"","text":"TensorFlow 공식 홈페이지에서 설명하는 Expert 버전을 사용해본다. Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Build Model 1234567891011121314151617181920212223242526input_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(input_shape, dtype=tf.float64)net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.5)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Preprocess TensorFlow 공식 홈페이지에서 말한 expert 방법을 사용한다. 1234567891011mnist = tf.keras.datasets.mnist# Load Data from MNIST(x_train, y_train), (x_test, y_test) = mnist.load_data()# Channel 차원 추가x_train = x_train[..., tf.newaxis]x_test = x_test[..., tf.newaxis]# Data Normailzationx_train, x_test = x_train / 255.0, x_test / 255.0 tf.data 사용 from_tensor_slices() shuffle() batch() 123456train_ds = tf.data.Dataset.from_tensor_slices((x_train, y_train))train_ds = train_ds.shuffle(1000)train_ds = train_ds.batch(32)test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))test_ds = test_ds.batch(32) Visualize Data matplotlib 불러와서 데이터를 시각화한다. 1234567import matplotlib.pyplot as plt%matplotlib inlinefor image, label in train_ds.take(2): plt.title(label[0].shape) plt.imshow(image[0, :, :, 0], 'gray') plt.show() Training (Keras) Keras로 학습 할 때는 기존과 같지만, train_ds는 generator라서 그래도 넣을 수 있다. 12model.compile(optimizer='adam', loss='sparse_categorical_crossentropy')model.fit(train_ds, epochs=1000) Optimization Loss Function Optimizer Metrics 12345678loss_object = tf.keras.losses.SparseCategoricalCrossentropy()optimizer = tf.keras.optimizers.Adam()train_loss = tf.keras.metrics.Mean(name='train_loss')train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')test_loss = tf.keras.metrics.Mean(name='test_loss')test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy') Training @tf.function : 기존 session 열었던 것 처럼 바로 작동 안 하고, 그래프만 만들고 학습이 시작되면 돌아가도록 한다. 12345678910@tf.functiondef train_step(images, labels): with tf.GradientTape() as tape: predictions = model(images) loss = loss_object(labels, predictions) gradients = tape.gradient(loss, model.trainable_variables) optimizer.apply_gradients(zip(gradients, model.trainable_variables)) train_loss(loss) train_accuracy(labels, predictions) 1234567@tf.functiondef test_step(images, lebels): predictions = model(images) t_loss = loss_object(labels, predictions) test_loss(t_loss) test_accuracy(labels, predictions) 12345678910111213for epoch in range(2): for images, labels in train_ds: train_step(images, labels) for test_images, test_labels in test_ds: test_step(test_images, test_labels) template = 'Epoch &#123;&#125;, Loss: &#123;&#125;, Accuracy: &#123;&#125;, Test Loss &#123;&#125;, Test Accuracy: &#123;&#125;' print(template.format(epoch+1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100)) 결과 1234Start TrainingEpoch 1, Loss: 0.04196552559733391, Accuracy: 98.74666595458984, Test Loss 0.043360475450754166, Test Accuracy: 98.72000122070312Start TrainingEpoch 2, Loss: 0.033374134451150894, Accuracy: 99.0050048828125, Test Loss 0.03336939960718155, Test Accuracy: 98.95500183105469","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] Optimizer 및 Training (Keras)","slug":"ai-dev-5","date":"2020-07-24T08:35:22.000Z","updated":"2023-07-17T12:55:31.769Z","comments":true,"path":"2020/07/24/ai-dev-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/24/ai-dev-5/","excerpt":"","text":"Load Packages 1234import tensorflow as tffrom tensorflow.keras import layersfrom tensorflow.keras import datasets 학습 과정 돌아보기 Prepare MNIST Datset 1(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data() Build Model 1234567891011121314151617181920212223inputs = layers.Input((28, 28, 1))net = layers.Conv2D(32, (3, 3), padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, (3, 3), padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPooling2D(pool_size=(2, 2))(net)net = layers.Dropout(0.25)(net)net = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.5)(net)net = layers.Dense(10)(net) # num_classesnet = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic_CNN') Optimization 모델을 학습하기 전에 설정을 한다. Loss Function Metrics Optimizer Loss Function Categorical vs Binary 12loss = 'binary_crossentropy'loss = 'categorical_crossentropy' sparse_categorical_crossentropy vs categorical_crossentropy 12345loss_fun = tf.keras.losses.sparse_categorical_crossentropy# 또는tf.keras.losses.categorical_crossentropytf.keras.losses.binary_crossentropy Metrics 모델을 평가하는 방법이다.(정확도 측정) Accuracy : 예측이 레이블과 일치하는 빈도를 계산 BinaryAccuracy: 예측이 이진 레이블과 일치하는 빈도를 계산 CategoricalAccuracy : 예측이 one-hot 레이블과 일치하는 빈도를 계산 TopKCategoricalAccuracy : 상위 K 예측에서 대상이 얼마나 자주 나타되는지 계산 SparseTopKCategoricalAccuracy : 상위 K 예측에서 정수 대상이 얼마나 자주 나타하는지 계산 12345# accurany를 이름으로 넣는 방법metrics = ['accuracy']# tf.keras.metricsmetrics = [tf.keras.metrics.CategoricalAccuracy()] Optimizer ‘sgd’ ‘rmsprop’ ‘adam’ 123456optm = tf.keras.optimizers.Adam()# Outtf.keras.optimizers.SGD()tf.keras.optimizers.RMSprop()tf.keras.optimizers.Adam() Compile Optimizer 적용을 합니다. 123model.compile(optimizer=optm, loss=loss_fun, metrics=metrics) Prepaer Dataset 학습에 사용할 데이터셋을 준비한다. 데이터셋 확인 12345train_x.shape, train_y.shape&gt; ((60000, 28, 28), (60000,))test_x.shape, test_y.shape&gt; ((10000, 28, 28), (10000,)) 차원 수 늘리기 1234567import numpy as npnp.expand_dims(train_x, -1).shape&gt; (60000, 28, 28, 1)tf.expand_dims(train_x, -1).shape&gt; TensorShape([60000, 28, 28, 1]) 123# 최신 버전train_x = train_x[..., tf.newaxis]test_x = test_x[..., tf.newaxis] Rescaling 12345678np.min(train_x), np.max(train_x)&gt; (0, 255)train_x = train_x / 255.test_x = test_x / 255.np.min(train_x), np.max(train_x)&gt; (0.0, 1.0) Training 본격적으로 학습을 해봅니다. 그 전에 학습용 Hyperparameter 설정한다. num_epochs, batch_size 12345# 전체 sample 데이터를 이용하여 한 바퀴 돌며 학습하는 것을 1회 epoch이라 부른다.num_epochs = 1# 모델에 한번에 들어가는 데이터 수를 조절하여 메모리 사용 효율을 향상시킨다.batch_size = 32 실행! 12345678model.fit(train_x, train_y, batch_size=batch_size, shuffle=True, epochs=num_epochs)# ResultTrain on 60000 samples60000/60000 [==============================] - 99s 2ms/sample - loss: 0.1414 - categorical_accuracy: 0.0992","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 각 Layer별 역할 및 파라미터","slug":"ai-dev-4","date":"2020-07-20T07:39:18.000Z","updated":"2023-07-17T12:54:57.875Z","comments":true,"path":"2020/07/20/ai-dev-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-4/","excerpt":"","text":"Load Packages 12345import tensorflow as tfimport osimport matplotlib.pyplot as plt%matplotlib inline Input Image 1234567891011from tensorflow.keras import datasets(train_x, train_y), (test_x, test_y) = datasets.mnist.load_data()image = train_x[0]# 차원 수 높이기image = image[tf.newaxis, ..., tf.newaxis]image.shape# Out(1, 28, 28, 1) Feature Extraction Convolution filters: layer에서 나갈 때 몇 개의 filter를 만들 것인지 kernel_size: filter(Weight)의 크기 strides: 몇 개의 pixel을 skip 하면서 훑어지나갈 것인지 (크기에도 영향을 준다.) padding: zero padding을 만들 것인지. VALID는 padding이 없고, SAME은 padding이 있습니다. (크기에도 영향을 준다.) activation: Activation Function을 만들 것인지. 당장 설정 안해도 Layer 층을 따로 만들 수 있습니다. (Default: None) 1234tf.keras.layers.Conv2D(filters=3, kernel_size=(3, 3), strides=(1, 1), padding='VALID', activation='relu')# (3, 3) 대신에 3으로도 대체 가능tf.keras.layers.Conv2D(3, 3, 1, 'VALID') Visualization 1234image = tf.cast(image, dtype=tf.float32)layer = tf.keras.layers.Conv2D(3, 3, strides=(1, 1), padding='SAME')output = layer(image) 12345plt.subplot(121)plt.imshow(image[0, :, :, 0], 'gray')plt.subplot(122)plt.imshow(output[0, :, :, 0], 'gray')plt.show() weight 불러오기 1234567891011121314weight = layer.get_weights()[0]plt.figure(figsize=(15, 5))plt.subplot(131)plt.hist(output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(132)plt.title(weight.shape)plt.imshow(weight[:, :, 0, 0], 'gray')plt.subplot(133)plt.title(output.shape)plt.imshow(output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Activation Function 0 미만의 값들을 0으로 바꿔준다. 12345678import numpy as npact_layer = tf.keras.layers.ReLU()act_output = act_layer(output)np.min(act_output), np.max(act_output)# Out(0.0, 244.73064) # 0미만 값들이 0으로 바뀜 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(act_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(act_output.shape)plt.imshow(act_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Pooling 강조되는 것들만 압축합니다. 123456pool_layer = tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=(2, 2), padding='SAME')pool_output = pool_layer(act_output)pool_output.shape# OutTensorShape([1, 14, 14, 3]) 12345678910plt.figure(figsize=(15, 5))plt.subplot(121)plt.hist(pool_output.numpy().ravel(), range=[-2, 2])plt.ylim(0, 100)plt.subplot(122)plt.title(pool_output.shape)plt.imshow(pool_output[0, :, :, 0], 'gray')plt.colorbar()plt.show() Fully Connected Flatten 1234567891011layer = tf.keras.layers.Flatten()flatten = layer(output)flatten.shape# OutTensorShape([1, 2352]) # 28 * 28 * 3output.shape# OutTensorShape([1, 28, 28, 3]) 123456plt.figure(figsize=(10, 5))plt.subplot(211)plt.hist(flatten.numpy().ravel())plt.subplot(212)plt.imshow(flatten[:, :100])plt.show() Dense 하나씩 연결하겠다는 의미다. 123456layer = tf.keras.layers.Dense(32, activation='relu')output = layer(flatten)output.shape# OutTensorShape([1, 32]) # 32로 줄어들었습니다. DropOut 학습할 때만 랜덤하게 끊어준다. 학습이 끝나면 다시 복구시킨다. 1234567# 0.7은 비율입니다. 얼마나 끊을 것인지 살릴 것인지layer = tf.keras.layers.Dropout(0.7)output = layer(output)output.shape# OutTensorShape([1, 32]) Build Model 1234567891011121314151617181920212223242526272829303132from tensorflow.keras import layersinput_shape = (28, 28, 1)num_classes = 10inputs = layers.Input(shape=input_shape)# Feature Extractionnet = layers.Conv2D(32, 3, padding='SAME')(inputs)net = layers.Activation('relu')(net)net = layers.Conv2D(32, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.Conv2D(64, 3, padding='SAME')(net)net = layers.Activation('relu')(net)net = layers.MaxPool2D(2, 2)(net)net = layers.Dropout(0.25)(net)# Fully Connectednet = layers.Flatten()(net)net = layers.Dense(512)(net)net = layers.Activation('relu')(net)net = layers.Dropout(0.25)(net)net = layers.Dense(num_classes)(net)net = layers.Activation('softmax')(net)model = tf.keras.Model(inputs=inputs, outputs=net, name='Basic-CNN')model.summary() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# OutModel: \"Basic-CNN\"_________________________________________________________________Layer (type) Output Shape Param #=================================================================input_1 (InputLayer) [(None, 28, 28, 1)] 0_________________________________________________________________conv2d_25 (Conv2D) (None, 28, 28, 32) 320_________________________________________________________________activation_8 (Activation) (None, 28, 28, 32) 0_________________________________________________________________conv2d_26 (Conv2D) (None, 28, 28, 32) 9248_________________________________________________________________activation_9 (Activation) (None, 28, 28, 32) 0_________________________________________________________________max_pooling2d_8 (MaxPooling2 (None, 14, 14, 32) 0_________________________________________________________________dropout_5 (Dropout) (None, 14, 14, 32) 0_________________________________________________________________conv2d_27 (Conv2D) (None, 14, 14, 64) 18496_________________________________________________________________activation_10 (Activation) (None, 14, 14, 64) 0_________________________________________________________________conv2d_28 (Conv2D) (None, 14, 14, 64) 36928_________________________________________________________________activation_11 (Activation) (None, 14, 14, 64) 0_________________________________________________________________max_pooling2d_9 (MaxPooling2 (None, 7, 7, 64) 0_________________________________________________________________dropout_6 (Dropout) (None, 7, 7, 64) 0_________________________________________________________________flatten_4 (Flatten) (None, 3136) 0_________________________________________________________________dense_3 (Dense) (None, 512) 1606144_________________________________________________________________activation_12 (Activation) (None, 512) 0_________________________________________________________________dropout_7 (Dropout) (None, 512) 0_________________________________________________________________dense_4 (Dense) (None, 10) 5130_________________________________________________________________activation_13 (Activation) (None, 10) 0=================================================================Total params: 1,676,266Trainable params: 1,676,266Non-trainable params: 0_________________________________________________________________","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[TensorFlow 2.0] 예제 데이터셋 (MNIST) 사용","slug":"ai-dev-3","date":"2020-07-20T04:02:24.000Z","updated":"2023-07-17T12:54:27.550Z","comments":true,"path":"2020/07/20/ai-dev-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-3/","excerpt":"","text":"Load Packages 123456import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tf%matplotlib inline 데이터 불러오기 TensorFlow 에서 제공해주는 데이터셋(MNIST) 예제 불러오기다. 12345678from tensorflow.keras import datasetsmnist = datasets.mnist(train_x, train_y), (test_x, test_y) = mnist.load_data()train_x.shape# Out(60000, 28, 28) Image Dataset 들여다보기 불러온 데이터셋에서 이미지 데이터 하나만 뽑아서 시각화한다. 데이터 하나만 뽑기 12345image = train_x[0]image.shape# Out(28, 28) 시각화 하기 12plt.imshow(image, 'gray')plt.show() Channel 관련 [Batch Size, Height, Width, Channel] Gray Scale 이면 1, RGB 이면 3으로 만들어줘야 한다. 데이터 차원수 늘리기(numpy) 123456# -1 인 경우 마지막에 차원을 늘린다는 의미입니다.train_x = np.expand_dims(train_x, -1)train_x.shape# Out(60000, 28, 28, 1) 데이터 차원수 늘리기 (tensorflow) 12345new_train_x = tf.expand_dims(train_x, -1)new_train_x.shape# OutTensorShape([60000, 28, 28, 1]) TensorFlow 공식홈페이지에 나온 방법이다. 12345new_train_x =train_x[..., tf.newaxis]new_train_x.shape# Out(60000, 28, 28, 1) 다시 시각화 하기 주의사항: matplotlib로 이미지 시각화 할 때 gray scale의 이미지는 3번째 dimension이 없으므로, 2개의 dimension으로 차원 조절해서 넣어줘야 한다. 1234567display = new_train_x[0, :, :, 0]ordisplay = np.squeeze(new_train_x[0])display.shape# Out(28, 28) 12plt.imshow(display, 'gray')plt.show() Label Dataset 들여다보기 Label 하나를 열어서 Image와 비교하여 제대로 들어갔는지, 어떤 식으로 저장 되어 있는지 확인한다. Label 하나만 뽑아보기 1234train_y[0]# Out5 Lebel 시각화 하기 123plt.title(train_y[0])plt.imshow(train_x[0], 'gray')plt.show() OneHot Encoding 컴퓨터가 이해할 수 있는 형태로 변환해서 Label을 주도록 한다. 12345678# 1[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]# 5[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]# 9[0, 0, 0, 0, 0, 0, 0, 0, 0, 1] 1을 예시로 one hot encoding 하기 123456from tensorflow.keras.utils import to_categoricalto_categorical(1, 10)# Outarray([0., 1., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) Label 확인해서 to_categorical 사용 12345label = train_y[0]label_onehot = to_categorical(label, num_classes=10)# Outarray([0., 0., 0., 0., 0., 1., 0., 0., 0., 0.], dtype=float32) one hot encoding으로 바꾼 것과 이미지 확인 123plt.title(label_onehot)plt.imshow(train_x[0], 'gray')plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"[Tensorflow 2.0] 기초 사용법","slug":"ai-dev-2","date":"2020-07-20T02:30:15.000Z","updated":"2023-07-17T12:53:41.945Z","comments":true,"path":"2020/07/20/ai-dev-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/20/ai-dev-2/","excerpt":"","text":"Load Packages 12import numpy as npimport tensorflow as tf Tensor 생성 list -&gt; Tensor 1234tf.constant([1, 2, 3])# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; tuple -&gt; Tensor 123456tf.constant(((1, 2, 3), (1, 2, 3)))# Out&lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy=array([[1, 2, 3], [1, 2, 3]])&gt; Array -&gt; Tensor 12345arr = np.array([1, 2, 3])tf.constant(arr)# Out&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3])&gt; Tensor에 담긴 정보 확인 shape 확인 12345tensor = tf.constant(arr)tensor.shape# OutTensorShape([3]) Data Type 확인 주의: Tensor를 생성 할 때 Data Type을 정해주지 않기 때문에 혼동이 올 수 있다. Data Type에 따라 모델의 무게나 성능 차이에 영향을 줄 수 있다. 1234tensor.dtype# Outtf.int32 Data Type 정의 1234tf.constant([1, 2, 3], dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Data Type 변환 1234tf.cast(tensor, dtype=tf.uint8)# Out&lt;tf.Tensor: shape=(3,), dtype=uint8, numpy=array([1, 2, 3], dtype=uint8)&gt; Tensor에서 Numpy 불러오기 1234tensor.numpy()# Outarray([1, 2, 3]) Numpy로 변환된 것 확인 1234type(tensor.numpy())# Outnumpy.ndarray 난수 생성 Numpy에서는 난수 생성 시 기본적으로 Normal Distribution을 생성한다. Normal Distribution은 중심 극한 이론에 의한 연속적인 모양 Uniform Distribution은 중심 극한 이론과는 무관하며 불연속적이며 일정한 분포 Numpy에서 사용법 12345np.random.randn(9)# Outarray([ 0.53020669, 0.65508422, -0.59177912, 1.16459962, -1.05122869, 0.08080872, 0.17245994, 0.08721459, -0.69788519]) TensorFlow에서 사용법 1234567tf.random.normal([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[ 0.46394104, -0.8973731 , -0.1977468 ], [-1.6685097 , -0.8181516 , -1.8963411 ], [ 0.5654544 , 0.13616897, -1.7370273 ]], dtype=float32)&gt; 1234567tf.random.uniform([3, 3])# Out&lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy=array([[0.7996844 , 0.05048668, 0.7060809 ], [0.9390234 , 0.29056323, 0.33341527], [0.4387114 , 0.13688791, 0.12659645]], dtype=float32)&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"}]},{"title":"Tensorflow 2.0과 PyTorch 소개","slug":"ai-dev-1","date":"2020-07-17T10:02:44.000Z","updated":"2023-07-17T12:53:10.927Z","comments":true,"path":"2020/07/17/ai-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-dev-1/","excerpt":"","text":"TensorFlow 2.0 1.x에 비해 정말 쉬워졌다. Numpy Array와 호환이 쉽다. TensorBorad, TFLite, TPU 여전히 많은 사용자들이 사용한다. 상용 목적으로 주로 사용한다. PyTorch Dynamic Graph &amp; Define by Run 쉽고 빠르며 코드가 간결하다. 빠르게 성장하고 있다. 커뮤니티가 많이 활성화 되고 있다. 연구 목적으로 주로 사용한다. 둘 다 때에 따라 환경에 맞게 사용하면 될 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"}]},{"title":"[Python] 시각화 기초(이미지)","slug":"ai-development-6","date":"2020-07-17T09:20:17.000Z","updated":"2024-01-11T08:08:39.221Z","comments":true,"path":"2020/07/17/ai-development-6/","link":"","permalink":"http://hgko1207.github.io/2020/07/17/ai-development-6/","excerpt":"","text":"Load Packages 12345import numpy as npfrom PIL import Imageimport matplotlib.pyplot as plt%matplotlib inline 이미지 불러오기 123456789path = 'images/dog.jpg'image_pil = Image.open(path)image = np.array(image_pil)image.shape# Out(300, 400, 3) 이미지 들여다 보기 1234np.min(image), np.max(image)# Out(0, 255) 그래프로 시각화하기 12plt.hist(image.ravel(), 256, [0, 256])plt.show() 그림 나타내기 12plt.imshow(image)plt.show() 이미지 흑백으로 열기 1234567image_pil = Image.open(path).convert(\"L\")image_bw = np.array(image_pil)image_bw.shape# Out(300, 400) 흑백 이미지 열기 12plt.imshow(image_bw, 'gray')plt.show() 다른 색상으로 cmap 표현하기 gray scale 12plt.imshow(image_bw, 'gray')plt.show() RdBu(Red and Blue) 12plt.imshow(image_bw, 'RdBu')plt.show() jet 색상 값이 높을수록 빨간색, 낮을수록 파란색으로 표현한다. 12plt.imshow(image_bw, 'jet')plt.show() Colorbar 추가하기 123plt.imshow(image_bw, 'jet')plt.colorbar()plt.show() 이미지 설정 이미지 보기 사이즈를 조절한다. 123plt.figure(figsize=(10, 10))plt.imshow(image)plt.show() 이미지에 제목 추가 123plt.title('Dog')plt.imshow(image)plt.show() 두 번째 이미지 열기 1234567cat_path = 'images/cat.jpg'cat_pil = Image.open(cat_path)cat_image = np.array(cat_pil)plt.imshow(cat_image)plt.show() 두 번째 이미지를 첫 번째 이미지 모양에 맞추기 준비 먼저 opencv 패키지를 설치한다. 1$ pip install opencv-python 12345678# Inimport cv2dog_image = cv2.resize(image, (400, 300))dog_image.shape, cat_image.shape# Out((300, 400, 3), (300, 400, 3)) 이미지 합치기 123plt.imshow(dog_image)plt.imshow(cat_image, alpha=0.5)plt.show() Subplot 12345678plt.figure(figsize=(10, 10))plt.subplot(221)plt.imshow(dog_image)plt.subplot(222)plt.imshow(image_bw, 'gray')plt.subplot(223)plt.imshow(cat_image)plt.show()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] 시각화 기초(그래프)","slug":"ai-development-5","date":"2020-07-16T09:08:35.000Z","updated":"2024-01-11T08:08:16.508Z","comments":true,"path":"2020/07/16/ai-development-5/","link":"","permalink":"http://hgko1207.github.io/2020/07/16/ai-development-5/","excerpt":"","text":"Python에서 matplotlib를 사용하여 시각화하는 방법에 대해 알아보겠다. Load Packages 1234import numpy as npimport matplotlib.pyplot as plt%matplotlib inline Basic Attributes 123456789101112131415alpha : 투명도king : 그래프 종류 'line', 'bar', 'barh', 'kde'logy : Y축에 대해 Log scalinguse_index : 객체의 색인을 눈금 이름으로 사용할지 여부rot : 눈금 이름 돌리기 (rotating) 0 ~ 360xticks, yticks : X, Y축으로 사용할 값xlim, ylim : X, Y축의 한계grid : 축의 그리드를 표현할지 여부subplots : 각 column에 독립된 subplot 그리기sharex, sharey : subplots=True 이면 같은 X, Y축을 공유하고 눈금과 한계를 연결figsize : 생성될 그래프의 크기를 tuple로 지정title : 그래프의 제목 지정legend : subplot의 범례 지정sort_columns : column을 알파벳 순서로 그린다. Matplotlib 사용하기 점선 그래프 그리기 123data = np.random.randn(50).cumsum()plt.plot(data)plt.show() 여러 그래프 그릴 준비 하기 123plt.subplot(1, 2, 1)plt.subplot(1, 2, 2)plt.show() Multi Graph 그리기 12345678910111213hist_data = np.random.randn(100)scat_data = np.arange(30)plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 옵션 그래프를 그릴 때 표시 되는 색이나 마커 패턴을 바꾸는 것을 확인한다. 색상: r(빨간색), g(초록색), b(파란색), C(청록색), y(노란색), k(검은색), w(흰색) 마커: o(원), v(역삼각형), ^(삼각형), s(네모), +(플러스), .(점) 12plt.plot(data, 'go')plt.show() 그래프 사이즈 조절 plt.figure 안에 figsize를 이용하여 가로, 세로 길이 조절 가능하다. (inch 단위) 123plt.figure(figsize=(10, 10))plt.plot(data, 'k+')plt.show() 여러 그래프 그리고 그에 대한 크기 조절을 한다. 12345678910111213# 맨 위에 있어야 한다.plt.figure(figsize=(10, 5))plt.subplot(2, 2, 1)plt.plot(data)plt.subplot(2, 2, 2)plt.hist(hist_data, bins=20)plt.subplot(2, 2, 3)plt.scatter(scat_data, np.arange(30) + 3 * np.random.randn(30))plt.show() 그래프 겹치기와 legend 표시 123456data = np.random.randn(30).cumsum()plt.plot(data, 'k--', label='Default')plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')plt.legend()plt.show() 이름 달기 12345plt.plot(np.random.randn(1000).cumsum())plt.title('Random Graph')plt.xlabel('Stages')plt.ylabel('Values')plt.show() 종합 1234567plt.title('Graph')plt.plot(np.random.randn(500).cumsum(), 'k^', label='one')plt.plot(np.random.randn(500).cumsum(), 'b.', label='two')plt.plot(np.random.randn(500).cumsum(), 'r', label='three')plt.legend()plt.show() 그래프 저장하기 12# 현재 작업 위치로 저장한다.plt.savefig('saved_graph.svg')","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"}]},{"title":"[Python] Numpy 기초(3)","slug":"ai-development-4","date":"2020-07-09T07:16:50.000Z","updated":"2024-01-11T08:07:54.347Z","comments":true,"path":"2020/07/09/ai-development-4/","link":"","permalink":"http://hgko1207.github.io/2020/07/09/ai-development-4/","excerpt":"","text":"zeros 0으로 채워진 numpy 배열을 만든다. 123456np.zeros([3, 3])# Outarray([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) ones 1로 채워진 numpy 배열을 만든다. 123456np.ones([3, 3])# Outarray([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) arange 하나의 값만 입력하면 1씩 증가하는 1차원 배열을 만든다. 1234np.arange(10)# Outarray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 두 개의 인자를 넣으면 입력한 값의 범위만큼 배열을 만든다. 1234np.arange(4, 9)# Outarray([4, 5, 6, 7, 8]) reshape 1차원 배열의 차원 수를 바꿀 때 사용된다. 123456np.arange(9).reshape(3, 3)# Outarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) Index 기본적으로 python 에서 쓰는 방식과 동일하다. 12345arr = np.arange(9).reshape(3, 3)arr[1]# Outarray([3, 4, 5]) Slicing 다차원 배열의 원소 중 복수 개를 접근하기 위해 사용한다. 123456arr = np.arange(9).reshape(3, 3)arr[1:]# Outarray([[3, 4, 5], [6, 7, 8]]) 12345arr[1:, 1:]# Outarray([[4, 5], [7, 8]]) Boolean Indexing 원하는 행 또는 열의 값만 얻을 수 있고, 값들을 변경할 수 있다. 1234567891011data = np.random.randn(3, 3)data &lt;= 0# Outarray([[-0.43152818, -2.40848595, -0.00309727], [ 0.74972847, 0.18525482, -0.39854904], [ 1.09053126, 0.32096086, 0.31703319]])array([[ True, True, True], [False, False, True], [False, False, False]]) 1234data[data &lt;= 0]# Outarray([-0.43152818, -2.40848595, -0.00309727, -0.39854904]) 123456data[data &lt;= 0] = 1# Outarray([[1. , 1. , 1. ], [0.74972847, 0.18525482, 1. ], [1.09053126, 0.32096086, 0.31703319]]) Broadcast 연산하려는 서로 다른 두 개의 행렬의 shape가 같지 않고, 한쪽의 차원이라도 같거나 또는 값의 개수가 한 개 일 때 이를 여러 복사를 하여 연산한다. 1234567arr = np.arange(9).reshape(3, 3)arr + 3# Outarray([[ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) 123456arr * 3# Outarray([[ 0, 3, 6], [ 9, 12, 15], [18, 21, 24]]) 123456arr + np.array([1, 2, 3])# Outarray([[ 1, 3, 5], [ 4, 6, 8], [ 7, 9, 11]]) Math Function 배열 연산에 대해 여러 가지 예제다. 123456arr + 5arr * 5arr + arrnp.add(arr, 1)np.multiply(arr, 3) 12345678910np.sum(arr)np.sum(arr + arr_2)np.sum(arr, 0) # 0차원 기준으로 더해서 배열을 만든다.np.max(arr)np.max(arr, 0) # 0차원에서 가장 큰 값들을 배열로 만든다.np.min(arr)np.mean(arr) 12345678910arr = np.array([1, 6, 3, 7, 3, 2, 9, 0, 2])np.argmax(arr) # 가장 큰 수의 index값을 리턴한다.# Out6np.argmin(arr)# Out7 12345arr = np.array([3, 5, 6, 6, 3, 3, 1])np.unique(arr) # 유니크한 값들을 리턴한다.# Outarray([1, 3, 5, 6])","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(2)","slug":"ai-development-3","date":"2020-07-02T01:36:18.000Z","updated":"2024-01-11T08:06:52.087Z","comments":true,"path":"2020/07/02/ai-development-3/","link":"","permalink":"http://hgko1207.github.io/2020/07/02/ai-development-3/","excerpt":"","text":"Numpy 기초에 대해 다뤄보겠다. Load Package 1import numpy as np data type 배열의 dtype을 봅니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3]])arr.dtype# Outdtype('int32') .astype() 으로 datatype을 변환 가능하다. 123456arr = arr.astype('float32')arr = arr.astype(np.float32)# Outarray([[1., 2., 3.], [1., 2., 3.]], dtype=float32) len(arr.shape)를 통해서 차원이 개수를 확인할 수 있지만, 다음과 같이 ndim 을 통해 차원 수를 확인하다. 12345len(arr.shape)arr.ndim# Out2 Reshape 차원을 바꾼다. 12345arr = arr.reshape([1, 6])arr.shape# Out(1, 6) 차원을 몇 개로 나눠야할지 모를 경우 -1을 활용하다. 12345arr = arr.reshape(-1)arr.shape# Out(6,) 3차원으로 늘리는 방법이다. 123456arr = np.random.randn(8, 8) # (8, 8)arr = arr.reshape([32, 2]) # (32, 2)arr = arr.reshape([-1, 2, 1])# Out(32, 2, 1) Ravel 배열을 1차원으로 바꿔준다. 나중에 배열 layer를 flatten 할 때 같은 기능이라 생각하면 된다. 12345arr = arr.ravel()arr.shape# Out(64,) np.expand_dims() 안의 값은 유지하되 차원 수를 늘리고 싶을 때 사용한다. 12345arr = np.expand_dims(arr, 0)arr.shape# Out(1, 64)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"[Python] Numpy 기초(1)","slug":"ai-development-2","date":"2020-07-01T08:11:52.000Z","updated":"2024-01-11T08:06:05.488Z","comments":true,"path":"2020/07/01/ai-development-2/","link":"","permalink":"http://hgko1207.github.io/2020/07/01/ai-development-2/","excerpt":"","text":"Numpy 란 Numpy는 C언어로 구현된 파이썬 라이브러리로써, 고성능의 수치계산을 위해 제작되었습니다. Numerical Python의 줄임말이기도 한 Numpy는 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공합니다. 출처: Tigercow.Door Numpy는 고차원적인 데이터를 다루기 쉽게 만들어져 있어 딥러닝을 하게 되면 많이 접하게 됩니다. 이제 Numpy 사용방법에 대해 알아보겠습니다. 12# Numpy 사용하기import numpy as np 0차원 numpy array는 1 또는 5, 10와 같이 숫자 데이터를 array화 해줄 수 있습니다. 12345arr = np.array(5);arr.shape # 배열의 형태(크기)를 나타냅니다.# Out() # shape가 아무것도 없는 것으로 나옵니다. 1234arr.ndim # 배열의 차원을 나타냅니다.# Out0 # 0차원을 의미합니다. 1차원 숫자가 10과 같이 하나만 들어간다고 해도 [] 리스트를 한번 씌우게 되면 차원이 생깁니다. 이때는 1차원이 되는데 numpy에서 shape를 표현할 때 (1)이 아닌 (1,) 형식으로 표현하게 됩니다. 12345arr = np.array([5])arr.shape# Out(1,) (3,)에서 3은 3이라는 값이 들어간 것이 아닌 1차원에 3개의 값이 들어갔다는 의미입니다. 2차원 대괄호를 추가적으로 씌우면 차원이 추가적으로 하나 생깁니다. 12345arr = np.array([[1, 2, 3]])arr.shape# Out(1, 3) 다음의 shape를 보면 차원이 2개 있고, 각 차원마다 각각 3개의 값이 들어있다는 의미입니다. 12345arr = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])arr.shape# Out(3, 3) 참고로 0차원 숫자에 대괄호를 2번 씌우면 두 개의 차원이 됩니다. 12345arr = np.array([[10]])arr.shape# Out(1, 1) 다차원 12345678910111213141516171819arr = np.array([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]])# Outarray([[[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]], [[[1, 2, 3], [1, 2, 3], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], [1, 2, 3]]]]) 4차원의 배열을 나타냅니다. 1234arr.shape# Out(2, 2, 3, 3)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"}]},{"title":"인공지능 개발준비 - 개발환경 구축(Windows)","slug":"ai-development-1","date":"2020-06-30T02:34:28.000Z","updated":"2024-01-11T08:04:51.172Z","comments":true,"path":"2020/06/30/ai-development-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/ai-development-1/","excerpt":"","text":"인공지능(AI)을 통해 개발을 하기 위해 개발 도구들을 설치합니다. 1. Anaconda 설치 Anaconda는 여러 가지 수학 및 과학 패키지들을 기본적으로 포함하고 있는 Python 배포판입니다. 그래서 머신러닝, 딥러닝, 데이터 분석에서 사용을 하려고 한다면 Anaconda를 통해 설치하는 것이 좋습니다. Anaconda Download 사이트에 접속하여 아래로 내려가 보면 다운로드 화면이 보입니다. 현재 Windows 운영체제에 맞게 선택하여 다운로드를 합니다. 다운로드가 완료되면 설치를 진행합니다. Next 버튼을 클릭하다가 아래 그림처럼 All Users를 선택합니다. 간혹 Windows에서 사용자의 계정을 한글로 만들었을 경우 설치할 때 또는 개발할 때 에러가 날 수 있기 때문에 선택합니다. 아래 그림처럼 체크박스도 선택을 하여 환경변수 설정이 되도록 합니다. Install 버튼을 클릭하면 설치가 됩니다. 설치가 잘 되었나 확인하려면 workspace 폴더에서 커맨드 창을 열고 다음 명령어를 실행합니다. 1$ c:\\workspace&gt; jupyter notebook Jupyter Notebook 페이지가 실행되고 Python 코드를 작성할 수 있습니다. 2. TensorFlow 설치 TensorFlow는 머신러닝을 위한 엔드 투 엔드 오픈소스 플랫폼입니다. 도구, 라이브러리, 커뮤니티 리소스로 구성된 포괄적이고 유연한 생태계를 통해 연구원들은 ML에서 첨단 기술을 구현할 수 있고 개발자들은 ML이 접목된 애플리케이션을 손쉽게 빌드 및 배포할 수 있습니다. 출처 : https://www.tensorflow.org/?hl=ko TensorFlow 2 설치 사이트에 접속합니다. 설치 가이드에 따라 설치를 합니다. 1$ pip install tensorflow 설치가 완료되면 Jupyter Notebook에서 import를 하여 확인합니다. 3. Pytorch 설치 PyTorch는 Python을 위한 오픈소스 머신 러닝 라이브러리입니다. Torch를 기반으로 하며, 자연어 처리와 같은 애플리케이션을 위해 사용됩니다. 출처 : 위키백과 Pytorch 사이트에 접속합니다. 아래로 내려가 보면 여러가지 설정을 하여 설치하는 방법을 안내해줍니다. Windows 버전이기 때문에 아래 그림 처럼 설정을 합니다. 만약에 GPU를 사용할 수 있으면 CUDA 버전에 맞게 설정하면 됩니다. 설정이 완료되었으면 Run this Command 칸의 내용을 복사하여 Command 창에 붙여넣기 하고 실행을 합니다. TensorFlow와 마찬가지로 Jupyter Notebook에서 import를 하여 설치가 완료되었는지 확인합니다. AI 개발 준비가 모두 완료 되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"}]},{"title":"[C++] string을 이용한 File Path 분리 방법","slug":"cpp-coding-1","date":"2020-06-30T02:05:16.000Z","updated":"2024-01-11T08:05:22.961Z","comments":true,"path":"2020/06/30/cpp-coding-1/","link":"","permalink":"http://hgko1207.github.io/2020/06/30/cpp-coding-1/","excerpt":"","text":"개요 string 형식의 파일 경로를 이용하여 File Path와 Name을 분리합니다. 1) File Path와 File Name 분리 1234567891011121314#include &lt;iostream&gt;namespace using std;int main()&#123; string pullPath = \"c:\\\\test\\\\test.tif\"; int find = pullPath.rfind(\"\\\\\") + 1; string filePath = pullPath.substr(0, find); string fileName = pullPath.substr(find, pullPath.length() - find); cout &lt;&lt; \"Folder Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"File Name : \" &lt;&lt; fileName &lt;&lt; endl;&#125; 결과 12Folder Path : c:\\\\testFile Name : test.tif 2) 파일 확장자 바꾸기 123456789101112131415161718#include &lt;iostream&gt;namespace using std;int main()&#123; string filePath = \"c:\\\\test\\\\test.tif\"; string modExt = \"ntf\"; int ext = filePath.rfind(\"tif\"); int name = filePath.rfind(\"\\\\\") + 1; string dstPath = filePath.substr(0, name); dstPath += filePath.substr(name, ext - name); dstPath += modExt; cout &lt;&lt; \"Input Path : \" &lt;&lt; filePath &lt;&lt; endl; cout &lt;&lt; \"Output Path : \" &lt;&lt; dstPath &lt;&lt; endl;&#125; 결과 12Input Path : c:\\\\test\\\\test.tifOutput Path : c:\\\\test\\\\test.ntf","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"Hexo Quick Start","slug":"hello-world","date":"2020-06-29T06:30:00.000Z","updated":"2022-12-30T01:18:40.221Z","comments":true,"path":"2020/06/29/hello-world/","link":"","permalink":"http://hgko1207.github.io/2020/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[Git] 이클립스에서 Git Repository 연동","slug":"eclipse-git-clone","date":"2020-05-18T01:48:33.000Z","updated":"2024-01-11T07:09:32.719Z","comments":true,"path":"2020/05/18/eclipse-git-clone/","link":"","permalink":"http://hgko1207.github.io/2020/05/18/eclipse-git-clone/","excerpt":"","text":"이클립스와 Git 원격저장소 연동하는 방법과 프로젝트를 내려받는 방법에 대해 알아보도록 하겠습니다. 1. 원격저장소 주소 복사 먼저 github 사이트에서 생성한 저장소의 주소를 복사합니다. 2. 이클립스 실행 이클립스를 실행하고 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보입니다. Git을 선택하고 [OK] 버튼을 눌러 활성화시킵니다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경됩니다. 3. 원격저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭합니다. Clone Git Repository 창의 첫 번째 빨간 박스에 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력됩니다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭합니다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭합니다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭합니다. 원격저장소가 연동되면 아래 그림과 같이 프로젝트를 확인할 수 있습니다. 4. 프로젝트 내려받기 연동된 원격저장소에서 Working Tree -&gt; 프로젝트 선택 -&gt; 우클릭 -&gt; Import Projects 선택을 합니다. Import Projects 창에서 내려받아지는 경로를 확인 후 [Finish] 버튼을 클릭합니다. 내려받기가 완료되면 프로젝트가 생성됩니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"}]},{"title":"Hyperspectral(초분광) 센서","slug":"satellite-hyperspectral","date":"2020-05-11T01:17:10.000Z","updated":"2023-07-13T03:27:46.618Z","comments":true,"path":"2020/05/11/satellite-hyperspectral/","link":"","permalink":"http://hgko1207.github.io/2020/05/11/satellite-hyperspectral/","excerpt":"","text":"Hyperspectral 특징 초분광 영상의 픽셀 분광은 하나의 표면에 대한 다중분광픽셀 스펙트럼에서 이용할 수 있는 것보다 훨씬 많은 정보 제공 가능하다. Hyperspectral 원격탐사 특징 입사되는 빛을 분광시켜 영상의 각 화소에 해당하는 지표물의 수십에서 수백 개의 분광 정보를 취득하고 그 개체의 정보를 이미지 형태로 확보 가능 물질 고유의 광학적 성질과 물질의 흡수 및 반사 특징을 분석함으로써 토지피복, 식생, 그리고 수질 등의 식별에 주로 이용된다. 스펙트럼 영상은 두 개의 공간적 차원과 하나의 스펙트럼 크기로 구성된 3차원 (x, y, λ)으로 나타남(x, y : 공간적 2차원 / λ : 스펙트럼 크기) 2차원 (2-D) 검출기에서 각 화소에 스펙트럼 정보를 수집하여 초분광 큐브로 알려진 공간 및 스펙트럼 정보인 3차원(3-D) 데이터를 형성 Hyperspectral 활용 위성 Terra/Aqua(MODIS) STSat-3(COMIS) NMP-EO-1(Hyperion) NMP-EO-1(Hyperion)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"}]},{"title":"[MySQL] Query 정리","slug":"mysql-query","date":"2020-05-07T02:17:14.000Z","updated":"2024-01-11T07:08:12.345Z","comments":true,"path":"2020/05/07/mysql-query/","link":"","permalink":"http://hgko1207.github.io/2020/05/07/mysql-query/","excerpt":"","text":"SELECT 123SELECT * FROM 테이블명SELECT * FROM 테이블명 WHERE 조건SELECT 필드명1, 필드명2, ... FROM 테이블명 WHERE 조건 INSERT 123INSERT INTO 테이블명(필드명1, 필드명2, 필드명3, ...) VALUES (데이터값1, 데이터값2, 데이터값3, ...)또는INSERT INTO 테이블명 VALUES (데이터값1, 데이터값2, 데이터값3, ...) UPDATE 1UPDATE 테이블명 SET 필드명1=데이터값1, 필드명2=데이터값2, ... WHERE 필드명=데이터값 DELETE 1DELETE FROM 테이블명 WHERE 필드명=데이터값 중복 데이터 조회 중복된 것 모두 조회 1SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 중복된 개수가 n개 이상인 것 12345SELECT 필드명, count(*) as 변수명 FROM 테이블명 GROUP BY 필드명 HAVING 변수명 &gt; n;또는SELECT 필드명, count(*) FROM 테이블명 GROUP BY 필드명 HAVING count(*) &gt; n;SELECT 필드명, count(*) as 변수명 FROM 테이블명 WHERE 조건 GROUP BY 필드명 HAVING 변수명 &gt; n; 중복 데이터 추출(WHERE 절의 IN 사용) 123SELECT * FROM 테이블명 WHERE column1 IN ( SELECT column1 FROM 테이블명 WHERE 조건 GROUP BY column1 HAVING count(*) &gt; 1) AUTO_INCREMENT 초기화 1ALTER TABLE 테이블명 AUTO_INCREMENT = 시작할 값; 날짜 12SELECT * FROM 테이블명 WHERE 필드명 &gt;= 시작날짜SELECT * FROM 테이블명 WHERE 필드명 BETWEEN 시작날짜 and 종료날짜","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"}]},{"title":"Clean Code","slug":"book-cleancode","date":"2020-04-28T00:50:27.000Z","updated":"2024-01-11T07:07:47.404Z","comments":true,"path":"2020/04/28/book-cleancode/","link":"","permalink":"http://hgko1207.github.io/2020/04/28/book-cleancode/","excerpt":"","text":"책 정보 책 소개 애자일 소프트웨어의 혁명적인 패러다임을 제시하는 책이다. 저자 로버트 마틴은 오브젝트 멘토(Object Mentor)의 동료들과 힘을 모아 ‘개발하며’ 클린 코드를 만드는 최상의 애자일 기법을 정제하여『Clean Code 클린 코드』에 담았다. 아주 많은 코드를 읽고 그 코드의 무엇이 옳은지, 그른지 생각하며 전문가로서 자신이 지니는 가치를 돌아보기 위해 꾸준히 노력한다면, 이 책을 통해 여러분의 프로그래밍 실력은 한층 더 높아질 것이다. 리뷰 전부 다 읽어보진 못하였지만 읽다 보면 얼마나 잘못하고 있었는지 반성하게 됩니다. 의미 있는 이름, 좋은 주석 다는 법, 객체와 자료 구조 등 어떻게 깨끗하고 아름다운 코드를 작성할 수 있는지 알려줍니다. 잘못된 점과 좋은 점을 짚어주기 때문에 내가 짰던 코드와 비교할 수 있고 17장에는 사례 연구를 만들면서 수집한 휴리스틱과 냄새를 열거합니다. 협업을 할 때 필요한 내용들이며, 지금은 중간 개발자로서 신입 개발자를 교육할 때에도 정말 좋은 추천서라고 느껴집니다. 책 내용이 많고 글자 수도 많아서 끈기 있게 읽어야 할 것 같습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"}]},{"title":"Microwave(극초단파) 센서","slug":"satellite-microwave","date":"2020-04-27T00:42:37.000Z","updated":"2023-07-13T03:27:04.724Z","comments":true,"path":"2020/04/27/satellite-microwave/","link":"","permalink":"http://hgko1207.github.io/2020/04/27/satellite-microwave/","excerpt":"","text":"Microwave 특징 물체들이 방출하는 마이크로웨이브 파를 위성에서 감지하여 원격탐사에 활용하는 기술이다. 마이크로파의 파장 영역은 보통 1mm ~ 1m 이다. 자연방사 에너지를 관측하는지, 위성에서 Microwave를 쏘아서 되돌아오는 신호를 관측하는지에 따라 Passive microwave와 Active microwave로 나눌 수 있다. 대표적으로 SAR, 산란계, 고도계, 복사계로 나눠진다. Microwave 원격탐사 특징 1. Passive vs Active 2. 센서 특징 Microwave 활용 위성 GCOM-W1(AMSR-2) SMAP(SMAP) NOAA, AQUA, Metop(AMSU-A) GPM(GMI, GPM Microwave Imager)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"}]},{"title":"IR(적외선) 센서","slug":"satellite-ir-sensor","date":"2020-04-24T00:50:14.000Z","updated":"2023-07-13T03:26:42.946Z","comments":true,"path":"2020/04/24/satellite-ir-sensor/","link":"","permalink":"http://hgko1207.github.io/2020/04/24/satellite-ir-sensor/","excerpt":"","text":"IR(Infrared) 정의 가시광선대의 적색 끝부분에서부터 마이크로파전까지의 전자기파, 가시광선이나 자외선에 비해 강한 열작용을 가지고 있다. 파장 대역 : 0.7-1000㎛ 활용 분야 : 소독/멸균, 외과수술 및 종양 제거, 군사적(야간 투시경), 야간 촬영용 카메라 IR 특징 태양빛을 프리즘을 이용하여 스펙트럼으로 분산시킬 때 붉은색보다 더 바깥쪽에 위치함 열을 가지는 모든 물체에서 방출 또는 반사되는 특징이 있기 때문에 강한 열작용을 가짐(열선이라고도 불림) 파장에 따라 지구 대기를 투과하지 못하는 특성이 있어 대기 환경에 민감 IR 원격탐사의 특징 장파장으로 갈수록 물체 고유의 특성이 잘 관측될 수 있음 야간이나 해무(바다 안개), 옅은 구름이 낀 상황에서도 촬영 가능 해양 및 구름의 온도를 측정하여 지구의 열 balance를 측정하고, 해수표면으로부터 방사되어 나오는 원적외선을 감지함 인접한 물체간의 열적 특성 차이나 잠열 분석이 가능한 정보 제공(공간 분해능 + 열적 분해능) 센서의 발달과 더불어 온도 해상도는 1K에서 0.3K 정도로 높아짐 공간 해상도 역시 250m의 해상도를 갖는 것이 개발됨에 따라 large scale에서 small scale의 연구가 가능해짐 IR 활용 위성 Terra(ASTER) Terra/Aqua(MODIS) Landsat-7(ETM+)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"}]},{"title":"[Android Studio] 설치 및 주요 기능 정리","slug":"android-studio","date":"2020-04-21T00:49:50.000Z","updated":"2024-01-11T07:06:07.264Z","comments":true,"path":"2020/04/21/android-studio/","link":"","permalink":"http://hgko1207.github.io/2020/04/21/android-studio/","excerpt":"","text":"1. Android Studio 다운로드 및 설치 다운로드 사이트에서 최신 버전의 Android Studio를 다운로드하여 설치합니다. 현재 최신은 3.6.3 버전이다. 설치를 완료하고 다음 화면이 오픈되면 이제 개발을 시작할 수 있다. 2. 프로젝트 생성 Start a new Android Studio Project 선택 Slelect a Project Templat Empty Activity 선택 Configure Your Project Name: HelloApp Package: com.hgko.helloapp Language: Java or Kotlin Minimum SDK: API 26: Android 8.0(Oreo) Finish 버튼 클릭하면 다음과 같이 프로젝트가 생성된다. 3. 실행 1) 스마트폰 연결 시 스마트폰에서 USB 디버깅 설정 설정 &gt; 빌드 번호 6번 터치 -&gt; 개발자 옵션 화성화(메뉴가 보임) &gt; USB 디버깅 활성화 선택 스마트폰 케이블 연결 logcat에서 디바이스 연결 확인 2) 가상 디바이스 사용 시 Tools &gt; AVD Manager Create Virtual Device… 클릭 Select Hardware 적당한 디바이스를 선택한다. 예) Phone &gt; Pixel XL System Image Android 버전을 선택 Finish 버튼 클릭 스마트폰 또는 가상 디바이스를 연결 후 상단 툴바에서 장비를 선택 후 Run을 클릭하면 컴파일이 되며, 앱이 설치되고 구동된다. 4. SDK 설치 Tools &gt; SDK Manager 에서 설치 현황 및 안드로이드 버젼 별 SDK 설치/삭제/업데이트 등을 수행할 수 있다. 5. Device File Explorer 연결된 장비(스마트폰 or 가상 디바이스)의 파일 시스템을 탐색하는 뷰를 제공한다. View &gt; Tool Windows &gt; Device File Explorer 메뉴를 클릭하여 다음과 같이 Device File Explorer 뷰를 오픈한다. 디바이스 파일 중에 특히 다음과 같은 경로들이 유용하다. 1) data/data/app_name/ 내부 저장소에 저장괸 입의 데이터 파일 경로 2) sdcard/ 외부 사용자 SD 카드에 저장된 파일(사진 등) 경로 6. 주요 단축키 참고 : Android 스튜디오 단축키 설명 단축키 기본 코드 완성 Ctrl+Space 스마트 코드 완성 Ctrl+Shift+Enter, Ctrl+Enter 자동 Import Alt+Enter 주석 Ctrl+/ 블록 주석 Ctrl+Shift+/ 빌드 Ctrl+F9 복사 F5 코드 서식 자동 지정 Ctrl+Alt+L 자동 들여 쓰기 Ctrl+Alt+I 7. 자동 import 설정 Alt + Enter를 입력하지 않아도 클래스 사용시 자동으로 import 문을 추가해 주는 기능이다. File &gt; Settings &gt; Editor &gt; General &gt; Auto Import 에서 다음과 같이 “Add unambiguous…” 와 “Optimize imports…” 를 체크한다. 8. 새로운 개념/기능 1) ART VM 안드로이드는 이전 가지는 DVT에서 구동되었으나 현재는 ART라는 VM을 이용한다. ART는 JIT(Just In Time, 실행 시 컴파일 방식으로 2.2 버젼부터 지원)을 지원하는 VM들과 달리 앱이 설치 시 전체 바이트 코드가 기계어로 컴파일되는 AOT(Ahead Of Time)를 이용하므로 획기적으로 성능이 개선되었다. 2) App Bundle 안드로이드 앱 내보내기에 기존 APK 파일 외에 앱 번들이 추가되었다. Google Play의 새로운 앱 제공 모델인 Dynamic Delivery는 App Bundle을 사용하여 각 사용자의 기기 설정에 최적화된 APK를 생성하고 제공하므로, 사용자는 앱 실행에 필요한 최소한의 코드와 리소스만 다운로드하면 된다. 개발자가 더 이상 다양한 기기를 지원하기 위해 여러 개의 APK를 빌드하고 서명하고 관리할 필요가 없으며 사용자는 더 작고 최적화된 앱을 다운로드할 수 있다. 또한 앱 프로젝트에 동적 기능 모듈을 추가하여 App Bundle에 포함할 수 있다. 모듈의 일부 기능과 자원(동영상, 이미지 등)들은 사용자가 처음 앱을 다운로드하고 설치할 때 포함되지 않도록 할 수 있다. 나중에 앱에서 Play Core 라이브러리를 사용하여 이러한 모듈을 동적 기능 APK로 다운로드하도록 요청할 수 있다. 정리하면 App Bundle로 내보내기를 추천한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"}]},{"title":"[JavaScript] IE에서 작동하지 않는 BLOB 다운로드","slug":"javascript-blob","date":"2020-04-20T00:56:01.000Z","updated":"2023-07-13T03:24:54.579Z","comments":true,"path":"2020/04/20/javascript-blob/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/javascript-blob/","excerpt":"","text":"이미지를 Jcrop 라이브러리를 사용하여 자르고 Canvas 영역을 blob 형식으로 바꿔서 a Tag 를 생성하여 다운로드를 시도하였다. 크롬에서는 잘 동작하였지만 IE 에서는 동작하지 않고 에러를 발생하였다. 아래 코드처럼 작성하였더니 둘 다 동작하였다. 소스 코드 12345678910111213function downloadURI(blob, name) &#123; if (window.navigator &amp;&amp; window.navigator.msSaveOrOpenBlob) &#123; // IE에서 동작 window.navigator.msSaveBlob(blob, name); &#125; else &#123; // 크롬에서 동작 var link = document.createElement('a'); link.download = name; link.href = URL.createObjectURL(blob); link.click(); delete link; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"}]},{"title":"SAR 위성 활용","slug":"satellite-sar","date":"2020-04-20T00:31:30.000Z","updated":"2022-09-02T14:49:52.079Z","comments":true,"path":"2020/04/20/satellite-sar/","link":"","permalink":"http://hgko1207.github.io/2020/04/20/satellite-sar/","excerpt":"","text":"SAR 위성 소개 SAR 위성이란? SAR(Synthetic Aperture Radar)란 각 Band의 다양한 파장대의 신호를 이용 지표면의 특성을 영상화 함 BANS 별 소개 SAR(파장 and 편파) 1. KOMPSAT-5(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. TerraSAR-X(독일의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. ALOS-2(일본의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 4. RADARSAT-2(캐나다의 위성) 위성의 본체 및 탑재체 제원 촬영모드 활용 분야 별 촬영 모드(개념도) 활용 분야 별 촬영 모드(지상) 활용 분야 별 촬영 모드(해양)","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"}]},{"title":"[Android Studio] lombok 사용 방법","slug":"android-lombok","date":"2020-04-18T11:14:23.000Z","updated":"2024-01-11T07:04:44.560Z","comments":true,"path":"2020/04/18/android-lombok/","link":"","permalink":"http://hgko1207.github.io/2020/04/18/android-lombok/","excerpt":"","text":"자바에서 코드를 작성 시 모델을 만들다 보면 constructor와 기본 getter/setter 그리고 상황에 따라서 builder를 만들어 사용해야 합니다. 그런데 이런 일들을 모두 타이핑 하다 보니 보일러플레이트 같은 코드들이 많이도 써야 합니다. lombok를 사용하면 모델 객체들의 불필요한 보일러플레이트 코드들을 줄일 수 있습니다. annotation 방법으로 사용하기 때문에 사용 방법도 간단합니다. lombok annotation @Getter / @Setter 기본적으로 멤버 필드들에 대한 getter/setter 메소드들을 만들어 줍니다. @AllArgsConstructor / @NoArgsConstructor 멤버필드들이 모두 파라미터로 지정된 생성자와 빈 생성자를 만들어 줍니다. @Builder 모델을 빌더 패턴으로 만들어 줍니다. @ToString toString의 override된 메소드를 만들어 줍니다. @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 합쳐 둔 어노테이션입니다. @EqualsAndHashCode 해당 객체의 equals()와 hashCode() 메소드를 생성합니다. 그 외에도 여러가지가 있습니다. 그럼 AndroidStudio 에 적용하는 방법을 알아봅니다. 적용 방법 우선 lombok plugin을 설치해야 합니다. File -&gt; Settings -&gt; Plugins -&gt; Browse repositories lombok을 검색하여 Lombok Plugin을 설치합니다. gradle에 lombok 적용하기 Gradle Scripts -&gt; build.gradle 파일을 엽니다. dependencies 아래에 추가해줍니다. 12compileOnly 'org.projectlombok:lombok:1.18.12'annotationProcessor 'org.projectlombok:lombok:1.18.12' 이와 같은 과정 후에 다음과 같은 결과를 볼 수 있습니다. 결과","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"}]},{"title":"광학 위성 활용","slug":"satellite-optical","date":"2020-04-17T04:04:26.000Z","updated":"2023-12-01T06:14:00.818Z","comments":true,"path":"2020/04/17/satellite-optical/","link":"","permalink":"http://hgko1207.github.io/2020/04/17/satellite-optical/","excerpt":"","text":"위성영상 활용 목적 원격탐사 : 기록장치에 의해 물리적인 접속이 없이 관심 대상이 되는 목표물이나 현상에 대한 정보를 획득하는 방법 원격 : 관찰자와 관찰 대상이 분리되어 간격이 있는 것 탐사 : 감지하거나 특징을 지음 = 원거리에서 관찰 대상을 감지하거나 특징을 찾는 것 광학 위성 소개 고성능 광학 카메라를 탑재한 지구 관측 위성 해상도 : 위성의 해상도는 10m 급에서 0.4m 에 이르기까지 다양함 저해상도 활용 : 주로 광범위한 지역의 탐사나 지속적 관찰이 필요한 부분에 사용 고해상도 활용 : 고해상도로 갈수록 군사용이나 특수목적으로 사용 촬영 방식 : 전자광학카메라를 이용한 촬영(광학 신호를 전자신호로 변환하여 영상을 제공하는 방식) 장점 : 눈에 익숙한 영상이 촬영 됨 단점 : 촬영 지역에 구름이 심하게 끼거나 밤이 되면 사진을 찍지 못함 1. KOMPSAT-3(한국의 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 2. World View-3(미국의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야 3. SkySat-2(미국의 상용 위성 + Google) 위성의 본체 및 탑재체 제원 배포자료 활용 분야 4. STOP-7(프랑스의 상용 위성) 위성의 본체 및 탑재체 제원 촬영모드 및 배포자료 활용 분야","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"}]},{"title":"리팩토링","slug":"book-refactoring","date":"2020-04-16T04:43:08.000Z","updated":"2024-01-11T06:59:39.571Z","comments":true,"path":"2020/04/16/book-refactoring/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/book-refactoring/","excerpt":"","text":"책 정보 책 소개 코드 품질을 개선하는 객체지향 사고법을 정리한 참고서 프로그램이 돌아가기면 하면 객체지향인가? 객체지향이라는 도구를 제대로 활용하지 못하고 마구잡이로 작성한 코드에는 악취가 진동한다. 리팩토링은 코드의 동작이나 의도는 유지하면서 코드의 구조, 재사용성, 가독성을 개선해 코드의 악취를 제거하고 전체 디자인을 개선하는 방법이다. 독자는 72가지 리팩토링 기법을 통해 코드를 점진적으로 개선하는 방법을 학습할 수 있으며, 이 책을 마쳤을 때는 객체지향 프로그래밍 능력이 한 단계 향상될 것이다. 객체지향 언어의 문법을 익혔다고 저절로 객체지향 프로그래밍을 할 수 있는 게 아니다. 리팩토링 카탈로그를 통해 어떤 코드를 고쳐야 하는지, 왜 고쳐야 하는지, 고친 코드가 왜 좋은지 이해할 수 있다. 이런 과정을 통해 객체지향에 어울리는 코드 디자인을 배우게 되고, 자신의 코딩 스타일도 바뀌게 된다. 이 책을 읽기 전과 후는 코드의 품질에 결정적인 차이를 가져오게 된다. 리뷰 3년 차 개발을 하던 중 팀장님에게 추천받았던 책입니다. 여러 가지 프로젝트를 개발하면서 고민했던 부분이 개발을 하고 있을 때 또는 유지보수 시 코드를 다시 보게 되면 너무 지저분해 보이고 가독성도 떨어지며 수정 작업이 오래 걸리는 것을 느끼게 되었습니다. 그래서 중복 코드를 제거하고 코딩 규칙을 검색하면서 개선해 보려고 노력을 하였지만 지식이 없어 힘들었습니다. 이 책을 읽으면서 리팩토링에 대해 알게 되고 필요성을 더욱 느끼게 되고 개발자로서 조금 더 성장할 수 있는 계기가 된 것 같습니다. 다만 번역서이기도 하고 글이 많아 읽기가 힘든 부분이 있습니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"}]},{"title":"[Openlayers] getGetFeatureInfoUrl 함수 사용","slug":"openlayers-dev-1","date":"2020-04-16T01:02:45.000Z","updated":"2024-01-11T07:02:16.192Z","comments":true,"path":"2020/04/16/openlayers-dev-1/","link":"","permalink":"http://hgko1207.github.io/2020/04/16/openlayers-dev-1/","excerpt":"","text":"Geoserver에서 필요한 정보를 가져오기 위해 OpenLayers의 getGetFeatureInfoUrl 함수를 사용하였습니다. feature의 정보 중에 GRAY_INDEX 라는 컬럼의 정보를 가져와야 합니다. 아래 방식으로 image 형태인 layer 를 구성하였습니다. 1234567891011var wmsLayer = new ol.layer.Image(&#123; source: new ol.source.ImageWMS(&#123; ratio: 1, url: 'http://localhost:8080/geoserver/img/wms', params: &#123; FORMAT: 'image/png', VERSION: '1.1.1', STYLES: '', &#125;, &#125;),&#125;); getGetFeatureInfoUrl 함수를 사용하여 feature 정보를 불러와 표출하였습니다. 아래에서 url 에 요청할 때 Cross-Origin Read Blocking(CORN) 문제가 있어 ajax 대신 XMLHttpRequest를 사용하였습니다. 123456789101112131415161718192021222324252627var url = wmsLayer.getSource().getGetFeatureInfoUrl([longitude, latitude], view.getResolution(), view.getProjection(), &#123; INFO_FORMAT: 'application/json', FEATURE_COUNT: 10, QUERY_LAYERS: imageLayers, LAYERS: imageLayers,&#125;);if (url) &#123; var parser = new ol.format.GeoJSON(); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === xhr.DONE) &#123; // 요청이 완료되면 if (xhr.status === 200 || xhr.status === 201) &#123; var result = parser.readFeatures(xhr.responseText); if (result.length) &#123; var info = result[0].get('GRAY_INDEX'); $('#measurement_text').text( 'Val: ' + info + ', Lon: ' + longitude.toFixed(3) + ', Lat: ' + latitude.toFixed(3) ); &#125; &#125; &#125; &#125;; xhr.open('GET', url); xhr.send();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"}]},{"title":"[Cesium] 개발 팁","slug":"cesium-tip","date":"2020-04-15T13:04:56.000Z","updated":"2024-01-11T07:01:03.244Z","comments":true,"path":"2020/04/15/cesium-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/15/cesium-tip/","excerpt":"","text":"영상 레이어 추가 Geoserver에 추가된 영상 레이어를 Cesium 지도에 표출하는 코드입니다. layers 에는 Geoserver에 있는 레이어의 이름을 넣으면 됩니다. 123456789101112131415var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: '', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', &#125;, &#125;)); CesiumJS 포인트 그리기 마우스 왼쪽 버튼을 누를 때 포인트를 그립니다. 1234567891011121314151617181920var ellipsoid = viewer.scene.globe.ellipsoid;var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);handler.setInputAction(function (event) &#123; if (event.position != null) &#123; var cartesian = scene.camera.pickEllipsoid(event.position, ellipsoid); if (cartesian) &#123; var cartographic = Cesium.Cartographic.fromCartesian(cartesian); var longitude = Cesium.Math.toDegrees(cartographic.longitude); var latitude = Cesium.Math.toDegrees(cartographic.latitude); var point = scene.primitives.add(new Cesium.PointPrimitiveCollection()); point.add(&#123; position: Cesium.Cartesian3.fromDegrees(longitude, latitude), color: Cesium.Color.RED, // default: WHITE &#125;); &#125; &#125;&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 영상 레이어 추가 시 스타일 지정 영상 레이어 추가와 거의 같지만 styles와 COLORSCALERANGE 파라미터가 추가되었습니다. styles 에는 Geoserver에 추가된 스타일 이름을 지정하고, COLORSCALERANGE 에는 min, max 값을 지정한다. (COLORSCALERANGE 파라미터는 없어도 됩니다.) 12345678910111213141516var imageryLayer = viewer.imageryLayers.addImageryProvider( new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/img/wms', layers: 'img:GCOMW1_L2_SMC_20120703', parameters: &#123; service: 'WMS', version: '1.1.0', request: 'GetMap', styles: 'lut_redblue', srs: 'EPSG:4326', format: 'image/png', transparent: 'true', COLORSCALERANGE: '0,100', &#125;, &#125;));","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Cesium","slug":"Cesium","permalink":"http://hgko1207.github.io/tags/Cesium/"}]},{"title":"[Eclipse RCP] 개발 팁","slug":"rcp-tip","date":"2020-04-14T04:14:58.000Z","updated":"2024-01-11T06:59:07.588Z","comments":true,"path":"2020/04/14/rcp-tip/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/rcp-tip/","excerpt":"","text":"1) RCP 배포 시 필수사항 build.properties 에 javacDefaultEncoding…=UTF-8 추가하기 추가하지 않을 시 한글이 깨지거나 다른 클래스를 참조할 수 없는 문제로 인해 배포된 프로그램이 실행이 되지 않을 수 있다. 2) Spring Bean 사용 방법 RCP에서 Spring 빈 생성 방법 서비스 인터페이스 설정 파일의 Runtime에 관련 라이브러리 Export 한다. String : core, beans, cglib, scheduling Log : slf4f, logback 빈 설정 정보를 담고 있는 클래스 인 AppConfig를 생성하고, AppConfig 클래스에 서비스 빈등록을 하고, SpringBeanFinder 클래스를 생성하여, 애플리케이션 컨텍스트를 로딩하고, getBean 메소드를 이용하여 해당 빈을 룩업 시킨다. RCP에서 DL(Dependency Lookup) 방법 SpringBeanFinder를 Activator를 이용하여 사용한다. getSpringBean(Class beanClass) Service를 사용하는 클래스에서private final XXXService = Activator.getSpringBean(XXXService.class); 형식으로 최상단에 멤버변수 선언을 한다. 서비스 인터페이스 설계 GUI에서 요구되는 서비스를 리스트업 한다. 리스트 한 서비스를 인터페이스로 생성한다. DummyXXXService를 먼저 생성하고 GUI에서 테스트 및 구현한다. ConnectionManager를 이용해서 서비스 구현한다. RequestMessage, ResponseMessage 생성 RequestMessage 생성 시 Service 정의 3) RCP 카페 https://cafe.naver.com/eclipseplugin 4) RCP Tutorial SWT : http://www.java2s.com/Tutorial/Java/0280__SWT/Catalog0280__SWT.htm SWT JFace Eclipse : http://java2s.com/Code/Java/SWT-JFace-Eclipse/CatalogSWT-JFace-Eclipse.htm Eclipse JFace Table : http://www.vogella.com/articles/EclipseJFaceTable/article.html Eclipse 4 RCP : http://www.vogella.com/articles/EclipseRCP/article.html Eclipse Commands : http://www.vogella.com/articles/EclipseCommands/article.html Eclipse RCP : http://www.vogella.com/articles/Eclipse3RCP/article.html#tips_loadimages","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"}]},{"title":"개발자의 성장","slug":"info-developer","date":"2020-04-14T01:55:09.000Z","updated":"2024-01-11T06:58:37.307Z","comments":true,"path":"2020/04/14/info-developer/","link":"","permalink":"http://hgko1207.github.io/2020/04/14/info-developer/","excerpt":"","text":"회사에서 성장하기 1. 업무를 소비하지 말자 그냥 시키는 것을 그냥 하던 대로 그냥 빨리 해치워 버려야 한다는 생각으로 그냥 일단 돌아가면 되도록 그냥 개발을 하는 것 그냥 아무 생각 없이 누군지는 해주겠지(위험) 이렇게 업무를 개발을 하지 말자 책임감을 가지고 하자 2. 질문을 잘하자 배울 점이 많은 동료가 있는 것은 정말 큰 메리트 하지만 이것을 활용하지 못한다면 아무 의미 없음 회사의 업무는 혼자 하는 것이 아님 이 점을 최대한 활용 질문하는 법 충분한 구글링(검색)을 먼저 하자 사전 준비(질문 정리) 현재 발생한 상황 정리 자신의 시도들을 정리 최종적으로 Yes / No로 대답할 수 있도록 정리 그럴 수 없다면 자신의 결론에 대한 의견을 답할 수 있도록 정리 자신의 수준을 아는 사람에게 질문하자(중요) 3. 문서화를 잘하자 트러블 슈팅 나는 어쩌다 이 버그를 마주했는가 그 원인은 무엇이 있는가 그래서 어떤 시도를 해보았나 그래서 최종적으로 어떻게 해결을 했나 개발에 대한 팁 또는 유틸을 정리 4. 변화무쌍한 스펙 변경에 맞서는 경험 초기에 결정된 스펙은 무조건 변경된다. 나는 이에 어떻게 대응할 것인가 변경될 수 있는 요소들을 어떻게 제어할 것인가","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"}]},{"title":"자바 ORM 표준 JPA 프로그래밍","slug":"book-jpa","date":"2020-04-10T01:58:49.000Z","updated":"2024-01-11T06:56:50.913Z","comments":true,"path":"2020/04/10/book-jpa/","link":"","permalink":"http://hgko1207.github.io/2020/04/10/book-jpa/","excerpt":"","text":"책 정보 책 소개 자바 ORM 표준 JPA는 SQL 작성 없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주고, 객체와 관계형 데이터베이스의 차이도 중간에서 해결해 줍니다. 이 책은 JPA 기초 이론과 핵심 원리, 그리고 실무에 필요한 성능 최적화 방법까지 JPA에 대한 모든 것을 다룹니다. 또한, 스프링 프레임워크와 JPA를 함께 사용하는 방법을 설명하고, 스프링 데이터 JPA, QueryDSL 같은 혁신적인 오픈 소스를 활용해서 자바 웹 애플리케이션을 효과적으로 개발하는 방법을 다룹니다. 리뷰 스프링 프레임워크로 웹 개발할 때 JPA를 사용하기 전에는 MyBatis를 많이 사용하였다. JPA를 알고 난 후 책을 바로 구매하여 공부를 시작하게 되었다. 4년 전에 구매한 책이지만 지금까지도 가끔 보고 있고 설명이 잘 되어있어 실무에 바로 반영할 수 있었다. JPA를 사용하면서 더욱 데이터베이스 사용에 대해 편리해졌고, QueryDSL까지 사용하면서 웹 개발이 재미있어졌다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"}]},{"title":"[React] UI 추천","slug":"react-design","date":"2020-04-08T08:36:55.000Z","updated":"2024-01-11T06:57:43.850Z","comments":true,"path":"2020/04/08/react-design/","link":"","permalink":"http://hgko1207.github.io/2020/04/08/react-design/","excerpt":"","text":"React로 개발 시 기본적인 디자인을 적용하기 위해 고민이 많이 됩니다. 유료 템플릿 프로젝트를 구매해서 사용할 수 있지만 매번 사는 게 부담이기 때문에 디자인을 하기 무척 힘듭니다. 그래서 검색하던 중에 편리하게 디자인 할 수 있도록 지원해 주는 것들을 몇 가지 찾을 수 있었습니다. 1) Ant Design 리액트와 타입스크립트(Typescript) 기반으로 제작된 UI 라이브러리 중국 회사에서 오픈소스화한 라이브러리 코드가 리액트 기반이기 때문에 사용하기 편리함 앤트 디자인의 10가지 디자인 원칙 Proximity (근접성) Alignment (정렬) Contrast (대조) Repetition (반복) Make it Direct (직관적으로 만들어라) Stay on the Page (화면에 머물러라) Keep it Lightweight (가볍게 유지하라) Provide an Invitation (가이드를 제공해라) Use Transition (트랜지션을 사용하라) React Immediately (즉각적인 반응) 12$ npm i antd$ npm i --save @ant-design/icons 2) Material UI 리액트 기반 UI 라이브러리 중에 가장 인기 있고, 성숙한 라이브러리 구글 머테리얼 디자인 기반으로 제작 1$ npm install @material-ui/core 3) React Bootstrap 웹 UI 라이브러리로 전세계에서 가장 많이 사용되는 Bootstrap을 리액트 기반으로 변경한 라이브러리 Bootstrap 3.x 버전을 기반으로 제작된 라이브러리 Bootstrap 4.x 버전으로 마이그레이션 할 수 있음 1$ npm install react-bootstrap bootstrap 4) reactstrap Bootstrap 4.x 버전을 기반으로 제작된 라이브러리 1$ npm install --save reactstrap react react-dom 5) Semantic UI React 부트스트랩 만큼이나 인기 있는 Semantic UI의 리액트 버전 Semantic UI에 jQuery 의존성을 제거하고 순수하게 리액트로만 개발 된 버전 1$ yarn add semantic-ui-react","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"}]},{"title":"PROJ.4 란?","slug":"satellite-proj4","date":"2020-03-27T00:38:26.000Z","updated":"2024-01-11T06:56:15.764Z","comments":true,"path":"2020/03/27/satellite-proj4/","link":"","permalink":"http://hgko1207.github.io/2020/03/27/satellite-proj4/","excerpt":"","text":"PROJ.4 란? ​다양한 좌표계 변환을 제공하는 라이브러리 자유롭게 인자를 지정하여 표준이 아닌 좌표계 간도 변환 가능 USGS의 Gerald Evenden에 의해 만들어진 오픈소스 라이브러리 현재 OSGeo 프로젝트 중 하나이며 MIT 라이선스 GeoServer, OpenLayers, PostGIS, QGIS, GDAL, OGR, GeoTools 등 엄청나게 많은 프로그램에서 사용 중 C, C++, JAVA, Javascript 등 다양한 언어로 포팅 되어 있음​ 경위도 좌표계(WGS84) GPS가 사용하는 좌표계 EPSG:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs https://epsg.io/4326 구글 좌표계(Mercator) EPSG:3857, EPSG:900913 +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs https://epsg.io/3857 TM(Transverse Mercator) 국토지리정보원 기준 좌표계 +proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs UTM(Universal Transverse Mercator) 전 세계를 6도 단위로 나누는 표준적인 TM으로 군사지도에서 많이 사용 UTM52N: 경도 120 ~ 126도 사이에서 사용 EPSG:32652 +proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32652 UTM51N: 경도 126 ~ 132도 사이에서 사용 EPSG:32651 +proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://epsg.io/32651 Polar Stereographic 기상청 북반구 표현에 사용 +proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs https://spatialreference.org/ref/epsg/wgs-84-ups-north/ 참고 epsg.io 한국 주요 좌표계 EPSG코드 및 proj4 인자 정리","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"}]},{"title":"Gdal 사용 방법","slug":"satellite-gdal","date":"2020-03-26T02:07:02.000Z","updated":"2024-01-11T06:55:54.027Z","comments":true,"path":"2020/03/26/satellite-gdal/","link":"","permalink":"http://hgko1207.github.io/2020/03/26/satellite-gdal/","excerpt":"","text":"GDAL 은 래스터 및 벡터 지리 공간 데이터를 조작할 수 있는 오픈 소스 라이브러리다. 라이브러리로서 지원되는 모든 형식의 호출 응용 프로그램에 단일 추상 데이터 모델을 제공한다. 데이터 변환 및 처리를 위한 다양한 명령 행 인터페이스 유틸리티가 제공된다. Windows, Linux 및 MacOS 에서 사용 가능하다. 1. gdalinfo (http://www.gdal.org/gdalinfo.html) GDAL 이 지원하는 영상 정보를 확인한다. 1gdalinfo test.tif 2. gdal_translate (http://www.gdal.org/gdal_translate.html) 다른 형식으로 래스터 데이터를 변환 영상 resize 및 포멧 변경 1gdal_translate -of GTiff -outsize 50% 50% src_dataset dst_dataset 3. gdalwarp (http://www.gdal.org/gdal_utilities.html) image reprojection and warping utility 좌표변환, resampling, image mosaicing 1gdalwarp -t_srs EPSG:4326 input.tif output.tif 4. gdal_merge (https://gdal.org/programs/gdal_merge.html) 일련의 이미지를 자동으로 모자이크한다. 모든 이미지는 동일한 좌표계에 밴드 수가 일치해야 한다. 겹치는 영역에서는 마지막 이미지가 이전 이미지에 복사된다. 1gdal_merge.py -init 255 -o out.tif in1.tif in2.tif 5. gdalmanage (http://www.gdal.org/gdalmanage.html) Mode: identify datasetname : List data format of file. 데이터 포맷 정보 보기 copy datasetname newdatasetname : 파일 복사 rename datasetname newdatasetname : 이름 수정 delete datasetname : 이미지 삭제 12345# 파일일 때gdalmanage identify test.tif# 폴더일 때gdalmanage identify –r test/ 6. gdal_contour (http://www.gdal.org/gdal_contour.html) 입력 래스터 표고 모델(DEM)로부터 벡터 등고선 파일을 생성한다. 7. gdal_polygonize.py (http://www.gdal.org/gdal_polygonize.html) Produces a polygon feature layer from a raster. ERS -&gt; Shape 파일로 변환 1python gdal_polygonize.py inputFile -f ”ESRI Shapefile” outputFile 8. ogr2ogr (http://www.gdal.org/ogr2ogr.html) Shape 파일 좌표 변환 1ogr2ogr -f \"ESRI Shapefile\" out.shp wgs84.shp -s_srs EPSG:32616 -t_srs EPSG:4326 Shape -&gt; GeoJSON 변환 1ogr2ogr -f GeoJSON -t_srs crs:84 [name].geojson [name].shp http://www.mercatorgeosystems.com/blog-articles/2008/05/30/using-ogr2ogr-to-re-project-a-shape-file/ 9. gdaldem (https://gdal.org/programs/gdaldem.html) ERS -&gt; GTiff 파일로 변환한다. 1gdaldem color-relief -of GTiff -co \"TILED=YES\" K220100502_22131215_ref_med_union.ers color_file.txt color.tif ※ GDAL 에서 .py 파일은 .exe로 만들어서 붙입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"}],"tags":[{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"}]},{"title":"[java] Geocoder을 이용해 주소를 위도/경도로 변환하기","slug":"java-geocoder","date":"2020-03-25T01:18:14.000Z","updated":"2024-01-11T06:53:30.099Z","comments":true,"path":"2020/03/25/java-geocoder/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/java-geocoder/","excerpt":"","text":"Geocoding 이란 주소를 위도, 경도로 변환해 주는 Google에서 제공하는 API입니다. 링크 : 지오코딩이란? 처음엔 HttpURLConnection 으로 접속해서 InputStreamReader 로 읽은 후 JSON으로 파싱 하게 만들었는데 해외 사이트에 geocoder 라이브러리를 이용하여 받아오는 예제가 있었다. 어쨌든 더 편리하고 깔끔하게 해결되었습니다. Geocoder Maven dependency 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.geocoder-java&lt;&#x2F;groupId&gt; &lt;artifactId&gt;geocoder-java&lt;&#x2F;artifactId&gt; &lt;version&gt;0.16&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Method 123456789101112131415161718192021222324252627public static Float[] findGeoPoint(String location) &#123; if (location == null) return null; // setAddress : 변환하려는 주소 (경기도 성남시 분당구 등) // setLanguate : 인코딩 설정 GeocoderRequest geocoderRequest = newGeocoderRequestBuilder().setAddress(location).setLanguage(\"ko\").getGeocoderRequest(); try &#123; Geocoder geocoder = new Geocoder(); GeocodeResponse geocoderResponse = geocoder.geocode(geocoderRequest); if (geocoderResponse.getStatus() == GeocoderStatus.OK &amp; !geocoderResponse.getResults().isEmpty()) &#123; GeocoderResult geocoderResult=geocoderResponse.getResults().iterator().next(); LatLng latitudeLongitude = geocoderResult.getGeometry().getLocation(); Float[] coords = new Float[2]; coords[0] = latitudeLongitude.getLat().floatValue(); coords[1] = latitudeLongitude.getLng().floatValue(); ​return coords; &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return null;&#125; latitudeLongitude.getLat().floatValue(); 이 부분은 floart 형이 아닌 toString()으로도 가능하다. 테스트 1234String location = \"대전광역시 유성구 궁동\";Float[] coords = CommonUtil.findGeoPoint(location);System.out.println(location + \": \" + coords[0] + \", \" + coords[1]); 결과 1대전광역시 유성구 궁동 : 36.366701, 127.344510","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"}],"tags":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"}]},{"title":"Spring AOP","slug":"spring-aop","date":"2020-03-25T01:04:18.000Z","updated":"2024-01-11T06:55:12.053Z","comments":true,"path":"2020/03/25/spring-aop/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/spring-aop/","excerpt":"","text":"AOP(Aspect Oriented Programming) 는 공통관심사항을 분리하여 반복되는 부분을 추출해 핵심 로직에 영향을 미치지 않고 소스의 중복을 줄이는 방법으로 기존 OOP(Object-Oriented Programming) 에서 공통관심사항을 여러 모듈에서 적용하며 발생하는 중복된 코드 양산의 한계를 극복하기 위해 나오게 되었습니다. Spring AOP의 장점 예를 들어 어떠한 홈페이지에 로그인 처리를 해야 할 때 AOP를 사용하지 않는다면 모든 페이지마다 로그인 상태인지 확인하는 소스코드를 넣어야 할 테고 혹시나 그 로직이 변경되게 된다면 또 그 모든 페이지의 소스를 수정해야 하는 일이 생길 것입니다. 하지만 AOP를 적용한다면 단 하나의 로그인 로직만 바꿔도 모든 소스에 적용시킬 수 있는 장점이 있습니다. 스프링 AOP 용어 스프링 AOP를 이해하기 위해선 5가지 용어에 대한 이해가 필요합니다. Aspect : 여러 객체에서 공통으로 적용되는 공통 관심사항(ex:트랜잭션, 로깅, 보안) JoinPoint : Aspect가 적용될 수 있는지점(ex:메소드, 필드) Pointcut : 공통 관심사항이 적용될 Joinpoint Advice : 어느시점(ex: 메소드수행 전/후, 예외발생후등)에 어떤 공통관심기능(Aspect)을 적용할지 정의한것 Weaving : 어떤 Advice를 어떤 Pointcut(핵심사항)에 적용시킬 것 인지에 대한 설정(Advisor)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"}]},{"title":"com, net, co.kr의 차이는?","slug":"info-domain","date":"2020-03-25T01:01:05.000Z","updated":"2023-07-13T03:18:17.744Z","comments":true,"path":"2020/03/25/info-domain/","link":"","permalink":"http://hgko1207.github.io/2020/03/25/info-domain/","excerpt":"","text":"사용 com(company) : 회사의 도메인에 사용한다. net(network) : 네트워크를 관리하는 기관의 도메인에 사용한다. co.kr(company korea) : 회사의 도메인에 사용한다.(한국) 인터넷이 미국에서 시작했기 때문에 도메인도 미국이 먼저 선점했다. 그래서 다른 국가들은 .kr 처럼 국가고유 도메인을 추가하여 쓰게 되었다. 일본은 jp, 영국은 uk, 중국은 cn 등이 다 그런 것이다. 원래의 의미는 co.kr, com : 영리목적으로 설립된 회사의 홈페이지를 나타내는 말 or.kr, org : 비영리기구 ne.kr, net : 네트워크 관련 회사, 혹은 통신 관련 회사를 나타내는 말 하지만 or,org 를 제외하고는 모두 동일한 의미를 나타낸다고 보면 된다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"}]},{"title":"[Git] 커맨드 명령어","slug":"git-use","date":"2020-03-24T01:45:42.000Z","updated":"2024-01-11T06:48:53.991Z","comments":true,"path":"2020/03/24/git-use/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/git-use/","excerpt":"","text":"설정 확인 1$ git config --list 계정 확인 12$ git config user.name$ git config user.email 계정 변경 12$ git config --global user.name \"user name\"$ git config --global user.email \"user email\" Git Create 12345$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin https://github.com/username/repositoryName$ git push -u origin master 현재 master 브랜치를 push 할 때 origin의 master 브랜치로 푸시하는 명령어다. 처음 push 할 때 사용한다. 1$ git push --set-upstream origin master Git Update 12$ git add .$ git commit -m \"update\" commit 내용을 확인한다. 1$ git status 원격 저장소에 반영한다. 1$ git push Git Pull 12$ git remote add origin https://github.com/username/repositoryName$ git pull origin master 독립적인 두 프로젝트를 병합할 경우 --allow-unrelated-histories 옵션을 사용한다. 1$ git pull origin master --allow-unrelated-histories Git Repository Download 1$ git clone https://github.com/username/repositoryName 서브 모듈 포함에서 받을 경우 다음 명령어를 참고한다. 1234$ git clone https://github.com/username/repositoryName$ git submodule initor$ git clone --recurse-submodules https://github.com/username/repositoryName Git Ignore .gitignore 파일을 생성한다. 1$ touch .gitignore Git에 이미 올라가 있는 파일을 삭제하고 .gitignore 적용 123456789101112# 원격 저장소와 로컬 저장소에 있는 파일을 삭제한다.git rm [File Name]# 원격 저장소에 있는 파일을 삭제한다.(로컬 저장소에 있는 파일은 삭제하지 않는다.)git rm --cached [File Name]# 폴더 하위의 모든 파일을 삭제한다.git rm -r --cached [Directory]git rm -r --cached example/# 원격 저장소의 파일을 모두 삭제한다.git rm -r --cached . Git branch branch 를 만들고 관리하는 명령어다. 1234567891011# branch 만들기git branch [branch name]# branch 목록 보기git branch# 지정한 branch 삭제git branch -d [branch name]# branch 선택하기git checkout [branch name] Git Remote 원격 저장소를 관리할 수 있는 명령어다. 1234567891011# 원격 저장소의 이름 목록git remote# 원격 저장소에 대한 자세한 목록보기git remote -v# 원격 저장소 추가git remote add [name] [url]# 원격 저장소를 삭제git remote rm [name] Git Clean 작업 디렉토리에서 추적되지 않는 파일을 삭제하는 명령어다. 12345678# untracked 파일 모두 삭제git clean -f# 디렉토리까지 삭제git clean -fd# .gitignore로 무시되는 파일 삭제git clean -d -x Git Stash 1234567891011121314151617# 트래킹 된 파일을 stash 영역에 임시 저장하고 수정 내용은 제거git stash# stash 한 기록을 리스트 형태로 확인git stash list# 가장 최근에 저장한 stash 복원git stash apply# 가장 최근에 저장한 stash 삭제git stash drop# stash 기록 모두 삭제git stash clear# stash를 복원하고 삭제git stash pop 참고 Git 개요","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"}]},{"title":"React Study(2)","slug":"react-study-2","date":"2020-03-24T01:41:09.000Z","updated":"2024-01-11T06:51:26.280Z","comments":true,"path":"2020/03/24/react-study-2/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-2/","excerpt":"","text":"React 세미나😊(2) 2. Project Setup 2.1. Requirements 먼저 Node.js 가 설치되어 있어야 한다. Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/)에서 Window Installer 를 다운로드하고 설치한다. 12$ node -v$ npm -v 에디터로는 MS에서 제공하는 Visual Studio Code(VS Code)를 사용한다. vscode 는 크로스 플랫폼 에디터로 다양한 언어를 서포트하며, IntelliSense 와 Git 기능, 그리고 Extension 을 이용한 확장 기능을 제공하고 있다. 설치 방법은 https://code.visualstudio.com/ 에 접속하여 다운로드 후 설치하면 된다. React 개발에 좋은 Extension는 ESLint, Prettier, vscode-styled-components, Auto Close Tag, React-Native/React/Redux snippets for es6/es7 등 다양하게 있어 설치하고 사용하면 됩니다. 2.2. Creating React App 기존에는 Webpack, Babel 등 필요한 모듈들을 직접 설치하고 설정하느라 상당한 시간이 소요가 되었다. 2016년에 React 작업 환경을 명령어 하나로 설정 할 수 있는 공식 도구가 나오면서 개발자들과 입문자들에게 많은 도움이 되었다. 먼저 프로젝트 생성을 한다. 주의사항은 npm 5.2.0 이상 버전을 설치해야 합니다. 최신 npm 버전에는 npx 가 설치되어 있다. 123456$ npm install npx -global$ npx create-react-app test-project$ cd test-project$ code . 설치가 완료되면 Visual Studio Code 편집기로 프로젝트를 연다. 처음 프로젝트가 설치되면 여러가지 파일이 생성되는데 초기 세팅을 위해 불필요한 파일을 제거하는 것이 좋다. src 폴더에서 App.js, index.js 파일을 제외한 파일을 제거하고 import 된 코드를 제거한다. 3. React 개발 3.1. JSX JSX (JavaScript eXtension) 는 자바스크립트 언어 문법의 확장입니다. 자바스크립트 안에서 HTML 문법을 사용해서 화면을 구성할 수 있게 도와주는 문법으로, React 개발에 엄청난 도움을 줍니다. 123456789101112import React, &#123; Component &#125; from 'react';class HelloMessage extends React.Component &#123; render() &#123; return ( // JSX 문법 &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; ); &#125;&#125;export default HelloMessage; 아래는 스타일링의 여러가지 방법이다. class 대신 className 을 사용한다. 스타일 속성은 중괄호 ({}) 안에 객체 형태로 표시하며 단어 사이의 '-'를 없애는 대신 카멜케이스(Camel Case)를 사용해 CSS 프로퍼티는 나타낸다. styled-components는 리액트 CSS-in-JS 관련 라이브러리 중에서 가장 잘 나가는 라이브러리로써 자바스크립트 파일 안에 CSS 를 작성하는 형태다. 12345678910111213141516171819// App.jsimport React, &#123; Component &#125; from 'react';import styled from 'styled-components';import './App.css';const Content = styled.div` background-color: 'blue'; font-size: 16px;`;function App() &#123; return ( &lt;div&gt; &lt;div className=\"App\"&gt;&lt;/div&gt; &lt;div style=&#123;&#123; backgroundColor: 'black', fontSize: '12px', color: 'white' &#125;&#125;&gt;&lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; );&#125; 123456// App.css.App &#123; background-color: white; font-size: 16px; color: black;&#125; JSX 는 꼭 지켜야 할 몇몇 제한이 있다. JSX 를 사용하는 스크립트 파일은 상단에 React 라이브러리를 꼭 불러와야 한다.1import React from 'react'; 열어 놓은 태그는 꼭 닫아야 한다.1234# 에러&lt;hello&gt;# 정상 동작&lt;hello&gt;&lt;/hello&gt; or &lt;hello /&gt; 최상위 태그는 꼭 1개여야 한다.12345678&lt;Fragment&gt; &lt;header&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;h1&gt;main&lt;/h1&gt; &lt;/main&gt;&lt;/Fragment&gt; 3.2. Component 기반 구조 React 는 Component 기반 라이브러리다. 하나의 코드로 작성하는 것이 아니라 여러 부분을 분할해서 만들기 때문에 코드의 재사용성과 유지보수성이 증가 된다. 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;홈페이지&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;!-- 헤더 내용 --&gt; &lt;/header&gt; &lt;div class=\"content-list\"&gt; &lt;!-- 콘텐츠 리스트 --&gt; &lt;/div&gt; &lt;footer&gt; &lt;!-- 푸터 내용 --&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 위와 같은 html 코드가 있다고 해보자. 이를 React 로 만들게 되면 다음과 같다. 123456789101112131415161718import React, &#123; Component &#125; from 'react';import Header from './component/Header';import Footer from './component/Footer';import ContentList from './component/ContentList';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;ContentList /&gt; &lt;Footer /&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header 나 Footer, ContentList 등은 컴포넌트로 만들고, 이를 조립해서 루트 컴포넌트를 만드는 방식이다. 컴포넌트의 종류로는 클래스형(stateful)과 함수형(stateless)으로 나누어진다. 3.3. Props props란 부모 컴포넌트에서 자식 컴포넌트로 전달해 주는 데이터를 말한다. props는 읽기 전용 데이터라고 생각하면 된다. 자식 컴포넌트에서 전달받은 props를 변경이 불가능하고 props를 전달해 준 최상위 부모 컴포넌트만 props를 변경할 수 있다. 3.4. State state는 동적인 데이터를 다룰 때 사용한다. 사용자와의 상호작용을 통해 데이터를 동적으로 변경을 해야 할 때 사용한다. state는 클래스형 컴포넌트에서만 사용할 수 있는데 각각의 state는 독립적이라 다른 컴포넌트의 직접적인 접근은 불가능하다. 3.5 LifeCycle API LifeCycle API는 컴포넌트가 DOM 위에 생성되기 전 후 및 데이터가 변경되어 상태를 업데이트하기 전 후로 실행되는 메서드들이다. 자원낭비를 줄이기 위하여 코드를 최적화할 때 사용된다. 많이 사용하는 LifeCycle 메서드들은 constructor, componentDidMount, render, shouldComponentUpdate 이다. 참고 VS Code 기본 세팅 vscode 추천 익스텐션(Extensions)과 세팅 craete-react-app github React 시작하기 [npm] 🤔npx란 무엇인가? JSX 소개 - React 누구든지 하는 리액트 3편: JSX 리액트 Styled Components - 1편 강의 https://academy.nomadcoders.co/ https://www.opentutorials.org/module/4058","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"React Study(1)","slug":"react-study-1","date":"2020-03-24T01:39:16.000Z","updated":"2024-01-11T06:49:57.919Z","comments":true,"path":"2020/03/24/react-study-1/","link":"","permalink":"http://hgko1207.github.io/2020/03/24/react-study-1/","excerpt":"","text":"React 세미나😊(1) 최근 React를 다시 공부하게 되면서 올해 초에 회사에서 세미나를 하게 되었다. 물론 기초이지만 React 에 관심을 다시 가지게 되는 계기가 되었다. React란? React는 페이스북에서 제공해 주는 프런트엔드 라이브러리다. 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM을 통해 속도와 편의를 높이고, 단방향 데이터 플로우를 지원하여 보일러플레이트 코드를 감소 시켜준다. React 는 싱글 페이지 애플리케이션(SPA)이나 모바일 애플리케이션을 개발할 때 사용할 수 있다. 특징 컴포넌트 기반 아키텍처 템플릿 언어가 아닌 자바스크립트로 컴포넌트 작성 특정 관심사에 집중된 기능 블록 (관심사의 분리) One Way Data flow(단방향 데이터 흐름 지향) React 는 데이터의 흐름이 한 방향으로만 흐흔다. 데이터가 내려가기만 하고 밑에서 데이터를 올릴 수 없다. 그래서 부모의 데이터를 바꿔주기 위해서는 state를 이용해야 한다. Virtual DOM - React는 가상의 DOM을 만들어서 진짜 DOM 과 비교하여 변경 사항이 있을 경우 전체를 새롭게 만드는 것이 아니라 변경된 부분만 진짜 DOM 에 반영하는 방식으로 작업을 수행한다. 그럼으로써 애플리케이션의 효율성과 속도를 높일 수 있게 된다. JSX 문법 리액트 JS를 하기 위해 알아야 할 것 Javascript(ES6) HTML CSS 1. Fundamentals(기초) React에서 많이 사용되는 자바스크립트 ES6 문법 기초를 먼저 알아보자. 기존에 우리가 웹 개발에서 많이 보던 자바스크립트는 2009년 12월에 나온 ECMAScript5(ES5) 버전이다. 최근 Node.js, react에서는 2015년 6월에 업데이트된 ECMAScript6(ES6) 문법의 자바스크립트를 사용하고 있다. ES6 문법을 사용하면서 처음에는 익숙해지기 어려웠지만 사용할 수록 코드가 간결해지고 깔끔해지면서 가독성이 좋아졌고, 모듈 별로 개발하면서 코드 관리가 쉬워졌다. 현재는 ES8까지 업데이트 되었지만 몇 가지 걸림돌이 있어 넘어가지 않고 있다. 아래에는 바뀐 ES6 문법과 많이 사용되는 기능들이다. 1.1. var -&gt; let &amp; const const 는 블록 범위이며 값이 지정되면 나중에 바꿀 수 없다. 또한, 재 선언 될 수도 없다. let 은 블록 범위이며 값이 지정되어도 값을 바꿀 수 있다. 12const name = 'eden';let tel = '010-0000-0000'; 1.2. Arrow Functions 함수는 간결해지고 코드는 짧아졌다. Argument가 하나 일 때는 괄호가 필요 없다.(유일한 규칙) 1234567// ES5function sayHello(name) &#123; reutn \"Hello \" + name;&#125;// ES6const sayHello = name =&gt; \"Hello \" + name;const sayHello = (name, something) =&gt; \"Hello \" + name + something; 1.3. Template Literals ``(backticks) 사용 12345const name = 'eden';// ES5console.log('Hello ' + name);// ES6console.log(`Hello $&#123;name&#125;`); 1.4. Object Destructuring (비구조화) 적은 코드를 사용해서 더 깔끔하게 보이도록 한다. 1234567891011121314151617181920212223const human = &#123; name: 'Ko', lastName: 'HyeongGyun', nationality: 'Korea', favFood: &#123; dinner: 'Samgyupsal', &#125;,&#125;;// ES5const name = human.name;const lastName = human.lastName;const difName = human.nationality;const dinner = human.favFood.dinner;// ES6const &#123; name, lastName, nationality: difName, favFood: &#123; dinner &#125;,&#125; = human;console.log(name, lastName, difName, dinner); 1.5. Spread Operator Iterable Object(열거 가능한 오브젝트)를 하나씩 전개한다. 표현방식 […iterable], 변수 앞에 ‘…’ 찍어서 선언한다. 변수뿐만 아니라 Argument, Function에서도 쓰인다. 123456const days = ['Mon', 'Tues', 'Wed'];const otherDays = ['Thu', 'Fri', 'Sat'];const allDays = [...days, ...otherDays, 'Sun'];console.log(allDays);결과: ['Mon', 'Tues', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; 1.6. Classes constructor 메서드도 사용할 수 있고 extends를 통해서 클래스 상속도 가능하다. 123456789101112131415161718class Human &#123; constructor(name, lastName) &#123; this.name = name; this.lastName = lastName; &#125;&#125;class Baby extends Human &#123; cry() &#123; console.log('cry'); &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;&#125;const myBaby = new Baby('mini', 'me');console.log(myBaby.cry(), myBaby.sayName()); 1.7. Array.map 요소를 일괄적으로 변경한다. 12345const days = ['Mon', 'Tues', 'Wed', 'Thu', 'Fri'];const smilingDays = days.map((day) =&gt; `😂 $&#123;day&#125;`);console.log(smilingDays);결과: ['😂 Mon', '😂 Tues', '😂 Wed', '😂 Thu', '😂 Fri']; 1.8. Array.filter 요소를 걸러내어 배열로 true/false 반환, 없으면 빈 배열을 반환한다. 123const numbers = [123, 5, 15, 67, 241, 54, 1, 6, 23, 90];const otherNumbers = numbers.filter((number) =&gt; number &gt; 15);console.log(otherNumbers); 1.9. forEach, includes, push 123456let posts = ['Hi', 'Hello', 'Bye'];if (!posts.includes('new')) &#123; posts.push('new');&#125;posts.forEach((post) =&gt; console.log(post)); CodeSandbox 웹 기반 자바스크립트 에디터 서비스를 제공하는 사이트 간단한 소스 코드 테스트를 할 때 사용하면 편리하다. codesandbox.io 참고 https://velog.io/@stampid/React란 https://velog.io/@kyusung/react-summary https://hgko1207.github.io/2019/01/09/react-start/ https://sanghaklee.tistory.com/54 http://woowabros.github.io/experience/2017/12/01/es6-experience.html https://blog.asamaru.net/2017/08/14/top-10-es6-features/ https://velog.io/@decody/map-정리","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"}]},{"title":"Node.js 교과서","slug":"book-nodejs","date":"2019-06-19T07:31:30.000Z","updated":"2024-01-11T06:47:07.547Z","comments":true,"path":"2019/06/19/book-nodejs/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/book-nodejs/","excerpt":"","text":"책 정보 책 소개 노드의 기본부터 실무까지, 전 과정을 한 권에 담았다! 다양한 서비스를 직접 만드는, 실무에 가장 가까운 강의! Node.js 10 + 자바스크립트 ES2018, 최신 문법으로 배우자. 서버와 데이터베이스 개념을 시작으로 노드의 기본 개념을 차근차근 설명해 나간다. 군더더기 없는 직관적인 설명, 풍부한 그림으로 기본 개념을 확실히 이해하고, 노드의 기능과 생태계를 사용해 보며 실제로 동작하는 서버를 만들어보자. 웹 서버, 웹 API 서버, SNS 서비스, 실시간 GIF 채팅방, 경매 시스템, 위치 기반 장소 검색 서비스, 커맨드라인 인터페이스를 모두 만들어 볼 수 있다. 실무에 당장 적용할 수 있고, 참고할 수 있는 예제와 코드를 최신 문법으로 다뤄보자. 리뷰 최근 Node.js에 관심이 생겨 공부를 해볼까 하다가 지인의 추천으로 이 책을 사게 되었습니다. 노드의 기본부터 실무까지 꼼꼼하게 설명되어 있고 무엇보다 예제 소스가 잘 되어 있어 힘들게 코드를 안 봐도 되고 이해도 빨라 금방 익숙해졌습니다. 아직은 걸음마 단계이지만 차근차근 공부하고 프로젝트도 진행해 볼 예정입니다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"}]},{"title":"[WPF] Prism Library 사용 방법","slug":"wpf-prism","date":"2019-06-19T07:26:34.000Z","updated":"2024-01-11T06:48:27.847Z","comments":true,"path":"2019/06/19/wpf-prism/","link":"","permalink":"http://hgko1207.github.io/2019/06/19/wpf-prism/","excerpt":"","text":"최근 WPF 기반으로 응용 애플리케이션을 개발하고 있습니다. C#을 처음 하는 거라 처음에는 익숙하지 않았지만 자바와 비슷한 면이 많아 금방 적응하였습니다. WPF 개발을 하는데 Prism Library를 적용하였습니다. Prism은 WPF를 통해 풍부하고 유연하고 유지보수가 쉬운 설계를 할 수 있게 도와준다고 합니다. 그리고 MVVM 패턴, Dependency Inejction, CompositeView, Event Aggregator들을 이용하여 독립적인 컴포넌트들 간의 느슨한 결합들을 이용한 설계 중심의 애플리케이션 제작에도 도움을 준다고 합니다. 즉, WPF 어플리케이션을 만들 시 MVVM 디자인 패턴으로 개발하고 이에 추가적으로 Prism이 제공하는 CompositeView 제작방식과 Event Aggregator 기능들을 사용할 수 있는 것입니다. Prism 설계 목표(Prism Design Goals) 재사용성(Reuse) 확장성(Extensibility) 유연성(Flexibility) 협업(Team Development) 품질(Quality) Prism Key Concepts Prism의 설계 목표와 핵심 개념들입니다. Modules Module catalog Shell Views View models Models Commands Regions Navigation EventAggregator Dependency injection container Services Controllers Bootstrapper Prism 아키텍처","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"}]},{"title":"Hexo 시작 및 기본 사용법","slug":"hexo-basic-usage","date":"2019-02-13T01:38:15.000Z","updated":"2023-07-13T03:11:52.865Z","comments":true,"path":"2019/02/13/hexo-basic-usage/","link":"","permalink":"http://hgko1207.github.io/2019/02/13/hexo-basic-usage/","excerpt":"","text":"Hexo Hexo 라는 블로그 프레임워크를 사용하여 블로그를 작성하던 중에 시간이 지나면 생성하는 법이나 작성하는 법 등 사용법들을 자꾸 잊어버리게 되어 기존에 자주 보곤 했던 Hexo 사용법이 잘 정리되어있던 블로그 링크를 모아놨다. 참고 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 기본 사용법 Hexo 시작하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"}]},{"title":"[JavaScript] Daum 우편번호 서비스 사용 방법","slug":"javascript-postcode","date":"2019-01-18T06:52:14.000Z","updated":"2024-01-11T06:46:10.067Z","comments":true,"path":"2019/01/18/javascript-postcode/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-postcode/","excerpt":"","text":"웹 프로젝트를 하면서 사용자 등록을 하게 될 때 주소를 입력을 하게 되는데, 우편번호 주소 조회가 되도록 처리해 달라는 요청이 있었습니다. 그래서 우편번호 서비스를 검색해 봤을 때 여러 가지가 있었지만 개인적으로 좋아 보이는 Daum 우편번호 서비스를 사용하게 되었습니다. Daum 우편번호 서비스 쉽고 간편하게 우편번호 검색, 도로명 주소 입력 기능을 만들 수 있습니다. Key를 발급받을 필요가 없습니다. 사용량에 대한 제한이 전혀 없습니다. 기업용이든 상업적 용도이든 상관없이 무조건 무료로 사용 가능합니다. 도로명 주소, 지번 주소, 영문 주소까지 모두 확인 가능합니다. 이 것 말고도 여러 가지 장점이 더 있지만 사용하기 쉽고 무료이며 사용량에 대한 제한이 없고, 특히나 기본 사용법이 정말 쉽게 잘 설명되어 있어서 사용하게 되었습니다. 예제 123456789&lt;script src=\"//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt;&lt;script&gt; new daum.Postcode(&#123; oncomplete: function(data) &#123; // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다. // 예제를 참고하여 다양한 활용법을 확인해 보세요. &#125; &#125;).open();&lt;/script&gt; 적용 아래는 적용한 코드입니다. HTML HTML 코드는 아래와 같습니다. 우편번호, 도로명 주소, 상세 주소 입력 란이 있고 우편번호 찾기 버튼이 있습니다. 버튼을 클릭하게 되면 execDaumPostcode() 함수를 호출하게 됩니다. 12345678910111213141516171819202122&lt;div class=\"form-group row\"&gt; &lt;label class=\"col-md-2 offset-md-3 form-label\"&gt; 주 소 &lt;span class=\"text-danger\"&gt;*&lt;/span&gt; &lt;/label&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"postcode\" id=\"postcode\" placeholder=\"우편번호\" readonly /&gt; &lt;/div&gt; &lt;div class=\"col-md-2 postcode-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-info\" onclick=\"execDaumPostcode()\"&gt;우편번호 찾기&lt;/button&gt; &lt;/div&gt; &lt;div class=\"offset-md-5 col-md-4 mt-2\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"address\" id=\"address\" placeholder=\"도로명 주소\" readonly /&gt; &lt;/div&gt; &lt;div class=\"offset-md-5 col-md-4 mt-2\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"detailA_address\" name=\"detailAddress\" placeholder=\"상세 주소\" required /&gt; &lt;/div&gt;&lt;/div&gt; 결과 화면입니다. JavaScript 버튼을 클릭하여 execDaumPostcode() 함수가 호출되면서 주소 검색 팝업창이 보이게 합니다. 팝업창에서 주소 검색 결과 항목을 클릭했을 때 우편번호와 도로명주소 입력란에 값을 채워 넣게 됩니다. 123456789101112131415161718192021222324252627&lt;script src=\"//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt;&lt;script&gt;/** 우편번호 찾기 */function execDaumPostcode() &#123; new daum.Postcode(&#123; oncomplete: function(data) &#123; // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다. // 각 주소의 노출 규칙에 따라 주소를 조합한다. // 내려오는 변수가 값이 없는 경우엔 공백('')값을 가지므로, 이를 참고하여 분기 한다. let addr = ''; // 주소 변수 //사용자가 선택한 주소 타입에 따라 해당 주소 값을 가져온다. if (data.userSelectedType === 'R') &#123; // 사용자가 도로명 주소를 선택했을 경우 addr = data.roadAddress; &#125; else &#123; // 사용자가 지번 주소를 선택했을 경우(J) addr = data.jibunAddress; &#125; $(\"#postcode\").val(data.zonecode); $(\"#address\").val(addr); $(\"#address\").focus(); &#125; &#125;).open();&#125;&lt;/script&gt; 결론 Daum 우편번호 서비스를 사용하여 주소를 검색하고 우편번호와 도로명 주소를 받아 입력란에 넣어줬습니다. Daum 우편번호 서비스 사이트 가시면 예제와 속성, 함수에 대한 부분도 잘 설명되어 있기 때문에 다양하게 개발할 수 있습니다. 참고 Daum 우편번호 서비스 Daum 우편번호 서비스 사용 가이드 - 우편번호 검색, 적용법 및 사용예제","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"Daum 우편번호","slug":"Daum-우편번호","permalink":"http://hgko1207.github.io/tags/Daum-%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"}]},{"title":"[JavaScript] 전화번호 하이픈(-) 자동입력","slug":"javascript-autoHypenTel","date":"2019-01-18T06:22:36.000Z","updated":"2024-01-11T06:43:51.812Z","comments":true,"path":"2019/01/18/javascript-autoHypenTel/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/javascript-autoHypenTel/","excerpt":"","text":"사용자 등록 시 전화번호를 입력하게 되는데 아래 그림처럼 세 개의 입력을 받아 합치는 형식으로 많이 되어 있습니다. 이렇게 개발해도 괜찮지만 좀 더 쉽게 하기 위해서 전화번호 입력 시 자동으로 하이픈(-)이 입력되도록 하는 형식으로 바꾸면 좋겠다 싶어 반영해 봤습니다. 개발된 화면은 다음과 같습니다. 1) HTML 먼저 HTML 소스 코드다. input 태그를 사용하고 pattern과 maxlength, required, placeholder를 사용하였습니다. 속성에 대한 설명은 참고 사이트를 보시면 됩니다. 12345678910&lt;input type=\"tel\" class=\"form-control m-input\" name=\"tel\" id=\"telInput\" required pattern=\"[0-9]&#123;2,3&#125;-[0-9]&#123;3,4&#125;-[0-9]&#123;4&#125;\" maxlength=\"13\" placeholder=\"예) 010-1234-5678\"/&gt; 2) JavaScript 먼저 전화번호 크기에 따라 나눴습니다. 서울 전화번호는 02로 두자리로 시작하고 핸드폰은 010, 011…이고 다른 지역 전화번호는 031, 041, 051 등 세 자리로 시작하여 {2}-{3 or 4}-{4} 또는 {3}-{3 or 4}-{4} 형태가 되도록 문자열을 잘라내는 방식으로 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function autoHypenTel(str) &#123; str = str.replace(/[^0-9]/g, ''); var tmp = ''; if (str.substring(0, 2) == 02) &#123; // 서울 전화번호일 경우 10자리까지만 나타나고 그 이상의 자리수는 자동삭제 if (str.length &lt; 3) &#123; return str; &#125; else if (str.length &lt; 6) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2); return tmp; &#125; else if (str.length &lt; 10) &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 3); tmp += '-'; tmp += str.substr(5); return tmp; &#125; else &#123; tmp += str.substr(0, 2); tmp += '-'; tmp += str.substr(2, 4); tmp += '-'; tmp += str.substr(6, 4); return tmp; &#125; &#125; else &#123; // 핸드폰 및 다른 지역 전화번호 일 경우 if (str.length &lt; 4) &#123; return str; &#125; else if (str.length &lt; 7) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3); return tmp; &#125; else if (str.length &lt; 11) &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 3); tmp += '-'; tmp += str.substr(6); return tmp; &#125; else &#123; tmp += str.substr(0, 3); tmp += '-'; tmp += str.substr(3, 4); tmp += '-'; tmp += str.substr(7); return tmp; &#125; &#125; return str;&#125; 호출 부분 코드입니다. 키가 입력될 때마다 검사를 진행합니다. 12345$('#telInput').keyup(function (event) &#123; event = event || window.event; var _val = this.value.trim(); this.value = autoHypenTel(_val);&#125;); 전화번호 시작이 1588, 1668 등과 같은 번호 일 경우에 대해서는 작성하지 않았습니다. 보다시피 완벽하게 최적화가 되지 않았기 때문에 추후에 수정이 될 것 같습니다. 참고 HTML Input 속성들(Attributes) 핸드폰 번호 하이픈(-) 자동입력 전화번호 입력 시 하이픈(-) 자동 입력","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"}]},{"title":"[Git] 이클립스에서 Git 사용법","slug":"eclipse-git","date":"2019-01-18T02:17:07.000Z","updated":"2024-01-11T06:41:51.685Z","comments":true,"path":"2019/01/18/eclipse-git/","link":"","permalink":"http://hgko1207.github.io/2019/01/18/eclipse-git/","excerpt":"","text":"기존에는 사내에서 개발할 때 SVN으로 형상관리를 하였는데, 이번에 개인 공부도 하고 프로젝트로 만들다 보니 GitHub를 사용하게 되었습니다. GitHub는 원격 저장소를 제공하며 여러 가지 프로젝트 진행을 원활하게 하는 도구를 함께 제공하는 이점이 있어서 사용하였습니다. 스프링 프레임워크 기반 웹 프로젝트를 이클립스로 개발하고 있어 이클립스와 GitHub를 연동하였습니다. 이제 연동 방법을 설명합니다. 1. 원격 저장소 생성 먼저 공식 사이트인 https://github.com/ 에서 회원가입을 합니다. 회원가입 후 로그인을 하고 “Start a project” 버튼을 클릭합니다. 래 그림처럼 화면이 나옵니다. 원격 저장소 이름을 입력하고 다른 것은 수정하지 말고 “Create repository” 버튼을 클릭하면 다음과 같은 원격저장소가 생성됩니다. 빨간 네모 박스의 경로를 복사해둡니다. 2. EGit 설치 이클립스를 실행하고 Help -&gt; Eclipse Marketplace를 클릭합니다. Marketplace에서 Egit를 검색한다. 아래 그림처럼 EGit - Git Integration for Eclipse를 찾아 설치합니다. 설치가 완료되면 이클립스를 다시 실행하게 됩니다. 재실행 후에 이클립스의 오른쪽 위에 퍼스펙티브 버튼을 클릭하면 창이 보입니다. Git 을 선택하고 [OK] 버튼을 눌러 활성화시킵니다. Git 퍼스펙티브가 추가된 것을 볼 수 있으며 아이콘을 클릭하면 아래 그림처럼 기본화면이 변경됩니다. 3. 원격 저장소 연동 Git 퍼스펙티브 화면에서 [Clone a Git repository] 를 클릭합니다. Clone Git Repository 창이 보이면 Clone URL를 선택하고 [Next] 버튼을 클릭하면 아래의 그림처럼 화면이 보입니다.(이클립스 버전마다 조금씩 다른 것 같습니다.) 첫 번째 빨간 박스에서 앞에서 복사해둔 Git 원격 저장소 주소를 URI 칸에 복사하면 Host, Repository path 칸에 자동으로 입력됩니다. 그 밑의 빨간 박스에는 깃허브 아이디와 패스워드를 입력하고 [Next] 버튼을 클릭합니다. Branch 를 선택하는 화면이 보이는데 Branch를 만들지 않았으므로 그냥 [Next] 버튼을 클릭합니다. 원격 저장소와 연결할 로컬 저장소를 설정한 뒤 [Finish] 버튼을 클릭합니다. 4. 프로젝트 연동 개발하고 있는 프로젝트와 연동하기 위해 작업을 합니다. 프로젝트를 마우스 우클릭 후 그림처럼 **[Team] -&gt; [Share Project]**를 클릭합니다. Git을 선택하고 [Next] 버튼을 클릭합니다. 그런 다음 Repository 란에서 앞에서 생성한 저장소를 설정해주고 [Finish] 버튼을 클릭합니다. 4. 첫 번째 커밋 원격 저장소에 첫 번째로 합니다. 프로젝트를 마우스 우클릭 후 **[Team] -&gt; [Commit]**을 클릭합니다. 다음과 같은 화면이 뜨면 Commit Message 항목에 메시지를 작성 한 후 프로젝트 파일 전체를 Staged Changes 로 옮깁니다. 그런 후에 마지막으로 [Commit and Push] 버튼을 클릭합니다. Branch에 push 하기 과정인데 이 부분은 패스하겠습니다. [Next] 버튼을 클릭합니다. 그럼 로그인 창이 뜰 텐데, GitHub의 아이디와 비밀번호를 입력하시고 [OK] 버튼을 클릭합니다. Push 확인 화면이 보여지는데 확인하고 [Finish] 버튼을 클릭합니다. 다시 로그인 창이 뜹니다. 처음에만 2번 로그인하고 그다음에는 한 번만 로그인하면 됩니다. 아이디 비밀번호를 입력하고 [OK] 버튼을 클릭합니다. 완료가 되면 아래 그림처럼 Push 결과 화면이 보입니다. 5. GitHub에서 프로젝트 확인 GitHub 홈페이지를 가서 Push 된 프로젝트를 확인 할 수 있습니다. 그림처럼 프로젝트가 올라가있고 수정된 이력도 보입니다. 이클립스에서 소스 코드를 수정하고 위에서 본 Commit 과정과 같이 하면 프로젝트를 관리할 수 있습니다. 결론 이클립스와 GitHub의 원격 저장소와 연동하여 설정을 하였습니다. 아직은 깃을 많이 사용해보지 못하였고 조금씩 알아가며 사용하고 있고 Branch에 대해서도 알아가고 있습니다. 늦은 감이 있긴 한데 이제라도 얼른 써서 익숙해지려고 노력해야겠습니다. 참고 [Git] 이클립스에서 Git 사용하기 [Git] 이클릭스에서의 Git 사용법(egit) 1 [Git] 이클립스와 깃(GitHub) 연동하여 원격 저장소의 프로젝트 내려받기 [git] 이클립스(eclipse) 연동하여 처음 사용하기","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"}]},{"title":"[React Native] Expo 사용 방법","slug":"react-native-expo-start","date":"2019-01-11T07:35:26.000Z","updated":"2024-01-11T06:34:44.446Z","comments":true,"path":"2019/01/11/react-native-expo-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-expo-start/","excerpt":"","text":"Expo 리액트 네이티브는 리액트 아키텍처를 모바일에 적용한 것으로, ES6 문법과 리액트를 이용해 모바일 애플리케이션을 개발할 수 있도록 해주는 프레임워크다. 리액트 네이티브 프로젝트 생성 시 react-native init &lt;프로젝트 이름&gt;을 입력하여 사용하였다. 이것만으로도 충분하다고 느껴졌는데 다른 강좌를 보던 중에 Expo 툴을 발견하게 되었다. Expo는 리액트 네이티브 애플리케이션의 빌드를 돕는 툴이다. 네이티브 API에 접근하는 것도 쉽게 만들어주고, 안드로이드와 iOS 버전을 알아서 빌드해준다. 무엇보다 코드를 수정하면 바로 hot reloading 시켜주는 것이 가장 편하다. 작년 12월 쯤에 리액트 네이티브를 알게 되고 최근에 Expo도 접하게 되면서 찾던 중 처음에는 Expo Xde를 다운로드하여 사용하라고 하여서 Expo 홈페이지를 찾아봤지만 다운로드하지 못하였다. 그러던 중 xde 지원이 중단되고 대신 Expo dev tool(=expo cli 최신버전)을 설치해서 사용하라고 하는 내용을 보게 되었다. Expo cli 설치 및 실행 1. node.js 설치 이전 글인 리액트 시작하기 를 참고한다. &gt; [Programming/React/리액트 시작하기] - Node.js 설치: Windows 2. expo-cli 설치 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행한다. 1$ npm install -g expo-cli 3. 프로젝트 생성 프로젝트 생성할 때는 expo init &lt;프로젝트 이름&gt; 명령어를 사용한다. init 입력 후 프로젝트 개발 목적에 맞게 선택한다. 그런 다음 Use Yarn to install dependencies? 하는 질문에 Y 를 입력하고 엔터를 입력한다. 그러면 설치가 시작되고 완료 후 프로젝트가 정상적으로 생성이 되었는지 확인한다. 1$ expo init react-native-project 4. 프로젝트 실행 프로젝트를 실행하면 새 탭이 생성되면서 다음 그림처럼 보인다. 12$ cd react-native-project$ expo start 5. 모바일 디바이스 연결 실제 모바일 디바이스 먼저 Expo 홈페이지에서 계정을 생성한다. 그런 다음 모바일에서 “Expo client” 앱을 설치한다. 그리고 프로젝트 실행 화면에서 Publish or republish project… 을 클릭하고 내용을 입력 후 Publish Project 버튼을 클릭한다. 클릭하는 순간 터미널(또는 명령프롬프트)에 계정 정보를 입력하라는 문구가 뜬다. 그럼 생성한 계정정보를 입력 후 엔터키를 누르고 프로젝트 실행 화면으로 넘어와서 성공했는지 확인한다. &quot;Expo client&quot; 앱을 실행하고 생성한 계정정보를 입력한다. 로그인 성공 후 하단에 있는 Projects 탭을 클릭한다. 그러면 Publish 성공한 프로젝트가 보인다. 프로젝트를 클릭하면 우리가 작업한 화면이 보일 것이다. 코드를 수정하면 바로 앱에서 변경되는 것을 확인할 수 있다. 이슈사항은 모바일 디바이스와 연결 시 같은 망의 네트워크여야 하는 것 같다. QR Code로 하는 방법도 있는 것 같은데 아직 시도를 못 해봤다. 에뮬레이터 iOS는 Xcode를 설치하고 Android는 Android Studio를 설치하고 AVD manager에서 디바이스를 생성 후 실행시켜준다. 그런 다음 프로젝트 실행 화면에서 “Run on Android device/emulator” 또는 “Run on iOS simulator” 를 클릭한다. 자동으로 에뮬레이터에 앱이 설치가 되고 실행이 된다. 그리고서 실행된 화면을 확인하고 코드를 변경한다. 라이브 리로드 설정이 되어있으면 바로 리로드가 되는 것을 확인할 수 있다. 에뮬레이터 연결은 Expo 뿐만 아니라 앱 개발할 때 자주 사용하기 때문에 따로 설명은 없고 아래 링크에서 가이드를 보면 나와있다. &gt; 모바일 클라이언트 : iOS 및 Android 에뮬레이터 참고 Expo Quick Start Expo Xde 지원 중단에 따른 Expo dev tool(Expo cli) 설치 및 실행 방법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"}]},{"title":"[React Native] 시작하기","slug":"react-native-start","date":"2019-01-11T04:20:56.000Z","updated":"2024-01-11T06:36:08.306Z","comments":true,"path":"2019/01/11/react-native-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/react-native-start/","excerpt":"","text":"React Native 란 리액트는 페이스북이 웹 개발을 쉽게 하기 위해 만든 기술입니다. 리액트 네이티브는 리액트의 접근 방법을 모바일로 확장하는 페이스북의 오픈소스 프로젝트입니다. 기존의 하이브리드 앱은 WebView에 화면을 만들어 놓고 모바일 앱에서 접근하는 것이었기 때문에 퍼포먼스가 떨어지고, 모바일 앱과의 괴리감이 있었습니다. 리액트 네이티브는 실제 네이티브 UI를 사용하여 모바일 앱을 구현합니다. 퍼포먼스는 올라가고 괴리감도 사라지게 됩니다. 리액트 네이티브를 사용하면 JavaScript를 사용하여 모바일 앱을 제작할 수 있습니다. 리액트와 동일한 디자인을 사용하여 선언적 구성 요소에서 풍부한 모바일 UI를 구성할 수 있습니다. 출처: 배고픈사자의 React Native [리액트 네이티브] 장점 높은 생산성 리액트를 사용하여 개발해 보신분이라면 처음부터 빠르게 개발을 시작할 수 있습니다. 아니라면 처음에 당연히 러닝커브(Learning Curve)는 필요합니다. 그렇지만 Swift, Java 또는 Kotlin, Objective-C를 배우는 것보다 자바스크립트 언어 하나로 작성하기 때문에 생산성이 당연히 좋다고 생각합니다. 그리고 iOS와 Android를 동시에 개발할 수 있다는 점이 매우 큰 장점입니다. 라이브 리로딩 리액트 네이티브를 사용하면 앱을 더 빠르게 빌드할 수 있습니다. 기존 앱을 개발할 때는 변경되면 다시 빌드를 해야 했지만 리액트 네이티브로 개발할 때 다시 컴파일 하는 대신 즉시 앱을 다시 로드할 수 있습니다. 코드를 수정해서 저장만 하면 변경된 내용을 바로 확인할 수 있어 실제 개발시간을 확실히 단축시킬 수 있습니다. 필요한 경우 원시 코드 사용 리액트 네이티브는 Swift, Java 또는 Objective-C로 작성된 구성 요소와 원활하게 결합합니다. 애플리케이션의 몇 가지 측면을 최적화해야하는 경우 네이티브 코드로 간단하게 작성할 수 있습니다. 단점 개발자료 부족 시작된지 얼마 되지 않는 프로젝트라서 검색을 하였을 때 확실히 자료가 적은 것 같습니다. 더군다나 영어 자료는 있는데 한글로 된 자료는 더욱 없다고 느껴집니다. 힘든 유지보수 플랫폼 기기에 대한 문제가 생기면 원인을 찾기가 힘든 것 같습니다. 그리고 국내에 리액트 네이티브 개발자가 많이 없다고 들었습니다. 만약에 리액트 네이티브로 개발을 완료하고 퇴사를 하게 되면 후임자나 유지보수를 해야 하는 개발자를 구해야 하는데 특히 소규모 회사들은 더욱 어렵다고 느껴집니다. 비고 위의 단점이 있더라도 장점이 크다고 느껴지고 흥미가 있어 리액트 네이티브에 대해 공부하고 앞으로 있는 새로운 프로젝트에서 사용해 볼 예정입니다. 리액트 네이티브 설치와 실행 및 환경설정은 워낙 정리가 잘 되어있는 블로그가 많아서 따로 정리를 하지 않았습니다. 아래 참고에 되어 있는 링크를 따라가면 window, macOS 환경에서의 설치와 ios, android 플랫폼에서 실행할 수 있도록 잘 설명되어 있습니다. 그리고 리액트 네이티브에 대한 내용과 장단점에 대해서도 참고 링크를 보면 자세하게 볼 수 있습니다. 참고 React Native 설치와 실행(hello world) [RN] React-Native 시작하기 React Native React Native Getting Started [RN] React-Native의 장단점은?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"}]},{"title":"WPF MVVM 일주일 만에 배우기","slug":"book-wpf","date":"2019-01-11T02:00:22.000Z","updated":"2023-07-12T06:26:18.327Z","comments":true,"path":"2019/01/11/book-wpf/","link":"","permalink":"http://hgko1207.github.io/2019/01/11/book-wpf/","excerpt":"","text":"책 정보 책 소개 필자의 십 수년간의 강의 경험을 최적화하여 집필한 가장 얇은 WPF 개발 서적으로 군더더기 없이 WPF를 빨리 배울 수 있다. 간단한 연습 과제와 따라 하기 방식의 해당 풀이를 통해 컨트롤 및 레이아웃, 데이터 바인딩 등의 WPF 기본 사항들을 익히고 최종적으로는 MVVM 패턴을 사용한 WPF 응용 프로그램 예제를 만들어 본다. 한국어판에서는 좀 더 쉽게 이해할 수 있도록 스크린샷과 설명을 추가했다. 짧은 시간 내에 WPF 및 MVVM 패턴에 대한 내용을 익히고 실제 프로젝트에 적용하고자 한다면 WPF 개발 서적이 몇 없는 국내 현실에서 단비와 같은 이 책 한 권으로 의도한 바를 이룰 수 있을 것이다. 리뷰 WPF 기반 프로젝트를 하기 전에 WPF 에 대한 기본 개념을 잡기 위해 구매한 책이다. 기본 개념을 잡기 위해 구매한 책이라 그런지 입문하는 입장에서는 좋은 책 인 것 같지만 정말 기본만 배우게 되어 조금 아쉬웠다. 그래도 애플리케이션 생성과 데이터 바인딩, MVVM 패턴 등 중요한 용어에 대해 알려줘서 나중에 개발 시 구글 검색을 할 때 좋을 것 같았다. 코드 양은 얼마 없고 페이지 수도 짧아 일주일이 되지 않아 다 읽게 되었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"}]},{"title":"이것이 C#이다","slug":"book-c","date":"2019-01-09T09:13:33.000Z","updated":"2024-01-11T06:47:24.508Z","comments":true,"path":"2019/01/09/book-c/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/book-c/","excerpt":"","text":"책 정보 책 소개 한 번 배울 때 제대로, 기본기부터 탄탄히 다지고 간다! 이 책은 C# .NET 프레임워크 세계에 첫 발을 들이는 입문자를 위한 책이다. 따라서 딱딱하지 않은 대화식 표현으로 1:1 강의처럼 배울 수 있는 것이 이 책의 가장 큰 장점이다. 또한 C#의 핵심 문법은 물론, 프로그래밍 동작 원리까지도 입문자 입장에서 하나하나 꼼꼼히 설명하였다. 책을 덮을 때쯤이면 기초 문법부터, 고급 문법, 그리고 .NET 프레임워크의 활용까지 C#의 전반적인 큰 틀을 자연스레 익힐 수 있을 것이다.『이것이 C#이다』로 C# 프로그래밍을 시작한다면, 튼튼한 기본기가 갖춰져, 더 이상 실전과 응용도 두렵지 않습니다. 리뷰 개발 서적을 구매하고 공부하는 것을 좋아해서 찾아보다가 예전부터 알개발해 보고 싶었던 C# 책을 찾게 되었다. 마침 회사에서도 C#, WPF 기반 프로젝트를 수행하게 되어 급하게 알아보다가 이 책을 구매해서 역시나 코드를 보며 이해하였다. Java 개발을 몇년 간 한 경험으로 C# 코드를 봤을 때 정말 비슷한 점이 많고 오히려 더 쉽게 느껴졌다. 역시나 개발을 하면서 더 익숙해지겠지만 LINQ 나 람다식으로 인해 코드가 직관적이고 간결하게 표현되는 것을 보며 책을 구매하기 잘 했다고 생각하였다. 여러모로 만족이었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"}]},{"title":"[React] 설치 및 설정 방법","slug":"react-start","date":"2019-01-09T05:10:34.000Z","updated":"2024-01-11T06:32:36.105Z","comments":true,"path":"2019/01/09/react-start/","link":"","permalink":"http://hgko1207.github.io/2019/01/09/react-start/","excerpt":"","text":"리액트란 React는 사용자 인터페이스를 만들기 위해 페이스북과 인스타그램에서 개발한 오픈소스 자바스크립트 라이브러리로써, 사용자 인터페이스(User Interface)에 집중하며, Virtual DOM을 통해 속도와 편의를 높이고, 단방향 데이터플로우를 지원하여 보일러플레이트 코드를 감소시켜, 많은 사람들이 React를 MVC의 V를 고려하여 선택한다. 즉, React는 지속해서 데이터가 변하는 대규모 어플리케이션의 구축이라는 하나의 문제를 풀기 위해서 만들어졌다. 아래는 React에서 장점들이다. 단순함 : 당신의 어플리케이션이 어떤 주어진 시점에 어떻게 보여야 할지를 단순하게 표현함으로써, React는 그 데이터들이 변할 때, 자동적으로 모든 UI 업데이트들을 관리할 것이다. 선언적인 문법 : 데이터가 변할 때, React는 개념적으로 ‘새로고침’ 버튼을 눌러서, 변화된 부분을 알아채 업데이트하게 된다. 구성적인 컴포넌트 개발 : React는 재사용가능한 컴포넌트들을 개발하기 위한 모든 것이다. 사실, React로 당신이 할 수 있는 오직 한 가지는 컴포넌트를 개발하는 것이다. 그것들은 캡슐화되어있기 때문에, 컴포넌트들은 재사용될 수 있고, 테스트될 수 있으며, 관심의 분리(seperation of concerns)를 지키게 해 준다. 설치하기 리액트를 설치하고 프로젝트를 만들어 보자. 리액트 프로젝트를 만들 때는 Node.js 와 npm을 반드시 먼저 설치해야 한다. Node.js는 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임이다. 2009년 Node.js를 출시한 이후 자바스크립트는 웹 브라우저 영역 외에 웹 서버는 물론, 모바일 애플리케이션, 데스크톱 애플리케이션 영역에서도 엄청나게 활약할 수 있게 되었다. 1. Node.js 설치: Windows Node.js 공식 다운로드 페이지(https://nodejs.org/ko/download/)에서 Windows Installer를 다운로드하고 설치한다. 설치가 끝나면 터미널(또는 명령프롬프트) 창을 열고, 다음 명령어를 실행하여 제대로 설치했는지 확인한다. 12$ node -vv10.15.0 2. 에디터 설치 리액트 애플리케이션을 만들면서 코드를 수정할 때는 코드 에디터를 설치하여 사용하는 것이 편하다. 브래킷(Bracket), 아톰, VS Code를 써본 결과 모든 운영체제를 지원하는 VS Code를 사용하고 있다. VS Code 공식 다운로드 페이지(https://code.visualstudio.com/Download)에서 운영체제에 맞는 버전을 설치한다. 여기서는 Windows 버전을 설치한다. 이 에디터는 macOS, Window, 리눅스를 모두 지원한다. 3. create-react-app 설치 create-react-app 도구는 npm으로 설치할 수 있다. 패키지를 설치하는 방법은 두 가지가 있는데, 첫 번째는 지역적으로 설치하는 것이고, 두 번째는 전역적으로 설치하는 것이다. create-react-app은 커맨드라인 도구라서 모든 디렉터리에서 필요하므로 전역적으로 설치한다. 1$ npm install -g create-react-app 프로젝트 생성 프로젝트 생성할 때는 create-react-app &lt;프로젝트 이름&gt; 명령어를 사용한다. 123$ create-react-app test-react$ cd test-react$ npm start npm start 실행하여 완료했다면 http://localhost:3000/ 로 접속하여 확인한다. 프로젝트 구조 VS Code를 실행하여 만들어진 test-react 프로젝트를 열면 다음과 같은 구조로 만들어져 있다. 이미 modules 가 설치되어 있고, 의존성 패키지는 대부분 node_modules/react-scripts 모듈 내에 선언되어 있다. src 폴더안에 있는 파일들을 추가하고 수정하면서 개발을 하면 된다. 정리 리액트에 관심이 생겨 책을 읽고 검색한 내용들을 모아서 리액트에 대한 설명부터 설치, 프로젝트 실행까지 간략하게 설명하였다. 현재는 리액트를 공부하면서 정리하는 단계라서 현업에서 리액트 라이브러리를 사용하면서 겪는 이슈사항이나 팁은 추후에 정리할 예정이다. 참고 React 시작하기 [ReactJs] create-react-app으로 react 시작하기 [React] 1. 리액트 시작하기 개발 관련 강좌 사이트 리액트를 다루는 기술 출간 / 집필후기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"}]},{"title":"[React Native] Live Reload","slug":"react-enable-reload","date":"2019-01-08T08:59:53.000Z","updated":"2024-01-11T06:30:20.062Z","comments":true,"path":"2019/01/08/react-enable-reload/","link":"","permalink":"http://hgko1207.github.io/2019/01/08/react-enable-reload/","excerpt":"","text":"Live Reload 리액트 네이티브 기반으로 안드로이드 앱 개발을 할 때 자동으로 리로드 되게 하려면 어떻게 해야 할까. 리액트 기반으로 웹 개발을 할 때에는 코드를 수정 시 자동으로 리로드 되었는데 리액트 네이티브로 개발할 때에 자동으로 되지 않아 검색하던 중 아래 내용처럼 옵션 설정을 하니까 잘 동작하였다. 명령 프롬프트에서 다음을 입력하여 장치 또는 에뮬레이터에서 앱을 설치하고 실행한다.1$ react-native run-android 에뮬레이터를 클릭하고 CTRL + M ( MacOS의 경우 CMD + M )을 누르거나 실행 중인 응용 프로그램이 있는 Android 장치를 흔들면 된다. 팝업 메뉴에서 Enable Live Reload 옵션을 선택한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"}]},{"title":"[Eclipse RCP] 이클립스 플러그인 추가","slug":"eclipse-rcp","date":"2019-01-07T09:25:03.000Z","updated":"2024-01-11T06:25:35.836Z","comments":true,"path":"2019/01/07/eclipse-rcp/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/eclipse-rcp/","excerpt":"","text":"Eclipse Piug-in 추가 Eclipse에 플러그인을 추가하는 방법에는 두 가지가 있다. 첫 번째 방법은 플러그인을 직접 복사해서 설치하는 방법이고, 두 번째 방법은 Eclipse 에서 제공하는 Software Update Manager 를 활용하는 방법이다. 직접 복사하는 방법 설치하고자 하는 플러그인을 Eclipse_home/plugin 디렉터리에 복사한 다음 Eclipse를 재시작하면 새롭게 설치된 Eclipse 플러그인 기능을 활용할 수 있다. Software Update Manager를 활용하는 방법 Eclipse 에서 제공하는 Software Update Manager 기능은 플러그인을 개발한 곳에서 이 기능을 사용할 수 있도록 지원하지 않으면 사용할 수 없다. Eclipse 에서 Help-&gt;Install New Software로 이동 후 설치 할 플러그인 URL를 입력하여 다운받는다. 또 다른 방법은 Help-&gt;Eclipse Marketplace로 이동 후 설치 플러그인을 검색 후 다운로드한다. 이클립스 RCP Piug-in 구조 모든 플러그인의 실제 동작에 대한 정의는 코드에 들어있지만, 플러그인의 종속성과 서비스는 MANIFEST.MF와 plugin.xml 파일에서 선다. 이런 구조 덕분에 플러그인 코드가 당장 필요한 순간이 되어서야 로딩되는 늦은 로딩(lazy loading)이 가능하며, 이에 따라 이클립스의 시동 시간과 메모리 사용량을 줄일 수 있습니다. 이클립스 시동될 때는 플러그인 로더가 각 플러그인에 대한 MANIFEST.MF와 plugin.xml 파일 전부를 훑어본 다음, 플러그인에 대한 정보를 포함하는 구조체를 구성한다. Piug-in 선언(MANIFEST.MF) 각 번들 내역서 내에는 이름, ID, 버전, 플러그인 클래스, 프로바이더에 대한 항목이 들어 있다. 1. Piug-in ID 플러그인 ID(Bundle-SymbolicName)는 단 하나의 플러그인을 식별하기 위해 설계된 것이며 일반적으로 자바 패키지 이름 규약(예: com.&lt;회사명&gt;.&lt;제품명&gt;)을 이용해 구성된다. 2. Piug-in 버전 플러그인에 지정된 버전(Bundle-version)은 항상 3개의 수를 점으로 구분해 나열한 것이다. 첫 번째 수는 주 버전(major version)을 의미하며 두 번째는 부 버전(minor version), 세 번째는 서비스 레벨을 의미한다. 3. Piug-in 이름과 제공자 이름과 제공자는 둘 다 사람이 읽기 위한 텍스트이므로 어떻게 입력하든지 상관없고 또한 유일할 것일 필요도 없다. 4. Piug-in 클래스 선언 모든 플러그인은 필요한 경우에 플러그인 클래스(Bundle-Activator)를 지정할 수 있다. 5. Piug-in 런타임 MANIFEST.MF 파일의 Bundle-ClassPath 선언에는 플러그인 코드에 포함된 라이브러리(*.jar 파일) 를 콤마(‘ , ‘)로 구분해 나열한다. Bundle-ClassPath에서 정의한 라이브러리에 들어있는 패키지를 다른 플러그인에서 접근 할 수 있게 지정하려면 ExportPackage 선언을 써서 접근 가능하게 할 패키지를 콤마 구분 목록으로 지정한다. 6. Piug-in 종속성 플러그인 로더는 각 로딩된 플러그인마다 개별 클래스 로더의 인스턴스를 생성하며 내역서의 Require-Bundle 선언을 사용해 해당 플러그인이 실행 중 참조해야 할 플러그인이 어느 것인지를 지정한다. Piug-in 모델 이클립스는 처음 실행될 때 각 플러그인 디렉토리를 모두 돌아본 다음, 찾아낸 개별 플러그인을 표현하는 내부 모델을 구성한다. 개별 플러그인 전체를 로딩하지 않으며 플러그인 내역서만 검토한다. 1. Platform org.eclipse.core.runtime.Platform 클래스는 현재 실행 중인 이클립스 환경에 대한 정보를 제공한다. 이 클래스를 사용해 설치되어 있는 플러그인(번들), 확장, 확장점, 명령행 인자, 작업 관리자 등의 정보를 얻을 수 있다. 2. Piug-in 과 번들 Platform.getBundleGroupProviders() 나 Platform.getBundle(String)을 사용해 현재 설치된 플러그 인(번들)에 대한 정보를 얻을 수 있다. 플러그인 클래스, 즉 번들 액티베이터에 접근하려면 해당 플러그인을 로드해야 하지만 Bundle 인터페이스에는 별도의 부담 없이 접근할 수 있다. 3. Piug-in 확장 레지스트리 Platform.getExtensionRegistry() 메소드를 사용해서 플러그인 확장 레지스트리(extension registry)에 접근할 수 있다. 확장 레지스트리에는 각 플러그인을 표현하는 플러그인 디스크립터가 포함되어 있으며 플러그인을 로딩하지 않고도 다양한 플러그인 정보를 얻을 수 있는 메소드를 제공한다. Piug-in 개발 Piug-in Project 생성 New -&gt; Plug-in Project 클릭한다. Project name 입력 후 Next 클릭한다. ID에 패키지명 입력 Activator 패키지 명을 1)번에 입력한 패키지명과 같도록 입력 No 버튼 클릭 후 Next 클릭 “Hello, World Command” 선택 후 Finish 클릭한다. 위와 같이 플러그인 프로젝트가 생성되면 MANIFEST.MF 클릭 -&gt; Extensions 탭으로 이동 기본적으로 “Hello, World Command”를 선택하면 commands, handlers, bindings, menus 4개의 트리가 만들어진다. Commands는 실제 동작으로부터 독립적이며 선언적이고, org.eclipse.ui.commands 확장점을 통하여 정의되어 있다. 그리고 단축키(Key Binding)가 정의될 수 있고, 커맨드의 행동은 핸들러를 통하여 정의된다. Handlers는 commands로부터 명령을 받아 호출되고, 호출되자마자 클래스를 실행한다. 클래스를 정의할 때 org.eclipse.core.commands.AbstractHandler 클래스를 상속받는다. Execute() 메소드는 핸들러가 실행되면 호출 되며, HandlerUtil 클래스를 통하여 서비스에 접근할 수 있다. Bindings는 메뉴에 단축키를 지정할 수 있다. Menus는 애플리케이션 메인 메뉴, 툴바, 뷰 툴바, 팝업메뉴를 만들 수 있다. org.eclipse.ui.menus 에서 menuContribution는 사용자 인터페이스에서 메뉴가 표시되는 위치를 정의할 수 있는 locationURI 속성을 가지고 있다. locationURI 속성에는 기본적으로 menu:와 toolbar:, popup: 으로 시작하며 그 다음에는 메뉴가 표시될 위치를 지정할 수 있다. 예를 들어, 파일 메뉴(ID:fileMenu)의 하의 메뉴에 위치시키려면 다음와 같은 위치식을 이용한다. 12// 예)menu:fileMenu?after=addition Piug-in 배포 플러그인을 만들었으면 jar로 생성해야 합니다. Export -&gt; Plug-in Development -&gt; Deployable plug-ins and fragments 선택 후 Next 클릭한다. 배포하는 플러그인 프로젝트를 선택하고, Directory란에 배포하는 폴더를 지정하고, Finish를 클릭한다. 지정한 폴더에 jar로 배포가 되는 것을 확인할 수 있다. 참고 이클립스 커맨드 튜토리얼 Eclipse RCP 란?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"}]},{"title":"도메인이란","slug":"it-domain","date":"2019-01-07T08:16:14.000Z","updated":"2024-01-11T06:27:57.981Z","comments":true,"path":"2019/01/07/it-domain/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/it-domain/","excerpt":"","text":"도메인 이름은 ‘인터넷에 연결된 컴퓨터들에 부여되는 교유의 문자 주소’ 정도라고 보시면 된다. 영어로는 DNS(Domain Name System)라고 합니다. 인터넷에 연결되어 있는 컴퓨터에 접속하려면 IP 주소(Internet Protocol Address)를 알아야 합니다. 그런데 IP 주소는 기억하기가 힘듭니다. 매우 불편합니다. 그래서 쉽게 사이트의 주소를 기억하고 여기서 좀 더 나아가서 사이트의 특성을 파악할 수 있도록 고안된 것이 바로 '도메인 이름’입니다. 도메인은 각 컴퓨터 고유의 IP주소에 대응되는 문자로 된 인터넷 주소입니다. EX) 구글(google) 사이트 google . co . kr =&gt; 소속기관이름 . 소속기관 분류 . 소속국가 도메인은 크게 3단계로 구분됩니다. (인터넷 도입 초기에는 3단계였으나, 현재는 2단계도 혼용 사용, 예) .kr) 가) 최상위 도메인(2가지로 분류) 미국 최상위 도메인 : com, edu, net, org, gov, re, mil, int 국가 최상위 도메인 : kr, jp, cn 나) 2차 도메인 미국 최상위 도메인에서의 2차 도메인 : naver, yahoo, google 국가 최상위 도메인에서의 2차 도메인 : or, co, ac, ne 다) 3차 도메인 국가 최상위 도메인에서의 3차 도메인 : nate, yahoo com : 상업기관 co.kr : 상업기기관 + 국가도메인 net : 네트워크 관련 기관 go.kr : 정부기관 + 국가도메인 or.kr : 비영이/기타 기관 + 국가도메인 kr과 혼합된 주소는 한국 관련 회사를 뜻하는 것입니다.","categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"}]},{"title":"[JPA] Annotation 정리","slug":"jpa-annotation","date":"2019-01-07T05:15:34.000Z","updated":"2024-01-11T06:29:56.163Z","comments":true,"path":"2019/01/07/jpa-annotation/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/jpa-annotation/","excerpt":"","text":"JPA 로 개발하면서 자주 사용하는 어노테이션을 정리하였다. @Entity 해당 클래스가 엔티티임을 알리기 위해 사용한다. 애플리케이션이 실행이 될 때 엔티티 자동검색을 통하여 이 어노테이션이 선언된 클래스들은 엔티티 빈으로 등록한다. @Table 데이터의 저장소, 테이블을 의미한다. name 값은 실제 데이터베이스의 테이블 명을 의미하며, 생략이 가능한다. 어노테이션을 생략하면 클래스의 이름을 테이블의 이름으로 자동 인식하게 된다. @Id 엔티티빈의 기본키를 의미한다. 이 어노테이션은 하나의 엔티티에는 반드시 하나가 존재해야 한다. 복수키도 설정할 수 있다. @GeneratedValue 데이터베이스에 의해 자동으로 생성된 값이라는 의미다. 즉, 프로그램 상에서 조작된 데이터가 아닌, 실제 데이터베이스에 데이터가 영속(저장)될 때 생성되는 값이다. 몇 가지 생성전략이 존재한다. IDENTITY : 기본 키 생성을 데이터베이스가 함 SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키 할당 TABLE : 키 생성 테이블 생성 @Column 필드와 테이블의 컬럼을 매핑시켜 준다. 이 어노테이션은 생략이 가능하며, 생략 시 필드의 이름이 테이블의 컬럼으로 자동으로 매핑이 된다. name속성(String) 필드와 매핑 될 컬럼의 이름을 명시한다. nullable속성(boolean) 해당 컬럼이 null값을 허용하는가 하지않는 가의 여부다. length속성(int) 컬럼의 길이값을 의미합니다. unique속성(boolean) 컬럼이 유일한 값을 가져야 하는가 아닌가의 여부다. insertable속성(boolean) 엔티티가 영속될 때 insert에 참여할지 말지를 결정한다. 기본값은 true updatable속성(boolean) 변경된 필드의 값을 테이블에도 반영할지를 결정한다. 기본값은 true name 속성을 제외한 나머지 속성은 잘 사용되지 않을 것이라고 생각된다. nullable, length, unique는 DDL과 관련된 속성이고, insertable, updatable은 원래 잘 사용되지 않는 속성이기 때문이다. @Temporal java.util.Date와 java.util.Calendar 값을 매핑할 때 사용한다. TemporalType.Date : 년-월-일 의 date 타입 (2019-01-04) TemporalType.Time : 시:분:초 의 time 타입 (12:11:11) TemporalType.TIMESTAMP : date + time의 timestamp(datetime) 타입 (2019-01-04 12:11:11) 어노테이션을 사용하지 않을 경우 기본값은 timestamp 다. JPA 데이터베이스 방언에 의해, 데이터베이스의 타입에 따른 timestamp 또는 datetime은 자동으로 작성된다. @ColumnPosition(1) 컬럼 순서 정한다. @Enumerated 자바의 enum 타입을 매핑할 때 사용한다. 속성으로 EnumType.ORDINAL 과 EnumType.STRING 이 존재하는데 이름 그대로 ORDINAL은 순서를 STRING은 Enum의 이름을 저장한다. @LOB 데이터베이스 BLOB, CLOB 타입과 매핑된다. CLOB(String, char[], java.sql.CLOB)은 문자, BLOB(byte[], java.sql.BLOB)은 나머지가 매핑된다. @Transient 저장 조회에 사용되지도 않고 그냥 단순 값을 가지고 있고 싶을 때 사용한다. @Access 데이터베이스에 엔티티에 값이 저장될 때 필드(AccessType.FIELD)의 값을 직접 접근해서 사용할 것인가 아니면 메서드에 직접(AccessType.PROPERTY) 접근할 것 인가를 설정하는 것이다. @MappedSuperClass 어노테이션을 사용하면 부모 엔티티 접근 없이 부모 클래스의 매핑정보를 사용할 수 있다. 부모의 내용을 별도로 재정의해서 사용하고 싶은 경우에는 @AttributeOverride를 사용하여 재정의 한다. 여러 개를 한번에 정의하기 위해서는 @AttributeOverrides를 사용한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"}]},{"title":"리액트를 다루는 기술","slug":"book-react-technology","date":"2019-01-07T04:53:57.000Z","updated":"2024-01-11T06:47:29.806Z","comments":true,"path":"2019/01/07/book-react-technology/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-react-technology/","excerpt":"","text":"책 정보 책소개 리액트를 이해하기 위한 핵심 개념은 물론이고 어떤 상황에서 어떻게 사용해야 하는지, 왜 이렇게 사용하는 것이 효과적인지를 배우자. 공식 문서에는 나오지 않는 실전 노하우와 팁을 풍부하게 담았다. 또한, 프로젝트 생성부터 코드를 작성 및 개선하고, 배포하기까지 실무에 바로 응용할 수 있도록 예제를 준비했다. 일정 관리 애플리케이션을 만들면서 리액트의 기본기를 다지고, 프로젝트를 진행하면서 컴포넌트 스타일링, 상태 관리, API 연동, 라우팅, 코드 스플리팅, 서버사이드 렌더링 등 리액트를 활용한 다양한 기술을 사용해 보자. 마지막으로 마크다운 기반의 블로그 시스템을 만들며 배운 지식을 종합적으로 활용해 보자. 리뷰 작년에 처음으로 AngularJS를 사용하여 프로젝트를 하면서 접한 이후로 관심이 생겨 최신 버전인 Angular6을 공부하였었는데 뭔가 착 달라붙는다는 느낌이 들지 않아 잠깐 공부를 멈췄다. 최근에 다시 새로운 기술을 공부하고 싶어 찾던 중에 리액트가 자바스크립트 라이브러리라서 접근하기가 쉽고 이해도도 빠를 것 같아 책을 바로 구매하게 되었다. 책을 사면 예제를 직접 하나씩 다 코딩하면서 공부하는 타입이라서 이번에도 모두 다 코딩을 하면서 익숙해져 갔다. 그런데 책에 있는 예제들이 자바스크립트라서 익숙하긴 한데 리액트 초보자에게는 조금 어렵다는 느낌이 들었다. 그래도 열심히 따라서 코딩한 덕분에 흐름을 이해할 수 있었다. 리액트를 알게 되면서 리액트 네이티브에 대해서도 공부하고 싶은데 출간된 책이 많이 없는 것 같아 아쉬웠다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"}]},{"title":"[Android] Tab 구성 시 주의사항","slug":"android-tab","date":"2019-01-07T04:42:09.000Z","updated":"2024-01-11T06:22:45.145Z","comments":true,"path":"2019/01/07/android-tab/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/android-tab/","excerpt":"","text":"FragmentStatePagerAdapter의 getItem() 이 두 번 호출될 때 Viewpager를 사용하여 Tab 을 구성하였을 때 FragmentStatePagerAdapter를 사용하였다. 탭에 추가한 Fragment 와는 상관없이 getItem() 이 두 번 호출이 되어서 Fragment 를 두 번 로드하게 되는 현상 때문에 문제가 생겨 꼬이게 되었다. 이럴 경우 Fragment 화면이 보일 때와 보이지 않을 때 setUSerVisiblaHint() 함수를 사용하여 처리하는데 탭에 추가한 Fragment가 전부 로드되지 않고 어중간하게 두 개의 화면만 로드되었기 때문에 다른 탭을 누르거나 다시 돌아왔을 때 setUSerVisiblaHint() 와 onCreateView() 함수가 비정상적으로 호출되는 바람에 코딩을 하는데 애먹었다. 그래서 찾은 방법은 아래 코드 처럼 ViewPagerAdapter에 Fragment를 3개 추가 하였을 때 setOffscreenPageLimit() 함수에 viewPager 에 추가한 Fragement 의 수를 지정하여 화면이 미리 로드되게 하면 getItem() 은 Fragement 수 만큼(예: 3번) 호출되지만 앞에서 문제되는 것을 해결할 수 있었다. 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tabs) TabLayout tabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); setupViewPager(); &#125; private void setupViewPager() &#123; ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager()); viewPagerAdapter.addFragment(new MobileFragment()); viewPagerAdapter.addFragment(new LteFragment()); viewPagerAdapter.addFragment(new WifiFragment()); viewPager.setOffscreenPageLimit(viewPagerAdapter.getCount()); viewPager.setAdapter(viewPagerAdapter); tabLayout.setupWithViewPager(viewPager); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"}]},{"title":"[JavaScript] Chart 라이브러리 정리","slug":"javascript-chart","date":"2019-01-07T04:19:53.000Z","updated":"2024-01-11T06:28:52.168Z","comments":true,"path":"2019/01/07/javascript-chart/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/javascript-chart/","excerpt":"","text":"웹 개발을 하면서 사용해 본 Chart 를 정리 해보았다. 무료인 것도 있고 조건부 무료인 차트도 있다. 대부분 사용하기에 편리하여 적용하기도 쉽고 심플하고 이쁜 디자인도 많고 예제와 설명이 잘 되어있어 좋았다. 1. AmCharts 링크 : ​https://www.amcharts.com/ 예제 : http://www.amcharts.com/demos/ 유료 라이선스 이지만 조건부 무료다. 사용해 본 라이브러리 중에 기능이 엄청 많고 디자인이 제일 깔끔하다. 라이선스 비용은 개인이 사용하기에는 부담이 될 수 있지만, 차트에 개발사 링크가 출력되는 조건만 지키면 무료로 사용 가능하다. 2. HighCharts 링크 : https://www.highcharts.com/ amCharts와 같이 조건부 무료입니다. Angular에서도 쓸 수 있고, 차트 종류도 다양하고, 사용법이 편리하며 커스터마이징도 쉽게 할 수 있다. 현재 가장 많이 사용하는 차트다. 3. D3 Data-Driven Documents 링크 : https://d3js.org/ 무료입니다. 데이터 시각화 프레임워크로 잘 알려져 있고, 자바스크립트로 개발을 한다. HTML5의 SVG(Scalable Vector Graphic)을 통해 다양한 화면 해상도에서 깨짐 없는 가시화가 가능하다. D3 차트에서는 버블차트와 OpenLayers3에 파이차트를 올려 사용하였다. D3는 기본적인 개념과 사용법을 익혀야 사용이 가능하므로 공부를 많이 해야 한다. 4. Chart.js 링크 : http://www.chartjs.org/ 예제 : http://www.chartjs.org/docs/latest/ 오픈소스이며, 전체적으로 깔끔하고 문서도 정리가 잘 되어 있습니다. 인기가 많고, 사용법이 편리하고 이쁩니다. 5. Google Chart 링크 : https://developers.google.com/chart/ 구글 차트는 많이 사용해보지 못하였지만, 기능은 많습니다. 하지만 디자인이 다른 차트에 비해 이쁘지 않은 것 같아 많이 사용하지 않았습니다. 그렇지만 사용하기는 편리합니다. 6. Morris.js 링크 : http://morrisjs.github.io/morris.js/ 무료이며 사용이 정말 간단합니다. 그리고 디자인도 심플한 편이라 간단하게 테스트 용으로 많이 사용하였습니다. 7. Chartist.js 링크 : http://gionkunz.github.io/chartist-js/ Chartist 또한 인기있는 Chart Javascript 라이브러리 중의 하나로 SVG를 사용하며, CSS를 통해 모양을 다듬을 수 있습니다. 위의 차트들이 자주 사용하는 차트들입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"}]},{"title":"[Cesium] 초기 설정","slug":"cesium-init","date":"2019-01-07T02:37:21.000Z","updated":"2024-01-11T06:24:54.384Z","comments":true,"path":"2019/01/07/cesium-init/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/cesium-init/","excerpt":"","text":"GIS 관련 프로젝트를 하다 보니 오픈소스인 CesiumJS 나 Openlayers 라이브러리를 사용하게 되었다. 최근에는 2D, 3D 모드가 가능한 CesiumJS를 주로 사용하게 되었다. Cesium 이란? 순수 웹 기불을 이용한 3D Globe 엔진 WebGL 기반 다양한 배경 영상/지도 기본 제공 3D / 2.5D / 2D 모드 지원 -&gt; Openlayers3에 통합 카메라 움직임 추적, 시간 시뮬레이션 등 다양한 기능 제공 Cesium 을 시작할 때 초기 설정이 복잡하다. 아래 두 개의 링크를 따라가서 따라 하면 쉽게 할 수 있다. 하지만 웹에서 커스터마이징을 하기 위해 아래 코드처럼 Cesium에서 지원하는 기본적인 기능들을 끄고 지도만 보이도록 설정해야 한다. API들은 문서나 인터넷 검색으로 찾아봅시다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- Include the CesiumJS JavaScript and CSS files --&gt; &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.81/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt; &lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; imageryProvider: new Cesium.WebMapServiceImageryProvider(&#123; url: 'http://localhost:8080/geoserver/gwc/service/wms', layers: 'osm:osm', parameters: &#123; service: 'WMS', version: '1.1.1', request: 'GetMap', layers: 'osm:osm', srs: 'EPSG:3857', crs: 'EPSG:3857', format: 'image/png', tranparent: true, tiled: true, &#125;, tilingScheme: new Cesium.WebMercatorTilingScheme(), &#125;), animation: false, baseLayerPicker: false, fullscreenButton: false, vrButton: false, geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, selectionIndicator: false, timeline: false, navigationHelpButton: false, projectionPicker: false, selectedEntity: false, trackedEntity: false, clockTrackedDataSource: false, &#125;); const scene = viewer.scene; const camera = viewer.camera; const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas); const ellipsoid = scene.globe.ellipsoid; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 위의 예제는 미리 구축된 Geoserver 를 베이스 맵으로 설정하였다. Geoserver 가 구축되지 않았다면 Cesium에서 제공되는 기본 Provider를 사용하면 된다. 123456&lt;!-- 예시 --&gt;&lt;script&gt; const viewer = new Cesium.Viewer('cesiumContainer', &#123; terrainProvider: Cesium.createWorldTerrain(), // 기본 지도를 지형지도로 셋팅 &#125;);&lt;/script&gt; 참고 https://cesium.com/docs/tutorials/quick-start/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"깡샘의 안드로이드 프로그래밍","slug":"book-ggangsam","date":"2019-01-07T01:09:21.000Z","updated":"2024-01-11T06:47:33.060Z","comments":true,"path":"2019/01/07/book-ggangsam/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/book-ggangsam/","excerpt":"","text":"책 정보 책 소개 이 책은 각 챕터마다 안드로이드 프로그램과 각 기능이 어떠한 구조로 어떻게 작동하는지 그 원리를 파악하는 데 주력합니다. 그리고 이를 구현하는 핵심 코드를 알아본 다음, 이를 종합하여 실제 상용 앱에서 많이 사용하는 기능을 직접 개발해 보는 실습을 진행합니다. 그리고 각 파트별로 도전 과제를 통해 학습자 스스로 주어진 조건에 맞는 앱을 만들어봄으로써 앞에서 배운 이론과 실습을 복기하고 문제 해결 능력을 기를 수 있게 구성하였습니다. 한 마디로 체계적이고 따라 하기 쉽습니다. 리뷰 최근에 안드로이드를 다시 공부하면서 보는 책이다. 안드로이드 스튜디오 3.0 기반으로 개발할 수 있도록 해주며, 끝에는 Kotlin 까지 나온다. 그리고 예제도 다양하여 도움이 많이 되었다.","categories":[{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"}]},{"title":"[Angular] 강좌 추천","slug":"angular","date":"2019-01-07T00:55:40.000Z","updated":"2024-01-11T06:23:13.935Z","comments":true,"path":"2019/01/07/angular/","link":"","permalink":"http://hgko1207.github.io/2019/01/07/angular/","excerpt":"","text":"Angular 강좌 추천 작년에 Angular1 즉 AngluarJS를 Spring Framework + Spring JPA + MySQL 합쳐서 연동하여 개발하였다. 그 때에 AngularJS 를 처음 접해보았고, 제가 아는 분에게 배우기도 해서 일부분을 개발하다가 하나의 프로젝트를 처음부터 만들어 보았었다. 그 이후로 Angular 를 사용하지 않았었는데, 지금 벌써 Angular 6 버전 까지 나와서 놀랐다. 아래 URL은 Angular 6 은 아니지만 Angular 5 버전 강좌다. NodeJS 와 Typescript 가 대세여서 공부해보려고 하다가 Angular를 다시 보게 되어 찾다가 이 강좌가 설명이 너무 잘 되어 있어서 공부를 하는 중이다. 여러모로 감사합니다. URL: https://moon9342.github.io/angular-lecture-introduction","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"}]},{"title":"[Web Design] Metronic Dashboard","slug":"dashboard","date":"2019-01-04T09:13:00.000Z","updated":"2024-01-11T06:22:12.990Z","comments":true,"path":"2019/01/04/dashboard/","link":"","permalink":"http://hgko1207.github.io/2019/01/04/dashboard/","excerpt":"","text":"대시보드 템플릿 웹 개발을 하다 보면 작은 프로젝트인데도 디자인 요청이 있다. 그럴 때마다 디자인된 부트스트랩 기반 템플릿을 찾곤 했었다. 매번 디자인이 아쉽고 템플릿을 사용하여도 직접 CSS를 작업하는 경우가 많았는데 지인의 추천으로 Metronic을 알게 되었다. Metronic - Responsive Admin Dashboard Template The World’s #1 Bootstrap 4 HTML, Angular 9, React, VueJS &amp; Laravel Admin Dashboard Theme 이 템플릿은 사용하기도 편하고 디자인도 요즘 트렌드에 맞게 계속 업데이트를 하고 있다. 알아둘 점은 유료다. 구매비용이 저렴한 것에 비해 다양한 컴포넌트들이 있고 10가지 이상의 템플릿을 제공해 준다. 한 마디로 가성비가 최고다. React, Angular, Vue에서 사용 가능하며 업데이트될 때마다 바로 적용되는 점이 매우 좋다. 이 템플릿을 쓰려면 구조와 사용법을 공부를 해야 하는 시간이 조금 소요되지만 커스텀하기가 편해서 자주 사용하고 있다. 물론 직접 프론트엔드를 개발하면서 하면 좋지만 편리하고 빠르게 개발하기 위해 템플릿들을 써서 개발하는 것도 좋은 것 같다. 단점이라면 포함된 기능들이 많아 초기에 로드할 때 느리다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"}]}],"categories":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/categories/IT/"},{"name":"Information","slug":"IT/Information","permalink":"http://hgko1207.github.io/categories/IT/Information/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"http://hgko1207.github.io/categories/Programming/Language/"},{"name":"JavaScript","slug":"Programming/Language/JavaScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/JavaScript/"},{"name":"Frontend","slug":"Programming/Frontend","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/"},{"name":"WPF","slug":"Programming/Frontend/WPF","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WPF/"},{"name":"HTML, CSS","slug":"Programming/Frontend/HTML-CSS","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/HTML-CSS/"},{"name":"Web","slug":"Programming/Web","permalink":"http://hgko1207.github.io/categories/Programming/Web/"},{"name":"React","slug":"Programming/Frontend/React","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/React/"},{"name":"AI","slug":"Programming/AI","permalink":"http://hgko1207.github.io/categories/Programming/AI/"},{"name":"TypeScript","slug":"Programming/Language/TypeScript","permalink":"http://hgko1207.github.io/categories/Programming/Language/TypeScript/"},{"name":"Git","slug":"IT/Git","permalink":"http://hgko1207.github.io/categories/IT/Git/"},{"name":"DevOps","slug":"Programming/DevOps","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/"},{"name":"Linux","slug":"Programming/DevOps/Linux","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Linux/"},{"name":"Python","slug":"Programming/Language/Python","permalink":"http://hgko1207.github.io/categories/Programming/Language/Python/"},{"name":"C#","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Vue","slug":"Programming/Frontend/Vue","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Vue/"},{"name":"WinUI","slug":"Programming/Frontend/WinUI","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/WinUI/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"http://hgko1207.github.io/categories/IT/Blockchain/"},{"name":"ETC","slug":"ETC","permalink":"http://hgko1207.github.io/categories/ETC/"},{"name":"Angular","slug":"Programming/Frontend/Angular","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Angular/"},{"name":"Backend","slug":"Programming/Backend","permalink":"http://hgko1207.github.io/categories/Programming/Backend/"},{"name":"Node.js","slug":"Programming/Backend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Node-js/"},{"name":"Flutter","slug":"Programming/Frontend/Flutter","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Flutter/"},{"name":"NestJS","slug":"Programming/Backend/NestJS","permalink":"http://hgko1207.github.io/categories/Programming/Backend/NestJS/"},{"name":"Dart","slug":"Programming/Language/Dart","permalink":"http://hgko1207.github.io/categories/Programming/Language/Dart/"},{"name":"Next.js","slug":"Programming/Frontend/Next-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Next-js/"},{"name":"Book","slug":"Book","permalink":"http://hgko1207.github.io/categories/Book/"},{"name":"DB","slug":"Programming/DB","permalink":"http://hgko1207.github.io/categories/Programming/DB/"},{"name":"Elasticsearch","slug":"Programming/DB/Elasticsearch","permalink":"http://hgko1207.github.io/categories/Programming/DB/Elasticsearch/"},{"name":"MySQL","slug":"Programming/DB/MySQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MySQL/"},{"name":"Spring","slug":"Programming/Backend/Spring","permalink":"http://hgko1207.github.io/categories/Programming/Backend/Spring/"},{"name":"BlockChain","slug":"IT/BlockChain","permalink":"http://hgko1207.github.io/categories/IT/BlockChain/"},{"name":"Java","slug":"Programming/Language/Java","permalink":"http://hgko1207.github.io/categories/Programming/Language/Java/"},{"name":"PostgreSQL","slug":"Programming/DB/PostgreSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/PostgreSQL/"},{"name":"Oracle","slug":"Programming/DB/Oracle","permalink":"http://hgko1207.github.io/categories/Programming/DB/Oracle/"},{"name":"Satellite","slug":"IT/Satellite","permalink":"http://hgko1207.github.io/categories/IT/Satellite/"},{"name":"MariaDB","slug":"Programming/DB/MariaDB","permalink":"http://hgko1207.github.io/categories/Programming/DB/MariaDB/"},{"name":"MyBatis","slug":"Programming/Backend/MyBatis","permalink":"http://hgko1207.github.io/categories/Programming/Backend/MyBatis/"},{"name":"Go","slug":"Programming/Language/Go","permalink":"http://hgko1207.github.io/categories/Programming/Language/Go/"},{"name":"Mobile","slug":"Programming/Mobile","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/"},{"name":"Android","slug":"Programming/Mobile/Android","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/Android/"},{"name":"MATLAB","slug":"Programming/Language/MATLAB","permalink":"http://hgko1207.github.io/categories/Programming/Language/MATLAB/"},{"name":"C++","slug":"Programming/Language/C","permalink":"http://hgko1207.github.io/categories/Programming/Language/C/"},{"name":"Kubernetes","slug":"Programming/DevOps/Kubernetes","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Kubernetes/"},{"name":"Docker","slug":"Programming/DevOps/Docker","permalink":"http://hgko1207.github.io/categories/Programming/DevOps/Docker/"},{"name":"Node.js","slug":"Programming/Frontend/Node-js","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Node-js/"},{"name":"MSSQL","slug":"Programming/DB/MSSQL","permalink":"http://hgko1207.github.io/categories/Programming/DB/MSSQL/"},{"name":"Eclipse RCP","slug":"Programming/Frontend/Eclipse-RCP","permalink":"http://hgko1207.github.io/categories/Programming/Frontend/Eclipse-RCP/"},{"name":"Hexo","slug":"IT/Hexo","permalink":"http://hgko1207.github.io/categories/IT/Hexo/"},{"name":"React Native","slug":"Programming/Mobile/React-Native","permalink":"http://hgko1207.github.io/categories/Programming/Mobile/React-Native/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://hgko1207.github.io/tags/IT/"},{"name":"Developer","slug":"Developer","permalink":"http://hgko1207.github.io/tags/Developer/"},{"name":"Programming","slug":"Programming","permalink":"http://hgko1207.github.io/tags/Programming/"},{"name":"기술","slug":"기술","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%88%A0/"},{"name":"Coding","slug":"Coding","permalink":"http://hgko1207.github.io/tags/Coding/"},{"name":"Coding Tips","slug":"Coding-Tips","permalink":"http://hgko1207.github.io/tags/Coding-Tips/"},{"name":"Programming Tips","slug":"Programming-Tips","permalink":"http://hgko1207.github.io/tags/Programming-Tips/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hgko1207.github.io/tags/JavaScript/"},{"name":"Web Development","slug":"Web-Development","permalink":"http://hgko1207.github.io/tags/Web-Development/"},{"name":"Web Developer","slug":"Web-Developer","permalink":"http://hgko1207.github.io/tags/Web-Developer/"},{"name":"Javascript Development","slug":"Javascript-Development","permalink":"http://hgko1207.github.io/tags/Javascript-Development/"},{"name":"Javascript Tips","slug":"Javascript-Tips","permalink":"http://hgko1207.github.io/tags/Javascript-Tips/"},{"name":"C#","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"http://hgko1207.github.io/tags/WPF/"},{"name":".NET 개발자","slug":"NET-개발자","permalink":"http://hgko1207.github.io/tags/NET-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"Web","slug":"Web","permalink":"http://hgko1207.github.io/tags/Web/"},{"name":"Web Design","slug":"Web-Design","permalink":"http://hgko1207.github.io/tags/Web-Design/"},{"name":"SEO","slug":"SEO","permalink":"http://hgko1207.github.io/tags/SEO/"},{"name":"Responsive Design","slug":"Responsive-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Design/"},{"name":"Scss","slug":"Scss","permalink":"http://hgko1207.github.io/tags/Scss/"},{"name":"KeyBinding","slug":"KeyBinding","permalink":"http://hgko1207.github.io/tags/KeyBinding/"},{"name":"Responsive Web Design","slug":"Responsive-Web-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Web-Design/"},{"name":"Responsive Website Design","slug":"Responsive-Website-Design","permalink":"http://hgko1207.github.io/tags/Responsive-Website-Design/"},{"name":"React","slug":"React","permalink":"http://hgko1207.github.io/tags/React/"},{"name":"React Native","slug":"React-Native","permalink":"http://hgko1207.github.io/tags/React-Native/"},{"name":"Front End Development","slug":"Front-End-Development","permalink":"http://hgko1207.github.io/tags/Front-End-Development/"},{"name":"React.js","slug":"React-js","permalink":"http://hgko1207.github.io/tags/React-js/"},{"name":"Chrome","slug":"Chrome","permalink":"http://hgko1207.github.io/tags/Chrome/"},{"name":"Developer Tools","slug":"Developer-Tools","permalink":"http://hgko1207.github.io/tags/Developer-Tools/"},{"name":"Chrome Extension","slug":"Chrome-Extension","permalink":"http://hgko1207.github.io/tags/Chrome-Extension/"},{"name":"웹 개발자","slug":"웹-개발자","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"웹 개발","slug":"웹-개발","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"풀스택","slug":"풀스택","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D/"},{"name":"풀스택 개발자","slug":"풀스택-개발자","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D-%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"풀스택 개발","slug":"풀스택-개발","permalink":"http://hgko1207.github.io/tags/%ED%92%80%EC%8A%A4%ED%83%9D-%EA%B0%9C%EB%B0%9C/"},{"name":"AI","slug":"AI","permalink":"http://hgko1207.github.io/tags/AI/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://hgko1207.github.io/tags/Artificial-Intelligence/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://hgko1207.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://hgko1207.github.io/tags/OpenAI/"},{"name":"ChatGPT-4","slug":"ChatGPT-4","permalink":"http://hgko1207.github.io/tags/ChatGPT-4/"},{"name":"ChatGPT-4o","slug":"ChatGPT-4o","permalink":"http://hgko1207.github.io/tags/ChatGPT-4o/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hgko1207.github.io/tags/TypeScript/"},{"name":"Class","slug":"Class","permalink":"http://hgko1207.github.io/tags/Class/"},{"name":"Interface","slug":"Interface","permalink":"http://hgko1207.github.io/tags/Interface/"},{"name":"TypeScript Tip","slug":"TypeScript-Tip","permalink":"http://hgko1207.github.io/tags/TypeScript-Tip/"},{"name":"Type","slug":"Type","permalink":"http://hgko1207.github.io/tags/Type/"},{"name":"Gpt","slug":"Gpt","permalink":"http://hgko1207.github.io/tags/Gpt/"},{"name":"Customgpt","slug":"Customgpt","permalink":"http://hgko1207.github.io/tags/Customgpt/"},{"name":"Productivity Tools","slug":"Productivity-Tools","permalink":"http://hgko1207.github.io/tags/Productivity-Tools/"},{"name":"Freelancing","slug":"Freelancing","permalink":"http://hgko1207.github.io/tags/Freelancing/"},{"name":"Freelancers","slug":"Freelancers","permalink":"http://hgko1207.github.io/tags/Freelancers/"},{"name":"Freelance","slug":"Freelance","permalink":"http://hgko1207.github.io/tags/Freelance/"},{"name":"HTML5","slug":"HTML5","permalink":"http://hgko1207.github.io/tags/HTML5/"},{"name":"typeof","slug":"typeof","permalink":"http://hgko1207.github.io/tags/typeof/"},{"name":"instanceof","slug":"instanceof","permalink":"http://hgko1207.github.io/tags/instanceof/"},{"name":"literal","slug":"literal","permalink":"http://hgko1207.github.io/tags/literal/"},{"name":"Mapped Types","slug":"Mapped-Types","permalink":"http://hgko1207.github.io/tags/Mapped-Types/"},{"name":"Indexed Access Types","slug":"Indexed-Access-Types","permalink":"http://hgko1207.github.io/tags/Indexed-Access-Types/"},{"name":"Advanced Typescript","slug":"Advanced-Typescript","permalink":"http://hgko1207.github.io/tags/Advanced-Typescript/"},{"name":"Strict Type","slug":"Strict-Type","permalink":"http://hgko1207.github.io/tags/Strict-Type/"},{"name":"strict","slug":"strict","permalink":"http://hgko1207.github.io/tags/strict/"},{"name":"프롬프트","slug":"프롬프트","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"ChatGPT 프롬프트","slug":"ChatGPT-프롬프트","permalink":"http://hgko1207.github.io/tags/ChatGPT-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"Generic","slug":"Generic","permalink":"http://hgko1207.github.io/tags/Generic/"},{"name":"Namespace","slug":"Namespace","permalink":"http://hgko1207.github.io/tags/Namespace/"},{"name":"Custom Module","slug":"Custom-Module","permalink":"http://hgko1207.github.io/tags/Custom-Module/"},{"name":"Type Guard","slug":"Type-Guard","permalink":"http://hgko1207.github.io/tags/Type-Guard/"},{"name":"Signature","slug":"Signature","permalink":"http://hgko1207.github.io/tags/Signature/"},{"name":"Overload","slug":"Overload","permalink":"http://hgko1207.github.io/tags/Overload/"},{"name":"Advanced Types","slug":"Advanced-Types","permalink":"http://hgko1207.github.io/tags/Advanced-Types/"},{"name":"keyof/typeof","slug":"keyof-typeof","permalink":"http://hgko1207.github.io/tags/keyof-typeof/"},{"name":"Html Attribute","slug":"Html-Attribute","permalink":"http://hgko1207.github.io/tags/Html-Attribute/"},{"name":"인공지능","slug":"인공지능","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Meta AI","slug":"Meta-AI","permalink":"http://hgko1207.github.io/tags/Meta-AI/"},{"name":"Facebook","slug":"Facebook","permalink":"http://hgko1207.github.io/tags/Facebook/"},{"name":"Prompt Engineering","slug":"Prompt-Engineering","permalink":"http://hgko1207.github.io/tags/Prompt-Engineering/"},{"name":"Set/Get","slug":"Set-Get","permalink":"http://hgko1207.github.io/tags/Set-Get/"},{"name":"Protected","slug":"Protected","permalink":"http://hgko1207.github.io/tags/Protected/"},{"name":"Private/Public/Static","slug":"Private-Public-Static","permalink":"http://hgko1207.github.io/tags/Private-Public-Static/"},{"name":"클래스","slug":"클래스","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"OOP","slug":"OOP","permalink":"http://hgko1207.github.io/tags/OOP/"},{"name":"상속","slug":"상속","permalink":"http://hgko1207.github.io/tags/%EC%83%81%EC%86%8D/"},{"name":"객체 지향 프로그래밍","slug":"객체-지향-프로그래밍","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"Any","slug":"Any","permalink":"http://hgko1207.github.io/tags/Any/"},{"name":"Void","slug":"Void","permalink":"http://hgko1207.github.io/tags/Void/"},{"name":"Never","slug":"Never","permalink":"http://hgko1207.github.io/tags/Never/"},{"name":"Strict Null Checks","slug":"Strict-Null-Checks","permalink":"http://hgko1207.github.io/tags/Strict-Null-Checks/"},{"name":"Typed Functions","slug":"Typed-Functions","permalink":"http://hgko1207.github.io/tags/Typed-Functions/"},{"name":"Function Signature","slug":"Function-Signature","permalink":"http://hgko1207.github.io/tags/Function-Signature/"},{"name":"Union","slug":"Union","permalink":"http://hgko1207.github.io/tags/Union/"},{"name":"Literal","slug":"Literal","permalink":"http://hgko1207.github.io/tags/Literal/"},{"name":"Tagged Type","slug":"Tagged-Type","permalink":"http://hgko1207.github.io/tags/Tagged-Type/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://hgko1207.github.io/tags/VS-Code/"},{"name":"생산성 향상","slug":"생산성-향상","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1-%ED%96%A5%EC%83%81/"},{"name":"개발자","slug":"개발자","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"VS Code 확장 프로그램","slug":"VS-Code-확장-프로그램","permalink":"http://hgko1207.github.io/tags/VS-Code-%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"CSS","slug":"CSS","permalink":"http://hgko1207.github.io/tags/CSS/"},{"name":"미디어 쿼리","slug":"미디어-쿼리","permalink":"http://hgko1207.github.io/tags/%EB%AF%B8%EB%94%94%EC%96%B4-%EC%BF%BC%EB%A6%AC/"},{"name":"Media Query","slug":"Media-Query","permalink":"http://hgko1207.github.io/tags/Media-Query/"},{"name":"반응형 웹사이트","slug":"반응형-웹사이트","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"Css Website","slug":"Css-Website","permalink":"http://hgko1207.github.io/tags/Css-Website/"},{"name":"Enum","slug":"Enum","permalink":"http://hgko1207.github.io/tags/Enum/"},{"name":"TypeScript Type","slug":"TypeScript-Type","permalink":"http://hgko1207.github.io/tags/TypeScript-Type/"},{"name":"HTML","slug":"HTML","permalink":"http://hgko1207.github.io/tags/HTML/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"자바스크립트 문자열","slug":"자바스크립트-문자열","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"문자열 메서드","slug":"문자열-메서드","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"GitHub","slug":"GitHub","permalink":"http://hgko1207.github.io/tags/GitHub/"},{"name":"GitHub Repository","slug":"GitHub-Repository","permalink":"http://hgko1207.github.io/tags/GitHub-Repository/"},{"name":"북마크","slug":"북마크","permalink":"http://hgko1207.github.io/tags/%EB%B6%81%EB%A7%88%ED%81%AC/"},{"name":"API","slug":"API","permalink":"http://hgko1207.github.io/tags/API/"},{"name":"무료 리소스","slug":"무료-리소스","permalink":"http://hgko1207.github.io/tags/%EB%AC%B4%EB%A3%8C-%EB%A6%AC%EC%86%8C%EC%8A%A4/"},{"name":"아이콘","slug":"아이콘","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EC%BD%98/"},{"name":"템플릿","slug":"템플릿","permalink":"http://hgko1207.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF/"},{"name":"글꼴","slug":"글꼴","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EA%BC%B4/"},{"name":"색상","slug":"색상","permalink":"http://hgko1207.github.io/tags/%EC%83%89%EC%83%81/"},{"name":"Chrome 확장 프로그램","slug":"Chrome-확장-프로그램","permalink":"http://hgko1207.github.io/tags/Chrome-%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"Git","slug":"Git","permalink":"http://hgko1207.github.io/tags/Git/"},{"name":"Git 명령어","slug":"Git-명령어","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Git 초보자","slug":"Git-초보자","permalink":"http://hgko1207.github.io/tags/Git-%EC%B4%88%EB%B3%B4%EC%9E%90/"},{"name":"기본 타입 정리","slug":"기본-타입-정리","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8-%ED%83%80%EC%9E%85-%EC%A0%95%EB%A6%AC/"},{"name":"Primitive Type","slug":"Primitive-Type","permalink":"http://hgko1207.github.io/tags/Primitive-Type/"},{"name":"Basic Type","slug":"Basic-Type","permalink":"http://hgko1207.github.io/tags/Basic-Type/"},{"name":"Java","slug":"Java","permalink":"http://hgko1207.github.io/tags/Java/"},{"name":"CentOS","slug":"CentOS","permalink":"http://hgko1207.github.io/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://hgko1207.github.io/tags/Linux/"},{"name":"CentOS 9 Stream","slug":"CentOS-9-Stream","permalink":"http://hgko1207.github.io/tags/CentOS-9-Stream/"},{"name":"Java 설치 방법","slug":"Java-설치-방법","permalink":"http://hgko1207.github.io/tags/Java-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95/"},{"name":"Gemini","slug":"Gemini","permalink":"http://hgko1207.github.io/tags/Gemini/"},{"name":"Google Gemini","slug":"Google-Gemini","permalink":"http://hgko1207.github.io/tags/Google-Gemini/"},{"name":"OpenAI ChatGPT","slug":"OpenAI-ChatGPT","permalink":"http://hgko1207.github.io/tags/OpenAI-ChatGPT/"},{"name":"프로젝트 관리","slug":"프로젝트-관리","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC/"},{"name":"직장","slug":"직장","permalink":"http://hgko1207.github.io/tags/%EC%A7%81%EC%9E%A5/"},{"name":"슈퍼스타","slug":"슈퍼스타","permalink":"http://hgko1207.github.io/tags/%EC%8A%88%ED%8D%BC%EC%8A%A4%ED%83%80/"},{"name":"Google","slug":"Google","permalink":"http://hgko1207.github.io/tags/Google/"},{"name":"MWC 2024","slug":"MWC-2024","permalink":"http://hgko1207.github.io/tags/MWC-2024/"},{"name":"EcoCharge","slug":"EcoCharge","permalink":"http://hgko1207.github.io/tags/EcoCharge/"},{"name":"HoloLens","slug":"HoloLens","permalink":"http://hgko1207.github.io/tags/HoloLens/"},{"name":"FlexPai","slug":"FlexPai","permalink":"http://hgko1207.github.io/tags/FlexPai/"},{"name":"시간 절약","slug":"시간-절약","permalink":"http://hgko1207.github.io/tags/%EC%8B%9C%EA%B0%84-%EC%A0%88%EC%95%BD/"},{"name":"객체","slug":"객체","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"객체 생성","slug":"객체-생성","permalink":"http://hgko1207.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/"},{"name":"Tsconfig","slug":"Tsconfig","permalink":"http://hgko1207.github.io/tags/Tsconfig/"},{"name":"TSC","slug":"TSC","permalink":"http://hgko1207.github.io/tags/TSC/"},{"name":"목표 설정","slug":"목표-설정","permalink":"http://hgko1207.github.io/tags/%EB%AA%A9%ED%91%9C-%EC%84%A4%EC%A0%95/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"변수","slug":"변수","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"변수가 배열인지","slug":"변수가-배열인지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EC%88%98%EA%B0%80-%EB%B0%B0%EC%97%B4%EC%9D%B8%EC%A7%80/"},{"name":"배열","slug":"배열","permalink":"http://hgko1207.github.io/tags/%EB%B0%B0%EC%97%B4/"},{"name":"번역","slug":"번역","permalink":"http://hgko1207.github.io/tags/%EB%B2%88%EC%97%AD/"},{"name":"수익 창출","slug":"수익-창출","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EC%9D%B5-%EC%B0%BD%EC%B6%9C/"},{"name":"운동","slug":"운동","permalink":"http://hgko1207.github.io/tags/%EC%9A%B4%EB%8F%99/"},{"name":"운동 계획","slug":"운동-계획","permalink":"http://hgko1207.github.io/tags/%EC%9A%B4%EB%8F%99-%EA%B3%84%ED%9A%8D/"},{"name":"Gemini AI","slug":"Gemini-AI","permalink":"http://hgko1207.github.io/tags/Gemini-AI/"},{"name":"Google AI","slug":"Google-AI","permalink":"http://hgko1207.github.io/tags/Google-AI/"},{"name":"DevOps","slug":"DevOps","permalink":"http://hgko1207.github.io/tags/DevOps/"},{"name":"컨테이너화","slug":"컨테이너화","permalink":"http://hgko1207.github.io/tags/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%ED%99%94/"},{"name":"가상화","slug":"가상화","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EC%83%81%ED%99%94/"},{"name":"글쓰기","slug":"글쓰기","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0/"},{"name":"개발","slug":"개발","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"코딩","slug":"코딩","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%94%A9/"},{"name":"개발자 도구","slug":"개발자-도구","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC/"},{"name":"Chatbot","slug":"Chatbot","permalink":"http://hgko1207.github.io/tags/Chatbot/"},{"name":"Bard","slug":"Bard","permalink":"http://hgko1207.github.io/tags/Bard/"},{"name":"Google Ai","slug":"Google-Ai","permalink":"http://hgko1207.github.io/tags/Google-Ai/"},{"name":"인플루언서","slug":"인플루언서","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A3%A8%EC%96%B8%EC%84%9C/"},{"name":"마케팅을 위한 ChatGPT","slug":"마케팅을-위한-ChatGPT","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85%EC%9D%84-%EC%9C%84%ED%95%9C-ChatGPT/"},{"name":"콘텐츠 작성 프롬프트","slug":"콘텐츠-작성-프롬프트","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0-%EC%9E%91%EC%84%B1-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"글쓰기를 위한 ChatGPT","slug":"글쓰기를-위한-ChatGPT","permalink":"http://hgko1207.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0%EB%A5%BC-%EC%9C%84%ED%95%9C-ChatGPT/"},{"name":"Technology","slug":"Technology","permalink":"http://hgko1207.github.io/tags/Technology/"},{"name":"생산력","slug":"생산력","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%82%B0%EB%A0%A5/"},{"name":"데이터 과학","slug":"데이터-과학","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%BC%ED%95%99/"},{"name":"최신 검색 기능","slug":"최신-검색-기능","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%8B%A0-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%8A%A5/"},{"name":"AI 도구","slug":"AI-도구","permalink":"http://hgko1207.github.io/tags/AI-%EB%8F%84%EA%B5%AC/"},{"name":"Text To Video","slug":"Text-To-Video","permalink":"http://hgko1207.github.io/tags/Text-To-Video/"},{"name":"AI 기술","slug":"AI-기술","permalink":"http://hgko1207.github.io/tags/AI-%EA%B8%B0%EC%88%A0/"},{"name":"Sora","slug":"Sora","permalink":"http://hgko1207.github.io/tags/Sora/"},{"name":"골프","slug":"골프","permalink":"http://hgko1207.github.io/tags/%EA%B3%A8%ED%94%84/"},{"name":"골프 선수","slug":"골프-선수","permalink":"http://hgko1207.github.io/tags/%EA%B3%A8%ED%94%84-%EC%84%A0%EC%88%98/"},{"name":"데이터","slug":"데이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"콘텐츠 제작","slug":"콘텐츠-제작","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0-%EC%A0%9C%EC%9E%91/"},{"name":"간단한 프롬프트","slug":"간단한-프롬프트","permalink":"http://hgko1207.github.io/tags/%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/"},{"name":"50가지 작업","slug":"50가지-작업","permalink":"http://hgko1207.github.io/tags/50%EA%B0%80%EC%A7%80-%EC%9E%91%EC%97%85/"},{"name":"축구선수","slug":"축구선수","permalink":"http://hgko1207.github.io/tags/%EC%B6%95%EA%B5%AC%EC%84%A0%EC%88%98/"},{"name":"AI 코딩 도우미","slug":"AI-코딩-도우미","permalink":"http://hgko1207.github.io/tags/AI-%EC%BD%94%EB%94%A9-%EB%8F%84%EC%9A%B0%EB%AF%B8/"},{"name":"인도","slug":"인도","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8F%84/"},{"name":"인도 투자","slug":"인도-투자","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8F%84-%ED%88%AC%EC%9E%90/"},{"name":"Chatbot Design","slug":"Chatbot-Design","permalink":"http://hgko1207.github.io/tags/Chatbot-Design/"},{"name":"챗봇","slug":"챗봇","permalink":"http://hgko1207.github.io/tags/%EC%B1%97%EB%B4%87/"},{"name":"이벤트","slug":"이벤트","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"클릭 이벤트","slug":"클릭-이벤트","permalink":"http://hgko1207.github.io/tags/%ED%81%B4%EB%A6%AD-%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"Click","slug":"Click","permalink":"http://hgko1207.github.io/tags/Click/"},{"name":"Function","slug":"Function","permalink":"http://hgko1207.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"http://hgko1207.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"메서드","slug":"메서드","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"Method","slug":"Method","permalink":"http://hgko1207.github.io/tags/Method/"},{"name":"Perplexity","slug":"Perplexity","permalink":"http://hgko1207.github.io/tags/Perplexity/"},{"name":"Microsoft Copilot","slug":"Microsoft-Copilot","permalink":"http://hgko1207.github.io/tags/Microsoft-Copilot/"},{"name":"커리어 성장","slug":"커리어-성장","permalink":"http://hgko1207.github.io/tags/%EC%BB%A4%EB%A6%AC%EC%96%B4-%EC%84%B1%EC%9E%A5/"},{"name":"초보자 팁","slug":"초보자-팁","permalink":"http://hgko1207.github.io/tags/%EC%B4%88%EB%B3%B4%EC%9E%90-%ED%8C%81/"},{"name":"디자인","slug":"디자인","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"2024년","slug":"2024년","permalink":"http://hgko1207.github.io/tags/2024%EB%85%84/"},{"name":"디자인 도구","slug":"디자인-도구","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%EB%8F%84%EA%B5%AC/"},{"name":"AI 디코딩","slug":"AI-디코딩","permalink":"http://hgko1207.github.io/tags/AI-%EB%94%94%EC%BD%94%EB%94%A9/"},{"name":"Python","slug":"Python","permalink":"http://hgko1207.github.io/tags/Python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","permalink":"http://hgko1207.github.io/tags/Pandas/"},{"name":"모범사례","slug":"모범사례","permalink":"http://hgko1207.github.io/tags/%EB%AA%A8%EB%B2%94%EC%82%AC%EB%A1%80/"},{"name":"트렌드","slug":"트렌드","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A0%8C%EB%93%9C/"},{"name":"전망","slug":"전망","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%EB%A7%9D/"},{"name":"Generative AI","slug":"Generative-AI","permalink":"http://hgko1207.github.io/tags/Generative-AI/"},{"name":"생성형 AI","slug":"생성형-AI","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EC%84%B1%ED%98%95-AI/"},{"name":"무료도구","slug":"무료도구","permalink":"http://hgko1207.github.io/tags/%EB%AC%B4%EB%A3%8C%EB%8F%84%EA%B5%AC/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hgko1207.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://hgko1207.github.io/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://hgko1207.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"원격회의","slug":"원격회의","permalink":"http://hgko1207.github.io/tags/%EC%9B%90%EA%B2%A9%ED%9A%8C%EC%9D%98/"},{"name":"회의도우미","slug":"회의도우미","permalink":"http://hgko1207.github.io/tags/%ED%9A%8C%EC%9D%98%EB%8F%84%EC%9A%B0%EB%AF%B8/"},{"name":"AI Meeting Assistant","slug":"AI-Meeting-Assistant","permalink":"http://hgko1207.github.io/tags/AI-Meeting-Assistant/"},{"name":"콘텐츠","slug":"콘텐츠","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%ED%85%90%EC%B8%A0/"},{"name":"소프트웨어 개발","slug":"소프트웨어-개발","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"},{"name":"Software Development","slug":"Software-Development","permalink":"http://hgko1207.github.io/tags/Software-Development/"},{"name":"Development","slug":"Development","permalink":"http://hgko1207.github.io/tags/Development/"},{"name":"String","slug":"String","permalink":"http://hgko1207.github.io/tags/String/"},{"name":"string","slug":"string","permalink":"http://hgko1207.github.io/tags/string/"},{"name":"Frontend","slug":"Frontend","permalink":"http://hgko1207.github.io/tags/Frontend/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://hgko1207.github.io/tags/Vue-js/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://hgko1207.github.io/tags/Vuejs/"},{"name":"Vuex","slug":"Vuex","permalink":"http://hgko1207.github.io/tags/Vuex/"},{"name":"WinUI","slug":"WinUI","permalink":"http://hgko1207.github.io/tags/WinUI/"},{"name":"WinForms","slug":"WinForms","permalink":"http://hgko1207.github.io/tags/WinForms/"},{"name":"UWP","slug":"UWP","permalink":"http://hgko1207.github.io/tags/UWP/"},{"name":"MFC","slug":"MFC","permalink":"http://hgko1207.github.io/tags/MFC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Framework","slug":"Framework","permalink":"http://hgko1207.github.io/tags/Framework/"},{"name":"예측분석","slug":"예측분석","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EC%B8%A1%EB%B6%84%EC%84%9D/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://hgko1207.github.io/tags/Blockchain/"},{"name":"블록체인","slug":"블록체인","permalink":"http://hgko1207.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"암호화폐","slug":"암호화폐","permalink":"http://hgko1207.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"},{"name":"인터페이스","slug":"인터페이스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"XML","slug":"XML","permalink":"http://hgko1207.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://hgko1207.github.io/tags/JSON/"},{"name":"AJAX","slug":"AJAX","permalink":"http://hgko1207.github.io/tags/AJAX/"},{"name":"디코딩","slug":"디코딩","permalink":"http://hgko1207.github.io/tags/%EB%94%94%EC%BD%94%EB%94%A9/"},{"name":"ML","slug":"ML","permalink":"http://hgko1207.github.io/tags/ML/"},{"name":"Generative Ai Tools","slug":"Generative-Ai-Tools","permalink":"http://hgko1207.github.io/tags/Generative-Ai-Tools/"},{"name":"이미지 생성기","slug":"이미지-생성기","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%83%9D%EC%84%B1%EA%B8%B0/"},{"name":"거절","slug":"거절","permalink":"http://hgko1207.github.io/tags/%EA%B1%B0%EC%A0%88/"},{"name":"좌절","slug":"좌절","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%EC%A0%88/"},{"name":"성공","slug":"성공","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EA%B3%B5/"},{"name":"동기부여","slug":"동기부여","permalink":"http://hgko1207.github.io/tags/%EB%8F%99%EA%B8%B0%EB%B6%80%EC%97%AC/"},{"name":"긍정적인 생각","slug":"긍정적인-생각","permalink":"http://hgko1207.github.io/tags/%EA%B8%8D%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%9D%EA%B0%81/"},{"name":"Motivation","slug":"Motivation","permalink":"http://hgko1207.github.io/tags/Motivation/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"열정","slug":"열정","permalink":"http://hgko1207.github.io/tags/%EC%97%B4%EC%A0%95/"},{"name":"MVVM","slug":"MVVM","permalink":"http://hgko1207.github.io/tags/MVVM/"},{"name":"MVC","slug":"MVC","permalink":"http://hgko1207.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://hgko1207.github.io/tags/MVP/"},{"name":"대화형 AI","slug":"대화형-AI","permalink":"http://hgko1207.github.io/tags/%EB%8C%80%ED%99%94%ED%98%95-AI/"},{"name":"다중 장치","slug":"다중-장치","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%EC%A4%91-%EC%9E%A5%EC%B9%98/"},{"name":"반응형 디자인","slug":"반응형-디자인","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"Flexbox","slug":"Flexbox","permalink":"http://hgko1207.github.io/tags/Flexbox/"},{"name":"성능 최적화","slug":"성능-최적화","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"반응형 웹","slug":"반응형-웹","permalink":"http://hgko1207.github.io/tags/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/"},{"name":"아이디어","slug":"아이디어","permalink":"http://hgko1207.github.io/tags/%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4/"},{"name":"Angular","slug":"Angular","permalink":"http://hgko1207.github.io/tags/Angular/"},{"name":"Library","slug":"Library","permalink":"http://hgko1207.github.io/tags/Library/"},{"name":"라이브러리","slug":"라이브러리","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"Angularjs","slug":"Angularjs","permalink":"http://hgko1207.github.io/tags/Angularjs/"},{"name":"차세대 웹 앱","slug":"차세대-웹-앱","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%84%B8%EB%8C%80-%EC%9B%B9-%EC%95%B1/"},{"name":"Vue 2","slug":"Vue-2","permalink":"http://hgko1207.github.io/tags/Vue-2/"},{"name":"Vue 3","slug":"Vue-3","permalink":"http://hgko1207.github.io/tags/Vue-3/"},{"name":"버전 관리","slug":"버전-관리","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"코드 관리","slug":"코드-관리","permalink":"http://hgko1207.github.io/tags/%EC%BD%94%EB%93%9C-%EA%B4%80%EB%A6%AC/"},{"name":"공동 개발","slug":"공동-개발","permalink":"http://hgko1207.github.io/tags/%EA%B3%B5%EB%8F%99-%EA%B0%9C%EB%B0%9C/"},{"name":"작업 흐름","slug":"작업-흐름","permalink":"http://hgko1207.github.io/tags/%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84/"},{"name":"VCS","slug":"VCS","permalink":"http://hgko1207.github.io/tags/VCS/"},{"name":"Vue","slug":"Vue","permalink":"http://hgko1207.github.io/tags/Vue/"},{"name":"기본","slug":"기본","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EB%B3%B8/"},{"name":"Component","slug":"Component","permalink":"http://hgko1207.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"http://hgko1207.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"Decorator","slug":"Decorator","permalink":"http://hgko1207.github.io/tags/Decorator/"},{"name":"데코레이터","slug":"데코레이터","permalink":"http://hgko1207.github.io/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"명령어","slug":"명령어","permalink":"http://hgko1207.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Angular CLI","slug":"Angular-CLI","permalink":"http://hgko1207.github.io/tags/Angular-CLI/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://hgko1207.github.io/tags/Visual-Studio-Code/"},{"name":"편집기","slug":"편집기","permalink":"http://hgko1207.github.io/tags/%ED%8E%B8%EC%A7%91%EA%B8%B0/"},{"name":"ChangeDetectorRef","slug":"ChangeDetectorRef","permalink":"http://hgko1207.github.io/tags/ChangeDetectorRef/"},{"name":"변경감지","slug":"변경감지","permalink":"http://hgko1207.github.io/tags/%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80/"},{"name":"Pipe","slug":"Pipe","permalink":"http://hgko1207.github.io/tags/Pipe/"},{"name":"파이프","slug":"파이프","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84/"},{"name":"ViewRef","slug":"ViewRef","permalink":"http://hgko1207.github.io/tags/ViewRef/"},{"name":"뷰","slug":"뷰","permalink":"http://hgko1207.github.io/tags/%EB%B7%B0/"},{"name":"ViewEncapsulation","slug":"ViewEncapsulation","permalink":"http://hgko1207.github.io/tags/ViewEncapsulation/"},{"name":"캡슐화","slug":"캡슐화","permalink":"http://hgko1207.github.io/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"http://hgko1207.github.io/tags/Lifecycle/"},{"name":"생명주기","slug":"생명주기","permalink":"http://hgko1207.github.io/tags/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"},{"name":"Hook","slug":"Hook","permalink":"http://hgko1207.github.io/tags/Hook/"},{"name":"훅","slug":"훅","permalink":"http://hgko1207.github.io/tags/%ED%9B%85/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://hgko1207.github.io/tags/NET-Core/"},{"name":"멀티스레딩","slug":"멀티스레딩","permalink":"http://hgko1207.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9/"},{"name":"스레드","slug":"스레드","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hgko1207.github.io/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://hgko1207.github.io/tags/Express/"},{"name":"웹 크롤러","slug":"웹-크롤러","permalink":"http://hgko1207.github.io/tags/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC/"},{"name":"Cheerio","slug":"Cheerio","permalink":"http://hgko1207.github.io/tags/Cheerio/"},{"name":"Backend","slug":"Backend","permalink":"http://hgko1207.github.io/tags/Backend/"},{"name":"최적화","slug":"최적화","permalink":"http://hgko1207.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Tree Shaking","slug":"Tree-Shaking","permalink":"http://hgko1207.github.io/tags/Tree-Shaking/"},{"name":"트리 쉐이킹","slug":"트리-쉐이킹","permalink":"http://hgko1207.github.io/tags/%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9/"},{"name":"Zone.js","slug":"Zone-js","permalink":"http://hgko1207.github.io/tags/Zone-js/"},{"name":"성능향상","slug":"성능향상","permalink":"http://hgko1207.github.io/tags/%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://hgko1207.github.io/tags/RabbitMQ/"},{"name":"메시지","slug":"메시지","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%EC%8B%9C%EC%A7%80/"},{"name":"차이점","slug":"차이점","permalink":"http://hgko1207.github.io/tags/%EC%B0%A8%EC%9D%B4%EC%A0%90/"},{"name":"OAuth","slug":"OAuth","permalink":"http://hgko1207.github.io/tags/OAuth/"},{"name":"JWT","slug":"JWT","permalink":"http://hgko1207.github.io/tags/JWT/"},{"name":"인증","slug":"인증","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"보안","slug":"보안","permalink":"http://hgko1207.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"Swagger","slug":"Swagger","permalink":"http://hgko1207.github.io/tags/Swagger/"},{"name":"AWS","slug":"AWS","permalink":"http://hgko1207.github.io/tags/AWS/"},{"name":"Amazon Web Services","slug":"Amazon-Web-Services","permalink":"http://hgko1207.github.io/tags/Amazon-Web-Services/"},{"name":"Git 명령","slug":"Git-명령","permalink":"http://hgko1207.github.io/tags/Git-%EB%AA%85%EB%A0%B9/"},{"name":"버전 제어","slug":"버전-제어","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84-%EC%A0%9C%EC%96%B4/"},{"name":"Testing","slug":"Testing","permalink":"http://hgko1207.github.io/tags/Testing/"},{"name":"테스트","slug":"테스트","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"소프트웨어","slug":"소프트웨어","permalink":"http://hgko1207.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"},{"name":"HTTP","slug":"HTTP","permalink":"http://hgko1207.github.io/tags/HTTP/"},{"name":"POST","slug":"POST","permalink":"http://hgko1207.github.io/tags/POST/"},{"name":"GET","slug":"GET","permalink":"http://hgko1207.github.io/tags/GET/"},{"name":"Https","slug":"Https","permalink":"http://hgko1207.github.io/tags/Https/"},{"name":"NPM","slug":"NPM","permalink":"http://hgko1207.github.io/tags/NPM/"},{"name":"Package","slug":"Package","permalink":"http://hgko1207.github.io/tags/Package/"},{"name":"Creating","slug":"Creating","permalink":"http://hgko1207.github.io/tags/Creating/"},{"name":"Publishing","slug":"Publishing","permalink":"http://hgko1207.github.io/tags/Publishing/"},{"name":"Script","slug":"Script","permalink":"http://hgko1207.github.io/tags/Script/"},{"name":"Workflow","slug":"Workflow","permalink":"http://hgko1207.github.io/tags/Workflow/"},{"name":"사용자 정의 스트립트","slug":"사용자-정의-스트립트","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8/"},{"name":"워크플로우 자동화","slug":"워크플로우-자동화","permalink":"http://hgko1207.github.io/tags/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9E%90%EB%8F%99%ED%99%94/"},{"name":"Http","slug":"Http","permalink":"http://hgko1207.github.io/tags/Http/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://hgko1207.github.io/tags/HttpClient/"},{"name":"Array","slug":"Array","permalink":"http://hgko1207.github.io/tags/Array/"},{"name":"Array Methods","slug":"Array-Methods","permalink":"http://hgko1207.github.io/tags/Array-Methods/"},{"name":"Error","slug":"Error","permalink":"http://hgko1207.github.io/tags/Error/"},{"name":"Handling","slug":"Handling","permalink":"http://hgko1207.github.io/tags/Handling/"},{"name":"오류처리","slug":"오류처리","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"},{"name":"callback","slug":"callback","permalink":"http://hgko1207.github.io/tags/callback/"},{"name":"Promise","slug":"Promise","permalink":"http://hgko1207.github.io/tags/Promise/"},{"name":"Async/Await","slug":"Async-Await","permalink":"http://hgko1207.github.io/tags/Async-Await/"},{"name":"콜백","slug":"콜백","permalink":"http://hgko1207.github.io/tags/%EC%BD%9C%EB%B0%B1/"},{"name":"multithreading","slug":"multithreading","permalink":"http://hgko1207.github.io/tags/multithreading/"},{"name":"Thread","slug":"Thread","permalink":"http://hgko1207.github.io/tags/Thread/"},{"name":"Animation","slug":"Animation","permalink":"http://hgko1207.github.io/tags/Animation/"},{"name":"애니메이션","slug":"애니메이션","permalink":"http://hgko1207.github.io/tags/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/"},{"name":"Performance","slug":"Performance","permalink":"http://hgko1207.github.io/tags/Performance/"},{"name":"콘솔","slug":"콘솔","permalink":"http://hgko1207.github.io/tags/%EC%BD%98%EC%86%94/"},{"name":"백그라운드","slug":"백그라운드","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C/"},{"name":"백그라운드 실행","slug":"백그라운드-실행","permalink":"http://hgko1207.github.io/tags/%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://hgko1207.github.io/tags/Eclipse/"},{"name":"이클립스","slug":"이클립스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4/"},{"name":"jar 파일","slug":"jar-파일","permalink":"http://hgko1207.github.io/tags/jar-%ED%8C%8C%EC%9D%BC/"},{"name":"Captcha","slug":"Captcha","permalink":"http://hgko1207.github.io/tags/Captcha/"},{"name":"SimpleCptcha","slug":"SimpleCptcha","permalink":"http://hgko1207.github.io/tags/SimpleCptcha/"},{"name":"자동가입방지문자","slug":"자동가입방지문자","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%8F%99%EA%B0%80%EC%9E%85%EB%B0%A9%EC%A7%80%EB%AC%B8%EC%9E%90/"},{"name":"DI","slug":"DI","permalink":"http://hgko1207.github.io/tags/DI/"},{"name":"의존성","slug":"의존성","permalink":"http://hgko1207.github.io/tags/%EC%9D%98%EC%A1%B4%EC%84%B1/"},{"name":"수명","slug":"수명","permalink":"http://hgko1207.github.io/tags/%EC%88%98%EB%AA%85/"},{"name":"lifetime","slug":"lifetime","permalink":"http://hgko1207.github.io/tags/lifetime/"},{"name":"Map","slug":"Map","permalink":"http://hgko1207.github.io/tags/Map/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://hgko1207.github.io/tags/OpenLayers/"},{"name":"지도","slug":"지도","permalink":"http://hgko1207.github.io/tags/%EC%A7%80%EB%8F%84/"},{"name":"FileSystemWatcher","slug":"FileSystemWatcher","permalink":"http://hgko1207.github.io/tags/FileSystemWatcher/"},{"name":"파일 감시","slug":"파일-감시","permalink":"http://hgko1207.github.io/tags/%ED%8C%8C%EC%9D%BC-%EA%B0%90%EC%8B%9C/"},{"name":"cross-fetch","slug":"cross-fetch","permalink":"http://hgko1207.github.io/tags/cross-fetch/"},{"name":"fetch","slug":"fetch","permalink":"http://hgko1207.github.io/tags/fetch/"},{"name":"Flutter","slug":"Flutter","permalink":"http://hgko1207.github.io/tags/Flutter/"},{"name":"플러터","slug":"플러터","permalink":"http://hgko1207.github.io/tags/%ED%94%8C%EB%9F%AC%ED%84%B0/"},{"name":"버전","slug":"버전","permalink":"http://hgko1207.github.io/tags/%EB%B2%84%EC%A0%84/"},{"name":"오류","slug":"오류","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%A5%98/"},{"name":"NestJS","slug":"NestJS","permalink":"http://hgko1207.github.io/tags/NestJS/"},{"name":"Jest","slug":"Jest","permalink":"http://hgko1207.github.io/tags/Jest/"},{"name":"e2e","slug":"e2e","permalink":"http://hgko1207.github.io/tags/e2e/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"http://hgko1207.github.io/tags/Unit-Testing/"},{"name":"Partial","slug":"Partial","permalink":"http://hgko1207.github.io/tags/Partial/"},{"name":"Mapped types","slug":"Mapped-types","permalink":"http://hgko1207.github.io/tags/Mapped-types/"},{"name":"Validation","slug":"Validation","permalink":"http://hgko1207.github.io/tags/Validation/"},{"name":"ValidationPipe","slug":"ValidationPipe","permalink":"http://hgko1207.github.io/tags/ValidationPipe/"},{"name":"검증","slug":"검증","permalink":"http://hgko1207.github.io/tags/%EA%B2%80%EC%A6%9D/"},{"name":"Module","slug":"Module","permalink":"http://hgko1207.github.io/tags/Module/"},{"name":"Param","slug":"Param","permalink":"http://hgko1207.github.io/tags/Param/"},{"name":"Decorators","slug":"Decorators","permalink":"http://hgko1207.github.io/tags/Decorators/"},{"name":"Controller","slug":"Controller","permalink":"http://hgko1207.github.io/tags/Controller/"},{"name":"Provider","slug":"Provider","permalink":"http://hgko1207.github.io/tags/Provider/"},{"name":"설치","slug":"설치","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"프로젝트생성","slug":"프로젝트생성","permalink":"http://hgko1207.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%83%9D%EC%84%B1/"},{"name":"Push","slug":"Push","permalink":"http://hgko1207.github.io/tags/Push/"},{"name":"Chocolatey","slug":"Chocolatey","permalink":"http://hgko1207.github.io/tags/Chocolatey/"},{"name":"Dart","slug":"Dart","permalink":"http://hgko1207.github.io/tags/Dart/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://hgko1207.github.io/tags/Data-Types/"},{"name":"Null Safety","slug":"Null-Safety","permalink":"http://hgko1207.github.io/tags/Null-Safety/"},{"name":"Variable","slug":"Variable","permalink":"http://hgko1207.github.io/tags/Variable/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://hgko1207.github.io/tags/JSDoc/"},{"name":"설정","slug":"설정","permalink":"http://hgko1207.github.io/tags/%EC%84%A4%EC%A0%95/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"http://hgko1207.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"http://hgko1207.github.io/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"generics","slug":"generics","permalink":"http://hgko1207.github.io/tags/generics/"},{"name":"Function Overloads","slug":"Function-Overloads","permalink":"http://hgko1207.github.io/tags/Function-Overloads/"},{"name":"Overloading","slug":"Overloading","permalink":"http://hgko1207.github.io/tags/Overloading/"},{"name":"FormattedText","slug":"FormattedText","permalink":"http://hgko1207.github.io/tags/FormattedText/"},{"name":"TextBlock","slug":"TextBlock","permalink":"http://hgko1207.github.io/tags/TextBlock/"},{"name":"문자열","slug":"문자열","permalink":"http://hgko1207.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"Types","slug":"Types","permalink":"http://hgko1207.github.io/tags/Types/"},{"name":"타입","slug":"타입","permalink":"http://hgko1207.github.io/tags/%ED%83%80%EC%9E%85/"},{"name":"Grid","slug":"Grid","permalink":"http://hgko1207.github.io/tags/Grid/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://hgko1207.github.io/tags/Bitmap/"},{"name":"이미지저장","slug":"이미지저장","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%A0%80%EC%9E%A5/"},{"name":"FormGroup","slug":"FormGroup","permalink":"http://hgko1207.github.io/tags/FormGroup/"},{"name":"리액트","slug":"리액트","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"Next.js","slug":"Next-js","permalink":"http://hgko1207.github.io/tags/Next-js/"},{"name":"Route","slug":"Route","permalink":"http://hgko1207.github.io/tags/Route/"},{"name":"엘라스틱서치","slug":"엘라스틱서치","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98/"},{"name":"키바나","slug":"키바나","permalink":"http://hgko1207.github.io/tags/%ED%82%A4%EB%B0%94%EB%82%98/"},{"name":"엘라스틱스택","slug":"엘라스틱스택","permalink":"http://hgko1207.github.io/tags/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%8A%A4%ED%83%9D/"},{"name":"로그스태시","slug":"로그스태시","permalink":"http://hgko1207.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C/"},{"name":"비트","slug":"비트","permalink":"http://hgko1207.github.io/tags/%EB%B9%84%ED%8A%B8/"},{"name":"Redirect","slug":"Redirect","permalink":"http://hgko1207.github.io/tags/Redirect/"},{"name":"Rewrite","slug":"Rewrite","permalink":"http://hgko1207.github.io/tags/Rewrite/"},{"name":"Routing","slug":"Routing","permalink":"http://hgko1207.github.io/tags/Routing/"},{"name":"Head","slug":"Head","permalink":"http://hgko1207.github.io/tags/Head/"},{"name":"헤더","slug":"헤더","permalink":"http://hgko1207.github.io/tags/%ED%97%A4%EB%8D%94/"},{"name":"Styles","slug":"Styles","permalink":"http://hgko1207.github.io/tags/Styles/"},{"name":"스타일","slug":"스타일","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%83%80%EC%9D%BC/"},{"name":"라우트","slug":"라우트","permalink":"http://hgko1207.github.io/tags/%EB%9D%BC%EC%9A%B0%ED%8A%B8/"},{"name":"Windows Forms","slug":"Windows-Forms","permalink":"http://hgko1207.github.io/tags/Windows-Forms/"},{"name":"WinForm","slug":"WinForm","permalink":"http://hgko1207.github.io/tags/WinForm/"},{"name":"윈도우","slug":"윈도우","permalink":"http://hgko1207.github.io/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"Kibana","slug":"Kibana","permalink":"http://hgko1207.github.io/tags/Kibana/"},{"name":"Database","slug":"Database","permalink":"http://hgko1207.github.io/tags/Database/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://hgko1207.github.io/tags/Elasticsearch/"},{"name":"Gatsby","slug":"Gatsby","permalink":"http://hgko1207.github.io/tags/Gatsby/"},{"name":"개츠비","slug":"개츠비","permalink":"http://hgko1207.github.io/tags/%EA%B0%9C%EC%B8%A0%EB%B9%84/"},{"name":"Page Query","slug":"Page-Query","permalink":"http://hgko1207.github.io/tags/Page-Query/"},{"name":"gatsby-source-filesystem","slug":"gatsby-source-filesystem","permalink":"http://hgko1207.github.io/tags/gatsby-source-filesystem/"},{"name":"useStaticQuery","slug":"useStaticQuery","permalink":"http://hgko1207.github.io/tags/useStaticQuery/"},{"name":"정적 쿼리","slug":"정적-쿼리","permalink":"http://hgko1207.github.io/tags/%EC%A0%95%EC%A0%81-%EC%BF%BC%EB%A6%AC/"},{"name":"SHACL","slug":"SHACL","permalink":"http://hgko1207.github.io/tags/SHACL/"},{"name":"RDF","slug":"RDF","permalink":"http://hgko1207.github.io/tags/RDF/"},{"name":"Head API","slug":"Head-API","permalink":"http://hgko1207.github.io/tags/Head-API/"},{"name":"Layout Components","slug":"Layout-Components","permalink":"http://hgko1207.github.io/tags/Layout-Components/"},{"name":"MySQL","slug":"MySQL","permalink":"http://hgko1207.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://hgko1207.github.io/tags/DB/"},{"name":"Spring","slug":"Spring","permalink":"http://hgko1207.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://hgko1207.github.io/tags/Spring-Boot/"},{"name":"스프링부트","slug":"스프링부트","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"http://hgko1207.github.io/tags/MultipartFile/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://hgko1207.github.io/tags/Bootstrap/"},{"name":"Modal","slug":"Modal","permalink":"http://hgko1207.github.io/tags/Modal/"},{"name":"리눅스","slug":"리눅스","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"mount","slug":"mount","permalink":"http://hgko1207.github.io/tags/mount/"},{"name":"마운트","slug":"마운트","permalink":"http://hgko1207.github.io/tags/%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"네트워크","slug":"네트워크","permalink":"http://hgko1207.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Network","slug":"Network","permalink":"http://hgko1207.github.io/tags/Network/"},{"name":"netstat","slug":"netstat","permalink":"http://hgko1207.github.io/tags/netstat/"},{"name":"Port","slug":"Port","permalink":"http://hgko1207.github.io/tags/Port/"},{"name":"PM2","slug":"PM2","permalink":"http://hgko1207.github.io/tags/PM2/"},{"name":"Service","slug":"Service","permalink":"http://hgko1207.github.io/tags/Service/"},{"name":"서비스","slug":"서비스","permalink":"http://hgko1207.github.io/tags/%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Metamask","slug":"Metamask","permalink":"http://hgko1207.github.io/tags/Metamask/"},{"name":"메타마스크","slug":"메타마스크","permalink":"http://hgko1207.github.io/tags/%EB%A9%94%ED%83%80%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://hgko1207.github.io/tags/WebSocket/"},{"name":"STOMP","slug":"STOMP","permalink":"http://hgko1207.github.io/tags/STOMP/"},{"name":"Feature","slug":"Feature","permalink":"http://hgko1207.github.io/tags/Feature/"},{"name":"Icon","slug":"Icon","permalink":"http://hgko1207.github.io/tags/Icon/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://hgko1207.github.io/tags/Ethereum/"},{"name":"ganache","slug":"ganache","permalink":"http://hgko1207.github.io/tags/ganache/"},{"name":"ganache-cli","slug":"ganache-cli","permalink":"http://hgko1207.github.io/tags/ganache-cli/"},{"name":"가나슈","slug":"가나슈","permalink":"http://hgko1207.github.io/tags/%EA%B0%80%EB%82%98%EC%8A%88/"},{"name":"계정관리","slug":"계정관리","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95%EA%B4%80%EB%A6%AC/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://hgko1207.github.io/tags/Spring-Data-JPA/"},{"name":"CascadeType","slug":"CascadeType","permalink":"http://hgko1207.github.io/tags/CascadeType/"},{"name":"Querydsl","slug":"Querydsl","permalink":"http://hgko1207.github.io/tags/Querydsl/"},{"name":"QuerydslRepositorySupport","slug":"QuerydslRepositorySupport","permalink":"http://hgko1207.github.io/tags/QuerydslRepositorySupport/"},{"name":"NamedQuery","slug":"NamedQuery","permalink":"http://hgko1207.github.io/tags/NamedQuery/"},{"name":"쿼리 메서드","slug":"쿼리-메서드","permalink":"http://hgko1207.github.io/tags/%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"ElementCollection","slug":"ElementCollection","permalink":"http://hgko1207.github.io/tags/ElementCollection/"},{"name":"스토리지 엔진","slug":"스토리지-엔진","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/"},{"name":"Storage Engine","slug":"Storage-Engine","permalink":"http://hgko1207.github.io/tags/Storage-Engine/"},{"name":"ALTER TABLE","slug":"ALTER-TABLE","permalink":"http://hgko1207.github.io/tags/ALTER-TABLE/"},{"name":"인덱스","slug":"인덱스","permalink":"http://hgko1207.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"INDEX","slug":"INDEX","permalink":"http://hgko1207.github.io/tags/INDEX/"},{"name":"계정","slug":"계정","permalink":"http://hgko1207.github.io/tags/%EA%B3%84%EC%A0%95/"},{"name":"자바","slug":"자바","permalink":"http://hgko1207.github.io/tags/%EC%9E%90%EB%B0%94/"},{"name":"Lambda","slug":"Lambda","permalink":"http://hgko1207.github.io/tags/Lambda/"},{"name":"람다","slug":"람다","permalink":"http://hgko1207.github.io/tags/%EB%9E%8C%EB%8B%A4/"},{"name":"Iteration","slug":"Iteration","permalink":"http://hgko1207.github.io/tags/Iteration/"},{"name":"Stream","slug":"Stream","permalink":"http://hgko1207.github.io/tags/Stream/"},{"name":"스트림","slug":"스트림","permalink":"http://hgko1207.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"stream","slug":"stream","permalink":"http://hgko1207.github.io/tags/stream/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://hgko1207.github.io/tags/PostgreSQL/"},{"name":"사용자 관리","slug":"사용자-관리","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B4%80%EB%A6%AC/"},{"name":"그룹 관리","slug":"그룹-관리","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%A3%B9-%EA%B4%80%EB%A6%AC/"},{"name":"사용자 인증","slug":"사용자-인증","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D/"},{"name":"Oracle","slug":"Oracle","permalink":"http://hgko1207.github.io/tags/Oracle/"},{"name":"사용자","slug":"사용자","permalink":"http://hgko1207.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90/"},{"name":"테이블","slug":"테이블","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"},{"name":"테이블스페이스","slug":"테이블스페이스","permalink":"http://hgko1207.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"WGS84","slug":"WGS84","permalink":"http://hgko1207.github.io/tags/WGS84/"},{"name":"도분초","slug":"도분초","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%B6%84%EC%B4%88/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://hgko1207.github.io/tags/MariaDB/"},{"name":"권한","slug":"권한","permalink":"http://hgko1207.github.io/tags/%EA%B6%8C%ED%95%9C/"},{"name":"NVM","slug":"NVM","permalink":"http://hgko1207.github.io/tags/NVM/"},{"name":"주민등록번호","slug":"주민등록번호","permalink":"http://hgko1207.github.io/tags/%EC%A3%BC%EB%AF%BC%EB%93%B1%EB%A1%9D%EB%B2%88%ED%98%B8/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://hgko1207.github.io/tags/OpenCV/"},{"name":"Sharpening","slug":"Sharpening","permalink":"http://hgko1207.github.io/tags/Sharpening/"},{"name":"Cytoscape","slug":"Cytoscape","permalink":"http://hgko1207.github.io/tags/Cytoscape/"},{"name":"Markdown","slug":"Markdown","permalink":"http://hgko1207.github.io/tags/Markdown/"},{"name":"Editor","slug":"Editor","permalink":"http://hgko1207.github.io/tags/Editor/"},{"name":"node-gyp","slug":"node-gyp","permalink":"http://hgko1207.github.io/tags/node-gyp/"},{"name":"Framer Motion","slug":"Framer-Motion","permalink":"http://hgko1207.github.io/tags/Framer-Motion/"},{"name":"alias","slug":"alias","permalink":"http://hgko1207.github.io/tags/alias/"},{"name":"별칭","slug":"별칭","permalink":"http://hgko1207.github.io/tags/%EB%B3%84%EC%B9%AD/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://hgko1207.github.io/tags/Tomcat/"},{"name":"톰캣","slug":"톰캣","permalink":"http://hgko1207.github.io/tags/%ED%86%B0%EC%BA%A3/"},{"name":"방화벽","slug":"방화벽","permalink":"http://hgko1207.github.io/tags/%EB%B0%A9%ED%99%94%EB%B2%BD/"},{"name":"reference","slug":"reference","permalink":"http://hgko1207.github.io/tags/reference/"},{"name":"memo","slug":"memo","permalink":"http://hgko1207.github.io/tags/memo/"},{"name":"react-beautiful-dnd","slug":"react-beautiful-dnd","permalink":"http://hgko1207.github.io/tags/react-beautiful-dnd/"},{"name":"Drag","slug":"Drag","permalink":"http://hgko1207.github.io/tags/Drag/"},{"name":"Drop","slug":"Drop","permalink":"http://hgko1207.github.io/tags/Drop/"},{"name":"react-hook-form","slug":"react-hook-form","permalink":"http://hgko1207.github.io/tags/react-hook-form/"},{"name":"Angular Cli","slug":"Angular-Cli","permalink":"http://hgko1207.github.io/tags/Angular-Cli/"},{"name":"Recoil","slug":"Recoil","permalink":"http://hgko1207.github.io/tags/Recoil/"},{"name":"ApexCharts","slug":"ApexCharts","permalink":"http://hgko1207.github.io/tags/ApexCharts/"},{"name":"React Query","slug":"React-Query","permalink":"http://hgko1207.github.io/tags/React-Query/"},{"name":"React Router","slug":"React-Router","permalink":"http://hgko1207.github.io/tags/React-Router/"},{"name":"Query","slug":"Query","permalink":"http://hgko1207.github.io/tags/Query/"},{"name":"Styled Components","slug":"Styled-Components","permalink":"http://hgko1207.github.io/tags/Styled-Components/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://hgko1207.github.io/tags/ffmpeg/"},{"name":"이미지","slug":"이미지","permalink":"http://hgko1207.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"},{"name":"Devexpress","slug":"Devexpress","permalink":"http://hgko1207.github.io/tags/Devexpress/"},{"name":"CE","slug":"CE","permalink":"http://hgko1207.github.io/tags/CE/"},{"name":"LE","slug":"LE","permalink":"http://hgko1207.github.io/tags/LE/"},{"name":"Circular Error","slug":"Circular-Error","permalink":"http://hgko1207.github.io/tags/Circular-Error/"},{"name":"Linear Error","slug":"Linear-Error","permalink":"http://hgko1207.github.io/tags/Linear-Error/"},{"name":"Satellite","slug":"Satellite","permalink":"http://hgko1207.github.io/tags/Satellite/"},{"name":"DEM","slug":"DEM","permalink":"http://hgko1207.github.io/tags/DEM/"},{"name":"DPPDB","slug":"DPPDB","permalink":"http://hgko1207.github.io/tags/DPPDB/"},{"name":"NITF","slug":"NITF","permalink":"http://hgko1207.github.io/tags/NITF/"},{"name":"CSM","slug":"CSM","permalink":"http://hgko1207.github.io/tags/CSM/"},{"name":"SensorModel","slug":"SensorModel","permalink":"http://hgko1207.github.io/tags/SensorModel/"},{"name":"댓글","slug":"댓글","permalink":"http://hgko1207.github.io/tags/%EB%8C%93%EA%B8%80/"},{"name":"Position Accuracy","slug":"Position-Accuracy","permalink":"http://hgko1207.github.io/tags/Position-Accuracy/"},{"name":"Accuracy","slug":"Accuracy","permalink":"http://hgko1207.github.io/tags/Accuracy/"},{"name":"nohup","slug":"nohup","permalink":"http://hgko1207.github.io/tags/nohup/"},{"name":"Hostname","slug":"Hostname","permalink":"http://hgko1207.github.io/tags/Hostname/"},{"name":"TimeZone","slug":"TimeZone","permalink":"http://hgko1207.github.io/tags/TimeZone/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://hgko1207.github.io/tags/MyBatis/"},{"name":"Paging","slug":"Paging","permalink":"http://hgko1207.github.io/tags/Paging/"},{"name":"페이징","slug":"페이징","permalink":"http://hgko1207.github.io/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"},{"name":"Setting","slug":"Setting","permalink":"http://hgko1207.github.io/tags/Setting/"},{"name":"압축","slug":"압축","permalink":"http://hgko1207.github.io/tags/%EC%95%95%EC%B6%95/"},{"name":"해제","slug":"해제","permalink":"http://hgko1207.github.io/tags/%ED%95%B4%EC%A0%9C/"},{"name":"Go","slug":"Go","permalink":"http://hgko1207.github.io/tags/Go/"},{"name":"yum","slug":"yum","permalink":"http://hgko1207.github.io/tags/yum/"},{"name":"rpm","slug":"rpm","permalink":"http://hgko1207.github.io/tags/rpm/"},{"name":"Windows","slug":"Windows","permalink":"http://hgko1207.github.io/tags/Windows/"},{"name":"Site","slug":"Site","permalink":"http://hgko1207.github.io/tags/Site/"},{"name":"JPA","slug":"JPA","permalink":"http://hgko1207.github.io/tags/JPA/"},{"name":"Select","slug":"Select","permalink":"http://hgko1207.github.io/tags/Select/"},{"name":"Image","slug":"Image","permalink":"http://hgko1207.github.io/tags/Image/"},{"name":"Video","slug":"Video","permalink":"http://hgko1207.github.io/tags/Video/"},{"name":"Slider","slug":"Slider","permalink":"http://hgko1207.github.io/tags/Slider/"},{"name":"Prism","slug":"Prism","permalink":"http://hgko1207.github.io/tags/Prism/"},{"name":"Android","slug":"Android","permalink":"http://hgko1207.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://hgko1207.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"Weather","slug":"Weather","permalink":"http://hgko1207.github.io/tags/Weather/"},{"name":"MATLAB","slug":"MATLAB","permalink":"http://hgko1207.github.io/tags/MATLAB/"},{"name":"Com","slug":"Com","permalink":"http://hgko1207.github.io/tags/Com/"},{"name":"C++","slug":"C","permalink":"http://hgko1207.github.io/tags/C/"},{"name":"평균","slug":"평균","permalink":"http://hgko1207.github.io/tags/%ED%8F%89%EA%B7%A0/"},{"name":"표준편차","slug":"표준편차","permalink":"http://hgko1207.github.io/tags/%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://hgko1207.github.io/tags/SimpleDateFormat/"},{"name":"Geometry","slug":"Geometry","permalink":"http://hgko1207.github.io/tags/Geometry/"},{"name":"오라클","slug":"오라클","permalink":"http://hgko1207.github.io/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"SDO_GEOMETRY","slug":"SDO-GEOMETRY","permalink":"http://hgko1207.github.io/tags/SDO-GEOMETRY/"},{"name":"Properties","slug":"Properties","permalink":"http://hgko1207.github.io/tags/Properties/"},{"name":"Bytes","slug":"Bytes","permalink":"http://hgko1207.github.io/tags/Bytes/"},{"name":"Maven","slug":"Maven","permalink":"http://hgko1207.github.io/tags/Maven/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://hgko1207.github.io/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"http://hgko1207.github.io/tags/Docker/"},{"name":"Cmake","slug":"Cmake","permalink":"http://hgko1207.github.io/tags/Cmake/"},{"name":"Nginx","slug":"Nginx","permalink":"http://hgko1207.github.io/tags/Nginx/"},{"name":"NFS","slug":"NFS","permalink":"http://hgko1207.github.io/tags/NFS/"},{"name":"TimescaleDB","slug":"TimescaleDB","permalink":"http://hgko1207.github.io/tags/TimescaleDB/"},{"name":"Kafka","slug":"Kafka","permalink":"http://hgko1207.github.io/tags/Kafka/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://hgko1207.github.io/tags/Zookeeper/"},{"name":"Proxy","slug":"Proxy","permalink":"http://hgko1207.github.io/tags/Proxy/"},{"name":"Yum","slug":"Yum","permalink":"http://hgko1207.github.io/tags/Yum/"},{"name":"VNC","slug":"VNC","permalink":"http://hgko1207.github.io/tags/VNC/"},{"name":"Server","slug":"Server","permalink":"http://hgko1207.github.io/tags/Server/"},{"name":"Command","slug":"Command","permalink":"http://hgko1207.github.io/tags/Command/"},{"name":"외부접속허용","slug":"외부접속허용","permalink":"http://hgko1207.github.io/tags/%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D%ED%97%88%EC%9A%A9/"},{"name":"Event","slug":"Event","permalink":"http://hgko1207.github.io/tags/Event/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://hgko1207.github.io/tags/DeepLearning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://hgko1207.github.io/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"},{"name":"MSSQL","slug":"MSSQL","permalink":"http://hgko1207.github.io/tags/MSSQL/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hgko1207.github.io/tags/Canvas/"},{"name":"Template","slug":"Template","permalink":"http://hgko1207.github.io/tags/Template/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://hgko1207.github.io/tags/Tensorflow/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hgko1207.github.io/tags/PyTorch/"},{"name":"JQuery","slug":"JQuery","permalink":"http://hgko1207.github.io/tags/JQuery/"},{"name":"DataTables","slug":"DataTables","permalink":"http://hgko1207.github.io/tags/DataTables/"},{"name":"Open API","slug":"Open-API","permalink":"http://hgko1207.github.io/tags/Open-API/"},{"name":"예보","slug":"예보","permalink":"http://hgko1207.github.io/tags/%EC%98%88%EB%B3%B4/"},{"name":"기상정보","slug":"기상정보","permalink":"http://hgko1207.github.io/tags/%EA%B8%B0%EC%83%81%EC%A0%95%EB%B3%B4/"},{"name":"날씨","slug":"날씨","permalink":"http://hgko1207.github.io/tags/%EB%82%A0%EC%94%A8/"},{"name":"그라데이션","slug":"그라데이션","permalink":"http://hgko1207.github.io/tags/%EA%B7%B8%EB%9D%BC%EB%8D%B0%EC%9D%B4%EC%85%98/"},{"name":"proj4","slug":"proj4","permalink":"http://hgko1207.github.io/tags/proj4/"},{"name":"좌표변환","slug":"좌표변환","permalink":"http://hgko1207.github.io/tags/%EC%A2%8C%ED%91%9C%EB%B3%80%ED%99%98/"},{"name":"율리우스력","slug":"율리우스력","permalink":"http://hgko1207.github.io/tags/%EC%9C%A8%EB%A6%AC%EC%9A%B0%EC%8A%A4%EB%A0%A5/"},{"name":"RCP","slug":"RCP","permalink":"http://hgko1207.github.io/tags/RCP/"},{"name":"Numpy","slug":"Numpy","permalink":"http://hgko1207.github.io/tags/Numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://hgko1207.github.io/tags/matplotlib/"},{"name":"Graph","slug":"Graph","permalink":"http://hgko1207.github.io/tags/Graph/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://hgko1207.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://hgko1207.github.io/tags/Pytorch/"},{"name":"Hexo","slug":"Hexo","permalink":"http://hgko1207.github.io/tags/Hexo/"},{"name":"Clone","slug":"Clone","permalink":"http://hgko1207.github.io/tags/Clone/"},{"name":"Sensor","slug":"Sensor","permalink":"http://hgko1207.github.io/tags/Sensor/"},{"name":"Hyperspectral","slug":"Hyperspectral","permalink":"http://hgko1207.github.io/tags/Hyperspectral/"},{"name":"Program","slug":"Program","permalink":"http://hgko1207.github.io/tags/Program/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://hgko1207.github.io/tags/Clean-Code/"},{"name":"Microwave","slug":"Microwave","permalink":"http://hgko1207.github.io/tags/Microwave/"},{"name":"IR","slug":"IR","permalink":"http://hgko1207.github.io/tags/IR/"},{"name":"Infrared","slug":"Infrared","permalink":"http://hgko1207.github.io/tags/Infrared/"},{"name":"적외선 센서","slug":"적외선-센서","permalink":"http://hgko1207.github.io/tags/%EC%A0%81%EC%99%B8%EC%84%A0-%EC%84%BC%EC%84%9C/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://hgko1207.github.io/tags/Android-Studio/"},{"name":"Download","slug":"Download","permalink":"http://hgko1207.github.io/tags/Download/"},{"name":"SAR 위성","slug":"SAR-위성","permalink":"http://hgko1207.github.io/tags/SAR-%EC%9C%84%EC%84%B1/"},{"name":"SAR","slug":"SAR","permalink":"http://hgko1207.github.io/tags/SAR/"},{"name":"lombok","slug":"lombok","permalink":"http://hgko1207.github.io/tags/lombok/"},{"name":"광학 위성","slug":"광학-위성","permalink":"http://hgko1207.github.io/tags/%EA%B4%91%ED%95%99-%EC%9C%84%EC%84%B1/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://hgko1207.github.io/tags/Refactoring/"},{"name":"리팩토링","slug":"리팩토링","permalink":"http://hgko1207.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"},{"name":"Openlayers","slug":"Openlayers","permalink":"http://hgko1207.github.io/tags/Openlayers/"},{"name":"CesiumJS","slug":"CesiumJS","permalink":"http://hgko1207.github.io/tags/CesiumJS/"},{"name":"3D","slug":"3D","permalink":"http://hgko1207.github.io/tags/3D/"},{"name":"Cesium","slug":"Cesium","permalink":"http://hgko1207.github.io/tags/Cesium/"},{"name":"Growth","slug":"Growth","permalink":"http://hgko1207.github.io/tags/Growth/"},{"name":"Design","slug":"Design","permalink":"http://hgko1207.github.io/tags/Design/"},{"name":"React UI","slug":"React-UI","permalink":"http://hgko1207.github.io/tags/React-UI/"},{"name":"UI Library","slug":"UI-Library","permalink":"http://hgko1207.github.io/tags/UI-Library/"},{"name":"Coordinate System","slug":"Coordinate-System","permalink":"http://hgko1207.github.io/tags/Coordinate-System/"},{"name":"PROJ.4","slug":"PROJ-4","permalink":"http://hgko1207.github.io/tags/PROJ-4/"},{"name":"EPSG","slug":"EPSG","permalink":"http://hgko1207.github.io/tags/EPSG/"},{"name":"Gdal","slug":"Gdal","permalink":"http://hgko1207.github.io/tags/Gdal/"},{"name":"Geocoder","slug":"Geocoder","permalink":"http://hgko1207.github.io/tags/Geocoder/"},{"name":"위도","slug":"위도","permalink":"http://hgko1207.github.io/tags/%EC%9C%84%EB%8F%84/"},{"name":"경도","slug":"경도","permalink":"http://hgko1207.github.io/tags/%EA%B2%BD%EB%8F%84/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://hgko1207.github.io/tags/Spring-Framework/"},{"name":"AOP","slug":"AOP","permalink":"http://hgko1207.github.io/tags/AOP/"},{"name":"domain","slug":"domain","permalink":"http://hgko1207.github.io/tags/domain/"},{"name":"com","slug":"com","permalink":"http://hgko1207.github.io/tags/com/"},{"name":"net","slug":"net","permalink":"http://hgko1207.github.io/tags/net/"},{"name":"co.kr","slug":"co-kr","permalink":"http://hgko1207.github.io/tags/co-kr/"},{"name":"Repository","slug":"Repository","permalink":"http://hgko1207.github.io/tags/Repository/"},{"name":"gitignore","slug":"gitignore","permalink":"http://hgko1207.github.io/tags/gitignore/"},{"name":"Study","slug":"Study","permalink":"http://hgko1207.github.io/tags/Study/"},{"name":"ES6","slug":"ES6","permalink":"http://hgko1207.github.io/tags/ES6/"},{"name":"Address","slug":"Address","permalink":"http://hgko1207.github.io/tags/Address/"},{"name":"Daum 우편번호","slug":"Daum-우편번호","permalink":"http://hgko1207.github.io/tags/Daum-%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8/"},{"name":"kakao","slug":"kakao","permalink":"http://hgko1207.github.io/tags/kakao/"},{"name":"우편번호 서비스","slug":"우편번호-서비스","permalink":"http://hgko1207.github.io/tags/%EC%9A%B0%ED%8E%B8%EB%B2%88%ED%98%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Hypen","slug":"Hypen","permalink":"http://hgko1207.github.io/tags/Hypen/"},{"name":"input","slug":"input","permalink":"http://hgko1207.github.io/tags/input/"},{"name":"전화번호","slug":"전화번호","permalink":"http://hgko1207.github.io/tags/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8/"},{"name":"EGit","slug":"EGit","permalink":"http://hgko1207.github.io/tags/EGit/"},{"name":"Expo","slug":"Expo","permalink":"http://hgko1207.github.io/tags/Expo/"},{"name":"Expo Cli","slug":"Expo-Cli","permalink":"http://hgko1207.github.io/tags/Expo-Cli/"},{"name":"WFP","slug":"WFP","permalink":"http://hgko1207.github.io/tags/WFP/"},{"name":"VSCode","slug":"VSCode","permalink":"http://hgko1207.github.io/tags/VSCode/"},{"name":"Live Reload","slug":"Live-Reload","permalink":"http://hgko1207.github.io/tags/Live-Reload/"},{"name":"Plugin","slug":"Plugin","permalink":"http://hgko1207.github.io/tags/Plugin/"},{"name":"DNS","slug":"DNS","permalink":"http://hgko1207.github.io/tags/DNS/"},{"name":"도메인","slug":"도메인","permalink":"http://hgko1207.github.io/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"Domain","slug":"Domain","permalink":"http://hgko1207.github.io/tags/Domain/"},{"name":"Jpa","slug":"Jpa","permalink":"http://hgko1207.github.io/tags/Jpa/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://hgko1207.github.io/tags/Hibernate/"},{"name":"Annotation","slug":"Annotation","permalink":"http://hgko1207.github.io/tags/Annotation/"},{"name":"Tab","slug":"Tab","permalink":"http://hgko1207.github.io/tags/Tab/"},{"name":"Chart","slug":"Chart","permalink":"http://hgko1207.github.io/tags/Chart/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hgko1207.github.io/tags/AngularJS/"},{"name":"Angular 강좌","slug":"Angular-강좌","permalink":"http://hgko1207.github.io/tags/Angular-%EA%B0%95%EC%A2%8C/"},{"name":"Metronic","slug":"Metronic","permalink":"http://hgko1207.github.io/tags/Metronic/"},{"name":"Dashboard Template","slug":"Dashboard-Template","permalink":"http://hgko1207.github.io/tags/Dashboard-Template/"}]}